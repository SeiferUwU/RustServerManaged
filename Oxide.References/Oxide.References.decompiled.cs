#define TRACE
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Net.Security;
using System.Net.Sockets;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Runtime.Serialization.Formatters.Binary;
using System.Security;
using System.Security.Authentication;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Permissions;
using System.Security.Principal;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Timers;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Serialization;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Metadata;
using Mono.Cecil.PE;
using Mono.Collections.Generic;
using Mono.Posix;
using Mono.Security.Cryptography;
using Mono.Unix;
using Mono.Unix.Native;
using Newtonsoft.Json.Bson;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Linq.JsonPath;
using Newtonsoft.Json.Serialization;
using Newtonsoft.Json.Shims;
using Newtonsoft.Json.Utilities;
using ProtoBuf.Compiler;
using ProtoBuf.Meta;
using ProtoBuf.Serializers;
using UnityEngine;
using WebSocketSharp.Net;
using WebSocketSharp.Net.WebSockets;
using WebSocketSharp.Server;

[assembly: AssemblyCompany("Oxide Team and Contributors")]
[assembly: AssemblyConfiguration("Release")]
[assembly: AssemblyCopyright("(c) 2013-2022 Oxide Team and Contributors")]
[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyProduct("Oxide.References")]
[assembly: AssemblyTitle("Oxide.References")]
[assembly: AssemblyMetadata("RepositoryUrl", "https://github.com/OxideMod/Oxide.References")]
[assembly: AssemblyDescription("Dependency references for the Oxide modding framework")]
[assembly: AssemblyFileVersion("2.0.3780.0")]
[assembly: AssemblyInformationalVersion("2.0.3780")]
[assembly: AssemblyVersion("2.0.3780.0")]
namespace Mono
{
	internal static class Empty<T>
	{
		public static readonly T[] Array = new T[0];
	}
}
namespace Mono.Security.Cryptography
{
	internal static class CryptoConvert
	{
		private static int ToInt32LE(byte[] bytes, int offset)
		{
			return (bytes[offset + 3] << 24) | (bytes[offset + 2] << 16) | (bytes[offset + 1] << 8) | bytes[offset];
		}

		private static uint ToUInt32LE(byte[] bytes, int offset)
		{
			return (uint)((bytes[offset + 3] << 24) | (bytes[offset + 2] << 16) | (bytes[offset + 1] << 8) | bytes[offset]);
		}

		private static byte[] Trim(byte[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] != 0)
				{
					byte[] array2 = new byte[array.Length - i];
					Buffer.BlockCopy(array, i, array2, 0, array2.Length);
					return array2;
				}
			}
			return null;
		}

		private static RSA FromCapiPrivateKeyBlob(byte[] blob, int offset)
		{
			RSAParameters parameters = default(RSAParameters);
			try
			{
				if (blob[offset] != 7 || blob[offset + 1] != 2 || blob[offset + 2] != 0 || blob[offset + 3] != 0 || ToUInt32LE(blob, offset + 8) != 843141970)
				{
					throw new CryptographicException("Invalid blob header");
				}
				int num = ToInt32LE(blob, offset + 12);
				byte[] array = new byte[4];
				Buffer.BlockCopy(blob, offset + 16, array, 0, 4);
				Array.Reverse((Array)array);
				parameters.Exponent = Trim(array);
				int num2 = offset + 20;
				int num3 = num >> 3;
				parameters.Modulus = new byte[num3];
				Buffer.BlockCopy(blob, num2, parameters.Modulus, 0, num3);
				Array.Reverse((Array)parameters.Modulus);
				num2 += num3;
				int num4 = num3 >> 1;
				parameters.P = new byte[num4];
				Buffer.BlockCopy(blob, num2, parameters.P, 0, num4);
				Array.Reverse((Array)parameters.P);
				num2 += num4;
				parameters.Q = new byte[num4];
				Buffer.BlockCopy(blob, num2, parameters.Q, 0, num4);
				Array.Reverse((Array)parameters.Q);
				num2 += num4;
				parameters.DP = new byte[num4];
				Buffer.BlockCopy(blob, num2, parameters.DP, 0, num4);
				Array.Reverse((Array)parameters.DP);
				num2 += num4;
				parameters.DQ = new byte[num4];
				Buffer.BlockCopy(blob, num2, parameters.DQ, 0, num4);
				Array.Reverse((Array)parameters.DQ);
				num2 += num4;
				parameters.InverseQ = new byte[num4];
				Buffer.BlockCopy(blob, num2, parameters.InverseQ, 0, num4);
				Array.Reverse((Array)parameters.InverseQ);
				num2 += num4;
				parameters.D = new byte[num3];
				if (num2 + num3 + offset <= blob.Length)
				{
					Buffer.BlockCopy(blob, num2, parameters.D, 0, num3);
					Array.Reverse((Array)parameters.D);
				}
			}
			catch (Exception inner)
			{
				throw new CryptographicException("Invalid blob.", inner);
			}
			RSA rSA = null;
			try
			{
				rSA = RSA.Create();
				rSA.ImportParameters(parameters);
			}
			catch (CryptographicException)
			{
				bool flag = false;
				try
				{
					rSA = new RSACryptoServiceProvider(new CspParameters
					{
						Flags = CspProviderFlags.UseMachineKeyStore
					});
					rSA.ImportParameters(parameters);
				}
				catch
				{
					flag = true;
				}
				if (flag)
				{
					throw;
				}
			}
			return rSA;
		}

		private static RSA FromCapiPublicKeyBlob(byte[] blob, int offset)
		{
			try
			{
				if (blob[offset] != 6 || blob[offset + 1] != 2 || blob[offset + 2] != 0 || blob[offset + 3] != 0 || ToUInt32LE(blob, offset + 8) != 826364754)
				{
					throw new CryptographicException("Invalid blob header");
				}
				int num = ToInt32LE(blob, offset + 12);
				RSAParameters parameters = new RSAParameters
				{
					Exponent = new byte[3]
				};
				parameters.Exponent[0] = blob[offset + 18];
				parameters.Exponent[1] = blob[offset + 17];
				parameters.Exponent[2] = blob[offset + 16];
				int srcOffset = offset + 20;
				int num2 = num >> 3;
				parameters.Modulus = new byte[num2];
				Buffer.BlockCopy(blob, srcOffset, parameters.Modulus, 0, num2);
				Array.Reverse((Array)parameters.Modulus);
				RSA rSA = null;
				try
				{
					rSA = RSA.Create();
					rSA.ImportParameters(parameters);
				}
				catch (CryptographicException)
				{
					rSA = new RSACryptoServiceProvider(new CspParameters
					{
						Flags = CspProviderFlags.UseMachineKeyStore
					});
					rSA.ImportParameters(parameters);
				}
				return rSA;
			}
			catch (Exception inner)
			{
				throw new CryptographicException("Invalid blob.", inner);
			}
		}

		public static RSA FromCapiKeyBlob(byte[] blob)
		{
			return FromCapiKeyBlob(blob, 0);
		}

		public static RSA FromCapiKeyBlob(byte[] blob, int offset)
		{
			if (blob == null)
			{
				throw new ArgumentNullException("blob");
			}
			if (offset >= blob.Length)
			{
				throw new ArgumentException("blob is too small.");
			}
			switch (blob[offset])
			{
			case 0:
				if (blob[offset + 12] == 6)
				{
					return FromCapiPublicKeyBlob(blob, offset + 12);
				}
				break;
			case 6:
				return FromCapiPublicKeyBlob(blob, offset);
			case 7:
				return FromCapiPrivateKeyBlob(blob, offset);
			}
			throw new CryptographicException("Unknown blob format.");
		}
	}
}
namespace Mono.Collections.Generic
{
	public class Collection<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection
	{
		public struct Enumerator : IEnumerator<T>, IDisposable, IEnumerator
		{
			private Collection<T> collection;

			private T current;

			private int next;

			private readonly int version;

			public T Current => current;

			object IEnumerator.Current
			{
				get
				{
					CheckState();
					if (next <= 0)
					{
						throw new InvalidOperationException();
					}
					return current;
				}
			}

			internal Enumerator(Collection<T> collection)
			{
				this = default(Enumerator);
				this.collection = collection;
				version = collection.version;
			}

			public bool MoveNext()
			{
				CheckState();
				if (next < 0)
				{
					return false;
				}
				if (next < collection.size)
				{
					current = collection.items[next++];
					return true;
				}
				next = -1;
				return false;
			}

			public void Reset()
			{
				CheckState();
				next = 0;
			}

			private void CheckState()
			{
				if (collection == null)
				{
					throw new ObjectDisposedException(GetType().FullName);
				}
				if (version != collection.version)
				{
					throw new InvalidOperationException();
				}
			}

			public void Dispose()
			{
				collection = null;
			}
		}

		internal T[] items;

		internal int size;

		private int version;

		public int Count => size;

		public T this[int index]
		{
			get
			{
				if (index >= size)
				{
					throw new ArgumentOutOfRangeException();
				}
				return items[index];
			}
			set
			{
				CheckIndex(index);
				if (index == size)
				{
					throw new ArgumentOutOfRangeException();
				}
				OnSet(value, index);
				items[index] = value;
			}
		}

		public int Capacity
		{
			get
			{
				return items.Length;
			}
			set
			{
				if (value < 0 || value < size)
				{
					throw new ArgumentOutOfRangeException();
				}
				Resize(value);
			}
		}

		bool ICollection<T>.IsReadOnly => false;

		bool IList.IsFixedSize => false;

		bool IList.IsReadOnly => false;

		object IList.this[int index]
		{
			get
			{
				return this[index];
			}
			set
			{
				CheckIndex(index);
				try
				{
					this[index] = (T)value;
					return;
				}
				catch (InvalidCastException)
				{
				}
				catch (NullReferenceException)
				{
				}
				throw new ArgumentException();
			}
		}

		int ICollection.Count => Count;

		bool ICollection.IsSynchronized => false;

		object ICollection.SyncRoot => this;

		public Collection()
		{
			items = Empty<T>.Array;
		}

		public Collection(int capacity)
		{
			if (capacity < 0)
			{
				throw new ArgumentOutOfRangeException();
			}
			items = new T[capacity];
		}

		public Collection(ICollection<T> items)
		{
			if (items == null)
			{
				throw new ArgumentNullException("items");
			}
			this.items = new T[items.Count];
			items.CopyTo(this.items, 0);
			size = this.items.Length;
		}

		public void Add(T item)
		{
			if (size == items.Length)
			{
				Grow(1);
			}
			OnAdd(item, size);
			items[size++] = item;
			version++;
		}

		public bool Contains(T item)
		{
			return IndexOf(item) != -1;
		}

		public int IndexOf(T item)
		{
			return Array.IndexOf(items, item, 0, size);
		}

		public void Insert(int index, T item)
		{
			CheckIndex(index);
			if (size == items.Length)
			{
				Grow(1);
			}
			OnInsert(item, index);
			Shift(index, 1);
			items[index] = item;
			version++;
		}

		public void RemoveAt(int index)
		{
			if (index < 0 || index >= size)
			{
				throw new ArgumentOutOfRangeException();
			}
			T item = items[index];
			OnRemove(item, index);
			Shift(index, -1);
			Array.Clear(items, size, 1);
			version++;
		}

		public bool Remove(T item)
		{
			int num = IndexOf(item);
			if (num == -1)
			{
				return false;
			}
			OnRemove(item, num);
			Shift(num, -1);
			Array.Clear(items, size, 1);
			version++;
			return true;
		}

		public void Clear()
		{
			OnClear();
			Array.Clear(items, 0, size);
			size = 0;
			version++;
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			Array.Copy(items, 0, array, arrayIndex, size);
		}

		public T[] ToArray()
		{
			T[] array = new T[size];
			Array.Copy(items, 0, array, 0, size);
			return array;
		}

		private void CheckIndex(int index)
		{
			if (index < 0 || index > size)
			{
				throw new ArgumentOutOfRangeException();
			}
		}

		private void Shift(int start, int delta)
		{
			if (delta < 0)
			{
				start -= delta;
			}
			if (start < size)
			{
				Array.Copy(items, start, items, start + delta, size - start);
			}
			size += delta;
			if (delta < 0)
			{
				Array.Clear(items, size, -delta);
			}
		}

		protected virtual void OnAdd(T item, int index)
		{
		}

		protected virtual void OnInsert(T item, int index)
		{
		}

		protected virtual void OnSet(T item, int index)
		{
		}

		protected virtual void OnRemove(T item, int index)
		{
		}

		protected virtual void OnClear()
		{
		}

		internal virtual void Grow(int desired)
		{
			int num = size + desired;
			if (num > items.Length)
			{
				num = System.Math.Max(System.Math.Max(items.Length * 2, 4), num);
				Resize(num);
			}
		}

		protected void Resize(int new_size)
		{
			if (new_size != size)
			{
				if (new_size < size)
				{
					throw new ArgumentOutOfRangeException();
				}
				items = items.Resize(new_size);
			}
		}

		int IList.Add(object value)
		{
			try
			{
				Add((T)value);
				return size - 1;
			}
			catch (InvalidCastException)
			{
			}
			catch (NullReferenceException)
			{
			}
			throw new ArgumentException();
		}

		void IList.Clear()
		{
			Clear();
		}

		bool IList.Contains(object value)
		{
			return ((IList)this).IndexOf(value) > -1;
		}

		int IList.IndexOf(object value)
		{
			try
			{
				return IndexOf((T)value);
			}
			catch (InvalidCastException)
			{
			}
			catch (NullReferenceException)
			{
			}
			return -1;
		}

		void IList.Insert(int index, object value)
		{
			CheckIndex(index);
			try
			{
				Insert(index, (T)value);
				return;
			}
			catch (InvalidCastException)
			{
			}
			catch (NullReferenceException)
			{
			}
			throw new ArgumentException();
		}

		void IList.Remove(object value)
		{
			try
			{
				Remove((T)value);
			}
			catch (InvalidCastException)
			{
			}
			catch (NullReferenceException)
			{
			}
		}

		void IList.RemoveAt(int index)
		{
			RemoveAt(index);
		}

		void ICollection.CopyTo(Array array, int index)
		{
			Array.Copy(items, 0, array, index, size);
		}

		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return new Enumerator(this);
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			return new Enumerator(this);
		}
	}
	public sealed class ReadOnlyCollection<T> : Collection<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection
	{
		private static ReadOnlyCollection<T> empty;

		public static ReadOnlyCollection<T> Empty => empty ?? (empty = new ReadOnlyCollection<T>());

		bool ICollection<T>.IsReadOnly => true;

		bool IList.IsFixedSize => true;

		bool IList.IsReadOnly => true;

		private ReadOnlyCollection()
		{
		}

		public ReadOnlyCollection(T[] array)
		{
			if (array == null)
			{
				throw new ArgumentNullException();
			}
			Initialize(array, array.Length);
		}

		public ReadOnlyCollection(Collection<T> collection)
		{
			if (collection == null)
			{
				throw new ArgumentNullException();
			}
			Initialize(collection.items, collection.size);
		}

		private void Initialize(T[] items, int size)
		{
			base.items = new T[size];
			Array.Copy(items, 0, base.items, 0, size);
			base.size = size;
		}

		internal override void Grow(int desired)
		{
			throw new InvalidOperationException();
		}

		protected override void OnAdd(T item, int index)
		{
			throw new InvalidOperationException();
		}

		protected override void OnClear()
		{
			throw new InvalidOperationException();
		}

		protected override void OnInsert(T item, int index)
		{
			throw new InvalidOperationException();
		}

		protected override void OnRemove(T item, int index)
		{
			throw new InvalidOperationException();
		}

		protected override void OnSet(T item, int index)
		{
			throw new InvalidOperationException();
		}
	}
}
namespace Mono.Cecil
{
	public struct MetadataToken
	{
		private readonly uint token;

		public static readonly MetadataToken Zero = new MetadataToken(0u);

		public uint RID => token & 0xFFFFFF;

		public TokenType TokenType => (TokenType)(token & 0xFF000000u);

		public MetadataToken(uint token)
		{
			this.token = token;
		}

		public MetadataToken(TokenType type)
			: this(type, 0)
		{
		}

		public MetadataToken(TokenType type, uint rid)
		{
			token = (uint)type | rid;
		}

		public MetadataToken(TokenType type, int rid)
		{
			token = (uint)type | (uint)rid;
		}

		public int ToInt32()
		{
			return (int)token;
		}

		public uint ToUInt32()
		{
			return token;
		}

		public override int GetHashCode()
		{
			return (int)token;
		}

		public override bool Equals(object obj)
		{
			if (obj is MetadataToken)
			{
				return ((MetadataToken)obj).token == token;
			}
			return false;
		}

		public static bool operator ==(MetadataToken one, MetadataToken other)
		{
			return one.token == other.token;
		}

		public static bool operator !=(MetadataToken one, MetadataToken other)
		{
			return one.token != other.token;
		}

		public override string ToString()
		{
			return string.Format("[{0}:0x{1}]", TokenType, RID.ToString("x4"));
		}
	}
	public enum TokenType : uint
	{
		Module = 0u,
		TypeRef = 16777216u,
		TypeDef = 33554432u,
		Field = 67108864u,
		Method = 100663296u,
		Param = 134217728u,
		InterfaceImpl = 150994944u,
		MemberRef = 167772160u,
		CustomAttribute = 201326592u,
		Permission = 234881024u,
		Signature = 285212672u,
		Event = 335544320u,
		Property = 385875968u,
		ModuleRef = 436207616u,
		TypeSpec = 452984832u,
		Assembly = 536870912u,
		AssemblyRef = 587202560u,
		File = 637534208u,
		ExportedType = 654311424u,
		ManifestResource = 671088640u,
		GenericParam = 704643072u,
		MethodSpec = 721420288u,
		String = 1879048192u
	}
	internal static class Mixin
	{
		internal static object NoValue = new object();

		internal static object NotResolved = new object();

		public const int NotResolvedMarker = -2;

		public const int NoDataMarker = -1;

		public static uint ReadCompressedUInt32(this byte[] data, ref int position)
		{
			uint result;
			if ((data[position] & 0x80) == 0)
			{
				result = data[position];
				position++;
			}
			else if ((data[position] & 0x40) == 0)
			{
				result = (uint)((data[position] & -129) << 8);
				result |= data[position + 1];
				position += 2;
			}
			else
			{
				result = (uint)((data[position] & -193) << 24);
				result |= (uint)(data[position + 1] << 16);
				result |= (uint)(data[position + 2] << 8);
				result |= data[position + 3];
				position += 4;
			}
			return result;
		}

		public static MetadataToken GetMetadataToken(this CodedIndex self, uint data)
		{
			uint rid;
			TokenType type;
			switch (self)
			{
			case CodedIndex.TypeDefOrRef:
				rid = data >> 2;
				switch (data & 3)
				{
				case 0u:
					break;
				case 1u:
					goto IL_0069;
				case 2u:
					goto IL_0074;
				default:
					goto end_IL_0001;
				}
				type = TokenType.TypeDef;
				goto IL_03fb;
			case CodedIndex.HasConstant:
				rid = data >> 2;
				switch (data & 3)
				{
				case 0u:
					break;
				case 1u:
					goto IL_00a9;
				case 2u:
					goto IL_00b4;
				default:
					goto end_IL_0001;
				}
				type = TokenType.Field;
				goto IL_03fb;
			case CodedIndex.HasCustomAttribute:
				rid = data >> 5;
				switch (data & 0x1F)
				{
				case 0u:
					break;
				case 1u:
					goto IL_012e;
				case 2u:
					goto IL_0139;
				case 3u:
					goto IL_0144;
				case 4u:
					goto IL_014f;
				case 5u:
					goto IL_015a;
				case 6u:
					goto IL_0165;
				case 7u:
					goto IL_0170;
				case 8u:
					goto IL_0177;
				case 9u:
					goto IL_0182;
				case 10u:
					goto IL_018d;
				case 11u:
					goto IL_0198;
				case 12u:
					goto IL_01a3;
				case 13u:
					goto IL_01ae;
				case 14u:
					goto IL_01b9;
				case 15u:
					goto IL_01c4;
				case 16u:
					goto IL_01cf;
				case 17u:
					goto IL_01da;
				case 18u:
					goto IL_01e5;
				case 19u:
					goto IL_01f0;
				default:
					goto end_IL_0001;
				}
				type = TokenType.Method;
				goto IL_03fb;
			case CodedIndex.HasFieldMarshal:
			{
				rid = data >> 1;
				uint num = data & 1;
				if (num != 0)
				{
					if (num != 1)
					{
						break;
					}
					type = TokenType.Param;
				}
				else
				{
					type = TokenType.Field;
				}
				goto IL_03fb;
			}
			case CodedIndex.HasDeclSecurity:
				rid = data >> 2;
				switch (data & 3)
				{
				case 0u:
					break;
				case 1u:
					goto IL_024f;
				case 2u:
					goto IL_025a;
				default:
					goto end_IL_0001;
				}
				type = TokenType.TypeDef;
				goto IL_03fb;
			case CodedIndex.MemberRefParent:
				rid = data >> 3;
				switch (data & 7)
				{
				case 0u:
					break;
				case 1u:
					goto IL_0297;
				case 2u:
					goto IL_02a2;
				case 3u:
					goto IL_02ad;
				case 4u:
					goto IL_02b8;
				default:
					goto end_IL_0001;
				}
				type = TokenType.TypeDef;
				goto IL_03fb;
			case CodedIndex.HasSemantics:
			{
				rid = data >> 1;
				uint num = data & 1;
				if (num != 0)
				{
					if (num != 1)
					{
						break;
					}
					type = TokenType.Property;
				}
				else
				{
					type = TokenType.Event;
				}
				goto IL_03fb;
			}
			case CodedIndex.MethodDefOrRef:
			{
				rid = data >> 1;
				uint num = data & 1;
				if (num != 0)
				{
					if (num != 1)
					{
						break;
					}
					type = TokenType.MemberRef;
				}
				else
				{
					type = TokenType.Method;
				}
				goto IL_03fb;
			}
			case CodedIndex.MemberForwarded:
			{
				rid = data >> 1;
				uint num = data & 1;
				if (num != 0)
				{
					if (num != 1)
					{
						break;
					}
					type = TokenType.Method;
				}
				else
				{
					type = TokenType.Field;
				}
				goto IL_03fb;
			}
			case CodedIndex.Implementation:
				rid = data >> 2;
				switch (data & 3)
				{
				case 0u:
					break;
				case 1u:
					goto IL_036b;
				case 2u:
					goto IL_0376;
				default:
					goto end_IL_0001;
				}
				type = TokenType.File;
				goto IL_03fb;
			case CodedIndex.CustomAttributeType:
			{
				rid = data >> 3;
				uint num = data & 7;
				if (num != 2)
				{
					if (num != 3)
					{
						break;
					}
					type = TokenType.MemberRef;
				}
				else
				{
					type = TokenType.Method;
				}
				goto IL_03fb;
			}
			case CodedIndex.ResolutionScope:
				rid = data >> 2;
				switch (data & 3)
				{
				case 0u:
					break;
				case 1u:
					goto IL_03c4;
				case 2u:
					goto IL_03cc;
				case 3u:
					goto IL_03d4;
				default:
					goto end_IL_0001;
				}
				type = TokenType.Module;
				goto IL_03fb;
			case CodedIndex.TypeOrMethodDef:
				{
					rid = data >> 1;
					uint num = data & 1;
					if (num != 0)
					{
						if (num != 1)
						{
							break;
						}
						type = TokenType.Method;
					}
					else
					{
						type = TokenType.TypeDef;
					}
					goto IL_03fb;
				}
				IL_01c4:
				type = TokenType.AssemblyRef;
				goto IL_03fb;
				IL_01ae:
				type = TokenType.TypeSpec;
				goto IL_03fb;
				IL_01b9:
				type = TokenType.Assembly;
				goto IL_03fb;
				IL_03d4:
				type = TokenType.TypeRef;
				goto IL_03fb;
				IL_03cc:
				type = TokenType.AssemblyRef;
				goto IL_03fb;
				IL_03c4:
				type = TokenType.ModuleRef;
				goto IL_03fb;
				IL_01a3:
				type = TokenType.ModuleRef;
				goto IL_03fb;
				IL_0198:
				type = TokenType.Signature;
				goto IL_03fb;
				IL_0182:
				type = TokenType.Property;
				goto IL_03fb;
				IL_018d:
				type = TokenType.Event;
				goto IL_03fb;
				IL_0376:
				type = TokenType.ExportedType;
				goto IL_03fb;
				IL_036b:
				type = TokenType.AssemblyRef;
				goto IL_03fb;
				IL_0177:
				type = TokenType.Permission;
				goto IL_03fb;
				IL_0170:
				type = TokenType.Module;
				goto IL_03fb;
				IL_015a:
				type = TokenType.InterfaceImpl;
				goto IL_03fb;
				IL_0165:
				type = TokenType.MemberRef;
				goto IL_03fb;
				IL_014f:
				type = TokenType.Param;
				goto IL_03fb;
				IL_0139:
				type = TokenType.TypeRef;
				goto IL_03fb;
				IL_0144:
				type = TokenType.TypeDef;
				goto IL_03fb;
				IL_012e:
				type = TokenType.Field;
				goto IL_03fb;
				IL_0069:
				type = TokenType.TypeRef;
				goto IL_03fb;
				IL_02b8:
				type = TokenType.TypeSpec;
				goto IL_03fb;
				IL_02ad:
				type = TokenType.Method;
				goto IL_03fb;
				IL_02a2:
				type = TokenType.ModuleRef;
				goto IL_03fb;
				IL_0297:
				type = TokenType.TypeRef;
				goto IL_03fb;
				IL_00b4:
				type = TokenType.Property;
				goto IL_03fb;
				IL_025a:
				type = TokenType.Assembly;
				goto IL_03fb;
				IL_024f:
				type = TokenType.Method;
				goto IL_03fb;
				IL_00a9:
				type = TokenType.Param;
				goto IL_03fb;
				IL_03fb:
				return new MetadataToken(type, rid);
				IL_0074:
				type = TokenType.TypeSpec;
				goto IL_03fb;
				IL_01f0:
				type = TokenType.GenericParam;
				goto IL_03fb;
				IL_01e5:
				type = TokenType.ManifestResource;
				goto IL_03fb;
				IL_01da:
				type = TokenType.ExportedType;
				goto IL_03fb;
				IL_01cf:
				type = TokenType.File;
				goto IL_03fb;
				end_IL_0001:
				break;
			}
			return MetadataToken.Zero;
		}

		public static uint CompressMetadataToken(this CodedIndex self, MetadataToken token)
		{
			uint result = 0u;
			if (token.RID == 0)
			{
				return result;
			}
			switch (self)
			{
			case CodedIndex.TypeDefOrRef:
				result = token.RID << 2;
				switch (token.TokenType)
				{
				case TokenType.TypeDef:
					return result | 0;
				case TokenType.TypeRef:
					return result | 1;
				case TokenType.TypeSpec:
					return result | 2;
				}
				break;
			case CodedIndex.HasConstant:
				result = token.RID << 2;
				switch (token.TokenType)
				{
				case TokenType.Field:
					return result | 0;
				case TokenType.Param:
					return result | 1;
				case TokenType.Property:
					return result | 2;
				}
				break;
			case CodedIndex.HasCustomAttribute:
				result = token.RID << 5;
				switch (token.TokenType)
				{
				case TokenType.Method:
					return result | 0;
				case TokenType.Field:
					return result | 1;
				case TokenType.TypeRef:
					return result | 2;
				case TokenType.TypeDef:
					return result | 3;
				case TokenType.Param:
					return result | 4;
				case TokenType.InterfaceImpl:
					return result | 5;
				case TokenType.MemberRef:
					return result | 6;
				case TokenType.Module:
					return result | 7;
				case TokenType.Permission:
					return result | 8;
				case TokenType.Property:
					return result | 9;
				case TokenType.Event:
					return result | 0xA;
				case TokenType.Signature:
					return result | 0xB;
				case TokenType.ModuleRef:
					return result | 0xC;
				case TokenType.TypeSpec:
					return result | 0xD;
				case TokenType.Assembly:
					return result | 0xE;
				case TokenType.AssemblyRef:
					return result | 0xF;
				case TokenType.File:
					return result | 0x10;
				case TokenType.ExportedType:
					return result | 0x11;
				case TokenType.ManifestResource:
					return result | 0x12;
				case TokenType.GenericParam:
					return result | 0x13;
				}
				break;
			case CodedIndex.HasFieldMarshal:
				result = token.RID << 1;
				switch (token.TokenType)
				{
				case TokenType.Field:
					return result | 0;
				case TokenType.Param:
					return result | 1;
				}
				break;
			case CodedIndex.HasDeclSecurity:
				result = token.RID << 2;
				switch (token.TokenType)
				{
				case TokenType.TypeDef:
					return result | 0;
				case TokenType.Method:
					return result | 1;
				case TokenType.Assembly:
					return result | 2;
				}
				break;
			case CodedIndex.MemberRefParent:
				result = token.RID << 3;
				switch (token.TokenType)
				{
				case TokenType.TypeDef:
					return result | 0;
				case TokenType.TypeRef:
					return result | 1;
				case TokenType.ModuleRef:
					return result | 2;
				case TokenType.Method:
					return result | 3;
				case TokenType.TypeSpec:
					return result | 4;
				}
				break;
			case CodedIndex.HasSemantics:
				result = token.RID << 1;
				switch (token.TokenType)
				{
				case TokenType.Event:
					return result | 0;
				case TokenType.Property:
					return result | 1;
				}
				break;
			case CodedIndex.MethodDefOrRef:
				result = token.RID << 1;
				switch (token.TokenType)
				{
				case TokenType.Method:
					return result | 0;
				case TokenType.MemberRef:
					return result | 1;
				}
				break;
			case CodedIndex.MemberForwarded:
				result = token.RID << 1;
				switch (token.TokenType)
				{
				case TokenType.Field:
					return result | 0;
				case TokenType.Method:
					return result | 1;
				}
				break;
			case CodedIndex.Implementation:
				result = token.RID << 2;
				switch (token.TokenType)
				{
				case TokenType.File:
					return result | 0;
				case TokenType.AssemblyRef:
					return result | 1;
				case TokenType.ExportedType:
					return result | 2;
				}
				break;
			case CodedIndex.CustomAttributeType:
				result = token.RID << 3;
				switch (token.TokenType)
				{
				case TokenType.Method:
					return result | 2;
				case TokenType.MemberRef:
					return result | 3;
				}
				break;
			case CodedIndex.ResolutionScope:
				result = token.RID << 2;
				switch (token.TokenType)
				{
				case TokenType.Module:
					return result | 0;
				case TokenType.ModuleRef:
					return result | 1;
				case TokenType.AssemblyRef:
					return result | 2;
				case TokenType.TypeRef:
					return result | 3;
				}
				break;
			case CodedIndex.TypeOrMethodDef:
				result = token.RID << 1;
				switch (token.TokenType)
				{
				case TokenType.TypeDef:
					return result | 0;
				case TokenType.Method:
					return result | 1;
				}
				break;
			}
			throw new ArgumentException();
		}

		public static int GetSize(this CodedIndex self, Func<Table, int> counter)
		{
			int num;
			Table[] array;
			switch (self)
			{
			case CodedIndex.TypeDefOrRef:
				num = 2;
				array = new Table[3]
				{
					Table.TypeDef,
					Table.TypeRef,
					Table.TypeSpec
				};
				break;
			case CodedIndex.HasConstant:
				num = 2;
				array = new Table[3]
				{
					Table.Field,
					Table.Param,
					Table.Property
				};
				break;
			case CodedIndex.HasCustomAttribute:
				num = 5;
				array = new Table[20]
				{
					Table.Method,
					Table.Field,
					Table.TypeRef,
					Table.TypeDef,
					Table.Param,
					Table.InterfaceImpl,
					Table.MemberRef,
					Table.Module,
					Table.DeclSecurity,
					Table.Property,
					Table.Event,
					Table.StandAloneSig,
					Table.ModuleRef,
					Table.TypeSpec,
					Table.Assembly,
					Table.AssemblyRef,
					Table.File,
					Table.ExportedType,
					Table.ManifestResource,
					Table.GenericParam
				};
				break;
			case CodedIndex.HasFieldMarshal:
				num = 1;
				array = new Table[2]
				{
					Table.Field,
					Table.Param
				};
				break;
			case CodedIndex.HasDeclSecurity:
				num = 2;
				array = new Table[3]
				{
					Table.TypeDef,
					Table.Method,
					Table.Assembly
				};
				break;
			case CodedIndex.MemberRefParent:
				num = 3;
				array = new Table[5]
				{
					Table.TypeDef,
					Table.TypeRef,
					Table.ModuleRef,
					Table.Method,
					Table.TypeSpec
				};
				break;
			case CodedIndex.HasSemantics:
				num = 1;
				array = new Table[2]
				{
					Table.Event,
					Table.Property
				};
				break;
			case CodedIndex.MethodDefOrRef:
				num = 1;
				array = new Table[2]
				{
					Table.Method,
					Table.MemberRef
				};
				break;
			case CodedIndex.MemberForwarded:
				num = 1;
				array = new Table[2]
				{
					Table.Field,
					Table.Method
				};
				break;
			case CodedIndex.Implementation:
				num = 2;
				array = new Table[3]
				{
					Table.File,
					Table.AssemblyRef,
					Table.ExportedType
				};
				break;
			case CodedIndex.CustomAttributeType:
				num = 3;
				array = new Table[2]
				{
					Table.Method,
					Table.MemberRef
				};
				break;
			case CodedIndex.ResolutionScope:
				num = 2;
				array = new Table[4]
				{
					Table.Module,
					Table.ModuleRef,
					Table.AssemblyRef,
					Table.TypeRef
				};
				break;
			case CodedIndex.TypeOrMethodDef:
				num = 1;
				array = new Table[2]
				{
					Table.TypeDef,
					Table.Method
				};
				break;
			default:
				throw new ArgumentException();
			}
			int num2 = 0;
			for (int i = 0; i < array.Length; i++)
			{
				num2 = System.Math.Max(counter(array[i]), num2);
			}
			if (num2 >= 1 << 16 - num)
			{
				return 4;
			}
			return 2;
		}

		public static bool GetHasSecurityDeclarations(this ISecurityDeclarationProvider self, ModuleDefinition module)
		{
			if (module.HasImage())
			{
				return module.Read(self, (ISecurityDeclarationProvider provider, MetadataReader reader) => reader.HasSecurityDeclarations(provider));
			}
			return false;
		}

		public static Mono.Collections.Generic.Collection<SecurityDeclaration> GetSecurityDeclarations(this ISecurityDeclarationProvider self, ref Mono.Collections.Generic.Collection<SecurityDeclaration> variable, ModuleDefinition module)
		{
			if (!module.HasImage())
			{
				return variable = new Mono.Collections.Generic.Collection<SecurityDeclaration>();
			}
			return module.Read(ref variable, self, (ISecurityDeclarationProvider provider, MetadataReader reader) => reader.ReadSecurityDeclarations(provider));
		}

		public static void CheckName(string name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			if (name.Length == 0)
			{
				throw new ArgumentException("Empty name");
			}
		}

		public static void ResolveConstant(this IConstantProvider self, ref object constant, ModuleDefinition module)
		{
			if (module == null)
			{
				constant = NoValue;
				return;
			}
			lock (module.SyncRoot)
			{
				if (constant != NotResolved)
				{
					return;
				}
				if (module.HasImage())
				{
					constant = module.Read(self, (IConstantProvider provider, MetadataReader reader) => reader.ReadConstant(provider));
				}
				else
				{
					constant = NoValue;
				}
			}
		}

		public static bool GetHasCustomAttributes(this ICustomAttributeProvider self, ModuleDefinition module)
		{
			if (module.HasImage())
			{
				return module.Read(self, (ICustomAttributeProvider provider, MetadataReader reader) => reader.HasCustomAttributes(provider));
			}
			return false;
		}

		public static Mono.Collections.Generic.Collection<CustomAttribute> GetCustomAttributes(this ICustomAttributeProvider self, ref Mono.Collections.Generic.Collection<CustomAttribute> variable, ModuleDefinition module)
		{
			if (!module.HasImage())
			{
				return variable = new Mono.Collections.Generic.Collection<CustomAttribute>();
			}
			return module.Read(ref variable, self, (ICustomAttributeProvider provider, MetadataReader reader) => reader.ReadCustomAttributes(provider));
		}

		public static bool ContainsGenericParameter(this IGenericInstance self)
		{
			Mono.Collections.Generic.Collection<TypeReference> genericArguments = self.GenericArguments;
			for (int i = 0; i < genericArguments.Count; i++)
			{
				if (genericArguments[i].ContainsGenericParameter)
				{
					return true;
				}
			}
			return false;
		}

		public static void GenericInstanceFullName(this IGenericInstance self, StringBuilder builder)
		{
			builder.Append("<");
			Mono.Collections.Generic.Collection<TypeReference> genericArguments = self.GenericArguments;
			for (int i = 0; i < genericArguments.Count; i++)
			{
				if (i > 0)
				{
					builder.Append(",");
				}
				builder.Append(genericArguments[i].FullName);
			}
			builder.Append(">");
		}

		public static bool GetHasGenericParameters(this IGenericParameterProvider self, ModuleDefinition module)
		{
			if (module.HasImage())
			{
				return module.Read(self, (IGenericParameterProvider provider, MetadataReader reader) => reader.HasGenericParameters(provider));
			}
			return false;
		}

		public static Mono.Collections.Generic.Collection<GenericParameter> GetGenericParameters(this IGenericParameterProvider self, ref Mono.Collections.Generic.Collection<GenericParameter> collection, ModuleDefinition module)
		{
			if (!module.HasImage())
			{
				return collection = new GenericParameterCollection(self);
			}
			return module.Read(ref collection, self, (IGenericParameterProvider provider, MetadataReader reader) => reader.ReadGenericParameters(provider));
		}

		public static bool GetHasMarshalInfo(this IMarshalInfoProvider self, ModuleDefinition module)
		{
			if (module.HasImage())
			{
				return module.Read(self, (IMarshalInfoProvider provider, MetadataReader reader) => reader.HasMarshalInfo(provider));
			}
			return false;
		}

		public static MarshalInfo GetMarshalInfo(this IMarshalInfoProvider self, ref MarshalInfo variable, ModuleDefinition module)
		{
			if (!module.HasImage())
			{
				return null;
			}
			return module.Read(ref variable, self, (IMarshalInfoProvider provider, MetadataReader reader) => reader.ReadMarshalInfo(provider));
		}

		public static void CheckModifier(TypeReference modifierType, TypeReference type)
		{
			if (modifierType == null)
			{
				throw new ArgumentNullException("modifierType");
			}
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
		}

		public static bool HasImplicitThis(this IMethodSignature self)
		{
			if (self.HasThis)
			{
				return !self.ExplicitThis;
			}
			return false;
		}

		public static void MethodSignatureFullName(this IMethodSignature self, StringBuilder builder)
		{
			builder.Append("(");
			if (self.HasParameters)
			{
				Mono.Collections.Generic.Collection<ParameterDefinition> parameters = self.Parameters;
				for (int i = 0; i < parameters.Count; i++)
				{
					ParameterDefinition parameterDefinition = parameters[i];
					if (i > 0)
					{
						builder.Append(",");
					}
					if (parameterDefinition.ParameterType.IsSentinel)
					{
						builder.Append("...,");
					}
					builder.Append(parameterDefinition.ParameterType.FullName);
				}
			}
			builder.Append(")");
		}

		public static bool GetAttributes(this uint self, uint attributes)
		{
			return (self & attributes) != 0;
		}

		public static uint SetAttributes(this uint self, uint attributes, bool value)
		{
			if (value)
			{
				return self | attributes;
			}
			return self & ~attributes;
		}

		public static bool GetMaskedAttributes(this uint self, uint mask, uint attributes)
		{
			return (self & mask) == attributes;
		}

		public static uint SetMaskedAttributes(this uint self, uint mask, uint attributes, bool value)
		{
			if (value)
			{
				self &= ~mask;
				return self | attributes;
			}
			return self & ~(mask & attributes);
		}

		public static bool GetAttributes(this ushort self, ushort attributes)
		{
			return (self & attributes) != 0;
		}

		public static ushort SetAttributes(this ushort self, ushort attributes, bool value)
		{
			if (value)
			{
				return (ushort)(self | attributes);
			}
			return (ushort)(self & ~attributes);
		}

		public static bool GetMaskedAttributes(this ushort self, ushort mask, uint attributes)
		{
			return (self & mask) == attributes;
		}

		public static ushort SetMaskedAttributes(this ushort self, ushort mask, uint attributes, bool value)
		{
			if (value)
			{
				self = (ushort)(self & ~mask);
				return (ushort)(self | attributes);
			}
			return (ushort)(self & ~(mask & attributes));
		}

		public static ParameterDefinition GetParameter(this Mono.Cecil.Cil.MethodBody self, int index)
		{
			MethodDefinition method = self.method;
			if (method.HasThis)
			{
				if (index == 0)
				{
					return self.ThisParameter;
				}
				index--;
			}
			Mono.Collections.Generic.Collection<ParameterDefinition> parameters = method.Parameters;
			if (index < 0 || index >= parameters.size)
			{
				return null;
			}
			return parameters[index];
		}

		public static VariableDefinition GetVariable(this Mono.Cecil.Cil.MethodBody self, int index)
		{
			Mono.Collections.Generic.Collection<VariableDefinition> variables = self.Variables;
			if (index < 0 || index >= variables.size)
			{
				return null;
			}
			return variables[index];
		}

		public static bool GetSemantics(this MethodDefinition self, MethodSemanticsAttributes semantics)
		{
			return (self.SemanticsAttributes & semantics) != 0;
		}

		public static void SetSemantics(this MethodDefinition self, MethodSemanticsAttributes semantics, bool value)
		{
			if (value)
			{
				self.SemanticsAttributes |= semantics;
			}
			else
			{
				self.SemanticsAttributes &= (MethodSemanticsAttributes)(ushort)(~(int)semantics);
			}
		}

		public static bool IsVarArg(this IMethodSignature self)
		{
			return (self.CallingConvention & MethodCallingConvention.VarArg) != 0;
		}

		public static int GetSentinelPosition(this IMethodSignature self)
		{
			if (!self.HasParameters)
			{
				return -1;
			}
			Mono.Collections.Generic.Collection<ParameterDefinition> parameters = self.Parameters;
			for (int i = 0; i < parameters.Count; i++)
			{
				if (parameters[i].ParameterType.IsSentinel)
				{
					return i;
				}
			}
			return -1;
		}

		public static void CheckParameters(object parameters)
		{
			if (parameters == null)
			{
				throw new ArgumentNullException("parameters");
			}
		}

		public static bool HasImage(this ModuleDefinition self)
		{
			return self?.HasImage ?? false;
		}

		public static bool IsCorlib(this ModuleDefinition module)
		{
			if (module.Assembly == null)
			{
				return false;
			}
			return module.Assembly.Name.Name == "mscorlib";
		}

		public static string GetFullyQualifiedName(this Stream self)
		{
			if (!(self is FileStream fileStream))
			{
				return string.Empty;
			}
			return Path.GetFullPath(fileStream.Name);
		}

		public static TargetRuntime ParseRuntime(this string self)
		{
			switch (self[1])
			{
			case '1':
				if (self[3] != '0')
				{
					return TargetRuntime.Net_1_1;
				}
				return TargetRuntime.Net_1_0;
			case '2':
				return TargetRuntime.Net_2_0;
			default:
				return TargetRuntime.Net_4_0;
			}
		}

		public static string RuntimeVersionString(this TargetRuntime runtime)
		{
			return runtime switch
			{
				TargetRuntime.Net_1_0 => "v1.0.3705", 
				TargetRuntime.Net_1_1 => "v1.1.4322", 
				TargetRuntime.Net_2_0 => "v2.0.50727", 
				_ => "v4.0.30319", 
			};
		}

		public static TypeReference GetEnumUnderlyingType(this TypeDefinition self)
		{
			Mono.Collections.Generic.Collection<FieldDefinition> fields = self.Fields;
			for (int i = 0; i < fields.Count; i++)
			{
				FieldDefinition fieldDefinition = fields[i];
				if (!fieldDefinition.IsStatic)
				{
					return fieldDefinition.FieldType;
				}
			}
			throw new ArgumentException();
		}

		public static TypeDefinition GetNestedType(this TypeDefinition self, string fullname)
		{
			if (!self.HasNestedTypes)
			{
				return null;
			}
			Mono.Collections.Generic.Collection<TypeDefinition> nestedTypes = self.NestedTypes;
			for (int i = 0; i < nestedTypes.Count; i++)
			{
				TypeDefinition typeDefinition = nestedTypes[i];
				if (typeDefinition.TypeFullName() == fullname)
				{
					return typeDefinition;
				}
			}
			return null;
		}

		public static bool IsPrimitive(this ElementType self)
		{
			switch (self)
			{
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.I:
			case ElementType.U:
				return true;
			default:
				return false;
			}
		}

		public static string TypeFullName(this TypeReference self)
		{
			if (!string.IsNullOrEmpty(self.Namespace))
			{
				return self.Namespace + "." + self.Name;
			}
			return self.Name;
		}

		public static bool IsTypeOf(this TypeReference self, string @namespace, string name)
		{
			if (self.Name == name)
			{
				return self.Namespace == @namespace;
			}
			return false;
		}

		public static bool IsTypeSpecification(this TypeReference type)
		{
			switch (type.etype)
			{
			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Var:
			case ElementType.Array:
			case ElementType.GenericInst:
			case ElementType.FnPtr:
			case ElementType.SzArray:
			case ElementType.MVar:
			case ElementType.CModReqD:
			case ElementType.CModOpt:
			case ElementType.Sentinel:
			case ElementType.Pinned:
				return true;
			default:
				return false;
			}
		}

		public static TypeDefinition CheckedResolve(this TypeReference self)
		{
			return self.Resolve() ?? throw new ResolutionException(self);
		}

		public static void CheckType(TypeReference type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
		}

		public static RSA CreateRSA(this StrongNameKeyPair key_pair)
		{
			if (!TryGetKeyContainer(key_pair, out var key, out var key_container))
			{
				return Mono.Security.Cryptography.CryptoConvert.FromCapiKeyBlob(key);
			}
			return new RSACryptoServiceProvider(new CspParameters
			{
				Flags = CspProviderFlags.UseMachineKeyStore,
				KeyContainerName = key_container,
				KeyNumber = 2
			});
		}

		private static bool TryGetKeyContainer(ISerializable key_pair, out byte[] key, out string key_container)
		{
			SerializationInfo serializationInfo = new SerializationInfo(typeof(StrongNameKeyPair), new FormatterConverter());
			key_pair.GetObjectData(serializationInfo, default(StreamingContext));
			key = (byte[])serializationInfo.GetValue("_keyPairArray", typeof(byte[]));
			key_container = serializationInfo.GetString("_keyPairContainer");
			return key_container != null;
		}

		public static bool IsNullOrEmpty<T>(this T[] self)
		{
			if (self != null)
			{
				return self.Length == 0;
			}
			return true;
		}

		public static bool IsNullOrEmpty<T>(this Mono.Collections.Generic.Collection<T> self)
		{
			if (self != null)
			{
				return self.size == 0;
			}
			return true;
		}

		public static T[] Resize<T>(this T[] self, int length)
		{
			Array.Resize(ref self, length);
			return self;
		}
	}
	public struct ArrayDimension
	{
		private int? lower_bound;

		private int? upper_bound;

		public int? LowerBound
		{
			get
			{
				return lower_bound;
			}
			set
			{
				lower_bound = value;
			}
		}

		public int? UpperBound
		{
			get
			{
				return upper_bound;
			}
			set
			{
				upper_bound = value;
			}
		}

		public bool IsSized
		{
			get
			{
				if (!lower_bound.HasValue)
				{
					return upper_bound.HasValue;
				}
				return true;
			}
		}

		public ArrayDimension(int? lowerBound, int? upperBound)
		{
			lower_bound = lowerBound;
			upper_bound = upperBound;
		}

		public override string ToString()
		{
			if (IsSized)
			{
				return lower_bound + "..." + upper_bound;
			}
			return string.Empty;
		}
	}
	public sealed class ArrayType : TypeSpecification
	{
		private Mono.Collections.Generic.Collection<ArrayDimension> dimensions;

		public Mono.Collections.Generic.Collection<ArrayDimension> Dimensions
		{
			get
			{
				if (dimensions != null)
				{
					return dimensions;
				}
				dimensions = new Mono.Collections.Generic.Collection<ArrayDimension>();
				dimensions.Add(default(ArrayDimension));
				return dimensions;
			}
		}

		public int Rank
		{
			get
			{
				if (dimensions != null)
				{
					return dimensions.Count;
				}
				return 1;
			}
		}

		public bool IsVector
		{
			get
			{
				if (dimensions == null)
				{
					return true;
				}
				if (dimensions.Count > 1)
				{
					return false;
				}
				return !dimensions[0].IsSized;
			}
		}

		public override bool IsValueType
		{
			get
			{
				return false;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override string Name => base.Name + Suffix;

		public override string FullName => base.FullName + Suffix;

		private string Suffix
		{
			get
			{
				if (IsVector)
				{
					return "[]";
				}
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append("[");
				for (int i = 0; i < dimensions.Count; i++)
				{
					if (i > 0)
					{
						stringBuilder.Append(",");
					}
					stringBuilder.Append(dimensions[i].ToString());
				}
				stringBuilder.Append("]");
				return stringBuilder.ToString();
			}
		}

		public override bool IsArray => true;

		public ArrayType(TypeReference type)
			: base(type)
		{
			Mixin.CheckType(type);
			etype = Mono.Cecil.Metadata.ElementType.Array;
		}

		public ArrayType(TypeReference type, int rank)
			: this(type)
		{
			Mixin.CheckType(type);
			if (rank != 1)
			{
				dimensions = new Mono.Collections.Generic.Collection<ArrayDimension>(rank);
				for (int i = 0; i < rank; i++)
				{
					dimensions.Add(default(ArrayDimension));
				}
				etype = Mono.Cecil.Metadata.ElementType.Array;
			}
		}
	}
	public sealed class AssemblyDefinition : ICustomAttributeProvider, IMetadataTokenProvider, ISecurityDeclarationProvider
	{
		private AssemblyNameDefinition name;

		internal ModuleDefinition main_module;

		private Mono.Collections.Generic.Collection<ModuleDefinition> modules;

		private Mono.Collections.Generic.Collection<CustomAttribute> custom_attributes;

		private Mono.Collections.Generic.Collection<SecurityDeclaration> security_declarations;

		public AssemblyNameDefinition Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public string FullName
		{
			get
			{
				if (name == null)
				{
					return string.Empty;
				}
				return name.FullName;
			}
		}

		public MetadataToken MetadataToken
		{
			get
			{
				return new MetadataToken(TokenType.Assembly, 1);
			}
			set
			{
			}
		}

		public Mono.Collections.Generic.Collection<ModuleDefinition> Modules
		{
			get
			{
				if (modules != null)
				{
					return modules;
				}
				if (main_module.HasImage)
				{
					return main_module.Read(ref modules, this, (AssemblyDefinition _, MetadataReader reader) => reader.ReadModules());
				}
				return modules = new Mono.Collections.Generic.Collection<ModuleDefinition>(1) { main_module };
			}
		}

		public ModuleDefinition MainModule => main_module;

		public MethodDefinition EntryPoint
		{
			get
			{
				return main_module.EntryPoint;
			}
			set
			{
				main_module.EntryPoint = value;
			}
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
				{
					return custom_attributes.Count > 0;
				}
				return this.GetHasCustomAttributes(main_module);
			}
		}

		public Mono.Collections.Generic.Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, main_module);

		public bool HasSecurityDeclarations
		{
			get
			{
				if (security_declarations != null)
				{
					return security_declarations.Count > 0;
				}
				return this.GetHasSecurityDeclarations(main_module);
			}
		}

		public Mono.Collections.Generic.Collection<SecurityDeclaration> SecurityDeclarations => security_declarations ?? this.GetSecurityDeclarations(ref security_declarations, main_module);

		internal AssemblyDefinition()
		{
		}

		public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleKind kind)
		{
			return CreateAssembly(assemblyName, moduleName, new ModuleParameters
			{
				Kind = kind
			});
		}

		public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleParameters parameters)
		{
			if (assemblyName == null)
			{
				throw new ArgumentNullException("assemblyName");
			}
			if (moduleName == null)
			{
				throw new ArgumentNullException("moduleName");
			}
			Mixin.CheckParameters(parameters);
			if (parameters.Kind == ModuleKind.NetModule)
			{
				throw new ArgumentException("kind");
			}
			AssemblyDefinition assembly = ModuleDefinition.CreateModule(moduleName, parameters).Assembly;
			assembly.Name = assemblyName;
			return assembly;
		}

		public static AssemblyDefinition ReadAssembly(string fileName)
		{
			return ReadAssembly(ModuleDefinition.ReadModule(fileName));
		}

		public static AssemblyDefinition ReadAssembly(string fileName, ReaderParameters parameters)
		{
			return ReadAssembly(ModuleDefinition.ReadModule(fileName, parameters));
		}

		public static AssemblyDefinition ReadAssembly(Stream stream)
		{
			return ReadAssembly(ModuleDefinition.ReadModule(stream));
		}

		public static AssemblyDefinition ReadAssembly(Stream stream, ReaderParameters parameters)
		{
			return ReadAssembly(ModuleDefinition.ReadModule(stream, parameters));
		}

		private static AssemblyDefinition ReadAssembly(ModuleDefinition module)
		{
			return module.Assembly ?? throw new ArgumentException();
		}

		public void Write(string fileName)
		{
			Write(fileName, new WriterParameters());
		}

		public void Write(Stream stream)
		{
			Write(stream, new WriterParameters());
		}

		public void Write(string fileName, WriterParameters parameters)
		{
			main_module.Write(fileName, parameters);
		}

		public void Write(Stream stream, WriterParameters parameters)
		{
			main_module.Write(stream, parameters);
		}

		public override string ToString()
		{
			return FullName;
		}
	}
	[Flags]
	public enum AssemblyAttributes : uint
	{
		PublicKey = 1u,
		SideBySideCompatible = 0u,
		Retargetable = 0x100u,
		WindowsRuntime = 0x200u,
		DisableJITCompileOptimizer = 0x4000u,
		EnableJITCompileTracking = 0x8000u
	}
	public enum AssemblyHashAlgorithm : uint
	{
		None = 0u,
		Reserved = 32771u,
		SHA1 = 32772u
	}
	public sealed class AssemblyLinkedResource : Resource
	{
		private AssemblyNameReference reference;

		public AssemblyNameReference Assembly
		{
			get
			{
				return reference;
			}
			set
			{
				reference = value;
			}
		}

		public override ResourceType ResourceType => ResourceType.AssemblyLinked;

		public AssemblyLinkedResource(string name, ManifestResourceAttributes flags)
			: base(name, flags)
		{
		}

		public AssemblyLinkedResource(string name, ManifestResourceAttributes flags, AssemblyNameReference reference)
			: base(name, flags)
		{
			this.reference = reference;
		}
	}
	public sealed class AssemblyNameDefinition : AssemblyNameReference
	{
		public override byte[] Hash => Empty<byte>.Array;

		internal AssemblyNameDefinition()
		{
			token = new MetadataToken(TokenType.Assembly, 1);
		}

		public AssemblyNameDefinition(string name, Version version)
			: base(name, version)
		{
			token = new MetadataToken(TokenType.Assembly, 1);
		}
	}
	public class AssemblyNameReference : IMetadataScope, IMetadataTokenProvider
	{
		private string name;

		private string culture;

		private Version version;

		private uint attributes;

		private byte[] public_key;

		private byte[] public_key_token;

		private AssemblyHashAlgorithm hash_algorithm;

		private byte[] hash;

		internal MetadataToken token;

		private string full_name;

		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
				full_name = null;
			}
		}

		public string Culture
		{
			get
			{
				return culture;
			}
			set
			{
				culture = value;
				full_name = null;
			}
		}

		public Version Version
		{
			get
			{
				return version;
			}
			set
			{
				version = value;
				full_name = null;
			}
		}

		public AssemblyAttributes Attributes
		{
			get
			{
				return (AssemblyAttributes)attributes;
			}
			set
			{
				attributes = (uint)value;
			}
		}

		public bool HasPublicKey
		{
			get
			{
				return attributes.GetAttributes(1u);
			}
			set
			{
				attributes = attributes.SetAttributes(1u, value);
			}
		}

		public bool IsSideBySideCompatible
		{
			get
			{
				return attributes.GetAttributes(0u);
			}
			set
			{
				attributes = attributes.SetAttributes(0u, value);
			}
		}

		public bool IsRetargetable
		{
			get
			{
				return attributes.GetAttributes(256u);
			}
			set
			{
				attributes = attributes.SetAttributes(256u, value);
			}
		}

		public bool IsWindowsRuntime
		{
			get
			{
				return attributes.GetAttributes(512u);
			}
			set
			{
				attributes = attributes.SetAttributes(512u, value);
			}
		}

		public byte[] PublicKey
		{
			get
			{
				return public_key ?? Empty<byte>.Array;
			}
			set
			{
				public_key = value;
				HasPublicKey = !public_key.IsNullOrEmpty();
				public_key_token = Empty<byte>.Array;
				full_name = null;
			}
		}

		public byte[] PublicKeyToken
		{
			get
			{
				if (public_key_token.IsNullOrEmpty() && !public_key.IsNullOrEmpty())
				{
					byte[] array = HashPublicKey();
					byte[] array2 = new byte[8];
					Array.Copy(array, array.Length - 8, array2, 0, 8);
					Array.Reverse((Array)array2, 0, 8);
					public_key_token = array2;
				}
				return public_key_token ?? Empty<byte>.Array;
			}
			set
			{
				public_key_token = value;
				full_name = null;
			}
		}

		public virtual MetadataScopeType MetadataScopeType => MetadataScopeType.AssemblyNameReference;

		public string FullName
		{
			get
			{
				if (full_name != null)
				{
					return full_name;
				}
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(name);
				if (version != null)
				{
					stringBuilder.Append(", ");
					stringBuilder.Append("Version=");
					stringBuilder.Append(version.ToString());
				}
				stringBuilder.Append(", ");
				stringBuilder.Append("Culture=");
				stringBuilder.Append(string.IsNullOrEmpty(culture) ? "neutral" : culture);
				stringBuilder.Append(", ");
				stringBuilder.Append("PublicKeyToken=");
				byte[] publicKeyToken = PublicKeyToken;
				if (!publicKeyToken.IsNullOrEmpty() && publicKeyToken.Length != 0)
				{
					for (int i = 0; i < publicKeyToken.Length; i++)
					{
						stringBuilder.Append(publicKeyToken[i].ToString("x2"));
					}
				}
				else
				{
					stringBuilder.Append("null");
				}
				return full_name = stringBuilder.ToString();
			}
		}

		public AssemblyHashAlgorithm HashAlgorithm
		{
			get
			{
				return hash_algorithm;
			}
			set
			{
				hash_algorithm = value;
			}
		}

		public virtual byte[] Hash
		{
			get
			{
				return hash;
			}
			set
			{
				hash = value;
			}
		}

		public MetadataToken MetadataToken
		{
			get
			{
				return token;
			}
			set
			{
				token = value;
			}
		}

		private byte[] HashPublicKey()
		{
			AssemblyHashAlgorithm assemblyHashAlgorithm = hash_algorithm;
			HashAlgorithm hashAlgorithm = ((assemblyHashAlgorithm != AssemblyHashAlgorithm.Reserved) ? ((HashAlgorithm)SHA1.Create()) : ((HashAlgorithm)MD5.Create()));
			using (hashAlgorithm)
			{
				return hashAlgorithm.ComputeHash(public_key);
			}
		}

		public static AssemblyNameReference Parse(string fullName)
		{
			if (fullName == null)
			{
				throw new ArgumentNullException("fullName");
			}
			if (fullName.Length == 0)
			{
				throw new ArgumentException("Name can not be empty");
			}
			AssemblyNameReference assemblyNameReference = new AssemblyNameReference();
			string[] array = fullName.Split(new char[1] { ',' });
			for (int i = 0; i < array.Length; i++)
			{
				string text = array[i].Trim();
				if (i == 0)
				{
					assemblyNameReference.Name = text;
					continue;
				}
				string[] array2 = text.Split(new char[1] { '=' });
				if (array2.Length != 2)
				{
					throw new ArgumentException("Malformed name");
				}
				switch (array2[0].ToLowerInvariant())
				{
				case "version":
					assemblyNameReference.Version = new Version(array2[1]);
					break;
				case "culture":
					assemblyNameReference.Culture = array2[1];
					break;
				case "publickeytoken":
				{
					string text2 = array2[1];
					if (!(text2 == "null"))
					{
						assemblyNameReference.PublicKeyToken = new byte[text2.Length / 2];
						for (int j = 0; j < assemblyNameReference.PublicKeyToken.Length; j++)
						{
							assemblyNameReference.PublicKeyToken[j] = byte.Parse(text2.Substring(j * 2, 2), NumberStyles.HexNumber);
						}
					}
					break;
				}
				}
			}
			return assemblyNameReference;
		}

		internal AssemblyNameReference()
		{
		}

		public AssemblyNameReference(string name, Version version)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			this.name = name;
			this.version = version;
			hash_algorithm = AssemblyHashAlgorithm.None;
			token = new MetadataToken(TokenType.AssemblyRef);
		}

		public override string ToString()
		{
			return FullName;
		}
	}
	internal abstract class ModuleReader
	{
		protected readonly Image image;

		protected readonly ModuleDefinition module;

		protected ModuleReader(Image image, ReadingMode mode)
		{
			this.image = image;
			module = new ModuleDefinition(image);
			module.ReadingMode = mode;
		}

		protected abstract void ReadModule();

		protected void ReadModuleManifest(MetadataReader reader)
		{
			reader.Populate(module);
			ReadAssembly(reader);
		}

		private void ReadAssembly(MetadataReader reader)
		{
			AssemblyNameDefinition assemblyNameDefinition = reader.ReadAssemblyNameDefinition();
			if (assemblyNameDefinition == null)
			{
				module.kind = ModuleKind.NetModule;
				return;
			}
			AssemblyDefinition assemblyDefinition = new AssemblyDefinition();
			assemblyDefinition.Name = assemblyNameDefinition;
			module.assembly = assemblyDefinition;
			assemblyDefinition.main_module = module;
		}

		public static ModuleDefinition CreateModuleFrom(Image image, ReaderParameters parameters)
		{
			ModuleReader moduleReader = CreateModuleReader(image, parameters.ReadingMode);
			ModuleDefinition moduleDefinition = moduleReader.module;
			if (parameters.AssemblyResolver != null)
			{
				moduleDefinition.assembly_resolver = parameters.AssemblyResolver;
			}
			if (parameters.MetadataResolver != null)
			{
				moduleDefinition.metadata_resolver = parameters.MetadataResolver;
			}
			moduleReader.ReadModule();
			ReadSymbols(moduleDefinition, parameters);
			return moduleDefinition;
		}

		private static void ReadSymbols(ModuleDefinition module, ReaderParameters parameters)
		{
			ISymbolReaderProvider symbolReaderProvider = parameters.SymbolReaderProvider;
			if (symbolReaderProvider == null && parameters.ReadSymbols)
			{
				symbolReaderProvider = SymbolProvider.GetPlatformReaderProvider();
			}
			if (symbolReaderProvider != null)
			{
				module.SymbolReaderProvider = symbolReaderProvider;
				ISymbolReader reader = ((parameters.SymbolStream != null) ? symbolReaderProvider.GetSymbolReader(module, parameters.SymbolStream) : symbolReaderProvider.GetSymbolReader(module, module.FullyQualifiedName));
				module.ReadSymbols(reader);
			}
		}

		private static ModuleReader CreateModuleReader(Image image, ReadingMode mode)
		{
			return mode switch
			{
				ReadingMode.Immediate => new ImmediateModuleReader(image), 
				ReadingMode.Deferred => new DeferredModuleReader(image), 
				_ => throw new ArgumentException(), 
			};
		}
	}
	internal sealed class ImmediateModuleReader : ModuleReader
	{
		public ImmediateModuleReader(Image image)
			: base(image, ReadingMode.Immediate)
		{
		}

		protected override void ReadModule()
		{
			module.Read(module, delegate(ModuleDefinition module, MetadataReader reader)
			{
				ReadModuleManifest(reader);
				ReadModule(module);
				return module;
			});
		}

		public static void ReadModule(ModuleDefinition module)
		{
			if (module.HasAssemblyReferences)
			{
				Read(module.AssemblyReferences);
			}
			if (module.HasResources)
			{
				Read(module.Resources);
			}
			if (module.HasModuleReferences)
			{
				Read(module.ModuleReferences);
			}
			if (module.HasTypes)
			{
				ReadTypes(module.Types);
			}
			if (module.HasExportedTypes)
			{
				Read(module.ExportedTypes);
			}
			if (module.HasCustomAttributes)
			{
				Read(module.CustomAttributes);
			}
			AssemblyDefinition assembly = module.Assembly;
			if (assembly != null)
			{
				if (assembly.HasCustomAttributes)
				{
					ReadCustomAttributes(assembly);
				}
				if (assembly.HasSecurityDeclarations)
				{
					Read(assembly.SecurityDeclarations);
				}
			}
		}

		private static void ReadTypes(Mono.Collections.Generic.Collection<TypeDefinition> types)
		{
			for (int i = 0; i < types.Count; i++)
			{
				ReadType(types[i]);
			}
		}

		private static void ReadType(TypeDefinition type)
		{
			ReadGenericParameters(type);
			if (type.HasInterfaces)
			{
				Read(type.Interfaces);
			}
			if (type.HasNestedTypes)
			{
				ReadTypes(type.NestedTypes);
			}
			if (type.HasLayoutInfo)
			{
				Read(type.ClassSize);
			}
			if (type.HasFields)
			{
				ReadFields(type);
			}
			if (type.HasMethods)
			{
				ReadMethods(type);
			}
			if (type.HasProperties)
			{
				ReadProperties(type);
			}
			if (type.HasEvents)
			{
				ReadEvents(type);
			}
			ReadSecurityDeclarations(type);
			ReadCustomAttributes(type);
		}

		private static void ReadGenericParameters(IGenericParameterProvider provider)
		{
			if (!provider.HasGenericParameters)
			{
				return;
			}
			Mono.Collections.Generic.Collection<GenericParameter> genericParameters = provider.GenericParameters;
			for (int i = 0; i < genericParameters.Count; i++)
			{
				GenericParameter genericParameter = genericParameters[i];
				if (genericParameter.HasConstraints)
				{
					Read(genericParameter.Constraints);
				}
				ReadCustomAttributes(genericParameter);
			}
		}

		private static void ReadSecurityDeclarations(ISecurityDeclarationProvider provider)
		{
			if (provider.HasSecurityDeclarations)
			{
				Mono.Collections.Generic.Collection<SecurityDeclaration> securityDeclarations = provider.SecurityDeclarations;
				for (int i = 0; i < securityDeclarations.Count; i++)
				{
					Read(securityDeclarations[i].SecurityAttributes);
				}
			}
		}

		private static void ReadCustomAttributes(ICustomAttributeProvider provider)
		{
			if (provider.HasCustomAttributes)
			{
				Mono.Collections.Generic.Collection<CustomAttribute> customAttributes = provider.CustomAttributes;
				for (int i = 0; i < customAttributes.Count; i++)
				{
					Read(customAttributes[i].ConstructorArguments);
				}
			}
		}

		private static void ReadFields(TypeDefinition type)
		{
			Mono.Collections.Generic.Collection<FieldDefinition> fields = type.Fields;
			for (int i = 0; i < fields.Count; i++)
			{
				FieldDefinition fieldDefinition = fields[i];
				if (fieldDefinition.HasConstant)
				{
					Read(fieldDefinition.Constant);
				}
				if (fieldDefinition.HasLayoutInfo)
				{
					Read(fieldDefinition.Offset);
				}
				if (fieldDefinition.RVA > 0)
				{
					Read(fieldDefinition.InitialValue);
				}
				if (fieldDefinition.HasMarshalInfo)
				{
					Read(fieldDefinition.MarshalInfo);
				}
				ReadCustomAttributes(fieldDefinition);
			}
		}

		private static void ReadMethods(TypeDefinition type)
		{
			Mono.Collections.Generic.Collection<MethodDefinition> methods = type.Methods;
			for (int i = 0; i < methods.Count; i++)
			{
				MethodDefinition methodDefinition = methods[i];
				ReadGenericParameters(methodDefinition);
				if (methodDefinition.HasParameters)
				{
					ReadParameters(methodDefinition);
				}
				if (methodDefinition.HasOverrides)
				{
					Read(methodDefinition.Overrides);
				}
				if (methodDefinition.IsPInvokeImpl)
				{
					Read(methodDefinition.PInvokeInfo);
				}
				ReadSecurityDeclarations(methodDefinition);
				ReadCustomAttributes(methodDefinition);
				MethodReturnType methodReturnType = methodDefinition.MethodReturnType;
				if (methodReturnType.HasConstant)
				{
					Read(methodReturnType.Constant);
				}
				if (methodReturnType.HasMarshalInfo)
				{
					Read(methodReturnType.MarshalInfo);
				}
				ReadCustomAttributes(methodReturnType);
			}
		}

		private static void ReadParameters(MethodDefinition method)
		{
			Mono.Collections.Generic.Collection<ParameterDefinition> parameters = method.Parameters;
			for (int i = 0; i < parameters.Count; i++)
			{
				ParameterDefinition parameterDefinition = parameters[i];
				if (parameterDefinition.HasConstant)
				{
					Read(parameterDefinition.Constant);
				}
				if (parameterDefinition.HasMarshalInfo)
				{
					Read(parameterDefinition.MarshalInfo);
				}
				ReadCustomAttributes(parameterDefinition);
			}
		}

		private static void ReadProperties(TypeDefinition type)
		{
			Mono.Collections.Generic.Collection<PropertyDefinition> properties = type.Properties;
			for (int i = 0; i < properties.Count; i++)
			{
				PropertyDefinition propertyDefinition = properties[i];
				Read(propertyDefinition.GetMethod);
				if (propertyDefinition.HasConstant)
				{
					Read(propertyDefinition.Constant);
				}
				ReadCustomAttributes(propertyDefinition);
			}
		}

		private static void ReadEvents(TypeDefinition type)
		{
			Mono.Collections.Generic.Collection<EventDefinition> events = type.Events;
			for (int i = 0; i < events.Count; i++)
			{
				EventDefinition eventDefinition = events[i];
				Read(eventDefinition.AddMethod);
				ReadCustomAttributes(eventDefinition);
			}
		}

		private static void Read(object collection)
		{
		}
	}
	internal sealed class DeferredModuleReader : ModuleReader
	{
		public DeferredModuleReader(Image image)
			: base(image, ReadingMode.Deferred)
		{
		}

		protected override void ReadModule()
		{
			module.Read(module, delegate(ModuleDefinition module, MetadataReader reader)
			{
				ReadModuleManifest(reader);
				return module;
			});
		}
	}
	internal sealed class MetadataReader : ByteBuffer
	{
		internal readonly Image image;

		internal readonly ModuleDefinition module;

		internal readonly MetadataSystem metadata;

		internal IGenericContext context;

		internal CodeReader code;

		private uint Position
		{
			get
			{
				return (uint)position;
			}
			set
			{
				position = (int)value;
			}
		}

		public MetadataReader(ModuleDefinition module)
			: base(module.Image.MetadataSection.Data)
		{
			image = module.Image;
			this.module = module;
			metadata = module.MetadataSystem;
			code = new CodeReader(image.MetadataSection, this);
		}

		private int GetCodedIndexSize(CodedIndex index)
		{
			return image.GetCodedIndexSize(index);
		}

		private uint ReadByIndexSize(int size)
		{
			if (size == 4)
			{
				return ReadUInt32();
			}
			return ReadUInt16();
		}

		private byte[] ReadBlob()
		{
			BlobHeap blobHeap = image.BlobHeap;
			if (blobHeap == null)
			{
				position += 2;
				return Empty<byte>.Array;
			}
			return blobHeap.Read(ReadBlobIndex());
		}

		private byte[] ReadBlob(uint signature)
		{
			BlobHeap blobHeap = image.BlobHeap;
			if (blobHeap == null)
			{
				return Empty<byte>.Array;
			}
			return blobHeap.Read(signature);
		}

		private uint ReadBlobIndex()
		{
			return ReadByIndexSize(image.BlobHeap?.IndexSize ?? 2);
		}

		private string ReadString()
		{
			return image.StringHeap.Read(ReadByIndexSize(image.StringHeap.IndexSize));
		}

		private uint ReadStringIndex()
		{
			return ReadByIndexSize(image.StringHeap.IndexSize);
		}

		private uint ReadTableIndex(Table table)
		{
			return ReadByIndexSize(image.GetTableIndexSize(table));
		}

		private MetadataToken ReadMetadataToken(CodedIndex index)
		{
			return index.GetMetadataToken(ReadByIndexSize(GetCodedIndexSize(index)));
		}

		private int MoveTo(Table table)
		{
			TableInformation tableInformation = image.TableHeap[table];
			if (tableInformation.Length != 0)
			{
				Position = tableInformation.Offset;
			}
			return (int)tableInformation.Length;
		}

		private bool MoveTo(Table table, uint row)
		{
			TableInformation tableInformation = image.TableHeap[table];
			uint num = tableInformation.Length;
			if (num == 0 || row > num)
			{
				return false;
			}
			Position = tableInformation.Offset + tableInformation.RowSize * (row - 1);
			return true;
		}

		public AssemblyNameDefinition ReadAssemblyNameDefinition()
		{
			if (MoveTo(Table.Assembly) == 0)
			{
				return null;
			}
			AssemblyNameDefinition assemblyNameDefinition = new AssemblyNameDefinition();
			assemblyNameDefinition.HashAlgorithm = (AssemblyHashAlgorithm)ReadUInt32();
			PopulateVersionAndFlags(assemblyNameDefinition);
			assemblyNameDefinition.PublicKey = ReadBlob();
			PopulateNameAndCulture(assemblyNameDefinition);
			return assemblyNameDefinition;
		}

		public ModuleDefinition Populate(ModuleDefinition module)
		{
			if (MoveTo(Table.Module) == 0)
			{
				return module;
			}
			Advance(2);
			module.Name = ReadString();
			module.Mvid = image.GuidHeap.Read(ReadByIndexSize(image.GuidHeap.IndexSize));
			return module;
		}

		private void InitializeAssemblyReferences()
		{
			if (metadata.AssemblyReferences != null)
			{
				return;
			}
			int num = MoveTo(Table.AssemblyRef);
			AssemblyNameReference[] array = (metadata.AssemblyReferences = new AssemblyNameReference[num]);
			for (uint num2 = 0u; num2 < num; num2++)
			{
				AssemblyNameReference assemblyNameReference = new AssemblyNameReference();
				assemblyNameReference.token = new MetadataToken(TokenType.AssemblyRef, num2 + 1);
				PopulateVersionAndFlags(assemblyNameReference);
				byte[] array2 = ReadBlob();
				if (assemblyNameReference.HasPublicKey)
				{
					assemblyNameReference.PublicKey = array2;
				}
				else
				{
					assemblyNameReference.PublicKeyToken = array2;
				}
				PopulateNameAndCulture(assemblyNameReference);
				assemblyNameReference.Hash = ReadBlob();
				array[num2] = assemblyNameReference;
			}
		}

		public Mono.Collections.Generic.Collection<AssemblyNameReference> ReadAssemblyReferences()
		{
			InitializeAssemblyReferences();
			return new Mono.Collections.Generic.Collection<AssemblyNameReference>(metadata.AssemblyReferences);
		}

		public MethodDefinition ReadEntryPoint()
		{
			if (module.Image.EntryPointToken == 0)
			{
				return null;
			}
			return GetMethodDefinition(new MetadataToken(module.Image.EntryPointToken).RID);
		}

		public Mono.Collections.Generic.Collection<ModuleDefinition> ReadModules()
		{
			Mono.Collections.Generic.Collection<ModuleDefinition> collection = new Mono.Collections.Generic.Collection<ModuleDefinition>(1);
			collection.Add(module);
			int num = MoveTo(Table.File);
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				uint num3 = ReadUInt32();
				string name = ReadString();
				ReadBlobIndex();
				if (num3 == 0)
				{
					ReaderParameters parameters = new ReaderParameters
					{
						ReadingMode = module.ReadingMode,
						SymbolReaderProvider = module.SymbolReaderProvider,
						AssemblyResolver = module.AssemblyResolver
					};
					collection.Add(ModuleDefinition.ReadModule(GetModuleFileName(name), parameters));
				}
			}
			return collection;
		}

		private string GetModuleFileName(string name)
		{
			if (module.FullyQualifiedName == null)
			{
				throw new NotSupportedException();
			}
			return Path.Combine(Path.GetDirectoryName(module.FullyQualifiedName), name);
		}

		private void InitializeModuleReferences()
		{
			if (metadata.ModuleReferences == null)
			{
				int num = MoveTo(Table.ModuleRef);
				ModuleReference[] array = (metadata.ModuleReferences = new ModuleReference[num]);
				for (uint num2 = 0u; num2 < num; num2++)
				{
					ModuleReference moduleReference = new ModuleReference(ReadString());
					moduleReference.token = new MetadataToken(TokenType.ModuleRef, num2 + 1);
					array[num2] = moduleReference;
				}
			}
		}

		public Mono.Collections.Generic.Collection<ModuleReference> ReadModuleReferences()
		{
			InitializeModuleReferences();
			return new Mono.Collections.Generic.Collection<ModuleReference>(metadata.ModuleReferences);
		}

		public bool HasFileResource()
		{
			int num = MoveTo(Table.File);
			if (num == 0)
			{
				return false;
			}
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				if (ReadFileRecord(num2).Col1 == FileAttributes.ContainsNoMetaData)
				{
					return true;
				}
			}
			return false;
		}

		public Mono.Collections.Generic.Collection<Resource> ReadResources()
		{
			int num = MoveTo(Table.ManifestResource);
			Mono.Collections.Generic.Collection<Resource> collection = new Mono.Collections.Generic.Collection<Resource>(num);
			for (int i = 1; i <= num; i++)
			{
				uint offset = ReadUInt32();
				ManifestResourceAttributes manifestResourceAttributes = (ManifestResourceAttributes)ReadUInt32();
				string name = ReadString();
				MetadataToken scope = ReadMetadataToken(CodedIndex.Implementation);
				Resource item;
				if (scope.RID == 0)
				{
					item = new EmbeddedResource(name, manifestResourceAttributes, offset, this);
				}
				else if (scope.TokenType == TokenType.AssemblyRef)
				{
					item = new AssemblyLinkedResource(name, manifestResourceAttributes)
					{
						Assembly = (AssemblyNameReference)GetTypeReferenceScope(scope)
					};
				}
				else
				{
					if (scope.TokenType != TokenType.File)
					{
						throw new NotSupportedException();
					}
					Row<FileAttributes, string, uint> row = ReadFileRecord(scope.RID);
					item = new LinkedResource(name, manifestResourceAttributes)
					{
						File = row.Col2,
						hash = ReadBlob(row.Col3)
					};
				}
				collection.Add(item);
			}
			return collection;
		}

		private Row<FileAttributes, string, uint> ReadFileRecord(uint rid)
		{
			int num = position;
			if (!MoveTo(Table.File, rid))
			{
				throw new ArgumentException();
			}
			Row<FileAttributes, string, uint> result = new Row<FileAttributes, string, uint>((FileAttributes)ReadUInt32(), ReadString(), ReadBlobIndex());
			position = num;
			return result;
		}

		public MemoryStream GetManagedResourceStream(uint offset)
		{
			uint virtualAddress = image.Resources.VirtualAddress;
			Section sectionAtVirtualAddress = image.GetSectionAtVirtualAddress(virtualAddress);
			uint num = virtualAddress - sectionAtVirtualAddress.VirtualAddress + offset;
			byte[] data = sectionAtVirtualAddress.Data;
			int count = data[num] | (data[num + 1] << 8) | (data[num + 2] << 16) | (data[num + 3] << 24);
			return new MemoryStream(data, (int)(num + 4), count);
		}

		private void PopulateVersionAndFlags(AssemblyNameReference name)
		{
			name.Version = new Version(ReadUInt16(), ReadUInt16(), ReadUInt16(), ReadUInt16());
			name.Attributes = (AssemblyAttributes)ReadUInt32();
		}

		private void PopulateNameAndCulture(AssemblyNameReference name)
		{
			name.Name = ReadString();
			name.Culture = ReadString();
		}

		public TypeDefinitionCollection ReadTypes()
		{
			InitializeTypeDefinitions();
			TypeDefinition[] types = metadata.Types;
			int capacity = types.Length - metadata.NestedTypes.Count;
			TypeDefinitionCollection typeDefinitionCollection = new TypeDefinitionCollection(module, capacity);
			foreach (TypeDefinition typeDefinition in types)
			{
				if (!IsNested(typeDefinition.Attributes))
				{
					typeDefinitionCollection.Add(typeDefinition);
				}
			}
			if (image.HasTable(Table.MethodPtr) || image.HasTable(Table.FieldPtr))
			{
				CompleteTypes();
			}
			return typeDefinitionCollection;
		}

		private void CompleteTypes()
		{
			TypeDefinition[] types = metadata.Types;
			foreach (TypeDefinition obj in types)
			{
				InitializeCollection(obj.Fields);
				InitializeCollection(obj.Methods);
			}
		}

		private void InitializeTypeDefinitions()
		{
			if (metadata.Types != null)
			{
				return;
			}
			InitializeNestedTypes();
			InitializeFields();
			InitializeMethods();
			int num = MoveTo(Table.TypeDef);
			TypeDefinition[] array = (metadata.Types = new TypeDefinition[num]);
			for (uint num2 = 0u; num2 < num; num2++)
			{
				if (array[num2] == null)
				{
					array[num2] = ReadType(num2 + 1);
				}
			}
		}

		private static bool IsNested(TypeAttributes attributes)
		{
			switch (attributes & TypeAttributes.VisibilityMask)
			{
			case TypeAttributes.NestedPublic:
			case TypeAttributes.NestedPrivate:
			case TypeAttributes.NestedFamily:
			case TypeAttributes.NestedAssembly:
			case TypeAttributes.NestedFamANDAssem:
			case TypeAttributes.VisibilityMask:
				return true;
			default:
				return false;
			}
		}

		public bool HasNestedTypes(TypeDefinition type)
		{
			InitializeNestedTypes();
			if (!metadata.TryGetNestedTypeMapping(type, out var mapping))
			{
				return false;
			}
			return mapping.Length != 0;
		}

		public Mono.Collections.Generic.Collection<TypeDefinition> ReadNestedTypes(TypeDefinition type)
		{
			InitializeNestedTypes();
			if (!metadata.TryGetNestedTypeMapping(type, out var mapping))
			{
				return new MemberDefinitionCollection<TypeDefinition>(type);
			}
			MemberDefinitionCollection<TypeDefinition> memberDefinitionCollection = new MemberDefinitionCollection<TypeDefinition>(type, mapping.Length);
			for (int i = 0; i < mapping.Length; i++)
			{
				TypeDefinition typeDefinition = GetTypeDefinition(mapping[i]);
				if (typeDefinition != null)
				{
					memberDefinitionCollection.Add(typeDefinition);
				}
			}
			metadata.RemoveNestedTypeMapping(type);
			return memberDefinitionCollection;
		}

		private void InitializeNestedTypes()
		{
			if (metadata.NestedTypes != null)
			{
				return;
			}
			int num = MoveTo(Table.NestedClass);
			metadata.NestedTypes = new Dictionary<uint, uint[]>(num);
			metadata.ReverseNestedTypes = new Dictionary<uint, uint>(num);
			if (num != 0)
			{
				for (int i = 1; i <= num; i++)
				{
					uint nested = ReadTableIndex(Table.TypeDef);
					uint declaring = ReadTableIndex(Table.TypeDef);
					AddNestedMapping(declaring, nested);
				}
			}
		}

		private void AddNestedMapping(uint declaring, uint nested)
		{
			metadata.SetNestedTypeMapping(declaring, AddMapping(metadata.NestedTypes, declaring, nested));
			metadata.SetReverseNestedTypeMapping(nested, declaring);
		}

		private static TValue[] AddMapping<TKey, TValue>(Dictionary<TKey, TValue[]> cache, TKey key, TValue value)
		{
			if (!cache.TryGetValue(key, out var value2))
			{
				return new TValue[1] { value };
			}
			TValue[] array = new TValue[value2.Length + 1];
			Array.Copy(value2, array, value2.Length);
			array[value2.Length] = value;
			return array;
		}

		private TypeDefinition ReadType(uint rid)
		{
			if (!MoveTo(Table.TypeDef, rid))
			{
				return null;
			}
			TypeAttributes attributes = (TypeAttributes)ReadUInt32();
			string name = ReadString();
			TypeDefinition typeDefinition = new TypeDefinition(ReadString(), name, attributes);
			typeDefinition.token = new MetadataToken(TokenType.TypeDef, rid);
			typeDefinition.scope = module;
			typeDefinition.module = module;
			metadata.AddTypeDefinition(typeDefinition);
			context = typeDefinition;
			typeDefinition.BaseType = GetTypeDefOrRef(ReadMetadataToken(CodedIndex.TypeDefOrRef));
			typeDefinition.fields_range = ReadFieldsRange(rid);
			typeDefinition.methods_range = ReadMethodsRange(rid);
			if (IsNested(attributes))
			{
				typeDefinition.DeclaringType = GetNestedTypeDeclaringType(typeDefinition);
			}
			return typeDefinition;
		}

		private TypeDefinition GetNestedTypeDeclaringType(TypeDefinition type)
		{
			if (!metadata.TryGetReverseNestedTypeMapping(type, out var declaring))
			{
				return null;
			}
			metadata.RemoveReverseNestedTypeMapping(type);
			return GetTypeDefinition(declaring);
		}

		private Range ReadFieldsRange(uint type_index)
		{
			return ReadListRange(type_index, Table.TypeDef, Table.Field);
		}

		private Range ReadMethodsRange(uint type_index)
		{
			return ReadListRange(type_index, Table.TypeDef, Table.Method);
		}

		private Range ReadListRange(uint current_index, Table current, Table target)
		{
			Range result = new Range
			{
				Start = ReadTableIndex(target)
			};
			TableInformation tableInformation = image.TableHeap[current];
			uint num;
			if (current_index == tableInformation.Length)
			{
				num = image.TableHeap[target].Length + 1;
			}
			else
			{
				uint num2 = Position;
				Position += (uint)(int)(tableInformation.RowSize - image.GetTableIndexSize(target));
				num = ReadTableIndex(target);
				Position = num2;
			}
			result.Length = num - result.Start;
			return result;
		}

		public Row<short, int> ReadTypeLayout(TypeDefinition type)
		{
			InitializeTypeLayouts();
			uint rID = type.token.RID;
			if (!metadata.ClassLayouts.TryGetValue(rID, out var value))
			{
				return new Row<short, int>(-1, -1);
			}
			type.PackingSize = (short)value.Col1;
			type.ClassSize = (int)value.Col2;
			metadata.ClassLayouts.Remove(rID);
			return new Row<short, int>((short)value.Col1, (int)value.Col2);
		}

		private void InitializeTypeLayouts()
		{
			if (metadata.ClassLayouts == null)
			{
				int num = MoveTo(Table.ClassLayout);
				Dictionary<uint, Row<ushort, uint>> dictionary = (metadata.ClassLayouts = new Dictionary<uint, Row<ushort, uint>>(num));
				for (uint num2 = 0u; num2 < num; num2++)
				{
					ushort col = ReadUInt16();
					uint col2 = ReadUInt32();
					uint key = ReadTableIndex(Table.TypeDef);
					dictionary.Add(key, new Row<ushort, uint>(col, col2));
				}
			}
		}

		public TypeReference GetTypeDefOrRef(MetadataToken token)
		{
			return (TypeReference)LookupToken(token);
		}

		public TypeDefinition GetTypeDefinition(uint rid)
		{
			InitializeTypeDefinitions();
			TypeDefinition typeDefinition = metadata.GetTypeDefinition(rid);
			if (typeDefinition != null)
			{
				return typeDefinition;
			}
			return ReadTypeDefinition(rid);
		}

		private TypeDefinition ReadTypeDefinition(uint rid)
		{
			if (!MoveTo(Table.TypeDef, rid))
			{
				return null;
			}
			return ReadType(rid);
		}

		private void InitializeTypeReferences()
		{
			if (metadata.TypeReferences == null)
			{
				metadata.TypeReferences = new TypeReference[image.GetTableLength(Table.TypeRef)];
			}
		}

		public TypeReference GetTypeReference(string scope, string full_name)
		{
			InitializeTypeReferences();
			int num = metadata.TypeReferences.Length;
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				TypeReference typeReference = GetTypeReference(num2);
				if (!(typeReference.FullName != full_name))
				{
					if (string.IsNullOrEmpty(scope))
					{
						return typeReference;
					}
					if (typeReference.Scope.Name == scope)
					{
						return typeReference;
					}
				}
			}
			return null;
		}

		private TypeReference GetTypeReference(uint rid)
		{
			InitializeTypeReferences();
			TypeReference typeReference = metadata.GetTypeReference(rid);
			if (typeReference != null)
			{
				return typeReference;
			}
			return ReadTypeReference(rid);
		}

		private TypeReference ReadTypeReference(uint rid)
		{
			if (!MoveTo(Table.TypeRef, rid))
			{
				return null;
			}
			TypeReference typeReference = null;
			MetadataToken metadataToken = ReadMetadataToken(CodedIndex.ResolutionScope);
			string name = ReadString();
			TypeReference typeReference2 = new TypeReference(ReadString(), name, module, null);
			typeReference2.token = new MetadataToken(TokenType.TypeRef, rid);
			metadata.AddTypeReference(typeReference2);
			IMetadataScope scope;
			if (metadataToken.TokenType == TokenType.TypeRef)
			{
				typeReference = GetTypeDefOrRef(metadataToken);
				IMetadataScope metadataScope2;
				if (typeReference == null)
				{
					IMetadataScope metadataScope = module;
					metadataScope2 = metadataScope;
				}
				else
				{
					metadataScope2 = typeReference.Scope;
				}
				scope = metadataScope2;
			}
			else
			{
				scope = GetTypeReferenceScope(metadataToken);
			}
			typeReference2.scope = scope;
			typeReference2.DeclaringType = typeReference;
			MetadataSystem.TryProcessPrimitiveTypeReference(typeReference2);
			return typeReference2;
		}

		private IMetadataScope GetTypeReferenceScope(MetadataToken scope)
		{
			if (scope.TokenType == TokenType.Module)
			{
				return module;
			}
			IMetadataScope[] array;
			switch (scope.TokenType)
			{
			case TokenType.AssemblyRef:
				InitializeAssemblyReferences();
				array = metadata.AssemblyReferences;
				break;
			case TokenType.ModuleRef:
				InitializeModuleReferences();
				array = metadata.ModuleReferences;
				break;
			default:
				throw new NotSupportedException();
			}
			uint num = scope.RID - 1;
			if (num < 0 || num >= array.Length)
			{
				return null;
			}
			return array[num];
		}

		public IEnumerable<TypeReference> GetTypeReferences()
		{
			InitializeTypeReferences();
			int tableLength = image.GetTableLength(Table.TypeRef);
			TypeReference[] array = new TypeReference[tableLength];
			for (uint num = 1u; num <= tableLength; num++)
			{
				array[num - 1] = GetTypeReference(num);
			}
			return array;
		}

		private TypeReference GetTypeSpecification(uint rid)
		{
			if (!MoveTo(Table.TypeSpec, rid))
			{
				return null;
			}
			TypeReference typeReference = ReadSignature(ReadBlobIndex()).ReadTypeSignature();
			if (typeReference.token.RID == 0)
			{
				typeReference.token = new MetadataToken(TokenType.TypeSpec, rid);
			}
			return typeReference;
		}

		private SignatureReader ReadSignature(uint signature)
		{
			return new SignatureReader(signature, this);
		}

		public bool HasInterfaces(TypeDefinition type)
		{
			InitializeInterfaces();
			MetadataToken[] mapping;
			return metadata.TryGetInterfaceMapping(type, out mapping);
		}

		public Mono.Collections.Generic.Collection<TypeReference> ReadInterfaces(TypeDefinition type)
		{
			InitializeInterfaces();
			if (!metadata.TryGetInterfaceMapping(type, out var mapping))
			{
				return new Mono.Collections.Generic.Collection<TypeReference>();
			}
			Mono.Collections.Generic.Collection<TypeReference> collection = new Mono.Collections.Generic.Collection<TypeReference>(mapping.Length);
			context = type;
			for (int i = 0; i < mapping.Length; i++)
			{
				collection.Add(GetTypeDefOrRef(mapping[i]));
			}
			metadata.RemoveInterfaceMapping(type);
			return collection;
		}

		private void InitializeInterfaces()
		{
			if (metadata.Interfaces == null)
			{
				int num = MoveTo(Table.InterfaceImpl);
				metadata.Interfaces = new Dictionary<uint, MetadataToken[]>(num);
				for (int i = 0; i < num; i++)
				{
					uint type = ReadTableIndex(Table.TypeDef);
					MetadataToken metadataToken = ReadMetadataToken(CodedIndex.TypeDefOrRef);
					AddInterfaceMapping(type, metadataToken);
				}
			}
		}

		private void AddInterfaceMapping(uint type, MetadataToken @interface)
		{
			metadata.SetInterfaceMapping(type, AddMapping(metadata.Interfaces, type, @interface));
		}

		public Mono.Collections.Generic.Collection<FieldDefinition> ReadFields(TypeDefinition type)
		{
			Range fields_range = type.fields_range;
			if (fields_range.Length == 0)
			{
				return new MemberDefinitionCollection<FieldDefinition>(type);
			}
			MemberDefinitionCollection<FieldDefinition> memberDefinitionCollection = new MemberDefinitionCollection<FieldDefinition>(type, (int)fields_range.Length);
			context = type;
			if (!MoveTo(Table.FieldPtr, fields_range.Start))
			{
				if (!MoveTo(Table.Field, fields_range.Start))
				{
					return memberDefinitionCollection;
				}
				for (uint num = 0u; num < fields_range.Length; num++)
				{
					ReadField(fields_range.Start + num, memberDefinitionCollection);
				}
			}
			else
			{
				ReadPointers(Table.FieldPtr, Table.Field, fields_range, memberDefinitionCollection, ReadField);
			}
			return memberDefinitionCollection;
		}

		private void ReadField(uint field_rid, Mono.Collections.Generic.Collection<FieldDefinition> fields)
		{
			FieldAttributes attributes = (FieldAttributes)ReadUInt16();
			string name = ReadString();
			uint signature = ReadBlobIndex();
			FieldDefinition fieldDefinition = new FieldDefinition(name, attributes, ReadFieldType(signature));
			fieldDefinition.token = new MetadataToken(TokenType.Field, field_rid);
			metadata.AddFieldDefinition(fieldDefinition);
			if (!IsDeleted(fieldDefinition))
			{
				fields.Add(fieldDefinition);
			}
		}

		private void InitializeFields()
		{
			if (metadata.Fields == null)
			{
				metadata.Fields = new FieldDefinition[image.GetTableLength(Table.Field)];
			}
		}

		private TypeReference ReadFieldType(uint signature)
		{
			SignatureReader signatureReader = ReadSignature(signature);
			if (signatureReader.ReadByte() != 6)
			{
				throw new NotSupportedException();
			}
			return signatureReader.ReadTypeSignature();
		}

		public int ReadFieldRVA(FieldDefinition field)
		{
			InitializeFieldRVAs();
			uint rID = field.token.RID;
			if (!metadata.FieldRVAs.TryGetValue(rID, out var value))
			{
				return 0;
			}
			int fieldTypeSize = GetFieldTypeSize(field.FieldType);
			if (fieldTypeSize == 0 || value == 0)
			{
				return 0;
			}
			metadata.FieldRVAs.Remove(rID);
			field.InitialValue = GetFieldInitializeValue(fieldTypeSize, value);
			return (int)value;
		}

		private byte[] GetFieldInitializeValue(int size, uint rva)
		{
			Section sectionAtVirtualAddress = image.GetSectionAtVirtualAddress(rva);
			if (sectionAtVirtualAddress == null)
			{
				return Empty<byte>.Array;
			}
			byte[] array = new byte[size];
			Buffer.BlockCopy(sectionAtVirtualAddress.Data, (int)(rva - sectionAtVirtualAddress.VirtualAddress), array, 0, size);
			return array;
		}

		private static int GetFieldTypeSize(TypeReference type)
		{
			int result = 0;
			switch (type.etype)
			{
			case ElementType.Boolean:
			case ElementType.I1:
			case ElementType.U1:
				result = 1;
				break;
			case ElementType.Char:
			case ElementType.I2:
			case ElementType.U2:
				result = 2;
				break;
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.R4:
				result = 4;
				break;
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R8:
				result = 8;
				break;
			case ElementType.Ptr:
			case ElementType.FnPtr:
				result = IntPtr.Size;
				break;
			case ElementType.CModReqD:
			case ElementType.CModOpt:
				return GetFieldTypeSize(((IModifierType)type).ElementType);
			default:
			{
				TypeDefinition typeDefinition = type.Resolve();
				if (typeDefinition != null && typeDefinition.HasLayoutInfo)
				{
					result = typeDefinition.ClassSize;
				}
				break;
			}
			}
			return result;
		}

		private void InitializeFieldRVAs()
		{
			if (metadata.FieldRVAs == null)
			{
				int num = MoveTo(Table.FieldRVA);
				Dictionary<uint, uint> dictionary = (metadata.FieldRVAs = new Dictionary<uint, uint>(num));
				for (int i = 0; i < num; i++)
				{
					uint value = ReadUInt32();
					uint key = ReadTableIndex(Table.Field);
					dictionary.Add(key, value);
				}
			}
		}

		public int ReadFieldLayout(FieldDefinition field)
		{
			InitializeFieldLayouts();
			uint rID = field.token.RID;
			if (!metadata.FieldLayouts.TryGetValue(rID, out var value))
			{
				return -1;
			}
			metadata.FieldLayouts.Remove(rID);
			return (int)value;
		}

		private void InitializeFieldLayouts()
		{
			if (metadata.FieldLayouts == null)
			{
				int num = MoveTo(Table.FieldLayout);
				Dictionary<uint, uint> dictionary = (metadata.FieldLayouts = new Dictionary<uint, uint>(num));
				for (int i = 0; i < num; i++)
				{
					uint value = ReadUInt32();
					uint key = ReadTableIndex(Table.Field);
					dictionary.Add(key, value);
				}
			}
		}

		public bool HasEvents(TypeDefinition type)
		{
			InitializeEvents();
			if (!metadata.TryGetEventsRange(type, out var range))
			{
				return false;
			}
			return range.Length != 0;
		}

		public Mono.Collections.Generic.Collection<EventDefinition> ReadEvents(TypeDefinition type)
		{
			InitializeEvents();
			if (!metadata.TryGetEventsRange(type, out var range))
			{
				return new MemberDefinitionCollection<EventDefinition>(type);
			}
			MemberDefinitionCollection<EventDefinition> memberDefinitionCollection = new MemberDefinitionCollection<EventDefinition>(type, (int)range.Length);
			metadata.RemoveEventsRange(type);
			if (range.Length == 0)
			{
				return memberDefinitionCollection;
			}
			context = type;
			if (!MoveTo(Table.EventPtr, range.Start))
			{
				if (!MoveTo(Table.Event, range.Start))
				{
					return memberDefinitionCollection;
				}
				for (uint num = 0u; num < range.Length; num++)
				{
					ReadEvent(range.Start + num, memberDefinitionCollection);
				}
			}
			else
			{
				ReadPointers(Table.EventPtr, Table.Event, range, memberDefinitionCollection, ReadEvent);
			}
			return memberDefinitionCollection;
		}

		private void ReadEvent(uint event_rid, Mono.Collections.Generic.Collection<EventDefinition> events)
		{
			EventAttributes attributes = (EventAttributes)ReadUInt16();
			string name = ReadString();
			TypeReference typeDefOrRef = GetTypeDefOrRef(ReadMetadataToken(CodedIndex.TypeDefOrRef));
			EventDefinition eventDefinition = new EventDefinition(name, attributes, typeDefOrRef);
			eventDefinition.token = new MetadataToken(TokenType.Event, event_rid);
			if (!IsDeleted(eventDefinition))
			{
				events.Add(eventDefinition);
			}
		}

		private void InitializeEvents()
		{
			if (metadata.Events == null)
			{
				int num = MoveTo(Table.EventMap);
				metadata.Events = new Dictionary<uint, Range>(num);
				for (uint num2 = 1u; num2 <= num; num2++)
				{
					uint type_rid = ReadTableIndex(Table.TypeDef);
					Range range = ReadEventsRange(num2);
					metadata.AddEventsRange(type_rid, range);
				}
			}
		}

		private Range ReadEventsRange(uint rid)
		{
			return ReadListRange(rid, Table.EventMap, Table.Event);
		}

		public bool HasProperties(TypeDefinition type)
		{
			InitializeProperties();
			if (!metadata.TryGetPropertiesRange(type, out var range))
			{
				return false;
			}
			return range.Length != 0;
		}

		public Mono.Collections.Generic.Collection<PropertyDefinition> ReadProperties(TypeDefinition type)
		{
			InitializeProperties();
			if (!metadata.TryGetPropertiesRange(type, out var range))
			{
				return new MemberDefinitionCollection<PropertyDefinition>(type);
			}
			metadata.RemovePropertiesRange(type);
			MemberDefinitionCollection<PropertyDefinition> memberDefinitionCollection = new MemberDefinitionCollection<PropertyDefinition>(type, (int)range.Length);
			if (range.Length == 0)
			{
				return memberDefinitionCollection;
			}
			context = type;
			if (!MoveTo(Table.PropertyPtr, range.Start))
			{
				if (!MoveTo(Table.Property, range.Start))
				{
					return memberDefinitionCollection;
				}
				for (uint num = 0u; num < range.Length; num++)
				{
					ReadProperty(range.Start + num, memberDefinitionCollection);
				}
			}
			else
			{
				ReadPointers(Table.PropertyPtr, Table.Property, range, memberDefinitionCollection, ReadProperty);
			}
			return memberDefinitionCollection;
		}

		private void ReadProperty(uint property_rid, Mono.Collections.Generic.Collection<PropertyDefinition> properties)
		{
			PropertyAttributes attributes = (PropertyAttributes)ReadUInt16();
			string name = ReadString();
			uint signature = ReadBlobIndex();
			SignatureReader signatureReader = ReadSignature(signature);
			byte num = signatureReader.ReadByte();
			if ((num & 8) == 0)
			{
				throw new NotSupportedException();
			}
			bool hasThis = (num & 0x20) != 0;
			signatureReader.ReadCompressedUInt32();
			PropertyDefinition propertyDefinition = new PropertyDefinition(name, attributes, signatureReader.ReadTypeSignature());
			propertyDefinition.HasThis = hasThis;
			propertyDefinition.token = new MetadataToken(TokenType.Property, property_rid);
			if (!IsDeleted(propertyDefinition))
			{
				properties.Add(propertyDefinition);
			}
		}

		private void InitializeProperties()
		{
			if (metadata.Properties == null)
			{
				int num = MoveTo(Table.PropertyMap);
				metadata.Properties = new Dictionary<uint, Range>(num);
				for (uint num2 = 1u; num2 <= num; num2++)
				{
					uint type_rid = ReadTableIndex(Table.TypeDef);
					Range range = ReadPropertiesRange(num2);
					metadata.AddPropertiesRange(type_rid, range);
				}
			}
		}

		private Range ReadPropertiesRange(uint rid)
		{
			return ReadListRange(rid, Table.PropertyMap, Table.Property);
		}

		private MethodSemanticsAttributes ReadMethodSemantics(MethodDefinition method)
		{
			InitializeMethodSemantics();
			if (!metadata.Semantics.TryGetValue(method.token.RID, out var value))
			{
				return MethodSemanticsAttributes.None;
			}
			TypeDefinition declaringType = method.DeclaringType;
			switch (value.Col1)
			{
			case MethodSemanticsAttributes.AddOn:
				GetEvent(declaringType, value.Col2).add_method = method;
				break;
			case MethodSemanticsAttributes.Fire:
				GetEvent(declaringType, value.Col2).invoke_method = method;
				break;
			case MethodSemanticsAttributes.RemoveOn:
				GetEvent(declaringType, value.Col2).remove_method = method;
				break;
			case MethodSemanticsAttributes.Getter:
				GetProperty(declaringType, value.Col2).get_method = method;
				break;
			case MethodSemanticsAttributes.Setter:
				GetProperty(declaringType, value.Col2).set_method = method;
				break;
			case MethodSemanticsAttributes.Other:
				switch (value.Col2.TokenType)
				{
				case TokenType.Event:
				{
					EventDefinition eventDefinition = GetEvent(declaringType, value.Col2);
					if (eventDefinition.other_methods == null)
					{
						eventDefinition.other_methods = new Mono.Collections.Generic.Collection<MethodDefinition>();
					}
					eventDefinition.other_methods.Add(method);
					break;
				}
				case TokenType.Property:
				{
					PropertyDefinition property = GetProperty(declaringType, value.Col2);
					if (property.other_methods == null)
					{
						property.other_methods = new Mono.Collections.Generic.Collection<MethodDefinition>();
					}
					property.other_methods.Add(method);
					break;
				}
				default:
					throw new NotSupportedException();
				}
				break;
			default:
				throw new NotSupportedException();
			}
			metadata.Semantics.Remove(method.token.RID);
			return value.Col1;
		}

		private static EventDefinition GetEvent(TypeDefinition type, MetadataToken token)
		{
			if (token.TokenType != TokenType.Event)
			{
				throw new ArgumentException();
			}
			return GetMember(type.Events, token);
		}

		private static PropertyDefinition GetProperty(TypeDefinition type, MetadataToken token)
		{
			if (token.TokenType != TokenType.Property)
			{
				throw new ArgumentException();
			}
			return GetMember(type.Properties, token);
		}

		private static TMember GetMember<TMember>(Mono.Collections.Generic.Collection<TMember> members, MetadataToken token) where TMember : IMemberDefinition
		{
			for (int i = 0; i < members.Count; i++)
			{
				TMember result = members[i];
				if (result.MetadataToken == token)
				{
					return result;
				}
			}
			throw new ArgumentException();
		}

		private void InitializeMethodSemantics()
		{
			if (metadata.Semantics == null)
			{
				int num = MoveTo(Table.MethodSemantics);
				Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>> dictionary = (metadata.Semantics = new Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>>(0));
				for (uint num2 = 0u; num2 < num; num2++)
				{
					MethodSemanticsAttributes col = (MethodSemanticsAttributes)ReadUInt16();
					uint key = ReadTableIndex(Table.Method);
					MetadataToken col2 = ReadMetadataToken(CodedIndex.HasSemantics);
					dictionary[key] = new Row<MethodSemanticsAttributes, MetadataToken>(col, col2);
				}
			}
		}

		public PropertyDefinition ReadMethods(PropertyDefinition property)
		{
			ReadAllSemantics(property.DeclaringType);
			return property;
		}

		public EventDefinition ReadMethods(EventDefinition @event)
		{
			ReadAllSemantics(@event.DeclaringType);
			return @event;
		}

		public MethodSemanticsAttributes ReadAllSemantics(MethodDefinition method)
		{
			ReadAllSemantics(method.DeclaringType);
			return method.SemanticsAttributes;
		}

		private void ReadAllSemantics(TypeDefinition type)
		{
			Mono.Collections.Generic.Collection<MethodDefinition> methods = type.Methods;
			for (int i = 0; i < methods.Count; i++)
			{
				MethodDefinition methodDefinition = methods[i];
				if (!methodDefinition.sem_attrs_ready)
				{
					methodDefinition.sem_attrs = ReadMethodSemantics(methodDefinition);
					methodDefinition.sem_attrs_ready = true;
				}
			}
		}

		private Range ReadParametersRange(uint method_rid)
		{
			return ReadListRange(method_rid, Table.Method, Table.Param);
		}

		public Mono.Collections.Generic.Collection<MethodDefinition> ReadMethods(TypeDefinition type)
		{
			Range methods_range = type.methods_range;
			if (methods_range.Length == 0)
			{
				return new MemberDefinitionCollection<MethodDefinition>(type);
			}
			MemberDefinitionCollection<MethodDefinition> memberDefinitionCollection = new MemberDefinitionCollection<MethodDefinition>(type, (int)methods_range.Length);
			if (!MoveTo(Table.MethodPtr, methods_range.Start))
			{
				if (!MoveTo(Table.Method, methods_range.Start))
				{
					return memberDefinitionCollection;
				}
				for (uint num = 0u; num < methods_range.Length; num++)
				{
					ReadMethod(methods_range.Start + num, memberDefinitionCollection);
				}
			}
			else
			{
				ReadPointers(Table.MethodPtr, Table.Method, methods_range, memberDefinitionCollection, ReadMethod);
			}
			return memberDefinitionCollection;
		}

		private void ReadPointers<TMember>(Table ptr, Table table, Range range, Mono.Collections.Generic.Collection<TMember> members, Action<uint, Mono.Collections.Generic.Collection<TMember>> reader) where TMember : IMemberDefinition
		{
			for (uint num = 0u; num < range.Length; num++)
			{
				MoveTo(ptr, range.Start + num);
				uint num2 = ReadTableIndex(table);
				MoveTo(table, num2);
				reader(num2, members);
			}
		}

		private static bool IsDeleted(IMemberDefinition member)
		{
			if (member.IsSpecialName)
			{
				return member.Name == "_Deleted";
			}
			return false;
		}

		private void InitializeMethods()
		{
			if (metadata.Methods == null)
			{
				metadata.Methods = new MethodDefinition[image.GetTableLength(Table.Method)];
			}
		}

		private void ReadMethod(uint method_rid, Mono.Collections.Generic.Collection<MethodDefinition> methods)
		{
			MethodDefinition methodDefinition = new MethodDefinition();
			methodDefinition.rva = ReadUInt32();
			methodDefinition.ImplAttributes = (MethodImplAttributes)ReadUInt16();
			methodDefinition.Attributes = (MethodAttributes)ReadUInt16();
			methodDefinition.Name = ReadString();
			methodDefinition.token = new MetadataToken(TokenType.Method, method_rid);
			if (!IsDeleted(methodDefinition))
			{
				methods.Add(methodDefinition);
				uint signature = ReadBlobIndex();
				Range param_range = ReadParametersRange(method_rid);
				context = methodDefinition;
				ReadMethodSignature(signature, methodDefinition);
				metadata.AddMethodDefinition(methodDefinition);
				if (param_range.Length != 0)
				{
					int num = position;
					ReadParameters(methodDefinition, param_range);
					position = num;
				}
			}
		}

		private void ReadParameters(MethodDefinition method, Range param_range)
		{
			if (!MoveTo(Table.ParamPtr, param_range.Start))
			{
				if (MoveTo(Table.Param, param_range.Start))
				{
					for (uint num = 0u; num < param_range.Length; num++)
					{
						ReadParameter(param_range.Start + num, method);
					}
				}
			}
			else
			{
				ReadParameterPointers(method, param_range);
			}
		}

		private void ReadParameterPointers(MethodDefinition method, Range range)
		{
			for (uint num = 0u; num < range.Length; num++)
			{
				MoveTo(Table.ParamPtr, range.Start + num);
				uint num2 = ReadTableIndex(Table.Param);
				MoveTo(Table.Param, num2);
				ReadParameter(num2, method);
			}
		}

		private void ReadParameter(uint param_rid, MethodDefinition method)
		{
			ParameterAttributes attributes = (ParameterAttributes)ReadUInt16();
			ushort num = ReadUInt16();
			string name = ReadString();
			ParameterDefinition obj = ((num == 0) ? method.MethodReturnType.Parameter : method.Parameters[num - 1]);
			obj.token = new MetadataToken(TokenType.Param, param_rid);
			obj.Name = name;
			obj.Attributes = attributes;
		}

		private void ReadMethodSignature(uint signature, IMethodSignature method)
		{
			ReadSignature(signature).ReadMethodSignature(method);
		}

		public PInvokeInfo ReadPInvokeInfo(MethodDefinition method)
		{
			InitializePInvokes();
			uint rID = method.token.RID;
			if (!metadata.PInvokes.TryGetValue(rID, out var value))
			{
				return null;
			}
			metadata.PInvokes.Remove(rID);
			return new PInvokeInfo(value.Col1, image.StringHeap.Read(value.Col2), module.ModuleReferences[(int)(value.Col3 - 1)]);
		}

		private void InitializePInvokes()
		{
			if (metadata.PInvokes != null)
			{
				return;
			}
			int num = MoveTo(Table.ImplMap);
			Dictionary<uint, Row<PInvokeAttributes, uint, uint>> dictionary = (metadata.PInvokes = new Dictionary<uint, Row<PInvokeAttributes, uint, uint>>(num));
			for (int i = 1; i <= num; i++)
			{
				PInvokeAttributes col = (PInvokeAttributes)ReadUInt16();
				MetadataToken metadataToken = ReadMetadataToken(CodedIndex.MemberForwarded);
				uint col2 = ReadStringIndex();
				uint col3 = ReadTableIndex(Table.File);
				if (metadataToken.TokenType == TokenType.Method)
				{
					dictionary.Add(metadataToken.RID, new Row<PInvokeAttributes, uint, uint>(col, col2, col3));
				}
			}
		}

		public bool HasGenericParameters(IGenericParameterProvider provider)
		{
			InitializeGenericParameters();
			if (!metadata.TryGetGenericParameterRanges(provider, out var ranges))
			{
				return false;
			}
			return RangesSize(ranges) > 0;
		}

		public Mono.Collections.Generic.Collection<GenericParameter> ReadGenericParameters(IGenericParameterProvider provider)
		{
			InitializeGenericParameters();
			if (!metadata.TryGetGenericParameterRanges(provider, out var ranges))
			{
				return new GenericParameterCollection(provider);
			}
			metadata.RemoveGenericParameterRange(provider);
			GenericParameterCollection genericParameterCollection = new GenericParameterCollection(provider, RangesSize(ranges));
			for (int i = 0; i < ranges.Length; i++)
			{
				ReadGenericParametersRange(ranges[i], provider, genericParameterCollection);
			}
			return genericParameterCollection;
		}

		private void ReadGenericParametersRange(Range range, IGenericParameterProvider provider, GenericParameterCollection generic_parameters)
		{
			if (MoveTo(Table.GenericParam, range.Start))
			{
				for (uint num = 0u; num < range.Length; num++)
				{
					ReadUInt16();
					GenericParameterAttributes attributes = (GenericParameterAttributes)ReadUInt16();
					ReadMetadataToken(CodedIndex.TypeOrMethodDef);
					GenericParameter genericParameter = new GenericParameter(ReadString(), provider);
					genericParameter.token = new MetadataToken(TokenType.GenericParam, range.Start + num);
					genericParameter.Attributes = attributes;
					generic_parameters.Add(genericParameter);
				}
			}
		}

		private void InitializeGenericParameters()
		{
			if (metadata.GenericParameters == null)
			{
				metadata.GenericParameters = InitializeRanges(Table.GenericParam, delegate
				{
					Advance(4);
					MetadataToken result = ReadMetadataToken(CodedIndex.TypeOrMethodDef);
					ReadStringIndex();
					return result;
				});
			}
		}

		private Dictionary<MetadataToken, Range[]> InitializeRanges(Table table, Func<MetadataToken> get_next)
		{
			int num = MoveTo(table);
			Dictionary<MetadataToken, Range[]> dictionary = new Dictionary<MetadataToken, Range[]>(num);
			if (num == 0)
			{
				return dictionary;
			}
			MetadataToken metadataToken = MetadataToken.Zero;
			Range range = new Range(1u, 0u);
			for (uint num2 = 1u; num2 <= num; num2++)
			{
				MetadataToken metadataToken2 = get_next();
				if (num2 == 1)
				{
					metadataToken = metadataToken2;
					range.Length++;
				}
				else if (metadataToken2 != metadataToken)
				{
					AddRange(dictionary, metadataToken, range);
					range = new Range(num2, 1u);
					metadataToken = metadataToken2;
				}
				else
				{
					range.Length++;
				}
			}
			AddRange(dictionary, metadataToken, range);
			return dictionary;
		}

		private static void AddRange(Dictionary<MetadataToken, Range[]> ranges, MetadataToken owner, Range range)
		{
			if (owner.RID != 0)
			{
				if (!ranges.TryGetValue(owner, out var value))
				{
					ranges.Add(owner, new Range[1] { range });
				}
				else
				{
					value = value.Resize(value.Length + 1);
					value[^1] = range;
					ranges[owner] = value;
				}
			}
		}

		public bool HasGenericConstraints(GenericParameter generic_parameter)
		{
			InitializeGenericConstraints();
			if (!metadata.TryGetGenericConstraintMapping(generic_parameter, out var mapping))
			{
				return false;
			}
			return mapping.Length != 0;
		}

		public Mono.Collections.Generic.Collection<TypeReference> ReadGenericConstraints(GenericParameter generic_parameter)
		{
			InitializeGenericConstraints();
			if (!metadata.TryGetGenericConstraintMapping(generic_parameter, out var mapping))
			{
				return new Mono.Collections.Generic.Collection<TypeReference>();
			}
			Mono.Collections.Generic.Collection<TypeReference> collection = new Mono.Collections.Generic.Collection<TypeReference>(mapping.Length);
			context = (IGenericContext)generic_parameter.Owner;
			for (int i = 0; i < mapping.Length; i++)
			{
				collection.Add(GetTypeDefOrRef(mapping[i]));
			}
			metadata.RemoveGenericConstraintMapping(generic_parameter);
			return collection;
		}

		private void InitializeGenericConstraints()
		{
			if (metadata.GenericConstraints == null)
			{
				int num = MoveTo(Table.GenericParamConstraint);
				metadata.GenericConstraints = new Dictionary<uint, MetadataToken[]>(num);
				for (int i = 1; i <= num; i++)
				{
					AddGenericConstraintMapping(ReadTableIndex(Table.GenericParam), ReadMetadataToken(CodedIndex.TypeDefOrRef));
				}
			}
		}

		private void AddGenericConstraintMapping(uint generic_parameter, MetadataToken constraint)
		{
			metadata.SetGenericConstraintMapping(generic_parameter, AddMapping(metadata.GenericConstraints, generic_parameter, constraint));
		}

		public bool HasOverrides(MethodDefinition method)
		{
			InitializeOverrides();
			if (!metadata.TryGetOverrideMapping(method, out var mapping))
			{
				return false;
			}
			return mapping.Length != 0;
		}

		public Mono.Collections.Generic.Collection<MethodReference> ReadOverrides(MethodDefinition method)
		{
			InitializeOverrides();
			if (!metadata.TryGetOverrideMapping(method, out var mapping))
			{
				return new Mono.Collections.Generic.Collection<MethodReference>();
			}
			Mono.Collections.Generic.Collection<MethodReference> collection = new Mono.Collections.Generic.Collection<MethodReference>(mapping.Length);
			context = method;
			for (int i = 0; i < mapping.Length; i++)
			{
				collection.Add((MethodReference)LookupToken(mapping[i]));
			}
			metadata.RemoveOverrideMapping(method);
			return collection;
		}

		private void InitializeOverrides()
		{
			if (metadata.Overrides != null)
			{
				return;
			}
			int num = MoveTo(Table.MethodImpl);
			metadata.Overrides = new Dictionary<uint, MetadataToken[]>(num);
			for (int i = 1; i <= num; i++)
			{
				ReadTableIndex(Table.TypeDef);
				MetadataToken metadataToken = ReadMetadataToken(CodedIndex.MethodDefOrRef);
				if (metadataToken.TokenType != TokenType.Method)
				{
					throw new NotSupportedException();
				}
				MetadataToken metadataToken2 = ReadMetadataToken(CodedIndex.MethodDefOrRef);
				AddOverrideMapping(metadataToken.RID, metadataToken2);
			}
		}

		private void AddOverrideMapping(uint method_rid, MetadataToken @override)
		{
			metadata.SetOverrideMapping(method_rid, AddMapping(metadata.Overrides, method_rid, @override));
		}

		public Mono.Cecil.Cil.MethodBody ReadMethodBody(MethodDefinition method)
		{
			return code.ReadMethodBody(method);
		}

		public CallSite ReadCallSite(MetadataToken token)
		{
			if (!MoveTo(Table.StandAloneSig, token.RID))
			{
				return null;
			}
			uint signature = ReadBlobIndex();
			CallSite callSite = new CallSite();
			ReadMethodSignature(signature, callSite);
			callSite.MetadataToken = token;
			return callSite;
		}

		public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token)
		{
			if (!MoveTo(Table.StandAloneSig, local_var_token.RID))
			{
				return null;
			}
			SignatureReader signatureReader = ReadSignature(ReadBlobIndex());
			if (signatureReader.ReadByte() != 7)
			{
				throw new NotSupportedException();
			}
			uint num = signatureReader.ReadCompressedUInt32();
			if (num == 0)
			{
				return null;
			}
			VariableDefinitionCollection variableDefinitionCollection = new VariableDefinitionCollection((int)num);
			for (int i = 0; i < num; i++)
			{
				variableDefinitionCollection.Add(new VariableDefinition(signatureReader.ReadTypeSignature()));
			}
			return variableDefinitionCollection;
		}

		public IMetadataTokenProvider LookupToken(MetadataToken token)
		{
			uint rID = token.RID;
			if (rID == 0)
			{
				return null;
			}
			int num = position;
			IGenericContext genericContext = context;
			IMetadataTokenProvider result;
			switch (token.TokenType)
			{
			case TokenType.TypeDef:
				result = GetTypeDefinition(rID);
				break;
			case TokenType.TypeRef:
				result = GetTypeReference(rID);
				break;
			case TokenType.TypeSpec:
				result = GetTypeSpecification(rID);
				break;
			case TokenType.Field:
				result = GetFieldDefinition(rID);
				break;
			case TokenType.Method:
				result = GetMethodDefinition(rID);
				break;
			case TokenType.MemberRef:
				result = GetMemberReference(rID);
				break;
			case TokenType.MethodSpec:
				result = GetMethodSpecification(rID);
				break;
			default:
				return null;
			}
			position = num;
			context = genericContext;
			return result;
		}

		public FieldDefinition GetFieldDefinition(uint rid)
		{
			InitializeTypeDefinitions();
			FieldDefinition fieldDefinition = metadata.GetFieldDefinition(rid);
			if (fieldDefinition != null)
			{
				return fieldDefinition;
			}
			return LookupField(rid);
		}

		private FieldDefinition LookupField(uint rid)
		{
			TypeDefinition fieldDeclaringType = metadata.GetFieldDeclaringType(rid);
			if (fieldDeclaringType == null)
			{
				return null;
			}
			InitializeCollection(fieldDeclaringType.Fields);
			return metadata.GetFieldDefinition(rid);
		}

		public MethodDefinition GetMethodDefinition(uint rid)
		{
			InitializeTypeDefinitions();
			MethodDefinition methodDefinition = metadata.GetMethodDefinition(rid);
			if (methodDefinition != null)
			{
				return methodDefinition;
			}
			return LookupMethod(rid);
		}

		private MethodDefinition LookupMethod(uint rid)
		{
			TypeDefinition methodDeclaringType = metadata.GetMethodDeclaringType(rid);
			if (methodDeclaringType == null)
			{
				return null;
			}
			InitializeCollection(methodDeclaringType.Methods);
			return metadata.GetMethodDefinition(rid);
		}

		private MethodSpecification GetMethodSpecification(uint rid)
		{
			if (!MoveTo(Table.MethodSpec, rid))
			{
				return null;
			}
			MethodReference method = (MethodReference)LookupToken(ReadMetadataToken(CodedIndex.MethodDefOrRef));
			uint signature = ReadBlobIndex();
			MethodSpecification methodSpecification = ReadMethodSpecSignature(signature, method);
			methodSpecification.token = new MetadataToken(TokenType.MethodSpec, rid);
			return methodSpecification;
		}

		private MethodSpecification ReadMethodSpecSignature(uint signature, MethodReference method)
		{
			SignatureReader signatureReader = ReadSignature(signature);
			if (signatureReader.ReadByte() != 10)
			{
				throw new NotSupportedException();
			}
			GenericInstanceMethod genericInstanceMethod = new GenericInstanceMethod(method);
			signatureReader.ReadGenericInstanceSignature(method, genericInstanceMethod);
			return genericInstanceMethod;
		}

		private MemberReference GetMemberReference(uint rid)
		{
			InitializeMemberReferences();
			MemberReference memberReference = metadata.GetMemberReference(rid);
			if (memberReference != null)
			{
				return memberReference;
			}
			memberReference = ReadMemberReference(rid);
			if (memberReference != null && !memberReference.ContainsGenericParameter)
			{
				metadata.AddMemberReference(memberReference);
			}
			return memberReference;
		}

		private MemberReference ReadMemberReference(uint rid)
		{
			if (!MoveTo(Table.MemberRef, rid))
			{
				return null;
			}
			MetadataToken metadataToken = ReadMetadataToken(CodedIndex.MemberRefParent);
			string name = ReadString();
			uint signature = ReadBlobIndex();
			MemberReference memberReference;
			switch (metadataToken.TokenType)
			{
			case TokenType.TypeRef:
			case TokenType.TypeDef:
			case TokenType.TypeSpec:
				memberReference = ReadTypeMemberReference(metadataToken, name, signature);
				break;
			case TokenType.Method:
				memberReference = ReadMethodMemberReference(metadataToken, name, signature);
				break;
			default:
				throw new NotSupportedException();
			}
			memberReference.token = new MetadataToken(TokenType.MemberRef, rid);
			return memberReference;
		}

		private MemberReference ReadTypeMemberReference(MetadataToken type, string name, uint signature)
		{
			TypeReference typeDefOrRef = GetTypeDefOrRef(type);
			if (!typeDefOrRef.IsArray)
			{
				context = typeDefOrRef;
			}
			MemberReference memberReference = ReadMemberReferenceSignature(signature, typeDefOrRef);
			memberReference.Name = name;
			return memberReference;
		}

		private MemberReference ReadMemberReferenceSignature(uint signature, TypeReference declaring_type)
		{
			SignatureReader signatureReader = ReadSignature(signature);
			if (signatureReader.buffer[signatureReader.position] == 6)
			{
				signatureReader.position++;
				return new FieldReference
				{
					DeclaringType = declaring_type,
					FieldType = signatureReader.ReadTypeSignature()
				};
			}
			MethodReference methodReference = new MethodReference();
			methodReference.DeclaringType = declaring_type;
			signatureReader.ReadMethodSignature(methodReference);
			return methodReference;
		}

		private MemberReference ReadMethodMemberReference(MetadataToken token, string name, uint signature)
		{
			MemberReference memberReference = ReadMemberReferenceSignature(signature, ((MethodDefinition)(context = GetMethodDefinition(token.RID))).DeclaringType);
			memberReference.Name = name;
			return memberReference;
		}

		private void InitializeMemberReferences()
		{
			if (metadata.MemberReferences == null)
			{
				metadata.MemberReferences = new MemberReference[image.GetTableLength(Table.MemberRef)];
			}
		}

		public IEnumerable<MemberReference> GetMemberReferences()
		{
			InitializeMemberReferences();
			int tableLength = image.GetTableLength(Table.MemberRef);
			TypeSystem typeSystem = module.TypeSystem;
			MethodReference methodReference = new MethodReference(string.Empty, typeSystem.Void);
			methodReference.DeclaringType = new TypeReference(string.Empty, string.Empty, module, typeSystem.Corlib);
			MemberReference[] array = new MemberReference[tableLength];
			for (uint num = 1u; num <= tableLength; num++)
			{
				context = methodReference;
				array[num - 1] = GetMemberReference(num);
			}
			return array;
		}

		private void InitializeConstants()
		{
			if (metadata.Constants == null)
			{
				int num = MoveTo(Table.Constant);
				Dictionary<MetadataToken, Row<ElementType, uint>> dictionary = (metadata.Constants = new Dictionary<MetadataToken, Row<ElementType, uint>>(num));
				for (uint num2 = 1u; num2 <= num; num2++)
				{
					ElementType col = (ElementType)ReadUInt16();
					MetadataToken key = ReadMetadataToken(CodedIndex.HasConstant);
					uint col2 = ReadBlobIndex();
					dictionary.Add(key, new Row<ElementType, uint>(col, col2));
				}
			}
		}

		public object ReadConstant(IConstantProvider owner)
		{
			InitializeConstants();
			if (!metadata.Constants.TryGetValue(owner.MetadataToken, out var value))
			{
				return Mixin.NoValue;
			}
			metadata.Constants.Remove(owner.MetadataToken);
			switch (value.Col1)
			{
			case ElementType.Class:
			case ElementType.Object:
				return null;
			case ElementType.String:
				return ReadConstantString(ReadBlob(value.Col2));
			default:
				return ReadConstantPrimitive(value.Col1, value.Col2);
			}
		}

		private static string ReadConstantString(byte[] blob)
		{
			int num = blob.Length;
			if ((num & 1) == 1)
			{
				num--;
			}
			return Encoding.Unicode.GetString(blob, 0, num);
		}

		private object ReadConstantPrimitive(ElementType type, uint signature)
		{
			return ReadSignature(signature).ReadConstantSignature(type);
		}

		private void InitializeCustomAttributes()
		{
			if (metadata.CustomAttributes == null)
			{
				metadata.CustomAttributes = InitializeRanges(Table.CustomAttribute, delegate
				{
					MetadataToken result = ReadMetadataToken(CodedIndex.HasCustomAttribute);
					ReadMetadataToken(CodedIndex.CustomAttributeType);
					ReadBlobIndex();
					return result;
				});
			}
		}

		public bool HasCustomAttributes(ICustomAttributeProvider owner)
		{
			InitializeCustomAttributes();
			if (!metadata.TryGetCustomAttributeRanges(owner, out var ranges))
			{
				return false;
			}
			return RangesSize(ranges) > 0;
		}

		public Mono.Collections.Generic.Collection<CustomAttribute> ReadCustomAttributes(ICustomAttributeProvider owner)
		{
			InitializeCustomAttributes();
			if (!metadata.TryGetCustomAttributeRanges(owner, out var ranges))
			{
				return new Mono.Collections.Generic.Collection<CustomAttribute>();
			}
			Mono.Collections.Generic.Collection<CustomAttribute> collection = new Mono.Collections.Generic.Collection<CustomAttribute>(RangesSize(ranges));
			for (int i = 0; i < ranges.Length; i++)
			{
				ReadCustomAttributeRange(ranges[i], collection);
			}
			metadata.RemoveCustomAttributeRange(owner);
			return collection;
		}

		private void ReadCustomAttributeRange(Range range, Mono.Collections.Generic.Collection<CustomAttribute> custom_attributes)
		{
			if (MoveTo(Table.CustomAttribute, range.Start))
			{
				for (int i = 0; i < range.Length; i++)
				{
					ReadMetadataToken(CodedIndex.HasCustomAttribute);
					MethodReference constructor = (MethodReference)LookupToken(ReadMetadataToken(CodedIndex.CustomAttributeType));
					uint signature = ReadBlobIndex();
					custom_attributes.Add(new CustomAttribute(signature, constructor));
				}
			}
		}

		private static int RangesSize(Range[] ranges)
		{
			uint num = 0u;
			for (int i = 0; i < ranges.Length; i++)
			{
				num += ranges[i].Length;
			}
			return (int)num;
		}

		public byte[] ReadCustomAttributeBlob(uint signature)
		{
			return ReadBlob(signature);
		}

		public void ReadCustomAttributeSignature(CustomAttribute attribute)
		{
			SignatureReader signatureReader = ReadSignature(attribute.signature);
			if (!signatureReader.CanReadMore())
			{
				return;
			}
			if (signatureReader.ReadUInt16() != 1)
			{
				throw new InvalidOperationException();
			}
			MethodReference constructor = attribute.Constructor;
			if (constructor.HasParameters)
			{
				signatureReader.ReadCustomAttributeConstructorArguments(attribute, constructor.Parameters);
			}
			if (signatureReader.CanReadMore())
			{
				ushort num = signatureReader.ReadUInt16();
				if (num != 0)
				{
					signatureReader.ReadCustomAttributeNamedArguments(num, ref attribute.fields, ref attribute.properties);
				}
			}
		}

		private void InitializeMarshalInfos()
		{
			if (metadata.FieldMarshals != null)
			{
				return;
			}
			int num = MoveTo(Table.FieldMarshal);
			Dictionary<MetadataToken, uint> dictionary = (metadata.FieldMarshals = new Dictionary<MetadataToken, uint>(num));
			for (int i = 0; i < num; i++)
			{
				MetadataToken key = ReadMetadataToken(CodedIndex.HasFieldMarshal);
				uint value = ReadBlobIndex();
				if (key.RID != 0)
				{
					dictionary.Add(key, value);
				}
			}
		}

		public bool HasMarshalInfo(IMarshalInfoProvider owner)
		{
			InitializeMarshalInfos();
			return metadata.FieldMarshals.ContainsKey(owner.MetadataToken);
		}

		public MarshalInfo ReadMarshalInfo(IMarshalInfoProvider owner)
		{
			InitializeMarshalInfos();
			if (!metadata.FieldMarshals.TryGetValue(owner.MetadataToken, out var value))
			{
				return null;
			}
			SignatureReader signatureReader = ReadSignature(value);
			metadata.FieldMarshals.Remove(owner.MetadataToken);
			return signatureReader.ReadMarshalInfo();
		}

		private void InitializeSecurityDeclarations()
		{
			if (metadata.SecurityDeclarations == null)
			{
				metadata.SecurityDeclarations = InitializeRanges(Table.DeclSecurity, delegate
				{
					ReadUInt16();
					MetadataToken result = ReadMetadataToken(CodedIndex.HasDeclSecurity);
					ReadBlobIndex();
					return result;
				});
			}
		}

		public bool HasSecurityDeclarations(ISecurityDeclarationProvider owner)
		{
			InitializeSecurityDeclarations();
			if (!metadata.TryGetSecurityDeclarationRanges(owner, out var ranges))
			{
				return false;
			}
			return RangesSize(ranges) > 0;
		}

		public Mono.Collections.Generic.Collection<SecurityDeclaration> ReadSecurityDeclarations(ISecurityDeclarationProvider owner)
		{
			InitializeSecurityDeclarations();
			if (!metadata.TryGetSecurityDeclarationRanges(owner, out var ranges))
			{
				return new Mono.Collections.Generic.Collection<SecurityDeclaration>();
			}
			Mono.Collections.Generic.Collection<SecurityDeclaration> collection = new Mono.Collections.Generic.Collection<SecurityDeclaration>(RangesSize(ranges));
			for (int i = 0; i < ranges.Length; i++)
			{
				ReadSecurityDeclarationRange(ranges[i], collection);
			}
			metadata.RemoveSecurityDeclarationRange(owner);
			return collection;
		}

		private void ReadSecurityDeclarationRange(Range range, Mono.Collections.Generic.Collection<SecurityDeclaration> security_declarations)
		{
			if (MoveTo(Table.DeclSecurity, range.Start))
			{
				for (int i = 0; i < range.Length; i++)
				{
					SecurityAction action = (SecurityAction)ReadUInt16();
					ReadMetadataToken(CodedIndex.HasDeclSecurity);
					uint signature = ReadBlobIndex();
					security_declarations.Add(new SecurityDeclaration(action, signature, module));
				}
			}
		}

		public byte[] ReadSecurityDeclarationBlob(uint signature)
		{
			return ReadBlob(signature);
		}

		public void ReadSecurityDeclarationSignature(SecurityDeclaration declaration)
		{
			uint signature = declaration.signature;
			SignatureReader signatureReader = ReadSignature(signature);
			if (signatureReader.buffer[signatureReader.position] != 46)
			{
				ReadXmlSecurityDeclaration(signature, declaration);
				return;
			}
			signatureReader.position++;
			uint num = signatureReader.ReadCompressedUInt32();
			Mono.Collections.Generic.Collection<SecurityAttribute> collection = new Mono.Collections.Generic.Collection<SecurityAttribute>((int)num);
			for (int i = 0; i < num; i++)
			{
				collection.Add(signatureReader.ReadSecurityAttribute());
			}
			declaration.security_attributes = collection;
		}

		private void ReadXmlSecurityDeclaration(uint signature, SecurityDeclaration declaration)
		{
			byte[] array = ReadBlob(signature);
			Mono.Collections.Generic.Collection<SecurityAttribute> collection = new Mono.Collections.Generic.Collection<SecurityAttribute>(1);
			SecurityAttribute securityAttribute = new SecurityAttribute(module.TypeSystem.LookupType("System.Security.Permissions", "PermissionSetAttribute"));
			securityAttribute.properties = new Mono.Collections.Generic.Collection<CustomAttributeNamedArgument>(1);
			securityAttribute.properties.Add(new CustomAttributeNamedArgument("XML", new CustomAttributeArgument(module.TypeSystem.String, Encoding.Unicode.GetString(array, 0, array.Length))));
			collection.Add(securityAttribute);
			declaration.security_attributes = collection;
		}

		public Mono.Collections.Generic.Collection<ExportedType> ReadExportedTypes()
		{
			int num = MoveTo(Table.ExportedType);
			if (num == 0)
			{
				return new Mono.Collections.Generic.Collection<ExportedType>();
			}
			Mono.Collections.Generic.Collection<ExportedType> collection = new Mono.Collections.Generic.Collection<ExportedType>(num);
			for (int i = 1; i <= num; i++)
			{
				TypeAttributes attributes = (TypeAttributes)ReadUInt32();
				uint identifier = ReadUInt32();
				string name = ReadString();
				string text = ReadString();
				MetadataToken token = ReadMetadataToken(CodedIndex.Implementation);
				ExportedType declaringType = null;
				IMetadataScope scope = null;
				switch (token.TokenType)
				{
				case TokenType.AssemblyRef:
				case TokenType.File:
					scope = GetExportedTypeScope(token);
					break;
				case TokenType.ExportedType:
					declaringType = collection[(int)(token.RID - 1)];
					break;
				}
				ExportedType exportedType = new ExportedType(text, name, module, scope)
				{
					Attributes = attributes,
					Identifier = (int)identifier,
					DeclaringType = declaringType
				};
				exportedType.token = new MetadataToken(TokenType.ExportedType, i);
				collection.Add(exportedType);
			}
			return collection;
		}

		private IMetadataScope GetExportedTypeScope(MetadataToken token)
		{
			int num = position;
			IMetadataScope result;
			switch (token.TokenType)
			{
			case TokenType.AssemblyRef:
				InitializeAssemblyReferences();
				result = metadata.AssemblyReferences[token.RID - 1];
				break;
			case TokenType.File:
				InitializeModuleReferences();
				result = GetModuleReferenceFromFile(token);
				break;
			default:
				throw new NotSupportedException();
			}
			position = num;
			return result;
		}

		private ModuleReference GetModuleReferenceFromFile(MetadataToken token)
		{
			if (!MoveTo(Table.File, token.RID))
			{
				return null;
			}
			ReadUInt32();
			string text = ReadString();
			Mono.Collections.Generic.Collection<ModuleReference> moduleReferences = module.ModuleReferences;
			ModuleReference moduleReference;
			for (int i = 0; i < moduleReferences.Count; i++)
			{
				moduleReference = moduleReferences[i];
				if (moduleReference.Name == text)
				{
					return moduleReference;
				}
			}
			moduleReference = new ModuleReference(text);
			moduleReferences.Add(moduleReference);
			return moduleReference;
		}

		private static void InitializeCollection(object o)
		{
		}
	}
	internal sealed class SignatureReader : ByteBuffer
	{
		private readonly MetadataReader reader;

		private readonly uint start;

		private readonly uint sig_length;

		private TypeSystem TypeSystem => reader.module.TypeSystem;

		public SignatureReader(uint blob, MetadataReader reader)
			: base(reader.buffer)
		{
			this.reader = reader;
			MoveToBlob(blob);
			sig_length = ReadCompressedUInt32();
			start = (uint)position;
		}

		private void MoveToBlob(uint blob)
		{
			position = (int)(reader.image.BlobHeap.Offset + blob);
		}

		private MetadataToken ReadTypeTokenSignature()
		{
			return CodedIndex.TypeDefOrRef.GetMetadataToken(ReadCompressedUInt32());
		}

		private GenericParameter GetGenericParameter(GenericParameterType type, uint var)
		{
			IGenericContext context = reader.context;
			if (context == null)
			{
				return GetUnboundGenericParameter(type, (int)var);
			}
			IGenericParameterProvider genericParameterProvider = type switch
			{
				GenericParameterType.Type => context.Type, 
				GenericParameterType.Method => context.Method, 
				_ => throw new NotSupportedException(), 
			};
			if (!context.IsDefinition)
			{
				CheckGenericContext(genericParameterProvider, (int)var);
			}
			if ((int)var >= genericParameterProvider.GenericParameters.Count)
			{
				return GetUnboundGenericParameter(type, (int)var);
			}
			return genericParameterProvider.GenericParameters[(int)var];
		}

		private GenericParameter GetUnboundGenericParameter(GenericParameterType type, int index)
		{
			return new GenericParameter(index, type, reader.module);
		}

		private static void CheckGenericContext(IGenericParameterProvider owner, int index)
		{
			Mono.Collections.Generic.Collection<GenericParameter> genericParameters = owner.GenericParameters;
			for (int i = genericParameters.Count; i <= index; i++)
			{
				genericParameters.Add(new GenericParameter(owner));
			}
		}

		public void ReadGenericInstanceSignature(IGenericParameterProvider provider, IGenericInstance instance)
		{
			uint num = ReadCompressedUInt32();
			if (!provider.IsDefinition)
			{
				CheckGenericContext(provider, (int)(num - 1));
			}
			Mono.Collections.Generic.Collection<TypeReference> genericArguments = instance.GenericArguments;
			for (int i = 0; i < num; i++)
			{
				genericArguments.Add(ReadTypeSignature());
			}
		}

		private ArrayType ReadArrayTypeSignature()
		{
			ArrayType arrayType = new ArrayType(ReadTypeSignature());
			uint num = ReadCompressedUInt32();
			uint[] array = new uint[ReadCompressedUInt32()];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = ReadCompressedUInt32();
			}
			int[] array2 = new int[ReadCompressedUInt32()];
			for (int j = 0; j < array2.Length; j++)
			{
				array2[j] = ReadCompressedInt32();
			}
			arrayType.Dimensions.Clear();
			for (int k = 0; k < num; k++)
			{
				int? num2 = null;
				int? upperBound = null;
				if (k < array2.Length)
				{
					num2 = array2[k];
				}
				if (k < array.Length)
				{
					upperBound = num2 + (int)array[k] - 1;
				}
				arrayType.Dimensions.Add(new ArrayDimension(num2, upperBound));
			}
			return arrayType;
		}

		private TypeReference GetTypeDefOrRef(MetadataToken token)
		{
			return reader.GetTypeDefOrRef(token);
		}

		public TypeReference ReadTypeSignature()
		{
			return ReadTypeSignature((ElementType)ReadByte());
		}

		private TypeReference ReadTypeSignature(ElementType etype)
		{
			switch (etype)
			{
			case ElementType.ValueType:
			{
				TypeReference typeDefOrRef2 = GetTypeDefOrRef(ReadTypeTokenSignature());
				typeDefOrRef2.IsValueType = true;
				return typeDefOrRef2;
			}
			case ElementType.Class:
				return GetTypeDefOrRef(ReadTypeTokenSignature());
			case ElementType.Ptr:
				return new PointerType(ReadTypeSignature());
			case ElementType.FnPtr:
			{
				FunctionPointerType functionPointerType = new FunctionPointerType();
				ReadMethodSignature(functionPointerType);
				return functionPointerType;
			}
			case ElementType.ByRef:
				return new ByReferenceType(ReadTypeSignature());
			case ElementType.Pinned:
				return new PinnedType(ReadTypeSignature());
			case ElementType.SzArray:
				return new ArrayType(ReadTypeSignature());
			case ElementType.Array:
				return ReadArrayTypeSignature();
			case ElementType.CModOpt:
				return new OptionalModifierType(GetTypeDefOrRef(ReadTypeTokenSignature()), ReadTypeSignature());
			case ElementType.CModReqD:
				return new RequiredModifierType(GetTypeDefOrRef(ReadTypeTokenSignature()), ReadTypeSignature());
			case ElementType.Sentinel:
				return new SentinelType(ReadTypeSignature());
			case ElementType.Var:
				return GetGenericParameter(GenericParameterType.Type, ReadCompressedUInt32());
			case ElementType.MVar:
				return GetGenericParameter(GenericParameterType.Method, ReadCompressedUInt32());
			case ElementType.GenericInst:
			{
				bool num = ReadByte() == 17;
				TypeReference typeDefOrRef = GetTypeDefOrRef(ReadTypeTokenSignature());
				GenericInstanceType genericInstanceType = new GenericInstanceType(typeDefOrRef);
				ReadGenericInstanceSignature(typeDefOrRef, genericInstanceType);
				if (num)
				{
					genericInstanceType.IsValueType = true;
					typeDefOrRef.GetElementType().IsValueType = true;
				}
				return genericInstanceType;
			}
			case ElementType.Object:
				return TypeSystem.Object;
			case ElementType.Void:
				return TypeSystem.Void;
			case ElementType.TypedByRef:
				return TypeSystem.TypedReference;
			case ElementType.I:
				return TypeSystem.IntPtr;
			case ElementType.U:
				return TypeSystem.UIntPtr;
			default:
				return GetPrimitiveType(etype);
			}
		}

		public void ReadMethodSignature(IMethodSignature method)
		{
			byte b = ReadByte();
			if ((b & 0x20) != 0)
			{
				method.HasThis = true;
				b = (byte)(b & -33);
			}
			if ((b & 0x40) != 0)
			{
				method.ExplicitThis = true;
				b = (byte)(b & -65);
			}
			method.CallingConvention = (MethodCallingConvention)b;
			MethodReference methodReference = method as MethodReference;
			if (methodReference != null && !methodReference.DeclaringType.IsArray)
			{
				reader.context = methodReference;
			}
			if ((b & 0x10) != 0)
			{
				uint num = ReadCompressedUInt32();
				if (methodReference != null && !methodReference.IsDefinition)
				{
					CheckGenericContext(methodReference, (int)(num - 1));
				}
			}
			uint num2 = ReadCompressedUInt32();
			method.MethodReturnType.ReturnType = ReadTypeSignature();
			if (num2 != 0)
			{
				Mono.Collections.Generic.Collection<ParameterDefinition> collection = ((!(method is MethodReference methodReference2)) ? method.Parameters : (methodReference2.parameters = new ParameterDefinitionCollection(method, (int)num2)));
				for (int i = 0; i < num2; i++)
				{
					collection.Add(new ParameterDefinition(ReadTypeSignature()));
				}
			}
		}

		public object ReadConstantSignature(ElementType type)
		{
			return ReadPrimitiveValue(type);
		}

		public void ReadCustomAttributeConstructorArguments(CustomAttribute attribute, Mono.Collections.Generic.Collection<ParameterDefinition> parameters)
		{
			int count = parameters.Count;
			if (count != 0)
			{
				attribute.arguments = new Mono.Collections.Generic.Collection<CustomAttributeArgument>(count);
				for (int i = 0; i < count; i++)
				{
					attribute.arguments.Add(ReadCustomAttributeFixedArgument(parameters[i].ParameterType));
				}
			}
		}

		private CustomAttributeArgument ReadCustomAttributeFixedArgument(TypeReference type)
		{
			if (type.IsArray)
			{
				return ReadCustomAttributeFixedArrayArgument((ArrayType)type);
			}
			return ReadCustomAttributeElement(type);
		}

		public void ReadCustomAttributeNamedArguments(ushort count, ref Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> fields, ref Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> properties)
		{
			for (int i = 0; i < count; i++)
			{
				ReadCustomAttributeNamedArgument(ref fields, ref properties);
			}
		}

		private void ReadCustomAttributeNamedArgument(ref Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> fields, ref Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> properties)
		{
			byte b = ReadByte();
			TypeReference type = ReadCustomAttributeFieldOrPropType();
			string name = ReadUTF8String();
			(b switch
			{
				83 => GetCustomAttributeNamedArgumentCollection(ref fields), 
				84 => GetCustomAttributeNamedArgumentCollection(ref properties), 
				_ => throw new NotSupportedException(), 
			}).Add(new CustomAttributeNamedArgument(name, ReadCustomAttributeFixedArgument(type)));
		}

		private static Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> GetCustomAttributeNamedArgumentCollection(ref Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> collection)
		{
			if (collection != null)
			{
				return collection;
			}
			return collection = new Mono.Collections.Generic.Collection<CustomAttributeNamedArgument>();
		}

		private CustomAttributeArgument ReadCustomAttributeFixedArrayArgument(ArrayType type)
		{
			uint num = ReadUInt32();
			switch (num)
			{
			case uint.MaxValue:
				return new CustomAttributeArgument(type, null);
			case 0u:
				return new CustomAttributeArgument(type, Empty<CustomAttributeArgument>.Array);
			default:
			{
				CustomAttributeArgument[] array = new CustomAttributeArgument[num];
				TypeReference elementType = type.ElementType;
				for (int i = 0; i < num; i++)
				{
					array[i] = ReadCustomAttributeElement(elementType);
				}
				return new CustomAttributeArgument(type, array);
			}
			}
		}

		private CustomAttributeArgument ReadCustomAttributeElement(TypeReference type)
		{
			if (type.IsArray)
			{
				return ReadCustomAttributeFixedArrayArgument((ArrayType)type);
			}
			return new CustomAttributeArgument(type, (type.etype == ElementType.Object) ? ((object)ReadCustomAttributeElement(ReadCustomAttributeFieldOrPropType())) : ReadCustomAttributeElementValue(type));
		}

		private object ReadCustomAttributeElementValue(TypeReference type)
		{
			ElementType etype = type.etype;
			switch (etype)
			{
			case ElementType.String:
				return ReadUTF8String();
			case ElementType.None:
				if (type.IsTypeOf("System", "Type"))
				{
					return ReadTypeReference();
				}
				return ReadCustomAttributeEnum(type);
			default:
				return ReadPrimitiveValue(etype);
			}
		}

		private object ReadPrimitiveValue(ElementType type)
		{
			return type switch
			{
				ElementType.Boolean => ReadByte() == 1, 
				ElementType.I1 => (sbyte)ReadByte(), 
				ElementType.U1 => ReadByte(), 
				ElementType.Char => (char)ReadUInt16(), 
				ElementType.I2 => ReadInt16(), 
				ElementType.U2 => ReadUInt16(), 
				ElementType.I4 => ReadInt32(), 
				ElementType.U4 => ReadUInt32(), 
				ElementType.I8 => ReadInt64(), 
				ElementType.U8 => ReadUInt64(), 
				ElementType.R4 => ReadSingle(), 
				ElementType.R8 => ReadDouble(), 
				_ => throw new NotImplementedException(type.ToString()), 
			};
		}

		private TypeReference GetPrimitiveType(ElementType etype)
		{
			return etype switch
			{
				ElementType.Boolean => TypeSystem.Boolean, 
				ElementType.Char => TypeSystem.Char, 
				ElementType.I1 => TypeSystem.SByte, 
				ElementType.U1 => TypeSystem.Byte, 
				ElementType.I2 => TypeSystem.Int16, 
				ElementType.U2 => TypeSystem.UInt16, 
				ElementType.I4 => TypeSystem.Int32, 
				ElementType.U4 => TypeSystem.UInt32, 
				ElementType.I8 => TypeSystem.Int64, 
				ElementType.U8 => TypeSystem.UInt64, 
				ElementType.R4 => TypeSystem.Single, 
				ElementType.R8 => TypeSystem.Double, 
				ElementType.String => TypeSystem.String, 
				_ => throw new NotImplementedException(etype.ToString()), 
			};
		}

		private TypeReference ReadCustomAttributeFieldOrPropType()
		{
			ElementType elementType = (ElementType)ReadByte();
			return elementType switch
			{
				ElementType.Boxed => TypeSystem.Object, 
				ElementType.SzArray => new ArrayType(ReadCustomAttributeFieldOrPropType()), 
				ElementType.Enum => ReadTypeReference(), 
				ElementType.Type => TypeSystem.LookupType("System", "Type"), 
				_ => GetPrimitiveType(elementType), 
			};
		}

		public TypeReference ReadTypeReference()
		{
			return TypeParser.ParseType(reader.module, ReadUTF8String());
		}

		private object ReadCustomAttributeEnum(TypeReference enum_type)
		{
			TypeDefinition typeDefinition = enum_type.CheckedResolve();
			if (!typeDefinition.IsEnum)
			{
				throw new ArgumentException();
			}
			return ReadCustomAttributeElementValue(typeDefinition.GetEnumUnderlyingType());
		}

		public SecurityAttribute ReadSecurityAttribute()
		{
			SecurityAttribute securityAttribute = new SecurityAttribute(ReadTypeReference());
			ReadCompressedUInt32();
			ReadCustomAttributeNamedArguments((ushort)ReadCompressedUInt32(), ref securityAttribute.fields, ref securityAttribute.properties);
			return securityAttribute;
		}

		public MarshalInfo ReadMarshalInfo()
		{
			NativeType nativeType = ReadNativeType();
			switch (nativeType)
			{
			case NativeType.Array:
			{
				ArrayMarshalInfo arrayMarshalInfo = new ArrayMarshalInfo();
				if (CanReadMore())
				{
					arrayMarshalInfo.element_type = ReadNativeType();
				}
				if (CanReadMore())
				{
					arrayMarshalInfo.size_parameter_index = (int)ReadCompressedUInt32();
				}
				if (CanReadMore())
				{
					arrayMarshalInfo.size = (int)ReadCompressedUInt32();
				}
				if (CanReadMore())
				{
					arrayMarshalInfo.size_parameter_multiplier = (int)ReadCompressedUInt32();
				}
				return arrayMarshalInfo;
			}
			case NativeType.SafeArray:
			{
				SafeArrayMarshalInfo safeArrayMarshalInfo = new SafeArrayMarshalInfo();
				if (CanReadMore())
				{
					safeArrayMarshalInfo.element_type = ReadVariantType();
				}
				return safeArrayMarshalInfo;
			}
			case NativeType.FixedArray:
			{
				FixedArrayMarshalInfo fixedArrayMarshalInfo = new FixedArrayMarshalInfo();
				if (CanReadMore())
				{
					fixedArrayMarshalInfo.size = (int)ReadCompressedUInt32();
				}
				if (CanReadMore())
				{
					fixedArrayMarshalInfo.element_type = ReadNativeType();
				}
				return fixedArrayMarshalInfo;
			}
			case NativeType.FixedSysString:
			{
				FixedSysStringMarshalInfo fixedSysStringMarshalInfo = new FixedSysStringMarshalInfo();
				if (CanReadMore())
				{
					fixedSysStringMarshalInfo.size = (int)ReadCompressedUInt32();
				}
				return fixedSysStringMarshalInfo;
			}
			case NativeType.CustomMarshaler:
			{
				CustomMarshalInfo customMarshalInfo = new CustomMarshalInfo();
				string text = ReadUTF8String();
				customMarshalInfo.guid = ((!string.IsNullOrEmpty(text)) ? new Guid(text) : Guid.Empty);
				customMarshalInfo.unmanaged_type = ReadUTF8String();
				customMarshalInfo.managed_type = ReadTypeReference();
				customMarshalInfo.cookie = ReadUTF8String();
				return customMarshalInfo;
			}
			default:
				return new MarshalInfo(nativeType);
			}
		}

		private NativeType ReadNativeType()
		{
			return (NativeType)ReadByte();
		}

		private VariantType ReadVariantType()
		{
			return (VariantType)ReadByte();
		}

		private string ReadUTF8String()
		{
			if (buffer[position] == byte.MaxValue)
			{
				position++;
				return null;
			}
			int num = (int)ReadCompressedUInt32();
			if (num == 0)
			{
				return string.Empty;
			}
			string result = Encoding.UTF8.GetString(buffer, position, (buffer[position + num - 1] == 0) ? (num - 1) : num);
			position += num;
			return result;
		}

		public bool CanReadMore()
		{
			return position - start < sig_length;
		}
	}
	internal static class ModuleWriter
	{
		public static void WriteModuleTo(ModuleDefinition module, Stream stream, WriterParameters parameters)
		{
			if ((module.Attributes & ModuleAttributes.ILOnly) == 0)
			{
				throw new NotSupportedException("Writing mixed-mode assemblies is not supported");
			}
			if (module.HasImage && module.ReadingMode == ReadingMode.Deferred)
			{
				ImmediateModuleReader.ReadModule(module);
			}
			module.MetadataSystem.Clear();
			AssemblyNameDefinition assemblyNameDefinition = ((module.assembly != null) ? module.assembly.Name : null);
			string fullyQualifiedName = stream.GetFullyQualifiedName();
			ISymbolWriterProvider symbolWriterProvider = parameters.SymbolWriterProvider;
			if (symbolWriterProvider == null && parameters.WriteSymbols)
			{
				symbolWriterProvider = SymbolProvider.GetPlatformWriterProvider();
			}
			ISymbolWriter symbolWriter = GetSymbolWriter(module, fullyQualifiedName, symbolWriterProvider);
			if (parameters.StrongNameKeyPair != null && assemblyNameDefinition != null)
			{
				assemblyNameDefinition.PublicKey = parameters.StrongNameKeyPair.PublicKey;
				module.Attributes |= ModuleAttributes.StrongNameSigned;
			}
			MetadataBuilder metadata = new MetadataBuilder(module, fullyQualifiedName, symbolWriterProvider, symbolWriter);
			BuildMetadata(module, metadata);
			if (module.symbol_reader != null)
			{
				module.symbol_reader.Dispose();
			}
			ImageWriter imageWriter = ImageWriter.CreateWriter(module, metadata, stream);
			imageWriter.WriteImage();
			if (parameters.StrongNameKeyPair != null)
			{
				CryptoService.StrongName(stream, imageWriter, parameters.StrongNameKeyPair);
			}
			symbolWriter?.Dispose();
		}

		private static void BuildMetadata(ModuleDefinition module, MetadataBuilder metadata)
		{
			if (!module.HasImage)
			{
				metadata.BuildMetadata();
				return;
			}
			module.Read(metadata, delegate(MetadataBuilder builder, MetadataReader _)
			{
				builder.BuildMetadata();
				return builder;
			});
		}

		private static ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider)
		{
			return symbol_writer_provider?.GetSymbolWriter(module, fq_name);
		}
	}
	internal abstract class MetadataTable
	{
		public abstract int Length { get; }

		public bool IsLarge => Length > 65535;

		public abstract void Write(TableHeapBuffer buffer);

		public abstract void Sort();
	}
	internal abstract class OneRowTable<TRow> : MetadataTable where TRow : struct
	{
		internal TRow row;

		public sealed override int Length => 1;

		public sealed override void Sort()
		{
		}
	}
	internal abstract class MetadataTable<TRow> : MetadataTable where TRow : struct
	{
		internal TRow[] rows = new TRow[2];

		internal int length;

		public sealed override int Length => length;

		public int AddRow(TRow row)
		{
			if (rows.Length == length)
			{
				Grow();
			}
			rows[length++] = row;
			return length;
		}

		private void Grow()
		{
			TRow[] destinationArray = new TRow[rows.Length * 2];
			Array.Copy(rows, destinationArray, rows.Length);
			rows = destinationArray;
		}

		public override void Sort()
		{
		}
	}
	internal abstract class SortedTable<TRow> : MetadataTable<TRow>, IComparer<TRow> where TRow : struct
	{
		public sealed override void Sort()
		{
			Array.Sort(rows, 0, length, this);
		}

		protected int Compare(uint x, uint y)
		{
			if (x != y)
			{
				if (x <= y)
				{
					return -1;
				}
				return 1;
			}
			return 0;
		}

		public abstract int Compare(TRow x, TRow y);
	}
	internal sealed class ModuleTable : OneRowTable<uint>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			buffer.WriteUInt16(0);
			buffer.WriteString(row);
			buffer.WriteUInt16(1);
			buffer.WriteUInt16(0);
			buffer.WriteUInt16(0);
		}
	}
	internal sealed class TypeRefTable : MetadataTable<Row<uint, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteCodedRID(rows[i].Col1, CodedIndex.ResolutionScope);
				buffer.WriteString(rows[i].Col2);
				buffer.WriteString(rows[i].Col3);
			}
		}
	}
	internal sealed class TypeDefTable : MetadataTable<Row<TypeAttributes, uint, uint, uint, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt32((uint)rows[i].Col1);
				buffer.WriteString(rows[i].Col2);
				buffer.WriteString(rows[i].Col3);
				buffer.WriteCodedRID(rows[i].Col4, CodedIndex.TypeDefOrRef);
				buffer.WriteRID(rows[i].Col5, Table.Field);
				buffer.WriteRID(rows[i].Col6, Table.Method);
			}
		}
	}
	internal sealed class FieldTable : MetadataTable<Row<FieldAttributes, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);
				buffer.WriteString(rows[i].Col2);
				buffer.WriteBlob(rows[i].Col3);
			}
		}
	}
	internal sealed class MethodTable : MetadataTable<Row<uint, MethodImplAttributes, MethodAttributes, uint, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt32(rows[i].Col1);
				buffer.WriteUInt16((ushort)rows[i].Col2);
				buffer.WriteUInt16((ushort)rows[i].Col3);
				buffer.WriteString(rows[i].Col4);
				buffer.WriteBlob(rows[i].Col5);
				buffer.WriteRID(rows[i].Col6, Table.Param);
			}
		}
	}
	internal sealed class ParamTable : MetadataTable<Row<ParameterAttributes, ushort, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);
				buffer.WriteUInt16(rows[i].Col2);
				buffer.WriteString(rows[i].Col3);
			}
		}
	}
	internal sealed class InterfaceImplTable : MetadataTable<Row<uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.TypeDef);
				buffer.WriteCodedRID(rows[i].Col2, CodedIndex.TypeDefOrRef);
			}
		}
	}
	internal sealed class MemberRefTable : MetadataTable<Row<uint, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteCodedRID(rows[i].Col1, CodedIndex.MemberRefParent);
				buffer.WriteString(rows[i].Col2);
				buffer.WriteBlob(rows[i].Col3);
			}
		}
	}
	internal sealed class ConstantTable : SortedTable<Row<ElementType, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);
				buffer.WriteCodedRID(rows[i].Col2, CodedIndex.HasConstant);
				buffer.WriteBlob(rows[i].Col3);
			}
		}

		public override int Compare(Row<ElementType, uint, uint> x, Row<ElementType, uint, uint> y)
		{
			return Compare(x.Col2, y.Col2);
		}
	}
	internal sealed class CustomAttributeTable : SortedTable<Row<uint, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteCodedRID(rows[i].Col1, CodedIndex.HasCustomAttribute);
				buffer.WriteCodedRID(rows[i].Col2, CodedIndex.CustomAttributeType);
				buffer.WriteBlob(rows[i].Col3);
			}
		}

		public override int Compare(Row<uint, uint, uint> x, Row<uint, uint, uint> y)
		{
			return Compare(x.Col1, y.Col1);
		}
	}
	internal sealed class FieldMarshalTable : SortedTable<Row<uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteCodedRID(rows[i].Col1, CodedIndex.HasFieldMarshal);
				buffer.WriteBlob(rows[i].Col2);
			}
		}

		public override int Compare(Row<uint, uint> x, Row<uint, uint> y)
		{
			return Compare(x.Col1, y.Col1);
		}
	}
	internal sealed class DeclSecurityTable : SortedTable<Row<SecurityAction, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);
				buffer.WriteCodedRID(rows[i].Col2, CodedIndex.HasDeclSecurity);
				buffer.WriteBlob(rows[i].Col3);
			}
		}

		public override int Compare(Row<SecurityAction, uint, uint> x, Row<SecurityAction, uint, uint> y)
		{
			return Compare(x.Col2, y.Col2);
		}
	}
	internal sealed class ClassLayoutTable : SortedTable<Row<ushort, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16(rows[i].Col1);
				buffer.WriteUInt32(rows[i].Col2);
				buffer.WriteRID(rows[i].Col3, Table.TypeDef);
			}
		}

		public override int Compare(Row<ushort, uint, uint> x, Row<ushort, uint, uint> y)
		{
			return Compare(x.Col3, y.Col3);
		}
	}
	internal sealed class FieldLayoutTable : SortedTable<Row<uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt32(rows[i].Col1);
				buffer.WriteRID(rows[i].Col2, Table.Field);
			}
		}

		public override int Compare(Row<uint, uint> x, Row<uint, uint> y)
		{
			return Compare(x.Col2, y.Col2);
		}
	}
	internal sealed class StandAloneSigTable : MetadataTable<uint>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteBlob(rows[i]);
			}
		}
	}
	internal sealed class EventMapTable : MetadataTable<Row<uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.TypeDef);
				buffer.WriteRID(rows[i].Col2, Table.Event);
			}
		}
	}
	internal sealed class EventTable : MetadataTable<Row<EventAttributes, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);
				buffer.WriteString(rows[i].Col2);
				buffer.WriteCodedRID(rows[i].Col3, CodedIndex.TypeDefOrRef);
			}
		}
	}
	internal sealed class PropertyMapTable : MetadataTable<Row<uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.TypeDef);
				buffer.WriteRID(rows[i].Col2, Table.Property);
			}
		}
	}
	internal sealed class PropertyTable : MetadataTable<Row<PropertyAttributes, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);
				buffer.WriteString(rows[i].Col2);
				buffer.WriteBlob(rows[i].Col3);
			}
		}
	}
	internal sealed class MethodSemanticsTable : SortedTable<Row<MethodSemanticsAttributes, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);
				buffer.WriteRID(rows[i].Col2, Table.Method);
				buffer.WriteCodedRID(rows[i].Col3, CodedIndex.HasSemantics);
			}
		}

		public override int Compare(Row<MethodSemanticsAttributes, uint, uint> x, Row<MethodSemanticsAttributes, uint, uint> y)
		{
			return Compare(x.Col3, y.Col3);
		}
	}
	internal sealed class MethodImplTable : MetadataTable<Row<uint, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.TypeDef);
				buffer.WriteCodedRID(rows[i].Col2, CodedIndex.MethodDefOrRef);
				buffer.WriteCodedRID(rows[i].Col3, CodedIndex.MethodDefOrRef);
			}
		}
	}
	internal sealed class ModuleRefTable : MetadataTable<uint>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteString(rows[i]);
			}
		}
	}
	internal sealed class TypeSpecTable : MetadataTable<uint>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteBlob(rows[i]);
			}
		}
	}
	internal sealed class ImplMapTable : SortedTable<Row<PInvokeAttributes, uint, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16((ushort)rows[i].Col1);
				buffer.WriteCodedRID(rows[i].Col2, CodedIndex.MemberForwarded);
				buffer.WriteString(rows[i].Col3);
				buffer.WriteRID(rows[i].Col4, Table.ModuleRef);
			}
		}

		public override int Compare(Row<PInvokeAttributes, uint, uint, uint> x, Row<PInvokeAttributes, uint, uint, uint> y)
		{
			return Compare(x.Col2, y.Col2);
		}
	}
	internal sealed class FieldRVATable : SortedTable<Row<uint, uint>>
	{
		internal int position;

		public override void Write(TableHeapBuffer buffer)
		{
			position = buffer.position;
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt32(rows[i].Col1);
				buffer.WriteRID(rows[i].Col2, Table.Field);
			}
		}

		public override int Compare(Row<uint, uint> x, Row<uint, uint> y)
		{
			return Compare(x.Col2, y.Col2);
		}
	}
	internal sealed class AssemblyTable : OneRowTable<Row<AssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyAttributes, uint, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			buffer.WriteUInt32((uint)row.Col1);
			buffer.WriteUInt16(row.Col2);
			buffer.WriteUInt16(row.Col3);
			buffer.WriteUInt16(row.Col4);
			buffer.WriteUInt16(row.Col5);
			buffer.WriteUInt32((uint)row.Col6);
			buffer.WriteBlob(row.Col7);
			buffer.WriteString(row.Col8);
			buffer.WriteString(row.Col9);
		}
	}
	internal sealed class AssemblyRefTable : MetadataTable<Row<ushort, ushort, ushort, ushort, AssemblyAttributes, uint, uint, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16(rows[i].Col1);
				buffer.WriteUInt16(rows[i].Col2);
				buffer.WriteUInt16(rows[i].Col3);
				buffer.WriteUInt16(rows[i].Col4);
				buffer.WriteUInt32((uint)rows[i].Col5);
				buffer.WriteBlob(rows[i].Col6);
				buffer.WriteString(rows[i].Col7);
				buffer.WriteString(rows[i].Col8);
				buffer.WriteBlob(rows[i].Col9);
			}
		}
	}
	internal sealed class FileTable : MetadataTable<Row<FileAttributes, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt32((uint)rows[i].Col1);
				buffer.WriteString(rows[i].Col2);
				buffer.WriteBlob(rows[i].Col3);
			}
		}
	}
	internal sealed class ExportedTypeTable : MetadataTable<Row<TypeAttributes, uint, uint, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt32((uint)rows[i].Col1);
				buffer.WriteUInt32(rows[i].Col2);
				buffer.WriteString(rows[i].Col3);
				buffer.WriteString(rows[i].Col4);
				buffer.WriteCodedRID(rows[i].Col5, CodedIndex.Implementation);
			}
		}
	}
	internal sealed class ManifestResourceTable : MetadataTable<Row<uint, ManifestResourceAttributes, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt32(rows[i].Col1);
				buffer.WriteUInt32((uint)rows[i].Col2);
				buffer.WriteString(rows[i].Col3);
				buffer.WriteCodedRID(rows[i].Col4, CodedIndex.Implementation);
			}
		}
	}
	internal sealed class NestedClassTable : SortedTable<Row<uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.TypeDef);
				buffer.WriteRID(rows[i].Col2, Table.TypeDef);
			}
		}

		public override int Compare(Row<uint, uint> x, Row<uint, uint> y)
		{
			return Compare(x.Col1, y.Col1);
		}
	}
	internal sealed class GenericParamTable : MetadataTable<Row<ushort, GenericParameterAttributes, uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteUInt16(rows[i].Col1);
				buffer.WriteUInt16((ushort)rows[i].Col2);
				buffer.WriteCodedRID(rows[i].Col3, CodedIndex.TypeOrMethodDef);
				buffer.WriteString(rows[i].Col4);
			}
		}
	}
	internal sealed class MethodSpecTable : MetadataTable<Row<uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteCodedRID(rows[i].Col1, CodedIndex.MethodDefOrRef);
				buffer.WriteBlob(rows[i].Col2);
			}
		}
	}
	internal sealed class GenericParamConstraintTable : MetadataTable<Row<uint, uint>>
	{
		public override void Write(TableHeapBuffer buffer)
		{
			for (int i = 0; i < length; i++)
			{
				buffer.WriteRID(rows[i].Col1, Table.GenericParam);
				buffer.WriteCodedRID(rows[i].Col2, CodedIndex.TypeDefOrRef);
			}
		}
	}
	internal sealed class MetadataBuilder
	{
		private sealed class GenericParameterComparer : IComparer<GenericParameter>
		{
			public int Compare(GenericParameter a, GenericParameter b)
			{
				uint num = MakeCodedRID(a.Owner, CodedIndex.TypeOrMethodDef);
				uint num2 = MakeCodedRID(b.Owner, CodedIndex.TypeOrMethodDef);
				if (num == num2)
				{
					int position = a.Position;
					int position2 = b.Position;
					if (position != position2)
					{
						if (position <= position2)
						{
							return -1;
						}
						return 1;
					}
					return 0;
				}
				if (num <= num2)
				{
					return -1;
				}
				return 1;
			}
		}

		internal readonly ModuleDefinition module;

		internal readonly ISymbolWriterProvider symbol_writer_provider;

		internal readonly ISymbolWriter symbol_writer;

		internal readonly TextMap text_map;

		internal readonly string fq_name;

		private readonly Dictionary<Row<uint, uint, uint>, MetadataToken> type_ref_map;

		private readonly Dictionary<uint, MetadataToken> type_spec_map;

		private readonly Dictionary<Row<uint, uint, uint>, MetadataToken> member_ref_map;

		private readonly Dictionary<Row<uint, uint>, MetadataToken> method_spec_map;

		private readonly Mono.Collections.Generic.Collection<GenericParameter> generic_parameters;

		private readonly Dictionary<MetadataToken, MetadataToken> method_def_map;

		internal readonly CodeWriter code;

		internal readonly DataBuffer data;

		internal readonly ResourceBuffer resources;

		internal readonly StringHeapBuffer string_heap;

		internal readonly UserStringHeapBuffer user_string_heap;

		internal readonly BlobHeapBuffer blob_heap;

		internal readonly TableHeapBuffer table_heap;

		internal MetadataToken entry_point;

		private uint type_rid = 1u;

		private uint field_rid = 1u;

		private uint method_rid = 1u;

		private uint param_rid = 1u;

		private uint property_rid = 1u;

		private uint event_rid = 1u;

		private readonly TypeRefTable type_ref_table;

		private readonly TypeDefTable type_def_table;

		private readonly FieldTable field_table;

		private readonly MethodTable method_table;

		private readonly ParamTable param_table;

		private readonly InterfaceImplTable iface_impl_table;

		private readonly MemberRefTable member_ref_table;

		private readonly ConstantTable constant_table;

		private readonly CustomAttributeTable custom_attribute_table;

		private readonly DeclSecurityTable declsec_table;

		private readonly StandAloneSigTable standalone_sig_table;

		private readonly EventMapTable event_map_table;

		private readonly EventTable event_table;

		private readonly PropertyMapTable property_map_table;

		private readonly PropertyTable property_table;

		private readonly TypeSpecTable typespec_table;

		private readonly MethodSpecTable method_spec_table;

		internal readonly bool write_symbols;

		public MetadataBuilder(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider, ISymbolWriter symbol_writer)
		{
			this.module = module;
			text_map = CreateTextMap();
			this.fq_name = fq_name;
			this.symbol_writer_provider = symbol_writer_provider;
			this.symbol_writer = symbol_writer;
			write_symbols = symbol_writer != null;
			code = new CodeWriter(this);
			data = new DataBuffer();
			resources = new ResourceBuffer();
			string_heap = new StringHeapBuffer();
			user_string_heap = new UserStringHeapBuffer();
			blob_heap = new BlobHeapBuffer();
			table_heap = new TableHeapBuffer(module, this);
			type_ref_table = GetTable<TypeRefTable>(Table.TypeRef);
			type_def_table = GetTable<TypeDefTable>(Table.TypeDef);
			field_table = GetTable<FieldTable>(Table.Field);
			method_table = GetTable<MethodTable>(Table.Method);
			param_table = GetTable<ParamTable>(Table.Param);
			iface_impl_table = GetTable<InterfaceImplTable>(Table.InterfaceImpl);
			member_ref_table = GetTable<MemberRefTable>(Table.MemberRef);
			constant_table = GetTable<ConstantTable>(Table.Constant);
			custom_attribute_table = GetTable<CustomAttributeTable>(Table.CustomAttribute);
			declsec_table = GetTable<DeclSecurityTable>(Table.DeclSecurity);
			standalone_sig_table = GetTable<StandAloneSigTable>(Table.StandAloneSig);
			event_map_table = GetTable<EventMapTable>(Table.EventMap);
			event_table = GetTable<EventTable>(Table.Event);
			property_map_table = GetTable<PropertyMapTable>(Table.PropertyMap);
			property_table = GetTable<PropertyTable>(Table.Property);
			typespec_table = GetTable<TypeSpecTable>(Table.TypeSpec);
			method_spec_table = GetTable<MethodSpecTable>(Table.MethodSpec);
			RowEqualityComparer comparer = new RowEqualityComparer();
			type_ref_map = new Dictionary<Row<uint, uint, uint>, MetadataToken>(comparer);
			type_spec_map = new Dictionary<uint, MetadataToken>();
			member_ref_map = new Dictionary<Row<uint, uint, uint>, MetadataToken>(comparer);
			method_spec_map = new Dictionary<Row<uint, uint>, MetadataToken>(comparer);
			generic_parameters = new Mono.Collections.Generic.Collection<GenericParameter>();
			if (write_symbols)
			{
				method_def_map = new Dictionary<MetadataToken, MetadataToken>();
			}
		}

		private TextMap CreateTextMap()
		{
			TextMap textMap = new TextMap();
			textMap.AddMap(TextSegment.ImportAddressTable, (module.Architecture == TargetArchitecture.I386) ? 8 : 0);
			textMap.AddMap(TextSegment.CLIHeader, 72, 8);
			return textMap;
		}

		private TTable GetTable<TTable>(Table table) where TTable : MetadataTable, new()
		{
			return table_heap.GetTable<TTable>(table);
		}

		private uint GetStringIndex(string @string)
		{
			if (string.IsNullOrEmpty(@string))
			{
				return 0u;
			}
			return string_heap.GetStringIndex(@string);
		}

		private uint GetBlobIndex(ByteBuffer blob)
		{
			if (blob.length == 0)
			{
				return 0u;
			}
			return blob_heap.GetBlobIndex(blob);
		}

		private uint GetBlobIndex(byte[] blob)
		{
			if (blob.IsNullOrEmpty())
			{
				return 0u;
			}
			return GetBlobIndex(new ByteBuffer(blob));
		}

		public void BuildMetadata()
		{
			BuildModule();
			table_heap.WriteTableHeap();
		}

		private void BuildModule()
		{
			GetTable<ModuleTable>(Table.Module).row = GetStringIndex(module.Name);
			AssemblyDefinition assembly = module.Assembly;
			if (assembly != null)
			{
				BuildAssembly();
			}
			if (module.HasAssemblyReferences)
			{
				AddAssemblyReferences();
			}
			if (module.HasModuleReferences)
			{
				AddModuleReferences();
			}
			if (module.HasResources)
			{
				AddResources();
			}
			if (module.HasExportedTypes)
			{
				AddExportedTypes();
			}
			BuildTypes();
			if (assembly != null)
			{
				if (assembly.HasCustomAttributes)
				{
					AddCustomAttributes(assembly);
				}
				if (assembly.HasSecurityDeclarations)
				{
					AddSecurityDeclarations(assembly);
				}
			}
			if (module.HasCustomAttributes)
			{
				AddCustomAttributes(module);
			}
			if (module.EntryPoint != null)
			{
				entry_point = LookupToken(module.EntryPoint);
			}
		}

		private void BuildAssembly()
		{
			AssemblyDefinition assembly = module.Assembly;
			AssemblyNameDefinition name = assembly.Name;
			GetTable<AssemblyTable>(Table.Assembly).row = new Row<AssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyAttributes, uint, uint, uint>(name.HashAlgorithm, (ushort)name.Version.Major, (ushort)name.Version.Minor, (ushort)name.Version.Build, (ushort)name.Version.Revision, name.Attributes, GetBlobIndex(name.PublicKey), GetStringIndex(name.Name), GetStringIndex(name.Culture));
			if (assembly.Modules.Count > 1)
			{
				BuildModules();
			}
		}

		private void BuildModules()
		{
			Mono.Collections.Generic.Collection<ModuleDefinition> modules = module.Assembly.Modules;
			FileTable table = GetTable<FileTable>(Table.File);
			for (int i = 0; i < modules.Count; i++)
			{
				ModuleDefinition moduleDefinition = modules[i];
				if (!moduleDefinition.IsMain)
				{
					WriterParameters parameters = new WriterParameters
					{
						SymbolWriterProvider = symbol_writer_provider
					};
					string moduleFileName = GetModuleFileName(moduleDefinition.Name);
					moduleDefinition.Write(moduleFileName, parameters);
					byte[] blob = CryptoService.ComputeHash(moduleFileName);
					table.AddRow(new Row<FileAttributes, uint, uint>(FileAttributes.ContainsMetaData, GetStringIndex(moduleDefinition.Name), GetBlobIndex(blob)));
				}
			}
		}

		private string GetModuleFileName(string name)
		{
			if (string.IsNullOrEmpty(name))
			{
				throw new NotSupportedException();
			}
			return Path.Combine(Path.GetDirectoryName(fq_name), name);
		}

		private void AddAssemblyReferences()
		{
			Mono.Collections.Generic.Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
			AssemblyRefTable table = GetTable<AssemblyRefTable>(Table.AssemblyRef);
			for (int i = 0; i < assemblyReferences.Count; i++)
			{
				AssemblyNameReference assemblyNameReference = assemblyReferences[i];
				byte[] blob = (assemblyNameReference.PublicKey.IsNullOrEmpty() ? assemblyNameReference.PublicKeyToken : assemblyNameReference.PublicKey);
				Version version = assemblyNameReference.Version;
				int rid = table.AddRow(new Row<ushort, ushort, ushort, ushort, AssemblyAttributes, uint, uint, uint, uint>((ushort)version.Major, (ushort)version.Minor, (ushort)version.Build, (ushort)version.Revision, assemblyNameReference.Attributes, GetBlobIndex(blob), GetStringIndex(assemblyNameReference.Name), GetStringIndex(assemblyNameReference.Culture), GetBlobIndex(assemblyNameReference.Hash)));
				assemblyNameReference.token = new MetadataToken(TokenType.AssemblyRef, rid);
			}
		}

		private void AddModuleReferences()
		{
			Mono.Collections.Generic.Collection<ModuleReference> moduleReferences = module.ModuleReferences;
			ModuleRefTable table = GetTable<ModuleRefTable>(Table.ModuleRef);
			for (int i = 0; i < moduleReferences.Count; i++)
			{
				ModuleReference moduleReference = moduleReferences[i];
				moduleReference.token = new MetadataToken(TokenType.ModuleRef, table.AddRow(GetStringIndex(moduleReference.Name)));
			}
		}

		private void AddResources()
		{
			Mono.Collections.Generic.Collection<Resource> collection = module.Resources;
			ManifestResourceTable table = GetTable<ManifestResourceTable>(Table.ManifestResource);
			for (int i = 0; i < collection.Count; i++)
			{
				Resource resource = collection[i];
				Row<uint, ManifestResourceAttributes, uint, uint> row = new Row<uint, ManifestResourceAttributes, uint, uint>(0u, resource.Attributes, GetStringIndex(resource.Name), 0u);
				switch (resource.ResourceType)
				{
				case ResourceType.Embedded:
					row.Col1 = AddEmbeddedResource((EmbeddedResource)resource);
					break;
				case ResourceType.Linked:
					row.Col4 = CodedIndex.Implementation.CompressMetadataToken(new MetadataToken(TokenType.File, AddLinkedResource((LinkedResource)resource)));
					break;
				case ResourceType.AssemblyLinked:
					row.Col4 = CodedIndex.Implementation.CompressMetadataToken(((AssemblyLinkedResource)resource).Assembly.MetadataToken);
					break;
				default:
					throw new NotSupportedException();
				}
				table.AddRow(row);
			}
		}

		private uint AddLinkedResource(LinkedResource resource)
		{
			return (uint)GetTable<FileTable>(Table.File).AddRow(new Row<FileAttributes, uint, uint>(col3: GetBlobIndex(resource.Hash.IsNullOrEmpty() ? CryptoService.ComputeHash(resource.File) : resource.Hash), col1: FileAttributes.ContainsNoMetaData, col2: GetStringIndex(resource.File)));
		}

		private uint AddEmbeddedResource(EmbeddedResource resource)
		{
			return resources.AddResource(resource.GetResourceData());
		}

		private void AddExportedTypes()
		{
			Mono.Collections.Generic.Collection<ExportedType> exportedTypes = module.ExportedTypes;
			ExportedTypeTable table = GetTable<ExportedTypeTable>(Table.ExportedType);
			for (int i = 0; i < exportedTypes.Count; i++)
			{
				ExportedType exportedType = exportedTypes[i];
				int rid = table.AddRow(new Row<TypeAttributes, uint, uint, uint, uint>(exportedType.Attributes, (uint)exportedType.Identifier, GetStringIndex(exportedType.Name), GetStringIndex(exportedType.Namespace), MakeCodedRID(GetExportedTypeScope(exportedType), CodedIndex.Implementation)));
				exportedType.token = new MetadataToken(TokenType.ExportedType, rid);
			}
		}

		private MetadataToken GetExportedTypeScope(ExportedType exported_type)
		{
			if (exported_type.DeclaringType != null)
			{
				return exported_type.DeclaringType.MetadataToken;
			}
			IMetadataScope scope = exported_type.Scope;
			switch (scope.MetadataToken.TokenType)
			{
			case TokenType.AssemblyRef:
				return scope.MetadataToken;
			case TokenType.ModuleRef:
			{
				FileTable table = GetTable<FileTable>(Table.File);
				for (int i = 0; i < table.length; i++)
				{
					if (table.rows[i].Col2 == GetStringIndex(scope.Name))
					{
						return new MetadataToken(TokenType.File, i + 1);
					}
				}
				break;
			}
			}
			throw new NotSupportedException();
		}

		private void BuildTypes()
		{
			if (module.HasTypes)
			{
				AttachTokens();
				AddTypeDefs();
				AddGenericParameters();
			}
		}

		private void AttachTokens()
		{
			Mono.Collections.Generic.Collection<TypeDefinition> types = module.Types;
			for (int i = 0; i < types.Count; i++)
			{
				AttachTypeDefToken(types[i]);
			}
		}

		private void AttachTypeDefToken(TypeDefinition type)
		{
			type.token = new MetadataToken(TokenType.TypeDef, type_rid++);
			type.fields_range.Start = field_rid;
			type.methods_range.Start = method_rid;
			if (type.HasFields)
			{
				AttachFieldsDefToken(type);
			}
			if (type.HasMethods)
			{
				AttachMethodsDefToken(type);
			}
			if (type.HasNestedTypes)
			{
				AttachNestedTypesDefToken(type);
			}
		}

		private void AttachNestedTypesDefToken(TypeDefinition type)
		{
			Mono.Collections.Generic.Collection<TypeDefinition> nestedTypes = type.NestedTypes;
			for (int i = 0; i < nestedTypes.Count; i++)
			{
				AttachTypeDefToken(nestedTypes[i]);
			}
		}

		private void AttachFieldsDefToken(TypeDefinition type)
		{
			Mono.Collections.Generic.Collection<FieldDefinition> fields = type.Fields;
			type.fields_range.Length = (uint)fields.Count;
			for (int i = 0; i < fields.Count; i++)
			{
				fields[i].token = new MetadataToken(TokenType.Field, field_rid++);
			}
		}

		private void AttachMethodsDefToken(TypeDefinition type)
		{
			Mono.Collections.Generic.Collection<MethodDefinition> methods = type.Methods;
			type.methods_range.Length = (uint)methods.Count;
			for (int i = 0; i < methods.Count; i++)
			{
				MethodDefinition methodDefinition = methods[i];
				MetadataToken metadataToken = new MetadataToken(TokenType.Method, method_rid++);
				if (write_symbols && methodDefinition.token != MetadataToken.Zero)
				{
					method_def_map.Add(metadataToken, methodDefinition.token);
				}
				methodDefinition.token = metadataToken;
			}
		}

		public bool TryGetOriginalMethodToken(MetadataToken new_token, out MetadataToken original)
		{
			return method_def_map.TryGetValue(new_token, out original);
		}

		private MetadataToken GetTypeToken(TypeReference type)
		{
			if (type == null)
			{
				return MetadataToken.Zero;
			}
			if (type.IsDefinition)
			{
				return type.token;
			}
			if (type.IsTypeSpecification())
			{
				return GetTypeSpecToken(type);
			}
			return GetTypeRefToken(type);
		}

		private MetadataToken GetTypeSpecToken(TypeReference type)
		{
			uint blobIndex = GetBlobIndex(GetTypeSpecSignature(type));
			if (type_spec_map.TryGetValue(blobIndex, out var value))
			{
				return value;
			}
			return AddTypeSpecification(type, blobIndex);
		}

		private MetadataToken AddTypeSpecification(TypeReference type, uint row)
		{
			type.token = new MetadataToken(TokenType.TypeSpec, typespec_table.AddRow(row));
			MetadataToken token = type.token;
			type_spec_map.Add(row, token);
			return token;
		}

		private MetadataToken GetTypeRefToken(TypeReference type)
		{
			Row<uint, uint, uint> row = CreateTypeRefRow(type);
			if (type_ref_map.TryGetValue(row, out var value))
			{
				return value;
			}
			return AddTypeReference(type, row);
		}

		private Row<uint, uint, uint> CreateTypeRefRow(TypeReference type)
		{
			return new Row<uint, uint, uint>(MakeCodedRID(GetScopeToken(type), CodedIndex.ResolutionScope), GetStringIndex(type.Name), GetStringIndex(type.Namespace));
		}

		private MetadataToken GetScopeToken(TypeReference type)
		{
			if (type.IsNested)
			{
				return GetTypeRefToken(type.DeclaringType);
			}
			return type.Scope?.MetadataToken ?? MetadataToken.Zero;
		}

		private static uint MakeCodedRID(IMetadataTokenProvider provider, CodedIndex index)
		{
			return MakeCodedRID(provider.MetadataToken, index);
		}

		private static uint MakeCodedRID(MetadataToken token, CodedIndex index)
		{
			return index.CompressMetadataToken(token);
		}

		private MetadataToken AddTypeReference(TypeReference type, Row<uint, uint, uint> row)
		{
			type.token = new MetadataToken(TokenType.TypeRef, type_ref_table.AddRow(row));
			MetadataToken token = type.token;
			type_ref_map.Add(row, token);
			return token;
		}

		private void AddTypeDefs()
		{
			Mono.Collections.Generic.Collection<TypeDefinition> types = module.Types;
			for (int i = 0; i < types.Count; i++)
			{
				AddType(types[i]);
			}
		}

		private void AddType(TypeDefinition type)
		{
			type_def_table.AddRow(new Row<TypeAttributes, uint, uint, uint, uint, uint>(type.Attributes, GetStringIndex(type.Name), GetStringIndex(type.Namespace), MakeCodedRID(GetTypeToken(type.BaseType), CodedIndex.TypeDefOrRef), type.fields_range.Start, type.methods_range.Start));
			if (type.HasGenericParameters)
			{
				AddGenericParameters(type);
			}
			if (type.HasInterfaces)
			{
				AddInterfaces(type);
			}
			if (type.HasLayoutInfo)
			{
				AddLayoutInfo(type);
			}
			if (type.HasFields)
			{
				AddFields(type);
			}
			if (type.HasMethods)
			{
				AddMethods(type);
			}
			if (type.HasProperties)
			{
				AddProperties(type);
			}
			if (type.HasEvents)
			{
				AddEvents(type);
			}
			if (type.HasCustomAttributes)
			{
				AddCustomAttributes(type);
			}
			if (type.HasSecurityDeclarations)
			{
				AddSecurityDeclarations(type);
			}
			if (type.HasNestedTypes)
			{
				AddNestedTypes(type);
			}
		}

		private void AddGenericParameters(IGenericParameterProvider owner)
		{
			Mono.Collections.Generic.Collection<GenericParameter> genericParameters = owner.GenericParameters;
			for (int i = 0; i < genericParameters.Count; i++)
			{
				generic_parameters.Add(genericParameters[i]);
			}
		}

		private void AddGenericParameters()
		{
			GenericParameter[] items = generic_parameters.items;
			int size = generic_parameters.size;
			Array.Sort(items, 0, size, new GenericParameterComparer());
			GenericParamTable table = GetTable<GenericParamTable>(Table.GenericParam);
			GenericParamConstraintTable table2 = GetTable<GenericParamConstraintTable>(Table.GenericParamConstraint);
			for (int i = 0; i < size; i++)
			{
				GenericParameter genericParameter = items[i];
				int rid = table.AddRow(new Row<ushort, GenericParameterAttributes, uint, uint>((ushort)genericParameter.Position, genericParameter.Attributes, MakeCodedRID(genericParameter.Owner, CodedIndex.TypeOrMethodDef), GetStringIndex(genericParameter.Name)));
				genericParameter.token = new MetadataToken(TokenType.GenericParam, rid);
				if (genericParameter.HasConstraints)
				{
					AddConstraints(genericParameter, table2);
				}
				if (genericParameter.HasCustomAttributes)
				{
					AddCustomAttributes(genericParameter);
				}
			}
		}

		private void AddConstraints(GenericParameter generic_parameter, GenericParamConstraintTable table)
		{
			Mono.Collections.Generic.Collection<TypeReference> constraints = generic_parameter.Constraints;
			uint rID = generic_parameter.token.RID;
			for (int i = 0; i < constraints.Count; i++)
			{
				table.AddRow(new Row<uint, uint>(rID, MakeCodedRID(GetTypeToken(constraints[i]), CodedIndex.TypeDefOrRef)));
			}
		}

		private void AddInterfaces(TypeDefinition type)
		{
			Mono.Collections.Generic.Collection<TypeReference> interfaces = type.Interfaces;
			uint rID = type.token.RID;
			for (int i = 0; i < interfaces.Count; i++)
			{
				iface_impl_table.AddRow(new Row<uint, uint>(rID, MakeCodedRID(GetTypeToken(interfaces[i]), CodedIndex.TypeDefOrRef)));
			}
		}

		private void AddLayoutInfo(TypeDefinition type)
		{
			GetTable<ClassLayoutTable>(Table.ClassLayout).AddRow(new Row<ushort, uint, uint>((ushort)type.PackingSize, (uint)type.ClassSize, type.token.RID));
		}

		private void AddNestedTypes(TypeDefinition type)
		{
			Mono.Collections.Generic.Collection<TypeDefinition> nestedTypes = type.NestedTypes;
			NestedClassTable table = GetTable<NestedClassTable>(Table.NestedClass);
			for (int i = 0; i < nestedTypes.Count; i++)
			{
				TypeDefinition typeDefinition = nestedTypes[i];
				AddType(typeDefinition);
				table.AddRow(new Row<uint, uint>(typeDefinition.token.RID, type.token.RID));
			}
		}

		private void AddFields(TypeDefinition type)
		{
			Mono.Collections.Generic.Collection<FieldDefinition> fields = type.Fields;
			for (int i = 0; i < fields.Count; i++)
			{
				AddField(fields[i]);
			}
		}

		private void AddField(FieldDefinition field)
		{
			field_table.AddRow(new Row<FieldAttributes, uint, uint>(field.Attributes, GetStringIndex(field.Name), GetBlobIndex(GetFieldSignature(field))));
			if (!field.InitialValue.IsNullOrEmpty())
			{
				AddFieldRVA(field);
			}
			if (field.HasLayoutInfo)
			{
				AddFieldLayout(field);
			}
			if (field.HasCustomAttributes)
			{
				AddCustomAttributes(field);
			}
			if (field.HasConstant)
			{
				AddConstant(field, field.FieldType);
			}
			if (field.HasMarshalInfo)
			{
				AddMarshalInfo(field);
			}
		}

		private void AddFieldRVA(FieldDefinition field)
		{
			GetTable<FieldRVATable>(Table.FieldRVA).AddRow(new Row<uint, uint>(data.AddData(field.InitialValue), field.token.RID));
		}

		private void AddFieldLayout(FieldDefinition field)
		{
			GetTable<FieldLayoutTable>(Table.FieldLayout).AddRow(new Row<uint, uint>((uint)field.Offset, field.token.RID));
		}

		private void AddMethods(TypeDefinition type)
		{
			Mono.Collections.Generic.Collection<MethodDefinition> methods = type.Methods;
			for (int i = 0; i < methods.Count; i++)
			{
				AddMethod(methods[i]);
			}
		}

		private void AddMethod(MethodDefinition method)
		{
			method_table.AddRow(new Row<uint, MethodImplAttributes, MethodAttributes, uint, uint, uint>(method.HasBody ? code.WriteMethodBody(method) : 0u, method.ImplAttributes, method.Attributes, GetStringIndex(method.Name), GetBlobIndex(GetMethodSignature(method)), param_rid));
			AddParameters(method);
			if (method.HasGenericParameters)
			{
				AddGenericParameters(method);
			}
			if (method.IsPInvokeImpl)
			{
				AddPInvokeInfo(method);
			}
			if (method.HasCustomAttributes)
			{
				AddCustomAttributes(method);
			}
			if (method.HasSecurityDeclarations)
			{
				AddSecurityDeclarations(method);
			}
			if (method.HasOverrides)
			{
				AddOverrides(method);
			}
		}

		private void AddParameters(MethodDefinition method)
		{
			ParameterDefinition parameter = method.MethodReturnType.parameter;
			if (parameter != null && RequiresParameterRow(parameter))
			{
				AddParameter(0, parameter, param_table);
			}
			if (!method.HasParameters)
			{
				return;
			}
			Mono.Collections.Generic.Collection<ParameterDefinition> parameters = method.Parameters;
			for (int i = 0; i < parameters.Count; i++)
			{
				ParameterDefinition parameter2 = parameters[i];
				if (RequiresParameterRow(parameter2))
				{
					AddParameter((ushort)(i + 1), parameter2, param_table);
				}
			}
		}

		private void AddPInvokeInfo(MethodDefinition method)
		{
			PInvokeInfo pInvokeInfo = method.PInvokeInfo;
			if (pInvokeInfo != null)
			{
				GetTable<ImplMapTable>(Table.ImplMap).AddRow(new Row<PInvokeAttributes, uint, uint, uint>(pInvokeInfo.Attributes, MakeCodedRID(method, CodedIndex.MemberForwarded), GetStringIndex(pInvokeInfo.EntryPoint), pInvokeInfo.Module.MetadataToken.RID));
			}
		}

		private void AddOverrides(MethodDefinition method)
		{
			Mono.Collections.Generic.Collection<MethodReference> overrides = method.Overrides;
			MethodImplTable table = GetTable<MethodImplTable>(Table.MethodImpl);
			for (int i = 0; i < overrides.Count; i++)
			{
				table.AddRow(new Row<uint, uint, uint>(method.DeclaringType.token.RID, MakeCodedRID(method, CodedIndex.MethodDefOrRef), MakeCodedRID(LookupToken(overrides[i]), CodedIndex.MethodDefOrRef)));
			}
		}

		private static bool RequiresParameterRow(ParameterDefinition parameter)
		{
			if (string.IsNullOrEmpty(parameter.Name) && parameter.Attributes == ParameterAttributes.None && !parameter.HasMarshalInfo && !parameter.HasConstant)
			{
				return parameter.HasCustomAttributes;
			}
			return true;
		}

		private void AddParameter(ushort sequence, ParameterDefinition parameter, ParamTable table)
		{
			table.AddRow(new Row<ParameterAttributes, ushort, uint>(parameter.Attributes, sequence, GetStringIndex(parameter.Name)));
			parameter.token = new MetadataToken(TokenType.Param, param_rid++);
			if (parameter.HasCustomAttributes)
			{
				AddCustomAttributes(parameter);
			}
			if (parameter.HasConstant)
			{
				AddConstant(parameter, parameter.ParameterType);
			}
			if (parameter.HasMarshalInfo)
			{
				AddMarshalInfo(parameter);
			}
		}

		private void AddMarshalInfo(IMarshalInfoProvider owner)
		{
			GetTable<FieldMarshalTable>(Table.FieldMarshal).AddRow(new Row<uint, uint>(MakeCodedRID(owner, CodedIndex.HasFieldMarshal), GetBlobIndex(GetMarshalInfoSignature(owner))));
		}

		private void AddProperties(TypeDefinition type)
		{
			Mono.Collections.Generic.Collection<PropertyDefinition> properties = type.Properties;
			property_map_table.AddRow(new Row<uint, uint>(type.token.RID, property_rid));
			for (int i = 0; i < properties.Count; i++)
			{
				AddProperty(properties[i]);
			}
		}

		private void AddProperty(PropertyDefinition property)
		{
			property_table.AddRow(new Row<PropertyAttributes, uint, uint>(property.Attributes, GetStringIndex(property.Name), GetBlobIndex(GetPropertySignature(property))));
			property.token = new MetadataToken(TokenType.Property, property_rid++);
			MethodDefinition getMethod = property.GetMethod;
			if (getMethod != null)
			{
				AddSemantic(MethodSemanticsAttributes.Getter, property, getMethod);
			}
			getMethod = property.SetMethod;
			if (getMethod != null)
			{
				AddSemantic(MethodSemanticsAttributes.Setter, property, getMethod);
			}
			if (property.HasOtherMethods)
			{
				AddOtherSemantic(property, property.OtherMethods);
			}
			if (property.HasCustomAttributes)
			{
				AddCustomAttributes(property);
			}
			if (property.HasConstant)
			{
				AddConstant(property, property.PropertyType);
			}
		}

		private void AddOtherSemantic(IMetadataTokenProvider owner, Mono.Collections.Generic.Collection<MethodDefinition> others)
		{
			for (int i = 0; i < others.Count; i++)
			{
				AddSemantic(MethodSemanticsAttributes.Other, owner, others[i]);
			}
		}

		private void AddEvents(TypeDefinition type)
		{
			Mono.Collections.Generic.Collection<EventDefinition> events = type.Events;
			event_map_table.AddRow(new Row<uint, uint>(type.token.RID, event_rid));
			for (int i = 0; i < events.Count; i++)
			{
				AddEvent(events[i]);
			}
		}

		private void AddEvent(EventDefinition @event)
		{
			event_table.AddRow(new Row<EventAttributes, uint, uint>(@event.Attributes, GetStringIndex(@event.Name), MakeCodedRID(GetTypeToken(@event.EventType), CodedIndex.TypeDefOrRef)));
			@event.token = new MetadataToken(TokenType.Event, event_rid++);
			MethodDefinition addMethod = @event.AddMethod;
			if (addMethod != null)
			{
				AddSemantic(MethodSemanticsAttributes.AddOn, @event, addMethod);
			}
			addMethod = @event.InvokeMethod;
			if (addMethod != null)
			{
				AddSemantic(MethodSemanticsAttributes.Fire, @event, addMethod);
			}
			addMethod = @event.RemoveMethod;
			if (addMethod != null)
			{
				AddSemantic(MethodSemanticsAttributes.RemoveOn, @event, addMethod);
			}
			if (@event.HasOtherMethods)
			{
				AddOtherSemantic(@event, @event.OtherMethods);
			}
			if (@event.HasCustomAttributes)
			{
				AddCustomAttributes(@event);
			}
		}

		private void AddSemantic(MethodSemanticsAttributes semantics, IMetadataTokenProvider provider, MethodDefinition method)
		{
			method.SemanticsAttributes = semantics;
			GetTable<MethodSemanticsTable>(Table.MethodSemantics).AddRow(new Row<MethodSemanticsAttributes, uint, uint>(semantics, method.token.RID, MakeCodedRID(provider, CodedIndex.HasSemantics)));
		}

		private void AddConstant(IConstantProvider owner, TypeReference type)
		{
			object constant = owner.Constant;
			ElementType constantType = GetConstantType(type, constant);
			constant_table.AddRow(new Row<ElementType, uint, uint>(constantType, MakeCodedRID(owner.MetadataToken, CodedIndex.HasConstant), GetBlobIndex(GetConstantSignature(constantType, constant))));
		}

		private static ElementType GetConstantType(TypeReference constant_type, object constant)
		{
			if (constant == null)
			{
				return ElementType.Class;
			}
			ElementType etype = constant_type.etype;
			switch (etype)
			{
			case ElementType.None:
			{
				TypeDefinition typeDefinition = constant_type.CheckedResolve();
				if (typeDefinition.IsEnum)
				{
					return GetConstantType(typeDefinition.GetEnumUnderlyingType(), constant);
				}
				return ElementType.Class;
			}
			case ElementType.String:
				return ElementType.String;
			case ElementType.Object:
				return GetConstantType(constant.GetType());
			case ElementType.Var:
			case ElementType.Array:
			case ElementType.SzArray:
			case ElementType.MVar:
				return ElementType.Class;
			case ElementType.GenericInst:
			{
				GenericInstanceType genericInstanceType = (GenericInstanceType)constant_type;
				if (genericInstanceType.ElementType.IsTypeOf("System", "Nullable`1"))
				{
					return GetConstantType(genericInstanceType.GenericArguments[0], constant);
				}
				return GetConstantType(((TypeSpecification)constant_type).ElementType, constant);
			}
			case ElementType.ByRef:
			case ElementType.CModReqD:
			case ElementType.CModOpt:
			case ElementType.Sentinel:
				return GetConstantType(((TypeSpecification)constant_type).ElementType, constant);
			case ElementType.Boolean:
			case ElementType.Char:
			case ElementType.I1:
			case ElementType.U1:
			case ElementType.I2:
			case ElementType.U2:
			case ElementType.I4:
			case ElementType.U4:
			case ElementType.I8:
			case ElementType.U8:
			case ElementType.R4:
			case ElementType.R8:
			case ElementType.I:
			case ElementType.U:
				return GetConstantType(constant.GetType());
			default:
				return etype;
			}
		}

		private static ElementType GetConstantType(Type type)
		{
			return Type.GetTypeCode(type) switch
			{
				TypeCode.Boolean => ElementType.Boolean, 
				TypeCode.Byte => ElementType.U1, 
				TypeCode.SByte => ElementType.I1, 
				TypeCode.Char => ElementType.Char, 
				TypeCode.Int16 => ElementType.I2, 
				TypeCode.UInt16 => ElementType.U2, 
				TypeCode.Int32 => ElementType.I4, 
				TypeCode.UInt32 => ElementType.U4, 
				TypeCode.Int64 => ElementType.I8, 
				TypeCode.UInt64 => ElementType.U8, 
				TypeCode.Single => ElementType.R4, 
				TypeCode.Double => ElementType.R8, 
				TypeCode.String => ElementType.String, 
				_ => throw new NotSupportedException(type.FullName), 
			};
		}

		private void AddCustomAttributes(ICustomAttributeProvider owner)
		{
			Mono.Collections.Generic.Collection<CustomAttribute> customAttributes = owner.CustomAttributes;
			for (int i = 0; i < customAttributes.Count; i++)
			{
				CustomAttribute customAttribute = customAttributes[i];
				custom_attribute_table.AddRow(new Row<uint, uint, uint>(MakeCodedRID(owner, CodedIndex.HasCustomAttribute), MakeCodedRID(LookupToken(customAttribute.Constructor), CodedIndex.CustomAttributeType), GetBlobIndex(GetCustomAttributeSignature(customAttribute))));
			}
		}

		private void AddSecurityDeclarations(ISecurityDeclarationProvider owner)
		{
			Mono.Collections.Generic.Collection<SecurityDeclaration> securityDeclarations = owner.SecurityDeclarations;
			for (int i = 0; i < securityDeclarations.Count; i++)
			{
				SecurityDeclaration securityDeclaration = securityDeclarations[i];
				declsec_table.AddRow(new Row<SecurityAction, uint, uint>(securityDeclaration.Action, MakeCodedRID(owner, CodedIndex.HasDeclSecurity), GetBlobIndex(GetSecurityDeclarationSignature(securityDeclaration))));
			}
		}

		private MetadataToken GetMemberRefToken(MemberReference member)
		{
			Row<uint, uint, uint> row = CreateMemberRefRow(member);
			if (member_ref_map.TryGetValue(row, out var value))
			{
				return value;
			}
			AddMemberReference(member, row);
			return member.token;
		}

		private Row<uint, uint, uint> CreateMemberRefRow(MemberReference member)
		{
			return new Row<uint, uint, uint>(MakeCodedRID(GetTypeToken(member.DeclaringType), CodedIndex.MemberRefParent), GetStringIndex(member.Name), GetBlobIndex(GetMemberRefSignature(member)));
		}

		private void AddMemberReference(MemberReference member, Row<uint, uint, uint> row)
		{
			member.token = new MetadataToken(TokenType.MemberRef, member_ref_table.AddRow(row));
			member_ref_map.Add(row, member.token);
		}

		private MetadataToken GetMethodSpecToken(MethodSpecification method_spec)
		{
			Row<uint, uint> row = CreateMethodSpecRow(method_spec);
			if (method_spec_map.TryGetValue(row, out var value))
			{
				return value;
			}
			AddMethodSpecification(method_spec, row);
			return method_spec.token;
		}

		private void AddMethodSpecification(MethodSpecification method_spec, Row<uint, uint> row)
		{
			method_spec.token = new MetadataToken(TokenType.MethodSpec, method_spec_table.AddRow(row));
			method_spec_map.Add(row, method_spec.token);
		}

		private Row<uint, uint> CreateMethodSpecRow(MethodSpecification method_spec)
		{
			return new Row<uint, uint>(MakeCodedRID(LookupToken(method_spec.ElementMethod), CodedIndex.MethodDefOrRef), GetBlobIndex(GetMethodSpecSignature(method_spec)));
		}

		private SignatureWriter CreateSignatureWriter()
		{
			return new SignatureWriter(this);
		}

		private SignatureWriter GetMethodSpecSignature(MethodSpecification method_spec)
		{
			if (!method_spec.IsGenericInstance)
			{
				throw new NotSupportedException();
			}
			GenericInstanceMethod instance = (GenericInstanceMethod)method_spec;
			SignatureWriter signatureWriter = CreateSignatureWriter();
			signatureWriter.WriteByte(10);
			signatureWriter.WriteGenericInstanceSignature(instance);
			return signatureWriter;
		}

		public uint AddStandAloneSignature(uint signature)
		{
			return (uint)standalone_sig_table.AddRow(signature);
		}

		public uint GetLocalVariableBlobIndex(Mono.Collections.Generic.Collection<VariableDefinition> variables)
		{
			return GetBlobIndex(GetVariablesSignature(variables));
		}

		public uint GetCallSiteBlobIndex(CallSite call_site)
		{
			return GetBlobIndex(GetMethodSignature(call_site));
		}

		private SignatureWriter GetVariablesSignature(Mono.Collections.Generic.Collection<VariableDefinition> variables)
		{
			SignatureWriter signatureWriter = CreateSignatureWriter();
			signatureWriter.WriteByte(7);
			signatureWriter.WriteCompressedUInt32((uint)variables.Count);
			for (int i = 0; i < variables.Count; i++)
			{
				signatureWriter.WriteTypeSignature(variables[i].VariableType);
			}
			return signatureWriter;
		}

		private SignatureWriter GetFieldSignature(FieldReference field)
		{
			SignatureWriter signatureWriter = CreateSignatureWriter();
			signatureWriter.WriteByte(6);
			signatureWriter.WriteTypeSignature(field.FieldType);
			return signatureWriter;
		}

		private SignatureWriter GetMethodSignature(IMethodSignature method)
		{
			SignatureWriter signatureWriter = CreateSignatureWriter();
			signatureWriter.WriteMethodSignature(method);
			return signatureWriter;
		}

		private SignatureWriter GetMemberRefSignature(MemberReference member)
		{
			if (member is FieldReference field)
			{
				return GetFieldSignature(field);
			}
			if (member is MethodReference method)
			{
				return GetMethodSignature(method);
			}
			throw new NotSupportedException();
		}

		private SignatureWriter GetPropertySignature(PropertyDefinition property)
		{
			SignatureWriter signatureWriter = CreateSignatureWriter();
			byte b = 8;
			if (property.HasThis)
			{
				b |= 0x20;
			}
			uint num = 0u;
			Mono.Collections.Generic.Collection<ParameterDefinition> collection = null;
			if (property.HasParameters)
			{
				collection = property.Parameters;
				num = (uint)collection.Count;
			}
			signatureWriter.WriteByte(b);
			signatureWriter.WriteCompressedUInt32(num);
			signatureWriter.WriteTypeSignature(property.PropertyType);
			if (num == 0)
			{
				return signatureWriter;
			}
			for (int i = 0; i < num; i++)
			{
				signatureWriter.WriteTypeSignature(collection[i].ParameterType);
			}
			return signatureWriter;
		}

		private SignatureWriter GetTypeSpecSignature(TypeReference type)
		{
			SignatureWriter signatureWriter = CreateSignatureWriter();
			signatureWriter.WriteTypeSignature(type);
			return signatureWriter;
		}

		private SignatureWriter GetConstantSignature(ElementType type, object value)
		{
			SignatureWriter signatureWriter = CreateSignatureWriter();
			switch (type)
			{
			case ElementType.Class:
			case ElementType.Var:
			case ElementType.Array:
			case ElementType.Object:
			case ElementType.SzArray:
			case ElementType.MVar:
				signatureWriter.WriteInt32(0);
				break;
			case ElementType.String:
				signatureWriter.WriteConstantString((string)value);
				break;
			default:
				signatureWriter.WriteConstantPrimitive(value);
				break;
			}
			return signatureWriter;
		}

		private SignatureWriter GetCustomAttributeSignature(CustomAttribute attribute)
		{
			SignatureWriter signatureWriter = CreateSignatureWriter();
			if (!attribute.resolved)
			{
				signatureWriter.WriteBytes(attribute.GetBlob());
				return signatureWriter;
			}
			signatureWriter.WriteUInt16(1);
			signatureWriter.WriteCustomAttributeConstructorArguments(attribute);
			signatureWriter.WriteCustomAttributeNamedArguments(attribute);
			return signatureWriter;
		}

		private SignatureWriter GetSecurityDeclarationSignature(SecurityDeclaration declaration)
		{
			SignatureWriter signatureWriter = CreateSignatureWriter();
			if (!declaration.resolved)
			{
				signatureWriter.WriteBytes(declaration.GetBlob());
			}
			else if (module.Runtime < TargetRuntime.Net_2_0)
			{
				signatureWriter.WriteXmlSecurityDeclaration(declaration);
			}
			else
			{
				signatureWriter.WriteSecurityDeclaration(declaration);
			}
			return signatureWriter;
		}

		private SignatureWriter GetMarshalInfoSignature(IMarshalInfoProvider owner)
		{
			SignatureWriter signatureWriter = CreateSignatureWriter();
			signatureWriter.WriteMarshalInfo(owner.MarshalInfo);
			return signatureWriter;
		}

		private static Exception CreateForeignMemberException(MemberReference member)
		{
			return new ArgumentException($"Member '{member}' is declared in another module and needs to be imported");
		}

		public MetadataToken LookupToken(IMetadataTokenProvider provider)
		{
			if (provider == null)
			{
				throw new ArgumentNullException();
			}
			MemberReference memberReference = provider as MemberReference;
			if (memberReference == null || memberReference.Module != module)
			{
				throw CreateForeignMemberException(memberReference);
			}
			MetadataToken metadataToken = provider.MetadataToken;
			switch (metadataToken.TokenType)
			{
			case TokenType.TypeDef:
			case TokenType.Field:
			case TokenType.Method:
			case TokenType.Event:
			case TokenType.Property:
				return metadataToken;
			case TokenType.TypeRef:
			case TokenType.TypeSpec:
			case TokenType.GenericParam:
				return GetTypeToken((TypeReference)provider);
			case TokenType.MethodSpec:
				return GetMethodSpecToken((MethodSpecification)provider);
			case TokenType.MemberRef:
				return GetMemberRefToken(memberReference);
			default:
				throw new NotSupportedException();
			}
		}
	}
	internal sealed class SignatureWriter : ByteBuffer
	{
		private readonly MetadataBuilder metadata;

		public SignatureWriter(MetadataBuilder metadata)
			: base(6)
		{
			this.metadata = metadata;
		}

		public void WriteElementType(ElementType element_type)
		{
			WriteByte((byte)element_type);
		}

		public void WriteUTF8String(string @string)
		{
			if (@string == null)
			{
				WriteByte(byte.MaxValue);
				return;
			}
			byte[] bytes = Encoding.UTF8.GetBytes(@string);
			WriteCompressedUInt32((uint)bytes.Length);
			WriteBytes(bytes);
		}

		public void WriteMethodSignature(IMethodSignature method)
		{
			byte b = (byte)method.CallingConvention;
			if (method.HasThis)
			{
				b |= 0x20;
			}
			if (method.ExplicitThis)
			{
				b |= 0x40;
			}
			int num = ((method is IGenericParameterProvider { HasGenericParameters: not false } genericParameterProvider) ? genericParameterProvider.GenericParameters.Count : 0);
			if (num > 0)
			{
				b |= 0x10;
			}
			int num2 = (method.HasParameters ? method.Parameters.Count : 0);
			WriteByte(b);
			if (num > 0)
			{
				WriteCompressedUInt32((uint)num);
			}
			WriteCompressedUInt32((uint)num2);
			WriteTypeSignature(method.ReturnType);
			if (num2 != 0)
			{
				Mono.Collections.Generic.Collection<ParameterDefinition> parameters = method.Parameters;
				for (int i = 0; i < num2; i++)
				{
					WriteTypeSignature(parameters[i].ParameterType);
				}
			}
		}

		private uint MakeTypeDefOrRefCodedRID(TypeReference type)
		{
			return CodedIndex.TypeDefOrRef.CompressMetadataToken(metadata.LookupToken(type));
		}

		public void WriteTypeSignature(TypeReference type)
		{
			if (type == null)
			{
				throw new ArgumentNullException();
			}
			ElementType etype = type.etype;
			switch (etype)
			{
			case ElementType.Var:
			case ElementType.MVar:
			{
				GenericParameter obj = (GenericParameter)type;
				WriteElementType(etype);
				int num = obj.Position;
				if (num == -1)
				{
					throw new NotSupportedException();
				}
				WriteCompressedUInt32((uint)num);
				break;
			}
			case ElementType.GenericInst:
			{
				GenericInstanceType genericInstanceType = (GenericInstanceType)type;
				WriteElementType(ElementType.GenericInst);
				WriteElementType(genericInstanceType.IsValueType ? ElementType.ValueType : ElementType.Class);
				WriteCompressedUInt32(MakeTypeDefOrRefCodedRID(genericInstanceType.ElementType));
				WriteGenericInstanceSignature(genericInstanceType);
				break;
			}
			case ElementType.Ptr:
			case ElementType.ByRef:
			case ElementType.Sentinel:
			case ElementType.Pinned:
			{
				TypeSpecification typeSpecification = (TypeSpecification)type;
				WriteElementType(etype);
				WriteTypeSignature(typeSpecification.ElementType);
				break;
			}
			case ElementType.FnPtr:
			{
				FunctionPointerType method = (FunctionPointerType)type;
				WriteElementType(ElementType.FnPtr);
				WriteMethodSignature(method);
				break;
			}
			case ElementType.CModReqD:
			case ElementType.CModOpt:
			{
				IModifierType type2 = (IModifierType)type;
				WriteModifierSignature(etype, type2);
				break;
			}
			case ElementType.Array:
			{
				ArrayType arrayType = (ArrayType)type;
				if (!arrayType.IsVector)
				{
					WriteArrayTypeSignature(arrayType);
					break;
				}
				WriteElementType(ElementType.SzArray);
				WriteTypeSignature(arrayType.ElementType);
				break;
			}
			case ElementType.None:
				WriteElementType(type.IsValueType ? ElementType.ValueType : ElementType.Class);
				WriteCompressedUInt32(MakeTypeDefOrRefCodedRID(type));
				break;
			default:
				if (!TryWriteElementType(type))
				{
					throw new NotSupportedException();
				}
				break;
			}
		}

		private void WriteArrayTypeSignature(ArrayType array)
		{
			WriteElementType(ElementType.Array);
			WriteTypeSignature(array.ElementType);
			Mono.Collections.Generic.Collection<ArrayDimension> dimensions = array.Dimensions;
			int count = dimensions.Count;
			WriteCompressedUInt32((uint)count);
			int num = 0;
			int num2 = 0;
			for (int i = 0; i < count; i++)
			{
				ArrayDimension arrayDimension = dimensions[i];
				if (arrayDimension.UpperBound.HasValue)
				{
					num++;
					num2++;
				}
				else if (arrayDimension.LowerBound.HasValue)
				{
					num2++;
				}
			}
			int[] array2 = new int[num];
			int[] array3 = new int[num2];
			for (int j = 0; j < num2; j++)
			{
				ArrayDimension arrayDimension2 = dimensions[j];
				array3[j] = arrayDimension2.LowerBound.GetValueOrDefault();
				if (arrayDimension2.UpperBound.HasValue)
				{
					array2[j] = arrayDimension2.UpperBound.Value - array3[j] + 1;
				}
			}
			WriteCompressedUInt32((uint)num);
			for (int k = 0; k < num; k++)
			{
				WriteCompressedUInt32((uint)array2[k]);
			}
			WriteCompressedUInt32((uint)num2);
			for (int l = 0; l < num2; l++)
			{
				WriteCompressedInt32(array3[l]);
			}
		}

		public void WriteGenericInstanceSignature(IGenericInstance instance)
		{
			Mono.Collections.Generic.Collection<TypeReference> genericArguments = instance.GenericArguments;
			int count = genericArguments.Count;
			WriteCompressedUInt32((uint)count);
			for (int i = 0; i < count; i++)
			{
				WriteTypeSignature(genericArguments[i]);
			}
		}

		private void WriteModifierSignature(ElementType element_type, IModifierType type)
		{
			WriteElementType(element_type);
			WriteCompressedUInt32(MakeTypeDefOrRefCodedRID(type.ModifierType));
			WriteTypeSignature(type.ElementType);
		}

		private bool TryWriteElementType(TypeReference type)
		{
			ElementType etype = type.etype;
			if (etype == ElementType.None)
			{
				return false;
			}
			WriteElementType(etype);
			return true;
		}

		public void WriteConstantString(string value)
		{
			WriteBytes(Encoding.Unicode.GetBytes(value));
		}

		public void WriteConstantPrimitive(object value)
		{
			WritePrimitiveValue(value);
		}

		public void WriteCustomAttributeConstructorArguments(CustomAttribute attribute)
		{
			if (attribute.HasConstructorArguments)
			{
				Mono.Collections.Generic.Collection<CustomAttributeArgument> constructorArguments = attribute.ConstructorArguments;
				Mono.Collections.Generic.Collection<ParameterDefinition> parameters = attribute.Constructor.Parameters;
				if (parameters.Count != constructorArguments.Count)
				{
					throw new InvalidOperationException();
				}
				for (int i = 0; i < constructorArguments.Count; i++)
				{
					WriteCustomAttributeFixedArgument(parameters[i].ParameterType, constructorArguments[i]);
				}
			}
		}

		private void WriteCustomAttributeFixedArgument(TypeReference type, CustomAttributeArgument argument)
		{
			if (type.IsArray)
			{
				WriteCustomAttributeFixedArrayArgument((ArrayType)type, argument);
			}
			else
			{
				WriteCustomAttributeElement(type, argument);
			}
		}

		private void WriteCustomAttributeFixedArrayArgument(ArrayType type, CustomAttributeArgument argument)
		{
			if (!(argument.Value is CustomAttributeArgument[] array))
			{
				WriteUInt32(uint.MaxValue);
				return;
			}
			WriteInt32(array.Length);
			if (array.Length != 0)
			{
				TypeReference elementType = type.ElementType;
				for (int i = 0; i < array.Length; i++)
				{
					WriteCustomAttributeElement(elementType, array[i]);
				}
			}
		}

		private void WriteCustomAttributeElement(TypeReference type, CustomAttributeArgument argument)
		{
			if (type.IsArray)
			{
				WriteCustomAttributeFixedArrayArgument((ArrayType)type, argument);
			}
			else if (type.etype == ElementType.Object)
			{
				argument = (CustomAttributeArgument)argument.Value;
				type = argument.Type;
				WriteCustomAttributeFieldOrPropType(type);
				WriteCustomAttributeElement(type, argument);
			}
			else
			{
				WriteCustomAttributeValue(type, argument.Value);
			}
		}

		private void WriteCustomAttributeValue(TypeReference type, object value)
		{
			switch (type.etype)
			{
			case ElementType.String:
			{
				string text = (string)value;
				if (text == null)
				{
					WriteByte(byte.MaxValue);
				}
				else
				{
					WriteUTF8String(text);
				}
				break;
			}
			case ElementType.None:
				if (type.IsTypeOf("System", "Type"))
				{
					WriteTypeReference((TypeReference)value);
				}
				else
				{
					WriteCustomAttributeEnumValue(type, value);
				}
				break;
			default:
				WritePrimitiveValue(value);
				break;
			}
		}

		private void WritePrimitiveValue(object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException();
			}
			switch (Type.GetTypeCode(value.GetType()))
			{
			case TypeCode.Boolean:
				WriteByte((byte)(((bool)value) ? 1u : 0u));
				break;
			case TypeCode.Byte:
				WriteByte((byte)value);
				break;
			case TypeCode.SByte:
				WriteSByte((sbyte)value);
				break;
			case TypeCode.Int16:
				WriteInt16((short)value);
				break;
			case TypeCode.UInt16:
				WriteUInt16((ushort)value);
				break;
			case TypeCode.Char:
				WriteInt16((short)(char)value);
				break;
			case TypeCode.Int32:
				WriteInt32((int)value);
				break;
			case TypeCode.UInt32:
				WriteUInt32((uint)value);
				break;
			case TypeCode.Single:
				WriteSingle((float)value);
				break;
			case TypeCode.Int64:
				WriteInt64((long)value);
				break;
			case TypeCode.UInt64:
				WriteUInt64((ulong)value);
				break;
			case TypeCode.Double:
				WriteDouble((double)value);
				break;
			default:
				throw new NotSupportedException(value.GetType().FullName);
			}
		}

		private void WriteCustomAttributeEnumValue(TypeReference enum_type, object value)
		{
			TypeDefinition typeDefinition = enum_type.CheckedResolve();
			if (!typeDefinition.IsEnum)
			{
				throw new ArgumentException();
			}
			WriteCustomAttributeValue(typeDefinition.GetEnumUnderlyingType(), value);
		}

		private void WriteCustomAttributeFieldOrPropType(TypeReference type)
		{
			if (type.IsArray)
			{
				ArrayType arrayType = (ArrayType)type;
				WriteElementType(ElementType.SzArray);
				WriteCustomAttributeFieldOrPropType(arrayType.ElementType);
				return;
			}
			ElementType etype = type.etype;
			switch (etype)
			{
			case ElementType.Object:
				WriteElementType(ElementType.Boxed);
				break;
			case ElementType.None:
				if (type.IsTypeOf("System", "Type"))
				{
					WriteElementType(ElementType.Type);
					break;
				}
				WriteElementType(ElementType.Enum);
				WriteTypeReference(type);
				break;
			default:
				WriteElementType(etype);
				break;
			}
		}

		public void WriteCustomAttributeNamedArguments(CustomAttribute attribute)
		{
			int namedArgumentCount = GetNamedArgumentCount(attribute);
			WriteUInt16((ushort)namedArgumentCount);
			if (namedArgumentCount != 0)
			{
				WriteICustomAttributeNamedArguments(attribute);
			}
		}

		private static int GetNamedArgumentCount(ICustomAttribute attribute)
		{
			int num = 0;
			if (attribute.HasFields)
			{
				num += attribute.Fields.Count;
			}
			if (attribute.HasProperties)
			{
				num += attribute.Properties.Count;
			}
			return num;
		}

		private void WriteICustomAttributeNamedArguments(ICustomAttribute attribute)
		{
			if (attribute.HasFields)
			{
				WriteCustomAttributeNamedArguments(83, attribute.Fields);
			}
			if (attribute.HasProperties)
			{
				WriteCustomAttributeNamedArguments(84, attribute.Properties);
			}
		}

		private void WriteCustomAttributeNamedArguments(byte kind, Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> named_arguments)
		{
			for (int i = 0; i < named_arguments.Count; i++)
			{
				WriteCustomAttributeNamedArgument(kind, named_arguments[i]);
			}
		}

		private void WriteCustomAttributeNamedArgument(byte kind, CustomAttributeNamedArgument named_argument)
		{
			CustomAttributeArgument argument = named_argument.Argument;
			WriteByte(kind);
			WriteCustomAttributeFieldOrPropType(argument.Type);
			WriteUTF8String(named_argument.Name);
			WriteCustomAttributeFixedArgument(argument.Type, argument);
		}

		private void WriteSecurityAttribute(SecurityAttribute attribute)
		{
			WriteTypeReference(attribute.AttributeType);
			int namedArgumentCount = GetNamedArgumentCount(attribute);
			if (namedArgumentCount == 0)
			{
				WriteCompressedUInt32(1u);
				WriteCompressedUInt32(0u);
				return;
			}
			SignatureWriter signatureWriter = new SignatureWriter(metadata);
			signatureWriter.WriteCompressedUInt32((uint)namedArgumentCount);
			signatureWriter.WriteICustomAttributeNamedArguments(attribute);
			WriteCompressedUInt32((uint)signatureWriter.length);
			WriteBytes(signatureWriter);
		}

		public void WriteSecurityDeclaration(SecurityDeclaration declaration)
		{
			WriteByte(46);
			Mono.Collections.Generic.Collection<SecurityAttribute> security_attributes = declaration.security_attributes;
			if (security_attributes == null)
			{
				throw new NotSupportedException();
			}
			WriteCompressedUInt32((uint)security_attributes.Count);
			for (int i = 0; i < security_attributes.Count; i++)
			{
				WriteSecurityAttribute(security_attributes[i]);
			}
		}

		public void WriteXmlSecurityDeclaration(SecurityDeclaration declaration)
		{
			string xmlSecurityDeclaration = GetXmlSecurityDeclaration(declaration);
			if (xmlSecurityDeclaration == null)
			{
				throw new NotSupportedException();
			}
			WriteBytes(Encoding.Unicode.GetBytes(xmlSecurityDeclaration));
		}

		private static string GetXmlSecurityDeclaration(SecurityDeclaration declaration)
		{
			if (declaration.security_attributes == null || declaration.security_attributes.Count != 1)
			{
				return null;
			}
			SecurityAttribute securityAttribute = declaration.security_attributes[0];
			if (!securityAttribute.AttributeType.IsTypeOf("System.Security.Permissions", "PermissionSetAttribute"))
			{
				return null;
			}
			if (securityAttribute.properties == null || securityAttribute.properties.Count != 1)
			{
				return null;
			}
			CustomAttributeNamedArgument customAttributeNamedArgument = securityAttribute.properties[0];
			if (customAttributeNamedArgument.Name != "XML")
			{
				return null;
			}
			return (string)customAttributeNamedArgument.Argument.Value;
		}

		private void WriteTypeReference(TypeReference type)
		{
			WriteUTF8String(TypeParser.ToParseable(type));
		}

		public void WriteMarshalInfo(MarshalInfo marshal_info)
		{
			WriteNativeType(marshal_info.native);
			switch (marshal_info.native)
			{
			case NativeType.Array:
			{
				ArrayMarshalInfo arrayMarshalInfo = (ArrayMarshalInfo)marshal_info;
				if (arrayMarshalInfo.element_type != NativeType.None)
				{
					WriteNativeType(arrayMarshalInfo.element_type);
				}
				if (arrayMarshalInfo.size_parameter_index > -1)
				{
					WriteCompressedUInt32((uint)arrayMarshalInfo.size_parameter_index);
				}
				if (arrayMarshalInfo.size > -1)
				{
					WriteCompressedUInt32((uint)arrayMarshalInfo.size);
				}
				if (arrayMarshalInfo.size_parameter_multiplier > -1)
				{
					WriteCompressedUInt32((uint)arrayMarshalInfo.size_parameter_multiplier);
				}
				break;
			}
			case NativeType.SafeArray:
			{
				SafeArrayMarshalInfo safeArrayMarshalInfo = (SafeArrayMarshalInfo)marshal_info;
				if (safeArrayMarshalInfo.element_type != VariantType.None)
				{
					WriteVariantType(safeArrayMarshalInfo.element_type);
				}
				break;
			}
			case NativeType.FixedArray:
			{
				FixedArrayMarshalInfo fixedArrayMarshalInfo = (FixedArrayMarshalInfo)marshal_info;
				if (fixedArrayMarshalInfo.size > -1)
				{
					WriteCompressedUInt32((uint)fixedArrayMarshalInfo.size);
				}
				if (fixedArrayMarshalInfo.element_type != NativeType.None)
				{
					WriteNativeType(fixedArrayMarshalInfo.element_type);
				}
				break;
			}
			case NativeType.FixedSysString:
			{
				FixedSysStringMarshalInfo fixedSysStringMarshalInfo = (FixedSysStringMarshalInfo)marshal_info;
				if (fixedSysStringMarshalInfo.size > -1)
				{
					WriteCompressedUInt32((uint)fixedSysStringMarshalInfo.size);
				}
				break;
			}
			case NativeType.CustomMarshaler:
			{
				CustomMarshalInfo customMarshalInfo = (CustomMarshalInfo)marshal_info;
				WriteUTF8String((customMarshalInfo.guid != Guid.Empty) ? customMarshalInfo.guid.ToString() : string.Empty);
				WriteUTF8String(customMarshalInfo.unmanaged_type);
				WriteTypeReference(customMarshalInfo.managed_type);
				WriteUTF8String(customMarshalInfo.cookie);
				break;
			}
			}
		}

		private void WriteNativeType(NativeType native)
		{
			WriteByte((byte)native);
		}

		private void WriteVariantType(VariantType variant)
		{
			WriteByte((byte)variant);
		}
	}
	public delegate AssemblyDefinition AssemblyResolveEventHandler(object sender, AssemblyNameReference reference);
	public sealed class AssemblyResolveEventArgs : EventArgs
	{
		private readonly AssemblyNameReference reference;

		public AssemblyNameReference AssemblyReference => reference;

		public AssemblyResolveEventArgs(AssemblyNameReference reference)
		{
			this.reference = reference;
		}
	}
	[Serializable]
	public class AssemblyResolutionException : FileNotFoundException
	{
		private readonly AssemblyNameReference reference;

		public AssemblyNameReference AssemblyReference => reference;

		public AssemblyResolutionException(AssemblyNameReference reference)
			: base($"Failed to resolve assembly: '{reference}'")
		{
			this.reference = reference;
		}

		protected AssemblyResolutionException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
	public abstract class BaseAssemblyResolver : IAssemblyResolver
	{
		private static readonly bool on_mono = Type.GetType("Mono.Runtime") != null;

		private readonly Mono.Collections.Generic.Collection<string> directories;

		private Mono.Collections.Generic.Collection<string> gac_paths;

		public event AssemblyResolveEventHandler ResolveFailure;

		public void AddSearchDirectory(string directory)
		{
			directories.Add(directory);
		}

		public void RemoveSearchDirectory(string directory)
		{
			directories.Remove(directory);
		}

		public string[] GetSearchDirectories()
		{
			string[] array = new string[directories.size];
			Array.Copy(directories.items, array, array.Length);
			return array;
		}

		public virtual AssemblyDefinition Resolve(string fullName)
		{
			return Resolve(fullName, new ReaderParameters());
		}

		public virtual AssemblyDefinition Resolve(string fullName, ReaderParameters parameters)
		{
			if (fullName == null)
			{
				throw new ArgumentNullException("fullName");
			}
			return Resolve(AssemblyNameReference.Parse(fullName), parameters);
		}

		protected BaseAssemblyResolver()
		{
			directories = new Mono.Collections.Generic.Collection<string>(2) { ".", "bin" };
		}

		private AssemblyDefinition GetAssembly(string file, ReaderParameters parameters)
		{
			if (parameters.AssemblyResolver == null)
			{
				parameters.AssemblyResolver = this;
			}
			return ModuleDefinition.ReadModule(file, parameters).Assembly;
		}

		public virtual AssemblyDefinition Resolve(AssemblyNameReference name)
		{
			return Resolve(name, new ReaderParameters());
		}

		public virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			if (parameters == null)
			{
				parameters = new ReaderParameters();
			}
			AssemblyDefinition assemblyDefinition = SearchDirectory(name, directories, parameters);
			if (assemblyDefinition != null)
			{
				return assemblyDefinition;
			}
			if (name.IsRetargetable)
			{
				name = new AssemblyNameReference(name.Name, new Version(0, 0, 0, 0))
				{
					PublicKeyToken = Empty<byte>.Array
				};
			}
			string directoryName = Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName);
			if (IsZero(name.Version))
			{
				assemblyDefinition = SearchDirectory(name, new string[1] { directoryName }, parameters);
				if (assemblyDefinition != null)
				{
					return assemblyDefinition;
				}
			}
			if (name.Name == "mscorlib")
			{
				assemblyDefinition = GetCorlib(name, parameters);
				if (assemblyDefinition != null)
				{
					return assemblyDefinition;
				}
			}
			assemblyDefinition = GetAssemblyInGac(name, parameters);
			if (assemblyDefinition != null)
			{
				return assemblyDefinition;
			}
			assemblyDefinition = SearchDirectory(name, new string[1] { directoryName }, parameters);
			if (assemblyDefinition != null)
			{
				return assemblyDefinition;
			}
			if (this.ResolveFailure != null)
			{
				assemblyDefinition = this.ResolveFailure(this, name);
				if (assemblyDefinition != null)
				{
					return assemblyDefinition;
				}
			}
			throw new AssemblyResolutionException(name);
		}

		private AssemblyDefinition SearchDirectory(AssemblyNameReference name, IEnumerable<string> directories, ReaderParameters parameters)
		{
			string[] array = new string[2] { ".exe", ".dll" };
			foreach (string directory in directories)
			{
				string[] array2 = array;
				foreach (string text in array2)
				{
					string text2 = Path.Combine(directory, name.Name + text);
					if (File.Exists(text2))
					{
						return GetAssembly(text2, parameters);
					}
				}
			}
			return null;
		}

		private static bool IsZero(Version version)
		{
			if (!(version == null))
			{
				if (version.Major == 0 && version.Minor == 0 && version.Build == 0)
				{
					return version.Revision == 0;
				}
				return false;
			}
			return true;
		}

		private AssemblyDefinition GetCorlib(AssemblyNameReference reference, ReaderParameters parameters)
		{
			Version version = reference.Version;
			if (typeof(object).Assembly.GetName().Version == version || IsZero(version))
			{
				return GetAssembly(typeof(object).Module.FullyQualifiedName, parameters);
			}
			string fullName = Directory.GetParent(Directory.GetParent(typeof(object).Module.FullyQualifiedName).FullName).FullName;
			if (!on_mono)
			{
				fullName = version.Major switch
				{
					1 => (version.MajorRevision != 3300) ? Path.Combine(fullName, "v1.0.5000.0") : Path.Combine(fullName, "v1.0.3705"), 
					2 => Path.Combine(fullName, "v2.0.50727"), 
					4 => Path.Combine(fullName, "v4.0.30319"), 
					_ => throw new NotSupportedException("Version not supported: " + version), 
				};
			}
			else if (version.Major == 1)
			{
				fullName = Path.Combine(fullName, "1.0");
			}
			else if (version.Major == 2)
			{
				fullName = ((version.MajorRevision != 5) ? Path.Combine(fullName, "2.0") : Path.Combine(fullName, "2.1"));
			}
			else
			{
				if (version.Major != 4)
				{
					throw new NotSupportedException("Version not supported: " + version);
				}
				fullName = Path.Combine(fullName, "4.0");
			}
			string text = Path.Combine(fullName, "mscorlib.dll");
			if (File.Exists(text))
			{
				return GetAssembly(text, parameters);
			}
			return null;
		}

		private static Mono.Collections.Generic.Collection<string> GetGacPaths()
		{
			if (on_mono)
			{
				return GetDefaultMonoGacPaths();
			}
			Mono.Collections.Generic.Collection<string> collection = new Mono.Collections.Generic.Collection<string>(2);
			string environmentVariable = Environment.GetEnvironmentVariable("WINDIR");
			if (environmentVariable == null)
			{
				return collection;
			}
			collection.Add(Path.Combine(environmentVariable, "assembly"));
			collection.Add(Path.Combine(environmentVariable, Path.Combine("Microsoft.NET", "assembly")));
			return collection;
		}

		private static Mono.Collections.Generic.Collection<string> GetDefaultMonoGacPaths()
		{
			Mono.Collections.Generic.Collection<string> collection = new Mono.Collections.Generic.Collection<string>(1);
			string currentMonoGac = GetCurrentMonoGac();
			if (currentMonoGac != null)
			{
				collection.Add(currentMonoGac);
			}
			string environmentVariable = Environment.GetEnvironmentVariable("MONO_GAC_PREFIX");
			if (string.IsNullOrEmpty(environmentVariable))
			{
				return collection;
			}
			string[] array = environmentVariable.Split(new char[1] { Path.PathSeparator });
			foreach (string text in array)
			{
				if (!string.IsNullOrEmpty(text))
				{
					string text2 = Path.Combine(Path.Combine(Path.Combine(text, "lib"), "mono"), "gac");
					if (Directory.Exists(text2) && !collection.Contains(currentMonoGac))
					{
						collection.Add(text2);
					}
				}
			}
			return collection;
		}

		private static string GetCurrentMonoGac()
		{
			return Path.Combine(Directory.GetParent(Path.GetDirectoryName(typeof(object).Module.FullyQualifiedName)).FullName, "gac");
		}

		private AssemblyDefinition GetAssemblyInGac(AssemblyNameReference reference, ReaderParameters parameters)
		{
			if (reference.PublicKeyToken == null || reference.PublicKeyToken.Length == 0)
			{
				return null;
			}
			if (gac_paths == null)
			{
				gac_paths = GetGacPaths();
			}
			if (on_mono)
			{
				return GetAssemblyInMonoGac(reference, parameters);
			}
			return GetAssemblyInNetGac(reference, parameters);
		}

		private AssemblyDefinition GetAssemblyInMonoGac(AssemblyNameReference reference, ReaderParameters parameters)
		{
			for (int i = 0; i < gac_paths.Count; i++)
			{
				string gac = gac_paths[i];
				string assemblyFile = GetAssemblyFile(reference, string.Empty, gac);
				if (File.Exists(assemblyFile))
				{
					return GetAssembly(assemblyFile, parameters);
				}
			}
			return null;
		}

		private AssemblyDefinition GetAssemblyInNetGac(AssemblyNameReference reference, ReaderParameters parameters)
		{
			string[] array = new string[4] { "GAC_MSIL", "GAC_32", "GAC_64", "GAC" };
			string[] array2 = new string[2]
			{
				string.Empty,
				"v4.0_"
			};
			for (int i = 0; i < 2; i++)
			{
				for (int j = 0; j < array.Length; j++)
				{
					string text = Path.Combine(gac_paths[i], array[j]);
					string assemblyFile = GetAssemblyFile(reference, array2[i], text);
					if (Directory.Exists(text) && File.Exists(assemblyFile))
					{
						return GetAssembly(assemblyFile, parameters);
					}
				}
			}
			return null;
		}

		private static string GetAssemblyFile(AssemblyNameReference reference, string prefix, string gac)
		{
			StringBuilder stringBuilder = new StringBuilder().Append(prefix).Append(reference.Version).Append("__");
			for (int i = 0; i < reference.PublicKeyToken.Length; i++)
			{
				stringBuilder.Append(reference.PublicKeyToken[i].ToString("x2"));
			}
			return Path.Combine(Path.Combine(Path.Combine(gac, reference.Name), stringBuilder.ToString()), reference.Name + ".dll");
		}
	}
	public sealed class CallSite : IMethodSignature, IMetadataTokenProvider
	{
		private readonly MethodReference signature;

		public bool HasThis
		{
			get
			{
				return signature.HasThis;
			}
			set
			{
				signature.HasThis = value;
			}
		}

		public bool ExplicitThis
		{
			get
			{
				return signature.ExplicitThis;
			}
			set
			{
				signature.ExplicitThis = value;
			}
		}

		public MethodCallingConvention CallingConvention
		{
			get
			{
				return signature.CallingConvention;
			}
			set
			{
				signature.CallingConvention = value;
			}
		}

		public bool HasParameters => signature.HasParameters;

		public Mono.Collections.Generic.Collection<ParameterDefinition> Parameters => signature.Parameters;

		public TypeReference ReturnType
		{
			get
			{
				return signature.MethodReturnType.ReturnType;
			}
			set
			{
				signature.MethodReturnType.ReturnType = value;
			}
		}

		public MethodReturnType MethodReturnType => signature.MethodReturnType;

		public string Name
		{
			get
			{
				return string.Empty;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public string Namespace
		{
			get
			{
				return string.Empty;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public ModuleDefinition Module => ReturnType.Module;

		public IMetadataScope Scope => signature.ReturnType.Scope;

		public MetadataToken MetadataToken
		{
			get
			{
				return signature.token;
			}
			set
			{
				signature.token = value;
			}
		}

		public string FullName
		{
			get
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(ReturnType.FullName);
				this.MethodSignatureFullName(stringBuilder);
				return stringBuilder.ToString();
			}
		}

		internal CallSite()
		{
			signature = new MethodReference();
			signature.token = new MetadataToken(TokenType.Signature, 0);
		}

		public CallSite(TypeReference returnType)
			: this()
		{
			if (returnType == null)
			{
				throw new ArgumentNullException("returnType");
			}
			signature.ReturnType = returnType;
		}

		public override string ToString()
		{
			return FullName;
		}
	}
	internal class TypeParser
	{
		private class Type
		{
			public const int Ptr = -1;

			public const int ByRef = -2;

			public const int SzArray = -3;

			public string type_fullname;

			public string[] nested_names;

			public int arity;

			public int[] specs;

			public Type[] generic_arguments;

			public string assembly;
		}

		private readonly string fullname;

		private readonly int length;

		private int position;

		private TypeParser(string fullname)
		{
			this.fullname = fullname;
			length = fullname.Length;
		}

		private Type ParseType(bool fq_name)
		{
			Type type = new Type();
			type.type_fullname = ParsePart();
			type.nested_names = ParseNestedNames();
			if (TryGetArity(type))
			{
				type.generic_arguments = ParseGenericArguments(type.arity);
			}
			type.specs = ParseSpecs();
			if (fq_name)
			{
				type.assembly = ParseAssemblyName();
			}
			return type;
		}

		private static bool TryGetArity(Type type)
		{
			int arity = 0;
			TryAddArity(type.type_fullname, ref arity);
			string[] nested_names = type.nested_names;
			if (!nested_names.IsNullOrEmpty())
			{
				for (int i = 0; i < nested_names.Length; i++)
				{
					TryAddArity(nested_names[i], ref arity);
				}
			}
			type.arity = arity;
			return arity > 0;
		}

		private static bool TryGetArity(string name, out int arity)
		{
			arity = 0;
			int num = name.LastIndexOf('`');
			if (num == -1)
			{
				return false;
			}
			return ParseInt32(name.Substring(num + 1), out arity);
		}

		private static bool ParseInt32(string value, out int result)
		{
			return int.TryParse(value, out result);
		}

		private static void TryAddArity(string name, ref int arity)
		{
			if (TryGetArity(name, out var arity2))
			{
				arity += arity2;
			}
		}

		private string ParsePart()
		{
			StringBuilder stringBuilder = new StringBuilder();
			while (position < length && !IsDelimiter(fullname[position]))
			{
				if (fullname[position] == '\\')
				{
					position++;
				}
				stringBuilder.Append(fullname[position++]);
			}
			return stringBuilder.ToString();
		}

		private static bool IsDelimiter(char chr)
		{
			return "+,[]*&".IndexOf(chr) != -1;
		}

		private void TryParseWhiteSpace()
		{
			while (position < length && char.IsWhiteSpace(fullname[position]))
			{
				position++;
			}
		}

		private string[] ParseNestedNames()
		{
			string[] array = null;
			while (TryParse('+'))
			{
				Add(ref array, ParsePart());
			}
			return array;
		}

		private bool TryParse(char chr)
		{
			if (position < length && fullname[position] == chr)
			{
				position++;
				return true;
			}
			return false;
		}

		private static void Add<T>(ref T[] array, T item)
		{
			if (array == null)
			{
				array = new T[1] { item };
			}
			else
			{
				array = array.Resize(array.Length + 1);
				array[array.Length - 1] = item;
			}
		}

		private int[] ParseSpecs()
		{
			int[] array = null;
			while (position < length)
			{
				switch (fullname[position])
				{
				case '*':
					position++;
					Add(ref array, -1);
					break;
				case '&':
					position++;
					Add(ref array, -2);
					break;
				case '[':
					position++;
					switch (fullname[position])
					{
					case ']':
						position++;
						Add(ref array, -3);
						break;
					case '*':
						position++;
						Add(ref array, 1);
						break;
					default:
					{
						int num = 1;
						while (TryParse(','))
						{
							num++;
						}
						Add(ref array, num);
						TryParse(']');
						break;
					}
					}
					break;
				default:
					return array;
				}
			}
			return array;
		}

		private Type[] ParseGenericArguments(int arity)
		{
			Type[] array = null;
			if (position == length || fullname[position] != '[')
			{
				return array;
			}
			TryParse('[');
			for (int i = 0; i < arity; i++)
			{
				bool flag = TryParse('[');
				Add(ref array, ParseType(flag));
				if (flag)
				{
					TryParse(']');
				}
				TryParse(',');
				TryParseWhiteSpace();
			}
			TryParse(']');
			return array;
		}

		private string ParseAssemblyName()
		{
			if (!TryParse(','))
			{
				return string.Empty;
			}
			TryParseWhiteSpace();
			int num = position;
			while (position < length)
			{
				char c = fullname[position];
				if (c == '[' || c == ']')
				{
					break;
				}
				position++;
			}
			return fullname.Substring(num, position - num);
		}

		public static TypeReference ParseType(ModuleDefinition module, string fullname)
		{
			if (string.IsNullOrEmpty(fullname))
			{
				return null;
			}
			TypeParser typeParser = new TypeParser(fullname);
			return GetTypeReference(module, typeParser.ParseType(fq_name: true));
		}

		private static TypeReference GetTypeReference(ModuleDefinition module, Type type_info)
		{
			if (!TryGetDefinition(module, type_info, out var type))
			{
				type = CreateReference(type_info, module, GetMetadataScope(module, type_info));
			}
			return CreateSpecs(type, type_info);
		}

		private static TypeReference CreateSpecs(TypeReference type, Type type_info)
		{
			type = TryCreateGenericInstanceType(type, type_info);
			int[] specs = type_info.specs;
			if (specs.IsNullOrEmpty())
			{
				return type;
			}
			for (int i = 0; i < specs.Length; i++)
			{
				switch (specs[i])
				{
				case -1:
					type = new PointerType(type);
					continue;
				case -2:
					type = new ByReferenceType(type);
					continue;
				case -3:
					type = new ArrayType(type);
					continue;
				}
				ArrayType arrayType = new ArrayType(type);
				arrayType.Dimensions.Clear();
				for (int j = 0; j < specs[i]; j++)
				{
					arrayType.Dimensions.Add(default(ArrayDimension));
				}
				type = arrayType;
			}
			return type;
		}

		private static TypeReference TryCreateGenericInstanceType(TypeReference type, Type type_info)
		{
			Type[] generic_arguments = type_info.generic_arguments;
			if (generic_arguments.IsNullOrEmpty())
			{
				return type;
			}
			GenericInstanceType genericInstanceType = new GenericInstanceType(type);
			Mono.Collections.Generic.Collection<TypeReference> genericArguments = genericInstanceType.GenericArguments;
			for (int i = 0; i < generic_arguments.Length; i++)
			{
				genericArguments.Add(GetTypeReference(type.Module, generic_arguments[i]));
			}
			return genericInstanceType;
		}

		public static void SplitFullName(string fullname, out string @namespace, out string name)
		{
			int num = fullname.LastIndexOf('.');
			if (num == -1)
			{
				@namespace = string.Empty;
				name = fullname;
			}
			else
			{
				@namespace = fullname.Substring(0, num);
				name = fullname.Substring(num + 1);
			}
		}

		private static TypeReference CreateReference(Type type_info, ModuleDefinition module, IMetadataScope scope)
		{
			SplitFullName(type_info.type_fullname, out var @namespace, out var name);
			TypeReference typeReference = new TypeReference(@namespace, name, module, scope);
			MetadataSystem.TryProcessPrimitiveTypeReference(typeReference);
			AdjustGenericParameters(typeReference);
			string[] nested_names = type_info.nested_names;
			if (nested_names.IsNullOrEmpty())
			{
				return typeReference;
			}
			for (int i = 0; i < nested_names.Length; i++)
			{
				typeReference = new TypeReference(string.Empty, nested_names[i], module, null)
				{
					DeclaringType = typeReference
				};
				AdjustGenericParameters(typeReference);
			}
			return typeReference;
		}

		private static void AdjustGenericParameters(TypeReference type)
		{
			if (TryGetArity(type.Name, out var arity))
			{
				for (int i = 0; i < arity; i++)
				{
					type.GenericParameters.Add(new GenericParameter(type));
				}
			}
		}

		private static IMetadataScope GetMetadataScope(ModuleDefinition module, Type type_info)
		{
			if (string.IsNullOrEmpty(type_info.assembly))
			{
				return module.TypeSystem.Corlib;
			}
			return MatchReference(module, AssemblyNameReference.Parse(type_info.assembly));
		}

		private static AssemblyNameReference MatchReference(ModuleDefinition module, AssemblyNameReference pattern)
		{
			Mono.Collections.Generic.Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
			for (int i = 0; i < assemblyReferences.Count; i++)
			{
				AssemblyNameReference assemblyNameReference = assemblyReferences[i];
				if (assemblyNameReference.FullName == pattern.FullName)
				{
					return assemblyNameReference;
				}
			}
			return pattern;
		}

		private static bool TryGetDefinition(ModuleDefinition module, Type type_info, out TypeReference type)
		{
			type = null;
			if (!TryCurrentModule(module, type_info))
			{
				return false;
			}
			TypeDefinition typeDefinition = module.GetType(type_info.type_fullname);
			if (typeDefinition == null)
			{
				return false;
			}
			string[] nested_names = type_info.nested_names;
			if (!nested_names.IsNullOrEmpty())
			{
				for (int i = 0; i < nested_names.Length; i++)
				{
					typeDefinition = typeDefinition.GetNestedType(nested_names[i]);
				}
			}
			type = typeDefinition;
			return true;
		}

		private static bool TryCurrentModule(ModuleDefinition module, Type type_info)
		{
			if (string.IsNullOrEmpty(type_info.assembly))
			{
				return true;
			}
			if (module.assembly != null && module.assembly.Name.FullName == type_info.assembly)
			{
				return true;
			}
			return false;
		}

		public static string ToParseable(TypeReference type)
		{
			if (type == null)
			{
				return null;
			}
			StringBuilder stringBuilder = new StringBuilder();
			AppendType(type, stringBuilder, fq_name: true, top_level: true);
			return stringBuilder.ToString();
		}

		private static void AppendNamePart(string part, StringBuilder name)
		{
			foreach (char c in part)
			{
				if (IsDelimiter(c))
				{
					name.Append('\\');
				}
				name.Append(c);
			}
		}

		private static void AppendType(TypeReference type, StringBuilder name, bool fq_name, bool top_level)
		{
			TypeReference declaringType = type.DeclaringType;
			if (declaringType != null)
			{
				AppendType(declaringType, name, fq_name: false, top_level);
				name.Append('+');
			}
			string text = type.Namespace;
			if (!string.IsNullOrEmpty(text))
			{
				AppendNamePart(text, name);
				name.Append('.');
			}
			AppendNamePart(type.GetElementType().Name, name);
			if (fq_name)
			{
				if (type.IsTypeSpecification())
				{
					AppendTypeSpecification((TypeSpecification)type, name);
				}
				if (RequiresFullyQualifiedName(type, top_level))
				{
					name.Append(", ");
					name.Append(GetScopeFullName(type));
				}
			}
		}

		private static string GetScopeFullName(TypeReference type)
		{
			IMetadataScope scope = type.Scope;
			return scope.MetadataScopeType switch
			{
				MetadataScopeType.AssemblyNameReference => ((AssemblyNameReference)scope).FullName, 
				MetadataScopeType.ModuleDefinition => ((ModuleDefinition)scope).Assembly.Name.FullName, 
				_ => throw new ArgumentException(), 
			};
		}

		private static void AppendTypeSpecification(TypeSpecification type, StringBuilder name)
		{
			if (type.ElementType.IsTypeSpecification())
			{
				AppendTypeSpecification((TypeSpecification)type.ElementType, name);
			}
			switch (type.etype)
			{
			case ElementType.Ptr:
				name.Append('*');
				break;
			case ElementType.ByRef:
				name.Append('&');
				break;
			case ElementType.Array:
			case ElementType.SzArray:
			{
				ArrayType arrayType = (ArrayType)type;
				if (arrayType.IsVector)
				{
					name.Append("[]");
					break;
				}
				name.Append('[');
				for (int j = 1; j < arrayType.Rank; j++)
				{
					name.Append(',');
				}
				name.Append(']');
				break;
			}
			case ElementType.GenericInst:
			{
				Mono.Collections.Generic.Collection<TypeReference> genericArguments = ((GenericInstanceType)type).GenericArguments;
				name.Append('[');
				for (int i = 0; i < genericArguments.Count; i++)
				{
					if (i > 0)
					{
						name.Append(',');
					}
					TypeReference typeReference = genericArguments[i];
					bool num = typeReference.Scope != typeReference.Module;
					if (num)
					{
						name.Append('[');
					}
					AppendType(typeReference, name, fq_name: true, top_level: false);
					if (num)
					{
						name.Append(']');
					}
				}
				name.Append(']');
				break;
			}
			}
		}

		private static bool RequiresFullyQualifiedName(TypeReference type, bool top_level)
		{
			if (type.Scope == type.Module)
			{
				return false;
			}
			if (type.Scope.Name == "mscorlib" && top_level)
			{
				return false;
			}
			return true;
		}
	}
	internal enum ImportGenericKind
	{
		Definition,
		Open
	}
	internal struct ImportGenericContext
	{
		private Mono.Collections.Generic.Collection<IGenericParameterProvider> stack;

		public bool IsEmpty => stack == null;

		public ImportGenericContext(IGenericParameterProvider provider)
		{
			stack = null;
			Push(provider);
		}

		public void Push(IGenericParameterProvider provider)
		{
			if (stack == null)
			{
				stack = new Mono.Collections.Generic.Collection<IGenericParameterProvider>(1) { provider };
			}
			else
			{
				stack.Add(provider);
			}
		}

		public void Pop()
		{
			stack.RemoveAt(stack.Count - 1);
		}

		public TypeReference MethodParameter(string method, int position)
		{
			for (int num = stack.Count - 1; num >= 0; num--)
			{
				if (stack[num] is MethodReference methodReference && !(method != NormalizeMethodName(methodReference)))
				{
					return methodReference.GenericParameters[position];
				}
			}
			throw new InvalidOperationException();
		}

		public string NormalizeMethodName(MethodReference method)
		{
			return method.DeclaringType.GetElementType().FullName + "." + method.Name;
		}

		public TypeReference TypeParameter(string type, int position)
		{
			for (int num = stack.Count - 1; num >= 0; num--)
			{
				TypeReference typeReference = GenericTypeFor(stack[num]);
				if (!(typeReference.FullName != type))
				{
					return typeReference.GenericParameters[position];
				}
			}
			throw new InvalidOperationException();
		}

		private static TypeReference GenericTypeFor(IGenericParameterProvider context)
		{
			if (context is TypeReference typeReference)
			{
				return typeReference.GetElementType();
			}
			if (context is MethodReference methodReference)
			{
				return methodReference.DeclaringType.GetElementType();
			}
			throw new InvalidOperationException();
		}
	}
	internal class MetadataImporter
	{
		private readonly ModuleDefinition module;

		private static readonly Dictionary<Type, ElementType> type_etype_mapping = new Dictionary<Type, ElementType>(18)
		{
			{
				typeof(void),
				ElementType.Void
			},
			{
				typeof(bool),
				ElementType.Boolean
			},
			{
				typeof(char),
				ElementType.Char
			},
			{
				typeof(sbyte),
				ElementType.I1
			},
			{
				typeof(byte),
				ElementType.U1
			},
			{
				typeof(short),
				ElementType.I2
			},
			{
				typeof(ushort),
				ElementType.U2
			},
			{
				typeof(int),
				ElementType.I4
			},
			{
				typeof(uint),
				ElementType.U4
			},
			{
				typeof(long),
				ElementType.I8
			},
			{
				typeof(ulong),
				ElementType.U8
			},
			{
				typeof(float),
				ElementType.R4
			},
			{
				typeof(double),
				ElementType.R8
			},
			{
				typeof(string),
				ElementType.String
			},
			{
				typeof(TypedReference),
				ElementType.TypedByRef
			},
			{
				typeof(IntPtr),
				ElementType.I
			},
			{
				typeof(UIntPtr),
				ElementType.U
			},
			{
				typeof(object),
				ElementType.Object
			}
		};

		public MetadataImporter(ModuleDefinition module)
		{
			this.module = module;
		}

		public TypeReference ImportType(Type type, ImportGenericContext context)
		{
			return ImportType(type, context, ImportGenericKind.Open);
		}

		public TypeReference ImportType(Type type, ImportGenericContext context, ImportGenericKind import_kind)
		{
			if (IsTypeSpecification(type) || ImportOpenGenericType(type, import_kind))
			{
				return ImportTypeSpecification(type, context);
			}
			TypeReference typeReference = new TypeReference(string.Empty, type.Name, module, ImportScope(type.Assembly), type.IsValueType);
			typeReference.etype = ImportElementType(type);
			if (IsNestedType(type))
			{
				typeReference.DeclaringType = ImportType(type.DeclaringType, context, import_kind);
			}
			else
			{
				typeReference.Namespace = type.Namespace ?? string.Empty;
			}
			if (type.IsGenericType)
			{
				ImportGenericParameters(typeReference, type.GetGenericArguments());
			}
			return typeReference;
		}

		private static bool ImportOpenGenericType(Type type, ImportGenericKind import_kind)
		{
			if (type.IsGenericType && type.IsGenericTypeDefinition)
			{
				return import_kind == ImportGenericKind.Open;
			}
			return false;
		}

		private static bool ImportOpenGenericMethod(MethodBase method, ImportGenericKind import_kind)
		{
			if (method.IsGenericMethod && method.IsGenericMethodDefinition)
			{
				return import_kind == ImportGenericKind.Open;
			}
			return false;
		}

		private static bool IsNestedType(Type type)
		{
			return type.IsNested;
		}

		private TypeReference ImportTypeSpecification(Type type, ImportGenericContext context)
		{
			if (type.IsByRef)
			{
				return new ByReferenceType(ImportType(type.GetElementType(), context));
			}
			if (type.IsPointer)
			{
				return new PointerType(ImportType(type.GetElementType(), context));
			}
			if (type.IsArray)
			{
				return new ArrayType(ImportType(type.GetElementType(), context), type.GetArrayRank());
			}
			if (type.IsGenericType)
			{
				return ImportGenericInstance(type, context);
			}
			if (type.IsGenericParameter)
			{
				return ImportGenericParameter(type, context);
			}
			throw new NotSupportedException(type.FullName);
		}

		private static TypeReference ImportGenericParameter(Type type, ImportGenericContext context)
		{
			if (context.IsEmpty)
			{
				throw new InvalidOperationException();
			}
			if (type.DeclaringMethod != null)
			{
				return context.MethodParameter(NormalizeMethodName(type.DeclaringMethod), type.GenericParameterPosition);
			}
			if (type.DeclaringType != null)
			{
				return context.TypeParameter(NormalizeTypeFullName(type.DeclaringType), type.GenericParameterPosition);
			}
			throw new InvalidOperationException();
		}

		private static string NormalizeMethodName(MethodBase method)
		{
			return NormalizeTypeFullName(method.DeclaringType) + "." + method.Name;
		}

		private static string NormalizeTypeFullName(Type type)
		{
			if (IsNestedType(type))
			{
				return NormalizeTypeFullName(type.DeclaringType) + "/" + type.Name;
			}
			return type.FullName;
		}

		private TypeReference ImportGenericInstance(Type type, ImportGenericContext context)
		{
			TypeReference typeReference = ImportType(type.GetGenericTypeDefinition(), context, ImportGenericKind.Definition);
			GenericInstanceType genericInstanceType = new GenericInstanceType(typeReference);
			Type[] genericArguments = type.GetGenericArguments();
			Mono.Collections.Generic.Collection<TypeReference> genericArguments2 = genericInstanceType.GenericArguments;
			context.Push(typeReference);
			try
			{
				for (int i = 0; i < genericArguments.Length; i++)
				{
					genericArguments2.Add(ImportType(genericArguments[i], context));
				}
				return genericInstanceType;
			}
			finally
			{
				context.Pop();
			}
		}

		private static bool IsTypeSpecification(Type type)
		{
			if (!type.HasElementType && !IsGenericInstance(type))
			{
				return type.IsGenericParameter;
			}
			return true;
		}

		private static bool IsGenericInstance(Type type)
		{
			if (type.IsGenericType)
			{
				return !type.IsGenericTypeDefinition;
			}
			return false;
		}

		private static ElementType ImportElementType(Type type)
		{
			if (!type_etype_mapping.TryGetValue(type, out var value))
			{
				return ElementType.None;
			}
			return value;
		}

		private AssemblyNameReference ImportScope(Assembly assembly)
		{
			AssemblyName name = assembly.GetName();
			if (TryGetAssemblyNameReference(name, out var assembly_reference))
			{
				return assembly_reference;
			}
			assembly_reference = new AssemblyNameReference(name.Name, name.Version)
			{
				Culture = name.CultureInfo.Name,
				PublicKeyToken = name.GetPublicKeyToken(),
				HashAlgorithm = (AssemblyHashAlgorithm)name.HashAlgorithm
			};
			module.AssemblyReferences.Add(assembly_reference);
			return assembly_reference;
		}

		private bool TryGetAssemblyNameReference(AssemblyName name, out AssemblyNameReference assembly_reference)
		{
			Mono.Collections.Generic.Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
			for (int i = 0; i < assemblyReferences.Count; i++)
			{
				AssemblyNameReference assemblyNameReference = assemblyReferences[i];
				if (!(name.FullName != assemblyNameReference.FullName))
				{
					assembly_reference = assemblyNameReference;
					return true;
				}
			}
			assembly_reference = null;
			return false;
		}

		public FieldReference ImportField(FieldInfo field, ImportGenericContext context)
		{
			TypeReference typeReference = ImportType(field.DeclaringType, context);
			if (IsGenericInstance(field.DeclaringType))
			{
				field = ResolveFieldDefinition(field);
			}
			context.Push(typeReference);
			try
			{
				return new FieldReference
				{
					Name = field.Name,
					DeclaringType = typeReference,
					FieldType = ImportType(field.FieldType, context)
				};
			}
			finally
			{
				context.Pop();
			}
		}

		private static FieldInfo ResolveFieldDefinition(FieldInfo field)
		{
			return field.Module.ResolveField(field.MetadataToken);
		}

		public MethodReference ImportMethod(MethodBase method, ImportGenericContext context, ImportGenericKind import_kind)
		{
			if (IsMethodSpecification(method) || ImportOpenGenericMethod(method, import_kind))
			{
				return ImportMethodSpecification(method, context);
			}
			TypeReference declaringType = ImportType(method.DeclaringType, context);
			if (IsGenericInstance(method.DeclaringType))
			{
				method = method.Module.ResolveMethod(method.MetadataToken);
			}
			MethodReference methodReference = new MethodReference
			{
				Name = method.Name,
				HasThis = HasCallingConvention(method, CallingConventions.HasThis),
				ExplicitThis = HasCallingConvention(method, CallingConventions.ExplicitThis),
				DeclaringType = ImportType(method.DeclaringType, context, ImportGenericKind.Definition)
			};
			if (HasCallingConvention(method, CallingConventions.VarArgs))
			{
				methodReference.CallingConvention &= MethodCallingConvention.VarArg;
			}
			if (method.IsGenericMethod)
			{
				ImportGenericParameters(methodReference, method.GetGenericArguments());
			}
			context.Push(methodReference);
			try
			{
				MethodInfo methodInfo = method as MethodInfo;
				methodReference.ReturnType = ((methodInfo != null) ? ImportType(methodInfo.ReturnType, context) : ImportType(typeof(void), default(ImportGenericContext)));
				ParameterInfo[] parameters = method.GetParameters();
				Mono.Collections.Generic.Collection<ParameterDefinition> parameters2 = methodReference.Parameters;
				for (int i = 0; i < parameters.Length; i++)
				{
					parameters2.Add(new ParameterDefinition(ImportType(parameters[i].ParameterType, context)));
				}
				methodReference.DeclaringType = declaringType;
				return methodReference;
			}
			finally
			{
				context.Pop();
			}
		}

		private static void ImportGenericParameters(IGenericParameterProvider provider, Type[] arguments)
		{
			Mono.Collections.Generic.Collection<GenericParameter> genericParameters = provider.GenericParameters;
			for (int i = 0; i < arguments.Length; i++)
			{
				genericParameters.Add(new GenericParameter(arguments[i].Name, provider));
			}
		}

		private static bool IsMethodSpecification(MethodBase method)
		{
			if (method.IsGenericMethod)
			{
				return !method.IsGenericMethodDefinition;
			}
			return false;
		}

		private MethodReference ImportMethodSpecification(MethodBase method, ImportGenericContext context)
		{
			MethodInfo methodInfo = method as MethodInfo;
			if (methodInfo == null)
			{
				throw new InvalidOperationException();
			}
			MethodReference methodReference = ImportMethod(methodInfo.GetGenericMethodDefinition(), context, ImportGenericKind.Definition);
			GenericInstanceMethod genericInstanceMethod = new GenericInstanceMethod(methodReference);
			Type[] genericArguments = method.GetGenericArguments();
			Mono.Collections.Generic.Collection<TypeReference> genericArguments2 = genericInstanceMethod.GenericArguments;
			context.Push(methodReference);
			try
			{
				for (int i = 0; i < genericArguments.Length; i++)
				{
					genericArguments2.Add(ImportType(genericArguments[i], context));
				}
				return genericInstanceMethod;
			}
			finally
			{
				context.Pop();
			}
		}

		private static bool HasCallingConvention(MethodBase method, CallingConventions conventions)
		{
			return (method.CallingConvention & conventions) != 0;
		}

		public TypeReference ImportType(TypeReference type, ImportGenericContext context)
		{
			if (type.IsTypeSpecification())
			{
				return ImportTypeSpecification(type, context);
			}
			TypeReference typeReference = new TypeReference(type.Namespace, type.Name, module, ImportScope(type.Scope), type.IsValueType);
			MetadataSystem.TryProcessPrimitiveTypeReference(typeReference);
			if (type.IsNested)
			{
				typeReference.DeclaringType = ImportType(type.DeclaringType, context);
			}
			if (type.HasGenericParameters)
			{
				ImportGenericParameters(typeReference, type);
			}
			return typeReference;
		}

		private IMetadataScope ImportScope(IMetadataScope scope)
		{
			switch (scope.MetadataScopeType)
			{
			case MetadataScopeType.AssemblyNameReference:
				return ImportAssemblyName((AssemblyNameReference)scope);
			case MetadataScopeType.ModuleDefinition:
				if (scope == module)
				{
					return scope;
				}
				return ImportAssemblyName(((ModuleDefinition)scope).Assembly.Name);
			case MetadataScopeType.ModuleReference:
				throw new NotImplementedException();
			default:
				throw new NotSupportedException();
			}
		}

		private AssemblyNameReference ImportAssemblyName(AssemblyNameReference name)
		{
			if (TryGetAssemblyNameReference(name, out var assembly_reference))
			{
				return assembly_reference;
			}
			assembly_reference = new AssemblyNameReference(name.Name, name.Version)
			{
				Culture = name.Culture,
				HashAlgorithm = name.HashAlgorithm,
				IsRetargetable = name.IsRetargetable
			};
			byte[] array = ((!name.PublicKeyToken.IsNullOrEmpty()) ? new byte[name.PublicKeyToken.Length] : Empty<byte>.Array);
			if (array.Length != 0)
			{
				Buffer.BlockCopy(name.PublicKeyToken, 0, array, 0, array.Length);
			}
			assembly_reference.PublicKeyToken = array;
			module.AssemblyReferences.Add(assembly_reference);
			return assembly_reference;
		}

		private bool TryGetAssemblyNameReference(AssemblyNameReference name_reference, out AssemblyNameReference assembly_reference)
		{
			Mono.Collections.Generic.Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
			for (int i = 0; i < assemblyReferences.Count; i++)
			{
				AssemblyNameReference assemblyNameReference = assemblyReferences[i];
				if (!(name_reference.FullName != assemblyNameReference.FullName))
				{
					assembly_reference = assemblyNameReference;
					return true;
				}
			}
			assembly_reference = null;
			return false;
		}

		private static void ImportGenericParameters(IGenericParameterProvider imported, IGenericParameterProvider original)
		{
			Mono.Collections.Generic.Collection<GenericParameter> genericParameters = original.GenericParameters;
			Mono.Collections.Generic.Collection<GenericParameter> genericParameters2 = imported.GenericParameters;
			for (int i = 0; i < genericParameters.Count; i++)
			{
				genericParameters2.Add(new GenericParameter(genericParameters[i].Name, imported));
			}
		}

		private TypeReference ImportTypeSpecification(TypeReference type, ImportGenericContext context)
		{
			switch (type.etype)
			{
			case ElementType.SzArray:
			{
				ArrayType arrayType = (ArrayType)type;
				return new ArrayType(ImportType(arrayType.ElementType, context));
			}
			case ElementType.Ptr:
			{
				PointerType pointerType = (PointerType)type;
				return new PointerType(ImportType(pointerType.ElementType, context));
			}
			case ElementType.ByRef:
			{
				ByReferenceType byReferenceType = (ByReferenceType)type;
				return new ByReferenceType(ImportType(byReferenceType.ElementType, context));
			}
			case ElementType.Pinned:
			{
				PinnedType pinnedType = (PinnedType)type;
				return new PinnedType(ImportType(pinnedType.ElementType, context));
			}
			case ElementType.Sentinel:
			{
				SentinelType sentinelType = (SentinelType)type;
				return new SentinelType(ImportType(sentinelType.ElementType, context));
			}
			case ElementType.CModOpt:
			{
				OptionalModifierType optionalModifierType = (OptionalModifierType)type;
				return new OptionalModifierType(ImportType(optionalModifierType.ModifierType, context), ImportType(optionalModifierType.ElementType, context));
			}
			case ElementType.CModReqD:
			{
				RequiredModifierType requiredModifierType = (RequiredModifierType)type;
				return new RequiredModifierType(ImportType(requiredModifierType.ModifierType, context), ImportType(requiredModifierType.ElementType, context));
			}
			case ElementType.Array:
			{
				ArrayType arrayType2 = (ArrayType)type;
				ArrayType arrayType3 = new ArrayType(ImportType(arrayType2.ElementType, context));
				if (arrayType2.IsVector)
				{
					return arrayType3;
				}
				Mono.Collections.Generic.Collection<ArrayDimension> dimensions = arrayType2.Dimensions;
				Mono.Collections.Generic.Collection<ArrayDimension> dimensions2 = arrayType3.Dimensions;
				dimensions2.Clear();
				for (int j = 0; j < dimensions.Count; j++)
				{
					ArrayDimension arrayDimension = dimensions[j];
					dimensions2.Add(new ArrayDimension(arrayDimension.LowerBound, arrayDimension.UpperBound));
				}
				return arrayType3;
			}
			case ElementType.GenericInst:
			{
				GenericInstanceType genericInstanceType = (GenericInstanceType)type;
				GenericInstanceType genericInstanceType2 = new GenericInstanceType(ImportType(genericInstanceType.ElementType, context));
				Mono.Collections.Generic.Collection<TypeReference> genericArguments = genericInstanceType.GenericArguments;
				Mono.Collections.Generic.Collection<TypeReference> genericArguments2 = genericInstanceType2.GenericArguments;
				for (int i = 0; i < genericArguments.Count; i++)
				{
					genericArguments2.Add(ImportType(genericArguments[i], context));
				}
				return genericInstanceType2;
			}
			case ElementType.Var:
			{
				GenericParameter genericParameter2 = (GenericParameter)type;
				if (genericParameter2.DeclaringType == null)
				{
					throw new InvalidOperationException();
				}
				return context.TypeParameter(genericParameter2.DeclaringType.FullName, genericParameter2.Position);
			}
			case ElementType.MVar:
			{
				GenericParameter genericParameter = (GenericParameter)type;
				if (genericParameter.DeclaringMethod == null)
				{
					throw new InvalidOperationException();
				}
				return context.MethodParameter(context.NormalizeMethodName(genericParameter.DeclaringMethod), genericParameter.Position);
			}
			default:
				throw new NotSupportedException(type.etype.ToString());
			}
		}

		public FieldReference ImportField(FieldReference field, ImportGenericContext context)
		{
			TypeReference typeReference = ImportType(field.DeclaringType, context);
			context.Push(typeReference);
			try
			{
				return new FieldReference
				{
					Name = field.Name,
					DeclaringType = typeReference,
					FieldType = ImportType(field.FieldType, context)
				};
			}
			finally
			{
				context.Pop();
			}
		}

		public MethodReference ImportMethod(MethodReference method, ImportGenericContext context)
		{
			if (method.IsGenericInstance)
			{
				return ImportMethodSpecification(method, context);
			}
			TypeReference declaringType = ImportType(method.DeclaringType, context);
			MethodReference methodReference = new MethodReference
			{
				Name = method.Name,
				HasThis = method.HasThis,
				ExplicitThis = method.ExplicitThis,
				DeclaringType = declaringType,
				CallingConvention = method.CallingConvention
			};
			if (method.HasGenericParameters)
			{
				ImportGenericParameters(methodReference, method);
			}
			context.Push(methodReference);
			try
			{
				methodReference.ReturnType = ImportType(method.ReturnType, context);
				if (!method.HasParameters)
				{
					return methodReference;
				}
				Mono.Collections.Generic.Collection<ParameterDefinition> parameters = methodReference.Parameters;
				Mono.Collections.Generic.Collection<ParameterDefinition> parameters2 = method.Parameters;
				for (int i = 0; i < parameters2.Count; i++)
				{
					parameters.Add(new ParameterDefinition(ImportType(parameters2[i].ParameterType, context)));
				}
				return methodReference;
			}
			finally
			{
				context.Pop();
			}
		}

		private MethodSpecification ImportMethodSpecification(MethodReference method, ImportGenericContext context)
		{
			if (!method.IsGenericInstance)
			{
				throw new NotSupportedException();
			}
			GenericInstanceMethod genericInstanceMethod = (GenericInstanceMethod)method;
			GenericInstanceMethod genericInstanceMethod2 = new GenericInstanceMethod(ImportMethod(genericInstanceMethod.ElementMethod, context));
			Mono.Collections.Generic.Collection<TypeReference> genericArguments = genericInstanceMethod.GenericArguments;
			Mono.Collections.Generic.Collection<TypeReference> genericArguments2 = genericInstanceMethod2.GenericArguments;
			for (int i = 0; i < genericArguments.Count; i++)
			{
				genericArguments2.Add(ImportType(genericArguments[i], context));
			}
			return genericInstanceMethod2;
		}
	}
	public class ExportedType : IMetadataTokenProvider
	{
		private string @namespace;

		private string name;

		private uint attributes;

		private IMetadataScope scope;

		private ModuleDefinition module;

		private int identifier;

		private ExportedType declaring_type;

		internal MetadataToken token;

		public string Namespace
		{
			get
			{
				return @namespace;
			}
			set
			{
				@namespace = value;
			}
		}

		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public TypeAttributes Attributes
		{
			get
			{
				return (TypeAttributes)attributes;
			}
			set
			{
				attributes = (uint)value;
			}
		}

		public IMetadataScope Scope
		{
			get
			{
				if (declaring_type != null)
				{
					return declaring_type.Scope;
				}
				return scope;
			}
		}

		public ExportedType DeclaringType
		{
			get
			{
				return declaring_type;
			}
			set
			{
				declaring_type = value;
			}
		}

		public MetadataToken MetadataToken
		{
			get
			{
				return token;
			}
			set
			{
				token = value;
			}
		}

		public int Identifier
		{
			get
			{
				return identifier;
			}
			set
			{
				identifier = value;
			}
		}

		public bool IsNotPublic
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 0u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 0u, value);
			}
		}

		public bool IsPublic
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 1u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 1u, value);
			}
		}

		public bool IsNestedPublic
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 2u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 2u, value);
			}
		}

		public bool IsNestedPrivate
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 3u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 3u, value);
			}
		}

		public bool IsNestedFamily
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 4u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 4u, value);
			}
		}

		public bool IsNestedAssembly
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 5u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 5u, value);
			}
		}

		public bool IsNestedFamilyAndAssembly
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 6u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 6u, value);
			}
		}

		public bool IsNestedFamilyOrAssembly
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 7u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 7u, value);
			}
		}

		public bool IsAutoLayout
		{
			get
			{
				return attributes.GetMaskedAttributes(24u, 0u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(24u, 0u, value);
			}
		}

		public bool IsSequentialLayout
		{
			get
			{
				return attributes.GetMaskedAttributes(24u, 8u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(24u, 8u, value);
			}
		}

		public bool IsExplicitLayout
		{
			get
			{
				return attributes.GetMaskedAttributes(24u, 16u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(24u, 16u, value);
			}
		}

		public bool IsClass
		{
			get
			{
				return attributes.GetMaskedAttributes(32u, 0u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(32u, 0u, value);
			}
		}

		public bool IsInterface
		{
			get
			{
				return attributes.GetMaskedAttributes(32u, 32u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(32u, 32u, value);
			}
		}

		public bool IsAbstract
		{
			get
			{
				return attributes.GetAttributes(128u);
			}
			set
			{
				attributes = attributes.SetAttributes(128u, value);
			}
		}

		public bool IsSealed
		{
			get
			{
				return attributes.GetAttributes(256u);
			}
			set
			{
				attributes = attributes.SetAttributes(256u, value);
			}
		}

		public bool IsSpecialName
		{
			get
			{
				return attributes.GetAttributes(1024u);
			}
			set
			{
				attributes = attributes.SetAttributes(1024u, value);
			}
		}

		public bool IsImport
		{
			get
			{
				return attributes.GetAttributes(4096u);
			}
			set
			{
				attributes = attributes.SetAttributes(4096u, value);
			}
		}

		public bool IsSerializable
		{
			get
			{
				return attributes.GetAttributes(8192u);
			}
			set
			{
				attributes = attributes.SetAttributes(8192u, value);
			}
		}

		public bool IsAnsiClass
		{
			get
			{
				return attributes.GetMaskedAttributes(196608u, 0u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(196608u, 0u, value);
			}
		}

		public bool IsUnicodeClass
		{
			get
			{
				return attributes.GetMaskedAttributes(196608u, 65536u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(196608u, 65536u, value);
			}
		}

		public bool IsAutoClass
		{
			get
			{
				return attributes.GetMaskedAttributes(196608u, 131072u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(196608u, 131072u, value);
			}
		}

		public bool IsBeforeFieldInit
		{
			get
			{
				return attributes.GetAttributes(1048576u);
			}
			set
			{
				attributes = attributes.SetAttributes(1048576u, value);
			}
		}

		public bool IsRuntimeSpecialName
		{
			get
			{
				return attributes.GetAttributes(2048u);
			}
			set
			{
				attributes = attributes.SetAttributes(2048u, value);
			}
		}

		public bool HasSecurity
		{
			get
			{
				return attributes.GetAttributes(262144u);
			}
			set
			{
				attributes = attributes.SetAttributes(262144u, value);
			}
		}

		public bool IsForwarder
		{
			get
			{
				return attributes.GetAttributes(2097152u);
			}
			set
			{
				attributes = attributes.SetAttributes(2097152u, value);
			}
		}

		public string FullName
		{
			get
			{
				string text = (string.IsNullOrEmpty(@namespace) ? name : (@namespace + "." + name));
				if (declaring_type != null)
				{
					return declaring_type.FullName + "/" + text;
				}
				return text;
			}
		}

		public ExportedType(string @namespace, string name, ModuleDefinition module, IMetadataScope scope)
		{
			this.@namespace = @namespace;
			this.name = name;
			this.scope = scope;
			this.module = module;
		}

		public override string ToString()
		{
			return FullName;
		}

		public TypeDefinition Resolve()
		{
			return module.Resolve(CreateReference());
		}

		internal TypeReference CreateReference()
		{
			return new TypeReference(@namespace, name, module, scope)
			{
				DeclaringType = ((declaring_type != null) ? declaring_type.CreateReference() : null)
			};
		}
	}
	public enum SecurityAction : ushort
	{
		Request = 1,
		Demand,
		Assert,
		Deny,
		PermitOnly,
		LinkDemand,
		InheritDemand,
		RequestMinimum,
		RequestOptional,
		RequestRefuse,
		PreJitGrant,
		PreJitDeny,
		NonCasDemand,
		NonCasLinkDemand,
		NonCasInheritance
	}
	public interface ISecurityDeclarationProvider : IMetadataTokenProvider
	{
		bool HasSecurityDeclarations { get; }

		Mono.Collections.Generic.Collection<SecurityDeclaration> SecurityDeclarations { get; }
	}
	public sealed class SecurityAttribute : ICustomAttribute
	{
		private TypeReference attribute_type;

		internal Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> fields;

		internal Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> properties;

		public TypeReference AttributeType
		{
			get
			{
				return attribute_type;
			}
			set
			{
				attribute_type = value;
			}
		}

		public bool HasFields => !fields.IsNullOrEmpty();

		public Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> Fields => fields ?? (fields = new Mono.Collections.Generic.Collection<CustomAttributeNamedArgument>());

		public bool HasProperties => !properties.IsNullOrEmpty();

		public Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> Properties => properties ?? (properties = new Mono.Collections.Generic.Collection<CustomAttributeNamedArgument>());

		public SecurityAttribute(TypeReference attributeType)
		{
			attribute_type = attributeType;
		}
	}
	public sealed class SecurityDeclaration
	{
		internal readonly uint signature;

		private byte[] blob;

		private readonly ModuleDefinition module;

		internal bool resolved;

		private SecurityAction action;

		internal Mono.Collections.Generic.Collection<SecurityAttribute> security_attributes;

		public SecurityAction Action
		{
			get
			{
				return action;
			}
			set
			{
				action = value;
			}
		}

		public bool HasSecurityAttributes
		{
			get
			{
				Resolve();
				return !security_attributes.IsNullOrEmpty();
			}
		}

		public Mono.Collections.Generic.Collection<SecurityAttribute> SecurityAttributes
		{
			get
			{
				Resolve();
				return security_attributes ?? (security_attributes = new Mono.Collections.Generic.Collection<SecurityAttribute>());
			}
		}

		internal bool HasImage
		{
			get
			{
				if (module != null)
				{
					return module.HasImage;
				}
				return false;
			}
		}

		internal SecurityDeclaration(SecurityAction action, uint signature, ModuleDefinition module)
		{
			this.action = action;
			this.signature = signature;
			this.module = module;
		}

		public SecurityDeclaration(SecurityAction action)
		{
			this.action = action;
			resolved = true;
		}

		public SecurityDeclaration(SecurityAction action, byte[] blob)
		{
			this.action = action;
			resolved = false;
			this.blob = blob;
		}

		public byte[] GetBlob()
		{
			if (blob != null)
			{
				return blob;
			}
			if (!HasImage || signature == 0)
			{
				throw new NotSupportedException();
			}
			return blob = module.Read(this, (SecurityDeclaration declaration, MetadataReader reader) => reader.ReadSecurityDeclarationBlob(declaration.signature));
		}

		private void Resolve()
		{
			if (!resolved && HasImage)
			{
				module.Read(this, delegate(SecurityDeclaration declaration, MetadataReader reader)
				{
					reader.ReadSecurityDeclarationSignature(declaration);
					return this;
				});
				resolved = true;
			}
		}
	}
	public struct CustomAttributeArgument
	{
		private readonly TypeReference type;

		private readonly object value;

		public TypeReference Type => type;

		public object Value => value;

		public CustomAttributeArgument(TypeReference type, object value)
		{
			Mixin.CheckType(type);
			this.type = type;
			this.value = value;
		}
	}
	public struct CustomAttributeNamedArgument
	{
		private readonly string name;

		private readonly CustomAttributeArgument argument;

		public string Name => name;

		public CustomAttributeArgument Argument => argument;

		public CustomAttributeNamedArgument(string name, CustomAttributeArgument argument)
		{
			Mixin.CheckName(name);
			this.name = name;
			this.argument = argument;
		}
	}
	public interface ICustomAttribute
	{
		TypeReference AttributeType { get; }

		bool HasFields { get; }

		bool HasProperties { get; }

		Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> Fields { get; }

		Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> Properties { get; }
	}
	public sealed class CustomAttribute : ICustomAttribute
	{
		internal readonly uint signature;

		internal bool resolved;

		private MethodReference constructor;

		private byte[] blob;

		internal Mono.Collections.Generic.Collection<CustomAttributeArgument> arguments;

		internal Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> fields;

		internal Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> properties;

		public MethodReference Constructor
		{
			get
			{
				return constructor;
			}
			set
			{
				constructor = value;
			}
		}

		public TypeReference AttributeType => constructor.DeclaringType;

		public bool IsResolved => resolved;

		public bool HasConstructorArguments
		{
			get
			{
				Resolve();
				return !arguments.IsNullOrEmpty();
			}
		}

		public Mono.Collections.Generic.Collection<CustomAttributeArgument> ConstructorArguments
		{
			get
			{
				Resolve();
				return arguments ?? (arguments = new Mono.Collections.Generic.Collection<CustomAttributeArgument>());
			}
		}

		public bool HasFields
		{
			get
			{
				Resolve();
				return !fields.IsNullOrEmpty();
			}
		}

		public Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> Fields
		{
			get
			{
				Resolve();
				return fields ?? (fields = new Mono.Collections.Generic.Collection<CustomAttributeNamedArgument>());
			}
		}

		public bool HasProperties
		{
			get
			{
				Resolve();
				return !properties.IsNullOrEmpty();
			}
		}

		public Mono.Collections.Generic.Collection<CustomAttributeNamedArgument> Properties
		{
			get
			{
				Resolve();
				return properties ?? (properties = new Mono.Collections.Generic.Collection<CustomAttributeNamedArgument>());
			}
		}

		internal bool HasImage
		{
			get
			{
				if (constructor != null)
				{
					return constructor.HasImage;
				}
				return false;
			}
		}

		internal ModuleDefinition Module => constructor.Module;

		internal CustomAttribute(uint signature, MethodReference constructor)
		{
			this.signature = signature;
			this.constructor = constructor;
			resolved = false;
		}

		public CustomAttribute(MethodReference constructor)
		{
			this.constructor = constructor;
			resolved = true;
		}

		public CustomAttribute(MethodReference constructor, byte[] blob)
		{
			this.constructor = constructor;
			resolved = false;
			this.blob = blob;
		}

		public byte[] GetBlob()
		{
			if (blob != null)
			{
				return blob;
			}
			if (!HasImage)
			{
				throw new NotSupportedException();
			}
			return Module.Read(ref blob, this, (CustomAttribute attribute, MetadataReader reader) => reader.ReadCustomAttributeBlob(attribute.signature));
		}

		private void Resolve()
		{
			if (resolved || !HasImage)
			{
				return;
			}
			Module.Read(this, delegate(CustomAttribute attribute, MetadataReader reader)
			{
				try
				{
					reader.ReadCustomAttributeSignature(attribute);
					resolved = true;
				}
				catch (ResolutionException)
				{
					if (arguments != null)
					{
						arguments.Clear();
					}
					if (fields != null)
					{
						fields.Clear();
					}
					if (properties != null)
					{
						properties.Clear();
					}
					resolved = false;
				}
				return this;
			});
		}
	}
	public class DefaultAssemblyResolver : BaseAssemblyResolver
	{
		private readonly IDictionary<string, AssemblyDefinition> cache;

		public DefaultAssemblyResolver()
		{
			cache = new Dictionary<string, AssemblyDefinition>(StringComparer.Ordinal);
		}

		public override AssemblyDefinition Resolve(AssemblyNameReference name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			if (cache.TryGetValue(name.FullName, out var value))
			{
				return value;
			}
			value = base.Resolve(name);
			cache[name.FullName] = value;
			return value;
		}

		protected void RegisterAssembly(AssemblyDefinition assembly)
		{
			if (assembly == null)
			{
				throw new ArgumentNullException("assembly");
			}
			string fullName = assembly.Name.FullName;
			if (!cache.ContainsKey(fullName))
			{
				cache[fullName] = assembly;
			}
		}
	}
	internal enum FileAttributes : uint
	{
		ContainsMetaData,
		ContainsNoMetaData
	}
	public sealed class FunctionPointerType : TypeSpecification, IMethodSignature, IMetadataTokenProvider
	{
		private readonly MethodReference function;

		public bool HasThis
		{
			get
			{
				return function.HasThis;
			}
			set
			{
				function.HasThis = value;
			}
		}

		public bool ExplicitThis
		{
			get
			{
				return function.ExplicitThis;
			}
			set
			{
				function.ExplicitThis = value;
			}
		}

		public MethodCallingConvention CallingConvention
		{
			get
			{
				return function.CallingConvention;
			}
			set
			{
				function.CallingConvention = value;
			}
		}

		public bool HasParameters => function.HasParameters;

		public Mono.Collections.Generic.Collection<ParameterDefinition> Parameters => function.Parameters;

		public TypeReference ReturnType
		{
			get
			{
				return function.MethodReturnType.ReturnType;
			}
			set
			{
				function.MethodReturnType.ReturnType = value;
			}
		}

		public MethodReturnType MethodReturnType => function.MethodReturnType;

		public override string Name
		{
			get
			{
				return function.Name;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override string Namespace
		{
			get
			{
				return string.Empty;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override ModuleDefinition Module => ReturnType.Module;

		public override IMetadataScope Scope
		{
			get
			{
				return function.ReturnType.Scope;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override bool IsFunctionPointer => true;

		public override bool ContainsGenericParameter => function.ContainsGenericParameter;

		public override string FullName
		{
			get
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(function.Name);
				stringBuilder.Append(" ");
				stringBuilder.Append(function.ReturnType.FullName);
				stringBuilder.Append(" *");
				this.MethodSignatureFullName(stringBuilder);
				return stringBuilder.ToString();
			}
		}

		public FunctionPointerType()
			: base(null)
		{
			function = new MethodReference();
			function.Name = "method";
			etype = Mono.Cecil.Metadata.ElementType.FnPtr;
		}

		public override TypeDefinition Resolve()
		{
			return null;
		}

		public override TypeReference GetElementType()
		{
			return this;
		}
	}
	public sealed class GenericInstanceMethod : MethodSpecification, IGenericInstance, IMetadataTokenProvider, IGenericContext
	{
		private Mono.Collections.Generic.Collection<TypeReference> arguments;

		public bool HasGenericArguments => !arguments.IsNullOrEmpty();

		public Mono.Collections.Generic.Collection<TypeReference> GenericArguments => arguments ?? (arguments = new Mono.Collections.Generic.Collection<TypeReference>());

		public override bool IsGenericInstance => true;

		IGenericParameterProvider IGenericContext.Method => base.ElementMethod;

		IGenericParameterProvider IGenericContext.Type => base.ElementMethod.DeclaringType;

		public override bool ContainsGenericParameter
		{
			get
			{
				if (!this.ContainsGenericParameter())
				{
					return base.ContainsGenericParameter;
				}
				return true;
			}
		}

		public override string FullName
		{
			get
			{
				StringBuilder stringBuilder = new StringBuilder();
				MethodReference elementMethod = base.ElementMethod;
				stringBuilder.Append(elementMethod.ReturnType.FullName).Append(" ").Append(elementMethod.DeclaringType.FullName)
					.Append("::")
					.Append(elementMethod.Name);
				this.GenericInstanceFullName(stringBuilder);
				this.MethodSignatureFullName(stringBuilder);
				return stringBuilder.ToString();
			}
		}

		public GenericInstanceMethod(MethodReference method)
			: base(method)
		{
		}
	}
	public sealed class GenericInstanceType : TypeSpecification, IGenericInstance, IMetadataTokenProvider, IGenericContext
	{
		private Mono.Collections.Generic.Collection<TypeReference> arguments;

		public bool HasGenericArguments => !arguments.IsNullOrEmpty();

		public Mono.Collections.Generic.Collection<TypeReference> GenericArguments => arguments ?? (arguments = new Mono.Collections.Generic.Collection<TypeReference>());

		public override TypeReference DeclaringType
		{
			get
			{
				return base.ElementType.DeclaringType;
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public override string FullName
		{
			get
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(base.FullName);
				this.GenericInstanceFullName(stringBuilder);
				return stringBuilder.ToString();
			}
		}

		public override bool IsGenericInstance => true;

		public override bool ContainsGenericParameter
		{
			get
			{
				if (!this.ContainsGenericParameter())
				{
					return base.ContainsGenericParameter;
				}
				return true;
			}
		}

		IGenericParameterProvider IGenericContext.Type => base.ElementType;

		public GenericInstanceType(TypeReference type)
			: base(type)
		{
			base.IsValueType = type.IsValueType;
			etype = Mono.Cecil.Metadata.ElementType.GenericInst;
		}
	}
	public sealed class GenericParameter : TypeReference, ICustomAttributeProvider, IMetadataTokenProvider
	{
		internal int position;

		internal GenericParameterType type;

		internal IGenericParameterProvider owner;

		private ushort attributes;

		private Mono.Collections.Generic.Collection<TypeReference> constraints;

		private Mono.Collections.Generic.Collection<CustomAttribute> custom_attributes;

		public GenericParameterAttributes Attributes
		{
			get
			{
				return (GenericParameterAttributes)attributes;
			}
			set
			{
				attributes = (ushort)value;
			}
		}

		public int Position => position;

		public GenericParameterType Type => type;

		public IGenericParameterProvider Owner => owner;

		public bool HasConstraints
		{
			get
			{
				if (constraints != null)
				{
					return constraints.Count > 0;
				}
				if (base.HasImage)
				{
					return Module.Read(this, (GenericParameter generic_parameter, MetadataReader reader) => reader.HasGenericConstraints(generic_parameter));
				}
				return false;
			}
		}

		public Mono.Collections.Generic.Collection<TypeReference> Constraints
		{
			get
			{
				if (constraints != null)
				{
					return constraints;
				}
				if (base.HasImage)
				{
					return Module.Read(ref constraints, this, (GenericParameter generic_parameter, MetadataReader reader) => reader.ReadGenericConstraints(generic_parameter));
				}
				return constraints = new Mono.Collections.Generic.Collection<TypeReference>();
			}
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
				{
					return custom_attributes.Count > 0;
				}
				return this.GetHasCustomAttributes(Module);
			}
		}

		public Mono.Collections.Generic.Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

		public override IMetadataScope Scope
		{
			get
			{
				if (owner == null)
				{
					return null;
				}
				if (owner.GenericParameterType != GenericParameterType.Method)
				{
					return ((TypeReference)owner).Scope;
				}
				return ((MethodReference)owner).DeclaringType.Scope;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override TypeReference DeclaringType
		{
			get
			{
				return owner as TypeReference;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public MethodReference DeclaringMethod => owner as MethodReference;

		public override ModuleDefinition Module => module ?? owner.Module;

		public override string Name
		{
			get
			{
				if (!string.IsNullOrEmpty(base.Name))
				{
					return base.Name;
				}
				return base.Name = ((type == GenericParameterType.Method) ? "!!" : "!") + position;
			}
		}

		public override string Namespace
		{
			get
			{
				return string.Empty;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override string FullName => Name;

		public override bool IsGenericParameter => true;

		public override bool ContainsGenericParameter => true;

		public override MetadataType MetadataType => (MetadataType)etype;

		public bool IsNonVariant
		{
			get
			{
				return attributes.GetMaskedAttributes(3, 0u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(3, 0u, value);
			}
		}

		public bool IsCovariant
		{
			get
			{
				return attributes.GetMaskedAttributes(3, 1u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(3, 1u, value);
			}
		}

		public bool IsContravariant
		{
			get
			{
				return attributes.GetMaskedAttributes(3, 2u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(3, 2u, value);
			}
		}

		public bool HasReferenceTypeConstraint
		{
			get
			{
				return attributes.GetAttributes(4);
			}
			set
			{
				attributes = attributes.SetAttributes(4, value);
			}
		}

		public bool HasNotNullableValueTypeConstraint
		{
			get
			{
				return attributes.GetAttributes(8);
			}
			set
			{
				attributes = attributes.SetAttributes(8, value);
			}
		}

		public bool HasDefaultConstructorConstraint
		{
			get
			{
				return attributes.GetAttributes(16);
			}
			set
			{
				attributes = attributes.SetAttributes(16, value);
			}
		}

		public GenericParameter(IGenericParameterProvider owner)
			: this(string.Empty, owner)
		{
		}

		public GenericParameter(string name, IGenericParameterProvider owner)
			: base(string.Empty, name)
		{
			if (owner == null)
			{
				throw new ArgumentNullException();
			}
			position = -1;
			this.owner = owner;
			type = owner.GenericParameterType;
			etype = ConvertGenericParameterType(type);
			token = new MetadataToken(TokenType.GenericParam);
		}

		internal GenericParameter(int position, GenericParameterType type, ModuleDefinition module)
			: base(string.Empty, string.Empty)
		{
			if (module == null)
			{
				throw new ArgumentNullException();
			}
			this.position = position;
			this.type = type;
			etype = ConvertGenericParameterType(type);
			base.module = module;
			token = new MetadataToken(TokenType.GenericParam);
		}

		private static ElementType ConvertGenericParameterType(GenericParameterType type)
		{
			return type switch
			{
				GenericParameterType.Type => ElementType.Var, 
				GenericParameterType.Method => ElementType.MVar, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}

		public override TypeDefinition Resolve()
		{
			return null;
		}
	}
	internal sealed class GenericParameterCollection : Mono.Collections.Generic.Collection<GenericParameter>
	{
		private readonly IGenericParameterProvider owner;

		internal GenericParameterCollection(IGenericParameterProvider owner)
		{
			this.owner = owner;
		}

		internal GenericParameterCollection(IGenericParameterProvider owner, int capacity)
			: base(capacity)
		{
			this.owner = owner;
		}

		protected override void OnAdd(GenericParameter item, int index)
		{
			UpdateGenericParameter(item, index);
		}

		protected override void OnInsert(GenericParameter item, int index)
		{
			UpdateGenericParameter(item, index);
			for (int i = index; i < size; i++)
			{
				items[i].position = i + 1;
			}
		}

		protected override void OnSet(GenericParameter item, int index)
		{
			UpdateGenericParameter(item, index);
		}

		private void UpdateGenericParameter(GenericParameter item, int index)
		{
			item.owner = owner;
			item.position = index;
			item.type = owner.GenericParameterType;
		}

		protected override void OnRemove(GenericParameter item, int index)
		{
			item.owner = null;
			item.position = -1;
			item.type = GenericParameterType.Type;
			for (int i = index + 1; i < size; i++)
			{
				items[i].position = i - 1;
			}
		}
	}
	[Flags]
	public enum GenericParameterAttributes : ushort
	{
		VarianceMask = 3,
		NonVariant = 0,
		Covariant = 1,
		Contravariant = 2,
		SpecialConstraintMask = 0x1C,
		ReferenceTypeConstraint = 4,
		NotNullableValueTypeConstraint = 8,
		DefaultConstructorConstraint = 0x10
	}
	public interface IConstantProvider : IMetadataTokenProvider
	{
		bool HasConstant { get; set; }

		object Constant { get; set; }
	}
	public interface ICustomAttributeProvider : IMetadataTokenProvider
	{
		Mono.Collections.Generic.Collection<CustomAttribute> CustomAttributes { get; }

		bool HasCustomAttributes { get; }
	}
	public interface IGenericInstance : IMetadataTokenProvider
	{
		bool HasGenericArguments { get; }

		Mono.Collections.Generic.Collection<TypeReference> GenericArguments { get; }
	}
	public interface IGenericParameterProvider : IMetadataTokenProvider
	{
		bool HasGenericParameters { get; }

		bool IsDefinition { get; }

		ModuleDefinition Module { get; }

		Mono.Collections.Generic.Collection<GenericParameter> GenericParameters { get; }

		GenericParameterType GenericParameterType { get; }
	}
	public enum GenericParameterType
	{
		Type,
		Method
	}
	internal interface IGenericContext
	{
		bool IsDefinition { get; }

		IGenericParameterProvider Type { get; }

		IGenericParameterProvider Method { get; }
	}
	public interface IMarshalInfoProvider : IMetadataTokenProvider
	{
		bool HasMarshalInfo { get; }

		MarshalInfo MarshalInfo { get; set; }
	}
	public class MarshalInfo
	{
		internal NativeType native;

		public NativeType NativeType
		{
			get
			{
				return native;
			}
			set
			{
				native = value;
			}
		}

		public MarshalInfo(NativeType native)
		{
			this.native = native;
		}
	}
	public sealed class ArrayMarshalInfo : MarshalInfo
	{
		internal NativeType element_type;

		internal int size_parameter_index;

		internal int size;

		internal int size_parameter_multiplier;

		public NativeType ElementType
		{
			get
			{
				return element_type;
			}
			set
			{
				element_type = value;
			}
		}

		public int SizeParameterIndex
		{
			get
			{
				return size_parameter_index;
			}
			set
			{
				size_parameter_index = value;
			}
		}

		public int Size
		{
			get
			{
				return size;
			}
			set
			{
				size = value;
			}
		}

		public int SizeParameterMultiplier
		{
			get
			{
				return size_parameter_multiplier;
			}
			set
			{
				size_parameter_multiplier = value;
			}
		}

		public ArrayMarshalInfo()
			: base(NativeType.Array)
		{
			element_type = NativeType.None;
			size_parameter_index = -1;
			size = -1;
			size_parameter_multiplier = -1;
		}
	}
	public sealed class CustomMarshalInfo : MarshalInfo
	{
		internal Guid guid;

		internal string unmanaged_type;

		internal TypeReference managed_type;

		internal string cookie;

		public Guid Guid
		{
			get
			{
				return guid;
			}
			set
			{
				guid = value;
			}
		}

		public string UnmanagedType
		{
			get
			{
				return unmanaged_type;
			}
			set
			{
				unmanaged_type = value;
			}
		}

		public TypeReference ManagedType
		{
			get
			{
				return managed_type;
			}
			set
			{
				managed_type = value;
			}
		}

		public string Cookie
		{
			get
			{
				return cookie;
			}
			set
			{
				cookie = value;
			}
		}

		public CustomMarshalInfo()
			: base(NativeType.CustomMarshaler)
		{
		}
	}
	public sealed class SafeArrayMarshalInfo : MarshalInfo
	{
		internal VariantType element_type;

		public VariantType ElementType
		{
			get
			{
				return element_type;
			}
			set
			{
				element_type = value;
			}
		}

		public SafeArrayMarshalInfo()
			: base(NativeType.SafeArray)
		{
			element_type = VariantType.None;
		}
	}
	public sealed class FixedArrayMarshalInfo : MarshalInfo
	{
		internal NativeType element_type;

		internal int size;

		public NativeType ElementType
		{
			get
			{
				return element_type;
			}
			set
			{
				element_type = value;
			}
		}

		public int Size
		{
			get
			{
				return size;
			}
			set
			{
				size = value;
			}
		}

		public FixedArrayMarshalInfo()
			: base(NativeType.FixedArray)
		{
			element_type = NativeType.None;
		}
	}
	public sealed class FixedSysStringMarshalInfo : MarshalInfo
	{
		internal int size;

		public int Size
		{
			get
			{
				return size;
			}
			set
			{
				size = value;
			}
		}

		public FixedSysStringMarshalInfo()
			: base(NativeType.FixedSysString)
		{
			size = -1;
		}
	}
	public interface IAssemblyResolver
	{
		AssemblyDefinition Resolve(AssemblyNameReference name);

		AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);

		AssemblyDefinition Resolve(string fullName);

		AssemblyDefinition Resolve(string fullName, ReaderParameters parameters);
	}
	public interface IMetadataResolver
	{
		TypeDefinition Resolve(TypeReference type);

		FieldDefinition Resolve(FieldReference field);

		MethodDefinition Resolve(MethodReference method);
	}
	[Serializable]
	public class ResolutionException : Exception
	{
		private readonly MemberReference member;

		public MemberReference Member => member;

		public IMetadataScope Scope
		{
			get
			{
				if (member is TypeReference typeReference)
				{
					return typeReference.Scope;
				}
				TypeReference declaringType = member.DeclaringType;
				if (declaringType != null)
				{
					return declaringType.Scope;
				}
				throw new NotSupportedException();
			}
		}

		public ResolutionException(MemberReference member)
			: base("Failed to resolve " + member.FullName)
		{
			if (member == null)
			{
				throw new ArgumentNullException("member");
			}
			this.member = member;
		}

		protected ResolutionException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
	public class MetadataResolver : IMetadataResolver
	{
		private readonly IAssemblyResolver assembly_resolver;

		public IAssemblyResolver AssemblyResolver => assembly_resolver;

		public MetadataResolver(IAssemblyResolver assemblyResolver)
		{
			if (assemblyResolver == null)
			{
				throw new ArgumentNullException("assemblyResolver");
			}
			assembly_resolver = assemblyResolver;
		}

		public virtual TypeDefinition Resolve(TypeReference type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			type = type.GetElementType();
			IMetadataScope scope = type.Scope;
			if (scope == null)
			{
				return null;
			}
			switch (scope.MetadataScopeType)
			{
			case MetadataScopeType.AssemblyNameReference:
			{
				AssemblyDefinition assemblyDefinition = assembly_resolver.Resolve((AssemblyNameReference)scope);
				if (assemblyDefinition == null)
				{
					return null;
				}
				return GetType(assemblyDefinition.MainModule, type);
			}
			case MetadataScopeType.ModuleDefinition:
				return GetType((ModuleDefinition)scope, type);
			case MetadataScopeType.ModuleReference:
			{
				Mono.Collections.Generic.Collection<ModuleDefinition> modules = type.Module.Assembly.Modules;
				ModuleReference moduleReference = (ModuleReference)scope;
				for (int i = 0; i < modules.Count; i++)
				{
					ModuleDefinition moduleDefinition = modules[i];
					if (moduleDefinition.Name == moduleReference.Name)
					{
						return GetType(moduleDefinition, type);
					}
				}
				break;
			}
			}
			throw new NotSupportedException();
		}

		private static TypeDefinition GetType(ModuleDefinition module, TypeReference reference)
		{
			TypeDefinition typeDefinition = GetTypeDefinition(module, reference);
			if (typeDefinition != null)
			{
				return typeDefinition;
			}
			if (!module.HasExportedTypes)
			{
				return null;
			}
			Mono.Collections.Generic.Collection<ExportedType> exportedTypes = module.ExportedTypes;
			for (int i = 0; i < exportedTypes.Count; i++)
			{
				ExportedType exportedType = exportedTypes[i];
				if (!(exportedType.Name != reference.Name) && !(exportedType.Namespace != reference.Namespace))
				{
					return exportedType.Resolve();
				}
			}
			return null;
		}

		private static TypeDefinition GetTypeDefinition(ModuleDefinition module, TypeReference type)
		{
			if (!type.IsNested)
			{
				return module.GetType(type.Namespace, type.Name);
			}
			return type.DeclaringType.Resolve()?.GetNestedType(type.TypeFullName());
		}

		public virtual FieldDefinition Resolve(FieldReference field)
		{
			if (field == null)
			{
				throw new ArgumentNullException("field");
			}
			TypeDefinition typeDefinition = Resolve(field.DeclaringType);
			if (typeDefinition == null)
			{
				return null;
			}
			if (!typeDefinition.HasFields)
			{
				return null;
			}
			return GetField(typeDefinition, field);
		}

		private FieldDefinition GetField(TypeDefinition type, FieldReference reference)
		{
			while (type != null)
			{
				FieldDefinition field = GetField(type.Fields, reference);
				if (field != null)
				{
					return field;
				}
				if (type.BaseType == null)
				{
					return null;
				}
				type = Resolve(type.BaseType);
			}
			return null;
		}

		private static FieldDefinition GetField(Mono.Collections.Generic.Collection<FieldDefinition> fields, FieldReference reference)
		{
			for (int i = 0; i < fields.Count; i++)
			{
				FieldDefinition fieldDefinition = fields[i];
				if (!(fieldDefinition.Name != reference.Name) && AreSame(fieldDefinition.FieldType, reference.FieldType))
				{
					return fieldDefinition;
				}
			}
			return null;
		}

		public virtual MethodDefinition Resolve(MethodReference method)
		{
			if (method == null)
			{
				throw new ArgumentNullException("method");
			}
			TypeDefinition typeDefinition = Resolve(method.DeclaringType);
			if (typeDefinition == null)
			{
				return null;
			}
			method = method.GetElementMethod();
			if (!typeDefinition.HasMethods)
			{
				return null;
			}
			return GetMethod(typeDefinition, method);
		}

		private MethodDefinition GetMethod(TypeDefinition type, MethodReference reference)
		{
			while (type != null)
			{
				MethodDefinition method = GetMethod(type.Methods, reference);
				if (method != null)
				{
					return method;
				}
				if (type.BaseType == null)
				{
					return null;
				}
				type = Resolve(type.BaseType);
			}
			return null;
		}

		public static MethodDefinition GetMethod(Mono.Collections.Generic.Collection<MethodDefinition> methods, MethodReference reference)
		{
			for (int i = 0; i < methods.Count; i++)
			{
				MethodDefinition methodDefinition = methods[i];
				if (!(methodDefinition.Name != reference.Name) && methodDefinition.HasGenericParameters == reference.HasGenericParameters && (!methodDefinition.HasGenericParameters || methodDefinition.GenericParameters.Count == reference.GenericParameters.Count) && AreSame(methodDefinition.ReturnType, reference.ReturnType) && methodDefinition.HasParameters == reference.HasParameters)
				{
					if (!methodDefinition.HasParameters && !reference.HasParameters)
					{
						return methodDefinition;
					}
					if (AreSame(methodDefinition.Parameters, reference.Parameters))
					{
						return methodDefinition;
					}
				}
			}
			return null;
		}

		private static bool AreSame(Mono.Collections.Generic.Collection<ParameterDefinition> a, Mono.Collections.Generic.Collection<ParameterDefinition> b)
		{
			int count = a.Count;
			if (count != b.Count)
			{
				return false;
			}
			if (count == 0)
			{
				return true;
			}
			for (int i = 0; i < count; i++)
			{
				if (!AreSame(a[i].ParameterType, b[i].ParameterType))
				{
					return false;
				}
			}
			return true;
		}

		private static bool AreSame(TypeSpecification a, TypeSpecification b)
		{
			if (!AreSame(a.ElementType, b.ElementType))
			{
				return false;
			}
			if (a.IsGenericInstance)
			{
				return AreSame((GenericInstanceType)a, (GenericInstanceType)b);
			}
			if (a.IsRequiredModifier || a.IsOptionalModifier)
			{
				return AreSame((IModifierType)a, (IModifierType)b);
			}
			if (a.IsArray)
			{
				return AreSame((ArrayType)a, (ArrayType)b);
			}
			return true;
		}

		private static bool AreSame(ArrayType a, ArrayType b)
		{
			if (a.Rank != b.Rank)
			{
				return false;
			}
			return true;
		}

		private static bool AreSame(IModifierType a, IModifierType b)
		{
			return AreSame(a.ModifierType, b.ModifierType);
		}

		private static bool AreSame(GenericInstanceType a, GenericInstanceType b)
		{
			if (a.GenericArguments.Count != b.GenericArguments.Count)
			{
				return false;
			}
			for (int i = 0; i < a.GenericArguments.Count; i++)
			{
				if (!AreSame(a.GenericArguments[i], b.GenericArguments[i]))
				{
					return false;
				}
			}
			return true;
		}

		private static bool AreSame(GenericParameter a, GenericParameter b)
		{
			return a.Position == b.Position;
		}

		private static bool AreSame(TypeReference a, TypeReference b)
		{
			if (a == b)
			{
				return true;
			}
			if (a == null || b == null)
			{
				return false;
			}
			if (a.etype != b.etype)
			{
				return false;
			}
			if (a.IsGenericParameter)
			{
				return AreSame((GenericParameter)a, (GenericParameter)b);
			}
			if (a.IsTypeSpecification())
			{
				return AreSame((TypeSpecification)a, (TypeSpecification)b);
			}
			if (a.Name != b.Name || a.Namespace != b.Namespace)
			{
				return false;
			}
			return AreSame(a.DeclaringType, b.DeclaringType);
		}
	}
	public interface IModifierType
	{
		TypeReference ModifierType { get; }

		TypeReference ElementType { get; }
	}
	public sealed class OptionalModifierType : TypeSpecification, IModifierType
	{
		private TypeReference modifier_type;

		public TypeReference ModifierType
		{
			get
			{
				return modifier_type;
			}
			set
			{
				modifier_type = value;
			}
		}

		public override string Name => base.Name + Suffix;

		public override string FullName => base.FullName + Suffix;

		private string Suffix => string.Concat(" modopt(", modifier_type, ")");

		public override bool IsValueType
		{
			get
			{
				return false;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override bool IsOptionalModifier => true;

		public override bool ContainsGenericParameter
		{
			get
			{
				if (!modifier_type.ContainsGenericParameter)
				{
					return base.ContainsGenericParameter;
				}
				return true;
			}
		}

		public OptionalModifierType(TypeReference modifierType, TypeReference type)
			: base(type)
		{
			Mixin.CheckModifier(modifierType, type);
			modifier_type = modifierType;
			etype = Mono.Cecil.Metadata.ElementType.CModOpt;
		}
	}
	public sealed class RequiredModifierType : TypeSpecification, IModifierType
	{
		private TypeReference modifier_type;

		public TypeReference ModifierType
		{
			get
			{
				return modifier_type;
			}
			set
			{
				modifier_type = value;
			}
		}

		public override string Name => base.Name + Suffix;

		public override string FullName => base.FullName + Suffix;

		private string Suffix => string.Concat(" modreq(", modifier_type, ")");

		public override bool IsValueType
		{
			get
			{
				return false;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override bool IsRequiredModifier => true;

		public override bool ContainsGenericParameter
		{
			get
			{
				if (!modifier_type.ContainsGenericParameter)
				{
					return base.ContainsGenericParameter;
				}
				return true;
			}
		}

		public RequiredModifierType(TypeReference modifierType, TypeReference type)
			: base(type)
		{
			Mixin.CheckModifier(modifierType, type);
			modifier_type = modifierType;
			etype = Mono.Cecil.Metadata.ElementType.CModReqD;
		}
	}
	public enum NativeType
	{
		None = 102,
		Boolean = 2,
		I1 = 3,
		U1 = 4,
		I2 = 5,
		U2 = 6,
		I4 = 7,
		U4 = 8,
		I8 = 9,
		U8 = 10,
		R4 = 11,
		R8 = 12,
		LPStr = 20,
		Int = 31,
		UInt = 32,
		Func = 38,
		Array = 42,
		Currency = 15,
		BStr = 19,
		LPWStr = 21,
		LPTStr = 22,
		FixedSysString = 23,
		IUnknown = 25,
		IDispatch = 26,
		Struct = 27,
		IntF = 28,
		SafeArray = 29,
		FixedArray = 30,
		ByValStr = 34,
		ANSIBStr = 35,
		TBStr = 36,
		VariantBool = 37,
		ASAny = 40,
		LPStruct = 43,
		CustomMarshaler = 44,
		Error = 45,
		Max = 80
	}
	public sealed class PinnedType : TypeSpecification
	{
		public override bool IsValueType
		{
			get
			{
				return false;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override bool IsPinned => true;

		public PinnedType(TypeReference type)
			: base(type)
		{
			Mixin.CheckType(type);
			etype = Mono.Cecil.Metadata.ElementType.Pinned;
		}
	}
	internal struct Range
	{
		public uint Start;

		public uint Length;

		public Range(uint index, uint length)
		{
			Start = index;
			Length = length;
		}
	}
	internal sealed class MetadataSystem
	{
		internal AssemblyNameReference[] AssemblyReferences;

		internal ModuleReference[] ModuleReferences;

		internal TypeDefinition[] Types;

		internal TypeReference[] TypeReferences;

		internal FieldDefinition[] Fields;

		internal MethodDefinition[] Methods;

		internal MemberReference[] MemberReferences;

		internal Dictionary<uint, uint[]> NestedTypes;

		internal Dictionary<uint, uint> ReverseNestedTypes;

		internal Dictionary<uint, MetadataToken[]> Interfaces;

		internal Dictionary<uint, Row<ushort, uint>> ClassLayouts;

		internal Dictionary<uint, uint> FieldLayouts;

		internal Dictionary<uint, uint> FieldRVAs;

		internal Dictionary<MetadataToken, uint> FieldMarshals;

		internal Dictionary<MetadataToken, Row<ElementType, uint>> Constants;

		internal Dictionary<uint, MetadataToken[]> Overrides;

		internal Dictionary<MetadataToken, Range[]> CustomAttributes;

		internal Dictionary<MetadataToken, Range[]> SecurityDeclarations;

		internal Dictionary<uint, Range> Events;

		internal Dictionary<uint, Range> Properties;

		internal Dictionary<uint, Row<MethodSemanticsAttributes, MetadataToken>> Semantics;

		internal Dictionary<uint, Row<PInvokeAttributes, uint, uint>> PInvokes;

		internal Dictionary<MetadataToken, Range[]> GenericParameters;

		internal Dictionary<uint, MetadataToken[]> GenericConstraints;

		private static Dictionary<string, Row<ElementType, bool>> primitive_value_types;

		private static void InitializePrimitives()
		{
			primitive_value_types = new Dictionary<string, Row<ElementType, bool>>(18, StringComparer.Ordinal)
			{
				{
					"Void",
					new Row<ElementType, bool>(ElementType.Void, col2: false)
				},
				{
					"Boolean",
					new Row<ElementType, bool>(ElementType.Boolean, col2: true)
				},
				{
					"Char",
					new Row<ElementType, bool>(ElementType.Char, col2: true)
				},
				{
					"SByte",
					new Row<ElementType, bool>(ElementType.I1, col2: true)
				},
				{
					"Byte",
					new Row<ElementType, bool>(ElementType.U1, col2: true)
				},
				{
					"Int16",
					new Row<ElementType, bool>(ElementType.I2, col2: true)
				},
				{
					"UInt16",
					new Row<ElementType, bool>(ElementType.U2, col2: true)
				},
				{
					"Int32",
					new Row<ElementType, bool>(ElementType.I4, col2: true)
				},
				{
					"UInt32",
					new Row<ElementType, bool>(ElementType.U4, col2: true)
				},
				{
					"Int64",
					new Row<ElementType, bool>(ElementType.I8, col2: true)
				},
				{
					"UInt64",
					new Row<ElementType, bool>(ElementType.U8, col2: true)
				},
				{
					"Single",
					new Row<ElementType, bool>(ElementType.R4, col2: true)
				},
				{
					"Double",
					new Row<ElementType, bool>(ElementType.R8, col2: true)
				},
				{
					"String",
					new Row<ElementType, bool>(ElementType.String, col2: false)
				},
				{
					"TypedReference",
					new Row<ElementType, bool>(ElementType.TypedByRef, col2: false)
				},
				{
					"IntPtr",
					new Row<ElementType, bool>(ElementType.I, col2: true)
				},
				{
					"UIntPtr",
					new Row<ElementType, bool>(ElementType.U, col2: true)
				},
				{
					"Object",
					new Row<ElementType, bool>(ElementType.Object, col2: false)
				}
			};
		}

		public static void TryProcessPrimitiveTypeReference(TypeReference type)
		{
			if (!(type.Namespace != "System"))
			{
				IMetadataScope scope = type.scope;
				if (scope != null && scope.MetadataScopeType == MetadataScopeType.AssemblyNameReference && TryGetPrimitiveData(type, out var primitive_data))
				{
					type.etype = primitive_data.Col1;
					type.IsValueType = primitive_data.Col2;
				}
			}
		}

		public static bool TryGetPrimitiveElementType(TypeDefinition type, out ElementType etype)
		{
			etype = ElementType.None;
			if (type.Namespace != "System")
			{
				return false;
			}
			if (TryGetPrimitiveData(type, out var primitive_data) && primitive_data.Col1.IsPrimitive())
			{
				etype = primitive_data.Col1;
				return true;
			}
			return false;
		}

		private static bool TryGetPrimitiveData(TypeReference type, out Row<ElementType, bool> primitive_data)
		{
			if (primitive_value_types == null)
			{
				InitializePrimitives();
			}
			return primitive_value_types.TryGetValue(type.Name, out primitive_data);
		}

		public void Clear()
		{
			if (NestedTypes != null)
			{
				NestedTypes.Clear();
			}
			if (ReverseNestedTypes != null)
			{
				ReverseNestedTypes.Clear();
			}
			if (Interfaces != null)
			{
				Interfaces.Clear();
			}
			if (ClassLayouts != null)
			{
				ClassLayouts.Clear();
			}
			if (FieldLayouts != null)
			{
				FieldLayouts.Clear();
			}
			if (FieldRVAs != null)
			{
				FieldRVAs.Clear();
			}
			if (FieldMarshals != null)
			{
				FieldMarshals.Clear();
			}
			if (Constants != null)
			{
				Constants.Clear();
			}
			if (Overrides != null)
			{
				Overrides.Clear();
			}
			if (CustomAttributes != null)
			{
				CustomAttributes.Clear();
			}
			if (SecurityDeclarations != null)
			{
				SecurityDeclarations.Clear();
			}
			if (Events != null)
			{
				Events.Clear();
			}
			if (Properties != null)
			{
				Properties.Clear();
			}
			if (Semantics != null)
			{
				Semantics.Clear();
			}
			if (PInvokes != null)
			{
				PInvokes.Clear();
			}
			if (GenericParameters != null)
			{
				GenericParameters.Clear();
			}
			if (GenericConstraints != null)
			{
				GenericConstraints.Clear();
			}
		}

		public TypeDefinition GetTypeDefinition(uint rid)
		{
			if (rid < 1 || rid > Types.Length)
			{
				return null;
			}
			return Types[rid - 1];
		}

		public void AddTypeDefinition(TypeDefinition type)
		{
			Types[type.token.RID - 1] = type;
		}

		public TypeReference GetTypeReference(uint rid)
		{
			if (rid < 1 || rid > TypeReferences.Length)
			{
				return null;
			}
			return TypeReferences[rid - 1];
		}

		public void AddTypeReference(TypeReference type)
		{
			TypeReferences[type.token.RID - 1] = type;
		}

		public FieldDefinition GetFieldDefinition(uint rid)
		{
			if (rid < 1 || rid > Fields.Length)
			{
				return null;
			}
			return Fields[rid - 1];
		}

		public void AddFieldDefinition(FieldDefinition field)
		{
			Fields[field.token.RID - 1] = field;
		}

		public MethodDefinition GetMethodDefinition(uint rid)
		{
			if (rid < 1 || rid > Methods.Length)
			{
				return null;
			}
			return Methods[rid - 1];
		}

		public void AddMethodDefinition(MethodDefinition method)
		{
			Methods[method.token.RID - 1] = method;
		}

		public MemberReference GetMemberReference(uint rid)
		{
			if (rid < 1 || rid > MemberReferences.Length)
			{
				return null;
			}
			return MemberReferences[rid - 1];
		}

		public void AddMemberReference(MemberReference member)
		{
			MemberReferences[member.token.RID - 1] = member;
		}

		public bool TryGetNestedTypeMapping(TypeDefinition type, out uint[] mapping)
		{
			return NestedTypes.TryGetValue(type.token.RID, out mapping);
		}

		public void SetNestedTypeMapping(uint type_rid, uint[] mapping)
		{
			NestedTypes[type_rid] = mapping;
		}

		public void RemoveNestedTypeMapping(TypeDefinition type)
		{
			NestedTypes.Remove(type.token.RID);
		}

		public bool TryGetReverseNestedTypeMapping(TypeDefinition type, out uint declaring)
		{
			return ReverseNestedTypes.TryGetValue(type.token.RID, out declaring);
		}

		public void SetReverseNestedTypeMapping(uint nested, uint declaring)
		{
			ReverseNestedTypes.Add(nested, declaring);
		}

		public void RemoveReverseNestedTypeMapping(TypeDefinition type)
		{
			ReverseNestedTypes.Remove(type.token.RID);
		}

		public bool TryGetInterfaceMapping(TypeDefinition type, out MetadataToken[] mapping)
		{
			return Interfaces.TryGetValue(type.token.RID, out mapping);
		}

		public void SetInterfaceMapping(uint type_rid, MetadataToken[] mapping)
		{
			Interfaces[type_rid] = mapping;
		}

		public void RemoveInterfaceMapping(TypeDefinition type)
		{
			Interfaces.Remove(type.token.RID);
		}

		public void AddPropertiesRange(uint type_rid, Range range)
		{
			Properties.Add(type_rid, range);
		}

		public bool TryGetPropertiesRange(TypeDefinition type, out Range range)
		{
			return Properties.TryGetValue(type.token.RID, out range);
		}

		public void RemovePropertiesRange(TypeDefinition type)
		{
			Properties.Remove(type.token.RID);
		}

		public void AddEventsRange(uint type_rid, Range range)
		{
			Events.Add(type_rid, range);
		}

		public bool TryGetEventsRange(TypeDefinition type, out Range range)
		{
			return Events.TryGetValue(type.token.RID, out range);
		}

		public void RemoveEventsRange(TypeDefinition type)
		{
			Events.Remove(type.token.RID);
		}

		public bool TryGetGenericParameterRanges(IGenericParameterProvider owner, out Range[] ranges)
		{
			return GenericParameters.TryGetValue(owner.MetadataToken, out ranges);
		}

		public void RemoveGenericParameterRange(IGenericParameterProvider owner)
		{
			GenericParameters.Remove(owner.MetadataToken);
		}

		public bool TryGetCustomAttributeRanges(ICustomAttributeProvider owner, out Range[] ranges)
		{
			return CustomAttributes.TryGetValue(owner.MetadataToken, out ranges);
		}

		public void RemoveCustomAttributeRange(ICustomAttributeProvider owner)
		{
			CustomAttributes.Remove(owner.MetadataToken);
		}

		public bool TryGetSecurityDeclarationRanges(ISecurityDeclarationProvider owner, out Range[] ranges)
		{
			return SecurityDeclarations.TryGetValue(owner.MetadataToken, out ranges);
		}

		public void RemoveSecurityDeclarationRange(ISecurityDeclarationProvider owner)
		{
			SecurityDeclarations.Remove(owner.MetadataToken);
		}

		public bool TryGetGenericConstraintMapping(GenericParameter generic_parameter, out MetadataToken[] mapping)
		{
			return GenericConstraints.TryGetValue(generic_parameter.token.RID, out mapping);
		}

		public void SetGenericConstraintMapping(uint gp_rid, MetadataToken[] mapping)
		{
			GenericConstraints[gp_rid] = mapping;
		}

		public void RemoveGenericConstraintMapping(GenericParameter generic_parameter)
		{
			GenericConstraints.Remove(generic_parameter.token.RID);
		}

		public bool TryGetOverrideMapping(MethodDefinition method, out MetadataToken[] mapping)
		{
			return Overrides.TryGetValue(method.token.RID, out mapping);
		}

		public void SetOverrideMapping(uint rid, MetadataToken[] mapping)
		{
			Overrides[rid] = mapping;
		}

		public void RemoveOverrideMapping(MethodDefinition method)
		{
			Overrides.Remove(method.token.RID);
		}

		public TypeDefinition GetFieldDeclaringType(uint field_rid)
		{
			return BinaryRangeSearch(Types, field_rid, field: true);
		}

		public TypeDefinition GetMethodDeclaringType(uint method_rid)
		{
			return BinaryRangeSearch(Types, method_rid, field: false);
		}

		private static TypeDefinition BinaryRangeSearch(TypeDefinition[] types, uint rid, bool field)
		{
			int num = 0;
			int num2 = types.Length - 1;
			while (num <= num2)
			{
				int num3 = num + (num2 - num) / 2;
				TypeDefinition typeDefinition = types[num3];
				Range range = (field ? typeDefinition.fields_range : typeDefinition.methods_range);
				if (rid < range.Start)
				{
					num2 = num3 - 1;
					continue;
				}
				if (rid >= range.Start + range.Length)
				{
					num = num3 + 1;
					continue;
				}
				return typeDefinition;
			}
			return null;
		}
	}
	public interface IMethodSignature : IMetadataTokenProvider
	{
		bool HasThis { get; set; }

		bool ExplicitThis { get; set; }

		MethodCallingConvention CallingConvention { get; set; }

		bool HasParameters { get; }

		Mono.Collections.Generic.Collection<ParameterDefinition> Parameters { get; }

		TypeReference ReturnType { get; set; }

		MethodReturnType MethodReturnType { get; }
	}
	internal sealed class ParameterDefinitionCollection : Mono.Collections.Generic.Collection<ParameterDefinition>
	{
		private readonly IMethodSignature method;

		internal ParameterDefinitionCollection(IMethodSignature method)
		{
			this.method = method;
		}

		internal ParameterDefinitionCollection(IMethodSignature method, int capacity)
			: base(capacity)
		{
			this.method = method;
		}

		protected override void OnAdd(ParameterDefinition item, int index)
		{
			item.method = method;
			item.index = index;
		}

		protected override void OnInsert(ParameterDefinition item, int index)
		{
			item.method = method;
			item.index = index;
			for (int i = index; i < size; i++)
			{
				items[i].index = i + 1;
			}
		}

		protected override void OnSet(ParameterDefinition item, int index)
		{
			item.method = method;
			item.index = index;
		}

		protected override void OnRemove(ParameterDefinition item, int index)
		{
			item.method = null;
			item.index = -1;
			for (int i = index + 1; i < size; i++)
			{
				items[i].index = i - 1;
			}
		}
	}
	public sealed class EmbeddedResource : Resource
	{
		private readonly MetadataReader reader;

		private uint? offset;

		private byte[] data;

		private Stream stream;

		public override ResourceType ResourceType => ResourceType.Embedded;

		public EmbeddedResource(string name, ManifestResourceAttributes attributes, byte[] data)
			: base(name, attributes)
		{
			this.data = data;
		}

		public EmbeddedResource(string name, ManifestResourceAttributes attributes, Stream stream)
			: base(name, attributes)
		{
			this.stream = stream;
		}

		internal EmbeddedResource(string name, ManifestResourceAttributes attributes, uint offset, MetadataReader reader)
			: base(name, attributes)
		{
			this.offset = offset;
			this.reader = reader;
		}

		public Stream GetResourceStream()
		{
			if (stream != null)
			{
				return stream;
			}
			if (data != null)
			{
				return new MemoryStream(data);
			}
			if (offset.HasValue)
			{
				return reader.GetManagedResourceStream(offset.Value);
			}
			throw new InvalidOperationException();
		}

		public byte[] GetResourceData()
		{
			if (stream != null)
			{
				return ReadStream(stream);
			}
			if (data != null)
			{
				return data;
			}
			if (offset.HasValue)
			{
				return reader.GetManagedResourceStream(offset.Value).ToArray();
			}
			throw new InvalidOperationException();
		}

		private static byte[] ReadStream(Stream stream)
		{
			int num3;
			if (stream.CanSeek)
			{
				int num = (int)stream.Length;
				byte[] array = new byte[num];
				int num2 = 0;
				while ((num3 = stream.Read(array, num2, num - num2)) > 0)
				{
					num2 += num3;
				}
				return array;
			}
			byte[] array2 = new byte[8192];
			MemoryStream memoryStream = new MemoryStream();
			while ((num3 = stream.Read(array2, 0, array2.Length)) > 0)
			{
				memoryStream.Write(array2, 0, num3);
			}
			return memoryStream.ToArray();
		}
	}
	[Flags]
	public enum EventAttributes : ushort
	{
		None = 0,
		SpecialName = 0x200,
		RTSpecialName = 0x400
	}
	public sealed class EventDefinition : EventReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider
	{
		private ushort attributes;

		private Mono.Collections.Generic.Collection<CustomAttribute> custom_attributes;

		internal MethodDefinition add_method;

		internal MethodDefinition invoke_method;

		internal MethodDefinition remove_method;

		internal Mono.Collections.Generic.Collection<MethodDefinition> other_methods;

		public EventAttributes Attributes
		{
			get
			{
				return (EventAttributes)attributes;
			}
			set
			{
				attributes = (ushort)value;
			}
		}

		public MethodDefinition AddMethod
		{
			get
			{
				if (add_method != null)
				{
					return add_method;
				}
				InitializeMethods();
				return add_method;
			}
			set
			{
				add_method = value;
			}
		}

		public MethodDefinition InvokeMethod
		{
			get
			{
				if (invoke_method != null)
				{
					return invoke_method;
				}
				InitializeMethods();
				return invoke_method;
			}
			set
			{
				invoke_method = value;
			}
		}

		public MethodDefinition RemoveMethod
		{
			get
			{
				if (remove_method != null)
				{
					return remove_method;
				}
				InitializeMethods();
				return remove_method;
			}
			set
			{
				remove_method = value;
			}
		}

		public bool HasOtherMethods
		{
			get
			{
				if (other_methods != null)
				{
					return other_methods.Count > 0;
				}
				InitializeMethods();
				return !other_methods.IsNullOrEmpty();
			}
		}

		public Mono.Collections.Generic.Collection<MethodDefinition> OtherMethods
		{
			get
			{
				if (other_methods != null)
				{
					return other_methods;
				}
				InitializeMethods();
				if (other_methods != null)
				{
					return other_methods;
				}
				return other_methods = new Mono.Collections.Generic.Collection<MethodDefinition>();
			}
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
				{
					return custom_attributes.Count > 0;
				}
				return this.GetHasCustomAttributes(Module);
			}
		}

		public Mono.Collections.Generic.Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

		public bool IsSpecialName
		{
			get
			{
				return attributes.GetAttributes(512);
			}
			set
			{
				attributes = attributes.SetAttributes(512, value);
			}
		}

		public bool IsRuntimeSpecialName
		{
			get
			{
				return attributes.GetAttributes(1024);
			}
			set
			{
				attributes = attributes.SetAttributes(1024, value);
			}
		}

		public new TypeDefinition DeclaringType
		{
			get
			{
				return (TypeDefinition)base.DeclaringType;
			}
			set
			{
				base.DeclaringType = value;
			}
		}

		public override bool IsDefinition => true;

		public EventDefinition(string name, EventAttributes attributes, TypeReference eventType)
			: base(name, eventType)
		{
			this.attributes = (ushort)attributes;
			token = new MetadataToken(TokenType.Event);
		}

		private void InitializeMethods()
		{
			ModuleDefinition module = Module;
			if (module == null)
			{
				return;
			}
			lock (module.SyncRoot)
			{
				if (add_method == null && invoke_method == null && remove_method == null && module.HasImage())
				{
					module.Read(this, (EventDefinition @event, MetadataReader reader) => reader.ReadMethods(@event));
				}
			}
		}

		public override EventDefinition Resolve()
		{
			return this;
		}
	}
	public abstract class EventReference : MemberReference
	{
		private TypeReference event_type;

		public TypeReference EventType
		{
			get
			{
				return event_type;
			}
			set
			{
				event_type = value;
			}
		}

		public override string FullName => event_type.FullName + " " + MemberFullName();

		protected EventReference(string name, TypeReference eventType)
			: base(name)
		{
			if (eventType == null)
			{
				throw new ArgumentNullException("eventType");
			}
			event_type = eventType;
		}

		public abstract EventDefinition Resolve();
	}
	[Flags]
	public enum FieldAttributes : ushort
	{
		FieldAccessMask = 7,
		CompilerControlled = 0,
		Private = 1,
		FamANDAssem = 2,
		Assembly = 3,
		Family = 4,
		FamORAssem = 5,
		Public = 6,
		Static = 0x10,
		InitOnly = 0x20,
		Literal = 0x40,
		NotSerialized = 0x80,
		SpecialName = 0x200,
		PInvokeImpl = 0x2000,
		RTSpecialName = 0x400,
		HasFieldMarshal = 0x1000,
		HasDefault = 0x8000,
		HasFieldRVA = 0x100
	}
	public sealed class FieldDefinition : FieldReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider, IConstantProvider, IMarshalInfoProvider
	{
		private ushort attributes;

		private Mono.Collections.Generic.Collection<CustomAttribute> custom_attributes;

		private int offset = -2;

		internal int rva = -2;

		private byte[] initial_value;

		private object constant = Mixin.NotResolved;

		private MarshalInfo marshal_info;

		public bool HasLayoutInfo
		{
			get
			{
				if (offset >= 0)
				{
					return true;
				}
				ResolveLayout();
				return offset >= 0;
			}
		}

		public int Offset
		{
			get
			{
				if (offset >= 0)
				{
					return offset;
				}
				ResolveLayout();
				if (offset < 0)
				{
					return -1;
				}
				return offset;
			}
			set
			{
				offset = value;
			}
		}

		public int RVA
		{
			get
			{
				if (rva > 0)
				{
					return rva;
				}
				ResolveRVA();
				if (rva <= 0)
				{
					return 0;
				}
				return rva;
			}
		}

		public byte[] InitialValue
		{
			get
			{
				if (initial_value != null)
				{
					return initial_value;
				}
				ResolveRVA();
				if (initial_value == null)
				{
					initial_value = Empty<byte>.Array;
				}
				return initial_value;
			}
			set
			{
				initial_value = value;
				rva = 0;
			}
		}

		public FieldAttributes Attributes
		{
			get
			{
				return (FieldAttributes)attributes;
			}
			set
			{
				attributes = (ushort)value;
			}
		}

		public bool HasConstant
		{
			get
			{
				this.ResolveConstant(ref constant, Module);
				return constant != Mixin.NoValue;
			}
			set
			{
				if (!value)
				{
					constant = Mixin.NoValue;
				}
			}
		}

		public object Constant
		{
			get
			{
				if (!HasConstant)
				{
					return null;
				}
				return constant;
			}
			set
			{
				constant = value;
			}
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
				{
					return custom_attributes.Count > 0;
				}
				return this.GetHasCustomAttributes(Module);
			}
		}

		public Mono.Collections.Generic.Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

		public bool HasMarshalInfo
		{
			get
			{
				if (marshal_info != null)
				{
					return true;
				}
				return this.GetHasMarshalInfo(Module);
			}
		}

		public MarshalInfo MarshalInfo
		{
			get
			{
				return marshal_info ?? this.GetMarshalInfo(ref marshal_info, Module);
			}
			set
			{
				marshal_info = value;
			}
		}

		public bool IsCompilerControlled
		{
			get
			{
				return attributes.GetMaskedAttributes(7, 0u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7, 0u, value);
			}
		}

		public bool IsPrivate
		{
			get
			{
				return attributes.GetMaskedAttributes(7, 1u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7, 1u, value);
			}
		}

		public bool IsFamilyAndAssembly
		{
			get
			{
				return attributes.GetMaskedAttributes(7, 2u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7, 2u, value);
			}
		}

		public bool IsAssembly
		{
			get
			{
				return attributes.GetMaskedAttributes(7, 3u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7, 3u, value);
			}
		}

		public bool IsFamily
		{
			get
			{
				return attributes.GetMaskedAttributes(7, 4u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7, 4u, value);
			}
		}

		public bool IsFamilyOrAssembly
		{
			get
			{
				return attributes.GetMaskedAttributes(7, 5u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7, 5u, value);
			}
		}

		public bool IsPublic
		{
			get
			{
				return attributes.GetMaskedAttributes(7, 6u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7, 6u, value);
			}
		}

		public bool IsStatic
		{
			get
			{
				return attributes.GetAttributes(16);
			}
			set
			{
				attributes = attributes.SetAttributes(16, value);
			}
		}

		public bool IsInitOnly
		{
			get
			{
				return attributes.GetAttributes(32);
			}
			set
			{
				attributes = attributes.SetAttributes(32, value);
			}
		}

		public bool IsLiteral
		{
			get
			{
				return attributes.GetAttributes(64);
			}
			set
			{
				attributes = attributes.SetAttributes(64, value);
			}
		}

		public bool IsNotSerialized
		{
			get
			{
				return attributes.GetAttributes(128);
			}
			set
			{
				attributes = attributes.SetAttributes(128, value);
			}
		}

		public bool IsSpecialName
		{
			get
			{
				return attributes.GetAttributes(512);
			}
			set
			{
				attributes = attributes.SetAttributes(512, value);
			}
		}

		public bool IsPInvokeImpl
		{
			get
			{
				return attributes.GetAttributes(8192);
			}
			set
			{
				attributes = attributes.SetAttributes(8192, value);
			}
		}

		public bool IsRuntimeSpecialName
		{
			get
			{
				return attributes.GetAttributes(1024);
			}
			set
			{
				attributes = attributes.SetAttributes(1024, value);
			}
		}

		public bool HasDefault
		{
			get
			{
				return attributes.GetAttributes(32768);
			}
			set
			{
				attributes = attributes.SetAttributes(32768, value);
			}
		}

		public override bool IsDefinition => true;

		public new TypeDefinition DeclaringType
		{
			get
			{
				return (TypeDefinition)base.DeclaringType;
			}
			set
			{
				base.DeclaringType = value;
			}
		}

		private void ResolveLayout()
		{
			if (offset != -2)
			{
				return;
			}
			if (!base.HasImage)
			{
				offset = -1;
				return;
			}
			offset = Module.Read(this, (FieldDefinition field, MetadataReader reader) => reader.ReadFieldLayout(field));
		}

		private void ResolveRVA()
		{
			if (rva == -2 && base.HasImage)
			{
				rva = Module.Read(this, (FieldDefinition field, MetadataReader reader) => reader.ReadFieldRVA(field));
			}
		}

		public FieldDefinition(string name, FieldAttributes attributes, TypeReference fieldType)
			: base(name, fieldType)
		{
			this.attributes = (ushort)attributes;
		}

		public override FieldDefinition Resolve()
		{
			return this;
		}
	}
	public class FieldReference : MemberReference
	{
		private TypeReference field_type;

		public TypeReference FieldType
		{
			get
			{
				return field_type;
			}
			set
			{
				field_type = value;
			}
		}

		public override string FullName => field_type.FullName + " " + MemberFullName();

		public override bool ContainsGenericParameter
		{
			get
			{
				if (!field_type.ContainsGenericParameter)
				{
					return base.ContainsGenericParameter;
				}
				return true;
			}
		}

		internal FieldReference()
		{
			token = new MetadataToken(TokenType.MemberRef);
		}

		public FieldReference(string name, TypeReference fieldType)
			: base(name)
		{
			if (fieldType == null)
			{
				throw new ArgumentNullException("fieldType");
			}
			field_type = fieldType;
			token = new MetadataToken(TokenType.MemberRef);
		}

		public FieldReference(string name, TypeReference fieldType, TypeReference declaringType)
			: this(name, fieldType)
		{
			if (declaringType == null)
			{
				throw new ArgumentNullException("declaringType");
			}
			DeclaringType = declaringType;
		}

		public virtual FieldDefinition Resolve()
		{
			return (Module ?? throw new NotSupportedException()).Resolve(this);
		}
	}
	public interface IMemberDefinition : ICustomAttributeProvider, IMetadataTokenProvider
	{
		string Name { get; set; }

		string FullName { get; }

		bool IsSpecialName { get; set; }

		bool IsRuntimeSpecialName { get; set; }

		TypeDefinition DeclaringType { get; set; }
	}
	public sealed class LinkedResource : Resource
	{
		internal byte[] hash;

		private string file;

		public byte[] Hash => hash;

		public string File
		{
			get
			{
				return file;
			}
			set
			{
				file = value;
			}
		}

		public override ResourceType ResourceType => ResourceType.Linked;

		public LinkedResource(string name, ManifestResourceAttributes flags)
			: base(name, flags)
		{
		}

		public LinkedResource(string name, ManifestResourceAttributes flags, string file)
			: base(name, flags)
		{
			this.file = file;
		}
	}
	public abstract class MemberReference : IMetadataTokenProvider
	{
		private string name;

		private TypeReference declaring_type;

		internal MetadataToken token;

		public virtual string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public abstract string FullName { get; }

		public virtual TypeReference DeclaringType
		{
			get
			{
				return declaring_type;
			}
			set
			{
				declaring_type = value;
			}
		}

		public MetadataToken MetadataToken
		{
			get
			{
				return token;
			}
			set
			{
				token = value;
			}
		}

		internal bool HasImage => Module?.HasImage ?? false;

		public virtual ModuleDefinition Module
		{
			get
			{
				if (declaring_type == null)
				{
					return null;
				}
				return declaring_type.Module;
			}
		}

		public virtual bool IsDefinition => false;

		public virtual bool ContainsGenericParameter
		{
			get
			{
				if (declaring_type != null)
				{
					return declaring_type.ContainsGenericParameter;
				}
				return false;
			}
		}

		internal MemberReference()
		{
		}

		internal MemberReference(string name)
		{
			this.name = name ?? string.Empty;
		}

		internal string MemberFullName()
		{
			if (declaring_type == null)
			{
				return name;
			}
			return declaring_type.FullName + "::" + name;
		}

		public override string ToString()
		{
			return FullName;
		}
	}
	[Flags]
	public enum MethodAttributes : ushort
	{
		MemberAccessMask = 7,
		CompilerControlled = 0,
		Private = 1,
		FamANDAssem = 2,
		Assembly = 3,
		Family = 4,
		FamORAssem = 5,
		Public = 6,
		Static = 0x10,
		Final = 0x20,
		Virtual = 0x40,
		HideBySig = 0x80,
		VtableLayoutMask = 0x100,
		ReuseSlot = 0,
		NewSlot = 0x100,
		CheckAccessOnOverride = 0x200,
		Abstract = 0x400,
		SpecialName = 0x800,
		PInvokeImpl = 0x2000,
		UnmanagedExport = 8,
		RTSpecialName = 0x1000,
		HasSecurity = 0x4000,
		RequireSecObject = 0x8000
	}
	public enum MethodCallingConvention : byte
	{
		Default = 0,
		C = 1,
		StdCall = 2,
		ThisCall = 3,
		FastCall = 4,
		VarArg = 5,
		Generic = 16
	}
	public sealed class MethodDefinition : MethodReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider, ISecurityDeclarationProvider
	{
		private ushort attributes;

		private ushort impl_attributes;

		internal volatile bool sem_attrs_ready;

		internal MethodSemanticsAttributes sem_attrs;

		private Mono.Collections.Generic.Collection<CustomAttribute> custom_attributes;

		private Mono.Collections.Generic.Collection<SecurityDeclaration> security_declarations;

		internal uint rva;

		internal PInvokeInfo pinvoke;

		private Mono.Collections.Generic.Collection<MethodReference> overrides;

		internal Mono.Cecil.Cil.MethodBody body;

		public MethodAttributes Attributes
		{
			get
			{
				return (MethodAttributes)attributes;
			}
			set
			{
				attributes = (ushort)value;
			}
		}

		public MethodImplAttributes ImplAttributes
		{
			get
			{
				return (MethodImplAttributes)impl_attributes;
			}
			set
			{
				impl_attributes = (ushort)value;
			}
		}

		public MethodSemanticsAttributes SemanticsAttributes
		{
			get
			{
				if (sem_attrs_ready)
				{
					return sem_attrs;
				}
				if (base.HasImage)
				{
					ReadSemantics();
					return sem_attrs;
				}
				sem_attrs = MethodSemanticsAttributes.None;
				sem_attrs_ready = true;
				return sem_attrs;
			}
			set
			{
				sem_attrs = value;
			}
		}

		public bool HasSecurityDeclarations
		{
			get
			{
				if (security_declarations != null)
				{
					return security_declarations.Count > 0;
				}
				return this.GetHasSecurityDeclarations(Module);
			}
		}

		public Mono.Collections.Generic.Collection<SecurityDeclaration> SecurityDeclarations => security_declarations ?? this.GetSecurityDeclarations(ref security_declarations, Module);

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
				{
					return custom_attributes.Count > 0;
				}
				return this.GetHasCustomAttributes(Module);
			}
		}

		public Mono.Collections.Generic.Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

		public int RVA => (int)rva;

		public bool HasBody
		{
			get
			{
				if ((attributes & 0x400) == 0 && (attributes & 0x2000) == 0 && (impl_attributes & 0x1000) == 0 && (impl_attributes & 1) == 0 && (impl_attributes & 4) == 0)
				{
					return (impl_attributes & 3) == 0;
				}
				return false;
			}
		}

		public Mono.Cecil.Cil.MethodBody Body
		{
			get
			{
				Mono.Cecil.Cil.MethodBody methodBody = body;
				if (methodBody != null)
				{
					return methodBody;
				}
				if (!HasBody)
				{
					return null;
				}
				if (base.HasImage && rva != 0)
				{
					return Module.Read(ref body, this, (MethodDefinition method, MetadataReader reader) => reader.ReadMethodBody(method));
				}
				return body = new Mono.Cecil.Cil.MethodBody(this);
			}
			set
			{
				ModuleDefinition module = Module;
				if (module == null)
				{
					body = value;
					return;
				}
				lock (module.SyncRoot)
				{
					body = value;
				}
			}
		}

		public bool HasPInvokeInfo
		{
			get
			{
				if (pinvoke != null)
				{
					return true;
				}
				return IsPInvokeImpl;
			}
		}

		public PInvokeInfo PInvokeInfo
		{
			get
			{
				if (pinvoke != null)
				{
					return pinvoke;
				}
				if (base.HasImage && IsPInvokeImpl)
				{
					return Module.Read(ref pinvoke, this, (MethodDefinition method, MetadataReader reader) => reader.ReadPInvokeInfo(method));
				}
				return null;
			}
			set
			{
				IsPInvokeImpl = true;
				pinvoke = value;
			}
		}

		public bool HasOverrides
		{
			get
			{
				if (overrides != null)
				{
					return overrides.Count > 0;
				}
				if (base.HasImage)
				{
					return Module.Read(this, (MethodDefinition method, MetadataReader reader) => reader.HasOverrides(method));
				}
				return false;
			}
		}

		public Mono.Collections.Generic.Collection<MethodReference> Overrides
		{
			get
			{
				if (overrides != null)
				{
					return overrides;
				}
				if (base.HasImage)
				{
					return Module.Read(ref overrides, this, (MethodDefinition method, MetadataReader reader) => reader.ReadOverrides(method));
				}
				return overrides = new Mono.Collections.Generic.Collection<MethodReference>();
			}
		}

		public override bool HasGenericParameters
		{
			get
			{
				if (generic_parameters != null)
				{
					return generic_parameters.Count > 0;
				}
				return this.GetHasGenericParameters(Module);
			}
		}

		public override Mono.Collections.Generic.Collection<GenericParameter> GenericParameters => generic_parameters ?? this.GetGenericParameters(ref generic_parameters, Module);

		public bool IsCompilerControlled
		{
			get
			{
				return attributes.GetMaskedAttributes(7, 0u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7, 0u, value);
			}
		}

		public bool IsPrivate
		{
			get
			{
				return attributes.GetMaskedAttributes(7, 1u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7, 1u, value);
			}
		}

		public bool IsFamilyAndAssembly
		{
			get
			{
				return attributes.GetMaskedAttributes(7, 2u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7, 2u, value);
			}
		}

		public bool IsAssembly
		{
			get
			{
				return attributes.GetMaskedAttributes(7, 3u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7, 3u, value);
			}
		}

		public bool IsFamily
		{
			get
			{
				return attributes.GetMaskedAttributes(7, 4u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7, 4u, value);
			}
		}

		public bool IsFamilyOrAssembly
		{
			get
			{
				return attributes.GetMaskedAttributes(7, 5u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7, 5u, value);
			}
		}

		public bool IsPublic
		{
			get
			{
				return attributes.GetMaskedAttributes(7, 6u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7, 6u, value);
			}
		}

		public bool IsStatic
		{
			get
			{
				return attributes.GetAttributes(16);
			}
			set
			{
				attributes = attributes.SetAttributes(16, value);
			}
		}

		public bool IsFinal
		{
			get
			{
				return attributes.GetAttributes(32);
			}
			set
			{
				attributes = attributes.SetAttributes(32, value);
			}
		}

		public bool IsVirtual
		{
			get
			{
				return attributes.GetAttributes(64);
			}
			set
			{
				attributes = attributes.SetAttributes(64, value);
			}
		}

		public bool IsHideBySig
		{
			get
			{
				return attributes.GetAttributes(128);
			}
			set
			{
				attributes = attributes.SetAttributes(128, value);
			}
		}

		public bool IsReuseSlot
		{
			get
			{
				return attributes.GetMaskedAttributes(256, 0u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(256, 0u, value);
			}
		}

		public bool IsNewSlot
		{
			get
			{
				return attributes.GetMaskedAttributes(256, 256u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(256, 256u, value);
			}
		}

		public bool IsCheckAccessOnOverride
		{
			get
			{
				return attributes.GetAttributes(512);
			}
			set
			{
				attributes = attributes.SetAttributes(512, value);
			}
		}

		public bool IsAbstract
		{
			get
			{
				return attributes.GetAttributes(1024);
			}
			set
			{
				attributes = attributes.SetAttributes(1024, value);
			}
		}

		public bool IsSpecialName
		{
			get
			{
				return attributes.GetAttributes(2048);
			}
			set
			{
				attributes = attributes.SetAttributes(2048, value);
			}
		}

		public bool IsPInvokeImpl
		{
			get
			{
				return attributes.GetAttributes(8192);
			}
			set
			{
				attributes = attributes.SetAttributes(8192, value);
			}
		}

		public bool IsUnmanagedExport
		{
			get
			{
				return attributes.GetAttributes(8);
			}
			set
			{
				attributes = attributes.SetAttributes(8, value);
			}
		}

		public bool IsRuntimeSpecialName
		{
			get
			{
				return attributes.GetAttributes(4096);
			}
			set
			{
				attributes = attributes.SetAttributes(4096, value);
			}
		}

		public bool HasSecurity
		{
			get
			{
				return attributes.GetAttributes(16384);
			}
			set
			{
				attributes = attributes.SetAttributes(16384, value);
			}
		}

		public bool IsIL
		{
			get
			{
				return impl_attributes.GetMaskedAttributes(3, 0u);
			}
			set
			{
				impl_attributes = impl_attributes.SetMaskedAttributes(3, 0u, value);
			}
		}

		public bool IsNative
		{
			get
			{
				return impl_attributes.GetMaskedAttributes(3, 1u);
			}
			set
			{
				impl_attributes = impl_attributes.SetMaskedAttributes(3, 1u, value);
			}
		}

		public bool IsRuntime
		{
			get
			{
				return impl_attributes.GetMaskedAttributes(3, 3u);
			}
			set
			{
				impl_attributes = impl_attributes.SetMaskedAttributes(3, 3u, value);
			}
		}

		public bool IsUnmanaged
		{
			get
			{
				return impl_attributes.GetMaskedAttributes(4, 4u);
			}
			set
			{
				impl_attributes = impl_attributes.SetMaskedAttributes(4, 4u, value);
			}
		}

		public bool IsManaged
		{
			get
			{
				return impl_attributes.GetMaskedAttributes(4, 0u);
			}
			set
			{
				impl_attributes = impl_attributes.SetMaskedAttributes(4, 0u, value);
			}
		}

		public bool IsForwardRef
		{
			get
			{
				return impl_attributes.GetAttributes(16);
			}
			set
			{
				impl_attributes = impl_attributes.SetAttributes(16, value);
			}
		}

		public bool IsPreserveSig
		{
			get
			{
				return impl_attributes.GetAttributes(128);
			}
			set
			{
				impl_attributes = impl_attributes.SetAttributes(128, value);
			}
		}

		public bool IsInternalCall
		{
			get
			{
				return impl_attributes.GetAttributes(4096);
			}
			set
			{
				impl_attributes = impl_attributes.SetAttributes(4096, value);
			}
		}

		public bool IsSynchronized
		{
			get
			{
				return impl_attributes.GetAttributes(32);
			}
			set
			{
				impl_attributes = impl_attributes.SetAttributes(32, value);
			}
		}

		public bool NoInlining
		{
			get
			{
				return impl_attributes.GetAttributes(8);
			}
			set
			{
				impl_attributes = impl_attributes.SetAttributes(8, value);
			}
		}

		public bool NoOptimization
		{
			get
			{
				return impl_attributes.GetAttributes(64);
			}
			set
			{
				impl_attributes = impl_attributes.SetAttributes(64, value);
			}
		}

		public bool IsSetter
		{
			get
			{
				return this.GetSemantics(MethodSemanticsAttributes.Setter);
			}
			set
			{
				this.SetSemantics(MethodSemanticsAttributes.Setter, value);
			}
		}

		public bool IsGetter
		{
			get
			{
				return this.GetSemantics(MethodSemanticsAttributes.Getter);
			}
			set
			{
				this.SetSemantics(MethodSemanticsAttributes.Getter, value);
			}
		}

		public bool IsOther
		{
			get
			{
				return this.GetSemantics(MethodSemanticsAttributes.Other);
			}
			set
			{
				this.SetSemantics(MethodSemanticsAttributes.Other, value);
			}
		}

		public bool IsAddOn
		{
			get
			{
				return this.GetSemantics(MethodSemanticsAttributes.AddOn);
			}
			set
			{
				this.SetSemantics(MethodSemanticsAttributes.AddOn, value);
			}
		}

		public bool IsRemoveOn
		{
			get
			{
				return this.GetSemantics(MethodSemanticsAttributes.RemoveOn);
			}
			set
			{
				this.SetSemantics(MethodSemanticsAttributes.RemoveOn, value);
			}
		}

		public bool IsFire
		{
			get
			{
				return this.GetSemantics(MethodSemanticsAttributes.Fire);
			}
			set
			{
				this.SetSemantics(MethodSemanticsAttributes.Fire, value);
			}
		}

		public new TypeDefinition DeclaringType
		{
			get
			{
				return (TypeDefinition)base.DeclaringType;
			}
			set
			{
				base.DeclaringType = value;
			}
		}

		public bool IsConstructor
		{
			get
			{
				if (IsRuntimeSpecialName && IsSpecialName)
				{
					if (!(Name == ".cctor"))
					{
						return Name == ".ctor";
					}
					return true;
				}
				return false;
			}
		}

		public override bool IsDefinition => true;

		internal void ReadSemantics()
		{
			if (sem_attrs_ready)
			{
				return;
			}
			ModuleDefinition module = Module;
			if (module != null && module.HasImage)
			{
				module.Read(this, (MethodDefinition method, MetadataReader reader) => reader.ReadAllSemantics(method));
			}
		}

		internal MethodDefinition()
		{
			token = new MetadataToken(TokenType.Method);
		}

		public MethodDefinition(string name, MethodAttributes attributes, TypeReference returnType)
			: base(name, returnType)
		{
			this.attributes = (ushort)attributes;
			HasThis = !IsStatic;
			token = new MetadataToken(TokenType.Method);
		}

		public override MethodDefinition Resolve()
		{
			return this;
		}
	}
	[Flags]
	public enum MethodImplAttributes : ushort
	{
		CodeTypeMask = 3,
		IL = 0,
		Native = 1,
		OPTIL = 2,
		Runtime = 3,
		ManagedMask = 4,
		Unmanaged = 4,
		Managed = 0,
		ForwardRef = 0x10,
		PreserveSig = 0x80,
		InternalCall = 0x1000,
		Synchronized = 0x20,
		NoOptimization = 0x40,
		NoInlining = 8
	}
	public class MethodReference : MemberReference, IMethodSignature, IMetadataTokenProvider, IGenericParameterProvider, IGenericContext
	{
		internal ParameterDefinitionCollection parameters;

		private MethodReturnType return_type;

		private bool has_this;

		private bool explicit_this;

		private MethodCallingConvention calling_convention;

		internal Mono.Collections.Generic.Collection<GenericParameter> generic_parameters;

		public virtual bool HasThis
		{
			get
			{
				return has_this;
			}
			set
			{
				has_this = value;
			}
		}

		public virtual bool ExplicitThis
		{
			get
			{
				return explicit_this;
			}
			set
			{
				explicit_this = value;
			}
		}

		public virtual MethodCallingConvention CallingConvention
		{
			get
			{
				return calling_convention;
			}
			set
			{
				calling_convention = value;
			}
		}

		public virtual bool HasParameters => !parameters.IsNullOrEmpty();

		public virtual Mono.Collections.Generic.Collection<ParameterDefinition> Parameters
		{
			get
			{
				if (parameters == null)
				{
					parameters = new ParameterDefinitionCollection(this);
				}
				return parameters;
			}
		}

		IGenericParameterProvider IGenericContext.Type
		{
			get
			{
				TypeReference declaringType = DeclaringType;
				if (declaringType is GenericInstanceType genericInstanceType)
				{
					return genericInstanceType.ElementType;
				}
				return declaringType;
			}
		}

		IGenericParameterProvider IGenericContext.Method => this;

		GenericParameterType IGenericParameterProvider.GenericParameterType => GenericParameterType.Method;

		public virtual bool HasGenericParameters => !generic_parameters.IsNullOrEmpty();

		public virtual Mono.Collections.Generic.Collection<GenericParameter> GenericParameters
		{
			get
			{
				if (generic_parameters != null)
				{
					return generic_parameters;
				}
				return generic_parameters = new GenericParameterCollection(this);
			}
		}

		public TypeReference ReturnType
		{
			get
			{
				return MethodReturnType?.ReturnType;
			}
			set
			{
				MethodReturnType methodReturnType = MethodReturnType;
				if (methodReturnType != null)
				{
					methodReturnType.ReturnType = value;
				}
			}
		}

		public virtual MethodReturnType MethodReturnType
		{
			get
			{
				return return_type;
			}
			set
			{
				return_type = value;
			}
		}

		public override string FullName
		{
			get
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(ReturnType.FullName).Append(" ").Append(MemberFullName());
				this.MethodSignatureFullName(stringBuilder);
				return stringBuilder.ToString();
			}
		}

		public virtual bool IsGenericInstance => false;

		public override bool ContainsGenericParameter
		{
			get
			{
				if (ReturnType.ContainsGenericParameter || base.ContainsGenericParameter)
				{
					return true;
				}
				Mono.Collections.Generic.Collection<ParameterDefinition> collection = Parameters;
				for (int i = 0; i < collection.Count; i++)
				{
					if (collection[i].ParameterType.ContainsGenericParameter)
					{
						return true;
					}
				}
				return false;
			}
		}

		internal MethodReference()
		{
			return_type = new MethodReturnType(this);
			token = new MetadataToken(TokenType.MemberRef);
		}

		public MethodReference(string name, TypeReference returnType)
			: base(name)
		{
			if (returnType == null)
			{
				throw new ArgumentNullException("returnType");
			}
			return_type = new MethodReturnType(this);
			return_type.ReturnType = returnType;
			token = new MetadataToken(TokenType.MemberRef);
		}

		public MethodReference(string name, TypeReference returnType, TypeReference declaringType)
			: this(name, returnType)
		{
			if (declaringType == null)
			{
				throw new ArgumentNullException("declaringType");
			}
			DeclaringType = declaringType;
		}

		public virtual MethodReference GetElementMethod()
		{
			return this;
		}

		public virtual MethodDefinition Resolve()
		{
			return (Module ?? throw new NotSupportedException()).Resolve(this);
		}
	}
	public sealed class MethodReturnType : IConstantProvider, IMetadataTokenProvider, ICustomAttributeProvider, IMarshalInfoProvider
	{
		internal IMethodSignature method;

		internal ParameterDefinition parameter;

		private TypeReference return_type;

		public IMethodSignature Method => method;

		public TypeReference ReturnType
		{
			get
			{
				return return_type;
			}
			set
			{
				return_type = value;
			}
		}

		internal ParameterDefinition Parameter
		{
			get
			{
				if (parameter == null)
				{
					Interlocked.CompareExchange(ref parameter, new ParameterDefinition(return_type, method), null);
				}
				return parameter;
			}
		}

		public MetadataToken MetadataToken
		{
			get
			{
				return Parameter.MetadataToken;
			}
			set
			{
				Parameter.MetadataToken = value;
			}
		}

		public ParameterAttributes Attributes
		{
			get
			{
				return Parameter.Attributes;
			}
			set
			{
				Parameter.Attributes = value;
			}
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (parameter != null)
				{
					return parameter.HasCustomAttributes;
				}
				return false;
			}
		}

		public Mono.Collections.Generic.Collection<CustomAttribute> CustomAttributes => Parameter.CustomAttributes;

		public bool HasDefault
		{
			get
			{
				if (parameter != null)
				{
					return parameter.HasDefault;
				}
				return false;
			}
			set
			{
				Parameter.HasDefault = value;
			}
		}

		public bool HasConstant
		{
			get
			{
				if (parameter != null)
				{
					return parameter.HasConstant;
				}
				return false;
			}
			set
			{
				Parameter.HasConstant = value;
			}
		}

		public object Constant
		{
			get
			{
				return Parameter.Constant;
			}
			set
			{
				Parameter.Constant = value;
			}
		}

		public bool HasFieldMarshal
		{
			get
			{
				if (parameter != null)
				{
					return parameter.HasFieldMarshal;
				}
				return false;
			}
			set
			{
				Parameter.HasFieldMarshal = value;
			}
		}

		public bool HasMarshalInfo
		{
			get
			{
				if (parameter != null)
				{
					return parameter.HasMarshalInfo;
				}
				return false;
			}
		}

		public MarshalInfo MarshalInfo
		{
			get
			{
				return Parameter.MarshalInfo;
			}
			set
			{
				Parameter.MarshalInfo = value;
			}
		}

		public MethodReturnType(IMethodSignature method)
		{
			this.method = method;
		}
	}
	[Flags]
	public enum MethodSemanticsAttributes : ushort
	{
		None = 0,
		Setter = 1,
		Getter = 2,
		Other = 4,
		AddOn = 8,
		RemoveOn = 0x10,
		Fire = 0x20
	}
	public abstract class MethodSpecification : MethodReference
	{
		private readonly MethodReference method;

		public MethodReference ElementMethod => method;

		public override string Name
		{
			get
			{
				return method.Name;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override MethodCallingConvention CallingConvention
		{
			get
			{
				return method.CallingConvention;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override bool HasThis
		{
			get
			{
				return method.HasThis;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override bool ExplicitThis
		{
			get
			{
				return method.ExplicitThis;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override MethodReturnType MethodReturnType
		{
			get
			{
				return method.MethodReturnType;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override TypeReference DeclaringType
		{
			get
			{
				return method.DeclaringType;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override ModuleDefinition Module => method.Module;

		public override bool HasParameters => method.HasParameters;

		public override Mono.Collections.Generic.Collection<ParameterDefinition> Parameters => method.Parameters;

		public override bool ContainsGenericParameter => method.ContainsGenericParameter;

		internal MethodSpecification(MethodReference method)
		{
			if (method == null)
			{
				throw new ArgumentNullException("method");
			}
			this.method = method;
			token = new MetadataToken(TokenType.MethodSpec);
		}

		public sealed override MethodReference GetElementMethod()
		{
			return method.GetElementMethod();
		}
	}
	[Flags]
	public enum ParameterAttributes : ushort
	{
		None = 0,
		In = 1,
		Out = 2,
		Lcid = 4,
		Retval = 8,
		Optional = 0x10,
		HasDefault = 0x1000,
		HasFieldMarshal = 0x2000,
		Unused = 0xCFE0
	}
	public sealed class ParameterDefinition : ParameterReference, ICustomAttributeProvider, IMetadataTokenProvider, IConstantProvider, IMarshalInfoProvider
	{
		private ushort attributes;

		internal IMethodSignature method;

		private object constant = Mixin.NotResolved;

		private Mono.Collections.Generic.Collection<CustomAttribute> custom_attributes;

		private MarshalInfo marshal_info;

		public ParameterAttributes Attributes
		{
			get
			{
				return (ParameterAttributes)attributes;
			}
			set
			{
				attributes = (ushort)value;
			}
		}

		public IMethodSignature Method => method;

		public int Sequence
		{
			get
			{
				if (method == null)
				{
					return -1;
				}
				if (!method.HasImplicitThis())
				{
					return index;
				}
				return index + 1;
			}
		}

		public bool HasConstant
		{
			get
			{
				this.ResolveConstant(ref constant, parameter_type.Module);
				return constant != Mixin.NoValue;
			}
			set
			{
				if (!value)
				{
					constant = Mixin.NoValue;
				}
			}
		}

		public object Constant
		{
			get
			{
				if (!HasConstant)
				{
					return null;
				}
				return constant;
			}
			set
			{
				constant = value;
			}
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
				{
					return custom_attributes.Count > 0;
				}
				return this.GetHasCustomAttributes(parameter_type.Module);
			}
		}

		public Mono.Collections.Generic.Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, parameter_type.Module);

		public bool HasMarshalInfo
		{
			get
			{
				if (marshal_info != null)
				{
					return true;
				}
				return this.GetHasMarshalInfo(parameter_type.Module);
			}
		}

		public MarshalInfo MarshalInfo
		{
			get
			{
				return marshal_info ?? this.GetMarshalInfo(ref marshal_info, parameter_type.Module);
			}
			set
			{
				marshal_info = value;
			}
		}

		public bool IsIn
		{
			get
			{
				return attributes.GetAttributes(1);
			}
			set
			{
				attributes = attributes.SetAttributes(1, value);
			}
		}

		public bool IsOut
		{
			get
			{
				return attributes.GetAttributes(2);
			}
			set
			{
				attributes = attributes.SetAttributes(2, value);
			}
		}

		public bool IsLcid
		{
			get
			{
				return attributes.GetAttributes(4);
			}
			set
			{
				attributes = attributes.SetAttributes(4, value);
			}
		}

		public bool IsReturnValue
		{
			get
			{
				return attributes.GetAttributes(8);
			}
			set
			{
				attributes = attributes.SetAttributes(8, value);
			}
		}

		public bool IsOptional
		{
			get
			{
				return attributes.GetAttributes(16);
			}
			set
			{
				attributes = attributes.SetAttributes(16, value);
			}
		}

		public bool HasDefault
		{
			get
			{
				return attributes.GetAttributes(4096);
			}
			set
			{
				attributes = attributes.SetAttributes(4096, value);
			}
		}

		public bool HasFieldMarshal
		{
			get
			{
				return attributes.GetAttributes(8192);
			}
			set
			{
				attributes = attributes.SetAttributes(8192, value);
			}
		}

		internal ParameterDefinition(TypeReference parameterType, IMethodSignature method)
			: this(string.Empty, ParameterAttributes.None, parameterType)
		{
			this.method = method;
		}

		public ParameterDefinition(TypeReference parameterType)
			: this(string.Empty, ParameterAttributes.None, parameterType)
		{
		}

		public ParameterDefinition(string name, ParameterAttributes attributes, TypeReference parameterType)
			: base(name, parameterType)
		{
			this.attributes = (ushort)attributes;
			token = new MetadataToken(TokenType.Param);
		}

		public override ParameterDefinition Resolve()
		{
			return this;
		}
	}
	public abstract class ParameterReference : IMetadataTokenProvider
	{
		private string name;

		internal int index = -1;

		protected TypeReference parameter_type;

		internal MetadataToken token;

		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public int Index => index;

		public TypeReference ParameterType
		{
			get
			{
				return parameter_type;
			}
			set
			{
				parameter_type = value;
			}
		}

		public MetadataToken MetadataToken
		{
			get
			{
				return token;
			}
			set
			{
				token = value;
			}
		}

		internal ParameterReference(string name, TypeReference parameterType)
		{
			if (parameterType == null)
			{
				throw new ArgumentNullException("parameterType");
			}
			this.name = name ?? string.Empty;
			parameter_type = parameterType;
		}

		public override string ToString()
		{
			return name;
		}

		public abstract ParameterDefinition Resolve();
	}
	[Flags]
	public enum PInvokeAttributes : ushort
	{
		NoMangle = 1,
		CharSetMask = 6,
		CharSetNotSpec = 0,
		CharSetAnsi = 2,
		CharSetUnicode = 4,
		CharSetAuto = 6,
		SupportsLastError = 0x40,
		CallConvMask = 0x700,
		CallConvWinapi = 0x100,
		CallConvCdecl = 0x200,
		CallConvStdCall = 0x300,
		CallConvThiscall = 0x400,
		CallConvFastcall = 0x500,
		BestFitMask = 0x30,
		BestFitEnabled = 0x10,
		BestFitDisabled = 0x20,
		ThrowOnUnmappableCharMask = 0x3000,
		ThrowOnUnmappableCharEnabled = 0x1000,
		ThrowOnUnmappableCharDisabled = 0x2000
	}
	public sealed class PInvokeInfo
	{
		private ushort attributes;

		private string entry_point;

		private ModuleReference module;

		public PInvokeAttributes Attributes
		{
			get
			{
				return (PInvokeAttributes)attributes;
			}
			set
			{
				attributes = (ushort)value;
			}
		}

		public string EntryPoint
		{
			get
			{
				return entry_point;
			}
			set
			{
				entry_point = value;
			}
		}

		public ModuleReference Module
		{
			get
			{
				return module;
			}
			set
			{
				module = value;
			}
		}

		public bool IsNoMangle
		{
			get
			{
				return attributes.GetAttributes(1);
			}
			set
			{
				attributes = attributes.SetAttributes(1, value);
			}
		}

		public bool IsCharSetNotSpec
		{
			get
			{
				return attributes.GetMaskedAttributes(6, 0u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(6, 0u, value);
			}
		}

		public bool IsCharSetAnsi
		{
			get
			{
				return attributes.GetMaskedAttributes(6, 2u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(6, 2u, value);
			}
		}

		public bool IsCharSetUnicode
		{
			get
			{
				return attributes.GetMaskedAttributes(6, 4u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(6, 4u, value);
			}
		}

		public bool IsCharSetAuto
		{
			get
			{
				return attributes.GetMaskedAttributes(6, 6u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(6, 6u, value);
			}
		}

		public bool SupportsLastError
		{
			get
			{
				return attributes.GetAttributes(64);
			}
			set
			{
				attributes = attributes.SetAttributes(64, value);
			}
		}

		public bool IsCallConvWinapi
		{
			get
			{
				return attributes.GetMaskedAttributes(1792, 256u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(1792, 256u, value);
			}
		}

		public bool IsCallConvCdecl
		{
			get
			{
				return attributes.GetMaskedAttributes(1792, 512u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(1792, 512u, value);
			}
		}

		public bool IsCallConvStdCall
		{
			get
			{
				return attributes.GetMaskedAttributes(1792, 768u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(1792, 768u, value);
			}
		}

		public bool IsCallConvThiscall
		{
			get
			{
				return attributes.GetMaskedAttributes(1792, 1024u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(1792, 1024u, value);
			}
		}

		public bool IsCallConvFastcall
		{
			get
			{
				return attributes.GetMaskedAttributes(1792, 1280u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(1792, 1280u, value);
			}
		}

		public bool IsBestFitEnabled
		{
			get
			{
				return attributes.GetMaskedAttributes(48, 16u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(48, 16u, value);
			}
		}

		public bool IsBestFitDisabled
		{
			get
			{
				return attributes.GetMaskedAttributes(48, 32u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(48, 32u, value);
			}
		}

		public bool IsThrowOnUnmappableCharEnabled
		{
			get
			{
				return attributes.GetMaskedAttributes(12288, 4096u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(12288, 4096u, value);
			}
		}

		public bool IsThrowOnUnmappableCharDisabled
		{
			get
			{
				return attributes.GetMaskedAttributes(12288, 8192u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(12288, 8192u, value);
			}
		}

		public PInvokeInfo(PInvokeAttributes attributes, string entryPoint, ModuleReference module)
		{
			this.attributes = (ushort)attributes;
			entry_point = entryPoint;
			this.module = module;
		}
	}
	public sealed class PointerType : TypeSpecification
	{
		public override string Name => base.Name + "*";

		public override string FullName => base.FullName + "*";

		public override bool IsValueType
		{
			get
			{
				return false;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override bool IsPointer => true;

		public PointerType(TypeReference type)
			: base(type)
		{
			Mixin.CheckType(type);
			etype = Mono.Cecil.Metadata.ElementType.Ptr;
		}
	}
	[Flags]
	public enum PropertyAttributes : ushort
	{
		None = 0,
		SpecialName = 0x200,
		RTSpecialName = 0x400,
		HasDefault = 0x1000,
		Unused = 0xE9FF
	}
	public sealed class PropertyDefinition : PropertyReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider, IConstantProvider
	{
		private bool? has_this;

		private ushort attributes;

		private Mono.Collections.Generic.Collection<CustomAttribute> custom_attributes;

		internal MethodDefinition get_method;

		internal MethodDefinition set_method;

		internal Mono.Collections.Generic.Collection<MethodDefinition> other_methods;

		private object constant = Mixin.NotResolved;

		public PropertyAttributes Attributes
		{
			get
			{
				return (PropertyAttributes)attributes;
			}
			set
			{
				attributes = (ushort)value;
			}
		}

		public bool HasThis
		{
			get
			{
				if (has_this.HasValue)
				{
					return has_this.Value;
				}
				if (GetMethod != null)
				{
					return get_method.HasThis;
				}
				if (SetMethod != null)
				{
					return set_method.HasThis;
				}
				return false;
			}
			set
			{
				has_this = value;
			}
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
				{
					return custom_attributes.Count > 0;
				}
				return this.GetHasCustomAttributes(Module);
			}
		}

		public Mono.Collections.Generic.Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

		public MethodDefinition GetMethod
		{
			get
			{
				if (get_method != null)
				{
					return get_method;
				}
				InitializeMethods();
				return get_method;
			}
			set
			{
				get_method = value;
			}
		}

		public MethodDefinition SetMethod
		{
			get
			{
				if (set_method != null)
				{
					return set_method;
				}
				InitializeMethods();
				return set_method;
			}
			set
			{
				set_method = value;
			}
		}

		public bool HasOtherMethods
		{
			get
			{
				if (other_methods != null)
				{
					return other_methods.Count > 0;
				}
				InitializeMethods();
				return !other_methods.IsNullOrEmpty();
			}
		}

		public Mono.Collections.Generic.Collection<MethodDefinition> OtherMethods
		{
			get
			{
				if (other_methods != null)
				{
					return other_methods;
				}
				InitializeMethods();
				if (other_methods != null)
				{
					return other_methods;
				}
				return other_methods = new Mono.Collections.Generic.Collection<MethodDefinition>();
			}
		}

		public bool HasParameters
		{
			get
			{
				InitializeMethods();
				if (get_method != null)
				{
					return get_method.HasParameters;
				}
				if (set_method != null)
				{
					if (set_method.HasParameters)
					{
						return set_method.Parameters.Count > 1;
					}
					return false;
				}
				return false;
			}
		}

		public override Mono.Collections.Generic.Collection<ParameterDefinition> Parameters
		{
			get
			{
				InitializeMethods();
				if (get_method != null)
				{
					return MirrorParameters(get_method, 0);
				}
				if (set_method != null)
				{
					return MirrorParameters(set_method, 1);
				}
				return new Mono.Collections.Generic.Collection<ParameterDefinition>();
			}
		}

		public bool HasConstant
		{
			get
			{
				this.ResolveConstant(ref constant, Module);
				return constant != Mixin.NoValue;
			}
			set
			{
				if (!value)
				{
					constant = Mixin.NoValue;
				}
			}
		}

		public object Constant
		{
			get
			{
				if (!HasConstant)
				{
					return null;
				}
				return constant;
			}
			set
			{
				constant = value;
			}
		}

		public bool IsSpecialName
		{
			get
			{
				return attributes.GetAttributes(512);
			}
			set
			{
				attributes = attributes.SetAttributes(512, value);
			}
		}

		public bool IsRuntimeSpecialName
		{
			get
			{
				return attributes.GetAttributes(1024);
			}
			set
			{
				attributes = attributes.SetAttributes(1024, value);
			}
		}

		public bool HasDefault
		{
			get
			{
				return attributes.GetAttributes(4096);
			}
			set
			{
				attributes = attributes.SetAttributes(4096, value);
			}
		}

		public new TypeDefinition DeclaringType
		{
			get
			{
				return (TypeDefinition)base.DeclaringType;
			}
			set
			{
				base.DeclaringType = value;
			}
		}

		public override bool IsDefinition => true;

		public override string FullName
		{
			get
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(base.PropertyType.ToString());
				stringBuilder.Append(' ');
				stringBuilder.Append(MemberFullName());
				stringBuilder.Append('(');
				if (HasParameters)
				{
					Mono.Collections.Generic.Collection<ParameterDefinition> parameters = Parameters;
					for (int i = 0; i < parameters.Count; i++)
					{
						if (i > 0)
						{
							stringBuilder.Append(',');
						}
						stringBuilder.Append(parameters[i].ParameterType.FullName);
					}
				}
				stringBuilder.Append(')');
				return stringBuilder.ToString();
			}
		}

		private static Mono.Collections.Generic.Collection<ParameterDefinition> MirrorParameters(MethodDefinition method, int bound)
		{
			Mono.Collections.Generic.Collection<ParameterDefinition> collection = new Mono.Collections.Generic.Collection<ParameterDefinition>();
			if (!method.HasParameters)
			{
				return collection;
			}
			Mono.Collections.Generic.Collection<ParameterDefinition> parameters = method.Parameters;
			int num = parameters.Count - bound;
			for (int i = 0; i < num; i++)
			{
				collection.Add(parameters[i]);
			}
			return collection;
		}

		public PropertyDefinition(string name, PropertyAttributes attributes, TypeReference propertyType)
			: base(name, propertyType)
		{
			this.attributes = (ushort)attributes;
			token = new MetadataToken(TokenType.Property);
		}

		private void InitializeMethods()
		{
			ModuleDefinition module = Module;
			if (module == null)
			{
				return;
			}
			lock (module.SyncRoot)
			{
				if (get_method == null && set_method == null && module.HasImage())
				{
					module.Read(this, (PropertyDefinition property, MetadataReader reader) => reader.ReadMethods(property));
				}
			}
		}

		public override PropertyDefinition Resolve()
		{
			return this;
		}
	}
	public abstract class PropertyReference : MemberReference
	{
		private TypeReference property_type;

		public TypeReference PropertyType
		{
			get
			{
				return property_type;
			}
			set
			{
				property_type = value;
			}
		}

		public abstract Mono.Collections.Generic.Collection<ParameterDefinition> Parameters { get; }

		internal PropertyReference(string name, TypeReference propertyType)
			: base(name)
		{
			if (propertyType == null)
			{
				throw new ArgumentNullException("propertyType");
			}
			property_type = propertyType;
		}

		public abstract PropertyDefinition Resolve();
	}
	public sealed class ByReferenceType : TypeSpecification
	{
		public override string Name => base.Name + "&";

		public override string FullName => base.FullName + "&";

		public override bool IsValueType
		{
			get
			{
				return false;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override bool IsByReference => true;

		public ByReferenceType(TypeReference type)
			: base(type)
		{
			Mixin.CheckType(type);
			etype = Mono.Cecil.Metadata.ElementType.ByRef;
		}
	}
	public enum MetadataScopeType
	{
		AssemblyNameReference,
		ModuleReference,
		ModuleDefinition
	}
	public interface IMetadataScope : IMetadataTokenProvider
	{
		MetadataScopeType MetadataScopeType { get; }

		string Name { get; set; }
	}
	public interface IMetadataTokenProvider
	{
		MetadataToken MetadataToken { get; set; }
	}
	[Flags]
	public enum ManifestResourceAttributes : uint
	{
		VisibilityMask = 7u,
		Public = 1u,
		Private = 2u
	}
	public class ModuleReference : IMetadataScope, IMetadataTokenProvider
	{
		private string name;

		internal MetadataToken token;

		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public virtual MetadataScopeType MetadataScopeType => MetadataScopeType.ModuleReference;

		public MetadataToken MetadataToken
		{
			get
			{
				return token;
			}
			set
			{
				token = value;
			}
		}

		internal ModuleReference()
		{
			token = new MetadataToken(TokenType.ModuleRef);
		}

		public ModuleReference(string name)
			: this()
		{
			this.name = name;
		}

		public override string ToString()
		{
			return name;
		}
	}
	internal class MemberDefinitionCollection<T> : Mono.Collections.Generic.Collection<T> where T : IMemberDefinition
	{
		private TypeDefinition container;

		internal MemberDefinitionCollection(TypeDefinition container)
		{
			this.container = container;
		}

		internal MemberDefinitionCollection(TypeDefinition container, int capacity)
			: base(capacity)
		{
			this.container = container;
		}

		protected override void OnAdd(T item, int index)
		{
			Attach(item);
		}

		protected sealed override void OnSet(T item, int index)
		{
			Attach(item);
		}

		protected sealed override void OnInsert(T item, int index)
		{
			Attach(item);
		}

		protected sealed override void OnRemove(T item, int index)
		{
			Detach(item);
		}

		protected sealed override void OnClear()
		{
			using Enumerator enumerator = GetEnumerator();
			while (enumerator.MoveNext())
			{
				Detach(enumerator.Current);
			}
		}

		private void Attach(T element)
		{
			if (element.DeclaringType != container)
			{
				if (element.DeclaringType != null)
				{
					throw new ArgumentException("Member already attached");
				}
				TypeDefinition declaringType = container;
				element.DeclaringType = declaringType;
			}
		}

		private static void Detach(T element)
		{
			element.DeclaringType = null;
		}
	}
	public enum ReadingMode
	{
		Immediate = 1,
		Deferred
	}
	public sealed class ReaderParameters
	{
		private ReadingMode reading_mode;

		private IAssemblyResolver assembly_resolver;

		private IMetadataResolver metadata_resolver;

		private Stream symbol_stream;

		private ISymbolReaderProvider symbol_reader_provider;

		private bool read_symbols;

		public ReadingMode ReadingMode
		{
			get
			{
				return reading_mode;
			}
			set
			{
				reading_mode = value;
			}
		}

		public IAssemblyResolver AssemblyResolver
		{
			get
			{
				return assembly_resolver;
			}
			set
			{
				assembly_resolver = value;
			}
		}

		public IMetadataResolver MetadataResolver
		{
			get
			{
				return metadata_resolver;
			}
			set
			{
				metadata_resolver = value;
			}
		}

		public Stream SymbolStream
		{
			get
			{
				return symbol_stream;
			}
			set
			{
				symbol_stream = value;
			}
		}

		public ISymbolReaderProvider SymbolReaderProvider
		{
			get
			{
				return symbol_reader_provider;
			}
			set
			{
				symbol_reader_provider = value;
			}
		}

		public bool ReadSymbols
		{
			get
			{
				return read_symbols;
			}
			set
			{
				read_symbols = value;
			}
		}

		public ReaderParameters()
			: this(ReadingMode.Deferred)
		{
		}

		public ReaderParameters(ReadingMode readingMode)
		{
			reading_mode = readingMode;
		}
	}
	public sealed class ModuleParameters
	{
		private ModuleKind kind;

		private TargetRuntime runtime;

		private TargetArchitecture architecture;

		private IAssemblyResolver assembly_resolver;

		private IMetadataResolver metadata_resolver;

		public ModuleKind Kind
		{
			get
			{
				return kind;
			}
			set
			{
				kind = value;
			}
		}

		public TargetRuntime Runtime
		{
			get
			{
				return runtime;
			}
			set
			{
				runtime = value;
			}
		}

		public TargetArchitecture Architecture
		{
			get
			{
				return architecture;
			}
			set
			{
				architecture = value;
			}
		}

		public IAssemblyResolver AssemblyResolver
		{
			get
			{
				return assembly_resolver;
			}
			set
			{
				assembly_resolver = value;
			}
		}

		public IMetadataResolver MetadataResolver
		{
			get
			{
				return metadata_resolver;
			}
			set
			{
				metadata_resolver = value;
			}
		}

		public ModuleParameters()
		{
			kind = ModuleKind.Dll;
			Runtime = GetCurrentRuntime();
			architecture = TargetArchitecture.I386;
		}

		private static TargetRuntime GetCurrentRuntime()
		{
			return typeof(object).Assembly.ImageRuntimeVersion.ParseRuntime();
		}
	}
	public sealed class WriterParameters
	{
		private Stream symbol_stream;

		private ISymbolWriterProvider symbol_writer_provider;

		private bool write_symbols;

		private StrongNameKeyPair key_pair;

		public Stream SymbolStream
		{
			get
			{
				return symbol_stream;
			}
			set
			{
				symbol_stream = value;
			}
		}

		public ISymbolWriterProvider SymbolWriterProvider
		{
			get
			{
				return symbol_writer_provider;
			}
			set
			{
				symbol_writer_provider = value;
			}
		}

		public bool WriteSymbols
		{
			get
			{
				return write_symbols;
			}
			set
			{
				write_symbols = value;
			}
		}

		public StrongNameKeyPair StrongNameKeyPair
		{
			get
			{
				return key_pair;
			}
			set
			{
				key_pair = value;
			}
		}
	}
	public sealed class ModuleDefinition : ModuleReference, ICustomAttributeProvider, IMetadataTokenProvider
	{
		internal Image Image;

		internal MetadataSystem MetadataSystem;

		internal ReadingMode ReadingMode;

		internal ISymbolReaderProvider SymbolReaderProvider;

		internal ISymbolReader symbol_reader;

		internal IAssemblyResolver assembly_resolver;

		internal IMetadataResolver metadata_resolver;

		internal TypeSystem type_system;

		private readonly MetadataReader reader;

		private readonly string fq_name;

		internal string runtime_version;

		internal ModuleKind kind;

		private TargetRuntime runtime;

		private TargetArchitecture architecture;

		private ModuleAttributes attributes;

		private ModuleCharacteristics characteristics;

		private Guid mvid;

		internal AssemblyDefinition assembly;

		private MethodDefinition entry_point;

		private MetadataImporter importer;

		private Mono.Collections.Generic.Collection<CustomAttribute> custom_attributes;

		private Mono.Collections.Generic.Collection<AssemblyNameReference> references;

		private Mono.Collections.Generic.Collection<ModuleReference> modules;

		private Mono.Collections.Generic.Collection<Resource> resources;

		private Mono.Collections.Generic.Collection<ExportedType> exported_types;

		private TypeDefinitionCollection types;

		private readonly object module_lock = new object();

		public bool IsMain => kind != ModuleKind.NetModule;

		public ModuleKind Kind
		{
			get
			{
				return kind;
			}
			set
			{
				kind = value;
			}
		}

		public TargetRuntime Runtime
		{
			get
			{
				return runtime;
			}
			set
			{
				runtime = value;
				runtime_version = runtime.RuntimeVersionString();
			}
		}

		public string RuntimeVersion
		{
			get
			{
				return runtime_version;
			}
			set
			{
				runtime_version = value;
				runtime = runtime_version.ParseRuntime();
			}
		}

		public TargetArchitecture Architecture
		{
			get
			{
				return architecture;
			}
			set
			{
				architecture = value;
			}
		}

		public ModuleAttributes Attributes
		{
			get
			{
				return attributes;
			}
			set
			{
				attributes = value;
			}
		}

		public ModuleCharacteristics Characteristics
		{
			get
			{
				return characteristics;
			}
			set
			{
				characteristics = value;
			}
		}

		public string FullyQualifiedName => fq_name;

		public Guid Mvid
		{
			get
			{
				return mvid;
			}
			set
			{
				mvid = value;
			}
		}

		internal bool HasImage => Image != null;

		public bool HasSymbols => symbol_reader != null;

		public ISymbolReader SymbolReader => symbol_reader;

		public override MetadataScopeType MetadataScopeType => MetadataScopeType.ModuleDefinition;

		public AssemblyDefinition Assembly => assembly;

		internal MetadataImporter MetadataImporter
		{
			get
			{
				if (importer == null)
				{
					Interlocked.CompareExchange(ref importer, new MetadataImporter(this), null);
				}
				return importer;
			}
		}

		public IAssemblyResolver AssemblyResolver
		{
			get
			{
				if (assembly_resolver == null)
				{
					Interlocked.CompareExchange(ref assembly_resolver, new DefaultAssemblyResolver(), null);
				}
				return assembly_resolver;
			}
		}

		public IMetadataResolver MetadataResolver
		{
			get
			{
				if (metadata_resolver == null)
				{
					Interlocked.CompareExchange(ref metadata_resolver, new MetadataResolver(AssemblyResolver), null);
				}
				return metadata_resolver;
			}
		}

		public TypeSystem TypeSystem
		{
			get
			{
				if (type_system == null)
				{
					Interlocked.CompareExchange(ref type_system, TypeSystem.CreateTypeSystem(this), null);
				}
				return type_system;
			}
		}

		public bool HasAssemblyReferences
		{
			get
			{
				if (references != null)
				{
					return references.Count > 0;
				}
				if (HasImage)
				{
					return Image.HasTable(Table.AssemblyRef);
				}
				return false;
			}
		}

		public Mono.Collections.Generic.Collection<AssemblyNameReference> AssemblyReferences
		{
			get
			{
				if (references != null)
				{
					return references;
				}
				if (HasImage)
				{
					return Read(ref references, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadAssemblyReferences());
				}
				return references = new Mono.Collections.Generic.Collection<AssemblyNameReference>();
			}
		}

		public bool HasModuleReferences
		{
			get
			{
				if (modules != null)
				{
					return modules.Count > 0;
				}
				if (HasImage)
				{
					return Image.HasTable(Table.ModuleRef);
				}
				return false;
			}
		}

		public Mono.Collections.Generic.Collection<ModuleReference> ModuleReferences
		{
			get
			{
				if (modules != null)
				{
					return modules;
				}
				if (HasImage)
				{
					return Read(ref modules, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadModuleReferences());
				}
				return modules = new Mono.Collections.Generic.Collection<ModuleReference>();
			}
		}

		public bool HasResources
		{
			get
			{
				if (resources != null)
				{
					return resources.Count > 0;
				}
				if (HasImage)
				{
					if (!Image.HasTable(Table.ManifestResource))
					{
						return Read(this, (ModuleDefinition _, MetadataReader reader) => reader.HasFileResource());
					}
					return true;
				}
				return false;
			}
		}

		public Mono.Collections.Generic.Collection<Resource> Resources
		{
			get
			{
				if (resources != null)
				{
					return resources;
				}
				if (HasImage)
				{
					return Read(ref resources, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadResources());
				}
				return resources = new Mono.Collections.Generic.Collection<Resource>();
			}
		}

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
				{
					return custom_attributes.Count > 0;
				}
				return this.GetHasCustomAttributes(this);
			}
		}

		public Mono.Collections.Generic.Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, this);

		public bool HasTypes
		{
			get
			{
				if (types != null)
				{
					return types.Count > 0;
				}
				if (HasImage)
				{
					return Image.HasTable(Table.TypeDef);
				}
				return false;
			}
		}

		public Mono.Collections.Generic.Collection<TypeDefinition> Types
		{
			get
			{
				if (types != null)
				{
					return types;
				}
				if (HasImage)
				{
					return Read(ref types, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadTypes());
				}
				return types = new TypeDefinitionCollection(this);
			}
		}

		public bool HasExportedTypes
		{
			get
			{
				if (exported_types != null)
				{
					return exported_types.Count > 0;
				}
				if (HasImage)
				{
					return Image.HasTable(Table.ExportedType);
				}
				return false;
			}
		}

		public Mono.Collections.Generic.Collection<ExportedType> ExportedTypes
		{
			get
			{
				if (exported_types != null)
				{
					return exported_types;
				}
				if (HasImage)
				{
					return Read(ref exported_types, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadExportedTypes());
				}
				return exported_types = new Mono.Collections.Generic.Collection<ExportedType>();
			}
		}

		public MethodDefinition EntryPoint
		{
			get
			{
				if (entry_point != null)
				{
					return entry_point;
				}
				if (HasImage)
				{
					return Read(ref entry_point, this, (ModuleDefinition _, MetadataReader reader) => reader.ReadEntryPoint());
				}
				return entry_point = null;
			}
			set
			{
				entry_point = value;
			}
		}

		internal object SyncRoot => module_lock;

		public bool HasDebugHeader
		{
			get
			{
				if (Image != null)
				{
					return !Image.Debug.IsZero;
				}
				return false;
			}
		}

		internal ModuleDefinition()
		{
			MetadataSystem = new MetadataSystem();
			token = new MetadataToken(TokenType.Module, 1);
		}

		internal ModuleDefinition(Image image)
			: this()
		{
			Image = image;
			kind = image.Kind;
			RuntimeVersion = image.RuntimeVersion;
			architecture = image.Architecture;
			attributes = image.Attributes;
			characteristics = image.Characteristics;
			fq_name = image.FileName;
			reader = new MetadataReader(this);
		}

		public bool HasTypeReference(string fullName)
		{
			return HasTypeReference(string.Empty, fullName);
		}

		public bool HasTypeReference(string scope, string fullName)
		{
			CheckFullName(fullName);
			if (!HasImage)
			{
				return false;
			}
			return GetTypeReference(scope, fullName) != null;
		}

		public bool TryGetTypeReference(string fullName, out TypeReference type)
		{
			return TryGetTypeReference(string.Empty, fullName, out type);
		}

		public bool TryGetTypeReference(string scope, string fullName, out TypeReference type)
		{
			CheckFullName(fullName);
			if (!HasImage)
			{
				type = null;
				return false;
			}
			return (type = GetTypeReference(scope, fullName)) != null;
		}

		private TypeReference GetTypeReference(string scope, string fullname)
		{
			return Read(new Row<string, string>(scope, fullname), (Row<string, string> row, MetadataReader reader) => reader.GetTypeReference(row.Col1, row.Col2));
		}

		public IEnumerable<TypeReference> GetTypeReferences()
		{
			if (!HasImage)
			{
				return Empty<TypeReference>.Array;
			}
			return Read(this, (ModuleDefinition _, MetadataReader reader) => reader.GetTypeReferences());
		}

		public IEnumerable<MemberReference> GetMemberReferences()
		{
			if (!HasImage)
			{
				return Empty<MemberReference>.Array;
			}
			return Read(this, (ModuleDefinition _, MetadataReader reader) => reader.GetMemberReferences());
		}

		public TypeReference GetType(string fullName, bool runtimeName)
		{
			if (!runtimeName)
			{
				return GetType(fullName);
			}
			return TypeParser.ParseType(this, fullName);
		}

		public TypeDefinition GetType(string fullName)
		{
			CheckFullName(fullName);
			if (fullName.IndexOf('/') > 0)
			{
				return GetNestedType(fullName);
			}
			return ((TypeDefinitionCollection)Types).GetType(fullName);
		}

		public TypeDefinition GetType(string @namespace, string name)
		{
			Mixin.CheckName(name);
			return ((TypeDefinitionCollection)Types).GetType(@namespace ?? string.Empty, name);
		}

		public IEnumerable<TypeDefinition> GetTypes()
		{
			return GetTypes(Types);
		}

		private static IEnumerable<TypeDefinition> GetTypes(Mono.Collections.Generic.Collection<TypeDefinition> types)
		{
			for (int i = 0; i < types.Count; i++)
			{
				TypeDefinition type = types[i];
				yield return type;
				if (!type.HasNestedTypes)
				{
					continue;
				}
				foreach (TypeDefinition type2 in GetTypes(type.NestedTypes))
				{
					yield return type2;
				}
			}
		}

		private static void CheckFullName(string fullName)
		{
			if (fullName == null)
			{
				throw new ArgumentNullException("fullName");
			}
			if (fullName.Length == 0)
			{
				throw new ArgumentException();
			}
		}

		private TypeDefinition GetNestedType(string fullname)
		{
			string[] array = fullname.Split(new char[1] { '/' });
			TypeDefinition typeDefinition = GetType(array[0]);
			if (typeDefinition == null)
			{
				return null;
			}
			for (int i = 1; i < array.Length; i++)
			{
				TypeDefinition nestedType = typeDefinition.GetNestedType(array[i]);
				if (nestedType == null)
				{
					return null;
				}
				typeDefinition = nestedType;
			}
			return typeDefinition;
		}

		internal FieldDefinition Resolve(FieldReference field)
		{
			return MetadataResolver.Resolve(field);
		}

		internal MethodDefinition Resolve(MethodReference method)
		{
			return MetadataResolver.Resolve(method);
		}

		internal TypeDefinition Resolve(TypeReference type)
		{
			return MetadataResolver.Resolve(type);
		}

		private static void CheckType(object type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
		}

		private static void CheckField(object field)
		{
			if (field == null)
			{
				throw new ArgumentNullException("field");
			}
		}

		private static void CheckMethod(object method)
		{
			if (method == null)
			{
				throw new ArgumentNullException("method");
			}
		}

		private static void CheckContext(IGenericParameterProvider context, ModuleDefinition module)
		{
			if (context == null || context.Module == module)
			{
				return;
			}
			throw new ArgumentException();
		}

		private static ImportGenericContext GenericContextFor(IGenericParameterProvider context)
		{
			if (context == null)
			{
				return default(ImportGenericContext);
			}
			return new ImportGenericContext(context);
		}

		public TypeReference Import(Type type)
		{
			return Import(type, null);
		}

		public TypeReference Import(Type type, IGenericParameterProvider context)
		{
			CheckType(type);
			CheckContext(context, this);
			return MetadataImporter.ImportType(type, GenericContextFor(context), (context != null) ? ImportGenericKind.Open : ImportGenericKind.Definition);
		}

		public FieldReference Import(FieldInfo field)
		{
			return Import(field, null);
		}

		public FieldReference Import(FieldInfo field, IGenericParameterProvider context)
		{
			CheckField(field);
			CheckContext(context, this);
			return MetadataImporter.ImportField(field, GenericContextFor(context));
		}

		public MethodReference Import(MethodBase method)
		{
			CheckMethod(method);
			return MetadataImporter.ImportMethod(method, default(ImportGenericContext), ImportGenericKind.Definition);
		}

		public MethodReference Import(MethodBase method, IGenericParameterProvider context)
		{
			CheckMethod(method);
			CheckContext(context, this);
			return MetadataImporter.ImportMethod(method, GenericContextFor(context), (context != null) ? ImportGenericKind.Open : ImportGenericKind.Definition);
		}

		public TypeReference Import(TypeReference type)
		{
			CheckType(type);
			if (type.Module == this)
			{
				return type;
			}
			return MetadataImporter.ImportType(type, default(ImportGenericContext));
		}

		public TypeReference Import(TypeReference type, IGenericParameterProvider context)
		{
			CheckType(type);
			if (type.Module == this)
			{
				return type;
			}
			CheckContext(context, this);
			return MetadataImporter.ImportType(type, GenericContextFor(context));
		}

		public FieldReference Import(FieldReference field)
		{
			CheckField(field);
			if (field.Module == this)
			{
				return field;
			}
			return MetadataImporter.ImportField(field, default(ImportGenericContext));
		}

		public FieldReference Import(FieldReference field, IGenericParameterProvider context)
		{
			CheckField(field);
			if (field.Module == this)
			{
				return field;
			}
			CheckContext(context, this);
			return MetadataImporter.ImportField(field, GenericContextFor(context));
		}

		public MethodReference Import(MethodReference method)
		{
			return Import(method, null);
		}

		public MethodReference Import(MethodReference method, IGenericParameterProvider context)
		{
			CheckMethod(method);
			if (method.Module == this)
			{
				return method;
			}
			CheckContext(context, this);
			return MetadataImporter.ImportMethod(method, GenericContextFor(context));
		}

		public IMetadataTokenProvider LookupToken(int token)
		{
			return LookupToken(new MetadataToken((uint)token));
		}

		public IMetadataTokenProvider LookupToken(MetadataToken token)
		{
			return Read(token, (MetadataToken t, MetadataReader reader) => reader.LookupToken(t));
		}

		internal TRet Read<TItem, TRet>(TItem item, Func<TItem, MetadataReader, TRet> read)
		{
			lock (module_lock)
			{
				int position = reader.position;
				IGenericContext context = reader.context;
				TRet result = read(item, reader);
				reader.position = position;
				reader.context = context;
				return result;
			}
		}

		internal TRet Read<TItem, TRet>(ref TRet variable, TItem item, Func<TItem, MetadataReader, TRet> read) where TRet : class
		{
			lock (module_lock)
			{
				if (variable != null)
				{
					return variable;
				}
				int position = reader.position;
				IGenericContext context = reader.context;
				TRet val = read(item, reader);
				reader.position = position;
				reader.context = context;
				return variable = val;
			}
		}

		public ImageDebugDirectory GetDebugHeader(out byte[] header)
		{
			if (!HasDebugHeader)
			{
				throw new InvalidOperationException();
			}
			return Image.GetDebugHeader(out header);
		}

		private void ProcessDebugHeader()
		{
			if (HasDebugHeader)
			{
				byte[] header;
				ImageDebugDirectory debugHeader = GetDebugHeader(out header);
				if (!symbol_reader.ProcessDebugHeader(debugHeader, header))
				{
					throw new InvalidOperationException();
				}
			}
		}

		public static ModuleDefinition CreateModule(string name, ModuleKind kind)
		{
			return CreateModule(name, new ModuleParameters
			{
				Kind = kind
			});
		}

		public static ModuleDefinition CreateModule(string name, ModuleParameters parameters)
		{
			Mixin.CheckName(name);
			Mixin.CheckParameters(parameters);
			ModuleDefinition moduleDefinition = new ModuleDefinition
			{
				Name = name,
				kind = parameters.Kind,
				Runtime = parameters.Runtime,
				architecture = parameters.Architecture,
				mvid = Guid.NewGuid(),
				Attributes = ModuleAttributes.ILOnly,
				Characteristics = (ModuleCharacteristics.DynamicBase | ModuleCharacteristics.NoSEH | ModuleCharacteristics.NXCompat | ModuleCharacteristics.TerminalServerAware)
			};
			if (parameters.AssemblyResolver != null)
			{
				moduleDefinition.assembly_resolver = parameters.AssemblyResolver;
			}
			if (parameters.MetadataResolver != null)
			{
				moduleDefinition.metadata_resolver = parameters.MetadataResolver;
			}
			if (parameters.Kind != ModuleKind.NetModule)
			{
				AssemblyDefinition assemblyDefinition = (moduleDefinition.assembly = new AssemblyDefinition());
				moduleDefinition.assembly.Name = CreateAssemblyName(name);
				assemblyDefinition.main_module = moduleDefinition;
			}
			moduleDefinition.Types.Add(new TypeDefinition(string.Empty, "<Module>", TypeAttributes.NotPublic));
			return moduleDefinition;
		}

		private static AssemblyNameDefinition CreateAssemblyName(string name)
		{
			if (name.EndsWith(".dll") || name.EndsWith(".exe"))
			{
				name = name.Substring(0, name.Length - 4);
			}
			return new AssemblyNameDefinition(name, new Version(0, 0, 0, 0));
		}

		public void ReadSymbols()
		{
			if (string.IsNullOrEmpty(fq_name))
			{
				throw new InvalidOperationException();
			}
			ISymbolReaderProvider platformReaderProvider = SymbolProvider.GetPlatformReaderProvider();
			if (platformReaderProvider == null)
			{
				throw new InvalidOperationException();
			}
			ReadSymbols(platformReaderProvider.GetSymbolReader(this, fq_name));
		}

		public void ReadSymbols(ISymbolReader reader)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			symbol_reader = reader;
			ProcessDebugHeader();
		}

		public static ModuleDefinition ReadModule(string fileName)
		{
			return ReadModule(fileName, new ReaderParameters(ReadingMode.Deferred));
		}

		public static ModuleDefinition ReadModule(Stream stream)
		{
			return ReadModule(stream, new ReaderParameters(ReadingMode.Deferred));
		}

		public static ModuleDefinition ReadModule(string fileName, ReaderParameters parameters)
		{
			using Stream stream = GetFileStream(fileName, System.IO.FileMode.Open, FileAccess.Read, FileShare.Read);
			return ReadModule(stream, parameters);
		}

		private static void CheckStream(object stream)
		{
			if (stream == null)
			{
				throw new ArgumentNullException("stream");
			}
		}

		public static ModuleDefinition ReadModule(Stream stream, ReaderParameters parameters)
		{
			CheckStream(stream);
			if (!stream.CanRead || !stream.CanSeek)
			{
				throw new ArgumentException();
			}
			Mixin.CheckParameters(parameters);
			return ModuleReader.CreateModuleFrom(ImageReader.ReadImageFrom(stream), parameters);
		}

		private static Stream GetFileStream(string fileName, System.IO.FileMode mode, FileAccess access, FileShare share)
		{
			if (fileName == null)
			{
				throw new ArgumentNullException("fileName");
			}
			if (fileName.Length == 0)
			{
				throw new ArgumentException();
			}
			return new FileStream(fileName, mode, access, share);
		}

		public void Write(string fileName)
		{
			Write(fileName, new WriterParameters());
		}

		public void Write(Stream stream)
		{
			Write(stream, new WriterParameters());
		}

		public void Write(string fileName, WriterParameters parameters)
		{
			using Stream stream = GetFileStream(fileName, System.IO.FileMode.Create, FileAccess.ReadWrite, FileShare.None);
			Write(stream, parameters);
		}

		public void Write(Stream stream, WriterParameters parameters)
		{
			CheckStream(stream);
			if (!stream.CanWrite || !stream.CanSeek)
			{
				throw new ArgumentException();
			}
			Mixin.CheckParameters(parameters);
			ModuleWriter.WriteModuleTo(this, stream, parameters);
		}
	}
	public enum ModuleKind
	{
		Dll,
		Console,
		Windows,
		NetModule
	}
	public enum TargetArchitecture
	{
		I386,
		AMD64,
		IA64,
		ARMv7
	}
	[Flags]
	public enum ModuleAttributes
	{
		ILOnly = 1,
		Required32Bit = 2,
		StrongNameSigned = 8,
		Preferred32Bit = 0x20000
	}
	[Flags]
	public enum ModuleCharacteristics
	{
		HighEntropyVA = 0x20,
		DynamicBase = 0x40,
		NoSEH = 0x400,
		NXCompat = 0x100,
		AppContainer = 0x1000,
		TerminalServerAware = 0x8000
	}
	public enum ResourceType
	{
		Linked,
		Embedded,
		AssemblyLinked
	}
	public abstract class Resource
	{
		private string name;

		private uint attributes;

		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public ManifestResourceAttributes Attributes
		{
			get
			{
				return (ManifestResourceAttributes)attributes;
			}
			set
			{
				attributes = (uint)value;
			}
		}

		public abstract ResourceType ResourceType { get; }

		public bool IsPublic
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 1u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 1u, value);
			}
		}

		public bool IsPrivate
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 2u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 2u, value);
			}
		}

		internal Resource(string name, ManifestResourceAttributes attributes)
		{
			this.name = name;
			this.attributes = (uint)attributes;
		}
	}
	public sealed class SentinelType : TypeSpecification
	{
		public override bool IsValueType
		{
			get
			{
				return false;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override bool IsSentinel => true;

		public SentinelType(TypeReference type)
			: base(type)
		{
			Mixin.CheckType(type);
			etype = Mono.Cecil.Metadata.ElementType.Sentinel;
		}
	}
	public enum TargetRuntime
	{
		Net_1_0,
		Net_1_1,
		Net_2_0,
		Net_4_0
	}
	[Flags]
	public enum TypeAttributes : uint
	{
		VisibilityMask = 7u,
		NotPublic = 0u,
		Public = 1u,
		NestedPublic = 2u,
		NestedPrivate = 3u,
		NestedFamily = 4u,
		NestedAssembly = 5u,
		NestedFamANDAssem = 6u,
		NestedFamORAssem = 7u,
		LayoutMask = 0x18u,
		AutoLayout = 0u,
		SequentialLayout = 8u,
		ExplicitLayout = 0x10u,
		ClassSemanticMask = 0x20u,
		Class = 0u,
		Interface = 0x20u,
		Abstract = 0x80u,
		Sealed = 0x100u,
		SpecialName = 0x400u,
		Import = 0x1000u,
		Serializable = 0x2000u,
		WindowsRuntime = 0x4000u,
		StringFormatMask = 0x30000u,
		AnsiClass = 0u,
		UnicodeClass = 0x10000u,
		AutoClass = 0x20000u,
		BeforeFieldInit = 0x100000u,
		RTSpecialName = 0x800u,
		HasSecurity = 0x40000u,
		Forwarder = 0x200000u
	}
	public sealed class TypeDefinition : TypeReference, IMemberDefinition, ICustomAttributeProvider, IMetadataTokenProvider, ISecurityDeclarationProvider
	{
		private uint attributes;

		private TypeReference base_type;

		internal Range fields_range;

		internal Range methods_range;

		private short packing_size = -2;

		private int class_size = -2;

		private Mono.Collections.Generic.Collection<TypeReference> interfaces;

		private Mono.Collections.Generic.Collection<TypeDefinition> nested_types;

		private Mono.Collections.Generic.Collection<MethodDefinition> methods;

		private Mono.Collections.Generic.Collection<FieldDefinition> fields;

		private Mono.Collections.Generic.Collection<EventDefinition> events;

		private Mono.Collections.Generic.Collection<PropertyDefinition> properties;

		private Mono.Collections.Generic.Collection<CustomAttribute> custom_attributes;

		private Mono.Collections.Generic.Collection<SecurityDeclaration> security_declarations;

		public TypeAttributes Attributes
		{
			get
			{
				return (TypeAttributes)attributes;
			}
			set
			{
				attributes = (uint)value;
			}
		}

		public TypeReference BaseType
		{
			get
			{
				return base_type;
			}
			set
			{
				base_type = value;
			}
		}

		public bool HasLayoutInfo
		{
			get
			{
				if (packing_size >= 0 || class_size >= 0)
				{
					return true;
				}
				ResolveLayout();
				if (packing_size < 0)
				{
					return class_size >= 0;
				}
				return true;
			}
		}

		public short PackingSize
		{
			get
			{
				if (packing_size >= 0)
				{
					return packing_size;
				}
				ResolveLayout();
				if (packing_size < 0)
				{
					return -1;
				}
				return packing_size;
			}
			set
			{
				packing_size = value;
			}
		}

		public int ClassSize
		{
			get
			{
				if (class_size >= 0)
				{
					return class_size;
				}
				ResolveLayout();
				if (class_size < 0)
				{
					return -1;
				}
				return class_size;
			}
			set
			{
				class_size = value;
			}
		}

		public bool HasInterfaces
		{
			get
			{
				if (interfaces != null)
				{
					return interfaces.Count > 0;
				}
				if (base.HasImage)
				{
					return Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.HasInterfaces(type));
				}
				return false;
			}
		}

		public Mono.Collections.Generic.Collection<TypeReference> Interfaces
		{
			get
			{
				if (interfaces != null)
				{
					return interfaces;
				}
				if (base.HasImage)
				{
					return Module.Read(ref interfaces, this, (TypeDefinition type, MetadataReader reader) => reader.ReadInterfaces(type));
				}
				return interfaces = new Mono.Collections.Generic.Collection<TypeReference>();
			}
		}

		public bool HasNestedTypes
		{
			get
			{
				if (nested_types != null)
				{
					return nested_types.Count > 0;
				}
				if (base.HasImage)
				{
					return Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.HasNestedTypes(type));
				}
				return false;
			}
		}

		public Mono.Collections.Generic.Collection<TypeDefinition> NestedTypes
		{
			get
			{
				if (nested_types != null)
				{
					return nested_types;
				}
				if (base.HasImage)
				{
					return Module.Read(ref nested_types, this, (TypeDefinition type, MetadataReader reader) => reader.ReadNestedTypes(type));
				}
				return nested_types = new MemberDefinitionCollection<TypeDefinition>(this);
			}
		}

		public bool HasMethods
		{
			get
			{
				if (methods != null)
				{
					return methods.Count > 0;
				}
				if (base.HasImage)
				{
					return methods_range.Length != 0;
				}
				return false;
			}
		}

		public Mono.Collections.Generic.Collection<MethodDefinition> Methods
		{
			get
			{
				if (methods != null)
				{
					return methods;
				}
				if (base.HasImage)
				{
					return Module.Read(ref methods, this, (TypeDefinition type, MetadataReader reader) => reader.ReadMethods(type));
				}
				return methods = new MemberDefinitionCollection<MethodDefinition>(this);
			}
		}

		public bool HasFields
		{
			get
			{
				if (fields != null)
				{
					return fields.Count > 0;
				}
				if (base.HasImage)
				{
					return fields_range.Length != 0;
				}
				return false;
			}
		}

		public Mono.Collections.Generic.Collection<FieldDefinition> Fields
		{
			get
			{
				if (fields != null)
				{
					return fields;
				}
				if (base.HasImage)
				{
					return Module.Read(ref fields, this, (TypeDefinition type, MetadataReader reader) => reader.ReadFields(type));
				}
				return fields = new MemberDefinitionCollection<FieldDefinition>(this);
			}
		}

		public bool HasEvents
		{
			get
			{
				if (events != null)
				{
					return events.Count > 0;
				}
				if (base.HasImage)
				{
					return Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.HasEvents(type));
				}
				return false;
			}
		}

		public Mono.Collections.Generic.Collection<EventDefinition> Events
		{
			get
			{
				if (events != null)
				{
					return events;
				}
				if (base.HasImage)
				{
					return Module.Read(ref events, this, (TypeDefinition type, MetadataReader reader) => reader.ReadEvents(type));
				}
				return events = new MemberDefinitionCollection<EventDefinition>(this);
			}
		}

		public bool HasProperties
		{
			get
			{
				if (properties != null)
				{
					return properties.Count > 0;
				}
				if (base.HasImage)
				{
					return Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.HasProperties(type));
				}
				return false;
			}
		}

		public Mono.Collections.Generic.Collection<PropertyDefinition> Properties
		{
			get
			{
				if (properties != null)
				{
					return properties;
				}
				if (base.HasImage)
				{
					return Module.Read(ref properties, this, (TypeDefinition type, MetadataReader reader) => reader.ReadProperties(type));
				}
				return properties = new MemberDefinitionCollection<PropertyDefinition>(this);
			}
		}

		public bool HasSecurityDeclarations
		{
			get
			{
				if (security_declarations != null)
				{
					return security_declarations.Count > 0;
				}
				return this.GetHasSecurityDeclarations(Module);
			}
		}

		public Mono.Collections.Generic.Collection<SecurityDeclaration> SecurityDeclarations => security_declarations ?? this.GetSecurityDeclarations(ref security_declarations, Module);

		public bool HasCustomAttributes
		{
			get
			{
				if (custom_attributes != null)
				{
					return custom_attributes.Count > 0;
				}
				return this.GetHasCustomAttributes(Module);
			}
		}

		public Mono.Collections.Generic.Collection<CustomAttribute> CustomAttributes => custom_attributes ?? this.GetCustomAttributes(ref custom_attributes, Module);

		public override bool HasGenericParameters
		{
			get
			{
				if (generic_parameters != null)
				{
					return generic_parameters.Count > 0;
				}
				return this.GetHasGenericParameters(Module);
			}
		}

		public override Mono.Collections.Generic.Collection<GenericParameter> GenericParameters => generic_parameters ?? this.GetGenericParameters(ref generic_parameters, Module);

		public bool IsNotPublic
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 0u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 0u, value);
			}
		}

		public bool IsPublic
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 1u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 1u, value);
			}
		}

		public bool IsNestedPublic
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 2u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 2u, value);
			}
		}

		public bool IsNestedPrivate
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 3u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 3u, value);
			}
		}

		public bool IsNestedFamily
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 4u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 4u, value);
			}
		}

		public bool IsNestedAssembly
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 5u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 5u, value);
			}
		}

		public bool IsNestedFamilyAndAssembly
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 6u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 6u, value);
			}
		}

		public bool IsNestedFamilyOrAssembly
		{
			get
			{
				return attributes.GetMaskedAttributes(7u, 7u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(7u, 7u, value);
			}
		}

		public bool IsAutoLayout
		{
			get
			{
				return attributes.GetMaskedAttributes(24u, 0u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(24u, 0u, value);
			}
		}

		public bool IsSequentialLayout
		{
			get
			{
				return attributes.GetMaskedAttributes(24u, 8u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(24u, 8u, value);
			}
		}

		public bool IsExplicitLayout
		{
			get
			{
				return attributes.GetMaskedAttributes(24u, 16u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(24u, 16u, value);
			}
		}

		public bool IsClass
		{
			get
			{
				return attributes.GetMaskedAttributes(32u, 0u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(32u, 0u, value);
			}
		}

		public bool IsInterface
		{
			get
			{
				return attributes.GetMaskedAttributes(32u, 32u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(32u, 32u, value);
			}
		}

		public bool IsAbstract
		{
			get
			{
				return attributes.GetAttributes(128u);
			}
			set
			{
				attributes = attributes.SetAttributes(128u, value);
			}
		}

		public bool IsSealed
		{
			get
			{
				return attributes.GetAttributes(256u);
			}
			set
			{
				attributes = attributes.SetAttributes(256u, value);
			}
		}

		public bool IsSpecialName
		{
			get
			{
				return attributes.GetAttributes(1024u);
			}
			set
			{
				attributes = attributes.SetAttributes(1024u, value);
			}
		}

		public bool IsImport
		{
			get
			{
				return attributes.GetAttributes(4096u);
			}
			set
			{
				attributes = attributes.SetAttributes(4096u, value);
			}
		}

		public bool IsSerializable
		{
			get
			{
				return attributes.GetAttributes(8192u);
			}
			set
			{
				attributes = attributes.SetAttributes(8192u, value);
			}
		}

		public bool IsWindowsRuntime
		{
			get
			{
				return attributes.GetAttributes(16384u);
			}
			set
			{
				attributes = attributes.SetAttributes(16384u, value);
			}
		}

		public bool IsAnsiClass
		{
			get
			{
				return attributes.GetMaskedAttributes(196608u, 0u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(196608u, 0u, value);
			}
		}

		public bool IsUnicodeClass
		{
			get
			{
				return attributes.GetMaskedAttributes(196608u, 65536u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(196608u, 65536u, value);
			}
		}

		public bool IsAutoClass
		{
			get
			{
				return attributes.GetMaskedAttributes(196608u, 131072u);
			}
			set
			{
				attributes = attributes.SetMaskedAttributes(196608u, 131072u, value);
			}
		}

		public bool IsBeforeFieldInit
		{
			get
			{
				return attributes.GetAttributes(1048576u);
			}
			set
			{
				attributes = attributes.SetAttributes(1048576u, value);
			}
		}

		public bool IsRuntimeSpecialName
		{
			get
			{
				return attributes.GetAttributes(2048u);
			}
			set
			{
				attributes = attributes.SetAttributes(2048u, value);
			}
		}

		public bool HasSecurity
		{
			get
			{
				return attributes.GetAttributes(262144u);
			}
			set
			{
				attributes = attributes.SetAttributes(262144u, value);
			}
		}

		public bool IsEnum
		{
			get
			{
				if (base_type != null)
				{
					return base_type.IsTypeOf("System", "Enum");
				}
				return false;
			}
		}

		public override bool IsValueType
		{
			get
			{
				if (base_type == null)
				{
					return false;
				}
				if (!base_type.IsTypeOf("System", "Enum"))
				{
					if (base_type.IsTypeOf("System", "ValueType"))
					{
						return !this.IsTypeOf("System", "Enum");
					}
					return false;
				}
				return true;
			}
		}

		public override bool IsPrimitive
		{
			get
			{
				ElementType elementType;
				return MetadataSystem.TryGetPrimitiveElementType(this, out elementType);
			}
		}

		public override MetadataType MetadataType
		{
			get
			{
				if (MetadataSystem.TryGetPrimitiveElementType(this, out var result))
				{
					return (MetadataType)result;
				}
				return base.MetadataType;
			}
		}

		public override bool IsDefinition => true;

		public new TypeDefinition DeclaringType
		{
			get
			{
				return (TypeDefinition)base.DeclaringType;
			}
			set
			{
				base.DeclaringType = value;
			}
		}

		private void ResolveLayout()
		{
			if (packing_size != -2 || class_size != -2)
			{
				return;
			}
			if (!base.HasImage)
			{
				packing_size = -1;
				class_size = -1;
				return;
			}
			Row<short, int> row = Module.Read(this, (TypeDefinition type, MetadataReader reader) => reader.ReadTypeLayout(type));
			packing_size = row.Col1;
			class_size = row.Col2;
		}

		public TypeDefinition(string @namespace, string name, TypeAttributes attributes)
			: base(@namespace, name)
		{
			this.attributes = (uint)attributes;
			token = new MetadataToken(TokenType.TypeDef);
		}

		public TypeDefinition(string @namespace, string name, TypeAttributes attributes, TypeReference baseType)
			: this(@namespace, name, attributes)
		{
			BaseType = baseType;
		}

		public override TypeDefinition Resolve()
		{
			return this;
		}
	}
	internal sealed class TypeDefinitionCollection : Mono.Collections.Generic.Collection<TypeDefinition>
	{
		private readonly ModuleDefinition container;

		private readonly Dictionary<Row<string, string>, TypeDefinition> name_cache;

		internal TypeDefinitionCollection(ModuleDefinition container)
		{
			this.container = container;
			name_cache = new Dictionary<Row<string, string>, TypeDefinition>(new RowEqualityComparer());
		}

		internal TypeDefinitionCollection(ModuleDefinition container, int capacity)
			: base(capacity)
		{
			this.container = container;
			name_cache = new Dictionary<Row<string, string>, TypeDefinition>(capacity, new RowEqualityComparer());
		}

		protected override void OnAdd(TypeDefinition item, int index)
		{
			Attach(item);
		}

		protected override void OnSet(TypeDefinition item, int index)
		{
			Attach(item);
		}

		protected override void OnInsert(TypeDefinition item, int index)
		{
			Attach(item);
		}

		protected override void OnRemove(TypeDefinition item, int index)
		{
			Detach(item);
		}

		protected override void OnClear()
		{
			using Enumerator enumerator = GetEnumerator();
			while (enumerator.MoveNext())
			{
				TypeDefinition current = enumerator.Current;
				Detach(current);
			}
		}

		private void Attach(TypeDefinition type)
		{
			if (type.Module != null && type.Module != container)
			{
				throw new ArgumentException("Type already attached");
			}
			type.module = container;
			type.scope = container;
			name_cache[new Row<string, string>(type.Namespace, type.Name)] = type;
		}

		private void Detach(TypeDefinition type)
		{
			type.module = null;
			type.scope = null;
			name_cache.Remove(new Row<string, string>(type.Namespace, type.Name));
		}

		public TypeDefinition GetType(string fullname)
		{
			TypeParser.SplitFullName(fullname, out var @namespace, out var name);
			return GetType(@namespace, name);
		}

		public TypeDefinition GetType(string @namespace, string name)
		{
			if (name_cache.TryGetValue(new Row<string, string>(@namespace, name), out var value))
			{
				return value;
			}
			return null;
		}
	}
	public enum MetadataType : byte
	{
		Void = 1,
		Boolean = 2,
		Char = 3,
		SByte = 4,
		Byte = 5,
		Int16 = 6,
		UInt16 = 7,
		Int32 = 8,
		UInt32 = 9,
		Int64 = 10,
		UInt64 = 11,
		Single = 12,
		Double = 13,
		String = 14,
		Pointer = 15,
		ByReference = 16,
		ValueType = 17,
		Class = 18,
		Var = 19,
		Array = 20,
		GenericInstance = 21,
		TypedByReference = 22,
		IntPtr = 24,
		UIntPtr = 25,
		FunctionPointer = 27,
		Object = 28,
		MVar = 30,
		RequiredModifier = 31,
		OptionalModifier = 32,
		Sentinel = 65,
		Pinned = 69
	}
	public class TypeReference : MemberReference, IGenericParameterProvider, IMetadataTokenProvider, IGenericContext
	{
		private string @namespace;

		private bool value_type;

		internal IMetadataScope scope;

		internal ModuleDefinition module;

		internal ElementType etype;

		private string fullname;

		protected Mono.Collections.Generic.Collection<GenericParameter> generic_parameters;

		public override string Name
		{
			get
			{
				return base.Name;
			}
			set
			{
				base.Name = value;
				fullname = null;
			}
		}

		public virtual string Namespace
		{
			get
			{
				return @namespace;
			}
			set
			{
				@namespace = value;
				fullname = null;
			}
		}

		public virtual bool IsValueType
		{
			get
			{
				return value_type;
			}
			set
			{
				value_type = value;
			}
		}

		public override ModuleDefinition Module
		{
			get
			{
				if (module != null)
				{
					return module;
				}
				return DeclaringType?.Module;
			}
		}

		IGenericParameterProvider IGenericContext.Type => this;

		IGenericParameterProvider IGenericContext.Method => null;

		GenericParameterType IGenericParameterProvider.GenericParameterType => GenericParameterType.Type;

		public virtual bool HasGenericParameters => !generic_parameters.IsNullOrEmpty();

		public virtual Mono.Collections.Generic.Collection<GenericParameter> GenericParameters
		{
			get
			{
				if (generic_parameters != null)
				{
					return generic_parameters;
				}
				return generic_parameters = new GenericParameterCollection(this);
			}
		}

		public virtual IMetadataScope Scope
		{
			get
			{
				TypeReference declaringType = DeclaringType;
				if (declaringType != null)
				{
					return declaringType.Scope;
				}
				return scope;
			}
			set
			{
				TypeReference declaringType = DeclaringType;
				if (declaringType != null)
				{
					declaringType.Scope = value;
				}
				else
				{
					scope = value;
				}
			}
		}

		public bool IsNested => DeclaringType != null;

		public override TypeReference DeclaringType
		{
			get
			{
				return base.DeclaringType;
			}
			set
			{
				base.DeclaringType = value;
				fullname = null;
			}
		}

		public override string FullName
		{
			get
			{
				if (fullname != null)
				{
					return fullname;
				}
				fullname = this.TypeFullName();
				if (IsNested)
				{
					fullname = DeclaringType.FullName + "/" + fullname;
				}
				return fullname;
			}
		}

		public virtual bool IsByReference => false;

		public virtual bool IsPointer => false;

		public virtual bool IsSentinel => false;

		public virtual bool IsArray => false;

		public virtual bool IsGenericParameter => false;

		public virtual bool IsGenericInstance => false;

		public virtual bool IsRequiredModifier => false;

		public virtual bool IsOptionalModifier => false;

		public virtual bool IsPinned => false;

		public virtual bool IsFunctionPointer => false;

		public virtual bool IsPrimitive => etype.IsPrimitive();

		public virtual MetadataType MetadataType
		{
			get
			{
				if (etype == ElementType.None)
				{
					if (!IsValueType)
					{
						return MetadataType.Class;
					}
					return MetadataType.ValueType;
				}
				return (MetadataType)etype;
			}
		}

		protected TypeReference(string @namespace, string name)
			: base(name)
		{
			this.@namespace = @namespace ?? string.Empty;
			token = new MetadataToken(TokenType.TypeRef, 0);
		}

		public TypeReference(string @namespace, string name, ModuleDefinition module, IMetadataScope scope)
			: this(@namespace, name)
		{
			this.module = module;
			this.scope = scope;
		}

		public TypeReference(string @namespace, string name, ModuleDefinition module, IMetadataScope scope, bool valueType)
			: this(@namespace, name, module, scope)
		{
			value_type = valueType;
		}

		public virtual TypeReference GetElementType()
		{
			return this;
		}

		public virtual TypeDefinition Resolve()
		{
			return (Module ?? throw new NotSupportedException()).Resolve(this);
		}
	}
	public abstract class TypeSpecification : TypeReference
	{
		private readonly TypeReference element_type;

		public TypeReference ElementType => element_type;

		public override string Name
		{
			get
			{
				return element_type.Name;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override string Namespace
		{
			get
			{
				return element_type.Namespace;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override IMetadataScope Scope
		{
			get
			{
				return element_type.Scope;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public override ModuleDefinition Module => element_type.Module;

		public override string FullName => element_type.FullName;

		public override bool ContainsGenericParameter => element_type.ContainsGenericParameter;

		public override MetadataType MetadataType => (MetadataType)etype;

		internal TypeSpecification(TypeReference type)
			: base(null, null)
		{
			element_type = type;
			token = new MetadataToken(TokenType.TypeSpec);
		}

		public override TypeReference GetElementType()
		{
			return element_type.GetElementType();
		}
	}
	public abstract class TypeSystem
	{
		private sealed class CoreTypeSystem : TypeSystem
		{
			public CoreTypeSystem(ModuleDefinition module)
				: base(module)
			{
			}

			internal override TypeReference LookupType(string @namespace, string name)
			{
				TypeReference typeReference = LookupTypeDefinition(@namespace, name) ?? LookupTypeForwarded(@namespace, name);
				if (typeReference != null)
				{
					return typeReference;
				}
				throw new NotSupportedException();
			}

			private TypeReference LookupTypeDefinition(string @namespace, string name)
			{
				if (module.MetadataSystem.Types == null)
				{
					Initialize(module.Types);
				}
				return module.Read(new Row<string, string>(@namespace, name), delegate(Row<string, string> row, MetadataReader reader)
				{
					TypeDefinition[] types = reader.metadata.Types;
					for (int i = 0; i < types.Length; i++)
					{
						if (types[i] == null)
						{
							types[i] = reader.GetTypeDefinition((uint)(i + 1));
						}
						TypeDefinition typeDefinition = types[i];
						if (typeDefinition.Name == row.Col2 && typeDefinition.Namespace == row.Col1)
						{
							return typeDefinition;
						}
					}
					return (TypeDefinition)null;
				});
			}

			private TypeReference LookupTypeForwarded(string @namespace, string name)
			{
				if (!module.HasExportedTypes)
				{
					return null;
				}
				Mono.Collections.Generic.Collection<ExportedType> exportedTypes = module.ExportedTypes;
				for (int i = 0; i < exportedTypes.Count; i++)
				{
					ExportedType exportedType = exportedTypes[i];
					if (exportedType.Name == name && exportedType.Namespace == @namespace)
					{
						return exportedType.CreateReference();
					}
				}
				return null;
			}

			private static void Initialize(object obj)
			{
			}
		}

		private sealed class CommonTypeSystem : TypeSystem
		{
			private AssemblyNameReference corlib;

			public CommonTypeSystem(ModuleDefinition module)
				: base(module)
			{
			}

			internal override TypeReference LookupType(string @namespace, string name)
			{
				return CreateTypeReference(@namespace, name);
			}

			public AssemblyNameReference GetCorlibReference()
			{
				if (corlib != null)
				{
					return corlib;
				}
				Mono.Collections.Generic.Collection<AssemblyNameReference> assemblyReferences = module.AssemblyReferences;
				for (int i = 0; i < assemblyReferences.Count; i++)
				{
					AssemblyNameReference assemblyNameReference = assemblyReferences[i];
					if (assemblyNameReference.Name == "mscorlib")
					{
						return corlib = assemblyNameReference;
					}
				}
				corlib = new AssemblyNameReference
				{
					Name = "mscorlib",
					Version = GetCorlibVersion(),
					PublicKeyToken = new byte[8] { 183, 122, 92, 86, 25, 52, 224, 137 }
				};
				assemblyReferences.Add(corlib);
				return corlib;
			}

			private Version GetCorlibVersion()
			{
				switch (module.Runtime)
				{
				case TargetRuntime.Net_1_0:
				case TargetRuntime.Net_1_1:
					return new Version(1, 0, 0, 0);
				case TargetRuntime.Net_2_0:
					return new Version(2, 0, 0, 0);
				case TargetRuntime.Net_4_0:
					return new Version(4, 0, 0, 0);
				default:
					throw new NotSupportedException();
				}
			}

			private TypeReference CreateTypeReference(string @namespace, string name)
			{
				return new TypeReference(@namespace, name, module, GetCorlibReference());
			}
		}

		private readonly ModuleDefinition module;

		private TypeReference type_object;

		private TypeReference type_void;

		private TypeReference type_bool;

		private TypeReference type_char;

		private TypeReference type_sbyte;

		private TypeReference type_byte;

		private TypeReference type_int16;

		private TypeReference type_uint16;

		private TypeReference type_int32;

		private TypeReference type_uint32;

		private TypeReference type_int64;

		private TypeReference type_uint64;

		private TypeReference type_single;

		private TypeReference type_double;

		private TypeReference type_intptr;

		private TypeReference type_uintptr;

		private TypeReference type_string;

		private TypeReference type_typedref;

		public IMetadataScope Corlib
		{
			get
			{
				if (!(this is CommonTypeSystem commonTypeSystem))
				{
					return module;
				}
				return commonTypeSystem.GetCorlibReference();
			}
		}

		public TypeReference Object => type_object ?? LookupSystemType(ref type_object, "Object", ElementType.Object);

		public TypeReference Void => type_void ?? LookupSystemType(ref type_void, "Void", ElementType.Void);

		public TypeReference Boolean => type_bool ?? LookupSystemValueType(ref type_bool, "Boolean", ElementType.Boolean);

		public TypeReference Char => type_char ?? LookupSystemValueType(ref type_char, "Char", ElementType.Char);

		public TypeReference SByte => type_sbyte ?? LookupSystemValueType(ref type_sbyte, "SByte", ElementType.I1);

		public TypeReference Byte => type_byte ?? LookupSystemValueType(ref type_byte, "Byte", ElementType.U1);

		public TypeReference Int16 => type_int16 ?? LookupSystemValueType(ref type_int16, "Int16", ElementType.I2);

		public TypeReference UInt16 => type_uint16 ?? LookupSystemValueType(ref type_uint16, "UInt16", ElementType.U2);

		public TypeReference Int32 => type_int32 ?? LookupSystemValueType(ref type_int32, "Int32", ElementType.I4);

		public TypeReference UInt32 => type_uint32 ?? LookupSystemValueType(ref type_uint32, "UInt32", ElementType.U4);

		public TypeReference Int64 => type_int64 ?? LookupSystemValueType(ref type_int64, "Int64", ElementType.I8);

		public TypeReference UInt64 => type_uint64 ?? LookupSystemValueType(ref type_uint64, "UInt64", ElementType.U8);

		public TypeReference Single => type_single ?? LookupSystemValueType(ref type_single, "Single", ElementType.R4);

		public TypeReference Double => type_double ?? LookupSystemValueType(ref type_double, "Double", ElementType.R8);

		public TypeReference IntPtr => type_intptr ?? LookupSystemValueType(ref type_intptr, "IntPtr", ElementType.I);

		public TypeReference UIntPtr => type_uintptr ?? LookupSystemValueType(ref type_uintptr, "UIntPtr", ElementType.U);

		public TypeReference String => type_string ?? LookupSystemType(ref type_string, "String", ElementType.String);

		public TypeReference TypedReference => type_typedref ?? LookupSystemValueType(ref type_typedref, "TypedReference", ElementType.TypedByRef);

		private TypeSystem(ModuleDefinition module)
		{
			this.module = module;
		}

		internal static TypeSystem CreateTypeSystem(ModuleDefinition module)
		{
			if (module.IsCorlib())
			{
				return new CoreTypeSystem(module);
			}
			return new CommonTypeSystem(module);
		}

		internal abstract TypeReference LookupType(string @namespace, string name);

		private TypeReference LookupSystemType(ref TypeReference reference, string name, ElementType element_type)
		{
			lock (module.SyncRoot)
			{
				if (reference != null)
				{
					return reference;
				}
				TypeReference typeReference = LookupType("System", name);
				typeReference.etype = element_type;
				return reference = typeReference;
			}
		}

		private TypeReference LookupSystemValueType(ref TypeReference typeRef, string name, ElementType element_type)
		{
			lock (module.SyncRoot)
			{
				if (typeRef != null)
				{
					return typeRef;
				}
				TypeReference typeReference = LookupType("System", name);
				typeReference.etype = element_type;
				typeReference.IsValueType = true;
				return typeRef = typeReference;
			}
		}
	}
	public enum VariantType
	{
		None = 0,
		I2 = 2,
		I4 = 3,
		R4 = 4,
		R8 = 5,
		CY = 6,
		Date = 7,
		BStr = 8,
		Dispatch = 9,
		Error = 10,
		Bool = 11,
		Variant = 12,
		Unknown = 13,
		Decimal = 14,
		I1 = 16,
		UI1 = 17,
		UI2 = 18,
		UI4 = 19,
		Int = 22,
		UInt = 23
	}
	internal static class CryptoService
	{
		public static void StrongName(Stream stream, ImageWriter writer, StrongNameKeyPair key_pair)
		{
			int strong_name_pointer;
			byte[] strong_name = CreateStrongName(key_pair, HashStream(stream, writer, out strong_name_pointer));
			PatchStrongName(stream, strong_name_pointer, strong_name);
		}

		private static void PatchStrongName(Stream stream, int strong_name_pointer, byte[] strong_name)
		{
			stream.Seek(strong_name_pointer, SeekOrigin.Begin);
			stream.Write(strong_name, 0, strong_name.Length);
		}

		private static byte[] CreateStrongName(StrongNameKeyPair key_pair, byte[] hash)
		{
			using RSA key = key_pair.CreateRSA();
			RSAPKCS1SignatureFormatter rSAPKCS1SignatureFormatter = new RSAPKCS1SignatureFormatter(key);
			rSAPKCS1SignatureFormatter.SetHashAlgorithm("SHA1");
			byte[] array = rSAPKCS1SignatureFormatter.CreateSignature(hash);
			Array.Reverse((Array)array);
			return array;
		}

		private static byte[] HashStream(Stream stream, ImageWriter writer, out int strong_name_pointer)
		{
			Section text = writer.text;
			int headerSize = (int)writer.GetHeaderSize();
			int pointerToRawData = (int)text.PointerToRawData;
			DataDirectory strongNameSignatureDirectory = writer.GetStrongNameSignatureDirectory();
			if (strongNameSignatureDirectory.Size == 0)
			{
				throw new InvalidOperationException();
			}
			strong_name_pointer = (int)(pointerToRawData + (strongNameSignatureDirectory.VirtualAddress - text.VirtualAddress));
			int size = (int)strongNameSignatureDirectory.Size;
			SHA1Managed sHA1Managed = new SHA1Managed();
			byte[] buffer = new byte[8192];
			using (CryptoStream dest_stream = new CryptoStream(Stream.Null, sHA1Managed, CryptoStreamMode.Write))
			{
				stream.Seek(0L, SeekOrigin.Begin);
				CopyStreamChunk(stream, dest_stream, buffer, headerSize);
				stream.Seek(pointerToRawData, SeekOrigin.Begin);
				CopyStreamChunk(stream, dest_stream, buffer, strong_name_pointer - pointerToRawData);
				stream.Seek(size, SeekOrigin.Current);
				CopyStreamChunk(stream, dest_stream, buffer, (int)(stream.Length - (strong_name_pointer + size)));
			}
			return sHA1Managed.Hash;
		}

		private static void CopyStreamChunk(Stream stream, Stream dest_stream, byte[] buffer, int length)
		{
			while (length > 0)
			{
				int num = stream.Read(buffer, 0, System.Math.Min(buffer.Length, length));
				dest_stream.Write(buffer, 0, num);
				length -= num;
			}
		}

		public static byte[] ComputeHash(string file)
		{
			if (!File.Exists(file))
			{
				return Empty<byte>.Array;
			}
			SHA1Managed sHA1Managed = new SHA1Managed();
			using (FileStream fileStream = new FileStream(file, System.IO.FileMode.Open, FileAccess.Read, FileShare.Read))
			{
				byte[] buffer = new byte[8192];
				using CryptoStream dest_stream = new CryptoStream(Stream.Null, sHA1Managed, CryptoStreamMode.Write);
				CopyStreamChunk(fileStream, dest_stream, buffer, (int)fileStream.Length);
			}
			return sHA1Managed.Hash;
		}
	}
}
namespace Mono.Cecil.PE
{
	internal class BinaryStreamReader : BinaryReader
	{
		public BinaryStreamReader(Stream stream)
			: base(stream)
		{
		}

		protected void Advance(int bytes)
		{
			BaseStream.Seek(bytes, SeekOrigin.Current);
		}

		protected DataDirectory ReadDataDirectory()
		{
			return new DataDirectory(ReadUInt32(), ReadUInt32());
		}
	}
	internal class BinaryStreamWriter : BinaryWriter
	{
		public BinaryStreamWriter(Stream stream)
			: base(stream)
		{
		}

		public void WriteByte(byte value)
		{
			Write(value);
		}

		public void WriteUInt16(ushort value)
		{
			Write(value);
		}

		public void WriteInt16(short value)
		{
			Write(value);
		}

		public void WriteUInt32(uint value)
		{
			Write(value);
		}

		public void WriteInt32(int value)
		{
			Write(value);
		}

		public void WriteUInt64(ulong value)
		{
			Write(value);
		}

		public void WriteBytes(byte[] bytes)
		{
			Write(bytes);
		}

		public void WriteDataDirectory(DataDirectory directory)
		{
			Write(directory.VirtualAddress);
			Write(directory.Size);
		}

		public void WriteBuffer(ByteBuffer buffer)
		{
			Write(buffer.buffer, 0, buffer.length);
		}

		protected void Advance(int bytes)
		{
			BaseStream.Seek(bytes, SeekOrigin.Current);
		}
	}
	internal sealed class ByteBufferEqualityComparer : IEqualityComparer<ByteBuffer>
	{
		public bool Equals(ByteBuffer x, ByteBuffer y)
		{
			if (x.length != y.length)
			{
				return false;
			}
			byte[] buffer = x.buffer;
			byte[] buffer2 = y.buffer;
			for (int i = 0; i < x.length; i++)
			{
				if (buffer[i] != buffer2[i])
				{
					return false;
				}
			}
			return true;
		}

		public int GetHashCode(ByteBuffer buffer)
		{
			int num = 0;
			byte[] buffer2 = buffer.buffer;
			for (int i = 0; i < buffer.length; i++)
			{
				num = (num * 37) ^ buffer2[i];
			}
			return num;
		}
	}
	internal class ByteBuffer
	{
		internal byte[] buffer;

		internal int length;

		internal int position;

		public ByteBuffer()
		{
			buffer = Empty<byte>.Array;
		}

		public ByteBuffer(int length)
		{
			buffer = new byte[length];
		}

		public ByteBuffer(byte[] buffer)
		{
			this.buffer = buffer ?? Empty<byte>.Array;
			length = this.buffer.Length;
		}

		public void Reset(byte[] buffer)
		{
			this.buffer = buffer ?? Empty<byte>.Array;
			length = this.buffer.Length;
		}

		public void Advance(int length)
		{
			position += length;
		}

		public byte ReadByte()
		{
			return buffer[position++];
		}

		public sbyte ReadSByte()
		{
			return (sbyte)ReadByte();
		}

		public byte[] ReadBytes(int length)
		{
			byte[] array = new byte[length];
			Buffer.BlockCopy(buffer, position, array, 0, length);
			position += length;
			return array;
		}

		public ushort ReadUInt16()
		{
			ushort result = (ushort)(buffer[position] | (buffer[position + 1] << 8));
			position += 2;
			return result;
		}

		public short ReadInt16()
		{
			return (short)ReadUInt16();
		}

		public uint ReadUInt32()
		{
			int result = buffer[position] | (buffer[position + 1] << 8) | (buffer[position + 2] << 16) | (buffer[position + 3] << 24);
			position += 4;
			return (uint)result;
		}

		public int ReadInt32()
		{
			return (int)ReadUInt32();
		}

		public ulong ReadUInt64()
		{
			uint num = ReadUInt32();
			return ((ulong)ReadUInt32() << 32) | num;
		}

		public long ReadInt64()
		{
			return (long)ReadUInt64();
		}

		public uint ReadCompressedUInt32()
		{
			byte b = ReadByte();
			if ((b & 0x80) == 0)
			{
				return b;
			}
			if ((b & 0x40) == 0)
			{
				return (uint)(((b & -129) << 8) | ReadByte());
			}
			return (uint)(((b & -193) << 24) | (ReadByte() << 16) | (ReadByte() << 8) | ReadByte());
		}

		public int ReadCompressedInt32()
		{
			int num = (int)(ReadCompressedUInt32() >> 1);
			if ((num & 1) == 0)
			{
				return num;
			}
			if (num < 64)
			{
				return num - 64;
			}
			if (num < 8192)
			{
				return num - 8192;
			}
			if (num < 268435456)
			{
				return num - 268435456;
			}
			return num - 536870912;
		}

		public float ReadSingle()
		{
			if (!BitConverter.IsLittleEndian)
			{
				byte[] array = ReadBytes(4);
				Array.Reverse((Array)array);
				return BitConverter.ToSingle(array, 0);
			}
			float result = BitConverter.ToSingle(buffer, position);
			position += 4;
			return result;
		}

		public double ReadDouble()
		{
			if (!BitConverter.IsLittleEndian)
			{
				byte[] array = ReadBytes(8);
				Array.Reverse((Array)array);
				return BitConverter.ToDouble(array, 0);
			}
			double result = BitConverter.ToDouble(buffer, position);
			position += 8;
			return result;
		}

		public void WriteByte(byte value)
		{
			if (position == buffer.Length)
			{
				Grow(1);
			}
			buffer[position++] = value;
			if (position > length)
			{
				length = position;
			}
		}

		public void WriteSByte(sbyte value)
		{
			WriteByte((byte)value);
		}

		public void WriteUInt16(ushort value)
		{
			if (position + 2 > buffer.Length)
			{
				Grow(2);
			}
			buffer[position++] = (byte)value;
			buffer[position++] = (byte)(value >> 8);
			if (position > length)
			{
				length = position;
			}
		}

		public void WriteInt16(short value)
		{
			WriteUInt16((ushort)value);
		}

		public void WriteUInt32(uint value)
		{
			if (position + 4 > buffer.Length)
			{
				Grow(4);
			}
			buffer[position++] = (byte)value;
			buffer[position++] = (byte)(value >> 8);
			buffer[position++] = (byte)(value >> 16);
			buffer[position++] = (byte)(value >> 24);
			if (position > length)
			{
				length = position;
			}
		}

		public void WriteInt32(int value)
		{
			WriteUInt32((uint)value);
		}

		public void WriteUInt64(ulong value)
		{
			if (position + 8 > buffer.Length)
			{
				Grow(8);
			}
			buffer[position++] = (byte)value;
			buffer[position++] = (byte)(value >> 8);
			buffer[position++] = (byte)(value >> 16);
			buffer[position++] = (byte)(value >> 24);
			buffer[position++] = (byte)(value >> 32);
			buffer[position++] = (byte)(value >> 40);
			buffer[position++] = (byte)(value >> 48);
			buffer[position++] = (byte)(value >> 56);
			if (position > length)
			{
				length = position;
			}
		}

		public void WriteInt64(long value)
		{
			WriteUInt64((ulong)value);
		}

		public void WriteCompressedUInt32(uint value)
		{
			if (value < 128)
			{
				WriteByte((byte)value);
				return;
			}
			if (value < 16384)
			{
				WriteByte((byte)(0x80 | (value >> 8)));
				WriteByte((byte)(value & 0xFF));
				return;
			}
			WriteByte((byte)((value >> 24) | 0xC0));
			WriteByte((byte)((value >> 16) & 0xFF));
			WriteByte((byte)((value >> 8) & 0xFF));
			WriteByte((byte)(value & 0xFF));
		}

		public void WriteCompressedInt32(int value)
		{
			if (value >= 0)
			{
				WriteCompressedUInt32((uint)(value << 1));
				return;
			}
			if (value > -64)
			{
				value = 64 + value;
			}
			else if (value >= -8192)
			{
				value = 8192 + value;
			}
			else if (value >= -536870912)
			{
				value = 536870912 + value;
			}
			WriteCompressedUInt32((uint)((value << 1) | 1));
		}

		public void WriteBytes(byte[] bytes)
		{
			int num = bytes.Length;
			if (position + num > buffer.Length)
			{
				Grow(num);
			}
			Buffer.BlockCopy(bytes, 0, buffer, position, num);
			position += num;
			if (position > length)
			{
				length = position;
			}
		}

		public void WriteBytes(int length)
		{
			if (position + length > buffer.Length)
			{
				Grow(length);
			}
			position += length;
			if (position > this.length)
			{
				this.length = position;
			}
		}

		public void WriteBytes(ByteBuffer buffer)
		{
			if (position + buffer.length > this.buffer.Length)
			{
				Grow(buffer.length);
			}
			Buffer.BlockCopy(buffer.buffer, 0, this.buffer, position, buffer.length);
			position += buffer.length;
			if (position > length)
			{
				length = position;
			}
		}

		public void WriteSingle(float value)
		{
			byte[] bytes = BitConverter.GetBytes(value);
			if (!BitConverter.IsLittleEndian)
			{
				Array.Reverse((Array)bytes);
			}
			WriteBytes(bytes);
		}

		public void WriteDouble(double value)
		{
			byte[] bytes = BitConverter.GetBytes(value);
			if (!BitConverter.IsLittleEndian)
			{
				Array.Reverse((Array)bytes);
			}
			WriteBytes(bytes);
		}

		private void Grow(int desired)
		{
			byte[] array = buffer;
			int num = array.Length;
			byte[] dst = new byte[System.Math.Max(num + desired, num * 2)];
			Buffer.BlockCopy(array, 0, dst, 0, num);
			buffer = dst;
		}
	}
	internal struct DataDirectory
	{
		public readonly uint VirtualAddress;

		public readonly uint Size;

		public bool IsZero
		{
			get
			{
				if (VirtualAddress == 0)
				{
					return Size == 0;
				}
				return false;
			}
		}

		public DataDirectory(uint rva, uint size)
		{
			VirtualAddress = rva;
			Size = size;
		}
	}
	internal sealed class Image
	{
		public ModuleKind Kind;

		public string RuntimeVersion;

		public TargetArchitecture Architecture;

		public ModuleCharacteristics Characteristics;

		public string FileName;

		public Section[] Sections;

		public Section MetadataSection;

		public uint EntryPointToken;

		public ModuleAttributes Attributes;

		public DataDirectory Debug;

		public DataDirectory Resources;

		public DataDirectory StrongName;

		public StringHeap StringHeap;

		public BlobHeap BlobHeap;

		public UserStringHeap UserStringHeap;

		public GuidHeap GuidHeap;

		public TableHeap TableHeap;

		private readonly int[] coded_index_sizes = new int[13];

		private readonly Func<Table, int> counter;

		public Image()
		{
			counter = GetTableLength;
		}

		public bool HasTable(Table table)
		{
			return GetTableLength(table) > 0;
		}

		public int GetTableLength(Table table)
		{
			return (int)TableHeap[table].Length;
		}

		public int GetTableIndexSize(Table table)
		{
			if (GetTableLength(table) >= 65536)
			{
				return 4;
			}
			return 2;
		}

		public int GetCodedIndexSize(CodedIndex coded_index)
		{
			int num = coded_index_sizes[(int)coded_index];
			if (num != 0)
			{
				return num;
			}
			return coded_index_sizes[(int)coded_index] = coded_index.GetSize(counter);
		}

		public uint ResolveVirtualAddress(uint rva)
		{
			Section sectionAtVirtualAddress = GetSectionAtVirtualAddress(rva);
			if (sectionAtVirtualAddress == null)
			{
				throw new ArgumentOutOfRangeException();
			}
			return ResolveVirtualAddressInSection(rva, sectionAtVirtualAddress);
		}

		public uint ResolveVirtualAddressInSection(uint rva, Section section)
		{
			return rva + section.PointerToRawData - section.VirtualAddress;
		}

		public Section GetSection(string name)
		{
			Section[] sections = Sections;
			foreach (Section section in sections)
			{
				if (section.Name == name)
				{
					return section;
				}
			}
			return null;
		}

		public Section GetSectionAtVirtualAddress(uint rva)
		{
			Section[] sections = Sections;
			foreach (Section section in sections)
			{
				if (rva >= section.VirtualAddress && rva < section.VirtualAddress + section.SizeOfRawData)
				{
					return section;
				}
			}
			return null;
		}

		public ImageDebugDirectory GetDebugHeader(out byte[] header)
		{
			Section sectionAtVirtualAddress = GetSectionAtVirtualAddress(Debug.VirtualAddress);
			ByteBuffer byteBuffer = new ByteBuffer(sectionAtVirtualAddress.Data);
			byteBuffer.position = (int)(Debug.VirtualAddress - sectionAtVirtualAddress.VirtualAddress);
			ImageDebugDirectory result = new ImageDebugDirectory
			{
				Characteristics = byteBuffer.ReadInt32(),
				TimeDateStamp = byteBuffer.ReadInt32(),
				MajorVersion = byteBuffer.ReadInt16(),
				MinorVersion = byteBuffer.ReadInt16(),
				Type = byteBuffer.ReadInt32(),
				SizeOfData = byteBuffer.ReadInt32(),
				AddressOfRawData = byteBuffer.ReadInt32(),
				PointerToRawData = byteBuffer.ReadInt32()
			};
			if (result.SizeOfData == 0 || result.PointerToRawData == 0)
			{
				header = Empty<byte>.Array;
				return result;
			}
			byteBuffer.position = (int)(result.PointerToRawData - sectionAtVirtualAddress.PointerToRawData);
			header = new byte[result.SizeOfData];
			Buffer.BlockCopy(byteBuffer.buffer, byteBuffer.position, header, 0, header.Length);
			return result;
		}
	}
	internal sealed class ImageReader : BinaryStreamReader
	{
		private readonly Image image;

		private DataDirectory cli;

		private DataDirectory metadata;

		public ImageReader(Stream stream)
			: base(stream)
		{
			image = new Image();
			image.FileName = stream.GetFullyQualifiedName();
		}

		private void MoveTo(DataDirectory directory)
		{
			BaseStream.Position = image.ResolveVirtualAddress(directory.VirtualAddress);
		}

		private void MoveTo(uint position)
		{
			BaseStream.Position = position;
		}

		private void ReadImage()
		{
			if (BaseStream.Length < 128)
			{
				throw new BadImageFormatException();
			}
			if (ReadUInt16() != 23117)
			{
				throw new BadImageFormatException();
			}
			Advance(58);
			MoveTo(ReadUInt32());
			if (ReadUInt32() != 17744)
			{
				throw new BadImageFormatException();
			}
			image.Architecture = ReadArchitecture();
			ushort count = ReadUInt16();
			Advance(14);
			ushort characteristics = ReadUInt16();
			ReadOptionalHeaders(out var subsystem, out var dll_characteristics);
			ReadSections(count);
			ReadCLIHeader();
			ReadMetadata();
			image.Kind = GetModuleKind(characteristics, subsystem);
			image.Characteristics = (ModuleCharacteristics)dll_characteristics;
		}

		private TargetArchitecture ReadArchitecture()
		{
			return ReadUInt16() switch
			{
				332 => TargetArchitecture.I386, 
				34404 => TargetArchitecture.AMD64, 
				512 => TargetArchitecture.IA64, 
				452 => TargetArchitecture.ARMv7, 
				_ => throw new NotSupportedException(), 
			};
		}

		private static ModuleKind GetModuleKind(ushort characteristics, ushort subsystem)
		{
			if ((characteristics & 0x2000) != 0)
			{
				return ModuleKind.Dll;
			}
			if (subsystem == 2 || subsystem == 9)
			{
				return ModuleKind.Windows;
			}
			return ModuleKind.Console;
		}

		private void ReadOptionalHeaders(out ushort subsystem, out ushort dll_characteristics)
		{
			bool flag = ReadUInt16() == 523;
			Advance(66);
			subsystem = ReadUInt16();
			dll_characteristics = ReadUInt16();
			Advance(flag ? 88 : 72);
			image.Debug = ReadDataDirectory();
			Advance(56);
			cli = ReadDataDirectory();
			if (cli.IsZero)
			{
				throw new BadImageFormatException();
			}
			Advance(8);
		}

		private string ReadAlignedString(int length)
		{
			int num = 0;
			char[] array = new char[length];
			while (num < length)
			{
				byte b = ReadByte();
				if (b == 0)
				{
					break;
				}
				array[num++] = (char)b;
			}
			Advance(-1 + ((num + 4) & -4) - num);
			return new string(array, 0, num);
		}

		private string ReadZeroTerminatedString(int length)
		{
			int num = 0;
			char[] array = new char[length];
			byte[] array2 = ReadBytes(length);
			while (num < length)
			{
				byte b = array2[num];
				if (b == 0)
				{
					break;
				}
				array[num++] = (char)b;
			}
			return new string(array, 0, num);
		}

		private void ReadSections(ushort count)
		{
			Section[] array = new Section[count];
			for (int i = 0; i < count; i++)
			{
				Section section = new Section();
				section.Name = ReadZeroTerminatedString(8);
				Advance(4);
				section.VirtualAddress = ReadUInt32();
				section.SizeOfRawData = ReadUInt32();
				section.PointerToRawData = ReadUInt32();
				Advance(16);
				array[i] = section;
				ReadSectionData(section);
			}
			image.Sections = array;
		}

		private void ReadSectionData(Section section)
		{
			long position = BaseStream.Position;
			MoveTo(section.PointerToRawData);
			int sizeOfRawData = (int)section.SizeOfRawData;
			byte[] array = new byte[sizeOfRawData];
			int num = 0;
			int num2;
			while ((num2 = Read(array, num, sizeOfRawData - num)) > 0)
			{
				num += num2;
			}
			section.Data = array;
			BaseStream.Position = position;
		}

		private void ReadCLIHeader()
		{
			MoveTo(cli);
			Advance(8);
			metadata = ReadDataDirectory();
			image.Attributes = (ModuleAttributes)ReadUInt32();
			image.EntryPointToken = ReadUInt32();
			image.Resources = ReadDataDirectory();
			image.StrongName = ReadDataDirectory();
		}

		private void ReadMetadata()
		{
			MoveTo(metadata);
			if (ReadUInt32() != 1112167234)
			{
				throw new BadImageFormatException();
			}
			Advance(8);
			image.RuntimeVersion = ReadZeroTerminatedString(ReadInt32());
			Advance(2);
			ushort num = ReadUInt16();
			Section sectionAtVirtualAddress = image.GetSectionAtVirtualAddress(metadata.VirtualAddress);
			if (sectionAtVirtualAddress == null)
			{
				throw new BadImageFormatException();
			}
			image.MetadataSection = sectionAtVirtualAddress;
			for (int i = 0; i < num; i++)
			{
				ReadMetadataStream(sectionAtVirtualAddress);
			}
			if (image.TableHeap != null)
			{
				ReadTableHeap();
			}
		}

		private void ReadMetadataStream(Section section)
		{
			uint start = metadata.VirtualAddress - section.VirtualAddress + ReadUInt32();
			uint size = ReadUInt32();
			switch (ReadAlignedString(16))
			{
			case "#~":
			case "#-":
				image.TableHeap = new TableHeap(section, start, size);
				break;
			case "#Strings":
				image.StringHeap = new StringHeap(section, start, size);
				break;
			case "#Blob":
				image.BlobHeap = new BlobHeap(section, start, size);
				break;
			case "#GUID":
				image.GuidHeap = new GuidHeap(section, start, size);
				break;
			case "#US":
				image.UserStringHeap = new UserStringHeap(section, start, size);
				break;
			}
		}

		private void ReadTableHeap()
		{
			TableHeap tableHeap = image.TableHeap;
			uint pointerToRawData = tableHeap.Section.PointerToRawData;
			MoveTo(tableHeap.Offset + pointerToRawData);
			Advance(6);
			byte sizes = ReadByte();
			Advance(1);
			tableHeap.Valid = ReadInt64();
			tableHeap.Sorted = ReadInt64();
			for (int i = 0; i < 45; i++)
			{
				if (tableHeap.HasTable((Table)i))
				{
					tableHeap.Tables[i].Length = ReadUInt32();
				}
			}
			SetIndexSize(image.StringHeap, sizes, 1);
			SetIndexSize(image.GuidHeap, sizes, 2);
			SetIndexSize(image.BlobHeap, sizes, 4);
			ComputeTableInformations();
		}

		private static void SetIndexSize(Heap heap, uint sizes, byte flag)
		{
			if (heap != null)
			{
				heap.IndexSize = (((sizes & flag) != 0) ? 4 : 2);
			}
		}

		private int GetTableIndexSize(Table table)
		{
			return image.GetTableIndexSize(table);
		}

		private int GetCodedIndexSize(CodedIndex index)
		{
			return image.GetCodedIndexSize(index);
		}

		private void ComputeTableInformations()
		{
			uint num = (uint)(int)BaseStream.Position - image.MetadataSection.PointerToRawData;
			int indexSize = image.StringHeap.IndexSize;
			int num2 = ((image.BlobHeap != null) ? image.BlobHeap.IndexSize : 2);
			TableHeap tableHeap = image.TableHeap;
			TableInformation[] tables = tableHeap.Tables;
			for (int i = 0; i < 45; i++)
			{
				Table table = (Table)i;
				if (tableHeap.HasTable(table))
				{
					int num3 = table switch
					{
						Table.Module => 2 + indexSize + image.GuidHeap.IndexSize * 3, 
						Table.TypeRef => GetCodedIndexSize(CodedIndex.ResolutionScope) + indexSize * 2, 
						Table.TypeDef => 4 + indexSize * 2 + GetCodedIndexSize(CodedIndex.TypeDefOrRef) + GetTableIndexSize(Table.Field) + GetTableIndexSize(Table.Method), 
						Table.FieldPtr => GetTableIndexSize(Table.Field), 
						Table.Field => 2 + indexSize + num2, 
						Table.MethodPtr => GetTableIndexSize(Table.Method), 
						Table.Method => 8 + indexSize + num2 + GetTableIndexSize(Table.Param), 
						Table.ParamPtr => GetTableIndexSize(Table.Param), 
						Table.Param => 4 + indexSize, 
						Table.InterfaceImpl => GetTableIndexSize(Table.TypeDef) + GetCodedIndexSize(CodedIndex.TypeDefOrRef), 
						Table.MemberRef => GetCodedIndexSize(CodedIndex.MemberRefParent) + indexSize + num2, 
						Table.Constant => 2 + GetCodedIndexSize(CodedIndex.HasConstant) + num2, 
						Table.CustomAttribute => GetCodedIndexSize(CodedIndex.HasCustomAttribute) + GetCodedIndexSize(CodedIndex.CustomAttributeType) + num2, 
						Table.FieldMarshal => GetCodedIndexSize(CodedIndex.HasFieldMarshal) + num2, 
						Table.DeclSecurity => 2 + GetCodedIndexSize(CodedIndex.HasDeclSecurity) + num2, 
						Table.ClassLayout => 6 + GetTableIndexSize(Table.TypeDef), 
						Table.FieldLayout => 4 + GetTableIndexSize(Table.Field), 
						Table.StandAloneSig => num2, 
						Table.EventMap => GetTableIndexSize(Table.TypeDef) + GetTableIndexSize(Table.Event), 
						Table.EventPtr => GetTableIndexSize(Table.Event), 
						Table.Event => 2 + indexSize + GetCodedIndexSize(CodedIndex.TypeDefOrRef), 
						Table.PropertyMap => GetTableIndexSize(Table.TypeDef) + GetTableIndexSize(Table.Property), 
						Table.PropertyPtr => GetTableIndexSize(Table.Property), 
						Table.Property => 2 + indexSize + num2, 
						Table.MethodSemantics => 2 + GetTableIndexSize(Table.Method) + GetCodedIndexSize(CodedIndex.HasSemantics), 
						Table.MethodImpl => GetTableIndexSize(Table.TypeDef) + GetCodedIndexSize(CodedIndex.MethodDefOrRef) + GetCodedIndexSize(CodedIndex.MethodDefOrRef), 
						Table.ModuleRef => indexSize, 
						Table.TypeSpec => num2, 
						Table.ImplMap => 2 + GetCodedIndexSize(CodedIndex.MemberForwarded) + indexSize + GetTableIndexSize(Table.ModuleRef), 
						Table.FieldRVA => 4 + GetTableIndexSize(Table.Field), 
						Table.EncLog => 8, 
						Table.EncMap => 4, 
						Table.Assembly => 16 + num2 + indexSize * 2, 
						Table.AssemblyProcessor => 4, 
						Table.AssemblyOS => 12, 
						Table.AssemblyRef => 12 + num2 * 2 + indexSize * 2, 
						Table.AssemblyRefProcessor => 4 + GetTableIndexSize(Table.AssemblyRef), 
						Table.AssemblyRefOS => 12 + GetTableIndexSize(Table.AssemblyRef), 
						Table.File => 4 + indexSize + num2, 
						Table.ExportedType => 8 + indexSize * 2 + GetCodedIndexSize(CodedIndex.Implementation), 
						Table.ManifestResource => 8 + indexSize + GetCodedIndexSize(CodedIndex.Implementation), 
						Table.NestedClass => GetTableIndexSize(Table.TypeDef) + GetTableIndexSize(Table.TypeDef), 
						Table.GenericParam => 4 + GetCodedIndexSize(CodedIndex.TypeOrMethodDef) + indexSize, 
						Table.MethodSpec => GetCodedIndexSize(CodedIndex.MethodDefOrRef) + num2, 
						Table.GenericParamConstraint => GetTableIndexSize(Table.GenericParam) + GetCodedIndexSize(CodedIndex.TypeDefOrRef), 
						_ => throw new NotSupportedException(), 
					};
					tables[i].RowSize = (uint)num3;
					tables[i].Offset = num;
					num += (uint)(num3 * (int)tables[i].Length);
				}
			}
		}

		public static Image ReadImageFrom(Stream stream)
		{
			try
			{
				ImageReader imageReader = new ImageReader(stream);
				imageReader.ReadImage();
				return imageReader.image;
			}
			catch (EndOfStreamException inner)
			{
				throw new BadImageFormatException(stream.GetFullyQualifiedName(), inner);
			}
		}
	}
	internal sealed class ImageWriter : BinaryStreamWriter
	{
		private readonly ModuleDefinition module;

		private readonly MetadataBuilder metadata;

		private readonly TextMap text_map;

		private ImageDebugDirectory debug_directory;

		private byte[] debug_data;

		private ByteBuffer win32_resources;

		private const uint pe_header_size = 152u;

		private const uint section_header_size = 40u;

		private const uint file_alignment = 512u;

		private const uint section_alignment = 8192u;

		private const ulong image_base = 4194304uL;

		internal const uint text_rva = 8192u;

		private readonly bool pe64;

		private readonly bool has_reloc;

		private readonly uint time_stamp;

		internal Section text;

		internal Section rsrc;

		internal Section reloc;

		private ushort sections;

		private ImageWriter(ModuleDefinition module, MetadataBuilder metadata, Stream stream)
			: base(stream)
		{
			this.module = module;
			this.metadata = metadata;
			pe64 = module.Architecture == TargetArchitecture.AMD64 || module.Architecture == TargetArchitecture.IA64;
			has_reloc = module.Architecture == TargetArchitecture.I386;
			GetDebugHeader();
			GetWin32Resources();
			text_map = BuildTextMap();
			sections = (ushort)((!has_reloc) ? 1u : 2u);
			time_stamp = (uint)DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1)).TotalSeconds;
		}

		private void GetDebugHeader()
		{
			ISymbolWriter symbol_writer = metadata.symbol_writer;
			if (symbol_writer != null && !symbol_writer.GetDebugHeader(out debug_directory, out debug_data))
			{
				debug_data = Empty<byte>.Array;
			}
		}

		private void GetWin32Resources()
		{
			Section imageResourceSection = GetImageResourceSection();
			if (imageResourceSection != null)
			{
				byte[] array = new byte[imageResourceSection.Data.Length];
				Buffer.BlockCopy(imageResourceSection.Data, 0, array, 0, imageResourceSection.Data.Length);
				win32_resources = new ByteBuffer(array);
			}
		}

		private Section GetImageResourceSection()
		{
			if (!module.HasImage)
			{
				return null;
			}
			return module.Image.GetSection(".rsrc");
		}

		public static ImageWriter CreateWriter(ModuleDefinition module, MetadataBuilder metadata, Stream stream)
		{
			ImageWriter imageWriter = new ImageWriter(module, metadata, stream);
			imageWriter.BuildSections();
			return imageWriter;
		}

		private void BuildSections()
		{
			bool num = win32_resources != null;
			if (num)
			{
				sections++;
			}
			text = CreateSection(".text", text_map.GetLength(), null);
			Section previous = text;
			if (num)
			{
				rsrc = CreateSection(".rsrc", (uint)win32_resources.length, previous);
				PatchWin32Resources(win32_resources);
				previous = rsrc;
			}
			if (has_reloc)
			{
				reloc = CreateSection(".reloc", 12u, previous);
			}
		}

		private Section CreateSection(string name, uint size, Section previous)
		{
			return new Section
			{
				Name = name,
				VirtualAddress = ((previous != null) ? (previous.VirtualAddress + Align(previous.VirtualSize, 8192u)) : 8192u),
				VirtualSize = size,
				PointerToRawData = ((previous != null) ? (previous.PointerToRawData + previous.SizeOfRawData) : Align(GetHeaderSize(), 512u)),
				SizeOfRawData = Align(size, 512u)
			};
		}

		private static uint Align(uint value, uint align)
		{
			align--;
			return (value + align) & ~align;
		}

		private void WriteDOSHeader()
		{
			Write(new byte[128]
			{
				77, 90, 144, 0, 3, 0, 0, 0, 4, 0,
				0, 0, 255, 255, 0, 0, 184, 0, 0, 0,
				0, 0, 0, 0, 64, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				128, 0, 0, 0, 14, 31, 186, 14, 0, 180,
				9, 205, 33, 184, 1, 76, 205, 33, 84, 104,
				105, 115, 32, 112, 114, 111, 103, 114, 97, 109,
				32, 99, 97, 110, 110, 111, 116, 32, 98, 101,
				32, 114, 117, 110, 32, 105, 110, 32, 68, 79,
				83, 32, 109, 111, 100, 101, 46, 13, 13, 10,
				36, 0, 0, 0, 0, 0, 0, 0
			});
		}

		private ushort SizeOfOptionalHeader()
		{
			return (ushort)((!pe64) ? 224u : 240u);
		}

		private void WritePEFileHeader()
		{
			WriteUInt32(17744u);
			WriteUInt16(GetMachine());
			WriteUInt16(sections);
			WriteUInt32(time_stamp);
			WriteUInt32(0u);
			WriteUInt32(0u);
			WriteUInt16(SizeOfOptionalHeader());
			ushort num = (ushort)(2 | ((!pe64) ? 256 : 32));
			if (module.Kind == ModuleKind.Dll || module.Kind == ModuleKind.NetModule)
			{
				num |= 0x2000;
			}
			WriteUInt16(num);
		}

		private ushort GetMachine()
		{
			return module.Architecture switch
			{
				TargetArchitecture.I386 => 332, 
				TargetArchitecture.AMD64 => 34404, 
				TargetArchitecture.IA64 => 512, 
				TargetArchitecture.ARMv7 => 452, 
				_ => throw new NotSupportedException(), 
			};
		}

		private Section LastSection()
		{
			if (reloc != null)
			{
				return reloc;
			}
			if (rsrc != null)
			{
				return rsrc;
			}
			return text;
		}

		private void WriteOptionalHeaders()
		{
			WriteUInt16((ushort)((!pe64) ? 267u : 523u));
			WriteByte(8);
			WriteByte(0);
			WriteUInt32(text.SizeOfRawData);
			WriteUInt32(((reloc != null) ? reloc.SizeOfRawData : 0) + ((rsrc != null) ? rsrc.SizeOfRawData : 0));
			WriteUInt32(0u);
			Range range = text_map.GetRange(TextSegment.StartupStub);
			WriteUInt32((range.Length != 0) ? range.Start : 0u);
			WriteUInt32(8192u);
			if (!pe64)
			{
				WriteUInt32(0u);
				WriteUInt32(4194304u);
			}
			else
			{
				WriteUInt64(4194304uL);
			}
			WriteUInt32(8192u);
			WriteUInt32(512u);
			WriteUInt16(4);
			WriteUInt16(0);
			WriteUInt16(0);
			WriteUInt16(0);
			WriteUInt16(4);
			WriteUInt16(0);
			WriteUInt32(0u);
			Section section = LastSection();
			WriteUInt32(section.VirtualAddress + Align(section.VirtualSize, 8192u));
			WriteUInt32(text.PointerToRawData);
			WriteUInt32(0u);
			WriteUInt16(GetSubSystem());
			WriteUInt16((ushort)module.Characteristics);
			if (!pe64)
			{
				WriteUInt32(1048576u);
				WriteUInt32(4096u);
				WriteUInt32(1048576u);
				WriteUInt32(4096u);
			}
			else
			{
				WriteUInt64(1048576uL);
				WriteUInt64(4096uL);
				WriteUInt64(1048576uL);
				WriteUInt64(4096uL);
			}
			WriteUInt32(0u);
			WriteUInt32(16u);
			WriteZeroDataDirectory();
			WriteDataDirectory(text_map.GetDataDirectory(TextSegment.ImportDirectory));
			if (rsrc != null)
			{
				WriteUInt32(rsrc.VirtualAddress);
				WriteUInt32(rsrc.VirtualSize);
			}
			else
			{
				WriteZeroDataDirectory();
			}
			WriteZeroDataDirectory();
			WriteZeroDataDirectory();
			WriteUInt32((reloc != null) ? reloc.VirtualAddress : 0u);
			WriteUInt32((reloc != null) ? reloc.VirtualSize : 0u);
			if (text_map.GetLength(TextSegment.DebugDirectory) > 0)
			{
				WriteUInt32(text_map.GetRVA(TextSegment.DebugDirectory));
				WriteUInt32(28u);
			}
			else
			{
				WriteZeroDataDirectory();
			}
			WriteZeroDataDirectory();
			WriteZeroDataDirectory();
			WriteZeroDataDirectory();
			WriteZeroDataDirectory();
			WriteZeroDataDirectory();
			WriteDataDirectory(text_map.GetDataDirectory(TextSegment.ImportAddressTable));
			WriteZeroDataDirectory();
			WriteDataDirectory(text_map.GetDataDirectory(TextSegment.CLIHeader));
			WriteZeroDataDirectory();
		}

		private void WriteZeroDataDirectory()
		{
			WriteUInt32(0u);
			WriteUInt32(0u);
		}

		private ushort GetSubSystem()
		{
			switch (module.Kind)
			{
			case ModuleKind.Dll:
			case ModuleKind.Console:
			case ModuleKind.NetModule:
				return 3;
			case ModuleKind.Windows:
				return 2;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		private void WriteSectionHeaders()
		{
			WriteSection(text, 1610612768u);
			if (rsrc != null)
			{
				WriteSection(rsrc, 1073741888u);
			}
			if (reloc != null)
			{
				WriteSection(reloc, 1107296320u);
			}
		}

		private void WriteSection(Section section, uint characteristics)
		{
			byte[] array = new byte[8];
			string name = section.Name;
			for (int i = 0; i < name.Length; i++)
			{
				array[i] = (byte)name[i];
			}
			WriteBytes(array);
			WriteUInt32(section.VirtualSize);
			WriteUInt32(section.VirtualAddress);
			WriteUInt32(section.SizeOfRawData);
			WriteUInt32(section.PointerToRawData);
			WriteUInt32(0u);
			WriteUInt32(0u);
			WriteUInt16(0);
			WriteUInt16(0);
			WriteUInt32(characteristics);
		}

		private void MoveTo(uint pointer)
		{
			BaseStream.Seek(pointer, SeekOrigin.Begin);
		}

		private void MoveToRVA(Section section, uint rva)
		{
			BaseStream.Seek(section.PointerToRawData + rva - section.VirtualAddress, SeekOrigin.Begin);
		}

		private void MoveToRVA(TextSegment segment)
		{
			MoveToRVA(text, text_map.GetRVA(segment));
		}

		private void WriteRVA(uint rva)
		{
			if (!pe64)
			{
				WriteUInt32(rva);
			}
			else
			{
				WriteUInt64(rva);
			}
		}

		private void PrepareSection(Section section)
		{
			MoveTo(section.PointerToRawData);
			if (section.SizeOfRawData <= 4096)
			{
				Write(new byte[section.SizeOfRawData]);
				MoveTo(section.PointerToRawData);
				return;
			}
			int i = 0;
			byte[] buffer = new byte[4096];
			int num;
			for (; i != section.SizeOfRawData; i += num)
			{
				num = System.Math.Min((int)section.SizeOfRawData - i, 4096);
				Write(buffer, 0, num);
			}
			MoveTo(section.PointerToRawData);
		}

		private void WriteText()
		{
			PrepareSection(text);
			if (has_reloc)
			{
				WriteRVA(text_map.GetRVA(TextSegment.ImportHintNameTable));
				WriteRVA(0u);
			}
			WriteUInt32(72u);
			WriteUInt16(2);
			WriteUInt16((ushort)((module.Runtime > TargetRuntime.Net_1_1) ? 5u : 0u));
			WriteUInt32(text_map.GetRVA(TextSegment.MetadataHeader));
			WriteUInt32(GetMetadataLength());
			WriteUInt32((uint)module.Attributes);
			WriteUInt32(metadata.entry_point.ToUInt32());
			WriteDataDirectory(text_map.GetDataDirectory(TextSegment.Resources));
			WriteDataDirectory(text_map.GetDataDirectory(TextSegment.StrongNameSignature));
			WriteZeroDataDirectory();
			WriteZeroDataDirectory();
			WriteZeroDataDirectory();
			WriteZeroDataDirectory();
			MoveToRVA(TextSegment.Code);
			WriteBuffer(metadata.code);
			MoveToRVA(TextSegment.Resources);
			WriteBuffer(metadata.resources);
			if (metadata.data.length > 0)
			{
				MoveToRVA(TextSegment.Data);
				WriteBuffer(metadata.data);
			}
			MoveToRVA(TextSegment.MetadataHeader);
			WriteMetadataHeader();
			WriteMetadata();
			if (text_map.GetLength(TextSegment.DebugDirectory) > 0)
			{
				MoveToRVA(TextSegment.DebugDirectory);
				WriteDebugDirectory();
			}
			if (has_reloc)
			{
				MoveToRVA(TextSegment.ImportDirectory);
				WriteImportDirectory();
				MoveToRVA(TextSegment.StartupStub);
				WriteStartupStub();
			}
		}

		private uint GetMetadataLength()
		{
			return text_map.GetRVA(TextSegment.DebugDirectory) - text_map.GetRVA(TextSegment.MetadataHeader);
		}

		private void WriteMetadataHeader()
		{
			WriteUInt32(1112167234u);
			WriteUInt16(1);
			WriteUInt16(1);
			WriteUInt32(0u);
			byte[] zeroTerminatedString = GetZeroTerminatedString(module.runtime_version);
			WriteUInt32((uint)zeroTerminatedString.Length);
			WriteBytes(zeroTerminatedString);
			WriteUInt16(0);
			WriteUInt16(GetStreamCount());
			uint offset = text_map.GetRVA(TextSegment.TableHeap) - text_map.GetRVA(TextSegment.MetadataHeader);
			WriteStreamHeader(ref offset, TextSegment.TableHeap, "#~");
			WriteStreamHeader(ref offset, TextSegment.StringHeap, "#Strings");
			WriteStreamHeader(ref offset, TextSegment.UserStringHeap, "#US");
			WriteStreamHeader(ref offset, TextSegment.GuidHeap, "#GUID");
			WriteStreamHeader(ref offset, TextSegment.BlobHeap, "#Blob");
		}

		private ushort GetStreamCount()
		{
			return (ushort)((uint)(2 + ((!metadata.user_string_heap.IsEmpty) ? 1 : 0) + 1) + ((!metadata.blob_heap.IsEmpty) ? 1u : 0u));
		}

		private void WriteStreamHeader(ref uint offset, TextSegment heap, string name)
		{
			uint length = (uint)text_map.GetLength(heap);
			if (length != 0)
			{
				WriteUInt32(offset);
				WriteUInt32(length);
				WriteBytes(GetZeroTerminatedString(name));
				offset += length;
			}
		}

		private static byte[] GetZeroTerminatedString(string @string)
		{
			return GetString(@string, (@string.Length + 1 + 3) & -4);
		}

		private static byte[] GetSimpleString(string @string)
		{
			return GetString(@string, @string.Length);
		}

		private static byte[] GetString(string @string, int length)
		{
			byte[] array = new byte[length];
			for (int i = 0; i < @string.Length; i++)
			{
				array[i] = (byte)@string[i];
			}
			return array;
		}

		private void WriteMetadata()
		{
			WriteHeap(TextSegment.TableHeap, metadata.table_heap);
			WriteHeap(TextSegment.StringHeap, metadata.string_heap);
			WriteHeap(TextSegment.UserStringHeap, metadata.user_string_heap);
			WriteGuidHeap();
			WriteHeap(TextSegment.BlobHeap, metadata.blob_heap);
		}

		private void WriteHeap(TextSegment heap, HeapBuffer buffer)
		{
			if (!buffer.IsEmpty)
			{
				MoveToRVA(heap);
				WriteBuffer(buffer);
			}
		}

		private void WriteGuidHeap()
		{
			MoveToRVA(TextSegment.GuidHeap);
			WriteBytes(module.Mvid.ToByteArray());
		}

		private void WriteDebugDirectory()
		{
			WriteInt32(debug_directory.Characteristics);
			WriteUInt32(time_stamp);
			WriteInt16(debug_directory.MajorVersion);
			WriteInt16(debug_directory.MinorVersion);
			WriteInt32(debug_directory.Type);
			WriteInt32(debug_directory.SizeOfData);
			WriteInt32(debug_directory.AddressOfRawData);
			WriteInt32((int)BaseStream.Position + 4);
			WriteBytes(debug_data);
		}

		private void WriteImportDirectory()
		{
			WriteUInt32(text_map.GetRVA(TextSegment.ImportDirectory) + 40);
			WriteUInt32(0u);
			WriteUInt32(0u);
			WriteUInt32(text_map.GetRVA(TextSegment.ImportHintNameTable) + 14);
			WriteUInt32(text_map.GetRVA(TextSegment.ImportAddressTable));
			Advance(20);
			WriteUInt32(text_map.GetRVA(TextSegment.ImportHintNameTable));
			MoveToRVA(TextSegment.ImportHintNameTable);
			WriteUInt16(0);
			WriteBytes(GetRuntimeMain());
			WriteByte(0);
			WriteBytes(GetSimpleString("mscoree.dll"));
			WriteUInt16(0);
		}

		private byte[] GetRuntimeMain()
		{
			if (module.Kind != ModuleKind.Dll && module.Kind != ModuleKind.NetModule)
			{
				return GetSimpleString("_CorExeMain");
			}
			return GetSimpleString("_CorDllMain");
		}

		private void WriteStartupStub()
		{
			if (module.Architecture == TargetArchitecture.I386)
			{
				WriteUInt16(9727);
				WriteUInt32(4194304 + text_map.GetRVA(TextSegment.ImportAddressTable));
				return;
			}
			throw new NotSupportedException();
		}

		private void WriteRsrc()
		{
			PrepareSection(rsrc);
			WriteBuffer(win32_resources);
		}

		private void WriteReloc()
		{
			PrepareSection(reloc);
			uint rVA = text_map.GetRVA(TextSegment.StartupStub);
			rVA += (uint)((module.Architecture == TargetArchitecture.IA64) ? 32 : 2);
			uint num = rVA & 0xFFFFF000u;
			WriteUInt32(num);
			WriteUInt32(12u);
			if (module.Architecture == TargetArchitecture.I386)
			{
				WriteUInt32(12288 + rVA - num);
				return;
			}
			throw new NotSupportedException();
		}

		public void WriteImage()
		{
			WriteDOSHeader();
			WritePEFileHeader();
			WriteOptionalHeaders();
			WriteSectionHeaders();
			WriteText();
			if (rsrc != null)
			{
				WriteRsrc();
			}
			if (reloc != null)
			{
				WriteReloc();
			}
		}

		private TextMap BuildTextMap()
		{
			TextMap textMap = metadata.text_map;
			textMap.AddMap(TextSegment.Code, metadata.code.length, (!pe64) ? 4 : 16);
			textMap.AddMap(TextSegment.Resources, metadata.resources.length, 8);
			textMap.AddMap(TextSegment.Data, metadata.data.length, 4);
			if (metadata.data.length > 0)
			{
				metadata.table_heap.FixupData(textMap.GetRVA(TextSegment.Data));
			}
			textMap.AddMap(TextSegment.StrongNameSignature, GetStrongNameLength(), 4);
			textMap.AddMap(TextSegment.MetadataHeader, GetMetadataHeaderLength());
			textMap.AddMap(TextSegment.TableHeap, metadata.table_heap.length, 4);
			textMap.AddMap(TextSegment.StringHeap, metadata.string_heap.length, 4);
			textMap.AddMap(TextSegment.UserStringHeap, (!metadata.user_string_heap.IsEmpty) ? metadata.user_string_heap.length : 0, 4);
			textMap.AddMap(TextSegment.GuidHeap, 16);
			textMap.AddMap(TextSegment.BlobHeap, (!metadata.blob_heap.IsEmpty) ? metadata.blob_heap.length : 0, 4);
			int length = 0;
			if (!debug_data.IsNullOrEmpty())
			{
				debug_directory.AddressOfRawData = (int)(textMap.GetNextRVA(TextSegment.BlobHeap) + 28);
				length = debug_data.Length + 28;
			}
			textMap.AddMap(TextSegment.DebugDirectory, length, 4);
			if (!has_reloc)
			{
				uint nextRVA = textMap.GetNextRVA(TextSegment.DebugDirectory);
				textMap.AddMap(TextSegment.ImportDirectory, new Range(nextRVA, 0u));
				textMap.AddMap(TextSegment.ImportHintNameTable, new Range(nextRVA, 0u));
				textMap.AddMap(TextSegment.StartupStub, new Range(nextRVA, 0u));
				return textMap;
			}
			uint nextRVA2 = textMap.GetNextRVA(TextSegment.DebugDirectory);
			uint num = nextRVA2 + 48;
			num = (num + 15) & 0xFFFFFFF0u;
			uint num2 = num - nextRVA2 + 27;
			uint num3 = nextRVA2 + num2;
			num3 = ((module.Architecture == TargetArchitecture.IA64) ? ((num3 + 15) & 0xFFFFFFF0u) : (2 + ((num3 + 3) & 0xFFFFFFFCu)));
			textMap.AddMap(TextSegment.ImportDirectory, new Range(nextRVA2, num2));
			textMap.AddMap(TextSegment.ImportHintNameTable, new Range(num, 0u));
			textMap.AddMap(TextSegment.StartupStub, new Range(num3, GetStartupStubLength()));
			return textMap;
		}

		private uint GetStartupStubLength()
		{
			if (module.Architecture == TargetArchitecture.I386)
			{
				return 6u;
			}
			throw new NotSupportedException();
		}

		private int GetMetadataHeaderLength()
		{
			return 72 + ((!metadata.user_string_heap.IsEmpty) ? 12 : 0) + 16 + ((!metadata.blob_heap.IsEmpty) ? 16 : 0);
		}

		private int GetStrongNameLength()
		{
			if (module.Assembly == null)
			{
				return 0;
			}
			byte[] publicKey = module.Assembly.Name.PublicKey;
			if (publicKey.IsNullOrEmpty())
			{
				return 0;
			}
			int num = publicKey.Length;
			if (num > 32)
			{
				return num - 32;
			}
			return 128;
		}

		public DataDirectory GetStrongNameSignatureDirectory()
		{
			return text_map.GetDataDirectory(TextSegment.StrongNameSignature);
		}

		public uint GetHeaderSize()
		{
			return (uint)(152 + SizeOfOptionalHeader() + sections * 40);
		}

		private void PatchWin32Resources(ByteBuffer resources)
		{
			PatchResourceDirectoryTable(resources);
		}

		private void PatchResourceDirectoryTable(ByteBuffer resources)
		{
			resources.Advance(12);
			int num = resources.ReadUInt16() + resources.ReadUInt16();
			for (int i = 0; i < num; i++)
			{
				PatchResourceDirectoryEntry(resources);
			}
		}

		private void PatchResourceDirectoryEntry(ByteBuffer resources)
		{
			resources.Advance(4);
			uint num = resources.ReadUInt32();
			int position = resources.position;
			resources.position = (int)(num & 0x7FFFFFFF);
			if ((num & 0x80000000u) != 0)
			{
				PatchResourceDirectoryTable(resources);
			}
			else
			{
				PatchResourceDataEntry(resources);
			}
			resources.position = position;
		}

		private void PatchResourceDataEntry(ByteBuffer resources)
		{
			Section imageResourceSection = GetImageResourceSection();
			uint num = resources.ReadUInt32();
			resources.position -= 4;
			resources.WriteUInt32(num - imageResourceSection.VirtualAddress + rsrc.VirtualAddress);
		}
	}
	internal sealed class Section
	{
		public string Name;

		public uint VirtualAddress;

		public uint VirtualSize;

		public uint SizeOfRawData;

		public uint PointerToRawData;

		public byte[] Data;
	}
	internal enum TextSegment
	{
		ImportAddressTable,
		CLIHeader,
		Code,
		Resources,
		Data,
		StrongNameSignature,
		MetadataHeader,
		TableHeap,
		StringHeap,
		UserStringHeap,
		GuidHeap,
		BlobHeap,
		DebugDirectory,
		ImportDirectory,
		ImportHintNameTable,
		StartupStub
	}
	internal sealed class TextMap
	{
		private readonly Range[] map = new Range[16];

		public void AddMap(TextSegment segment, int length)
		{
			map[(int)segment] = new Range(GetStart(segment), (uint)length);
		}

		public void AddMap(TextSegment segment, int length, int align)
		{
			align--;
			AddMap(segment, (length + align) & ~align);
		}

		public void AddMap(TextSegment segment, Range range)
		{
			map[(int)segment] = range;
		}

		public Range GetRange(TextSegment segment)
		{
			return map[(int)segment];
		}

		public DataDirectory GetDataDirectory(TextSegment segment)
		{
			Range range = map[(int)segment];
			return new DataDirectory((range.Length != 0) ? range.Start : 0u, range.Length);
		}

		public uint GetRVA(TextSegment segment)
		{
			return map[(int)segment].Start;
		}

		public uint GetNextRVA(TextSegment segment)
		{
			return map[(int)segment].Start + map[(int)segment].Length;
		}

		public int GetLength(TextSegment segment)
		{
			return (int)map[(int)segment].Length;
		}

		private uint GetStart(TextSegment segment)
		{
			if (segment != TextSegment.ImportAddressTable)
			{
				return ComputeStart((int)segment);
			}
			return 8192u;
		}

		private uint ComputeStart(int index)
		{
			index--;
			return map[index].Start + map[index].Length;
		}

		public uint GetLength()
		{
			Range range = map[15];
			return range.Start - 8192 + range.Length;
		}
	}
}
namespace Mono.Cecil.Metadata
{
	internal sealed class BlobHeap : Heap
	{
		public BlobHeap(Section section, uint start, uint size)
			: base(section, start, size)
		{
		}

		public byte[] Read(uint index)
		{
			if (index == 0 || index > Size - 1)
			{
				return Empty<byte>.Array;
			}
			byte[] data = Section.Data;
			int position = (int)(index + Offset);
			int num = (int)data.ReadCompressedUInt32(ref position);
			byte[] array = new byte[num];
			Buffer.BlockCopy(data, position, array, 0, num);
			return array;
		}
	}
	internal sealed class TableHeapBuffer : HeapBuffer
	{
		private readonly ModuleDefinition module;

		private readonly MetadataBuilder metadata;

		internal MetadataTable[] tables = new MetadataTable[45];

		private bool large_string;

		private bool large_blob;

		private readonly int[] coded_index_sizes = new int[13];

		private readonly Func<Table, int> counter;

		public override bool IsEmpty => false;

		public TableHeapBuffer(ModuleDefinition module, MetadataBuilder metadata)
			: base(24)
		{
			this.module = module;
			this.metadata = metadata;
			counter = GetTableLength;
		}

		private int GetTableLength(Table table)
		{
			return tables[(uint)table]?.Length ?? 0;
		}

		public TTable GetTable<TTable>(Table table) where TTable : MetadataTable, new()
		{
			TTable val = (TTable)tables[(uint)table];
			if (val != null)
			{
				return val;
			}
			val = new TTable();
			tables[(uint)table] = val;
			return val;
		}

		public void WriteBySize(uint value, int size)
		{
			if (size == 4)
			{
				WriteUInt32(value);
			}
			else
			{
				WriteUInt16((ushort)value);
			}
		}

		public void WriteBySize(uint value, bool large)
		{
			if (large)
			{
				WriteUInt32(value);
			}
			else
			{
				WriteUInt16((ushort)value);
			}
		}

		public void WriteString(uint @string)
		{
			WriteBySize(@string, large_string);
		}

		public void WriteBlob(uint blob)
		{
			WriteBySize(blob, large_blob);
		}

		public void WriteRID(uint rid, Table table)
		{
			WriteBySize(rid, tables[(uint)table]?.IsLarge ?? false);
		}

		private int GetCodedIndexSize(CodedIndex coded_index)
		{
			int num = coded_index_sizes[(int)coded_index];
			if (num != 0)
			{
				return num;
			}
			return coded_index_sizes[(int)coded_index] = coded_index.GetSize(counter);
		}

		public void WriteCodedRID(uint rid, CodedIndex coded_index)
		{
			WriteBySize(rid, GetCodedIndexSize(coded_index));
		}

		public void WriteTableHeap()
		{
			WriteUInt32(0u);
			WriteByte(GetTableHeapVersion());
			WriteByte(0);
			WriteByte(GetHeapSizes());
			WriteByte(10);
			WriteUInt64(GetValid());
			WriteUInt64(24190111578624uL);
			WriteRowCount();
			WriteTables();
		}

		private void WriteRowCount()
		{
			for (int i = 0; i < tables.Length; i++)
			{
				MetadataTable metadataTable = tables[i];
				if (metadataTable != null && metadataTable.Length != 0)
				{
					WriteUInt32((uint)metadataTable.Length);
				}
			}
		}

		private void WriteTables()
		{
			for (int i = 0; i < tables.Length; i++)
			{
				MetadataTable metadataTable = tables[i];
				if (metadataTable != null && metadataTable.Length != 0)
				{
					metadataTable.Write(this);
				}
			}
		}

		private ulong GetValid()
		{
			ulong num = 0uL;
			for (int i = 0; i < tables.Length; i++)
			{
				MetadataTable metadataTable = tables[i];
				if (metadataTable != null && metadataTable.Length != 0)
				{
					metadataTable.Sort();
					num |= (ulong)(1L << i);
				}
			}
			return num;
		}

		private byte GetHeapSizes()
		{
			byte b = 0;
			if (metadata.string_heap.IsLarge)
			{
				large_string = true;
				b |= 1;
			}
			if (metadata.blob_heap.IsLarge)
			{
				large_blob = true;
				b |= 4;
			}
			return b;
		}

		private byte GetTableHeapVersion()
		{
			TargetRuntime runtime = module.Runtime;
			if (runtime == TargetRuntime.Net_1_0 || runtime == TargetRuntime.Net_1_1)
			{
				return 1;
			}
			return 2;
		}

		public void FixupData(uint data_rva)
		{
			FieldRVATable table = GetTable<FieldRVATable>(Table.FieldRVA);
			if (table.length != 0)
			{
				int num = (GetTable<FieldTable>(Table.Field).IsLarge ? 4 : 2);
				int num2 = position;
				position = table.position;
				for (int i = 0; i < table.length; i++)
				{
					uint num3 = ReadUInt32();
					position -= 4;
					WriteUInt32(num3 + data_rva);
					position += num;
				}
				position = num2;
			}
		}
	}
	internal sealed class ResourceBuffer : ByteBuffer
	{
		public ResourceBuffer()
			: base(0)
		{
		}

		public uint AddResource(byte[] resource)
		{
			int result = position;
			WriteInt32(resource.Length);
			WriteBytes(resource);
			return (uint)result;
		}
	}
	internal sealed class DataBuffer : ByteBuffer
	{
		public DataBuffer()
			: base(0)
		{
		}

		public uint AddData(byte[] data)
		{
			int result = position;
			WriteBytes(data);
			return (uint)result;
		}
	}
	internal abstract class HeapBuffer : ByteBuffer
	{
		public bool IsLarge => length > 65535;

		public abstract bool IsEmpty { get; }

		protected HeapBuffer(int length)
			: base(length)
		{
		}
	}
	internal class StringHeapBuffer : HeapBuffer
	{
		private readonly Dictionary<string, uint> strings = new Dictionary<string, uint>(StringComparer.Ordinal);

		public sealed override bool IsEmpty => length <= 1;

		public StringHeapBuffer()
			: base(1)
		{
			WriteByte(0);
		}

		public uint GetStringIndex(string @string)
		{
			if (strings.TryGetValue(@string, out var value))
			{
				return value;
			}
			value = (uint)position;
			WriteString(@string);
			strings.Add(@string, value);
			return value;
		}

		protected virtual void WriteString(string @string)
		{
			WriteBytes(Encoding.UTF8.GetBytes(@string));
			WriteByte(0);
		}
	}
	internal sealed class BlobHeapBuffer : HeapBuffer
	{
		private readonly Dictionary<ByteBuffer, uint> blobs = new Dictionary<ByteBuffer, uint>(new ByteBufferEqualityComparer());

		public override bool IsEmpty => length <= 1;

		public BlobHeapBuffer()
			: base(1)
		{
			WriteByte(0);
		}

		public uint GetBlobIndex(ByteBuffer blob)
		{
			if (blobs.TryGetValue(blob, out var value))
			{
				return value;
			}
			value = (uint)position;
			WriteBlob(blob);
			blobs.Add(blob, value);
			return value;
		}

		private void WriteBlob(ByteBuffer blob)
		{
			WriteCompressedUInt32((uint)blob.length);
			WriteBytes(blob);
		}
	}
	internal sealed class UserStringHeapBuffer : StringHeapBuffer
	{
		protected override void WriteString(string @string)
		{
			WriteCompressedUInt32((uint)(@string.Length * 2 + 1));
			byte b = 0;
			foreach (char c in @string)
			{
				WriteUInt16(c);
				if (b != 1 && (c < ' ' || c > '~') && (c > '~' || (c >= '\u0001' && c <= '\b') || (c >= '\u000e' && c <= '\u001f') || c == '\'' || c == '-'))
				{
					b = 1;
				}
			}
			WriteByte(b);
		}
	}
	internal enum CodedIndex
	{
		TypeDefOrRef,
		HasConstant,
		HasCustomAttribute,
		HasFieldMarshal,
		HasDeclSecurity,
		MemberRefParent,
		HasSemantics,
		MethodDefOrRef,
		MemberForwarded,
		Implementation,
		CustomAttributeType,
		ResolutionScope,
		TypeOrMethodDef
	}
	internal enum ElementType : byte
	{
		None = 0,
		Void = 1,
		Boolean = 2,
		Char = 3,
		I1 = 4,
		U1 = 5,
		I2 = 6,
		U2 = 7,
		I4 = 8,
		U4 = 9,
		I8 = 10,
		U8 = 11,
		R4 = 12,
		R8 = 13,
		String = 14,
		Ptr = 15,
		ByRef = 16,
		ValueType = 17,
		Class = 18,
		Var = 19,
		Array = 20,
		GenericInst = 21,
		TypedByRef = 22,
		I = 24,
		U = 25,
		FnPtr = 27,
		Object = 28,
		SzArray = 29,
		MVar = 30,
		CModReqD = 31,
		CModOpt = 32,
		Internal = 33,
		Modifier = 64,
		Sentinel = 65,
		Pinned = 69,
		Type = 80,
		Boxed = 81,
		Enum = 85
	}
	internal sealed class GuidHeap : Heap
	{
		public GuidHeap(Section section, uint start, uint size)
			: base(section, start, size)
		{
		}

		public Guid Read(uint index)
		{
			if (index == 0)
			{
				return default(Guid);
			}
			byte[] array = new byte[16];
			index--;
			Buffer.BlockCopy(Section.Data, (int)(Offset + index), array, 0, 16);
			return new Guid(array);
		}
	}
	internal abstract class Heap
	{
		public int IndexSize;

		public readonly Section Section;

		public readonly uint Offset;

		public readonly uint Size;

		protected Heap(Section section, uint offset, uint size)
		{
			Section = section;
			Offset = offset;
			Size = size;
		}
	}
	internal struct Row<T1, T2>
	{
		internal T1 Col1;

		internal T2 Col2;

		public Row(T1 col1, T2 col2)
		{
			Col1 = col1;
			Col2 = col2;
		}
	}
	internal struct Row<T1, T2, T3>
	{
		internal T1 Col1;

		internal T2 Col2;

		internal T3 Col3;

		public Row(T1 col1, T2 col2, T3 col3)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
		}
	}
	internal struct Row<T1, T2, T3, T4>
	{
		internal T1 Col1;

		internal T2 Col2;

		internal T3 Col3;

		internal T4 Col4;

		public Row(T1 col1, T2 col2, T3 col3, T4 col4)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
			Col4 = col4;
		}
	}
	internal struct Row<T1, T2, T3, T4, T5>
	{
		internal T1 Col1;

		internal T2 Col2;

		internal T3 Col3;

		internal T4 Col4;

		internal T5 Col5;

		public Row(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
			Col4 = col4;
			Col5 = col5;
		}
	}
	internal struct Row<T1, T2, T3, T4, T5, T6>
	{
		internal T1 Col1;

		internal T2 Col2;

		internal T3 Col3;

		internal T4 Col4;

		internal T5 Col5;

		internal T6 Col6;

		public Row(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
			Col4 = col4;
			Col5 = col5;
			Col6 = col6;
		}
	}
	internal struct Row<T1, T2, T3, T4, T5, T6, T7, T8, T9>
	{
		internal T1 Col1;

		internal T2 Col2;

		internal T3 Col3;

		internal T4 Col4;

		internal T5 Col5;

		internal T6 Col6;

		internal T7 Col7;

		internal T8 Col8;

		internal T9 Col9;

		public Row(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6, T7 col7, T8 col8, T9 col9)
		{
			Col1 = col1;
			Col2 = col2;
			Col3 = col3;
			Col4 = col4;
			Col5 = col5;
			Col6 = col6;
			Col7 = col7;
			Col8 = col8;
			Col9 = col9;
		}
	}
	internal sealed class RowEqualityComparer : IEqualityComparer<Row<string, string>>, IEqualityComparer<Row<uint, uint>>, IEqualityComparer<Row<uint, uint, uint>>
	{
		public bool Equals(Row<string, string> x, Row<string, string> y)
		{
			if (x.Col1 == y.Col1)
			{
				return x.Col2 == y.Col2;
			}
			return false;
		}

		public int GetHashCode(Row<string, string> obj)
		{
			string col = obj.Col1;
			string col2 = obj.Col2;
			return (col?.GetHashCode() ?? 0) ^ (col2?.GetHashCode() ?? 0);
		}

		public bool Equals(Row<uint, uint> x, Row<uint, uint> y)
		{
			if (x.Col1 == y.Col1)
			{
				return x.Col2 == y.Col2;
			}
			return false;
		}

		public int GetHashCode(Row<uint, uint> obj)
		{
			return (int)(obj.Col1 ^ obj.Col2);
		}

		public bool Equals(Row<uint, uint, uint> x, Row<uint, uint, uint> y)
		{
			if (x.Col1 == y.Col1 && x.Col2 == y.Col2)
			{
				return x.Col3 == y.Col3;
			}
			return false;
		}

		public int GetHashCode(Row<uint, uint, uint> obj)
		{
			return (int)(obj.Col1 ^ obj.Col2 ^ obj.Col3);
		}
	}
	internal class StringHeap : Heap
	{
		private readonly Dictionary<uint, string> strings = new Dictionary<uint, string>();

		public StringHeap(Section section, uint start, uint size)
			: base(section, start, size)
		{
		}

		public string Read(uint index)
		{
			if (index == 0)
			{
				return string.Empty;
			}
			if (strings.TryGetValue(index, out var value))
			{
				return value;
			}
			if (index > Size - 1)
			{
				return string.Empty;
			}
			value = ReadStringAt(index);
			if (value.Length != 0)
			{
				strings.Add(index, value);
			}
			return value;
		}

		protected virtual string ReadStringAt(uint index)
		{
			int num = 0;
			byte[] data = Section.Data;
			int num2 = (int)(index + Offset);
			for (int i = num2; data[i] != 0; i++)
			{
				num++;
			}
			return Encoding.UTF8.GetString(data, num2, num);
		}
	}
	internal enum Table : byte
	{
		Module,
		TypeRef,
		TypeDef,
		FieldPtr,
		Field,
		MethodPtr,
		Method,
		ParamPtr,
		Param,
		InterfaceImpl,
		MemberRef,
		Constant,
		CustomAttribute,
		FieldMarshal,
		DeclSecurity,
		ClassLayout,
		FieldLayout,
		StandAloneSig,
		EventMap,
		EventPtr,
		Event,
		PropertyMap,
		PropertyPtr,
		Property,
		MethodSemantics,
		MethodImpl,
		ModuleRef,
		TypeSpec,
		ImplMap,
		FieldRVA,
		EncLog,
		EncMap,
		Assembly,
		AssemblyProcessor,
		AssemblyOS,
		AssemblyRef,
		AssemblyRefProcessor,
		AssemblyRefOS,
		File,
		ExportedType,
		ManifestResource,
		NestedClass,
		GenericParam,
		MethodSpec,
		GenericParamConstraint
	}
	internal struct TableInformation
	{
		public uint Offset;

		public uint Length;

		public uint RowSize;
	}
	internal sealed class TableHeap : Heap
	{
		public long Valid;

		public long Sorted;

		public const int TableCount = 45;

		public readonly TableInformation[] Tables = new TableInformation[45];

		public TableInformation this[Table table] => Tables[(uint)table];

		public TableHeap(Section section, uint start, uint size)
			: base(section, start, size)
		{
		}

		public bool HasTable(Table table)
		{
			return (Valid & (1L << (int)table)) != 0;
		}
	}
	internal sealed class UserStringHeap : StringHeap
	{
		public UserStringHeap(Section section, uint start, uint size)
			: base(section, start, size)
		{
		}

		protected override string ReadStringAt(uint index)
		{
			byte[] data = Section.Data;
			int position = (int)(index + Offset);
			uint num = (uint)(data.ReadCompressedUInt32(ref position) & -2);
			if (num < 1)
			{
				return string.Empty;
			}
			char[] array = new char[num / 2];
			int i = position;
			int num2 = 0;
			for (; i < position + num; i += 2)
			{
				array[num2++] = (char)(data[i] | (data[i + 1] << 8));
			}
			return new string(array);
		}
	}
}
namespace Mono.Cecil.Cil
{
	public enum Code
	{
		Nop,
		Break,
		Ldarg_0,
		Ldarg_1,
		Ldarg_2,
		Ldarg_3,
		Ldloc_0,
		Ldloc_1,
		Ldloc_2,
		Ldloc_3,
		Stloc_0,
		Stloc_1,
		Stloc_2,
		Stloc_3,
		Ldarg_S,
		Ldarga_S,
		Starg_S,
		Ldloc_S,
		Ldloca_S,
		Stloc_S,
		Ldnull,
		Ldc_I4_M1,
		Ldc_I4_0,
		Ldc_I4_1,
		Ldc_I4_2,
		Ldc_I4_3,
		Ldc_I4_4,
		Ldc_I4_5,
		Ldc_I4_6,
		Ldc_I4_7,
		Ldc_I4_8,
		Ldc_I4_S,
		Ldc_I4,
		Ldc_I8,
		Ldc_R4,
		Ldc_R8,
		Dup,
		Pop,
		Jmp,
		Call,
		Calli,
		Ret,
		Br_S,
		Brfalse_S,
		Brtrue_S,
		Beq_S,
		Bge_S,
		Bgt_S,
		Ble_S,
		Blt_S,
		Bne_Un_S,
		Bge_Un_S,
		Bgt_Un_S,
		Ble_Un_S,
		Blt_Un_S,
		Br,
		Brfalse,
		Brtrue,
		Beq,
		Bge,
		Bgt,
		Ble,
		Blt,
		Bne_Un,
		Bge_Un,
		Bgt_Un,
		Ble_Un,
		Blt_Un,
		Switch,
		Ldind_I1,
		Ldind_U1,
		Ldind_I2,
		Ldind_U2,
		Ldind_I4,
		Ldind_U4,
		Ldind_I8,
		Ldind_I,
		Ldind_R4,
		Ldind_R8,
		Ldind_Ref,
		Stind_Ref,
		Stind_I1,
		Stind_I2,
		Stind_I4,
		Stind_I8,
		Stind_R4,
		Stind_R8,
		Add,
		Sub,
		Mul,
		Div,
		Div_Un,
		Rem,
		Rem_Un,
		And,
		Or,
		Xor,
		Shl,
		Shr,
		Shr_Un,
		Neg,
		Not,
		Conv_I1,
		Conv_I2,
		Conv_I4,
		Conv_I8,
		Conv_R4,
		Conv_R8,
		Conv_U4,
		Conv_U8,
		Callvirt,
		Cpobj,
		Ldobj,
		Ldstr,
		Newobj,
		Castclass,
		Isinst,
		Conv_R_Un,
		Unbox,
		Throw,
		Ldfld,
		Ldflda,
		Stfld,
		Ldsfld,
		Ldsflda,
		Stsfld,
		Stobj,
		Conv_Ovf_I1_Un,
		Conv_Ovf_I2_Un,
		Conv_Ovf_I4_Un,
		Conv_Ovf_I8_Un,
		Conv_Ovf_U1_Un,
		Conv_Ovf_U2_Un,
		Conv_Ovf_U4_Un,
		Conv_Ovf_U8_Un,
		Conv_Ovf_I_Un,
		Conv_Ovf_U_Un,
		Box,
		Newarr,
		Ldlen,
		Ldelema,
		Ldelem_I1,
		Ldelem_U1,
		Ldelem_I2,
		Ldelem_U2,
		Ldelem_I4,
		Ldelem_U4,
		Ldelem_I8,
		Ldelem_I,
		Ldelem_R4,
		Ldelem_R8,
		Ldelem_Ref,
		Stelem_I,
		Stelem_I1,
		Stelem_I2,
		Stelem_I4,
		Stelem_I8,
		Stelem_R4,
		Stelem_R8,
		Stelem_Ref,
		Ldelem_Any,
		Stelem_Any,
		Unbox_Any,
		Conv_Ovf_I1,
		Conv_Ovf_U1,
		Conv_Ovf_I2,
		Conv_Ovf_U2,
		Conv_Ovf_I4,
		Conv_Ovf_U4,
		Conv_Ovf_I8,
		Conv_Ovf_U8,
		Refanyval,
		Ckfinite,
		Mkrefany,
		Ldtoken,
		Conv_U2,
		Conv_U1,
		Conv_I,
		Conv_Ovf_I,
		Conv_Ovf_U,
		Add_Ovf,
		Add_Ovf_Un,
		Mul_Ovf,
		Mul_Ovf_Un,
		Sub_Ovf,
		Sub_Ovf_Un,
		Endfinally,
		Leave,
		Leave_S,
		Stind_I,
		Conv_U,
		Arglist,
		Ceq,
		Cgt,
		Cgt_Un,
		Clt,
		Clt_Un,
		Ldftn,
		Ldvirtftn,
		Ldarg,
		Ldarga,
		Starg,
		Ldloc,
		Ldloca,
		Stloc,
		Localloc,
		Endfilter,
		Unaligned,
		Volatile,
		Tail,
		Initobj,
		Constrained,
		Cpblk,
		Initblk,
		No,
		Rethrow,
		Sizeof,
		Refanytype,
		Readonly
	}
	internal sealed class CodeWriter : ByteBuffer
	{
		private readonly uint code_base;

		internal readonly MetadataBuilder metadata;

		private readonly Dictionary<uint, MetadataToken> standalone_signatures;

		private uint current;

		private MethodBody body;

		public CodeWriter(MetadataBuilder metadata)
			: base(0)
		{
			code_base = metadata.text_map.GetNextRVA(TextSegment.CLIHeader);
			current = code_base;
			this.metadata = metadata;
			standalone_signatures = new Dictionary<uint, MetadataToken>();
		}

		public uint WriteMethodBody(MethodDefinition method)
		{
			uint result = BeginMethod();
			if (IsUnresolved(method))
			{
				if (method.rva == 0)
				{
					return 0u;
				}
				WriteUnresolvedMethodBody(method);
			}
			else
			{
				if (IsEmptyMethodBody(method.Body))
				{
					return 0u;
				}
				WriteResolvedMethodBody(method);
			}
			Align(4);
			EndMethod();
			return result;
		}

		private static bool IsEmptyMethodBody(MethodBody body)
		{
			if (body.instructions.IsNullOrEmpty())
			{
				return body.variables.IsNullOrEmpty();
			}
			return false;
		}

		private static bool IsUnresolved(MethodDefinition method)
		{
			if (method.HasBody && method.HasImage)
			{
				return method.body == null;
			}
			return false;
		}

		private void WriteUnresolvedMethodBody(MethodDefinition method)
		{
			MethodSymbols symbols;
			ByteBuffer byteBuffer = metadata.module.Read(method, (MethodDefinition _, MetadataReader reader) => reader.code).PatchRawMethodBody(method, this, out symbols);
			WriteBytes(byteBuffer);
			if (!symbols.instructions.IsNullOrEmpty())
			{
				symbols.method_token = method.token;
				symbols.local_var_token = GetLocalVarToken(byteBuffer, symbols);
				metadata.symbol_writer?.Write(symbols);
			}
		}

		private static MetadataToken GetLocalVarToken(ByteBuffer buffer, MethodSymbols symbols)
		{
			if (symbols.variables.IsNullOrEmpty())
			{
				return MetadataToken.Zero;
			}
			buffer.position = 8;
			return new MetadataToken(buffer.ReadUInt32());
		}

		private void WriteResolvedMethodBody(MethodDefinition method)
		{
			body = method.Body;
			ComputeHeader();
			if (RequiresFatHeader())
			{
				WriteFatHeader();
			}
			else
			{
				WriteByte((byte)(2 | (body.CodeSize << 2)));
			}
			WriteInstructions();
			if (body.HasExceptionHandlers)
			{
				WriteExceptionHandlers();
			}
			metadata.symbol_writer?.Write(body);
		}

		private void WriteFatHeader()
		{
			MethodBody methodBody = body;
			byte b = 3;
			if (methodBody.InitLocals)
			{
				b |= 0x10;
			}
			if (methodBody.HasExceptionHandlers)
			{
				b |= 8;
			}
			WriteByte(b);
			WriteByte(48);
			WriteInt16((short)methodBody.max_stack_size);
			WriteInt32(methodBody.code_size);
			methodBody.local_var_token = (methodBody.HasVariables ? GetStandAloneSignature(methodBody.Variables) : MetadataToken.Zero);
			WriteMetadataToken(methodBody.local_var_token);
		}

		private void WriteInstructions()
		{
			Mono.Collections.Generic.Collection<Instruction> instructions = body.Instructions;
			Instruction[] items = instructions.items;
			int size = instructions.size;
			for (int i = 0; i < size; i++)
			{
				Instruction instruction = items[i];
				WriteOpCode(instruction.opcode);
				WriteOperand(instruction);
			}
		}

		private void WriteOpCode(OpCode opcode)
		{
			if (opcode.Size == 1)
			{
				WriteByte(opcode.Op2);
				return;
			}
			WriteByte(opcode.Op1);
			WriteByte(opcode.Op2);
		}

		private void WriteOperand(Instruction instruction)
		{
			OpCode opcode = instruction.opcode;
			OperandType operandType = opcode.OperandType;
			if (operandType == OperandType.InlineNone)
			{
				return;
			}
			object operand = instruction.operand;
			if (operand == null)
			{
				throw new ArgumentException();
			}
			switch (operandType)
			{
			case OperandType.InlineSwitch:
			{
				Instruction[] array = (Instruction[])operand;
				WriteInt32(array.Length);
				int num = instruction.Offset + opcode.Size + 4 * (array.Length + 1);
				for (int i = 0; i < array.Length; i++)
				{
					WriteInt32(GetTargetOffset(array[i]) - num);
				}
				break;
			}
			case OperandType.ShortInlineBrTarget:
			{
				Instruction instruction2 = (Instruction)operand;
				WriteSByte((sbyte)(GetTargetOffset(instruction2) - (instruction.Offset + opcode.Size + 1)));
				break;
			}
			case OperandType.InlineBrTarget:
			{
				Instruction instruction3 = (Instruction)operand;
				WriteInt32(GetTargetOffset(instruction3) - (instruction.Offset + opcode.Size + 4));
				break;
			}
			case OperandType.ShortInlineVar:
				WriteByte((byte)GetVariableIndex((VariableDefinition)operand));
				break;
			case OperandType.ShortInlineArg:
				WriteByte((byte)GetParameterIndex((ParameterDefinition)operand));
				break;
			case OperandType.InlineVar:
				WriteInt16((short)GetVariableIndex((VariableDefinition)operand));
				break;
			case OperandType.InlineArg:
				WriteInt16((short)GetParameterIndex((ParameterDefinition)operand));
				break;
			case OperandType.InlineSig:
				WriteMetadataToken(GetStandAloneSignature((CallSite)operand));
				break;
			case OperandType.ShortInlineI:
				if (opcode == OpCodes.Ldc_I4_S)
				{
					WriteSByte((sbyte)operand);
				}
				else
				{
					WriteByte((byte)operand);
				}
				break;
			case OperandType.InlineI:
				WriteInt32((int)operand);
				break;
			case OperandType.InlineI8:
				WriteInt64((long)operand);
				break;
			case OperandType.ShortInlineR:
				WriteSingle((float)operand);
				break;
			case OperandType.InlineR:
				WriteDouble((double)operand);
				break;
			case OperandType.InlineString:
				WriteMetadataToken(new MetadataToken(TokenType.String, GetUserStringIndex((string)operand)));
				break;
			case OperandType.InlineField:
			case OperandType.InlineMethod:
			case OperandType.InlineTok:
			case OperandType.InlineType:
				WriteMetadataToken(metadata.LookupToken((IMetadataTokenProvider)operand));
				break;
			default:
				throw new ArgumentException();
			}
		}

		private int GetTargetOffset(Instruction instruction)
		{
			if (instruction == null)
			{
				Instruction instruction2 = body.instructions[body.instructions.size - 1];
				return instruction2.offset + instruction2.GetSize();
			}
			return instruction.offset;
		}

		private uint GetUserStringIndex(string @string)
		{
			if (@string == null)
			{
				return 0u;
			}
			return metadata.user_string_heap.GetStringIndex(@string);
		}

		private static int GetVariableIndex(VariableDefinition variable)
		{
			return variable.Index;
		}

		private int GetParameterIndex(ParameterDefinition parameter)
		{
			if (body.method.HasThis)
			{
				if (parameter == body.this_parameter)
				{
					return 0;
				}
				return parameter.Index + 1;
			}
			return parameter.Index;
		}

		private bool RequiresFatHeader()
		{
			MethodBody methodBody = body;
			if (methodBody.CodeSize < 64 && !methodBody.InitLocals && !methodBody.HasVariables && !methodBody.HasExceptionHandlers)
			{
				return methodBody.MaxStackSize > 8;
			}
			return true;
		}

		private void ComputeHeader()
		{
			int num = 0;
			Mono.Collections.Generic.Collection<Instruction> instructions = body.instructions;
			Instruction[] items = instructions.items;
			int size = instructions.size;
			int stack_size = 0;
			int max_stack = 0;
			Dictionary<Instruction, int> stack_sizes = null;
			if (body.HasExceptionHandlers)
			{
				ComputeExceptionHandlerStackSize(ref stack_sizes);
			}
			for (int i = 0; i < size; i++)
			{
				Instruction instruction = items[i];
				instruction.offset = num;
				num += instruction.GetSize();
				ComputeStackSize(instruction, ref stack_sizes, ref stack_size, ref max_stack);
			}
			body.code_size = num;
			body.max_stack_size = max_stack;
		}

		private void ComputeExceptionHandlerStackSize(ref Dictionary<Instruction, int> stack_sizes)
		{
			Mono.Collections.Generic.Collection<ExceptionHandler> exceptionHandlers = body.ExceptionHandlers;
			for (int i = 0; i < exceptionHandlers.Count; i++)
			{
				ExceptionHandler exceptionHandler = exceptionHandlers[i];
				switch (exceptionHandler.HandlerType)
				{
				case ExceptionHandlerType.Catch:
					AddExceptionStackSize(exceptionHandler.HandlerStart, ref stack_sizes);
					break;
				case ExceptionHandlerType.Filter:
					AddExceptionStackSize(exceptionHandler.FilterStart, ref stack_sizes);
					AddExceptionStackSize(exceptionHandler.HandlerStart, ref stack_sizes);
					break;
				}
			}
		}

		private static void AddExceptionStackSize(Instruction handler_start, ref Dictionary<Instruction, int> stack_sizes)
		{
			if (handler_start != null)
			{
				if (stack_sizes == null)
				{
					stack_sizes = new Dictionary<Instruction, int>();
				}
				stack_sizes[handler_start] = 1;
			}
		}

		private static void ComputeStackSize(Instruction instruction, ref Dictionary<Instruction, int> stack_sizes, ref int stack_size, ref int max_stack)
		{
			if (stack_sizes != null && stack_sizes.TryGetValue(instruction, out var value))
			{
				stack_size = value;
			}
			max_stack = System.Math.Max(max_stack, stack_size);
			ComputeStackDelta(instruction, ref stack_size);
			max_stack = System.Math.Max(max_stack, stack_size);
			CopyBranchStackSize(instruction, ref stack_sizes, stack_size);
			ComputeStackSize(instruction, ref stack_size);
		}

		private static void CopyBranchStackSize(Instruction instruction, ref Dictionary<Instruction, int> stack_sizes, int stack_size)
		{
			if (stack_size == 0)
			{
				return;
			}
			switch (instruction.opcode.OperandType)
			{
			case OperandType.InlineBrTarget:
			case OperandType.ShortInlineBrTarget:
				CopyBranchStackSize(ref stack_sizes, (Instruction)instruction.operand, stack_size);
				break;
			case OperandType.InlineSwitch:
			{
				Instruction[] array = (Instruction[])instruction.operand;
				for (int i = 0; i < array.Length; i++)
				{
					CopyBranchStackSize(ref stack_sizes, array[i], stack_size);
				}
				break;
			}
			}
		}

		private static void CopyBranchStackSize(ref Dictionary<Instruction, int> stack_sizes, Instruction target, int stack_size)
		{
			if (stack_sizes == null)
			{
				stack_sizes = new Dictionary<Instruction, int>();
			}
			int num = stack_size;
			if (stack_sizes.TryGetValue(target, out var value))
			{
				num = System.Math.Max(num, value);
			}
			stack_sizes[target] = num;
		}

		private static void ComputeStackSize(Instruction instruction, ref int stack_size)
		{
			switch (instruction.opcode.FlowControl)
			{
			case FlowControl.Branch:
			case FlowControl.Break:
			case FlowControl.Return:
			case FlowControl.Throw:
				stack_size = 0;
				break;
			}
		}

		private static void ComputeStackDelta(Instruction instruction, ref int stack_size)
		{
			FlowControl flowControl = instruction.opcode.FlowControl;
			if (flowControl == FlowControl.Call)
			{
				IMethodSignature methodSignature = (IMethodSignature)instruction.operand;
				if (methodSignature.HasImplicitThis() && instruction.opcode.Code != Code.Newobj)
				{
					stack_size--;
				}
				if (methodSignature.HasParameters)
				{
					stack_size -= methodSignature.Parameters.Count;
				}
				if (instruction.opcode.Code == Code.Calli)
				{
					stack_size--;
				}
				if (methodSignature.ReturnType.etype != ElementType.Void || instruction.opcode.Code == Code.Newobj)
				{
					stack_size++;
				}
			}
			else
			{
				ComputePopDelta(instruction.opcode.StackBehaviourPop, ref stack_size);
				ComputePushDelta(instruction.opcode.StackBehaviourPush, ref stack_size);
			}
		}

		private static void ComputePopDelta(StackBehaviour pop_behavior, ref int stack_size)
		{
			switch (pop_behavior)
			{
			case StackBehaviour.Pop1:
			case StackBehaviour.Popi:
			case StackBehaviour.Popref:
				stack_size--;
				break;
			case StackBehaviour.Pop1_pop1:
			case StackBehaviour.Popi_pop1:
			case StackBehaviour.Popi_popi:
			case StackBehaviour.Popi_popi8:
			case StackBehaviour.Popi_popr4:
			case StackBehaviour.Popi_popr8:
			case StackBehaviour.Popref_pop1:
			case StackBehaviour.Popref_popi:
				stack_size -= 2;
				break;
			case StackBehaviour.Popi_popi_popi:
			case StackBehaviour.Popref_popi_popi:
			case StackBehaviour.Popref_popi_popi8:
			case StackBehaviour.Popref_popi_popr4:
			case StackBehaviour.Popref_popi_popr8:
			case StackBehaviour.Popref_popi_popref:
				stack_size -= 3;
				break;
			case StackBehaviour.PopAll:
				stack_size = 0;
				break;
			}
		}

		private static void ComputePushDelta(StackBehaviour push_behaviour, ref int stack_size)
		{
			switch (push_behaviour)
			{
			case StackBehaviour.Push1:
			case StackBehaviour.Pushi:
			case StackBehaviour.Pushi8:
			case StackBehaviour.Pushr4:
			case StackBehaviour.Pushr8:
			case StackBehaviour.Pushref:
				stack_size++;
				break;
			case StackBehaviour.Push1_push1:
				stack_size += 2;
				break;
			}
		}

		private void WriteExceptionHandlers()
		{
			Align(4);
			Mono.Collections.Generic.Collection<ExceptionHandler> exceptionHandlers = body.ExceptionHandlers;
			if (exceptionHandlers.Count < 21 && !RequiresFatSection(exceptionHandlers))
			{
				WriteSmallSection(exceptionHandlers);
			}
			else
			{
				WriteFatSection(exceptionHandlers);
			}
		}

		private static bool RequiresFatSection(Mono.Collections.Generic.Collection<ExceptionHandler> handlers)
		{
			for (int i = 0; i < handlers.Count; i++)
			{
				ExceptionHandler exceptionHandler = handlers[i];
				if (IsFatRange(exceptionHandler.TryStart, exceptionHandler.TryEnd))
				{
					return true;
				}
				if (IsFatRange(exceptionHandler.HandlerStart, exceptionHandler.HandlerEnd))
				{
					return true;
				}
				if (exceptionHandler.HandlerType == ExceptionHandlerType.Filter && IsFatRange(exceptionHandler.FilterStart, exceptionHandler.HandlerStart))
				{
					return true;
				}
			}
			return false;
		}

		private static bool IsFatRange(Instruction start, Instruction end)
		{
			if (start == null)
			{
				throw new ArgumentException();
			}
			if (end == null)
			{
				return true;
			}
			if (end.Offset - start.Offset <= 255)
			{
				return start.Offset > 65535;
			}
			return true;
		}

		private void WriteSmallSection(Mono.Collections.Generic.Collection<ExceptionHandler> handlers)
		{
			WriteByte(1);
			WriteByte((byte)(handlers.Count * 12 + 4));
			WriteBytes(2);
			WriteExceptionHandlers(handlers, delegate(int i)
			{
				WriteUInt16((ushort)i);
			}, delegate(int i)
			{
				WriteByte((byte)i);
			});
		}

		private void WriteFatSection(Mono.Collections.Generic.Collection<ExceptionHandler> handlers)
		{
			WriteByte(65);
			int num = handlers.Count * 24 + 4;
			WriteByte((byte)(num & 0xFF));
			WriteByte((byte)((num >> 8) & 0xFF));
			WriteByte((byte)((num >> 16) & 0xFF));
			WriteExceptionHandlers(handlers, base.WriteInt32, base.WriteInt32);
		}

		private void WriteExceptionHandlers(Mono.Collections.Generic.Collection<ExceptionHandler> handlers, Action<int> write_entry, Action<int> write_length)
		{
			for (int i = 0; i < handlers.Count; i++)
			{
				ExceptionHandler exceptionHandler = handlers[i];
				write_entry((int)exceptionHandler.HandlerType);
				write_entry(exceptionHandler.TryStart.Offset);
				write_length(GetTargetOffset(exceptionHandler.TryEnd) - exceptionHandler.TryStart.Offset);
				write_entry(exceptionHandler.HandlerStart.Offset);
				write_length(GetTargetOffset(exceptionHandler.HandlerEnd) - exceptionHandler.HandlerStart.Offset);
				WriteExceptionHandlerSpecific(exceptionHandler);
			}
		}

		private void WriteExceptionHandlerSpecific(ExceptionHandler handler)
		{
			switch (handler.HandlerType)
			{
			case ExceptionHandlerType.Catch:
				WriteMetadataToken(metadata.LookupToken(handler.CatchType));
				break;
			case ExceptionHandlerType.Filter:
				WriteInt32(handler.FilterStart.Offset);
				break;
			default:
				WriteInt32(0);
				break;
			}
		}

		public MetadataToken GetStandAloneSignature(Mono.Collections.Generic.Collection<VariableDefinition> variables)
		{
			uint localVariableBlobIndex = metadata.GetLocalVariableBlobIndex(variables);
			return GetStandAloneSignatureToken(localVariableBlobIndex);
		}

		public MetadataToken GetStandAloneSignature(CallSite call_site)
		{
			uint callSiteBlobIndex = metadata.GetCallSiteBlobIndex(call_site);
			return call_site.MetadataToken = GetStandAloneSignatureToken(callSiteBlobIndex);
		}

		private MetadataToken GetStandAloneSignatureToken(uint signature)
		{
			if (standalone_signatures.TryGetValue(signature, out var value))
			{
				return value;
			}
			value = new MetadataToken(TokenType.Signature, metadata.AddStandAloneSignature(signature));
			standalone_signatures.Add(signature, value);
			return value;
		}

		private uint BeginMethod()
		{
			return current;
		}

		private void WriteMetadataToken(MetadataToken token)
		{
			WriteUInt32(token.ToUInt32());
		}

		private void Align(int align)
		{
			align--;
			WriteBytes(((position + align) & ~align) - position);
		}

		private void EndMethod()
		{
			current = (uint)(code_base + position);
		}
	}
	internal sealed class CodeReader : ByteBuffer
	{
		internal readonly MetadataReader reader;

		private int start;

		private Section code_section;

		private MethodDefinition method;

		private MethodBody body;

		private int Offset => position - start;

		public CodeReader(Section section, MetadataReader reader)
			: base(section.Data)
		{
			code_section = section;
			this.reader = reader;
		}

		public MethodBody ReadMethodBody(MethodDefinition method)
		{
			this.method = method;
			body = new MethodBody(method);
			reader.context = method;
			ReadMethodBody();
			return body;
		}

		public void MoveTo(int rva)
		{
			if (!IsInSection(rva))
			{
				code_section = reader.image.GetSectionAtVirtualAddress((uint)rva);
				Reset(code_section.Data);
			}
			position = rva - (int)code_section.VirtualAddress;
		}

		private bool IsInSection(int rva)
		{
			if (code_section.VirtualAddress <= rva)
			{
				return rva < code_section.VirtualAddress + code_section.SizeOfRawData;
			}
			return false;
		}

		private void ReadMethodBody()
		{
			MoveTo(method.RVA);
			byte b = ReadByte();
			switch (b & 3)
			{
			case 2:
				body.code_size = b >> 2;
				body.MaxStackSize = 8;
				ReadCode();
				break;
			case 3:
				position--;
				ReadFatMethod();
				break;
			default:
				throw new InvalidOperationException();
			}
			ISymbolReader symbol_reader = reader.module.symbol_reader;
			if (symbol_reader != null)
			{
				Mono.Collections.Generic.Collection<Instruction> instructions = body.Instructions;
				symbol_reader.Read(body, (int offset) => GetInstruction(instructions, offset));
			}
		}

		private void ReadFatMethod()
		{
			ushort num = ReadUInt16();
			body.max_stack_size = ReadUInt16();
			body.code_size = (int)ReadUInt32();
			body.local_var_token = new MetadataToken(ReadUInt32());
			body.init_locals = (num & 0x10) != 0;
			if (body.local_var_token.RID != 0)
			{
				body.variables = ReadVariables(body.local_var_token);
			}
			ReadCode();
			if ((num & 8) != 0)
			{
				ReadSection();
			}
		}

		public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token)
		{
			int num = reader.position;
			VariableDefinitionCollection result = reader.ReadVariables(local_var_token);
			reader.position = num;
			return result;
		}

		private void ReadCode()
		{
			start = position;
			int num = body.code_size;
			if (num < 0 || buffer.Length <= (uint)(num + position))
			{
				num = 0;
			}
			int num2 = start + num;
			Mono.Collections.Generic.Collection<Instruction> collection = (body.instructions = new InstructionCollection((num + 1) / 2));
			while (position < num2)
			{
				int offset = position - start;
				OpCode opCode = ReadOpCode();
				Instruction instruction = new Instruction(offset, opCode);
				if (opCode.OperandType != OperandType.InlineNone)
				{
					instruction.operand = ReadOperand(instruction);
				}
				collection.Add(instruction);
			}
			ResolveBranches(collection);
		}

		private OpCode ReadOpCode()
		{
			byte b = ReadByte();
			if (b == 254)
			{
				return OpCodes.TwoBytesOpCode[ReadByte()];
			}
			return OpCodes.OneByteOpCode[b];
		}

		private object ReadOperand(Instruction instruction)
		{
			switch (instruction.opcode.OperandType)
			{
			case OperandType.InlineSwitch:
			{
				int num = ReadInt32();
				int num2 = Offset + 4 * num;
				int[] array = new int[num];
				for (int i = 0; i < num; i++)
				{
					array[i] = num2 + ReadInt32();
				}
				return array;
			}
			case OperandType.ShortInlineBrTarget:
				return ReadSByte() + Offset;
			case OperandType.InlineBrTarget:
				return ReadInt32() + Offset;
			case OperandType.ShortInlineI:
				if (instruction.opcode == OpCodes.Ldc_I4_S)
				{
					return ReadSByte();
				}
				return ReadByte();
			case OperandType.InlineI:
				return ReadInt32();
			case OperandType.ShortInlineR:
				return ReadSingle();
			case OperandType.InlineR:
				return ReadDouble();
			case OperandType.InlineI8:
				return ReadInt64();
			case OperandType.ShortInlineVar:
				return GetVariable(ReadByte());
			case OperandType.InlineVar:
				return GetVariable(ReadUInt16());
			case OperandType.ShortInlineArg:
				return GetParameter(ReadByte());
			case OperandType.InlineArg:
				return GetParameter(ReadUInt16());
			case OperandType.InlineSig:
				return GetCallSite(ReadToken());
			case OperandType.InlineString:
				return GetString(ReadToken());
			case OperandType.InlineField:
			case OperandType.InlineMethod:
			case OperandType.InlineTok:
			case OperandType.InlineType:
				return reader.LookupToken(ReadToken());
			default:
				throw new NotSupportedException();
			}
		}

		public string GetString(MetadataToken token)
		{
			return reader.image.UserStringHeap.Read(token.RID);
		}

		public ParameterDefinition GetParameter(int index)
		{
			return body.GetParameter(index);
		}

		public VariableDefinition GetVariable(int index)
		{
			return body.GetVariable(index);
		}

		public CallSite GetCallSite(MetadataToken token)
		{
			return reader.ReadCallSite(token);
		}

		private void ResolveBranches(Mono.Collections.Generic.Collection<Instruction> instructions)
		{
			Instruction[] items = instructions.items;
			int size = instructions.size;
			for (int i = 0; i < size; i++)
			{
				Instruction instruction = items[i];
				switch (instruction.opcode.OperandType)
				{
				case OperandType.InlineBrTarget:
				case OperandType.ShortInlineBrTarget:
					instruction.operand = GetInstruction((int)instruction.operand);
					break;
				case OperandType.InlineSwitch:
				{
					int[] array = (int[])instruction.operand;
					Instruction[] array2 = new Instruction[array.Length];
					for (int j = 0; j < array.Length; j++)
					{
						array2[j] = GetInstruction(array[j]);
					}
					instruction.operand = array2;
					break;
				}
				}
			}
		}

		private Instruction GetInstruction(int offset)
		{
			return GetInstruction(body.Instructions, offset);
		}

		private static Instruction GetInstruction(Mono.Collections.Generic.Collection<Instruction> instructions, int offset)
		{
			int size = instructions.size;
			Instruction[] items = instructions.items;
			if (offset < 0 || offset > items[size - 1].offset)
			{
				return null;
			}
			int num = 0;
			int num2 = size - 1;
			while (num <= num2)
			{
				int num3 = num + (num2 - num) / 2;
				Instruction instruction = items[num3];
				int offset2 = instruction.offset;
				if (offset == offset2)
				{
					return instruction;
				}
				if (offset < offset2)
				{
					num2 = num3 - 1;
				}
				else
				{
					num = num3 + 1;
				}
			}
			return null;
		}

		private void ReadSection()
		{
			Align(4);
			byte num = ReadByte();
			if ((num & 0x40) == 0)
			{
				ReadSmallSection();
			}
			else
			{
				ReadFatSection();
			}
			if ((num & 0x80) != 0)
			{
				ReadSection();
			}
		}

		private void ReadSmallSection()
		{
			int count = ReadByte() / 12;
			Advance(2);
			ReadExceptionHandlers(count, () => ReadUInt16(), () => ReadByte());
		}

		private void ReadFatSection()
		{
			position--;
			int count = (ReadInt32() >> 8) / 24;
			ReadExceptionHandlers(count, base.ReadInt32, base.ReadInt32);
		}

		private void ReadExceptionHandlers(int count, Func<int> read_entry, Func<int> read_length)
		{
			for (int i = 0; i < count; i++)
			{
				ExceptionHandler exceptionHandler = new ExceptionHandler((ExceptionHandlerType)(read_entry() & 7));
				exceptionHandler.TryStart = GetInstruction(read_entry());
				exceptionHandler.TryEnd = GetInstruction(exceptionHandler.TryStart.Offset + read_length());
				exceptionHandler.HandlerStart = GetInstruction(read_entry());
				exceptionHandler.HandlerEnd = GetInstruction(exceptionHandler.HandlerStart.Offset + read_length());
				ReadExceptionHandlerSpecific(exceptionHandler);
				body.ExceptionHandlers.Add(exceptionHandler);
			}
		}

		private void ReadExceptionHandlerSpecific(ExceptionHandler handler)
		{
			switch (handler.HandlerType)
			{
			case ExceptionHandlerType.Catch:
				handler.CatchType = (TypeReference)reader.LookupToken(ReadToken());
				break;
			case ExceptionHandlerType.Filter:
				handler.FilterStart = GetInstruction(ReadInt32());
				break;
			default:
				Advance(4);
				break;
			}
		}

		private void Align(int align)
		{
			align--;
			Advance(((position + align) & ~align) - position);
		}

		public MetadataToken ReadToken()
		{
			return new MetadataToken(ReadUInt32());
		}

		public ByteBuffer PatchRawMethodBody(MethodDefinition method, CodeWriter writer, out MethodSymbols symbols)
		{
			ByteBuffer byteBuffer = new ByteBuffer();
			symbols = new MethodSymbols(method.Name);
			this.method = method;
			reader.context = method;
			MoveTo(method.RVA);
			byte b = ReadByte();
			MetadataToken local_var_token;
			switch (b & 3)
			{
			case 2:
				byteBuffer.WriteByte(b);
				local_var_token = MetadataToken.Zero;
				symbols.code_size = b >> 2;
				PatchRawCode(byteBuffer, symbols.code_size, writer);
				break;
			case 3:
				position--;
				PatchRawFatMethod(byteBuffer, symbols, writer, out local_var_token);
				break;
			default:
				throw new NotSupportedException();
			}
			ISymbolReader symbol_reader = reader.module.symbol_reader;
			if (symbol_reader != null && writer.metadata.write_symbols)
			{
				symbols.method_token = GetOriginalToken(writer.metadata, method);
				symbols.local_var_token = local_var_token;
				symbol_reader.Read(symbols);
			}
			return byteBuffer;
		}

		private void PatchRawFatMethod(ByteBuffer buffer, MethodSymbols symbols, CodeWriter writer, out MetadataToken local_var_token)
		{
			ushort num = ReadUInt16();
			buffer.WriteUInt16(num);
			buffer.WriteUInt16(ReadUInt16());
			symbols.code_size = ReadInt32();
			buffer.WriteInt32(symbols.code_size);
			local_var_token = ReadToken();
			if (local_var_token.RID != 0)
			{
				buffer.WriteUInt32(((symbols.variables = ReadVariables(local_var_token)) != null) ? writer.GetStandAloneSignature(symbols.variables).ToUInt32() : 0u);
			}
			else
			{
				buffer.WriteUInt32(0u);
			}
			PatchRawCode(buffer, symbols.code_size, writer);
			if ((num & 8) != 0)
			{
				PatchRawSection(buffer, writer.metadata);
			}
		}

		private static MetadataToken GetOriginalToken(MetadataBuilder metadata, MethodDefinition method)
		{
			if (metadata.TryGetOriginalMethodToken(method.token, out var original))
			{
				return original;
			}
			return MetadataToken.Zero;
		}

		private void PatchRawCode(ByteBuffer buffer, int code_size, CodeWriter writer)
		{
			MetadataBuilder metadata = writer.metadata;
			buffer.WriteBytes(ReadBytes(code_size));
			int num = buffer.position;
			buffer.position -= code_size;
			while (buffer.position < num)
			{
				byte b = buffer.ReadByte();
				OpCode opCode;
				if (b != 254)
				{
					opCode = OpCodes.OneByteOpCode[b];
				}
				else
				{
					byte b2 = buffer.ReadByte();
					opCode = OpCodes.TwoBytesOpCode[b2];
				}
				switch (opCode.OperandType)
				{
				case OperandType.ShortInlineBrTarget:
				case OperandType.ShortInlineI:
				case OperandType.ShortInlineVar:
				case OperandType.ShortInlineArg:
					buffer.position++;
					break;
				case OperandType.InlineVar:
				case OperandType.InlineArg:
					buffer.position += 2;
					break;
				case OperandType.InlineBrTarget:
				case OperandType.InlineI:
				case OperandType.ShortInlineR:
					buffer.position += 4;
					break;
				case OperandType.InlineI8:
				case OperandType.InlineR:
					buffer.position += 8;
					break;
				case OperandType.InlineSwitch:
				{
					int num2 = buffer.ReadInt32();
					buffer.position += num2 * 4;
					break;
				}
				case OperandType.InlineString:
				{
					string text = GetString(new MetadataToken(buffer.ReadUInt32()));
					buffer.position -= 4;
					buffer.WriteUInt32(new MetadataToken(TokenType.String, metadata.user_string_heap.GetStringIndex(text)).ToUInt32());
					break;
				}
				case OperandType.InlineSig:
				{
					CallSite callSite = GetCallSite(new MetadataToken(buffer.ReadUInt32()));
					buffer.position -= 4;
					buffer.WriteUInt32(writer.GetStandAloneSignature(callSite).ToUInt32());
					break;
				}
				case OperandType.InlineField:
				case OperandType.InlineMethod:
				case OperandType.InlineTok:
				case OperandType.InlineType:
				{
					IMetadataTokenProvider provider = reader.LookupToken(new MetadataToken(buffer.ReadUInt32()));
					buffer.position -= 4;
					buffer.WriteUInt32(metadata.LookupToken(provider).ToUInt32());
					break;
				}
				}
			}
		}

		private void PatchRawSection(ByteBuffer buffer, MetadataBuilder metadata)
		{
			int num = position;
			Align(4);
			buffer.WriteBytes(position - num);
			byte b = ReadByte();
			if ((b & 0x40) == 0)
			{
				buffer.WriteByte(b);
				PatchRawSmallSection(buffer, metadata);
			}
			else
			{
				PatchRawFatSection(buffer, metadata);
			}
			if ((b & 0x80) != 0)
			{
				PatchRawSection(buffer, metadata);
			}
		}

		private void PatchRawSmallSection(ByteBuffer buffer, MetadataBuilder metadata)
		{
			byte b = ReadByte();
			buffer.WriteByte(b);
			Advance(2);
			buffer.WriteUInt16(0);
			int count = b / 12;
			PatchRawExceptionHandlers(buffer, metadata, count, fat_entry: false);
		}

		private void PatchRawFatSection(ByteBuffer buffer, MetadataBuilder metadata)
		{
			position--;
			int num = ReadInt32();
			buffer.WriteInt32(num);
			int count = (num >> 8) / 24;
			PatchRawExceptionHandlers(buffer, metadata, count, fat_entry: true);
		}

		private void PatchRawExceptionHandlers(ByteBuffer buffer, MetadataBuilder metadata, int count, bool fat_entry)
		{
			for (int i = 0; i < count; i++)
			{
				ExceptionHandlerType exceptionHandlerType;
				if (fat_entry)
				{
					uint num = ReadUInt32();
					exceptionHandlerType = (ExceptionHandlerType)(num & 7);
					buffer.WriteUInt32(num);
				}
				else
				{
					ushort num2 = ReadUInt16();
					exceptionHandlerType = (ExceptionHandlerType)(num2 & 7);
					buffer.WriteUInt16(num2);
				}
				buffer.WriteBytes(ReadBytes(fat_entry ? 16 : 6));
				if (exceptionHandlerType == ExceptionHandlerType.Catch)
				{
					IMetadataTokenProvider provider = reader.LookupToken(ReadToken());
					buffer.WriteUInt32(metadata.LookupToken(provider).ToUInt32());
				}
				else
				{
					buffer.WriteUInt32(ReadUInt32());
				}
			}
		}
	}
	public enum DocumentType
	{
		Other,
		Text
	}
	public enum DocumentHashAlgorithm
	{
		None,
		MD5,
		SHA1
	}
	public enum DocumentLanguage
	{
		Other,
		C,
		Cpp,
		CSharp,
		Basic,
		Java,
		Cobol,
		Pascal,
		Cil,
		JScript,
		Smc,
		MCpp,
		FSharp
	}
	public enum DocumentLanguageVendor
	{
		Other,
		Microsoft
	}
	public sealed class Document
	{
		private string url;

		private byte type;

		private byte hash_algorithm;

		private byte language;

		private byte language_vendor;

		private byte[] hash;

		public string Url
		{
			get
			{
				return url;
			}
			set
			{
				url = value;
			}
		}

		public DocumentType Type
		{
			get
			{
				return (DocumentType)type;
			}
			set
			{
				type = (byte)value;
			}
		}

		public DocumentHashAlgorithm HashAlgorithm
		{
			get
			{
				return (DocumentHashAlgorithm)hash_algorithm;
			}
			set
			{
				hash_algorithm = (byte)value;
			}
		}

		public DocumentLanguage Language
		{
			get
			{
				return (DocumentLanguage)language;
			}
			set
			{
				language = (byte)value;
			}
		}

		public DocumentLanguageVendor LanguageVendor
		{
			get
			{
				return (DocumentLanguageVendor)language_vendor;
			}
			set
			{
				language_vendor = (byte)value;
			}
		}

		public byte[] Hash
		{
			get
			{
				return hash;
			}
			set
			{
				hash = value;
			}
		}

		public Document(string url)
		{
			this.url = url;
			hash = Empty<byte>.Array;
		}
	}
	public enum ExceptionHandlerType
	{
		Catch = 0,
		Filter = 1,
		Finally = 2,
		Fault = 4
	}
	public sealed class ExceptionHandler
	{
		private Instruction try_start;

		private Instruction try_end;

		private Instruction filter_start;

		private Instruction handler_start;

		private Instruction handler_end;

		private TypeReference catch_type;

		private ExceptionHandlerType handler_type;

		public Instruction TryStart
		{
			get
			{
				return try_start;
			}
			set
			{
				try_start = value;
			}
		}

		public Instruction TryEnd
		{
			get
			{
				return try_end;
			}
			set
			{
				try_end = value;
			}
		}

		public Instruction FilterStart
		{
			get
			{
				return filter_start;
			}
			set
			{
				filter_start = value;
			}
		}

		public Instruction HandlerStart
		{
			get
			{
				return handler_start;
			}
			set
			{
				handler_start = value;
			}
		}

		public Instruction HandlerEnd
		{
			get
			{
				return handler_end;
			}
			set
			{
				handler_end = value;
			}
		}

		public TypeReference CatchType
		{
			get
			{
				return catch_type;
			}
			set
			{
				catch_type = value;
			}
		}

		public ExceptionHandlerType HandlerType
		{
			get
			{
				return handler_type;
			}
			set
			{
				handler_type = value;
			}
		}

		public ExceptionHandler(ExceptionHandlerType handlerType)
		{
			handler_type = handlerType;
		}
	}
	public sealed class ILProcessor
	{
		private readonly MethodBody body;

		private readonly Mono.Collections.Generic.Collection<Instruction> instructions;

		public MethodBody Body => body;

		internal ILProcessor(MethodBody body)
		{
			this.body = body;
			instructions = body.Instructions;
		}

		public Instruction Create(OpCode opcode)
		{
			return Instruction.Create(opcode);
		}

		public Instruction Create(OpCode opcode, TypeReference type)
		{
			return Instruction.Create(opcode, type);
		}

		public Instruction Create(OpCode opcode, CallSite site)
		{
			return Instruction.Create(opcode, site);
		}

		public Instruction Create(OpCode opcode, MethodReference method)
		{
			return Instruction.Create(opcode, method);
		}

		public Instruction Create(OpCode opcode, FieldReference field)
		{
			return Instruction.Create(opcode, field);
		}

		public Instruction Create(OpCode opcode, string value)
		{
			return Instruction.Create(opcode, value);
		}

		public Instruction Create(OpCode opcode, sbyte value)
		{
			return Instruction.Create(opcode, value);
		}

		public Instruction Create(OpCode opcode, byte value)
		{
			if (opcode.OperandType == OperandType.ShortInlineVar)
			{
				return Instruction.Create(opcode, body.Variables[value]);
			}
			if (opcode.OperandType == OperandType.ShortInlineArg)
			{
				return Instruction.Create(opcode, body.GetParameter(value));
			}
			return Instruction.Create(opcode, value);
		}

		public Instruction Create(OpCode opcode, int value)
		{
			if (opcode.OperandType == OperandType.InlineVar)
			{
				return Instruction.Create(opcode, body.Variables[value]);
			}
			if (opcode.OperandType == OperandType.InlineArg)
			{
				return Instruction.Create(opcode, body.GetParameter(value));
			}
			return Instruction.Create(opcode, value);
		}

		public Instruction Create(OpCode opcode, long value)
		{
			return Instruction.Create(opcode, value);
		}

		public Instruction Create(OpCode opcode, float value)
		{
			return Instruction.Create(opcode, value);
		}

		public Instruction Create(OpCode opcode, double value)
		{
			return Instruction.Create(opcode, value);
		}

		public Instruction Create(OpCode opcode, Instruction target)
		{
			return Instruction.Create(opcode, target);
		}

		public Instruction Create(OpCode opcode, Instruction[] targets)
		{
			return Instruction.Create(opcode, targets);
		}

		public Instruction Create(OpCode opcode, VariableDefinition variable)
		{
			return Instruction.Create(opcode, variable);
		}

		public Instruction Create(OpCode opcode, ParameterDefinition parameter)
		{
			return Instruction.Create(opcode, parameter);
		}

		public void Emit(OpCode opcode)
		{
			Append(Create(opcode));
		}

		public void Emit(OpCode opcode, TypeReference type)
		{
			Append(Create(opcode, type));
		}

		public void Emit(OpCode opcode, MethodReference method)
		{
			Append(Create(opcode, method));
		}

		public void Emit(OpCode opcode, CallSite site)
		{
			Append(Create(opcode, site));
		}

		public void Emit(OpCode opcode, FieldReference field)
		{
			Append(Create(opcode, field));
		}

		public void Emit(OpCode opcode, string value)
		{
			Append(Create(opcode, value));
		}

		public void Emit(OpCode opcode, byte value)
		{
			Append(Create(opcode, value));
		}

		public void Emit(OpCode opcode, sbyte value)
		{
			Append(Create(opcode, value));
		}

		public void Emit(OpCode opcode, int value)
		{
			Append(Create(opcode, value));
		}

		public void Emit(OpCode opcode, long value)
		{
			Append(Create(opcode, value));
		}

		public void Emit(OpCode opcode, float value)
		{
			Append(Create(opcode, value));
		}

		public void Emit(OpCode opcode, double value)
		{
			Append(Create(opcode, value));
		}

		public void Emit(OpCode opcode, Instruction target)
		{
			Append(Create(opcode, target));
		}

		public void Emit(OpCode opcode, Instruction[] targets)
		{
			Append(Create(opcode, targets));
		}

		public void Emit(OpCode opcode, VariableDefinition variable)
		{
			Append(Create(opcode, variable));
		}

		public void Emit(OpCode opcode, ParameterDefinition parameter)
		{
			Append(Create(opcode, parameter));
		}

		public void InsertBefore(Instruction target, Instruction instruction)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (instruction == null)
			{
				throw new ArgumentNullException("instruction");
			}
			int num = instructions.IndexOf(target);
			if (num == -1)
			{
				throw new ArgumentOutOfRangeException("target");
			}
			instructions.Insert(num, instruction);
		}

		public void InsertAfter(Instruction target, Instruction instruction)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (instruction == null)
			{
				throw new ArgumentNullException("instruction");
			}
			int num = instructions.IndexOf(target);
			if (num == -1)
			{
				throw new ArgumentOutOfRangeException("target");
			}
			instructions.Insert(num + 1, instruction);
		}

		public void Append(Instruction instruction)
		{
			if (instruction == null)
			{
				throw new ArgumentNullException("instruction");
			}
			instructions.Add(instruction);
		}

		public void Replace(Instruction target, Instruction instruction)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (instruction == null)
			{
				throw new ArgumentNullException("instruction");
			}
			InsertAfter(target, instruction);
			Remove(target);
		}

		public void Remove(Instruction instruction)
		{
			if (instruction == null)
			{
				throw new ArgumentNullException("instruction");
			}
			if (!instructions.Remove(instruction))
			{
				throw new ArgumentOutOfRangeException("instruction");
			}
		}
	}
	public sealed class Instruction
	{
		internal int offset;

		internal OpCode opcode;

		internal object operand;

		internal Instruction previous;

		internal Instruction next;

		private SequencePoint sequence_point;

		public int Offset
		{
			get
			{
				return offset;
			}
			set
			{
				offset = value;
			}
		}

		public OpCode OpCode
		{
			get
			{
				return opcode;
			}
			set
			{
				opcode = value;
			}
		}

		public object Operand
		{
			get
			{
				return operand;
			}
			set
			{
				operand = value;
			}
		}

		public Instruction Previous
		{
			get
			{
				return previous;
			}
			set
			{
				previous = value;
			}
		}

		public Instruction Next
		{
			get
			{
				return next;
			}
			set
			{
				next = value;
			}
		}

		public SequencePoint SequencePoint
		{
			get
			{
				return sequence_point;
			}
			set
			{
				sequence_point = value;
			}
		}

		internal Instruction(int offset, OpCode opCode)
		{
			this.offset = offset;
			opcode = opCode;
		}

		internal Instruction(OpCode opcode, object operand)
		{
			this.opcode = opcode;
			this.operand = operand;
		}

		public int GetSize()
		{
			int size = opcode.Size;
			switch (opcode.OperandType)
			{
			case OperandType.InlineSwitch:
				return size + (1 + ((Instruction[])operand).Length) * 4;
			case OperandType.InlineI8:
			case OperandType.InlineR:
				return size + 8;
			case OperandType.InlineBrTarget:
			case OperandType.InlineField:
			case OperandType.InlineI:
			case OperandType.InlineMethod:
			case OperandType.InlineSig:
			case OperandType.InlineString:
			case OperandType.InlineTok:
			case OperandType.InlineType:
			case OperandType.ShortInlineR:
				return size + 4;
			case OperandType.InlineVar:
			case OperandType.InlineArg:
				return size + 2;
			case OperandType.ShortInlineBrTarget:
			case OperandType.ShortInlineI:
			case OperandType.ShortInlineVar:
			case OperandType.ShortInlineArg:
				return size + 1;
			default:
				return size;
			}
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			AppendLabel(stringBuilder, this);
			stringBuilder.Append(':');
			stringBuilder.Append(' ');
			stringBuilder.Append(opcode.Name);
			if (operand == null)
			{
				return stringBuilder.ToString();
			}
			stringBuilder.Append(' ');
			switch (opcode.OperandType)
			{
			case OperandType.InlineBrTarget:
			case OperandType.ShortInlineBrTarget:
				AppendLabel(stringBuilder, (Instruction)operand);
				break;
			case OperandType.InlineSwitch:
			{
				Instruction[] array = (Instruction[])operand;
				for (int i = 0; i < array.Length; i++)
				{
					if (i > 0)
					{
						stringBuilder.Append(',');
					}
					AppendLabel(stringBuilder, array[i]);
				}
				break;
			}
			case OperandType.InlineString:
				stringBuilder.Append('"');
				stringBuilder.Append(operand);
				stringBuilder.Append('"');
				break;
			default:
				stringBuilder.Append(operand);
				break;
			}
			return stringBuilder.ToString();
		}

		private static void AppendLabel(StringBuilder builder, Instruction instruction)
		{
			builder.Append("IL_");
			builder.Append(instruction.offset.ToString("x4"));
		}

		public static Instruction Create(OpCode opcode)
		{
			if (opcode.OperandType != OperandType.InlineNone)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, null);
		}

		public static Instruction Create(OpCode opcode, TypeReference type)
		{
			if (type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (opcode.OperandType != OperandType.InlineType && opcode.OperandType != OperandType.InlineTok)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, type);
		}

		public static Instruction Create(OpCode opcode, CallSite site)
		{
			if (site == null)
			{
				throw new ArgumentNullException("site");
			}
			if (opcode.Code != Code.Calli)
			{
				throw new ArgumentException("code");
			}
			return new Instruction(opcode, site);
		}

		public static Instruction Create(OpCode opcode, MethodReference method)
		{
			if (method == null)
			{
				throw new ArgumentNullException("method");
			}
			if (opcode.OperandType != OperandType.InlineMethod && opcode.OperandType != OperandType.InlineTok)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, method);
		}

		public static Instruction Create(OpCode opcode, FieldReference field)
		{
			if (field == null)
			{
				throw new ArgumentNullException("field");
			}
			if (opcode.OperandType != OperandType.InlineField && opcode.OperandType != OperandType.InlineTok)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, field);
		}

		public static Instruction Create(OpCode opcode, string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (opcode.OperandType != OperandType.InlineString)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, value);
		}

		public static Instruction Create(OpCode opcode, sbyte value)
		{
			if (opcode.OperandType != OperandType.ShortInlineI && opcode != OpCodes.Ldc_I4_S)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, value);
		}

		public static Instruction Create(OpCode opcode, byte value)
		{
			if (opcode.OperandType != OperandType.ShortInlineI || opcode == OpCodes.Ldc_I4_S)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, value);
		}

		public static Instruction Create(OpCode opcode, int value)
		{
			if (opcode.OperandType != OperandType.InlineI)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, value);
		}

		public static Instruction Create(OpCode opcode, long value)
		{
			if (opcode.OperandType != OperandType.InlineI8)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, value);
		}

		public static Instruction Create(OpCode opcode, float value)
		{
			if (opcode.OperandType != OperandType.ShortInlineR)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, value);
		}

		public static Instruction Create(OpCode opcode, double value)
		{
			if (opcode.OperandType != OperandType.InlineR)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, value);
		}

		public static Instruction Create(OpCode opcode, Instruction target)
		{
			if (target == null)
			{
				throw new ArgumentNullException("target");
			}
			if (opcode.OperandType != OperandType.InlineBrTarget && opcode.OperandType != OperandType.ShortInlineBrTarget)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, target);
		}

		public static Instruction Create(OpCode opcode, Instruction[] targets)
		{
			if (targets == null)
			{
				throw new ArgumentNullException("targets");
			}
			if (opcode.OperandType != OperandType.InlineSwitch)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, targets);
		}

		public static Instruction Create(OpCode opcode, VariableDefinition variable)
		{
			if (variable == null)
			{
				throw new ArgumentNullException("variable");
			}
			if (opcode.OperandType != OperandType.ShortInlineVar && opcode.OperandType != OperandType.InlineVar)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, variable);
		}

		public static Instruction Create(OpCode opcode, ParameterDefinition parameter)
		{
			if (parameter == null)
			{
				throw new ArgumentNullException("parameter");
			}
			if (opcode.OperandType != OperandType.ShortInlineArg && opcode.OperandType != OperandType.InlineArg)
			{
				throw new ArgumentException("opcode");
			}
			return new Instruction(opcode, parameter);
		}
	}
	public sealed class MethodBody : IVariableDefinitionProvider
	{
		internal readonly MethodDefinition method;

		internal ParameterDefinition this_parameter;

		internal int max_stack_size;

		internal int code_size;

		internal bool init_locals;

		internal MetadataToken local_var_token;

		internal Mono.Collections.Generic.Collection<Instruction> instructions;

		internal Mono.Collections.Generic.Collection<ExceptionHandler> exceptions;

		internal Mono.Collections.Generic.Collection<VariableDefinition> variables;

		private Scope scope;

		public MethodDefinition Method => method;

		public int MaxStackSize
		{
			get
			{
				return max_stack_size;
			}
			set
			{
				max_stack_size = value;
			}
		}

		public int CodeSize => code_size;

		public bool InitLocals
		{
			get
			{
				return init_locals;
			}
			set
			{
				init_locals = value;
			}
		}

		public MetadataToken LocalVarToken
		{
			get
			{
				return local_var_token;
			}
			set
			{
				local_var_token = value;
			}
		}

		public Mono.Collections.Generic.Collection<Instruction> Instructions => instructions ?? (instructions = new InstructionCollection());

		public bool HasExceptionHandlers => !exceptions.IsNullOrEmpty();

		public Mono.Collections.Generic.Collection<ExceptionHandler> ExceptionHandlers => exceptions ?? (exceptions = new Mono.Collections.Generic.Collection<ExceptionHandler>());

		public bool HasVariables => !variables.IsNullOrEmpty();

		public Mono.Collections.Generic.Collection<VariableDefinition> Variables => variables ?? (variables = new VariableDefinitionCollection());

		public Scope Scope
		{
			get
			{
				return scope;
			}
			set
			{
				scope = value;
			}
		}

		public ParameterDefinition ThisParameter
		{
			get
			{
				if (method == null || method.DeclaringType == null)
				{
					throw new NotSupportedException();
				}
				if (!method.HasThis)
				{
					return null;
				}
				if (this_parameter == null)
				{
					Interlocked.CompareExchange(ref this_parameter, CreateThisParameter(method), null);
				}
				return this_parameter;
			}
		}

		private static ParameterDefinition CreateThisParameter(MethodDefinition method)
		{
			TypeDefinition declaringType = method.DeclaringType;
			return new ParameterDefinition((declaringType.IsValueType || declaringType.IsPrimitive) ? ((TypeReference)new PointerType(declaringType)) : ((TypeReference)declaringType), method);
		}

		public MethodBody(MethodDefinition method)
		{
			this.method = method;
		}

		public ILProcessor GetILProcessor()
		{
			return new ILProcessor(this);
		}
	}
	public interface IVariableDefinitionProvider
	{
		bool HasVariables { get; }

		Mono.Collections.Generic.Collection<VariableDefinition> Variables { get; }
	}
	internal class VariableDefinitionCollection : Mono.Collections.Generic.Collection<VariableDefinition>
	{
		internal VariableDefinitionCollection()
		{
		}

		internal VariableDefinitionCollection(int capacity)
			: base(capacity)
		{
		}

		protected override void OnAdd(VariableDefinition item, int index)
		{
			item.index = index;
		}

		protected override void OnInsert(VariableDefinition item, int index)
		{
			item.index = index;
			for (int i = index; i < size; i++)
			{
				items[i].index = i + 1;
			}
		}

		protected override void OnSet(VariableDefinition item, int index)
		{
			item.index = index;
		}

		protected override void OnRemove(VariableDefinition item, int index)
		{
			item.index = -1;
			for (int i = index + 1; i < size; i++)
			{
				items[i].index = i - 1;
			}
		}
	}
	internal class InstructionCollection : Mono.Collections.Generic.Collection<Instruction>
	{
		internal InstructionCollection()
		{
		}

		internal InstructionCollection(int capacity)
			: base(capacity)
		{
		}

		protected override void OnAdd(Instruction item, int index)
		{
			if (index != 0)
			{
				Instruction instruction = items[index - 1];
				instruction.next = item;
				item.previous = instruction;
			}
		}

		protected override void OnInsert(Instruction item, int index)
		{
			if (size == 0)
			{
				return;
			}
			Instruction instruction = items[index];
			if (instruction == null)
			{
				Instruction instruction2 = items[index - 1];
				instruction2.next = item;
				item.previous = instruction2;
				return;
			}
			Instruction previous = instruction.previous;
			if (previous != null)
			{
				previous.next = item;
				item.previous = previous;
			}
			instruction.previous = item;
			item.next = instruction;
		}

		protected override void OnSet(Instruction item, int index)
		{
			Instruction instruction = items[index];
			item.previous = instruction.previous;
			item.next = instruction.next;
			instruction.previous = null;
			instruction.next = null;
		}

		protected override void OnRemove(Instruction item, int index)
		{
			Instruction previous = item.previous;
			if (previous != null)
			{
				previous.next = item.next;
			}
			Instruction next = item.next;
			if (next != null)
			{
				next.previous = item.previous;
			}
			item.previous = null;
			item.next = null;
		}
	}
	public enum FlowControl
	{
		Branch,
		Break,
		Call,
		Cond_Branch,
		Meta,
		Next,
		Phi,
		Return,
		Throw
	}
	public enum OpCodeType
	{
		Annotation,
		Macro,
		Nternal,
		Objmodel,
		Prefix,
		Primitive
	}
	public enum OperandType
	{
		InlineBrTarget,
		InlineField,
		InlineI,
		InlineI8,
		InlineMethod,
		InlineNone,
		InlinePhi,
		InlineR,
		InlineSig,
		InlineString,
		InlineSwitch,
		InlineTok,
		InlineType,
		InlineVar,
		InlineArg,
		ShortInlineBrTarget,
		ShortInlineI,
		ShortInlineR,
		ShortInlineVar,
		ShortInlineArg
	}
	public enum StackBehaviour
	{
		Pop0,
		Pop1,
		Pop1_pop1,
		Popi,
		Popi_pop1,
		Popi_popi,
		Popi_popi8,
		Popi_popi_popi,
		Popi_popr4,
		Popi_popr8,
		Popref,
		Popref_pop1,
		Popref_popi,
		Popref_popi_popi,
		Popref_popi_popi8,
		Popref_popi_popr4,
		Popref_popi_popr8,
		Popref_popi_popref,
		PopAll,
		Push0,
		Push1,
		Push1_push1,
		Pushi,
		Pushi8,
		Pushr4,
		Pushr8,
		Pushref,
		Varpop,
		Varpush
	}
	public struct OpCode
	{
		private readonly byte op1;

		private readonly byte op2;

		private readonly byte code;

		private readonly byte flow_control;

		private readonly byte opcode_type;

		private readonly byte operand_type;

		private readonly byte stack_behavior_pop;

		private readonly byte stack_behavior_push;

		public string Name => OpCodeNames.names[(int)Code];

		public int Size
		{
			get
			{
				if (op1 != byte.MaxValue)
				{
					return 2;
				}
				return 1;
			}
		}

		public byte Op1 => op1;

		public byte Op2 => op2;

		public short Value
		{
			get
			{
				if (op1 != byte.MaxValue)
				{
					return (short)((op1 << 8) | op2);
				}
				return op2;
			}
		}

		public Code Code => (Code)code;

		public FlowControl FlowControl => (FlowControl)flow_control;

		public OpCodeType OpCodeType => (OpCodeType)opcode_type;

		public OperandType OperandType => (OperandType)operand_type;

		public StackBehaviour StackBehaviourPop => (StackBehaviour)stack_behavior_pop;

		public StackBehaviour StackBehaviourPush => (StackBehaviour)stack_behavior_push;

		internal OpCode(int x, int y)
		{
			op1 = (byte)(x & 0xFF);
			op2 = (byte)((x >> 8) & 0xFF);
			code = (byte)((x >> 16) & 0xFF);
			flow_control = (byte)((x >> 24) & 0xFF);
			opcode_type = (byte)(y & 0xFF);
			operand_type = (byte)((y >> 8) & 0xFF);
			stack_behavior_pop = (byte)((y >> 16) & 0xFF);
			stack_behavior_push = (byte)((y >> 24) & 0xFF);
			if (op1 == byte.MaxValue)
			{
				OpCodes.OneByteOpCode[op2] = this;
			}
			else
			{
				OpCodes.TwoBytesOpCode[op2] = this;
			}
		}

		public override int GetHashCode()
		{
			return Value;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is OpCode opCode))
			{
				return false;
			}
			if (op1 == opCode.op1)
			{
				return op2 == opCode.op2;
			}
			return false;
		}

		public bool Equals(OpCode opcode)
		{
			if (op1 == opcode.op1)
			{
				return op2 == opcode.op2;
			}
			return false;
		}

		public static bool operator ==(OpCode one, OpCode other)
		{
			if (one.op1 == other.op1)
			{
				return one.op2 == other.op2;
			}
			return false;
		}

		public static bool operator !=(OpCode one, OpCode other)
		{
			if (one.op1 == other.op1)
			{
				return one.op2 != other.op2;
			}
			return true;
		}

		public override string ToString()
		{
			return Name;
		}
	}
	internal static class OpCodeNames
	{
		internal static readonly string[] names;

		static OpCodeNames()
		{
			byte[] array = new byte[1790]
			{
				3, 110, 111, 112, 5, 98, 114, 101, 97, 107,
				7, 108, 100, 97, 114, 103, 46, 48, 7, 108,
				100, 97, 114, 103, 46, 49, 7, 108, 100, 97,
				114, 103, 46, 50, 7, 108, 100, 97, 114, 103,
				46, 51, 7, 108, 100, 108, 111, 99, 46, 48,
				7, 108, 100, 108, 111, 99, 46, 49, 7, 108,
				100, 108, 111, 99, 46, 50, 7, 108, 100, 108,
				111, 99, 46, 51, 7, 115, 116, 108, 111, 99,
				46, 48, 7, 115, 116, 108, 111, 99, 46, 49,
				7, 115, 116, 108, 111, 99, 46, 50, 7, 115,
				116, 108, 111, 99, 46, 51, 7, 108, 100, 97,
				114, 103, 46, 115, 8, 108, 100, 97, 114, 103,
				97, 46, 115, 7, 115, 116, 97, 114, 103, 46,
				115, 7, 108, 100, 108, 111, 99, 46, 115, 8,
				108, 100, 108, 111, 99, 97, 46, 115, 7, 115,
				116, 108, 111, 99, 46, 115, 6, 108, 100, 110,
				117, 108, 108, 9, 108, 100, 99, 46, 105, 52,
				46, 109, 49, 8, 108, 100, 99, 46, 105, 52,
				46, 48, 8, 108, 100, 99, 46, 105, 52, 46,
				49, 8, 108, 100, 99, 46, 105, 52, 46, 50,
				8, 108, 100, 99, 46, 105, 52, 46, 51, 8,
				108, 100, 99, 46, 105, 52, 46, 52, 8, 108,
				100, 99, 46, 105, 52, 46, 53, 8, 108, 100,
				99, 46, 105, 52, 46, 54, 8, 108, 100, 99,
				46, 105, 52, 46, 55, 8, 108, 100, 99, 46,
				105, 52, 46, 56, 8, 108, 100, 99, 46, 105,
				52, 46, 115, 6, 108, 100, 99, 46, 105, 52,
				6, 108, 100, 99, 46, 105, 56, 6, 108, 100,
				99, 46, 114, 52, 6, 108, 100, 99, 46, 114,
				56, 3, 100, 117, 112, 3, 112, 111, 112, 3,
				106, 109, 112, 4, 99, 97, 108, 108, 5, 99,
				97, 108, 108, 105, 3, 114, 101, 116, 4, 98,
				114, 46, 115, 9, 98, 114, 102, 97, 108, 115,
				101, 46, 115, 8, 98, 114, 116, 114, 117, 101,
				46, 115, 5, 98, 101, 113, 46, 115, 5, 98,
				103, 101, 46, 115, 5, 98, 103, 116, 46, 115,
				5, 98, 108, 101, 46, 115, 5, 98, 108, 116,
				46, 115, 8, 98, 110, 101, 46, 117, 110, 46,
				115, 8, 98, 103, 101, 46, 117, 110, 46, 115,
				8, 98, 103, 116, 46, 117, 110, 46, 115, 8,
				98, 108, 101, 46, 117, 110, 46, 115, 8, 98,
				108, 116, 46, 117, 110, 46, 115, 2, 98, 114,
				7, 98, 114, 102, 97, 108, 115, 101, 6, 98,
				114, 116, 114, 117, 101, 3, 98, 101, 113, 3,
				98, 103, 101, 3, 98, 103, 116, 3, 98, 108,
				101, 3, 98, 108, 116, 6, 98, 110, 101, 46,
				117, 110, 6, 98, 103, 101, 46, 117, 110, 6,
				98, 103, 116, 46, 117, 110, 6, 98, 108, 101,
				46, 117, 110, 6, 98, 108, 116, 46, 117, 110,
				6, 115, 119, 105, 116, 99, 104, 8, 108, 100,
				105, 110, 100, 46, 105, 49, 8, 108, 100, 105,
				110, 100, 46, 117, 49, 8, 108, 100, 105, 110,
				100, 46, 105, 50, 8, 108, 100, 105, 110, 100,
				46, 117, 50, 8, 108, 100, 105, 110, 100, 46,
				105, 52, 8, 108, 100, 105, 110, 100, 46, 117,
				52, 8, 108, 100, 105, 110, 100, 46, 105, 56,
				7, 108, 100, 105, 110, 100, 46, 105, 8, 108,
				100, 105, 110, 100, 46, 114, 52, 8, 108, 100,
				105, 110, 100, 46, 114, 56, 9, 108, 100, 105,
				110, 100, 46, 114, 101, 102, 9, 115, 116, 105,
				110, 100, 46, 114, 101, 102, 8, 115, 116, 105,
				110, 100, 46, 105, 49, 8, 115, 116, 105, 110,
				100, 46, 105, 50, 8, 115, 116, 105, 110, 100,
				46, 105, 52, 8, 115, 116, 105, 110, 100, 46,
				105, 56, 8, 115, 116, 105, 110, 100, 46, 114,
				52, 8, 115, 116, 105, 110, 100, 46, 114, 56,
				3, 97, 100, 100, 3, 115, 117, 98, 3, 109,
				117, 108, 3, 100, 105, 118, 6, 100, 105, 118,
				46, 117, 110, 3, 114, 101, 109, 6, 114, 101,
				109, 46, 117, 110, 3, 97, 110, 100, 2, 111,
				114, 3, 120, 111, 114, 3, 115, 104, 108, 3,
				115, 104, 114, 6, 115, 104, 114, 46, 117, 110,
				3, 110, 101, 103, 3, 110, 111, 116, 7, 99,
				111, 110, 118, 46, 105, 49, 7, 99, 111, 110,
				118, 46, 105, 50, 7, 99, 111, 110, 118, 46,
				105, 52, 7, 99, 111, 110, 118, 46, 105, 56,
				7, 99, 111, 110, 118, 46, 114, 52, 7, 99,
				111, 110, 118, 46, 114, 56, 7, 99, 111, 110,
				118, 46, 117, 52, 7, 99, 111, 110, 118, 46,
				117, 56, 8, 99, 97, 108, 108, 118, 105, 114,
				116, 5, 99, 112, 111, 98, 106, 5, 108, 100,
				111, 98, 106, 5, 108, 100, 115, 116, 114, 6,
				110, 101, 119, 111, 98, 106, 9, 99, 97, 115,
				116, 99, 108, 97, 115, 115, 6, 105, 115, 105,
				110, 115, 116, 9, 99, 111, 110, 118, 46, 114,
				46, 117, 110, 5, 117, 110, 98, 111, 120, 5,
				116, 104, 114, 111, 119, 5, 108, 100, 102, 108,
				100, 6, 108, 100, 102, 108, 100, 97, 5, 115,
				116, 102, 108, 100, 6, 108, 100, 115, 102, 108,
				100, 7, 108, 100, 115, 102, 108, 100, 97, 6,
				115, 116, 115, 102, 108, 100, 5, 115, 116, 111,
				98, 106, 14, 99, 111, 110, 118, 46, 111, 118,
				102, 46, 105, 49, 46, 117, 110, 14, 99, 111,
				110, 118, 46, 111, 118, 102, 46, 105, 50, 46,
				117, 110, 14, 99, 111, 110, 118, 46, 111, 118,
				102, 46, 105, 52, 46, 117, 110, 14, 99, 111,
				110, 118, 46, 111, 118, 102, 46, 105, 56, 46,
				117, 110, 14, 99, 111, 110, 118, 46, 111, 118,
				102, 46, 117, 49, 46, 117, 110, 14, 99, 111,
				110, 118, 46, 111, 118, 102, 46, 117, 50, 46,
				117, 110, 14, 99, 111, 110, 118, 46, 111, 118,
				102, 46, 117, 52, 46, 117, 110, 14, 99, 111,
				110, 118, 46, 111, 118, 102, 46, 117, 56, 46,
				117, 110, 13, 99, 111, 110, 118, 46, 111, 118,
				102, 46, 105, 46, 117, 110, 13, 99, 111, 110,
				118, 46, 111, 118, 102, 46, 117, 46, 117, 110,
				3, 98, 111, 120, 6, 110, 101, 119, 97, 114,
				114, 5, 108, 100, 108, 101, 110, 7, 108, 100,
				101, 108, 101, 109, 97, 9, 108, 100, 101, 108,
				101, 109, 46, 105, 49, 9, 108, 100, 101, 108,
				101, 109, 46, 117, 49, 9, 108, 100, 101, 108,
				101, 109, 46, 105, 50, 9, 108, 100, 101, 108,
				101, 109, 46, 117, 50, 9, 108, 100, 101, 108,
				101, 109, 46, 105, 52, 9, 108, 100, 101, 108,
				101, 109, 46, 117, 52, 9, 108, 100, 101, 108,
				101, 109, 46, 105, 56, 8, 108, 100, 101, 108,
				101, 109, 46, 105, 9, 108, 100, 101, 108, 101,
				109, 46, 114, 52, 9, 108, 100, 101, 108, 101,
				109, 46, 114, 56, 10, 108, 100, 101, 108, 101,
				109, 46, 114, 101, 102, 8, 115, 116, 101, 108,
				101, 109, 46, 105, 9, 115, 116, 101, 108, 101,
				109, 46, 105, 49, 9, 115, 116, 101, 108, 101,
				109, 46, 105, 50, 9, 115, 116, 101, 108, 101,
				109, 46, 105, 52, 9, 115, 116, 101, 108, 101,
				109, 46, 105, 56, 9, 115, 116, 101, 108, 101,
				109, 46, 114, 52, 9, 115, 116, 101, 108, 101,
				109, 46, 114, 56, 10, 115, 116, 101, 108, 101,
				109, 46, 114, 101, 102, 10, 108, 100, 101, 108,
				101, 109, 46, 97, 110, 121, 10, 115, 116, 101,
				108, 101, 109, 46, 97, 110, 121, 9, 117, 110,
				98, 111, 120, 46, 97, 110, 121, 11, 99, 111,
				110, 118, 46, 111, 118, 102, 46, 105, 49, 11,
				99, 111, 110, 118, 46, 111, 118, 102, 46, 117,
				49, 11, 99, 111, 110, 118, 46, 111, 118, 102,
				46, 105, 50, 11, 99, 111, 110, 118, 46, 111,
				118, 102, 46, 117, 50, 11, 99, 111, 110, 118,
				46, 111, 118, 102, 46, 105, 52, 11, 99, 111,
				110, 118, 46, 111, 118, 102, 46, 117, 52, 11,
				99, 111, 110, 118, 46, 111, 118, 102, 46, 105,
				56, 11, 99, 111, 110, 118, 46, 111, 118, 102,
				46, 117, 56, 9, 114, 101, 102, 97, 110, 121,
				118, 97, 108, 8, 99, 107, 102, 105, 110, 105,
				116, 101, 8, 109, 107, 114, 101, 102, 97, 110,
				121, 7, 108, 100, 116, 111, 107, 101, 110, 7,
				99, 111, 110, 118, 46, 117, 50, 7, 99, 111,
				110, 118, 46, 117, 49, 6, 99, 111, 110, 118,
				46, 105, 10, 99, 111, 110, 118, 46, 111, 118,
				102, 46, 105, 10, 99, 111, 110, 118, 46, 111,
				118, 102, 46, 117, 7, 97, 100, 100, 46, 111,
				118, 102, 10, 97, 100, 100, 46, 111, 118, 102,
				46, 117, 110, 7, 109, 117, 108, 46, 111, 118,
				102, 10, 109, 117, 108, 46, 111, 118, 102, 46,
				117, 110, 7, 115, 117, 98, 46, 111, 118, 102,
				10, 115, 117, 98, 46, 111, 118, 102, 46, 117,
				110, 10, 101, 110, 100, 102, 105, 110, 97, 108,
				108, 121, 5, 108, 101, 97, 118, 101, 7, 108,
				101, 97, 118, 101, 46, 115, 7, 115, 116, 105,
				110, 100, 46, 105, 6, 99, 111, 110, 118, 46,
				117, 7, 97, 114, 103, 108, 105, 115, 116, 3,
				99, 101, 113, 3, 99, 103, 116, 6, 99, 103,
				116, 46, 117, 110, 3, 99, 108, 116, 6, 99,
				108, 116, 46, 117, 110, 5, 108, 100, 102, 116,
				110, 9, 108, 100, 118, 105, 114, 116, 102, 116,
				110, 5, 108, 100, 97, 114, 103, 6, 108, 100,
				97, 114, 103, 97, 5, 115, 116, 97, 114, 103,
				5, 108, 100, 108, 111, 99, 6, 108, 100, 108,
				111, 99, 97, 5, 115, 116, 108, 111, 99, 8,
				108, 111, 99, 97, 108, 108, 111, 99, 9, 101,
				110, 100, 102, 105, 108, 116, 101, 114, 10, 117,
				110, 97, 108, 105, 103, 110, 101, 100, 46, 9,
				118, 111, 108, 97, 116, 105, 108, 101, 46, 5,
				116, 97, 105, 108, 46, 7, 105, 110, 105, 116,
				111, 98, 106, 12, 99, 111, 110, 115, 116, 114,
				97, 105, 110, 101, 100, 46, 5, 99, 112, 98,
				108, 107, 7, 105, 110, 105, 116, 98, 108, 107,
				3, 110, 111, 46, 7, 114, 101, 116, 104, 114,
				111, 119, 6, 115, 105, 122, 101, 111, 102, 10,
				114, 101, 102, 97, 110, 121, 116, 121, 112, 101,
				9, 114, 101, 97, 100, 111, 110, 108, 121, 46
			};
			names = new string[219];
			int i = 0;
			int num = 0;
			for (; i < names.Length; i++)
			{
				char[] array2 = new char[array[num++]];
				for (int j = 0; j < array2.Length; j++)
				{
					array2[j] = (char)array[num++];
				}
				names[i] = new string(array2);
			}
		}
	}
	public static class OpCodes
	{
		internal static readonly OpCode[] OneByteOpCode = new OpCode[225];

		internal static readonly OpCode[] TwoBytesOpCode = new OpCode[31];

		public static readonly OpCode Nop = new OpCode(83886335, 318768389);

		public static readonly OpCode Break = new OpCode(16843263, 318768389);

		public static readonly OpCode Ldarg_0 = new OpCode(84017919, 335545601);

		public static readonly OpCode Ldarg_1 = new OpCode(84083711, 335545601);

		public static readonly OpCode Ldarg_2 = new OpCode(84149503, 335545601);

		public static readonly OpCode Ldarg_3 = new OpCode(84215295, 335545601);

		public static readonly OpCode Ldloc_0 = new OpCode(84281087, 335545601);

		public static readonly OpCode Ldloc_1 = new OpCode(84346879, 335545601);

		public static readonly OpCode Ldloc_2 = new OpCode(84412671, 335545601);

		public static readonly OpCode Ldloc_3 = new OpCode(84478463, 335545601);

		public static readonly OpCode Stloc_0 = new OpCode(84544255, 318833921);

		public static readonly OpCode Stloc_1 = new OpCode(84610047, 318833921);

		public static readonly OpCode Stloc_2 = new OpCode(84675839, 318833921);

		public static readonly OpCode Stloc_3 = new OpCode(84741631, 318833921);

		public static readonly OpCode Ldarg_S = new OpCode(84807423, 335549185);

		public static readonly OpCode Ldarga_S = new OpCode(84873215, 369103617);

		public static readonly OpCode Starg_S = new OpCode(84939007, 318837505);

		public static readonly OpCode Ldloc_S = new OpCode(85004799, 335548929);

		public static readonly OpCode Ldloca_S = new OpCode(85070591, 369103361);

		public static readonly OpCode Stloc_S = new OpCode(85136383, 318837249);

		public static readonly OpCode Ldnull = new OpCode(85202175, 436208901);

		public static readonly OpCode Ldc_I4_M1 = new OpCode(85267967, 369100033);

		public static readonly OpCode Ldc_I4_0 = new OpCode(85333759, 369100033);

		public static readonly OpCode Ldc_I4_1 = new OpCode(85399551, 369100033);

		public static readonly OpCode Ldc_I4_2 = new OpCode(85465343, 369100033);

		public static readonly OpCode Ldc_I4_3 = new OpCode(85531135, 369100033);

		public static readonly OpCode Ldc_I4_4 = new OpCode(85596927, 369100033);

		public static readonly OpCode Ldc_I4_5 = new OpCode(85662719, 369100033);

		public static readonly OpCode Ldc_I4_6 = new OpCode(85728511, 369100033);

		public static readonly OpCode Ldc_I4_7 = new OpCode(85794303, 369100033);

		public static readonly OpCode Ldc_I4_8 = new OpCode(85860095, 369100033);

		public static readonly OpCode Ldc_I4_S = new OpCode(85925887, 369102849);

		public static readonly OpCode Ldc_I4 = new OpCode(85991679, 369099269);

		public static readonly OpCode Ldc_I8 = new OpCode(86057471, 385876741);

		public static readonly OpCode Ldc_R4 = new OpCode(86123263, 402657541);

		public static readonly OpCode Ldc_R8 = new OpCode(86189055, 419432197);

		public static readonly OpCode Dup = new OpCode(86255103, 352388357);

		public static readonly OpCode Pop = new OpCode(86320895, 318833925);

		public static readonly OpCode Jmp = new OpCode(36055039, 318768133);

		public static readonly OpCode Call = new OpCode(36120831, 471532549);

		public static readonly OpCode Calli = new OpCode(36186623, 471533573);

		public static readonly OpCode Ret = new OpCode(120138495, 320537861);

		public static readonly OpCode Br_S = new OpCode(2763775, 318770945);

		public static readonly OpCode Brfalse_S = new OpCode(53161215, 318967553);

		public static readonly OpCode Brtrue_S = new OpCode(53227007, 318967553);

		public static readonly OpCode Beq_S = new OpCode(53292799, 318902017);

		public static readonly OpCode Bge_S = new OpCode(53358591, 318902017);

		public static readonly OpCode Bgt_S = new OpCode(53424383, 318902017);

		public static readonly OpCode Ble_S = new OpCode(53490175, 318902017);

		public static readonly OpCode Blt_S = new OpCode(53555967, 318902017);

		public static readonly OpCode Bne_Un_S = new OpCode(53621759, 318902017);

		public static readonly OpCode Bge_Un_S = new OpCode(53687551, 318902017);

		public static readonly OpCode Bgt_Un_S = new OpCode(53753343, 318902017);

		public static readonly OpCode Ble_Un_S = new OpCode(53819135, 318902017);

		public static readonly OpCode Blt_Un_S = new OpCode(53884927, 318902017);

		public static readonly OpCode Br = new OpCode(3619071, 318767109);

		public static readonly OpCode Brfalse = new OpCode(54016511, 318963717);

		public static readonly OpCode Brtrue = new OpCode(54082303, 318963717);

		public static readonly OpCode Beq = new OpCode(54148095, 318898177);

		public static readonly OpCode Bge = new OpCode(54213887, 318898177);

		public static readonly OpCode Bgt = new OpCode(54279679, 318898177);

		public static readonly OpCode Ble = new OpCode(54345471, 318898177);

		public static readonly OpCode Blt = new OpCode(54411263, 318898177);

		public static readonly OpCode Bne_Un = new OpCode(54477055, 318898177);

		public static readonly OpCode Bge_Un = new OpCode(54542847, 318898177);

		public static readonly OpCode Bgt_Un = new OpCode(54608639, 318898177);

		public static readonly OpCode Ble_Un = new OpCode(54674431, 318898177);

		public static readonly OpCode Blt_Un = new OpCode(54740223, 318898177);

		public static readonly OpCode Switch = new OpCode(54806015, 318966277);

		public static readonly OpCode Ldind_I1 = new OpCode(88426239, 369296645);

		public static readonly OpCode Ldind_U1 = new OpCode(88492031, 369296645);

		public static readonly OpCode Ldind_I2 = new OpCode(88557823, 369296645);

		public static readonly OpCode Ldind_U2 = new OpCode(88623615, 369296645);

		public static readonly OpCode Ldind_I4 = new OpCode(88689407, 369296645);

		public static readonly OpCode Ldind_U4 = new OpCode(88755199, 369296645);

		public static readonly OpCode Ldind_I8 = new OpCode(88820991, 386073861);

		public static readonly OpCode Ldind_I = new OpCode(88886783, 369296645);

		public static readonly OpCode Ldind_R4 = new OpCode(88952575, 402851077);

		public static readonly OpCode Ldind_R8 = new OpCode(89018367, 419628293);

		public static readonly OpCode Ldind_Ref = new OpCode(89084159, 436405509);

		public static readonly OpCode Stind_Ref = new OpCode(89149951, 319096069);

		public static readonly OpCode Stind_I1 = new OpCode(89215743, 319096069);

		public static readonly OpCode Stind_I2 = new OpCode(89281535, 319096069);

		public static readonly OpCode Stind_I4 = new OpCode(89347327, 319096069);

		public static readonly OpCode Stind_I8 = new OpCode(89413119, 319161605);

		public static readonly OpCode Stind_R4 = new OpCode(89478911, 319292677);

		public static readonly OpCode Stind_R8 = new OpCode(89544703, 319358213);

		public static readonly OpCode Add = new OpCode(89610495, 335676677);

		public static readonly OpCode Sub = new OpCode(89676287, 335676677);

		public static readonly OpCode Mul = new OpCode(89742079, 335676677);

		public static readonly OpCode Div = new OpCode(89807871, 335676677);

		public static readonly OpCode Div_Un = new OpCode(89873663, 335676677);

		public static readonly OpCode Rem = new OpCode(89939455, 335676677);

		public static readonly OpCode Rem_Un = new OpCode(90005247, 335676677);

		public static readonly OpCode And = new OpCode(90071039, 335676677);

		public static readonly OpCode Or = new OpCode(90136831, 335676677);

		public static readonly OpCode Xor = new OpCode(90202623, 335676677);

		public static readonly OpCode Shl = new OpCode(90268415, 335676677);

		public static readonly OpCode Shr = new OpCode(90334207, 335676677);

		public static readonly OpCode Shr_Un = new OpCode(90399999, 335676677);

		public static readonly OpCode Neg = new OpCode(90465791, 335611141);

		public static readonly OpCode Not = new OpCode(90531583, 335611141);

		public static readonly OpCode Conv_I1 = new OpCode(90597375, 369165573);

		public static readonly OpCode Conv_I2 = new OpCode(90663167, 369165573);

		public static readonly OpCode Conv_I4 = new OpCode(90728959, 369165573);

		public static readonly OpCode Conv_I8 = new OpCode(90794751, 385942789);

		public static readonly OpCode Conv_R4 = new OpCode(90860543, 402720005);

		public static readonly OpCode Conv_R8 = new OpCode(90926335, 419497221);

		public static readonly OpCode Conv_U4 = new OpCode(90992127, 369165573);

		public static readonly OpCode Conv_U8 = new OpCode(91057919, 385942789);

		public static readonly OpCode Callvirt = new OpCode(40792063, 471532547);

		public static readonly OpCode Cpobj = new OpCode(91189503, 319097859);

		public static readonly OpCode Ldobj = new OpCode(91255295, 335744003);

		public static readonly OpCode Ldstr = new OpCode(91321087, 436209923);

		public static readonly OpCode Newobj = new OpCode(41055231, 437978115);

		public static readonly OpCode Castclass = new OpCode(91452671, 436866051);

		public static readonly OpCode Isinst = new OpCode(91518463, 369757187);

		public static readonly OpCode Conv_R_Un = new OpCode(91584255, 419497221);

		public static readonly OpCode Unbox = new OpCode(91650559, 369757189);

		public static readonly OpCode Throw = new OpCode(142047999, 319423747);

		public static readonly OpCode Ldfld = new OpCode(91782143, 336199939);

		public static readonly OpCode Ldflda = new OpCode(91847935, 369754371);

		public static readonly OpCode Stfld = new OpCode(91913727, 319488259);

		public static readonly OpCode Ldsfld = new OpCode(91979519, 335544579);

		public static readonly OpCode Ldsflda = new OpCode(92045311, 369099011);

		public static readonly OpCode Stsfld = new OpCode(92111103, 318832899);

		public static readonly OpCode Stobj = new OpCode(92176895, 319032323);

		public static readonly OpCode Conv_Ovf_I1_Un = new OpCode(92242687, 369165573);

		public static readonly OpCode Conv_Ovf_I2_Un = new OpCode(92308479, 369165573);

		public static readonly OpCode Conv_Ovf_I4_Un = new OpCode(92374271, 369165573);

		public static readonly OpCode Conv_Ovf_I8_Un = new OpCode(92440063, 385942789);

		public static readonly OpCode Conv_Ovf_U1_Un = new OpCode(92505855, 369165573);

		public static readonly OpCode Conv_Ovf_U2_Un = new OpCode(92571647, 369165573);

		public static readonly OpCode Conv_Ovf_U4_Un = new OpCode(92637439, 369165573);

		public static readonly OpCode Conv_Ovf_U8_Un = new OpCode(92703231, 385942789);

		public static readonly OpCode Conv_Ovf_I_Un = new OpCode(92769023, 369165573);

		public static readonly OpCode Conv_Ovf_U_Un = new OpCode(92834815, 369165573);

		public static readonly OpCode Box = new OpCode(92900607, 436276229);

		public static readonly OpCode Newarr = new OpCode(92966399, 436407299);

		public static readonly OpCode Ldlen = new OpCode(93032191, 369755395);

		public static readonly OpCode Ldelema = new OpCode(93097983, 369888259);

		public static readonly OpCode Ldelem_I1 = new OpCode(93163775, 369886467);

		public static readonly OpCode Ldelem_U1 = new OpCode(93229567, 369886467);

		public static readonly OpCode Ldelem_I2 = new OpCode(93295359, 369886467);

		public static readonly OpCode Ldelem_U2 = new OpCode(93361151, 369886467);

		public static readonly OpCode Ldelem_I4 = new OpCode(93426943, 369886467);

		public static readonly OpCode Ldelem_U4 = new OpCode(93492735, 369886467);

		public static readonly OpCode Ldelem_I8 = new OpCode(93558527, 386663683);

		public static readonly OpCode Ldelem_I = new OpCode(93624319, 369886467);

		public static readonly OpCode Ldelem_R4 = new OpCode(93690111, 403440899);

		public static readonly OpCode Ldelem_R8 = new OpCode(93755903, 420218115);

		public static readonly OpCode Ldelem_Ref = new OpCode(93821695, 436995331);

		public static readonly OpCode Stelem_I = new OpCode(93887487, 319620355);

		public static readonly OpCode Stelem_I1 = new OpCode(93953279, 319620355);

		public static readonly OpCode Stelem_I2 = new OpCode(94019071, 319620355);

		public static readonly OpCode Stelem_I4 = new OpCode(94084863, 319620355);

		public static readonly OpCode Stelem_I8 = new OpCode(94150655, 319685891);

		public static readonly OpCode Stelem_R4 = new OpCode(94216447, 319751427);

		public static readonly OpCode Stelem_R8 = new OpCode(94282239, 319816963);

		public static readonly OpCode Stelem_Ref = new OpCode(94348031, 319882499);

		public static readonly OpCode Ldelem_Any = new OpCode(94413823, 336333827);

		public static readonly OpCode Stelem_Any = new OpCode(94479615, 319884291);

		public static readonly OpCode Unbox_Any = new OpCode(94545407, 336202755);

		public static readonly OpCode Conv_Ovf_I1 = new OpCode(94614527, 369165573);

		public static readonly OpCode Conv_Ovf_U1 = new OpCode(94680319, 369165573);

		public static readonly OpCode Conv_Ovf_I2 = new OpCode(94746111, 369165573);

		public static readonly OpCode Conv_Ovf_U2 = new OpCode(94811903, 369165573);

		public static readonly OpCode Conv_Ovf_I4 = new OpCode(94877695, 369165573);

		public static readonly OpCode Conv_Ovf_U4 = new OpCode(94943487, 369165573);

		public static readonly OpCode Conv_Ovf_I8 = new OpCode(95009279, 385942789);

		public static readonly OpCode Conv_Ovf_U8 = new OpCode(95075071, 385942789);

		public static readonly OpCode Refanyval = new OpCode(95142655, 369167365);

		public static readonly OpCode Ckfinite = new OpCode(95208447, 419497221);

		public static readonly OpCode Mkrefany = new OpCode(95274751, 335744005);

		public static readonly OpCode Ldtoken = new OpCode(95342847, 369101573);

		public static readonly OpCode Conv_U2 = new OpCode(95408639, 369165573);

		public static readonly OpCode Conv_U1 = new OpCode(95474431, 369165573);

		public static readonly OpCode Conv_I = new OpCode(95540223, 369165573);

		public static readonly OpCode Conv_Ovf_I = new OpCode(95606015, 369165573);

		public static readonly OpCode Conv_Ovf_U = new OpCode(95671807, 369165573);

		public static readonly OpCode Add_Ovf = new OpCode(95737599, 335676677);

		public static readonly OpCode Add_Ovf_Un = new OpCode(95803391, 335676677);

		public static readonly OpCode Mul_Ovf = new OpCode(95869183, 335676677);

		public static readonly OpCode Mul_Ovf_Un = new OpCode(95934975, 335676677);

		public static readonly OpCode Sub_Ovf = new OpCode(96000767, 335676677);

		public static readonly OpCode Sub_Ovf_Un = new OpCode(96066559, 335676677);

		public static readonly OpCode Endfinally = new OpCode(129686783, 318768389);

		public static readonly OpCode Leave = new OpCode(12312063, 319946757);

		public static readonly OpCode Leave_S = new OpCode(12377855, 319950593);

		public static readonly OpCode Stind_I = new OpCode(96329727, 319096069);

		public static readonly OpCode Conv_U = new OpCode(96395519, 369165573);

		public static readonly OpCode Arglist = new OpCode(96403710, 369100037);

		public static readonly OpCode Ceq = new OpCode(96469502, 369231109);

		public static readonly OpCode Cgt = new OpCode(96535294, 369231109);

		public static readonly OpCode Cgt_Un = new OpCode(96601086, 369231109);

		public static readonly OpCode Clt = new OpCode(96666878, 369231109);

		public static readonly OpCode Clt_Un = new OpCode(96732670, 369231109);

		public static readonly OpCode Ldftn = new OpCode(96798462, 369099781);

		public static readonly OpCode Ldvirtftn = new OpCode(96864254, 369755141);

		public static readonly OpCode Ldarg = new OpCode(96930302, 335547909);

		public static readonly OpCode Ldarga = new OpCode(96996094, 369102341);

		public static readonly OpCode Starg = new OpCode(97061886, 318836229);

		public static readonly OpCode Ldloc = new OpCode(97127678, 335547653);

		public static readonly OpCode Ldloca = new OpCode(97193470, 369102085);

		public static readonly OpCode Stloc = new OpCode(97259262, 318835973);

		public static readonly OpCode Localloc = new OpCode(97325054, 369296645);

		public static readonly OpCode Endfilter = new OpCode(130945534, 318964997);

		public static readonly OpCode Unaligned = new OpCode(80679678, 318771204);

		public static readonly OpCode Volatile = new OpCode(80745470, 318768388);

		public static readonly OpCode Tail = new OpCode(80811262, 318768388);

		public static readonly OpCode Initobj = new OpCode(97654270, 318966787);

		public static readonly OpCode Constrained = new OpCode(97720062, 318770180);

		public static readonly OpCode Cpblk = new OpCode(97785854, 319227141);

		public static readonly OpCode Initblk = new OpCode(97851646, 319227141);

		public static readonly OpCode No = new OpCode(97917438, 318771204);

		public static readonly OpCode Rethrow = new OpCode(148314878, 318768387);

		public static readonly OpCode Sizeof = new OpCode(98049278, 369101829);

		public static readonly OpCode Refanytype = new OpCode(98115070, 369165573);

		public static readonly OpCode Readonly = new OpCode(98180862, 318768388);
	}
	public sealed class SequencePoint
	{
		private Document document;

		private int start_line;

		private int start_column;

		private int end_line;

		private int end_column;

		public int StartLine
		{
			get
			{
				return start_line;
			}
			set
			{
				start_line = value;
			}
		}

		public int StartColumn
		{
			get
			{
				return start_column;
			}
			set
			{
				start_column = value;
			}
		}

		public int EndLine
		{
			get
			{
				return end_line;
			}
			set
			{
				end_line = value;
			}
		}

		public int EndColumn
		{
			get
			{
				return end_column;
			}
			set
			{
				end_column = value;
			}
		}

		public Document Document
		{
			get
			{
				return document;
			}
			set
			{
				document = value;
			}
		}

		public SequencePoint(Document document)
		{
			this.document = document;
		}
	}
	public struct ImageDebugDirectory
	{
		public int Characteristics;

		public int TimeDateStamp;

		public short MajorVersion;

		public short MinorVersion;

		public int Type;

		public int SizeOfData;

		public int AddressOfRawData;

		public int PointerToRawData;
	}
	public sealed class Scope : IVariableDefinitionProvider
	{
		private Instruction start;

		private Instruction end;

		private Mono.Collections.Generic.Collection<Scope> scopes;

		private Mono.Collections.Generic.Collection<VariableDefinition> variables;

		public Instruction Start
		{
			get
			{
				return start;
			}
			set
			{
				start = value;
			}
		}

		public Instruction End
		{
			get
			{
				return end;
			}
			set
			{
				end = value;
			}
		}

		public bool HasScopes => !scopes.IsNullOrEmpty();

		public Mono.Collections.Generic.Collection<Scope> Scopes
		{
			get
			{
				if (scopes == null)
				{
					scopes = new Mono.Collections.Generic.Collection<Scope>();
				}
				return scopes;
			}
		}

		public bool HasVariables => !variables.IsNullOrEmpty();

		public Mono.Collections.Generic.Collection<VariableDefinition> Variables
		{
			get
			{
				if (variables == null)
				{
					variables = new Mono.Collections.Generic.Collection<VariableDefinition>();
				}
				return variables;
			}
		}
	}
	public struct InstructionSymbol
	{
		public readonly int Offset;

		public readonly SequencePoint SequencePoint;

		public InstructionSymbol(int offset, SequencePoint sequencePoint)
		{
			Offset = offset;
			SequencePoint = sequencePoint;
		}
	}
	public sealed class MethodSymbols
	{
		internal int code_size;

		internal string method_name;

		internal MetadataToken method_token;

		internal MetadataToken local_var_token;

		internal Mono.Collections.Generic.Collection<VariableDefinition> variables;

		internal Mono.Collections.Generic.Collection<InstructionSymbol> instructions;

		public bool HasVariables => !variables.IsNullOrEmpty();

		public Mono.Collections.Generic.Collection<VariableDefinition> Variables
		{
			get
			{
				if (variables == null)
				{
					variables = new Mono.Collections.Generic.Collection<VariableDefinition>();
				}
				return variables;
			}
		}

		public Mono.Collections.Generic.Collection<InstructionSymbol> Instructions
		{
			get
			{
				if (instructions == null)
				{
					instructions = new Mono.Collections.Generic.Collection<InstructionSymbol>();
				}
				return instructions;
			}
		}

		public int CodeSize => code_size;

		public string MethodName => method_name;

		public MetadataToken MethodToken => method_token;

		public MetadataToken LocalVarToken => local_var_token;

		internal MethodSymbols(string methodName)
		{
			method_name = methodName;
		}

		public MethodSymbols(MetadataToken methodToken)
		{
			method_token = methodToken;
		}
	}
	public delegate Instruction InstructionMapper(int offset);
	public interface ISymbolReader : IDisposable
	{
		bool ProcessDebugHeader(ImageDebugDirectory directory, byte[] header);

		void Read(MethodBody body, InstructionMapper mapper);

		void Read(MethodSymbols symbols);
	}
	public interface ISymbolReaderProvider
	{
		ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);

		ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
	}
	internal static class SymbolProvider
	{
		private static readonly string symbol_kind = ((Type.GetType("Mono.Runtime") != null) ? "Mdb" : "Pdb");

		private static ISymbolReaderProvider reader_provider;

		private static ISymbolWriterProvider writer_provider;

		private static AssemblyName GetPlatformSymbolAssemblyName()
		{
			AssemblyName name = typeof(SymbolProvider).Assembly.GetName();
			AssemblyName assemblyName = new AssemblyName();
			assemblyName.Name = "Mono.Cecil." + symbol_kind;
			assemblyName.Version = name.Version;
			assemblyName.SetPublicKeyToken(name.GetPublicKeyToken());
			return assemblyName;
		}

		private static Type GetPlatformType(string fullname)
		{
			Type type = Type.GetType(fullname);
			if (type != null)
			{
				return type;
			}
			AssemblyName platformSymbolAssemblyName = GetPlatformSymbolAssemblyName();
			type = Type.GetType(fullname + ", " + platformSymbolAssemblyName.FullName);
			if (type != null)
			{
				return type;
			}
			try
			{
				Assembly assembly = Assembly.Load(platformSymbolAssemblyName);
				if (assembly != null)
				{
					return assembly.GetType(fullname);
				}
			}
			catch (FileNotFoundException)
			{
			}
			catch (FileLoadException)
			{
			}
			return null;
		}

		public static ISymbolReaderProvider GetPlatformReaderProvider()
		{
			if (reader_provider != null)
			{
				return reader_provider;
			}
			Type platformType = GetPlatformType(GetProviderTypeName("ReaderProvider"));
			if (platformType == null)
			{
				return null;
			}
			return reader_provider = (ISymbolReaderProvider)Activator.CreateInstance(platformType);
		}

		private static string GetProviderTypeName(string name)
		{
			return "Mono.Cecil." + symbol_kind + "." + symbol_kind + name;
		}

		public static ISymbolWriterProvider GetPlatformWriterProvider()
		{
			if (writer_provider != null)
			{
				return writer_provider;
			}
			Type platformType = GetPlatformType(GetProviderTypeName("WriterProvider"));
			if (platformType == null)
			{
				return null;
			}
			return writer_provider = (ISymbolWriterProvider)Activator.CreateInstance(platformType);
		}
	}
	public interface ISymbolWriter : IDisposable
	{
		bool GetDebugHeader(out ImageDebugDirectory directory, out byte[] header);

		void Write(MethodBody body);

		void Write(MethodSymbols symbols);
	}
	public interface ISymbolWriterProvider
	{
		ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);

		ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
	}
	public sealed class VariableDefinition : VariableReference
	{
		public bool IsPinned => variable_type.IsPinned;

		public VariableDefinition(TypeReference variableType)
			: base(variableType)
		{
		}

		public VariableDefinition(string name, TypeReference variableType)
			: base(name, variableType)
		{
		}

		public override VariableDefinition Resolve()
		{
			return this;
		}
	}
	public abstract class VariableReference
	{
		private string name;

		internal int index = -1;

		protected TypeReference variable_type;

		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public TypeReference VariableType
		{
			get
			{
				return variable_type;
			}
			set
			{
				variable_type = value;
			}
		}

		public int Index => index;

		internal VariableReference(TypeReference variable_type)
			: this(string.Empty, variable_type)
		{
		}

		internal VariableReference(string name, TypeReference variable_type)
		{
			this.name = name;
			this.variable_type = variable_type;
		}

		public abstract VariableDefinition Resolve();

		public override string ToString()
		{
			if (!string.IsNullOrEmpty(name))
			{
				return name;
			}
			if (index >= 0)
			{
				return "V_" + index;
			}
			return string.Empty;
		}
	}
}
[CompilerGenerated]
internal sealed class <ebf16fee-b68b-425d-bf00-99f3c15c7db1><PrivateImplementationDetails>
{
	[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 128)]
	private struct __StaticArrayInitTypeSize=128
	{
	}

	[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 1790)]
	private struct __StaticArrayInitTypeSize=1790
	{
	}

	internal static readonly __StaticArrayInitTypeSize=1790 11EFE417082EF85B0D9D6E3099593B910C1A506F/* Not supported: data(03 6E 6F 70 05 62 72 65 61 6B 07 6C 64 61 72 67 2E 30 07 6C 64 61 72 67 2E 31 07 6C 64 61 72 67 2E 32 07 6C 64 61 72 67 2E 33 07 6C 64 6C 6F 63 2E 30 07 6C 64 6C 6F 63 2E 31 07 6C 64 6C 6F 63 2E 32 07 6C 64 6C 6F 63 2E 33 07 73 74 6C 6F 63 2E 30 07 73 74 6C 6F 63 2E 31 07 73 74 6C 6F 63 2E 32 07 73 74 6C 6F 63 2E 33 07 6C 64 61 72 67 2E 73 08 6C 64 61 72 67 61 2E 73 07 73 74 61 72 67 2E 73 07 6C 64 6C 6F 63 2E 73 08 6C 64 6C 6F 63 61 2E 73 07 73 74 6C 6F 63 2E 73 06 6C 64 6E 75 6C 6C 09 6C 64 63 2E 69 34 2E 6D 31 08 6C 64 63 2E 69 34 2E 30 08 6C 64 63 2E 69 34 2E 31 08 6C 64 63 2E 69 34 2E 32 08 6C 64 63 2E 69 34 2E 33 08 6C 64 63 2E 69 34 2E 34 08 6C 64 63 2E 69 34 2E 35 08 6C 64 63 2E 69 34 2E 36 08 6C 64 63 2E 69 34 2E 37 08 6C 64 63 2E 69 34 2E 38 08 6C 64 63 2E 69 34 2E 73 06 6C 64 63 2E 69 34 06 6C 64 63 2E 69 38 06 6C 64 63 2E 72 34 06 6C 64 63 2E 72 38 03 64 75 70 03 70 6F 70 03 6A 6D 70 04 63 61 6C 6C 05 63 61 6C 6C 69 03 72 65 74 04 62 72 2E 73 09 62 72 66 61 6C 73 65 2E 73 08 62 72 74 72 75 65 2E 73 05 62 65 71 2E 73 05 62 67 65 2E 73 05 62 67 74 2E 73 05 62 6C 65 2E 73 05 62 6C 74 2E 73 08 62 6E 65 2E 75 6E 2E 73 08 62 67 65 2E 75 6E 2E 73 08 62 67 74 2E 75 6E 2E 73 08 62 6C 65 2E 75 6E 2E 73 08 62 6C 74 2E 75 6E 2E 73 02 62 72 07 62 72 66 61 6C 73 65 06 62 72 74 72 75 65 03 62 65 71 03 62 67 65 03 62 67 74 03 62 6C 65 03 62 6C 74 06 62 6E 65 2E 75 6E 06 62 67 65 2E 75 6E 06 62 67 74 2E 75 6E 06 62 6C 65 2E 75 6E 06 62 6C 74 2E 75 6E 06 73 77 69 74 63 68 08 6C 64 69 6E 64 2E 69 31 08 6C 64 69 6E 64 2E 75 31 08 6C 64 69 6E 64 2E 69 32 08 6C 64 69 6E 64 2E 75 32 08 6C 64 69 6E 64 2E 69 34 08 6C 64 69 6E 64 2E 75 34 08 6C 64 69 6E 64 2E 69 38 07 6C 64 69 6E 64 2E 69 08 6C 64 69 6E 64 2E 72 34 08 6C 64 69 6E 64 2E 72 38 09 6C 64 69 6E 64 2E 72 65 66 09 73 74 69 6E 64 2E 72 65 66 08 73 74 69 6E 64 2E 69 31 08 73 74 69 6E 64 2E 69 32 08 73 74 69 6E 64 2E 69 34 08 73 74 69 6E 64 2E 69 38 08 73 74 69 6E 64 2E 72 34 08 73 74 69 6E 64 2E 72 38 03 61 64 64 03 73 75 62 03 6D 75 6C 03 64 69 76 06 64 69 76 2E 75 6E 03 72 65 6D 06 72 65 6D 2E 75 6E 03 61 6E 64 02 6F 72 03 78 6F 72 03 73 68 6C 03 73 68 72 06 73 68 72 2E 75 6E 03 6E 65 67 03 6E 6F 74 07 63 6F 6E 76 2E 69 31 07 63 6F 6E 76 2E 69 32 07 63 6F 6E 76 2E 69 34 07 63 6F 6E 76 2E 69 38 07 63 6F 6E 76 2E 72 34 07 63 6F 6E 76 2E 72 38 07 63 6F 6E 76 2E 75 34 07 63 6F 6E 76 2E 75 38 08 63 61 6C 6C 76 69 72 74 05 63 70 6F 62 6A 05 6C 64 6F 62 6A 05 6C 64 73 74 72 06 6E 65 77 6F 62 6A 09 63 61 73 74 63 6C 61 73 73 06 69 73 69 6E 73 74 09 63 6F 6E 76 2E 72 2E 75 6E 05 75 6E 62 6F 78 05 74 68 72 6F 77 05 6C 64 66 6C 64 06 6C 64 66 6C 64 61 05 73 74 66 6C 64 06 6C 64 73 66 6C 64 07 6C 64 73 66 6C 64 61 06 73 74 73 66 6C 64 05 73 74 6F 62 6A 0E 63 6F 6E 76 2E 6F 76 66 2E 69 31 2E 75 6E 0E 63 6F 6E 76 2E 6F 76 66 2E 69 32 2E 75 6E 0E 63 6F 6E 76 2E 6F 76 66 2E 69 34 2E 75 6E 0E 63 6F 6E 76 2E 6F 76 66 2E 69 38 2E 75 6E 0E 63 6F 6E 76 2E 6F 76 66 2E 75 31 2E 75 6E 0E 63 6F 6E 76 2E 6F 76 66 2E 75 32 2E 75 6E 0E 63 6F 6E 76 2E 6F 76 66 2E 75 34 2E 75 6E 0E 63 6F 6E 76 2E 6F 76 66 2E 75 38 2E 75 6E 0D 63 6F 6E 76 2E 6F 76 66 2E 69 2E 75 6E 0D 63 6F 6E 76 2E 6F 76 66 2E 75 2E 75 6E 03 62 6F 78 06 6E 65 77 61 72 72 05 6C 64 6C 65 6E 07 6C 64 65 6C 65 6D 61 09 6C 64 65 6C 65 6D 2E 69 31 09 6C 64 65 6C 65 6D 2E 75 31 09 6C 64 65 6C 65 6D 2E 69 32 09 6C 64 65 6C 65 6D 2E 75 32 09 6C 64 65 6C 65 6D 2E 69 34 09 6C 64 65 6C 65 6D 2E 75 34 09 6C 64 65 6C 65 6D 2E 69 38 08 6C 64 65 6C 65 6D 2E 69 09 6C 64 65 6C 65 6D 2E 72 34 09 6C 64 65 6C 65 6D 2E 72 38 0A 6C 64 65 6C 65 6D 2E 72 65 66 08 73 74 65 6C 65 6D 2E 69 09 73 74 65 6C 65 6D 2E 69 31 09 73 74 65 6C 65 6D 2E 69 32 09 73 74 65 6C 65 6D 2E 69 34 09 73 74 65 6C 65 6D 2E 69 38 09 73 74 65 6C 65 6D 2E 72 34 09 73 74 65 6C 65 6D 2E 72 38 0A 73 74 65 6C 65 6D 2E 72 65 66 0A 6C 64 65 6C 65 6D 2E 61 6E 79 0A 73 74 65 6C 65 6D 2E 61 6E 79 09 75 6E 62 6F 78 2E 61 6E 79 0B 63 6F 6E 76 2E 6F 76 66 2E 69 31 0B 63 6F 6E 76 2E 6F 76 66 2E 75 31 0B 63 6F 6E 76 2E 6F 76 66 2E 69 32 0B 63 6F 6E 76 2E 6F 76 66 2E 75 32 0B 63 6F 6E 76 2E 6F 76 66 2E 69 34 0B 63 6F 6E 76 2E 6F 76 66 2E 75 34 0B 63 6F 6E 76 2E 6F 76 66 2E 69 38 0B 63 6F 6E 76 2E 6F 76 66 2E 75 38 09 72 65 66 61 6E 79 76 61 6C 08 63 6B 66 69 6E 69 74 65 08 6D 6B 72 65 66 61 6E 79 07 6C 64 74 6F 6B 65 6E 07 63 6F 6E 76 2E 75 32 07 63 6F 6E 76 2E 75 31 06 63 6F 6E 76 2E 69 0A 63 6F 6E 76 2E 6F 76 66 2E 69 0A 63 6F 6E 76 2E 6F 76 66 2E 75 07 61 64 64 2E 6F 76 66 0A 61 64 64 2E 6F 76 66 2E 75 6E 07 6D 75 6C 2E 6F 76 66 0A 6D 75 6C 2E 6F 76 66 2E 75 6E 07 73 75 62 2E 6F 76 66 0A 73 75 62 2E 6F 76 66 2E 75 6E 0A 65 6E 64 66 69 6E 61 6C 6C 79 05 6C 65 61 76 65 07 6C 65 61 76 65 2E 73 07 73 74 69 6E 64 2E 69 06 63 6F 6E 76 2E 75 07 61 72 67 6C 69 73 74 03 63 65 71 03 63 67 74 06 63 67 74 2E 75 6E 03 63 6C 74 06 63 6C 74 2E 75 6E 05 6C 64 66 74 6E 09 6C 64 76 69 72 74 66 74 6E 05 6C 64 61 72 67 06 6C 64 61 72 67 61 05 73 74 61 72 67 05 6C 64 6C 6F 63 06 6C 64 6C 6F 63 61 05 73 74 6C 6F 63 08 6C 6F 63 61 6C 6C 6F 63 09 65 6E 64 66 69 6C 74 65 72 0A 75 6E 61 6C 69 67 6E 65 64 2E 09 76 6F 6C 61 74 69 6C 65 2E 05 74 61 69 6C 2E 07 69 6E 69 74 6F 62 6A 0C 63 6F 6E 73 74 72 61 69 6E 65 64 2E 05 63 70 62 6C 6B 07 69 6E 69 74 62 6C 6B 03 6E 6F 2E 07 72 65 74 68 72 6F 77 06 73 69 7A 65 6F 66 0A 72 65 66 61 6E 79 74 79 70 65 09 72 65 61 64 6F 6E 6C 79 2E) */;

	internal static readonly long 504BD08902B7EE1EA70852EE7B30B06CD4130E90/* Not supported: data(B7 7A 5C 56 19 34 E0 89) */;

	internal static readonly __StaticArrayInitTypeSize=128 F11665C8721466F78A96C106B08F17FC29A12F6C/* Not supported: data(4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00 B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 80 00 00 00 0E 1F BA 0E 00 B4 09 CD 21 B8 01 4C CD 21 54 68 69 73 20 70 72 6F 67 72 61 6D 20 63 61 6E 6E 6F 74 20 62 65 20 72 75 6E 20 69 6E 20 44 4F 53 20 6D 6F 64 65 2E 0D 0D 0A 24 00 00 00 00 00 00 00) */;
}
namespace Mono.Cecil.Rocks
{
	public static class MethodDefinitionRocks
	{
		public static MethodDefinition GetBaseMethod(this MethodDefinition self)
		{
			if (self == null)
			{
				throw new ArgumentNullException("self");
			}
			if (!self.IsVirtual)
			{
				return self;
			}
			if (self.IsNewSlot)
			{
				return self;
			}
			for (TypeDefinition typeDefinition = ResolveBaseType(self.DeclaringType); typeDefinition != null; typeDefinition = ResolveBaseType(typeDefinition))
			{
				MethodDefinition matchingMethod = GetMatchingMethod(typeDefinition, self);
				if (matchingMethod != null)
				{
					return matchingMethod;
				}
			}
			return self;
		}

		public static MethodDefinition GetOriginalBaseMethod(this MethodDefinition self)
		{
			if (self == null)
			{
				throw new ArgumentNullException("self");
			}
			while (true)
			{
				MethodDefinition baseMethod = self.GetBaseMethod();
				if (baseMethod == self)
				{
					break;
				}
				self = baseMethod;
			}
			return self;
		}

		private static TypeDefinition ResolveBaseType(TypeDefinition type)
		{
			return type?.BaseType?.Resolve();
		}

		private static MethodDefinition GetMatchingMethod(TypeDefinition type, MethodDefinition method)
		{
			return MetadataResolver.GetMethod(type.Methods, method);
		}
	}
	public static class SecurityDeclarationRocks
	{
		public static PermissionSet ToPermissionSet(this SecurityDeclaration self)
		{
			if (self == null)
			{
				throw new ArgumentNullException("self");
			}
			if (TryProcessPermissionSetAttribute(self, out var set))
			{
				return set;
			}
			return CreatePermissionSet(self);
		}

		private static bool TryProcessPermissionSetAttribute(SecurityDeclaration declaration, out PermissionSet set)
		{
			set = null;
			if (!declaration.HasSecurityAttributes && declaration.SecurityAttributes.Count != 1)
			{
				return false;
			}
			SecurityAttribute securityAttribute = declaration.SecurityAttributes[0];
			if (!securityAttribute.AttributeType.IsTypeOf("System.Security.Permissions", "PermissionSetAttribute"))
			{
				return false;
			}
			PermissionSetAttribute permissionSetAttribute = new PermissionSetAttribute((System.Security.Permissions.SecurityAction)declaration.Action);
			CustomAttributeNamedArgument customAttributeNamedArgument = securityAttribute.Properties[0];
			string text = (string)customAttributeNamedArgument.Argument.Value;
			string name = customAttributeNamedArgument.Name;
			if (!(name == "XML"))
			{
				if (!(name == "Name"))
				{
					throw new NotImplementedException(customAttributeNamedArgument.Name);
				}
				permissionSetAttribute.Name = text;
			}
			else
			{
				permissionSetAttribute.XML = text;
			}
			set = permissionSetAttribute.CreatePermissionSet();
			return true;
		}

		private static PermissionSet CreatePermissionSet(SecurityDeclaration declaration)
		{
			PermissionSet permissionSet = new PermissionSet(PermissionState.None);
			foreach (SecurityAttribute securityAttribute in declaration.SecurityAttributes)
			{
				IPermission perm = CreatePermission(declaration, securityAttribute);
				permissionSet.AddPermission(perm);
			}
			return permissionSet;
		}

		private static IPermission CreatePermission(SecurityDeclaration declaration, SecurityAttribute attribute)
		{
			Type type = Type.GetType(attribute.AttributeType.FullName);
			if (type == null)
			{
				throw new ArgumentException("attribute");
			}
			System.Security.Permissions.SecurityAttribute obj = CreateSecurityAttribute(type, declaration) ?? throw new InvalidOperationException();
			CompleteSecurityAttribute(obj, attribute);
			return obj.CreatePermission();
		}

		private static void CompleteSecurityAttribute(System.Security.Permissions.SecurityAttribute security_attribute, SecurityAttribute attribute)
		{
			if (attribute.HasFields)
			{
				CompleteSecurityAttributeFields(security_attribute, attribute);
			}
			if (attribute.HasProperties)
			{
				CompleteSecurityAttributeProperties(security_attribute, attribute);
			}
		}

		private static void CompleteSecurityAttributeFields(System.Security.Permissions.SecurityAttribute security_attribute, SecurityAttribute attribute)
		{
			Type type = security_attribute.GetType();
			foreach (CustomAttributeNamedArgument field in attribute.Fields)
			{
				type.GetField(field.Name).SetValue(security_attribute, field.Argument.Value);
			}
		}

		private static void CompleteSecurityAttributeProperties(System.Security.Permissions.SecurityAttribute security_attribute, SecurityAttribute attribute)
		{
			Type type = security_attribute.GetType();
			foreach (CustomAttributeNamedArgument property in attribute.Properties)
			{
				type.GetProperty(property.Name).SetValue(security_attribute, property.Argument.Value, null);
			}
		}

		private static System.Security.Permissions.SecurityAttribute CreateSecurityAttribute(Type attribute_type, SecurityDeclaration declaration)
		{
			try
			{
				return (System.Security.Permissions.SecurityAttribute)Activator.CreateInstance(attribute_type, (System.Security.Permissions.SecurityAction)declaration.Action);
			}
			catch (MissingMethodException)
			{
				return (System.Security.Permissions.SecurityAttribute)Activator.CreateInstance(attribute_type, new object[0]);
			}
		}

		public static SecurityDeclaration ToSecurityDeclaration(this PermissionSet self, SecurityAction action, ModuleDefinition module)
		{
			if (self == null)
			{
				throw new ArgumentNullException("self");
			}
			if (module == null)
			{
				throw new ArgumentNullException("module");
			}
			SecurityDeclaration securityDeclaration = new SecurityDeclaration(action);
			SecurityAttribute item = new SecurityAttribute(module.TypeSystem.LookupType("System.Security.Permissions", "PermissionSetAttribute"))
			{
				Properties = 
				{
					new CustomAttributeNamedArgument("XML", new CustomAttributeArgument(module.TypeSystem.String, self.ToXml().ToString()))
				}
			};
			securityDeclaration.SecurityAttributes.Add(item);
			return securityDeclaration;
		}
	}
	public static class MethodBodyRocks
	{
		public static void SimplifyMacros(this Mono.Cecil.Cil.MethodBody self)
		{
			if (self == null)
			{
				throw new ArgumentNullException("self");
			}
			foreach (Instruction instruction in self.Instructions)
			{
				if (instruction.OpCode.OpCodeType == Mono.Cecil.Cil.OpCodeType.Macro)
				{
					switch (instruction.OpCode.Code)
					{
					case Code.Ldarg_0:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldarg, self.GetParameter(0));
						break;
					case Code.Ldarg_1:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldarg, self.GetParameter(1));
						break;
					case Code.Ldarg_2:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldarg, self.GetParameter(2));
						break;
					case Code.Ldarg_3:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldarg, self.GetParameter(3));
						break;
					case Code.Ldloc_0:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldloc, self.Variables[0]);
						break;
					case Code.Ldloc_1:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldloc, self.Variables[1]);
						break;
					case Code.Ldloc_2:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldloc, self.Variables[2]);
						break;
					case Code.Ldloc_3:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldloc, self.Variables[3]);
						break;
					case Code.Stloc_0:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Stloc, self.Variables[0]);
						break;
					case Code.Stloc_1:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Stloc, self.Variables[1]);
						break;
					case Code.Stloc_2:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Stloc, self.Variables[2]);
						break;
					case Code.Stloc_3:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Stloc, self.Variables[3]);
						break;
					case Code.Ldarg_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Ldarg;
						break;
					case Code.Ldarga_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Ldarga;
						break;
					case Code.Starg_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Starg;
						break;
					case Code.Ldloc_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Ldloc;
						break;
					case Code.Ldloca_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Ldloca;
						break;
					case Code.Stloc_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Stloc;
						break;
					case Code.Ldc_I4_M1:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4, -1);
						break;
					case Code.Ldc_I4_0:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4, 0);
						break;
					case Code.Ldc_I4_1:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4, 1);
						break;
					case Code.Ldc_I4_2:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4, 2);
						break;
					case Code.Ldc_I4_3:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4, 3);
						break;
					case Code.Ldc_I4_4:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4, 4);
						break;
					case Code.Ldc_I4_5:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4, 5);
						break;
					case Code.Ldc_I4_6:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4, 6);
						break;
					case Code.Ldc_I4_7:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4, 7);
						break;
					case Code.Ldc_I4_8:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4, 8);
						break;
					case Code.Ldc_I4_S:
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4, (int)(sbyte)instruction.Operand);
						break;
					case Code.Br_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Br;
						break;
					case Code.Brfalse_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Brfalse;
						break;
					case Code.Brtrue_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Brtrue;
						break;
					case Code.Beq_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Beq;
						break;
					case Code.Bge_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Bge;
						break;
					case Code.Bgt_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Bgt;
						break;
					case Code.Ble_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Ble;
						break;
					case Code.Blt_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Blt;
						break;
					case Code.Bne_Un_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Bne_Un;
						break;
					case Code.Bge_Un_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Bge_Un;
						break;
					case Code.Bgt_Un_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Bgt_Un;
						break;
					case Code.Ble_Un_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Ble_Un;
						break;
					case Code.Blt_Un_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Blt_Un;
						break;
					case Code.Leave_S:
						instruction.OpCode = Mono.Cecil.Cil.OpCodes.Leave;
						break;
					}
				}
			}
		}

		private static void ExpandMacro(Instruction instruction, Mono.Cecil.Cil.OpCode opcode, object operand)
		{
			instruction.OpCode = opcode;
			instruction.Operand = operand;
		}

		private static void MakeMacro(Instruction instruction, Mono.Cecil.Cil.OpCode opcode)
		{
			instruction.OpCode = opcode;
			instruction.Operand = null;
		}

		public static void OptimizeMacros(this Mono.Cecil.Cil.MethodBody self)
		{
			if (self == null)
			{
				throw new ArgumentNullException("self");
			}
			MethodDefinition method = self.Method;
			foreach (Instruction instruction in self.Instructions)
			{
				switch (instruction.OpCode.Code)
				{
				case Code.Ldarg:
				{
					int index = ((ParameterDefinition)instruction.Operand).Index;
					if (index == -1 && instruction.Operand == self.ThisParameter)
					{
						index = 0;
					}
					else if (method.HasThis)
					{
						index++;
					}
					switch (index)
					{
					case 0:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldarg_0);
						break;
					case 1:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldarg_1);
						break;
					case 2:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldarg_2);
						break;
					case 3:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldarg_3);
						break;
					default:
						if (index < 256)
						{
							ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldarg_S, instruction.Operand);
						}
						break;
					}
					break;
				}
				case Code.Ldloc:
				{
					int index = ((VariableDefinition)instruction.Operand).Index;
					switch (index)
					{
					case 0:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldloc_0);
						break;
					case 1:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldloc_1);
						break;
					case 2:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldloc_2);
						break;
					case 3:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldloc_3);
						break;
					default:
						if (index < 256)
						{
							ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldloc_S, instruction.Operand);
						}
						break;
					}
					break;
				}
				case Code.Stloc:
				{
					int index = ((VariableDefinition)instruction.Operand).Index;
					switch (index)
					{
					case 0:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Stloc_0);
						break;
					case 1:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Stloc_1);
						break;
					case 2:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Stloc_2);
						break;
					case 3:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Stloc_3);
						break;
					default:
						if (index < 256)
						{
							ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Stloc_S, instruction.Operand);
						}
						break;
					}
					break;
				}
				case Code.Ldarga:
				{
					int index = ((ParameterDefinition)instruction.Operand).Index;
					if (index == -1 && instruction.Operand == self.ThisParameter)
					{
						index = 0;
					}
					else if (method.HasThis)
					{
						index++;
					}
					if (index < 256)
					{
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldarga_S, instruction.Operand);
					}
					break;
				}
				case Code.Ldloca:
					if (((VariableDefinition)instruction.Operand).Index < 256)
					{
						ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldloca_S, instruction.Operand);
					}
					break;
				case Code.Ldc_I4:
				{
					int num = (int)instruction.Operand;
					switch (num)
					{
					case -1:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4_M1);
						break;
					case 0:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4_0);
						break;
					case 1:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4_1);
						break;
					case 2:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4_2);
						break;
					case 3:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4_3);
						break;
					case 4:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4_4);
						break;
					case 5:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4_5);
						break;
					case 6:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4_6);
						break;
					case 7:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4_7);
						break;
					case 8:
						MakeMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4_8);
						break;
					default:
						if (num >= -128 && num < 128)
						{
							ExpandMacro(instruction, Mono.Cecil.Cil.OpCodes.Ldc_I4_S, (sbyte)num);
						}
						break;
					}
					break;
				}
				}
			}
			OptimizeBranches(self);
		}

		private static void OptimizeBranches(Mono.Cecil.Cil.MethodBody body)
		{
			ComputeOffsets(body);
			foreach (Instruction instruction in body.Instructions)
			{
				if (instruction.OpCode.OperandType == Mono.Cecil.Cil.OperandType.InlineBrTarget && OptimizeBranch(instruction))
				{
					ComputeOffsets(body);
				}
			}
		}

		private static bool OptimizeBranch(Instruction instruction)
		{
			int num = ((Instruction)instruction.Operand).Offset - (instruction.Offset + instruction.OpCode.Size + 4);
			if (num < -128 || num > 127)
			{
				return false;
			}
			switch (instruction.OpCode.Code)
			{
			case Code.Br:
				instruction.OpCode = Mono.Cecil.Cil.OpCodes.Br_S;
				break;
			case Code.Brfalse:
				instruction.OpCode = Mono.Cecil.Cil.OpCodes.Brfalse_S;
				break;
			case Code.Brtrue:
				instruction.OpCode = Mono.Cecil.Cil.OpCodes.Brtrue_S;
				break;
			case Code.Beq:
				instruction.OpCode = Mono.Cecil.Cil.OpCodes.Beq_S;
				break;
			case Code.Bge:
				instruction.OpCode = Mono.Cecil.Cil.OpCodes.Bge_S;
				break;
			case Code.Bgt:
				instruction.OpCode = Mono.Cecil.Cil.OpCodes.Bgt_S;
				break;
			case Code.Ble:
				instruction.OpCode = Mono.Cecil.Cil.OpCodes.Ble_S;
				break;
			case Code.Blt:
				instruction.OpCode = Mono.Cecil.Cil.OpCodes.Blt_S;
				break;
			case Code.Bne_Un:
				instruction.OpCode = Mono.Cecil.Cil.OpCodes.Bne_Un_S;
				break;
			case Code.Bge_Un:
				instruction.OpCode = Mono.Cecil.Cil.OpCodes.Bge_Un_S;
				break;
			case Code.Bgt_Un:
				instruction.OpCode = Mono.Cecil.Cil.OpCodes.Bgt_Un_S;
				break;
			case Code.Ble_Un:
				instruction.OpCode = Mono.Cecil.Cil.OpCodes.Ble_Un_S;
				break;
			case Code.Blt_Un:
				instruction.OpCode = Mono.Cecil.Cil.OpCodes.Blt_Un_S;
				break;
			case Code.Leave:
				instruction.OpCode = Mono.Cecil.Cil.OpCodes.Leave_S;
				break;
			}
			return true;
		}

		private static void ComputeOffsets(Mono.Cecil.Cil.MethodBody body)
		{
			int num = 0;
			foreach (Instruction instruction in body.Instructions)
			{
				instruction.Offset = num;
				num += instruction.GetSize();
			}
		}
	}
	public interface IILVisitor
	{
		void OnInlineNone(Mono.Cecil.Cil.OpCode opcode);

		void OnInlineSByte(Mono.Cecil.Cil.OpCode opcode, sbyte value);

		void OnInlineByte(Mono.Cecil.Cil.OpCode opcode, byte value);

		void OnInlineInt32(Mono.Cecil.Cil.OpCode opcode, int value);

		void OnInlineInt64(Mono.Cecil.Cil.OpCode opcode, long value);

		void OnInlineSingle(Mono.Cecil.Cil.OpCode opcode, float value);

		void OnInlineDouble(Mono.Cecil.Cil.OpCode opcode, double value);

		void OnInlineString(Mono.Cecil.Cil.OpCode opcode, string value);

		void OnInlineBranch(Mono.Cecil.Cil.OpCode opcode, int offset);

		void OnInlineSwitch(Mono.Cecil.Cil.OpCode opcode, int[] offsets);

		void OnInlineVariable(Mono.Cecil.Cil.OpCode opcode, VariableDefinition variable);

		void OnInlineArgument(Mono.Cecil.Cil.OpCode opcode, ParameterDefinition parameter);

		void OnInlineSignature(Mono.Cecil.Cil.OpCode opcode, CallSite callSite);

		void OnInlineType(Mono.Cecil.Cil.OpCode opcode, TypeReference type);

		void OnInlineField(Mono.Cecil.Cil.OpCode opcode, FieldReference field);

		void OnInlineMethod(Mono.Cecil.Cil.OpCode opcode, MethodReference method);
	}
	public static class ILParser
	{
		private class ParseContext
		{
			public CodeReader Code { get; set; }

			public MetadataReader Metadata { get; set; }

			public Mono.Collections.Generic.Collection<VariableDefinition> Variables { get; set; }

			public IILVisitor Visitor { get; set; }
		}

		public static void Parse(MethodDefinition method, IILVisitor visitor)
		{
			if (method == null)
			{
				throw new ArgumentNullException("method");
			}
			if (visitor == null)
			{
				throw new ArgumentNullException("visitor");
			}
			if (!method.HasBody || !method.HasImage)
			{
				throw new ArgumentException();
			}
			ParseContext parseContext = CreateContext(method, visitor);
			CodeReader code = parseContext.Code;
			code.MoveTo(method.RVA);
			byte b = code.ReadByte();
			switch (b & 3)
			{
			case 2:
				ParseCode(b >> 2, parseContext);
				break;
			case 3:
				code.position--;
				ParseFatMethod(parseContext);
				break;
			default:
				throw new NotSupportedException();
			}
		}

		private static ParseContext CreateContext(MethodDefinition method, IILVisitor visitor)
		{
			CodeReader codeReader = method.Module.Read(method, (MethodDefinition _, MetadataReader reader) => new CodeReader(reader.image.MetadataSection, reader));
			return new ParseContext
			{
				Code = codeReader,
				Metadata = codeReader.reader,
				Visitor = visitor
			};
		}

		private static void ParseFatMethod(ParseContext context)
		{
			CodeReader code = context.Code;
			code.Advance(4);
			int code_size = code.ReadInt32();
			MetadataToken metadataToken = code.ReadToken();
			if (metadataToken != MetadataToken.Zero)
			{
				context.Variables = code.ReadVariables(metadataToken);
			}
			ParseCode(code_size, context);
		}

		private static void ParseCode(int code_size, ParseContext context)
		{
			CodeReader code = context.Code;
			MetadataReader metadata = context.Metadata;
			IILVisitor visitor = context.Visitor;
			int num = code.position + code_size;
			while (code.position < num)
			{
				byte b = code.ReadByte();
				Mono.Cecil.Cil.OpCode opCode = ((b != 254) ? Mono.Cecil.Cil.OpCodes.OneByteOpCode[b] : Mono.Cecil.Cil.OpCodes.TwoBytesOpCode[code.ReadByte()]);
				switch (opCode.OperandType)
				{
				case Mono.Cecil.Cil.OperandType.InlineNone:
					visitor.OnInlineNone(opCode);
					break;
				case Mono.Cecil.Cil.OperandType.InlineSwitch:
				{
					int num2 = code.ReadInt32();
					int[] array = new int[num2];
					for (int i = 0; i < num2; i++)
					{
						array[i] = code.ReadInt32();
					}
					visitor.OnInlineSwitch(opCode, array);
					break;
				}
				case Mono.Cecil.Cil.OperandType.ShortInlineBrTarget:
					visitor.OnInlineBranch(opCode, code.ReadSByte());
					break;
				case Mono.Cecil.Cil.OperandType.InlineBrTarget:
					visitor.OnInlineBranch(opCode, code.ReadInt32());
					break;
				case Mono.Cecil.Cil.OperandType.ShortInlineI:
					if (opCode == Mono.Cecil.Cil.OpCodes.Ldc_I4_S)
					{
						visitor.OnInlineSByte(opCode, code.ReadSByte());
					}
					else
					{
						visitor.OnInlineByte(opCode, code.ReadByte());
					}
					break;
				case Mono.Cecil.Cil.OperandType.InlineI:
					visitor.OnInlineInt32(opCode, code.ReadInt32());
					break;
				case Mono.Cecil.Cil.OperandType.InlineI8:
					visitor.OnInlineInt64(opCode, code.ReadInt64());
					break;
				case Mono.Cecil.Cil.OperandType.ShortInlineR:
					visitor.OnInlineSingle(opCode, code.ReadSingle());
					break;
				case Mono.Cecil.Cil.OperandType.InlineR:
					visitor.OnInlineDouble(opCode, code.ReadDouble());
					break;
				case Mono.Cecil.Cil.OperandType.InlineSig:
					visitor.OnInlineSignature(opCode, code.GetCallSite(code.ReadToken()));
					break;
				case Mono.Cecil.Cil.OperandType.InlineString:
					visitor.OnInlineString(opCode, code.GetString(code.ReadToken()));
					break;
				case Mono.Cecil.Cil.OperandType.ShortInlineArg:
					visitor.OnInlineArgument(opCode, code.GetParameter(code.ReadByte()));
					break;
				case Mono.Cecil.Cil.OperandType.InlineArg:
					visitor.OnInlineArgument(opCode, code.GetParameter(code.ReadInt16()));
					break;
				case Mono.Cecil.Cil.OperandType.ShortInlineVar:
					visitor.OnInlineVariable(opCode, GetVariable(context, code.ReadByte()));
					break;
				case Mono.Cecil.Cil.OperandType.InlineVar:
					visitor.OnInlineVariable(opCode, GetVariable(context, code.ReadInt16()));
					break;
				case Mono.Cecil.Cil.OperandType.InlineField:
				case Mono.Cecil.Cil.OperandType.InlineMethod:
				case Mono.Cecil.Cil.OperandType.InlineTok:
				case Mono.Cecil.Cil.OperandType.InlineType:
				{
					IMetadataTokenProvider metadataTokenProvider = metadata.LookupToken(code.ReadToken());
					switch (metadataTokenProvider.MetadataToken.TokenType)
					{
					case TokenType.TypeRef:
					case TokenType.TypeDef:
					case TokenType.TypeSpec:
						visitor.OnInlineType(opCode, (TypeReference)metadataTokenProvider);
						break;
					case TokenType.Method:
					case TokenType.MethodSpec:
						visitor.OnInlineMethod(opCode, (MethodReference)metadataTokenProvider);
						break;
					case TokenType.Field:
						visitor.OnInlineField(opCode, (FieldReference)metadataTokenProvider);
						break;
					case TokenType.MemberRef:
						if (metadataTokenProvider is FieldReference field)
						{
							visitor.OnInlineField(opCode, field);
							break;
						}
						if (metadataTokenProvider is MethodReference method)
						{
							visitor.OnInlineMethod(opCode, method);
							break;
						}
						throw new InvalidOperationException();
					}
					break;
				}
				}
			}
		}

		private static VariableDefinition GetVariable(ParseContext context, int index)
		{
			return context.Variables[index];
		}
	}
	public static class TypeReferenceRocks
	{
		public static ArrayType MakeArrayType(this TypeReference self)
		{
			return new ArrayType(self);
		}

		public static ArrayType MakeArrayType(this TypeReference self, int rank)
		{
			if (rank == 0)
			{
				throw new ArgumentOutOfRangeException("rank");
			}
			ArrayType arrayType = new ArrayType(self);
			for (int i = 1; i < rank; i++)
			{
				arrayType.Dimensions.Add(default(ArrayDimension));
			}
			return arrayType;
		}

		public static PointerType MakePointerType(this TypeReference self)
		{
			return new PointerType(self);
		}

		public static ByReferenceType MakeByReferenceType(this TypeReference self)
		{
			return new ByReferenceType(self);
		}

		public static OptionalModifierType MakeOptionalModifierType(this TypeReference self, TypeReference modifierType)
		{
			return new OptionalModifierType(modifierType, self);
		}

		public static RequiredModifierType MakeRequiredModifierType(this TypeReference self, TypeReference modifierType)
		{
			return new RequiredModifierType(modifierType, self);
		}

		public static GenericInstanceType MakeGenericInstanceType(this TypeReference self, params TypeReference[] arguments)
		{
			if (self == null)
			{
				throw new ArgumentNullException("self");
			}
			if (arguments == null)
			{
				throw new ArgumentNullException("arguments");
			}
			if (arguments.Length == 0)
			{
				throw new ArgumentException();
			}
			if (self.GenericParameters.Count != arguments.Length)
			{
				throw new ArgumentException();
			}
			GenericInstanceType genericInstanceType = new GenericInstanceType(self);
			foreach (TypeReference item in arguments)
			{
				genericInstanceType.GenericArguments.Add(item);
			}
			return genericInstanceType;
		}

		public static PinnedType MakePinnedType(this TypeReference self)
		{
			return new PinnedType(self);
		}

		public static SentinelType MakeSentinelType(this TypeReference self)
		{
			return new SentinelType(self);
		}
	}
	internal static class Functional
	{
		public static Func<A, R> Y<A, R>(Func<Func<A, R>, Func<A, R>> f)
		{
			Func<A, R> g = null;
			g = f((A a) => g(a));
			return g;
		}

		public static IEnumerable<TSource> Prepend<TSource>(this IEnumerable<TSource> source, TSource element)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return PrependIterator(source, element);
		}

		private static IEnumerable<TSource> PrependIterator<TSource>(IEnumerable<TSource> source, TSource element)
		{
			yield return element;
			foreach (TSource item in source)
			{
				yield return item;
			}
		}
	}
	public static class ModuleDefinitionRocks
	{
		public static IEnumerable<TypeDefinition> GetAllTypes(this ModuleDefinition self)
		{
			if (self == null)
			{
				throw new ArgumentNullException("self");
			}
			return self.Types.SelectMany(Functional.Y((Func<TypeDefinition, IEnumerable<TypeDefinition>> f) => (TypeDefinition type) => type.NestedTypes.SelectMany(f).Prepend(type)));
		}
	}
	public static class TypeDefinitionRocks
	{
		public static IEnumerable<MethodDefinition> GetConstructors(this TypeDefinition self)
		{
			if (self == null)
			{
				throw new ArgumentNullException("self");
			}
			if (!self.HasMethods)
			{
				return Empty<MethodDefinition>.Array;
			}
			return self.Methods.Where((MethodDefinition method) => method.IsConstructor);
		}

		public static MethodDefinition GetStaticConstructor(this TypeDefinition self)
		{
			if (self == null)
			{
				throw new ArgumentNullException("self");
			}
			if (!self.HasMethods)
			{
				return null;
			}
			return self.GetConstructors().FirstOrDefault((MethodDefinition ctor) => ctor.IsStatic);
		}

		public static IEnumerable<MethodDefinition> GetMethods(this TypeDefinition self)
		{
			if (self == null)
			{
				throw new ArgumentNullException("self");
			}
			if (!self.HasMethods)
			{
				return Empty<MethodDefinition>.Array;
			}
			return self.Methods.Where((MethodDefinition method) => !method.IsConstructor);
		}

		public static TypeReference GetEnumUnderlyingType(this TypeDefinition self)
		{
			if (self == null)
			{
				throw new ArgumentNullException("self");
			}
			if (!self.IsEnum)
			{
				throw new ArgumentException();
			}
			return Mixin.GetEnumUnderlyingType(self);
		}
	}
}
namespace WebSocketSharp
{
	public static class Ext
	{
		private static readonly byte[] _last = new byte[1];

		private static readonly int _retry = 5;

		private const string _tspecials = "()<>@,;:\\\"/[]?={} \t";

		private static byte[] compress(this byte[] data)
		{
			if (data.LongLength == 0)
			{
				return data;
			}
			using MemoryStream stream = new MemoryStream(data);
			return stream.compressToArray();
		}

		private static MemoryStream compress(this Stream stream)
		{
			MemoryStream memoryStream = new MemoryStream();
			if (stream.Length == 0)
			{
				return memoryStream;
			}
			stream.Position = 0L;
			using DeflateStream deflateStream = new DeflateStream(memoryStream, CompressionMode.Compress, leaveOpen: true);
			CopyTo(stream, deflateStream, 1024);
			deflateStream.Close();
			memoryStream.Write(_last, 0, 1);
			memoryStream.Position = 0L;
			return memoryStream;
		}

		private static byte[] compressToArray(this Stream stream)
		{
			using MemoryStream memoryStream = stream.compress();
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		private static byte[] decompress(this byte[] data)
		{
			if (data.LongLength == 0)
			{
				return data;
			}
			using MemoryStream stream = new MemoryStream(data);
			return stream.decompressToArray();
		}

		private static MemoryStream decompress(this Stream stream)
		{
			MemoryStream memoryStream = new MemoryStream();
			if (stream.Length == 0)
			{
				return memoryStream;
			}
			stream.Position = 0L;
			using DeflateStream source = new DeflateStream(stream, CompressionMode.Decompress, leaveOpen: true);
			CopyTo(source, memoryStream, 1024);
			memoryStream.Position = 0L;
			return memoryStream;
		}

		private static byte[] decompressToArray(this Stream stream)
		{
			using MemoryStream memoryStream = stream.decompress();
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		private static void times(this ulong n, Action action)
		{
			for (ulong num = 0uL; num < n; num++)
			{
				action();
			}
		}

		internal static byte[] Append(this ushort code, string reason)
		{
			byte[] array = code.InternalToByteArray(ByteOrder.Big);
			if (reason != null && reason.Length > 0)
			{
				List<byte> list = new List<byte>(array);
				list.AddRange(Encoding.UTF8.GetBytes(reason));
				array = list.ToArray();
			}
			return array;
		}

		internal static string CheckIfAvailable(this ServerState state, bool ready, bool start, bool shutting)
		{
			return ((!ready && (state == ServerState.Ready || state == ServerState.Stop)) || (!start && state == ServerState.Start) || (!shutting && state == ServerState.ShuttingDown)) ? ("This operation isn't available in: " + state.ToString().ToLower()) : null;
		}

		internal static string CheckIfAvailable(this WebSocketState state, bool connecting, bool open, bool closing, bool closed)
		{
			return ((!connecting && state == WebSocketState.Connecting) || (!open && state == WebSocketState.Open) || (!closing && state == WebSocketState.Closing) || (!closed && state == WebSocketState.Closed)) ? ("This operation isn't available in: " + state.ToString().ToLower()) : null;
		}

		internal static string CheckIfValidProtocols(this string[] protocols)
		{
			return protocols.Contains((string protocol) => protocol == null || protocol.Length == 0 || !protocol.IsToken()) ? "Contains an invalid value." : (protocols.ContainsTwice() ? "Contains a value twice." : null);
		}

		internal static string CheckIfValidServicePath(this string path)
		{
			return (path == null || path.Length == 0) ? "'path' is null or empty." : ((path[0] != '/') ? "'path' isn't an absolute path." : ((path.IndexOfAny(new char[2] { '?', '#' }) > -1) ? "'path' includes either or both query and fragment components." : null));
		}

		internal static string CheckIfValidSessionID(this string id)
		{
			return (id == null || id.Length == 0) ? "'id' is null or empty." : null;
		}

		internal static string CheckIfValidWaitTime(this TimeSpan time)
		{
			return (time <= TimeSpan.Zero) ? "A wait time is zero or less." : null;
		}

		internal static bool CheckWaitTime(this TimeSpan time, out string message)
		{
			message = null;
			if (time <= TimeSpan.Zero)
			{
				message = "A wait time is zero or less.";
				return false;
			}
			return true;
		}

		internal static void Close(this WebSocketSharp.Net.HttpListenerResponse response, WebSocketSharp.Net.HttpStatusCode code)
		{
			response.StatusCode = (int)code;
			response.OutputStream.Close();
		}

		internal static void CloseWithAuthChallenge(this WebSocketSharp.Net.HttpListenerResponse response, string challenge)
		{
			response.Headers.InternalSet("WWW-Authenticate", challenge, response: true);
			response.Close(WebSocketSharp.Net.HttpStatusCode.Unauthorized);
		}

		internal static byte[] Compress(this byte[] data, CompressionMethod method)
		{
			return (method == CompressionMethod.Deflate) ? data.compress() : data;
		}

		internal static Stream Compress(this Stream stream, CompressionMethod method)
		{
			return (method == CompressionMethod.Deflate) ? stream.compress() : stream;
		}

		internal static byte[] CompressToArray(this Stream stream, CompressionMethod method)
		{
			return (method == CompressionMethod.Deflate) ? stream.compressToArray() : stream.ToByteArray();
		}

		internal static bool Contains<T>(this IEnumerable<T> source, Func<T, bool> condition)
		{
			foreach (T item in source)
			{
				if (condition(item))
				{
					return true;
				}
			}
			return false;
		}

		internal static bool ContainsTwice(this string[] values)
		{
			int len = values.Length;
			Func<int, bool> contains = null;
			contains = delegate(int idx)
			{
				if (idx < len - 1)
				{
					for (int i = idx + 1; i < len; i++)
					{
						if (values[i] == values[idx])
						{
							return true;
						}
					}
					return contains(++idx);
				}
				return false;
			};
			return contains(0);
		}

		internal static T[] Copy<T>(this T[] source, long length)
		{
			T[] array = new T[length];
			Array.Copy(source, 0L, array, 0L, length);
			return array;
		}

		internal static void CopyTo(this Stream source, Stream destination, int bufferLength)
		{
			byte[] buffer = new byte[bufferLength];
			int num = 0;
			while ((num = source.Read(buffer, 0, bufferLength)) > 0)
			{
				destination.Write(buffer, 0, num);
			}
		}

		internal static void CopyToAsync(this Stream source, Stream destination, int bufferLength, Action completed, Action<Exception> error)
		{
			byte[] buff = new byte[bufferLength];
			AsyncCallback callback = null;
			callback = delegate(IAsyncResult ar)
			{
				try
				{
					int num = source.EndRead(ar);
					if (num <= 0)
					{
						if (completed != null)
						{
							completed();
						}
					}
					else
					{
						destination.Write(buff, 0, num);
						source.BeginRead(buff, 0, bufferLength, callback, null);
					}
				}
				catch (Exception obj2)
				{
					if (error != null)
					{
						error(obj2);
					}
				}
			};
			try
			{
				source.BeginRead(buff, 0, bufferLength, callback, null);
			}
			catch (Exception obj)
			{
				if (error != null)
				{
					error(obj);
				}
			}
		}

		internal static byte[] Decompress(this byte[] data, CompressionMethod method)
		{
			return (method == CompressionMethod.Deflate) ? data.decompress() : data;
		}

		internal static Stream Decompress(this Stream stream, CompressionMethod method)
		{
			return (method == CompressionMethod.Deflate) ? stream.decompress() : stream;
		}

		internal static byte[] DecompressToArray(this Stream stream, CompressionMethod method)
		{
			return (method == CompressionMethod.Deflate) ? stream.decompressToArray() : stream.ToByteArray();
		}

		internal static bool EqualsWith(this int value, char c, Action<int> action)
		{
			action(value);
			return value == c;
		}

		internal static string GetAbsolutePath(this Uri uri)
		{
			if (uri.IsAbsoluteUri)
			{
				return uri.AbsolutePath;
			}
			string originalString = uri.OriginalString;
			if (originalString[0] != '/')
			{
				return null;
			}
			int num = originalString.IndexOfAny(new char[2] { '?', '#' });
			return (num > 0) ? originalString.Substring(0, num) : originalString;
		}

		internal static string GetMessage(this CloseStatusCode code)
		{
			return code switch
			{
				CloseStatusCode.TlsHandshakeFailure => "An error has occurred during a TLS handshake.", 
				CloseStatusCode.ServerError => "WebSocket server got an internal error.", 
				CloseStatusCode.MandatoryExtension => "WebSocket client didn't receive expected extension(s).", 
				CloseStatusCode.TooBig => "A too big message has been received.", 
				CloseStatusCode.PolicyViolation => "A policy violation has occurred.", 
				CloseStatusCode.InvalidData => "Invalid data has been received.", 
				CloseStatusCode.Abnormal => "An exception has occurred.", 
				CloseStatusCode.UnsupportedData => "Unsupported data has been received.", 
				CloseStatusCode.ProtocolError => "A WebSocket protocol error has occurred.", 
				_ => string.Empty, 
			};
		}

		internal static string GetName(this string nameAndValue, char separator)
		{
			int num = nameAndValue.IndexOf(separator);
			return (num > 0) ? nameAndValue.Substring(0, num).Trim() : null;
		}

		internal static string GetValue(this string nameAndValue, char separator)
		{
			int num = nameAndValue.IndexOf(separator);
			return (num > -1 && num < nameAndValue.Length - 1) ? nameAndValue.Substring(num + 1).Trim() : null;
		}

		internal static string GetValue(this string nameAndValue, char separator, bool unquote)
		{
			int num = nameAndValue.IndexOf(separator);
			if (num < 0 || num == nameAndValue.Length - 1)
			{
				return null;
			}
			string text = nameAndValue.Substring(num + 1).Trim();
			return unquote ? text.Unquote() : text;
		}

		internal static TcpListenerWebSocketContext GetWebSocketContext(this TcpClient tcpClient, string protocol, bool secure, ServerSslConfiguration sslConfig, Logger logger)
		{
			return new TcpListenerWebSocketContext(tcpClient, protocol, secure, sslConfig, logger);
		}

		internal static byte[] InternalToByteArray(this ushort value, ByteOrder order)
		{
			byte[] bytes = BitConverter.GetBytes(value);
			if (!order.IsHostOrder())
			{
				Array.Reverse((Array)bytes);
			}
			return bytes;
		}

		internal static byte[] InternalToByteArray(this ulong value, ByteOrder order)
		{
			byte[] bytes = BitConverter.GetBytes(value);
			if (!order.IsHostOrder())
			{
				Array.Reverse((Array)bytes);
			}
			return bytes;
		}

		internal static bool IsCompressionExtension(this string value, CompressionMethod method)
		{
			return value.StartsWith(method.ToExtensionString());
		}

		internal static bool IsControl(this byte opcode)
		{
			return opcode > 7 && opcode < 16;
		}

		internal static bool IsControl(this Opcode opcode)
		{
			return (int)opcode >= 8;
		}

		internal static bool IsData(this byte opcode)
		{
			return opcode == 1 || opcode == 2;
		}

		internal static bool IsData(this Opcode opcode)
		{
			return opcode == Opcode.Text || opcode == Opcode.Binary;
		}

		internal static bool IsPortNumber(this int value)
		{
			return value > 0 && value < 65536;
		}

		internal static bool IsReserved(this ushort code)
		{
			return code == 1004 || code == 1005 || code == 1006 || code == 1015;
		}

		internal static bool IsReserved(this CloseStatusCode code)
		{
			return code == CloseStatusCode.Undefined || code == CloseStatusCode.NoStatus || code == CloseStatusCode.Abnormal || code == CloseStatusCode.TlsHandshakeFailure;
		}

		internal static bool IsSupported(this byte opcode)
		{
			return Enum.IsDefined(typeof(Opcode), opcode);
		}

		internal static bool IsText(this string value)
		{
			int length = value.Length;
			for (int i = 0; i < length; i++)
			{
				char c = value[i];
				if (c < ' ' && !Contains("\r\n\t", c))
				{
					return false;
				}
				switch (c)
				{
				case '\u007f':
					return false;
				case '\n':
					if (++i < length)
					{
						c = value[i];
						if (!Contains(" \t", c))
						{
							return false;
						}
					}
					break;
				}
			}
			return true;
		}

		internal static bool IsToken(this string value)
		{
			foreach (char c in value)
			{
				if (c < ' ' || c >= '\u007f' || Contains("()<>@,;:\\\"/[]?={} \t", c))
				{
					return false;
				}
			}
			return true;
		}

		internal static string Quote(this string value)
		{
			return string.Format("\"{0}\"", value.Replace("\"", "\\\""));
		}

		internal static byte[] ReadBytes(this Stream stream, int length)
		{
			byte[] array = new byte[length];
			int num = 0;
			try
			{
				int num2 = 0;
				while (length > 0)
				{
					num2 = stream.Read(array, num, length);
					if (num2 == 0)
					{
						break;
					}
					num += num2;
					length -= num2;
				}
			}
			catch
			{
			}
			return array.SubArray(0, num);
		}

		internal static byte[] ReadBytes(this Stream stream, long length, int bufferLength)
		{
			using MemoryStream memoryStream = new MemoryStream();
			try
			{
				byte[] buffer = new byte[bufferLength];
				int num = 0;
				while (length > 0)
				{
					if (length < bufferLength)
					{
						bufferLength = (int)length;
					}
					num = stream.Read(buffer, 0, bufferLength);
					if (num == 0)
					{
						break;
					}
					memoryStream.Write(buffer, 0, num);
					length -= num;
				}
			}
			catch
			{
			}
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		internal static void ReadBytesAsync(this Stream stream, int length, Action<byte[]> completed, Action<Exception> error)
		{
			byte[] buff = new byte[length];
			int offset = 0;
			int retry = 0;
			AsyncCallback callback = null;
			callback = delegate(IAsyncResult ar)
			{
				try
				{
					int num = stream.EndRead(ar);
					if (num == 0 && retry < _retry)
					{
						retry++;
						stream.BeginRead(buff, offset, length, callback, null);
					}
					else if (num == 0 || num == length)
					{
						if (completed != null)
						{
							completed(buff.SubArray(0, offset + num));
						}
					}
					else
					{
						retry = 0;
						offset += num;
						length -= num;
						stream.BeginRead(buff, offset, length, callback, null);
					}
				}
				catch (Exception obj2)
				{
					if (error != null)
					{
						error(obj2);
					}
				}
			};
			try
			{
				stream.BeginRead(buff, offset, length, callback, null);
			}
			catch (Exception obj)
			{
				if (error != null)
				{
					error(obj);
				}
			}
		}

		internal static void ReadBytesAsync(this Stream stream, long length, int bufferLength, Action<byte[]> completed, Action<Exception> error)
		{
			MemoryStream dest = new MemoryStream();
			byte[] buff = new byte[bufferLength];
			int retry = 0;
			Action<long> read = null;
			read = delegate(long len)
			{
				if (len < bufferLength)
				{
					bufferLength = (int)len;
				}
				stream.BeginRead(buff, 0, bufferLength, delegate(IAsyncResult ar)
				{
					try
					{
						int num = stream.EndRead(ar);
						if (num > 0)
						{
							dest.Write(buff, 0, num);
						}
						if (num == 0 && retry < _retry)
						{
							int num2 = retry;
							retry = num2 + 1;
							read(len);
						}
						else if (num == 0 || num == len)
						{
							if (completed != null)
							{
								dest.Close();
								completed(dest.ToArray());
							}
							dest.Dispose();
						}
						else
						{
							retry = 0;
							read(len - num);
						}
					}
					catch (Exception obj2)
					{
						dest.Dispose();
						if (error != null)
						{
							error(obj2);
						}
					}
				}, null);
			};
			try
			{
				read(length);
			}
			catch (Exception obj)
			{
				dest.Dispose();
				if (error != null)
				{
					error(obj);
				}
			}
		}

		internal static string RemovePrefix(this string value, params string[] prefixes)
		{
			int num = 0;
			foreach (string text in prefixes)
			{
				if (value.StartsWith(text))
				{
					num = text.Length;
					break;
				}
			}
			return (num > 0) ? value.Substring(num) : value;
		}

		internal static T[] Reverse<T>(this T[] array)
		{
			int num = array.Length;
			T[] array2 = new T[num];
			int num2 = num - 1;
			for (int i = 0; i <= num2; i++)
			{
				array2[i] = array[num2 - i];
			}
			return array2;
		}

		internal static IEnumerable<string> SplitHeaderValue(this string value, params char[] separators)
		{
			int len = value.Length;
			string seps = new string(separators);
			StringBuilder buff = new StringBuilder(32);
			bool escaped = false;
			bool quoted = false;
			for (int i = 0; i < len; i++)
			{
				char c = value[i];
				switch (c)
				{
				case '"':
					if (escaped)
					{
						escaped = !escaped;
					}
					else
					{
						quoted = !quoted;
					}
					break;
				case '\\':
					if (i < len - 1 && value[i + 1] == '"')
					{
						escaped = true;
					}
					break;
				default:
					if (Contains(seps, c) && !quoted)
					{
						yield return buff.ToString();
						buff.Length = 0;
						continue;
					}
					break;
				}
				buff.Append(c);
			}
			if (buff.Length > 0)
			{
				yield return buff.ToString();
			}
		}

		internal static byte[] ToByteArray(this Stream stream)
		{
			using MemoryStream memoryStream = new MemoryStream();
			stream.Position = 0L;
			CopyTo(stream, memoryStream, 1024);
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		internal static CompressionMethod ToCompressionMethod(this string value)
		{
			foreach (CompressionMethod value2 in Enum.GetValues(typeof(CompressionMethod)))
			{
				if (value2.ToExtensionString() == value)
				{
					return value2;
				}
			}
			return CompressionMethod.None;
		}

		internal static string ToExtensionString(this CompressionMethod method, params string[] parameters)
		{
			if (method == CompressionMethod.None)
			{
				return string.Empty;
			}
			string text = $"permessage-{method.ToString().ToLower()}";
			if (parameters == null || parameters.Length == 0)
			{
				return text;
			}
			return string.Format("{0}; {1}", text, parameters.ToString("; "));
		}

		internal static IPAddress ToIPAddress(this string hostnameOrAddress)
		{
			if (IPAddress.TryParse(hostnameOrAddress, out var address))
			{
				return address;
			}
			try
			{
				return Dns.GetHostAddresses(hostnameOrAddress)[0];
			}
			catch
			{
				return null;
			}
		}

		internal static List<TSource> ToList<TSource>(this IEnumerable<TSource> source)
		{
			return new List<TSource>(source);
		}

		internal static ushort ToUInt16(this byte[] source, ByteOrder sourceOrder)
		{
			return BitConverter.ToUInt16(source.ToHostOrder(sourceOrder), 0);
		}

		internal static ulong ToUInt64(this byte[] source, ByteOrder sourceOrder)
		{
			return BitConverter.ToUInt64(source.ToHostOrder(sourceOrder), 0);
		}

		internal static string TrimEndSlash(this string value)
		{
			value = value.TrimEnd(new char[1] { '/' });
			return (value.Length > 0) ? value : "/";
		}

		internal static bool TryCreateWebSocketUri(this string uriString, out Uri result, out string message)
		{
			result = null;
			Uri uri = uriString.ToUri();
			if (uri == null)
			{
				message = "An invalid URI string: " + uriString;
				return false;
			}
			if (!uri.IsAbsoluteUri)
			{
				message = "Not an absolute URI: " + uriString;
				return false;
			}
			string scheme = uri.Scheme;
			if (!(scheme == "ws") && !(scheme == "wss"))
			{
				message = "The scheme part isn't 'ws' or 'wss': " + uriString;
				return false;
			}
			if (uri.Fragment.Length > 0)
			{
				message = "Includes the fragment component: " + uriString;
				return false;
			}
			int port = uri.Port;
			if (port == 0)
			{
				message = "The port part is zero: " + uriString;
				return false;
			}
			result = ((port != -1) ? uri : new Uri(string.Format("{0}://{1}:{2}{3}", scheme, uri.Host, (scheme == "ws") ? 80 : 443, uri.PathAndQuery)));
			message = string.Empty;
			return true;
		}

		internal static string Unquote(this string value)
		{
			int num = value.IndexOf('"');
			if (num < 0)
			{
				return value;
			}
			int num2 = value.LastIndexOf('"');
			int num3 = num2 - num - 1;
			return (num3 < 0) ? value : ((num3 == 0) ? string.Empty : value.Substring(num + 1, num3).Replace("\\\"", "\""));
		}

		internal static string UTF8Decode(this byte[] bytes)
		{
			try
			{
				return Encoding.UTF8.GetString(bytes);
			}
			catch
			{
				return null;
			}
		}

		internal static byte[] UTF8Encode(this string s)
		{
			return Encoding.UTF8.GetBytes(s);
		}

		internal static void WriteBytes(this Stream stream, byte[] bytes, int bufferLength)
		{
			using MemoryStream source = new MemoryStream(bytes);
			CopyTo(source, stream, bufferLength);
		}

		internal static void WriteBytesAsync(this Stream stream, byte[] bytes, int bufferLength, Action completed, Action<Exception> error)
		{
			MemoryStream input = new MemoryStream(bytes);
			input.CopyToAsync(stream, bufferLength, delegate
			{
				if (completed != null)
				{
					completed();
				}
				input.Dispose();
			}, delegate(Exception ex)
			{
				input.Dispose();
				if (error != null)
				{
					error(ex);
				}
			});
		}

		public static bool Contains(this string value, params char[] chars)
		{
			return chars == null || chars.Length == 0 || (value != null && value.Length != 0 && value.IndexOfAny(chars) > -1);
		}

		public static bool Contains(this NameValueCollection collection, string name)
		{
			return collection != null && collection.Count > 0 && collection[name] != null;
		}

		public static bool Contains(this NameValueCollection collection, string name, string value)
		{
			if (collection == null || collection.Count == 0)
			{
				return false;
			}
			string text = collection[name];
			if (text == null)
			{
				return false;
			}
			string[] array = text.Split(new char[1] { ',' });
			foreach (string text2 in array)
			{
				if (text2.Trim().Equals(value, StringComparison.OrdinalIgnoreCase))
				{
					return true;
				}
			}
			return false;
		}

		public static void Emit(this EventHandler eventHandler, object sender, EventArgs e)
		{
			eventHandler?.Invoke(sender, e);
		}

		public static void Emit<TEventArgs>(this EventHandler<TEventArgs> eventHandler, object sender, TEventArgs e) where TEventArgs : EventArgs
		{
			eventHandler?.Invoke(sender, e);
		}

		public static WebSocketSharp.Net.CookieCollection GetCookies(this NameValueCollection headers, bool response)
		{
			string name = (response ? "Set-Cookie" : "Cookie");
			return (headers != null && headers.Contains(name)) ? WebSocketSharp.Net.CookieCollection.Parse(headers[name], response) : new WebSocketSharp.Net.CookieCollection();
		}

		public static string GetDescription(this WebSocketSharp.Net.HttpStatusCode code)
		{
			return ((int)code).GetStatusDescription();
		}

		public static string GetStatusDescription(this int code)
		{
			return code switch
			{
				100 => "Continue", 
				101 => "Switching Protocols", 
				102 => "Processing", 
				200 => "OK", 
				201 => "Created", 
				202 => "Accepted", 
				203 => "Non-Authoritative Information", 
				204 => "No Content", 
				205 => "Reset Content", 
				206 => "Partial Content", 
				207 => "Multi-Status", 
				300 => "Multiple Choices", 
				301 => "Moved Permanently", 
				302 => "Found", 
				303 => "See Other", 
				304 => "Not Modified", 
				305 => "Use Proxy", 
				307 => "Temporary Redirect", 
				400 => "Bad Request", 
				401 => "Unauthorized", 
				402 => "Payment Required", 
				403 => "Forbidden", 
				404 => "Not Found", 
				405 => "Method Not Allowed", 
				406 => "Not Acceptable", 
				407 => "Proxy Authentication Required", 
				408 => "Request Timeout", 
				409 => "Conflict", 
				410 => "Gone", 
				411 => "Length Required", 
				412 => "Precondition Failed", 
				413 => "Request Entity Too Large", 
				414 => "Request-Uri Too Long", 
				415 => "Unsupported Media Type", 
				416 => "Requested Range Not Satisfiable", 
				417 => "Expectation Failed", 
				422 => "Unprocessable Entity", 
				423 => "Locked", 
				424 => "Failed Dependency", 
				500 => "Internal Server Error", 
				501 => "Not Implemented", 
				502 => "Bad Gateway", 
				503 => "Service Unavailable", 
				504 => "Gateway Timeout", 
				505 => "Http Version Not Supported", 
				507 => "Insufficient Storage", 
				_ => string.Empty, 
			};
		}

		public static bool IsCloseStatusCode(this ushort value)
		{
			return value > 999 && value < 5000;
		}

		public static bool IsEnclosedIn(this string value, char c)
		{
			return value != null && value.Length > 1 && value[0] == c && value[value.Length - 1] == c;
		}

		public static bool IsHostOrder(this ByteOrder order)
		{
			return BitConverter.IsLittleEndian == (order == ByteOrder.Little);
		}

		public static bool IsLocal(this IPAddress address)
		{
			if (address == null)
			{
				return false;
			}
			if (address.Equals(IPAddress.Any))
			{
				return true;
			}
			if (address.Equals(IPAddress.Loopback))
			{
				return true;
			}
			if (Socket.OSSupportsIPv6)
			{
				if (address.Equals(IPAddress.IPv6Any))
				{
					return true;
				}
				if (address.Equals(IPAddress.IPv6Loopback))
				{
					return true;
				}
			}
			string hostName = Dns.GetHostName();
			IPAddress[] hostAddresses = Dns.GetHostAddresses(hostName);
			IPAddress[] array = hostAddresses;
			foreach (IPAddress obj in array)
			{
				if (address.Equals(obj))
				{
					return true;
				}
			}
			return false;
		}

		public static bool IsNullOrEmpty(this string value)
		{
			return value == null || value.Length == 0;
		}

		public static bool IsPredefinedScheme(this string value)
		{
			if (value == null || value.Length < 2)
			{
				return false;
			}
			char c = value[0];
			if (c == 'h')
			{
				return value == "http" || value == "https";
			}
			if (c == 'w')
			{
				return value == "ws" || value == "wss";
			}
			if (c == 'f')
			{
				return value == "file" || value == "ftp";
			}
			if (c == 'n')
			{
				c = value[1];
				return (c != 'e') ? (value == "nntp") : (value == "news" || value == "net.pipe" || value == "net.tcp");
			}
			return (c == 'g' && value == "gopher") || (c == 'm' && value == "mailto");
		}

		public static bool IsUpgradeTo(this WebSocketSharp.Net.HttpListenerRequest request, string protocol)
		{
			if (request == null)
			{
				throw new ArgumentNullException("request");
			}
			if (protocol == null)
			{
				throw new ArgumentNullException("protocol");
			}
			if (protocol.Length == 0)
			{
				throw new ArgumentException("An empty string.", "protocol");
			}
			return request.Headers.Contains("Upgrade", protocol) && request.Headers.Contains("Connection", "Upgrade");
		}

		public static bool MaybeUri(this string value)
		{
			if (value == null || value.Length == 0)
			{
				return false;
			}
			int num = value.IndexOf(':');
			if (num == -1)
			{
				return false;
			}
			if (num >= 10)
			{
				return false;
			}
			return value.Substring(0, num).IsPredefinedScheme();
		}

		public static T[] SubArray<T>(this T[] array, int startIndex, int length)
		{
			int num;
			if (array == null || (num = array.Length) == 0)
			{
				return new T[0];
			}
			if (startIndex < 0 || length <= 0 || startIndex + length > num)
			{
				return new T[0];
			}
			if (startIndex == 0 && length == num)
			{
				return array;
			}
			T[] array2 = new T[length];
			Array.Copy(array, startIndex, array2, 0, length);
			return array2;
		}

		public static T[] SubArray<T>(this T[] array, long startIndex, long length)
		{
			long num;
			if (array == null || (num = array.LongLength) == 0)
			{
				return new T[0];
			}
			if (startIndex < 0 || length <= 0 || startIndex + length > num)
			{
				return new T[0];
			}
			if (startIndex == 0L && length == num)
			{
				return array;
			}
			T[] array2 = new T[length];
			Array.Copy(array, startIndex, array2, 0L, length);
			return array2;
		}

		public static void Times(this int n, Action action)
		{
			if (n > 0 && action != null)
			{
				((ulong)n).times(action);
			}
		}

		public static void Times(this long n, Action action)
		{
			if (n > 0 && action != null)
			{
				((ulong)n).times(action);
			}
		}

		public static void Times(this uint n, Action action)
		{
			if (n != 0 && action != null)
			{
				times(n, action);
			}
		}

		public static void Times(this ulong n, Action action)
		{
			if (n != 0 && action != null)
			{
				n.times(action);
			}
		}

		public static void Times(this int n, Action<int> action)
		{
			if (n > 0 && action != null)
			{
				for (int i = 0; i < n; i++)
				{
					action(i);
				}
			}
		}

		public static void Times(this long n, Action<long> action)
		{
			if (n > 0 && action != null)
			{
				for (long num = 0L; num < n; num++)
				{
					action(num);
				}
			}
		}

		public static void Times(this uint n, Action<uint> action)
		{
			if (n != 0 && action != null)
			{
				for (uint num = 0u; num < n; num++)
				{
					action(num);
				}
			}
		}

		public static void Times(this ulong n, Action<ulong> action)
		{
			if (n != 0 && action != null)
			{
				for (ulong num = 0uL; num < n; num++)
				{
					action(num);
				}
			}
		}

		public static T To<T>(this byte[] source, ByteOrder sourceOrder) where T : struct
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (source.Length == 0)
			{
				return default(T);
			}
			Type typeFromHandle = typeof(T);
			byte[] value = source.ToHostOrder(sourceOrder);
			return ((object)typeFromHandle == typeof(bool)) ? ((T)(object)BitConverter.ToBoolean(value, 0)) : (((object)typeFromHandle == typeof(char)) ? ((T)(object)BitConverter.ToChar(value, 0)) : (((object)typeFromHandle == typeof(double)) ? ((T)(object)BitConverter.ToDouble(value, 0)) : (((object)typeFromHandle == typeof(short)) ? ((T)(object)BitConverter.ToInt16(value, 0)) : (((object)typeFromHandle == typeof(int)) ? ((T)(object)BitConverter.ToInt32(value, 0)) : (((object)typeFromHandle == typeof(long)) ? ((T)(object)BitConverter.ToInt64(value, 0)) : (((object)typeFromHandle == typeof(float)) ? ((T)(object)BitConverter.ToSingle(value, 0)) : (((object)typeFromHandle == typeof(ushort)) ? ((T)(object)BitConverter.ToUInt16(value, 0)) : (((object)typeFromHandle == typeof(uint)) ? ((T)(object)BitConverter.ToUInt32(value, 0)) : (((object)typeFromHandle == typeof(ulong)) ? ((T)(object)BitConverter.ToUInt64(value, 0)) : default(T))))))))));
		}

		public static byte[] ToByteArray<T>(this T value, ByteOrder order) where T : struct
		{
			Type typeFromHandle = typeof(T);
			byte[] array = (((object)typeFromHandle == typeof(bool)) ? BitConverter.GetBytes((bool)(object)value) : (((object)typeFromHandle != typeof(byte)) ? (((object)typeFromHandle == typeof(char)) ? BitConverter.GetBytes((char)(object)value) : (((object)typeFromHandle == typeof(double)) ? BitConverter.GetBytes((double)(object)value) : (((object)typeFromHandle == typeof(short)) ? BitConverter.GetBytes((short)(object)value) : (((object)typeFromHandle == typeof(int)) ? BitConverter.GetBytes((int)(object)value) : (((object)typeFromHandle == typeof(long)) ? BitConverter.GetBytes((long)(object)value) : (((object)typeFromHandle == typeof(float)) ? BitConverter.GetBytes((float)(object)value) : (((object)typeFromHandle == typeof(ushort)) ? BitConverter.GetBytes((ushort)(object)value) : (((object)typeFromHandle == typeof(uint)) ? BitConverter.GetBytes((uint)(object)value) : (((object)typeFromHandle == typeof(ulong)) ? BitConverter.GetBytes((ulong)(object)value) : WebSocket.EmptyBytes))))))))) : new byte[1] { (byte)(object)value }));
			if (array.Length > 1 && !order.IsHostOrder())
			{
				Array.Reverse((Array)array);
			}
			return array;
		}

		public static byte[] ToHostOrder(this byte[] source, ByteOrder sourceOrder)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return (source.Length > 1 && !sourceOrder.IsHostOrder()) ? source.Reverse() : source;
		}

		public static string ToString<T>(this T[] array, string separator)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			int num = array.Length;
			if (num == 0)
			{
				return string.Empty;
			}
			if (separator == null)
			{
				separator = string.Empty;
			}
			StringBuilder buff = new StringBuilder(64);
			(num - 1).Times(delegate(int i)
			{
				buff.AppendFormat("{0}{1}", array[i].ToString(), separator);
			});
			buff.Append(array[num - 1].ToString());
			return buff.ToString();
		}

		public static Uri ToUri(this string uriString)
		{
			Uri.TryCreate(uriString, uriString.MaybeUri() ? UriKind.Absolute : UriKind.Relative, out var result);
			return result;
		}

		public static string UrlDecode(this string value)
		{
			return (value != null && value.Length > 0) ? HttpUtility.UrlDecode(value) : value;
		}

		public static string UrlEncode(this string value)
		{
			return (value != null && value.Length > 0) ? HttpUtility.UrlEncode(value) : value;
		}

		public static void WriteContent(this WebSocketSharp.Net.HttpListenerResponse response, byte[] content)
		{
			if (response == null)
			{
				throw new ArgumentNullException("response");
			}
			if (content == null)
			{
				throw new ArgumentNullException("content");
			}
			long num = content.LongLength;
			if (num == 0)
			{
				response.Close();
				return;
			}
			response.ContentLength64 = num;
			Stream outputStream = response.OutputStream;
			if (num <= int.MaxValue)
			{
				outputStream.Write(content, 0, (int)num);
			}
			else
			{
				outputStream.WriteBytes(content, 1024);
			}
			outputStream.Close();
		}
	}
	public class MessageEventArgs : EventArgs
	{
		private string _data;

		private bool _dataSet;

		private Opcode _opcode;

		private byte[] _rawData;

		internal Opcode Opcode => _opcode;

		public string Data
		{
			get
			{
				if (!_dataSet)
				{
					_data = ((_opcode != Opcode.Binary) ? _rawData.UTF8Decode() : BitConverter.ToString(_rawData));
					_dataSet = true;
				}
				return _data;
			}
		}

		public bool IsBinary => _opcode == Opcode.Binary;

		public bool IsPing => _opcode == Opcode.Ping;

		public bool IsText => _opcode == Opcode.Text;

		public bool IsClose => _opcode == Opcode.Close;

		public byte[] RawData => _rawData;

		internal MessageEventArgs(WebSocketFrame frame)
		{
			_opcode = frame.Opcode;
			_rawData = frame.PayloadData.ApplicationData;
		}

		internal MessageEventArgs(Opcode opcode, byte[] rawData)
		{
			if ((ulong)rawData.LongLength > PayloadData.MaxLength)
			{
				throw new WebSocketException(CloseStatusCode.TooBig);
			}
			_opcode = opcode;
			_rawData = rawData;
		}
	}
	public class CloseEventArgs : EventArgs
	{
		private bool _clean;

		private PayloadData _payloadData;

		internal PayloadData PayloadData => _payloadData;

		public ushort Code => _payloadData.Code;

		public string Reason => _payloadData.Reason ?? string.Empty;

		public bool WasClean
		{
			get
			{
				return _clean;
			}
			internal set
			{
				_clean = value;
			}
		}

		internal CloseEventArgs()
		{
			_payloadData = PayloadData.Empty;
		}

		internal CloseEventArgs(ushort code)
			: this(code, null)
		{
		}

		internal CloseEventArgs(CloseStatusCode code)
			: this((ushort)code, null)
		{
		}

		internal CloseEventArgs(PayloadData payloadData)
		{
			_payloadData = payloadData;
		}

		internal CloseEventArgs(ushort code, string reason)
		{
			_payloadData = new PayloadData(code, reason);
		}

		internal CloseEventArgs(CloseStatusCode code, string reason)
			: this((ushort)code, reason)
		{
		}
	}
	public enum ByteOrder
	{
		Little,
		Big
	}
	public class ErrorEventArgs : EventArgs
	{
		private Exception _exception;

		private string _message;

		public Exception Exception => _exception;

		public string Message => _message;

		internal ErrorEventArgs(string message)
			: this(message, null)
		{
		}

		internal ErrorEventArgs(string message, Exception exception)
		{
			_message = message;
			_exception = exception;
		}
	}
	public class WebSocket : IDisposable
	{
		private AuthenticationChallenge _authChallenge;

		private string _base64Key;

		private bool _client;

		private Action _closeContext;

		private CompressionMethod _compression;

		private WebSocketContext _context;

		private WebSocketSharp.Net.CookieCollection _cookies;

		private WebSocketSharp.Net.NetworkCredential _credentials;

		private bool _emitOnPing;

		private bool _enableRedirection;

		private AutoResetEvent _exitReceiving;

		private string _extensions;

		private bool _extensionsRequested;

		private object _forMessageEventQueue;

		private object _forSend;

		private object _forState;

		private MemoryStream _fragmentsBuffer;

		private bool _fragmentsCompressed;

		private Opcode _fragmentsOpcode;

		private const string _guid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";

		private Func<WebSocketContext, string> _handshakeRequestChecker;

		private bool _ignoreExtensions;

		private bool _inContinuation;

		private volatile bool _inMessage;

		private volatile Logger _logger;

		private Action<MessageEventArgs> _message;

		private Queue<MessageEventArgs> _messageEventQueue;

		private uint _nonceCount;

		private string _origin;

		private bool _preAuth;

		private string _protocol;

		private string[] _protocols;

		private bool _protocolsRequested;

		private WebSocketSharp.Net.NetworkCredential _proxyCredentials;

		private Uri _proxyUri;

		private volatile WebSocketState _readyState;

		private AutoResetEvent _receivePong;

		private bool _secure;

		private ClientSslConfiguration _sslConfig;

		private Stream _stream;

		private TcpClient _tcpClient;

		private Uri _uri;

		private const string _version = "13";

		private TimeSpan _waitTime;

		internal static readonly byte[] EmptyBytes;

		internal static readonly int FragmentLength;

		internal static readonly RandomNumberGenerator RandomNumber;

		internal WebSocketSharp.Net.CookieCollection CookieCollection => _cookies;

		internal Func<WebSocketContext, string> CustomHandshakeRequestChecker
		{
			get
			{
				return _handshakeRequestChecker;
			}
			set
			{
				_handshakeRequestChecker = value;
			}
		}

		internal bool HasMessage
		{
			get
			{
				lock (_forMessageEventQueue)
				{
					return _messageEventQueue.Count > 0;
				}
			}
		}

		internal bool IgnoreExtensions
		{
			get
			{
				return _ignoreExtensions;
			}
			set
			{
				_ignoreExtensions = value;
			}
		}

		internal bool IsConnected => _readyState == WebSocketState.Open || _readyState == WebSocketState.Closing;

		public CompressionMethod Compression
		{
			get
			{
				return _compression;
			}
			set
			{
				lock (_forState)
				{
					if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
					{
						_logger.Error(text);
						error("An error has occurred in setting the compression.", null);
					}
					else
					{
						_compression = value;
					}
				}
			}
		}

		public IEnumerable<WebSocketSharp.Net.Cookie> Cookies
		{
			get
			{
				lock (_cookies.SyncRoot)
				{
					foreach (WebSocketSharp.Net.Cookie cookie in _cookies)
					{
						yield return cookie;
					}
				}
			}
		}

		public WebSocketSharp.Net.NetworkCredential Credentials => _credentials;

		public bool EmitOnPing
		{
			get
			{
				return _emitOnPing;
			}
			set
			{
				_emitOnPing = value;
			}
		}

		public bool EnableRedirection
		{
			get
			{
				return _enableRedirection;
			}
			set
			{
				lock (_forState)
				{
					if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
					{
						_logger.Error(text);
						error("An error has occurred in setting the enable redirection.", null);
					}
					else
					{
						_enableRedirection = value;
					}
				}
			}
		}

		public string Extensions => _extensions ?? string.Empty;

		public bool IsAlive => Ping();

		public bool IsSecure => _secure;

		public Logger Log
		{
			get
			{
				return _logger;
			}
			internal set
			{
				_logger = value;
			}
		}

		public string Origin
		{
			get
			{
				return _origin;
			}
			set
			{
				lock (_forState)
				{
					Uri result;
					if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
					{
						_logger.Error(text);
						error("An error has occurred in setting the origin.", null);
					}
					else if (value.IsNullOrEmpty())
					{
						_origin = value;
					}
					else if (!Uri.TryCreate(value, UriKind.Absolute, out result) || result.Segments.Length > 1)
					{
						_logger.Error("The syntax of an origin must be '<scheme>://<host>[:<port>]'.");
						error("An error has occurred in setting the origin.", null);
					}
					else
					{
						_origin = value.TrimEnd(new char[1] { '/' });
					}
				}
			}
		}

		public string Protocol
		{
			get
			{
				return _protocol ?? string.Empty;
			}
			internal set
			{
				_protocol = value;
			}
		}

		public WebSocketState ReadyState => _readyState;

		public ClientSslConfiguration SslConfiguration
		{
			get
			{
				return _client ? (_sslConfig ?? (_sslConfig = new ClientSslConfiguration(_uri.DnsSafeHost))) : null;
			}
			set
			{
				lock (_forState)
				{
					if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
					{
						_logger.Error(text);
						error("An error has occurred in setting the ssl configuration.", null);
					}
					else
					{
						_sslConfig = value;
					}
				}
			}
		}

		public Uri Url => _client ? _uri : _context.RequestUri;

		public TimeSpan WaitTime
		{
			get
			{
				return _waitTime;
			}
			set
			{
				lock (_forState)
				{
					if (!checkIfAvailable(client: true, server: true, connecting: true, open: false, closing: false, closed: true, out var text) || !value.CheckWaitTime(out text))
					{
						_logger.Error(text);
						error("An error has occurred in setting the wait time.", null);
					}
					else
					{
						_waitTime = value;
					}
				}
			}
		}

		public event EventHandler<CloseEventArgs> OnClose;

		public event EventHandler<ErrorEventArgs> OnError;

		public event EventHandler<MessageEventArgs> OnMessage;

		public event EventHandler OnOpen;

		static WebSocket()
		{
			EmptyBytes = new byte[0];
			FragmentLength = 1016;
			RandomNumber = new RNGCryptoServiceProvider();
		}

		internal WebSocket(HttpListenerWebSocketContext context, string protocol)
		{
			_context = context;
			_protocol = protocol;
			_closeContext = context.Close;
			_logger = context.Log;
			_message = messages;
			_secure = context.IsSecureConnection;
			_stream = context.Stream;
			_waitTime = TimeSpan.FromSeconds(1.0);
			init();
		}

		internal WebSocket(TcpListenerWebSocketContext context, string protocol)
		{
			_context = context;
			_protocol = protocol;
			_closeContext = context.Close;
			_logger = context.Log;
			_message = messages;
			_secure = context.IsSecureConnection;
			_stream = context.Stream;
			_waitTime = TimeSpan.FromSeconds(1.0);
			init();
		}

		public WebSocket(string url, params string[] protocols)
		{
			if (url == null)
			{
				throw new ArgumentNullException("url");
			}
			if (url.Length == 0)
			{
				throw new ArgumentException("An empty string.", "url");
			}
			if (!url.TryCreateWebSocketUri(out _uri, out var text))
			{
				throw new ArgumentException(text, "url");
			}
			if (protocols != null && protocols.Length != 0)
			{
				text = protocols.CheckIfValidProtocols();
				if (text != null)
				{
					throw new ArgumentException(text, "protocols");
				}
				_protocols = protocols;
			}
			_base64Key = CreateBase64Key();
			_client = true;
			_logger = new Logger();
			_message = messagec;
			_secure = _uri.Scheme == "wss";
			_waitTime = TimeSpan.FromSeconds(5.0);
			init();
		}

		private bool accept()
		{
			lock (_forState)
			{
				if (!checkIfAvailable(connecting: true, open: false, closing: false, closed: false, out var text))
				{
					_logger.Error(text);
					error("An error has occurred in accepting.", null);
					return false;
				}
				try
				{
					if (!acceptHandshake())
					{
						return false;
					}
					_readyState = WebSocketState.Open;
				}
				catch (Exception ex)
				{
					_logger.Fatal(ex.ToString());
					fatal("An exception has occurred while accepting.", ex);
					return false;
				}
				return true;
			}
		}

		private bool acceptHandshake()
		{
			_logger.Debug($"A request from {_context.UserEndPoint}:\n{_context}");
			if (!checkHandshakeRequest(_context, out var text))
			{
				sendHttpResponse(createHandshakeFailureResponse(WebSocketSharp.Net.HttpStatusCode.BadRequest));
				_logger.Fatal(text);
				fatal("An error has occurred while accepting.", CloseStatusCode.ProtocolError);
				return false;
			}
			if (!customCheckHandshakeRequest(_context, out text))
			{
				sendHttpResponse(createHandshakeFailureResponse(WebSocketSharp.Net.HttpStatusCode.BadRequest));
				_logger.Fatal(text);
				fatal("An error has occurred while accepting.", CloseStatusCode.PolicyViolation);
				return false;
			}
			_base64Key = _context.Headers["Sec-WebSocket-Key"];
			if (_protocol != null)
			{
				processSecWebSocketProtocolHeader(_context.SecWebSocketProtocols);
			}
			if (!_ignoreExtensions)
			{
				processSecWebSocketExtensionsClientHeader(_context.Headers["Sec-WebSocket-Extensions"]);
			}
			return sendHttpResponse(createHandshakeResponse());
		}

		private bool checkHandshakeRequest(WebSocketContext context, out string message)
		{
			message = null;
			if (context.RequestUri == null)
			{
				message = "Specifies an invalid Request-URI.";
				return false;
			}
			if (!context.IsWebSocketRequest)
			{
				message = "Not a WebSocket handshake request.";
				return false;
			}
			NameValueCollection headers = context.Headers;
			if (!validateSecWebSocketKeyHeader(headers["Sec-WebSocket-Key"]))
			{
				message = "Includes no Sec-WebSocket-Key header, or it has an invalid value.";
				return false;
			}
			if (!validateSecWebSocketVersionClientHeader(headers["Sec-WebSocket-Version"]))
			{
				message = "Includes no Sec-WebSocket-Version header, or it has an invalid value.";
				return false;
			}
			if (!validateSecWebSocketProtocolClientHeader(headers["Sec-WebSocket-Protocol"]))
			{
				message = "Includes an invalid Sec-WebSocket-Protocol header.";
				return false;
			}
			if (!_ignoreExtensions && !validateSecWebSocketExtensionsClientHeader(headers["Sec-WebSocket-Extensions"]))
			{
				message = "Includes an invalid Sec-WebSocket-Extensions header.";
				return false;
			}
			return true;
		}

		private bool checkHandshakeResponse(HttpResponse response, out string message)
		{
			message = null;
			if (response.IsRedirect)
			{
				message = "Indicates the redirection.";
				return false;
			}
			if (response.IsUnauthorized)
			{
				message = "Requires the authentication.";
				return false;
			}
			if (!response.IsWebSocketResponse)
			{
				message = "Not a WebSocket handshake response.";
				return false;
			}
			NameValueCollection headers = response.Headers;
			if (!validateSecWebSocketAcceptHeader(headers["Sec-WebSocket-Accept"]))
			{
				message = "Includes no Sec-WebSocket-Accept header, or it has an invalid value.";
				return false;
			}
			if (!validateSecWebSocketProtocolServerHeader(headers["Sec-WebSocket-Protocol"]))
			{
				message = "Includes no Sec-WebSocket-Protocol header, or it has an invalid value.";
				return false;
			}
			if (!validateSecWebSocketExtensionsServerHeader(headers["Sec-WebSocket-Extensions"]))
			{
				message = "Includes an invalid Sec-WebSocket-Extensions header.";
				return false;
			}
			if (!validateSecWebSocketVersionServerHeader(headers["Sec-WebSocket-Version"]))
			{
				message = "Includes an invalid Sec-WebSocket-Version header.";
				return false;
			}
			return true;
		}

		private bool checkIfAvailable(bool connecting, bool open, bool closing, bool closed, out string message)
		{
			message = null;
			if (!connecting && _readyState == WebSocketState.Connecting)
			{
				message = "This operation is not available in: connecting";
				return false;
			}
			if (!open && _readyState == WebSocketState.Open)
			{
				message = "This operation is not available in: open";
				return false;
			}
			if (!closing && _readyState == WebSocketState.Closing)
			{
				message = "This operation is not available in: closing";
				return false;
			}
			if (!closed && _readyState == WebSocketState.Closed)
			{
				message = "This operation is not available in: closed";
				return false;
			}
			return true;
		}

		private bool checkIfAvailable(bool client, bool server, bool connecting, bool open, bool closing, bool closed, out string message)
		{
			message = null;
			if (!client && _client)
			{
				message = "This operation is not available in: client";
				return false;
			}
			if (!server && !_client)
			{
				message = "This operation is not available in: server";
				return false;
			}
			return checkIfAvailable(connecting, open, closing, closed, out message);
		}

		private static bool checkParametersForSetCredentials(string username, string password, out string message)
		{
			message = null;
			if (username.IsNullOrEmpty())
			{
				return true;
			}
			if (Ext.Contains(username, ':') || !username.IsText())
			{
				message = "'username' contains an invalid character.";
				return false;
			}
			if (password.IsNullOrEmpty())
			{
				return true;
			}
			if (!password.IsText())
			{
				message = "'password' contains an invalid character.";
				return false;
			}
			return true;
		}

		private static bool checkParametersForSetProxy(string url, string username, string password, out string message)
		{
			message = null;
			if (url.IsNullOrEmpty())
			{
				return true;
			}
			if (!Uri.TryCreate(url, UriKind.Absolute, out var result) || result.Scheme != "http" || result.Segments.Length > 1)
			{
				message = "'url' is an invalid URL.";
				return false;
			}
			if (username.IsNullOrEmpty())
			{
				return true;
			}
			if (Ext.Contains(username, ':') || !username.IsText())
			{
				message = "'username' contains an invalid character.";
				return false;
			}
			if (password.IsNullOrEmpty())
			{
				return true;
			}
			if (!password.IsText())
			{
				message = "'password' contains an invalid character.";
				return false;
			}
			return true;
		}

		private bool checkReceivedFrame(WebSocketFrame frame, out string message)
		{
			message = null;
			bool isMasked = frame.IsMasked;
			if (_client && isMasked)
			{
				message = "A frame from the server is masked.";
				return false;
			}
			if (!_client && !isMasked)
			{
				message = "A frame from a client is not masked.";
				return false;
			}
			if (_inContinuation && frame.IsData)
			{
				message = "A data frame has been received while receiving continuation frames.";
				return false;
			}
			if (frame.IsCompressed && _compression == CompressionMethod.None)
			{
				message = "A compressed frame has been received without any agreement for it.";
				return false;
			}
			if (frame.Rsv2 == Rsv.On)
			{
				message = "The RSV2 of a frame is non-zero without any negotiation for it.";
				return false;
			}
			if (frame.Rsv3 == Rsv.On)
			{
				message = "The RSV3 of a frame is non-zero without any negotiation for it.";
				return false;
			}
			return true;
		}

		private void close(ushort code, string reason)
		{
			if (code == 1005)
			{
				close(new CloseEventArgs(), send: true, receive: true, received: false);
				return;
			}
			bool receive = !code.IsReserved();
			close(new CloseEventArgs(code, reason), receive, receive, received: false);
		}

		private void close(CloseEventArgs e, bool send, bool receive, bool received)
		{
			lock (_forState)
			{
				if (_readyState == WebSocketState.Closing)
				{
					_logger.Info("The closing is already in progress.");
					return;
				}
				if (_readyState == WebSocketState.Closed)
				{
					_logger.Info("The connection has been closed.");
					return;
				}
				send = send && _readyState == WebSocketState.Open;
				receive = receive && send;
				_readyState = WebSocketState.Closing;
			}
			_logger.Trace("Begin closing the connection.");
			byte[] frameAsBytes = (send ? WebSocketFrame.CreateCloseFrame(e.PayloadData, _client).ToArray() : null);
			e.WasClean = closeHandshake(frameAsBytes, receive, received);
			releaseResources();
			_logger.Trace("End closing the connection.");
			_readyState = WebSocketState.Closed;
			try
			{
				this.OnClose.Emit(this, e);
			}
			catch (Exception ex)
			{
				_logger.Error(ex.ToString());
				error("An exception has occurred during the OnClose event.", ex);
			}
		}

		private void closeAsync(ushort code, string reason)
		{
			if (code == 1005)
			{
				closeAsync(new CloseEventArgs(), send: true, receive: true, received: false);
				return;
			}
			bool receive = !code.IsReserved();
			closeAsync(new CloseEventArgs(code, reason), receive, receive, received: false);
		}

		private void closeAsync(CloseEventArgs e, bool send, bool receive, bool received)
		{
			Action<CloseEventArgs, bool, bool, bool> closer = close;
			closer.BeginInvoke(e, send, receive, received, delegate(IAsyncResult ar)
			{
				closer.EndInvoke(ar);
			}, null);
		}

		private bool closeHandshake(byte[] frameAsBytes, bool receive, bool received)
		{
			bool flag = frameAsBytes != null && sendBytes(frameAsBytes);
			received = received || (receive && flag && _exitReceiving != null && _exitReceiving.WaitOne(_waitTime));
			bool flag2 = flag && received;
			_logger.Debug($"Was clean?: {flag2}\n  sent: {flag}\n  received: {received}");
			return flag2;
		}

		private bool connect()
		{
			lock (_forState)
			{
				if (!checkIfAvailable(connecting: true, open: false, closing: false, closed: true, out var text))
				{
					_logger.Error(text);
					error("An error has occurred in connecting.", null);
					return false;
				}
				try
				{
					_readyState = WebSocketState.Connecting;
					if (!doHandshake())
					{
						return false;
					}
					_readyState = WebSocketState.Open;
				}
				catch (Exception ex)
				{
					_logger.Fatal(ex.ToString());
					fatal("An exception has occurred while connecting.", ex);
					return false;
				}
				return true;
			}
		}

		private string createExtensions()
		{
			StringBuilder stringBuilder = new StringBuilder(80);
			if (_compression != CompressionMethod.None)
			{
				string arg = _compression.ToExtensionString("server_no_context_takeover", "client_no_context_takeover");
				stringBuilder.AppendFormat("{0}, ", arg);
			}
			int length = stringBuilder.Length;
			if (length > 2)
			{
				stringBuilder.Length = length - 2;
				return stringBuilder.ToString();
			}
			return null;
		}

		private HttpResponse createHandshakeFailureResponse(WebSocketSharp.Net.HttpStatusCode code)
		{
			HttpResponse httpResponse = HttpResponse.CreateCloseResponse(code);
			httpResponse.Headers["Sec-WebSocket-Version"] = "13";
			return httpResponse;
		}

		private HttpRequest createHandshakeRequest()
		{
			HttpRequest httpRequest = HttpRequest.CreateWebSocketRequest(_uri);
			NameValueCollection headers = httpRequest.Headers;
			if (!_origin.IsNullOrEmpty())
			{
				headers["Origin"] = _origin;
			}
			headers["Sec-WebSocket-Key"] = _base64Key;
			_protocolsRequested = _protocols != null;
			if (_protocolsRequested)
			{
				headers["Sec-WebSocket-Protocol"] = _protocols.ToString(", ");
			}
			_extensionsRequested = _compression != CompressionMethod.None;
			if (_extensionsRequested)
			{
				headers["Sec-WebSocket-Extensions"] = createExtensions();
			}
			headers["Sec-WebSocket-Version"] = "13";
			AuthenticationResponse authenticationResponse = null;
			if (_authChallenge != null && _credentials != null)
			{
				authenticationResponse = new AuthenticationResponse(_authChallenge, _credentials, _nonceCount);
				_nonceCount = authenticationResponse.NonceCount;
			}
			else if (_preAuth)
			{
				authenticationResponse = new AuthenticationResponse(_credentials);
			}
			if (authenticationResponse != null)
			{
				headers["Authorization"] = authenticationResponse.ToString();
			}
			if (_cookies.Count > 0)
			{
				httpRequest.SetCookies(_cookies);
			}
			return httpRequest;
		}

		private HttpResponse createHandshakeResponse()
		{
			HttpResponse httpResponse = HttpResponse.CreateWebSocketResponse();
			NameValueCollection headers = httpResponse.Headers;
			headers["Sec-WebSocket-Accept"] = CreateResponseKey(_base64Key);
			if (_protocol != null)
			{
				headers["Sec-WebSocket-Protocol"] = _protocol;
			}
			if (_extensions != null)
			{
				headers["Sec-WebSocket-Extensions"] = _extensions;
			}
			if (_cookies.Count > 0)
			{
				httpResponse.SetCookies(_cookies);
			}
			return httpResponse;
		}

		private bool customCheckHandshakeRequest(WebSocketContext context, out string message)
		{
			message = null;
			return _handshakeRequestChecker == null || (message = _handshakeRequestChecker(context)) == null;
		}

		private MessageEventArgs dequeueFromMessageEventQueue()
		{
			lock (_forMessageEventQueue)
			{
				return (_messageEventQueue.Count > 0) ? _messageEventQueue.Dequeue() : null;
			}
		}

		private bool doHandshake()
		{
			setClientStream();
			HttpResponse httpResponse = sendHandshakeRequest();
			if (!checkHandshakeResponse(httpResponse, out var text))
			{
				_logger.Fatal(text);
				fatal("An error has occurred while connecting.", CloseStatusCode.ProtocolError);
				return false;
			}
			if (_protocolsRequested)
			{
				_protocol = httpResponse.Headers["Sec-WebSocket-Protocol"];
			}
			if (_extensionsRequested)
			{
				processSecWebSocketExtensionsServerHeader(httpResponse.Headers["Sec-WebSocket-Extensions"]);
			}
			processCookies(httpResponse.Cookies);
			return true;
		}

		private void enqueueToMessageEventQueue(MessageEventArgs e)
		{
			lock (_forMessageEventQueue)
			{
				_messageEventQueue.Enqueue(e);
			}
		}

		private void error(string message, Exception exception)
		{
			try
			{
				this.OnError.Emit(this, new ErrorEventArgs(message, exception));
			}
			catch (Exception ex)
			{
				_logger.Error(ex.ToString());
			}
		}

		private void fatal(string message, Exception exception)
		{
			CloseStatusCode code = ((exception is WebSocketException) ? ((WebSocketException)exception).Code : CloseStatusCode.Abnormal);
			fatal(message, code);
		}

		private void fatal(string message, CloseStatusCode code)
		{
			close(new CloseEventArgs(code, message), !code.IsReserved(), receive: false, received: false);
		}

		private void init()
		{
			_compression = CompressionMethod.None;
			_cookies = new WebSocketSharp.Net.CookieCollection();
			_forSend = new object();
			_forState = new object();
			_messageEventQueue = new Queue<MessageEventArgs>();
			_forMessageEventQueue = ((ICollection)_messageEventQueue).SyncRoot;
			_readyState = WebSocketState.Connecting;
		}

		private void message()
		{
			MessageEventArgs obj = null;
			lock (_forMessageEventQueue)
			{
				if (_inMessage || _messageEventQueue.Count == 0 || _readyState != WebSocketState.Open)
				{
					return;
				}
				_inMessage = true;
				obj = _messageEventQueue.Dequeue();
			}
			_message(obj);
		}

		private void messagec(MessageEventArgs e)
		{
			while (true)
			{
				try
				{
					this.OnMessage.Emit(this, e);
				}
				catch (Exception ex)
				{
					_logger.Error(ex.ToString());
					error("An exception has occurred during an OnMessage event.", ex);
				}
				lock (_forMessageEventQueue)
				{
					if (_messageEventQueue.Count == 0 || _readyState != WebSocketState.Open)
					{
						_inMessage = false;
						break;
					}
					e = _messageEventQueue.Dequeue();
				}
				bool flag = true;
			}
		}

		private void messages(MessageEventArgs e)
		{
			try
			{
				this.OnMessage.Emit(this, e);
			}
			catch (Exception ex)
			{
				_logger.Error(ex.ToString());
				error("An exception has occurred during an OnMessage event.", ex);
			}
			lock (_forMessageEventQueue)
			{
				if (_messageEventQueue.Count == 0 || _readyState != WebSocketState.Open)
				{
					_inMessage = false;
					return;
				}
				e = _messageEventQueue.Dequeue();
			}
			ThreadPool.QueueUserWorkItem(delegate
			{
				messages(e);
			});
		}

		private void open()
		{
			_inMessage = true;
			startReceiving();
			try
			{
				this.OnOpen.Emit(this, EventArgs.Empty);
			}
			catch (Exception ex)
			{
				_logger.Error(ex.ToString());
				error("An exception has occurred during the OnOpen event.", ex);
			}
			MessageEventArgs obj = null;
			lock (_forMessageEventQueue)
			{
				if (_messageEventQueue.Count == 0 || _readyState != WebSocketState.Open)
				{
					_inMessage = false;
					return;
				}
				obj = _messageEventQueue.Dequeue();
			}
			_message.BeginInvoke(obj, delegate(IAsyncResult ar)
			{
				_message.EndInvoke(ar);
			}, null);
		}

		private bool processCloseFrame(WebSocketFrame frame)
		{
			PayloadData payloadData = frame.PayloadData;
			close(new CloseEventArgs(payloadData), !payloadData.HasReservedCode, receive: false, received: true);
			return false;
		}

		private void processCookies(WebSocketSharp.Net.CookieCollection cookies)
		{
			if (cookies.Count != 0)
			{
				_cookies.SetOrRemove(cookies);
			}
		}

		private bool processDataFrame(WebSocketFrame frame)
		{
			enqueueToMessageEventQueue(frame.IsCompressed ? new MessageEventArgs(frame.Opcode, frame.PayloadData.ApplicationData.Decompress(_compression)) : new MessageEventArgs(frame));
			return true;
		}

		private bool processFragmentFrame(WebSocketFrame frame)
		{
			if (!_inContinuation)
			{
				if (frame.IsContinuation)
				{
					return true;
				}
				_fragmentsOpcode = frame.Opcode;
				_fragmentsCompressed = frame.IsCompressed;
				_fragmentsBuffer = new MemoryStream();
				_inContinuation = true;
			}
			_fragmentsBuffer.WriteBytes(frame.PayloadData.ApplicationData, 1024);
			if (frame.IsFinal)
			{
				using (_fragmentsBuffer)
				{
					byte[] rawData = (_fragmentsCompressed ? _fragmentsBuffer.DecompressToArray(_compression) : _fragmentsBuffer.ToArray());
					enqueueToMessageEventQueue(new MessageEventArgs(_fragmentsOpcode, rawData));
				}
				_fragmentsBuffer = null;
				_inContinuation = false;
			}
			return true;
		}

		private bool processPingFrame(WebSocketFrame frame)
		{
			if (send(new WebSocketFrame(Opcode.Pong, frame.PayloadData, _client).ToArray()))
			{
				_logger.Trace("Returned a pong.");
			}
			if (_emitOnPing)
			{
				enqueueToMessageEventQueue(new MessageEventArgs(frame));
			}
			return true;
		}

		private bool processPongFrame(WebSocketFrame frame)
		{
			_receivePong.Set();
			_logger.Trace("Received a pong.");
			return true;
		}

		private bool processReceivedFrame(WebSocketFrame frame)
		{
			if (!checkReceivedFrame(frame, out var text))
			{
				throw new WebSocketException(CloseStatusCode.ProtocolError, text);
			}
			frame.Unmask();
			return frame.IsFragment ? processFragmentFrame(frame) : (frame.IsData ? processDataFrame(frame) : (frame.IsPing ? processPingFrame(frame) : (frame.IsPong ? processPongFrame(frame) : (frame.IsClose ? processCloseFrame(frame) : processUnsupportedFrame(frame)))));
		}

		private void processSecWebSocketExtensionsClientHeader(string value)
		{
			if (value == null)
			{
				return;
			}
			StringBuilder stringBuilder = new StringBuilder(80);
			bool flag = false;
			foreach (string item in value.SplitHeaderValue(','))
			{
				string value2 = item.Trim();
				if (!flag && value2.IsCompressionExtension(CompressionMethod.Deflate))
				{
					_compression = CompressionMethod.Deflate;
					stringBuilder.AppendFormat("{0}, ", _compression.ToExtensionString("client_no_context_takeover", "server_no_context_takeover"));
					flag = true;
				}
			}
			int length = stringBuilder.Length;
			if (length > 2)
			{
				stringBuilder.Length = length - 2;
				_extensions = stringBuilder.ToString();
			}
		}

		private void processSecWebSocketExtensionsServerHeader(string value)
		{
			if (value == null)
			{
				_compression = CompressionMethod.None;
			}
			else
			{
				_extensions = value;
			}
		}

		private void processSecWebSocketProtocolHeader(IEnumerable<string> values)
		{
			if (!values.Contains((string p) => p == _protocol))
			{
				_protocol = null;
			}
		}

		private bool processUnsupportedFrame(WebSocketFrame frame)
		{
			_logger.Fatal("An unsupported frame:" + frame.PrintToString(dumped: false));
			fatal("There is no way to handle it.", CloseStatusCode.PolicyViolation);
			return false;
		}

		private void releaseClientResources()
		{
			if (_stream != null)
			{
				_stream.Dispose();
				_stream = null;
			}
			if (_tcpClient != null)
			{
				_tcpClient.Close();
				_tcpClient = null;
			}
		}

		private void releaseCommonResources()
		{
			if (_fragmentsBuffer != null)
			{
				_fragmentsBuffer.Dispose();
				_fragmentsBuffer = null;
				_inContinuation = false;
			}
			if (_receivePong != null)
			{
				_receivePong.Close();
				_receivePong = null;
			}
			if (_exitReceiving != null)
			{
				_exitReceiving.Close();
				_exitReceiving = null;
			}
		}

		private void releaseResources()
		{
			if (_client)
			{
				releaseClientResources();
			}
			else
			{
				releaseServerResources();
			}
			releaseCommonResources();
		}

		private void releaseServerResources()
		{
			if (_closeContext != null)
			{
				_closeContext();
				_closeContext = null;
				_stream = null;
				_context = null;
			}
		}

		private bool send(byte[] frameAsBytes)
		{
			lock (_forState)
			{
				if (_readyState != WebSocketState.Open)
				{
					_logger.Error("The sending has been interrupted.");
					return false;
				}
				return sendBytes(frameAsBytes);
			}
		}

		private bool send(Opcode opcode, Stream stream)
		{
			lock (_forSend)
			{
				Stream stream2 = stream;
				bool flag = false;
				bool flag2 = false;
				try
				{
					if (_compression != CompressionMethod.None)
					{
						stream = stream.Compress(_compression);
						flag = true;
					}
					flag2 = send(opcode, stream, flag);
					if (!flag2)
					{
						error("The sending has been interrupted.", null);
					}
				}
				catch (Exception ex)
				{
					_logger.Error(ex.ToString());
					error("An exception has occurred while sending data.", ex);
				}
				finally
				{
					if (flag)
					{
						stream.Dispose();
					}
					stream2.Dispose();
				}
				return flag2;
			}
		}

		private bool send(Opcode opcode, Stream stream, bool compressed)
		{
			long length = stream.Length;
			if (length == 0)
			{
				return send(Fin.Final, opcode, EmptyBytes, compressed);
			}
			long num = length / FragmentLength;
			int num2 = (int)(length % FragmentLength);
			byte[] array = null;
			if (num == 0)
			{
				array = new byte[num2];
				return stream.Read(array, 0, num2) == num2 && send(Fin.Final, opcode, array, compressed);
			}
			array = new byte[FragmentLength];
			if (num == 1 && num2 == 0)
			{
				return stream.Read(array, 0, FragmentLength) == FragmentLength && send(Fin.Final, opcode, array, compressed);
			}
			if (stream.Read(array, 0, FragmentLength) != FragmentLength || !send(Fin.More, opcode, array, compressed))
			{
				return false;
			}
			long num3 = ((num2 == 0) ? (num - 2) : (num - 1));
			for (long num4 = 0L; num4 < num3; num4++)
			{
				if (stream.Read(array, 0, FragmentLength) != FragmentLength || !send(Fin.More, Opcode.Cont, array, compressed))
				{
					return false;
				}
			}
			if (num2 == 0)
			{
				num2 = FragmentLength;
			}
			else
			{
				array = new byte[num2];
			}
			return stream.Read(array, 0, num2) == num2 && send(Fin.Final, Opcode.Cont, array, compressed);
		}

		private bool send(Fin fin, Opcode opcode, byte[] data, bool compressed)
		{
			lock (_forState)
			{
				if (_readyState != WebSocketState.Open)
				{
					_logger.Error("The sending has been interrupted.");
					return false;
				}
				return sendBytes(new WebSocketFrame(fin, opcode, data, compressed, _client).ToArray());
			}
		}

		private void sendAsync(Opcode opcode, Stream stream, Action<bool> completed)
		{
			Func<Opcode, Stream, bool> sender = send;
			sender.BeginInvoke(opcode, stream, delegate(IAsyncResult ar)
			{
				try
				{
					bool obj = sender.EndInvoke(ar);
					if (completed != null)
					{
						completed(obj);
					}
				}
				catch (Exception ex)
				{
					_logger.Error(ex.ToString());
					error("An exception has occurred during a send callback.", ex);
				}
			}, null);
		}

		private bool sendBytes(byte[] bytes)
		{
			try
			{
				_stream.Write(bytes, 0, bytes.Length);
				return true;
			}
			catch (Exception ex)
			{
				_logger.Error(ex.ToString());
				return false;
			}
		}

		private HttpResponse sendHandshakeRequest()
		{
			HttpRequest httpRequest = createHandshakeRequest();
			HttpResponse httpResponse = sendHttpRequest(httpRequest, 90000);
			if (httpResponse.IsUnauthorized)
			{
				string text = httpResponse.Headers["WWW-Authenticate"];
				_logger.Warn($"Received an authentication requirement for '{text}'.");
				if (text.IsNullOrEmpty())
				{
					_logger.Error("No authentication challenge is specified.");
					return httpResponse;
				}
				_authChallenge = AuthenticationChallenge.Parse(text);
				if (_authChallenge == null)
				{
					_logger.Error("An invalid authentication challenge is specified.");
					return httpResponse;
				}
				if (_credentials != null && (!_preAuth || _authChallenge.Scheme == WebSocketSharp.Net.AuthenticationSchemes.Digest))
				{
					if (httpResponse.HasConnectionClose)
					{
						releaseClientResources();
						setClientStream();
					}
					AuthenticationResponse authenticationResponse = new AuthenticationResponse(_authChallenge, _credentials, _nonceCount);
					_nonceCount = authenticationResponse.NonceCount;
					httpRequest.Headers["Authorization"] = authenticationResponse.ToString();
					httpResponse = sendHttpRequest(httpRequest, 15000);
				}
			}
			if (httpResponse.IsRedirect)
			{
				string text2 = httpResponse.Headers["Location"];
				_logger.Warn($"Received a redirection to '{text2}'.");
				if (_enableRedirection)
				{
					if (text2.IsNullOrEmpty())
					{
						_logger.Error("No url to redirect is located.");
						return httpResponse;
					}
					if (!text2.TryCreateWebSocketUri(out var result, out var text3))
					{
						_logger.Error("An invalid url to redirect is located: " + text3);
						return httpResponse;
					}
					releaseClientResources();
					_uri = result;
					_secure = result.Scheme == "wss";
					setClientStream();
					return sendHandshakeRequest();
				}
			}
			return httpResponse;
		}

		private HttpResponse sendHttpRequest(HttpRequest request, int millisecondsTimeout)
		{
			_logger.Debug("A request to the server:\n" + request.ToString());
			HttpResponse response = request.GetResponse(_stream, millisecondsTimeout);
			_logger.Debug("A response to this request:\n" + response.ToString());
			return response;
		}

		private bool sendHttpResponse(HttpResponse response)
		{
			_logger.Debug("A response to this request:\n" + response.ToString());
			return sendBytes(response.ToByteArray());
		}

		private void sendProxyConnectRequest()
		{
			HttpRequest httpRequest = HttpRequest.CreateConnectRequest(_uri);
			HttpResponse httpResponse = sendHttpRequest(httpRequest, 90000);
			if (httpResponse.IsProxyAuthenticationRequired)
			{
				string text = httpResponse.Headers["Proxy-Authenticate"];
				_logger.Warn($"Received a proxy authentication requirement for '{text}'.");
				if (text.IsNullOrEmpty())
				{
					throw new WebSocketException("No proxy authentication challenge is specified.");
				}
				AuthenticationChallenge authenticationChallenge = AuthenticationChallenge.Parse(text);
				if (authenticationChallenge == null)
				{
					throw new WebSocketException("An invalid proxy authentication challenge is specified.");
				}
				if (_proxyCredentials != null)
				{
					if (httpResponse.HasConnectionClose)
					{
						releaseClientResources();
						_tcpClient = new TcpClient(_proxyUri.DnsSafeHost, _proxyUri.Port);
						_stream = _tcpClient.GetStream();
					}
					AuthenticationResponse authenticationResponse = new AuthenticationResponse(authenticationChallenge, _proxyCredentials, 0u);
					httpRequest.Headers["Proxy-Authorization"] = authenticationResponse.ToString();
					httpResponse = sendHttpRequest(httpRequest, 15000);
				}
				if (httpResponse.IsProxyAuthenticationRequired)
				{
					throw new WebSocketException("A proxy authentication is required.");
				}
			}
			if (httpResponse.StatusCode[0] != '2')
			{
				throw new WebSocketException("The proxy has failed a connection to the requested host and port.");
			}
		}

		private void setClientStream()
		{
			if (_proxyUri != null)
			{
				_tcpClient = new TcpClient(_proxyUri.DnsSafeHost, _proxyUri.Port);
				_stream = _tcpClient.GetStream();
				sendProxyConnectRequest();
			}
			else
			{
				_tcpClient = new TcpClient(_uri.DnsSafeHost, _uri.Port);
				_stream = _tcpClient.GetStream();
			}
			if (_secure)
			{
				ClientSslConfiguration sslConfiguration = SslConfiguration;
				string targetHost = sslConfiguration.TargetHost;
				if (targetHost != _uri.DnsSafeHost)
				{
					throw new WebSocketException(CloseStatusCode.TlsHandshakeFailure, "An invalid host name is specified.");
				}
				try
				{
					SslStream sslStream = new SslStream(_stream, leaveInnerStreamOpen: false, sslConfiguration.ServerCertificateValidationCallback, sslConfiguration.ClientCertificateSelectionCallback);
					sslStream.AuthenticateAsClient(targetHost, sslConfiguration.ClientCertificates, sslConfiguration.EnabledSslProtocols, sslConfiguration.CheckCertificateRevocation);
					_stream = sslStream;
				}
				catch (Exception innerException)
				{
					throw new WebSocketException(CloseStatusCode.TlsHandshakeFailure, innerException);
				}
			}
		}

		private void startReceiving()
		{
			if (_messageEventQueue.Count > 0)
			{
				_messageEventQueue.Clear();
			}
			_exitReceiving = new AutoResetEvent(initialState: false);
			_receivePong = new AutoResetEvent(initialState: false);
			Action receive = null;
			receive = delegate
			{
				WebSocketFrame.ReadFrameAsync(_stream, unmask: false, delegate(WebSocketFrame frame)
				{
					if (!processReceivedFrame(frame) || _readyState == WebSocketState.Closed)
					{
						_exitReceiving?.Set();
					}
					else
					{
						receive();
						if (!_inMessage && HasMessage && _readyState == WebSocketState.Open)
						{
							message();
						}
					}
				}, delegate(Exception ex)
				{
					_logger.Fatal(ex.ToString());
					fatal("An exception has occurred while receiving.", ex);
				});
			};
			receive();
		}

		private bool validateSecWebSocketAcceptHeader(string value)
		{
			return value != null && value == CreateResponseKey(_base64Key);
		}

		private bool validateSecWebSocketExtensionsClientHeader(string value)
		{
			return value == null || value.Length > 0;
		}

		private bool validateSecWebSocketExtensionsServerHeader(string value)
		{
			if (value == null)
			{
				return true;
			}
			if (value.Length == 0)
			{
				return false;
			}
			if (!_extensionsRequested)
			{
				return false;
			}
			bool flag = _compression != CompressionMethod.None;
			foreach (string item in value.SplitHeaderValue(','))
			{
				string text = item.Trim();
				if (flag && text.IsCompressionExtension(_compression))
				{
					if (!text.Contains("server_no_context_takeover"))
					{
						_logger.Error("The server hasn't sent back 'server_no_context_takeover'.");
						return false;
					}
					if (!text.Contains("client_no_context_takeover"))
					{
						_logger.Warn("The server hasn't sent back 'client_no_context_takeover'.");
					}
					string method = _compression.ToExtensionString();
					if (text.SplitHeaderValue(';').Contains(delegate(string t)
					{
						t = t.Trim();
						return t != method && t != "server_no_context_takeover" && t != "client_no_context_takeover";
					}))
					{
						return false;
					}
					continue;
				}
				return false;
			}
			return true;
		}

		private bool validateSecWebSocketKeyHeader(string value)
		{
			return value != null && value.Length > 0;
		}

		private bool validateSecWebSocketProtocolClientHeader(string value)
		{
			return value == null || value.Length > 0;
		}

		private bool validateSecWebSocketProtocolServerHeader(string value)
		{
			if (value == null)
			{
				return !_protocolsRequested;
			}
			if (value.Length == 0)
			{
				return false;
			}
			return _protocolsRequested && _protocols.Contains((string p) => p == value);
		}

		private bool validateSecWebSocketVersionClientHeader(string value)
		{
			return value != null && value == "13";
		}

		private bool validateSecWebSocketVersionServerHeader(string value)
		{
			return value == null || value == "13";
		}

		internal static bool CheckParametersForClose(ushort code, string reason, bool client, out string message)
		{
			message = null;
			if (!code.IsCloseStatusCode())
			{
				message = "'code' is an invalid status code.";
				return false;
			}
			if (code == 1005 && !reason.IsNullOrEmpty())
			{
				message = "'code' cannot have a reason.";
				return false;
			}
			if (code == 1010 && !client)
			{
				message = "'code' cannot be used by a server.";
				return false;
			}
			if (code == 1011 && client)
			{
				message = "'code' cannot be used by a client.";
				return false;
			}
			if (!reason.IsNullOrEmpty() && reason.UTF8Encode().Length > 123)
			{
				message = "The size of 'reason' is greater than the allowable max size.";
				return false;
			}
			return true;
		}

		internal static bool CheckParametersForClose(CloseStatusCode code, string reason, bool client, out string message)
		{
			message = null;
			if (code == CloseStatusCode.NoStatus && !reason.IsNullOrEmpty())
			{
				message = "'code' cannot have a reason.";
				return false;
			}
			if (code == CloseStatusCode.MandatoryExtension && !client)
			{
				message = "'code' cannot be used by a server.";
				return false;
			}
			if (code == CloseStatusCode.ServerError && client)
			{
				message = "'code' cannot be used by a client.";
				return false;
			}
			if (!reason.IsNullOrEmpty() && reason.UTF8Encode().Length > 123)
			{
				message = "The size of 'reason' is greater than the allowable max size.";
				return false;
			}
			return true;
		}

		internal static string CheckPingParameter(string message, out byte[] bytes)
		{
			bytes = message.UTF8Encode();
			return (bytes.Length > 125) ? "A message has greater than the allowable max size." : null;
		}

		internal static string CheckSendParameter(byte[] data)
		{
			return (data == null) ? "'data' is null." : null;
		}

		internal static string CheckSendParameter(FileInfo file)
		{
			return (file == null) ? "'file' is null." : null;
		}

		internal static string CheckSendParameter(string data)
		{
			return (data == null) ? "'data' is null." : null;
		}

		internal static string CheckSendParameters(Stream stream, int length)
		{
			return (stream == null) ? "'stream' is null." : ((!stream.CanRead) ? "'stream' cannot be read." : ((length < 1) ? "'length' is less than 1." : null));
		}

		internal void Close(HttpResponse response)
		{
			_readyState = WebSocketState.Closing;
			sendHttpResponse(response);
			releaseServerResources();
			_readyState = WebSocketState.Closed;
		}

		internal void Close(WebSocketSharp.Net.HttpStatusCode code)
		{
			Close(createHandshakeFailureResponse(code));
		}

		internal void Close(CloseEventArgs e, byte[] frameAsBytes, bool receive)
		{
			lock (_forState)
			{
				if (_readyState == WebSocketState.Closing)
				{
					_logger.Info("The closing is already in progress.");
					return;
				}
				if (_readyState == WebSocketState.Closed)
				{
					_logger.Info("The connection has been closed.");
					return;
				}
				_readyState = WebSocketState.Closing;
			}
			e.WasClean = closeHandshake(frameAsBytes, receive, received: false);
			releaseServerResources();
			releaseCommonResources();
			_readyState = WebSocketState.Closed;
			try
			{
				this.OnClose.Emit(this, e);
			}
			catch (Exception ex)
			{
				_logger.Error(ex.ToString());
			}
		}

		internal static string CreateBase64Key()
		{
			byte[] array = new byte[16];
			RandomNumber.GetBytes(array);
			return Convert.ToBase64String(array);
		}

		internal static string CreateResponseKey(string base64Key)
		{
			StringBuilder stringBuilder = new StringBuilder(base64Key, 64);
			stringBuilder.Append("258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
			SHA1 sHA = new SHA1CryptoServiceProvider();
			byte[] inArray = sHA.ComputeHash(stringBuilder.ToString().UTF8Encode());
			return Convert.ToBase64String(inArray);
		}

		internal void InternalAccept()
		{
			try
			{
				if (!acceptHandshake())
				{
					return;
				}
				_readyState = WebSocketState.Open;
			}
			catch (Exception ex)
			{
				_logger.Fatal(ex.ToString());
				fatal("An exception has occurred while accepting.", ex);
				return;
			}
			open();
		}

		internal bool Ping(byte[] frameAsBytes, TimeSpan timeout)
		{
			if (_readyState != WebSocketState.Open)
			{
				return false;
			}
			if (!send(frameAsBytes))
			{
				return false;
			}
			return _receivePong?.WaitOne(timeout) ?? false;
		}

		internal void Send(Opcode opcode, byte[] data, Dictionary<CompressionMethod, byte[]> cache)
		{
			lock (_forSend)
			{
				lock (_forState)
				{
					if (_readyState != WebSocketState.Open)
					{
						_logger.Error("The sending has been interrupted.");
						return;
					}
					try
					{
						if (!cache.TryGetValue(_compression, out var value))
						{
							value = new WebSocketFrame(Fin.Final, opcode, data.Compress(_compression), _compression != CompressionMethod.None, mask: false).ToArray();
							cache.Add(_compression, value);
						}
						sendBytes(value);
					}
					catch (Exception ex)
					{
						_logger.Error(ex.ToString());
					}
				}
			}
		}

		internal void Send(Opcode opcode, Stream stream, Dictionary<CompressionMethod, Stream> cache)
		{
			lock (_forSend)
			{
				try
				{
					if (!cache.TryGetValue(_compression, out var value))
					{
						value = stream.Compress(_compression);
						cache.Add(_compression, value);
					}
					else
					{
						value.Position = 0L;
					}
					send(opcode, value, _compression != CompressionMethod.None);
				}
				catch (Exception ex)
				{
					_logger.Error(ex.ToString());
				}
			}
		}

		public void Accept()
		{
			if (!checkIfAvailable(client: false, server: true, connecting: true, open: false, closing: false, closed: false, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in accepting.", null);
			}
			else if (accept())
			{
				open();
			}
		}

		public void AcceptAsync()
		{
			if (!checkIfAvailable(client: false, server: true, connecting: true, open: false, closing: false, closed: false, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in accepting.", null);
				return;
			}
			Func<bool> acceptor = accept;
			acceptor.BeginInvoke(delegate(IAsyncResult ar)
			{
				if (acceptor.EndInvoke(ar))
				{
					open();
				}
			}, null);
		}

		public void Close()
		{
			if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else
			{
				close(new CloseEventArgs(), send: true, receive: true, received: false);
			}
		}

		public void Close(ushort code)
		{
			if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else if (!CheckParametersForClose(code, null, _client, out text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else
			{
				close(code, null);
			}
		}

		public void Close(CloseStatusCode code)
		{
			if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else if (!CheckParametersForClose(code, null, _client, out text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else
			{
				close((ushort)code, null);
			}
		}

		public void Close(ushort code, string reason)
		{
			if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else if (!CheckParametersForClose(code, reason, _client, out text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else
			{
				close(code, reason);
			}
		}

		public void Close(CloseStatusCode code, string reason)
		{
			if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else if (!CheckParametersForClose(code, reason, _client, out text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else
			{
				close((ushort)code, reason);
			}
		}

		public void CloseAsync()
		{
			if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else
			{
				closeAsync(new CloseEventArgs(), send: true, receive: true, received: false);
			}
		}

		public void CloseAsync(ushort code)
		{
			if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else if (!CheckParametersForClose(code, null, _client, out text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else
			{
				closeAsync(code, null);
			}
		}

		public void CloseAsync(CloseStatusCode code)
		{
			if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else if (!CheckParametersForClose(code, null, _client, out text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else
			{
				closeAsync((ushort)code, null);
			}
		}

		public void CloseAsync(ushort code, string reason)
		{
			if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else if (!CheckParametersForClose(code, reason, _client, out text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else
			{
				closeAsync(code, reason);
			}
		}

		public void CloseAsync(CloseStatusCode code, string reason)
		{
			if (!checkIfAvailable(connecting: true, open: true, closing: false, closed: false, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else if (!CheckParametersForClose(code, reason, _client, out text))
			{
				_logger.Error(text);
				error("An error has occurred in closing the connection.", null);
			}
			else
			{
				closeAsync((ushort)code, reason);
			}
		}

		public void Connect()
		{
			if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in connecting.", null);
			}
			else if (connect())
			{
				open();
			}
		}

		public void ConnectAsync()
		{
			if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in connecting.", null);
				return;
			}
			Func<bool> connector = connect;
			connector.BeginInvoke(delegate(IAsyncResult ar)
			{
				if (connector.EndInvoke(ar))
				{
					open();
				}
			}, null);
		}

		public bool Ping()
		{
			byte[] frameAsBytes = (_client ? WebSocketFrame.CreatePingFrame(mask: true).ToArray() : WebSocketFrame.EmptyPingBytes);
			return Ping(frameAsBytes, _waitTime);
		}

		public bool Ping(string message)
		{
			if (message == null || message.Length == 0)
			{
				return Ping();
			}
			byte[] bytes;
			string text = CheckPingParameter(message, out bytes);
			if (text != null)
			{
				_logger.Error(text);
				error("An error has occurred in sending a ping.", null);
				return false;
			}
			return Ping(WebSocketFrame.CreatePingFrame(bytes, _client).ToArray(), _waitTime);
		}

		public void Send(byte[] data)
		{
			string text = _readyState.CheckIfAvailable(connecting: false, open: true, closing: false, closed: false) ?? CheckSendParameter(data);
			if (text != null)
			{
				_logger.Error(text);
				error("An error has occurred in sending data.", null);
			}
			else
			{
				send(Opcode.Binary, new MemoryStream(data));
			}
		}

		public void Send(FileInfo file)
		{
			string text = _readyState.CheckIfAvailable(connecting: false, open: true, closing: false, closed: false) ?? CheckSendParameter(file);
			if (text != null)
			{
				_logger.Error(text);
				error("An error has occurred in sending data.", null);
			}
			else
			{
				send(Opcode.Binary, file.OpenRead());
			}
		}

		public void Send(string data)
		{
			string text = _readyState.CheckIfAvailable(connecting: false, open: true, closing: false, closed: false) ?? CheckSendParameter(data);
			if (text != null)
			{
				_logger.Error(text);
				error("An error has occurred in sending data.", null);
			}
			else
			{
				send(Opcode.Text, new MemoryStream(data.UTF8Encode()));
			}
		}

		public void SendAsync(byte[] data, Action<bool> completed)
		{
			string text = _readyState.CheckIfAvailable(connecting: false, open: true, closing: false, closed: false) ?? CheckSendParameter(data);
			if (text != null)
			{
				_logger.Error(text);
				error("An error has occurred in sending data.", null);
			}
			else
			{
				sendAsync(Opcode.Binary, new MemoryStream(data), completed);
			}
		}

		public void SendAsync(FileInfo file, Action<bool> completed)
		{
			string text = _readyState.CheckIfAvailable(connecting: false, open: true, closing: false, closed: false) ?? CheckSendParameter(file);
			if (text != null)
			{
				_logger.Error(text);
				error("An error has occurred in sending data.", null);
			}
			else
			{
				sendAsync(Opcode.Binary, file.OpenRead(), completed);
			}
		}

		public void SendAsync(string data, Action<bool> completed)
		{
			string text = _readyState.CheckIfAvailable(connecting: false, open: true, closing: false, closed: false) ?? CheckSendParameter(data);
			if (text != null)
			{
				_logger.Error(text);
				error("An error has occurred in sending data.", null);
			}
			else
			{
				sendAsync(Opcode.Text, new MemoryStream(data.UTF8Encode()), completed);
			}
		}

		public void SendAsync(Stream stream, int length, Action<bool> completed)
		{
			string text = _readyState.CheckIfAvailable(connecting: false, open: true, closing: false, closed: false) ?? CheckSendParameters(stream, length);
			if (text != null)
			{
				_logger.Error(text);
				error("An error has occurred in sending data.", null);
				return;
			}
			stream.ReadBytesAsync(length, delegate(byte[] data)
			{
				int num = data.Length;
				if (num == 0)
				{
					_logger.Error("The data cannot be read from 'stream'.");
					error("An error has occurred in sending data.", null);
				}
				else
				{
					if (num < length)
					{
						_logger.Warn($"The length of the data is less than 'length':\n  expected: {length}\n  actual: {num}");
					}
					bool obj = send(Opcode.Binary, new MemoryStream(data));
					if (completed != null)
					{
						completed(obj);
					}
				}
			}, delegate(Exception ex)
			{
				_logger.Error(ex.ToString());
				error("An exception has occurred while sending data.", ex);
			});
		}

		public void SetCookie(WebSocketSharp.Net.Cookie cookie)
		{
			if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in setting a cookie.", null);
				return;
			}
			if (cookie == null)
			{
				_logger.Error("'cookie' is null.");
				error("An error has occurred in setting a cookie.", null);
				return;
			}
			lock (_forState)
			{
				if (!checkIfAvailable(connecting: true, open: false, closing: false, closed: true, out text))
				{
					_logger.Error(text);
					error("An error has occurred in setting a cookie.", null);
					return;
				}
				lock (_cookies.SyncRoot)
				{
					_cookies.SetOrRemove(cookie);
				}
			}
		}

		public void SetCredentials(string username, string password, bool preAuth)
		{
			if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in setting the credentials.", null);
				return;
			}
			if (!checkParametersForSetCredentials(username, password, out text))
			{
				_logger.Error(text);
				error("An error has occurred in setting the credentials.", null);
				return;
			}
			lock (_forState)
			{
				if (!checkIfAvailable(connecting: true, open: false, closing: false, closed: true, out text))
				{
					_logger.Error(text);
					error("An error has occurred in setting the credentials.", null);
				}
				else if (username.IsNullOrEmpty())
				{
					_logger.Warn("The credentials are initialized.");
					_credentials = null;
					_preAuth = false;
				}
				else
				{
					_credentials = new WebSocketSharp.Net.NetworkCredential(username, password, _uri.PathAndQuery);
					_preAuth = preAuth;
				}
			}
		}

		public void SetProxy(string url, string username, string password)
		{
			if (!checkIfAvailable(client: true, server: false, connecting: true, open: false, closing: false, closed: true, out var text))
			{
				_logger.Error(text);
				error("An error has occurred in setting the proxy.", null);
				return;
			}
			if (!checkParametersForSetProxy(url, username, password, out text))
			{
				_logger.Error(text);
				error("An error has occurred in setting the proxy.", null);
				return;
			}
			lock (_forState)
			{
				if (!checkIfAvailable(connecting: true, open: false, closing: false, closed: true, out text))
				{
					_logger.Error(text);
					error("An error has occurred in setting the proxy.", null);
					return;
				}
				if (url.IsNullOrEmpty())
				{
					_logger.Warn("The url and credentials for the proxy are initialized.");
					_proxyUri = null;
					_proxyCredentials = null;
					return;
				}
				_proxyUri = new Uri(url);
				if (username.IsNullOrEmpty())
				{
					_logger.Warn("The credentials for the proxy are initialized.");
					_proxyCredentials = null;
				}
				else
				{
					_proxyCredentials = new WebSocketSharp.Net.NetworkCredential(username, password, $"{_uri.DnsSafeHost}:{_uri.Port}");
				}
			}
		}

		void IDisposable.Dispose()
		{
			close(new CloseEventArgs(1001), send: true, receive: true, received: false);
		}
	}
	public enum CloseStatusCode : ushort
	{
		Normal = 1000,
		Away = 1001,
		ProtocolError = 1002,
		UnsupportedData = 1003,
		Undefined = 1004,
		NoStatus = 1005,
		Abnormal = 1006,
		InvalidData = 1007,
		PolicyViolation = 1008,
		TooBig = 1009,
		MandatoryExtension = 1010,
		ServerError = 1011,
		TlsHandshakeFailure = 1015
	}
	internal enum Fin : byte
	{
		More,
		Final
	}
	internal enum Mask : byte
	{
		Off,
		On
	}
	public enum Opcode : byte
	{
		Cont = 0,
		Text = 1,
		Binary = 2,
		Close = 8,
		Ping = 9,
		Pong = 10
	}
	internal class PayloadData : IEnumerable<byte>, IEnumerable
	{
		private ushort _code;

		private bool _codeSet;

		private byte[] _data;

		private long _extDataLength;

		private long _length;

		private string _reason;

		private bool _reasonSet;

		public static readonly PayloadData Empty;

		public static readonly ulong MaxLength;

		internal ushort Code
		{
			get
			{
				if (!_codeSet)
				{
					_code = (ushort)((_length > 1) ? _data.SubArray(0, 2).ToUInt16(ByteOrder.Big) : 1005);
					_codeSet = true;
				}
				return _code;
			}
		}

		internal long ExtensionDataLength
		{
			get
			{
				return _extDataLength;
			}
			set
			{
				_extDataLength = value;
			}
		}

		internal bool HasReservedCode => _length > 1 && Code.IsReserved();

		internal string Reason
		{
			get
			{
				if (!_reasonSet)
				{
					_reason = ((_length > 2) ? _data.SubArray(2L, _length - 2).UTF8Decode() : string.Empty);
					_reasonSet = true;
				}
				return _reason;
			}
		}

		public byte[] ApplicationData => (_extDataLength > 0) ? _data.SubArray(_extDataLength, _length - _extDataLength) : _data;

		public byte[] ExtensionData => (_extDataLength > 0) ? _data.SubArray(0L, _extDataLength) : WebSocket.EmptyBytes;

		public ulong Length => (ulong)_length;

		static PayloadData()
		{
			Empty = new PayloadData();
			MaxLength = 9223372036854775807uL;
		}

		internal PayloadData()
		{
			_code = 1005;
			_reason = string.Empty;
			_data = WebSocket.EmptyBytes;
			_codeSet = true;
			_reasonSet = true;
		}

		internal PayloadData(byte[] data)
			: this(data, data.LongLength)
		{
		}

		internal PayloadData(byte[] data, long length)
		{
			_data = data;
			_length = length;
		}

		internal PayloadData(ushort code, string reason)
		{
			_code = code;
			_reason = reason ?? string.Empty;
			_data = code.Append(reason);
			_length = _data.LongLength;
			_codeSet = true;
			_reasonSet = true;
		}

		internal void Mask(byte[] key)
		{
			for (long num = 0L; num < _length; num++)
			{
				_data[num] ^= key[num % 4];
			}
		}

		public IEnumerator<byte> GetEnumerator()
		{
			byte[] data = _data;
			for (int i = 0; i < data.Length; i++)
			{
				yield return data[i];
			}
		}

		public byte[] ToArray()
		{
			return _data;
		}

		public override string ToString()
		{
			return BitConverter.ToString(_data);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	internal enum Rsv : byte
	{
		Off,
		On
	}
	public enum CompressionMethod : byte
	{
		None,
		Deflate
	}
	public class WebSocketException : Exception
	{
		private CloseStatusCode _code;

		public CloseStatusCode Code => _code;

		internal WebSocketException()
			: this(CloseStatusCode.Abnormal, null, null)
		{
		}

		internal WebSocketException(Exception innerException)
			: this(CloseStatusCode.Abnormal, null, innerException)
		{
		}

		internal WebSocketException(string message)
			: this(CloseStatusCode.Abnormal, message, null)
		{
		}

		internal WebSocketException(CloseStatusCode code)
			: this(code, null, null)
		{
		}

		internal WebSocketException(string message, Exception innerException)
			: this(CloseStatusCode.Abnormal, message, innerException)
		{
		}

		internal WebSocketException(CloseStatusCode code, Exception innerException)
			: this(code, null, innerException)
		{
		}

		internal WebSocketException(CloseStatusCode code, string message)
			: this(code, message, null)
		{
		}

		internal WebSocketException(CloseStatusCode code, string message, Exception innerException)
			: base(message ?? code.GetMessage(), innerException)
		{
			_code = code;
		}
	}
	public class LogData
	{
		private StackFrame _caller;

		private DateTime _date;

		private LogLevel _level;

		private string _message;

		public StackFrame Caller => _caller;

		public DateTime Date => _date;

		public LogLevel Level => _level;

		public string Message => _message;

		internal LogData(LogLevel level, StackFrame caller, string message)
		{
			_level = level;
			_caller = caller;
			_message = message ?? string.Empty;
			_date = DateTime.Now;
		}

		public override string ToString()
		{
			string text = $"{_date}|{_level,-5}|";
			MethodBase method = _caller.GetMethod();
			Type declaringType = method.DeclaringType;
			string arg = $"{text}{declaringType.Name}.{method.Name}|";
			string[] array = _message.Replace("\r\n", "\n").TrimEnd(new char[1] { '\n' }).Split(new char[1] { '\n' });
			if (array.Length <= 1)
			{
				return $"{arg}{_message}";
			}
			StringBuilder stringBuilder = new StringBuilder($"{arg}{array[0]}\n", 64);
			string format = $"{{0,{text.Length}}}{{1}}\n";
			for (int i = 1; i < array.Length; i++)
			{
				stringBuilder.AppendFormat(format, "", array[i]);
			}
			stringBuilder.Length--;
			return stringBuilder.ToString();
		}
	}
	public enum LogLevel
	{
		Trace,
		Debug,
		Info,
		Warn,
		Error,
		Fatal
	}
	public class Logger
	{
		private volatile string _file;

		private volatile LogLevel _level;

		private Action<LogData, string> _output;

		private object _sync;

		public string File
		{
			get
			{
				return _file;
			}
			set
			{
				lock (_sync)
				{
					_file = value;
					Warn($"The current path to the log file has been changed to {_file}.");
				}
			}
		}

		public LogLevel Level
		{
			get
			{
				return _level;
			}
			set
			{
				lock (_sync)
				{
					_level = value;
					Warn($"The current logging level has been changed to {_level}.");
				}
			}
		}

		public Action<LogData, string> Output
		{
			get
			{
				return _output;
			}
			set
			{
				lock (_sync)
				{
					_output = value ?? new Action<LogData, string>(defaultOutput);
					Warn("The current output action has been changed.");
				}
			}
		}

		public Logger()
			: this(LogLevel.Error, null, null)
		{
		}

		public Logger(LogLevel level)
			: this(level, null, null)
		{
		}

		public Logger(LogLevel level, string file, Action<LogData, string> output)
		{
			_level = level;
			_file = file;
			_output = output ?? new Action<LogData, string>(defaultOutput);
			_sync = new object();
		}

		private static void defaultOutput(LogData data, string path)
		{
			string value = data.ToString();
			Console.WriteLine(value);
			if (path != null && path.Length > 0)
			{
				writeToFile(value, path);
			}
		}

		private void output(string message, LogLevel level)
		{
			lock (_sync)
			{
				if (_level > level)
				{
					return;
				}
				LogData logData = null;
				try
				{
					logData = new LogData(level, new StackFrame(2, fNeedFileInfo: true), message);
					_output(logData, _file);
				}
				catch (Exception ex)
				{
					logData = new LogData(LogLevel.Fatal, new StackFrame(0, fNeedFileInfo: true), ex.Message);
					Console.WriteLine(logData.ToString());
				}
			}
		}

		private static void writeToFile(string value, string path)
		{
			using StreamWriter writer = new StreamWriter(path, append: true);
			using TextWriter textWriter = TextWriter.Synchronized(writer);
			textWriter.WriteLine(value);
		}

		public void Debug(string message)
		{
			if (_level <= LogLevel.Debug)
			{
				output(message, LogLevel.Debug);
			}
		}

		public void Error(string message)
		{
			if (_level <= LogLevel.Error)
			{
				output(message, LogLevel.Error);
			}
		}

		public void Fatal(string message)
		{
			output(message, LogLevel.Fatal);
		}

		public void Info(string message)
		{
			if (_level <= LogLevel.Info)
			{
				output(message, LogLevel.Info);
			}
		}

		public void Trace(string message)
		{
			if (_level <= LogLevel.Trace)
			{
				output(message, LogLevel.Trace);
			}
		}

		public void Warn(string message)
		{
			if (_level <= LogLevel.Warn)
			{
				output(message, LogLevel.Warn);
			}
		}
	}
	public enum WebSocketState : ushort
	{
		Connecting,
		Open,
		Closing,
		Closed
	}
	internal class WebSocketFrame : IEnumerable<byte>, IEnumerable
	{
		private byte[] _extPayloadLength;

		private Fin _fin;

		private Mask _mask;

		private byte[] _maskingKey;

		private Opcode _opcode;

		private PayloadData _payloadData;

		private byte _payloadLength;

		private Rsv _rsv1;

		private Rsv _rsv2;

		private Rsv _rsv3;

		internal static readonly byte[] EmptyPingBytes;

		internal int ExtendedPayloadLengthCount => (_payloadLength >= 126) ? ((_payloadLength == 126) ? 2 : 8) : 0;

		internal ulong FullPayloadLength => (_payloadLength < 126) ? _payloadLength : ((_payloadLength == 126) ? _extPayloadLength.ToUInt16(ByteOrder.Big) : _extPayloadLength.ToUInt64(ByteOrder.Big));

		public byte[] ExtendedPayloadLength => _extPayloadLength;

		public Fin Fin => _fin;

		public bool IsBinary => _opcode == Opcode.Binary;

		public bool IsClose => _opcode == Opcode.Close;

		public bool IsCompressed => _rsv1 == Rsv.On;

		public bool IsContinuation => _opcode == Opcode.Cont;

		public bool IsControl => (int)_opcode >= 8;

		public bool IsData => _opcode == Opcode.Text || _opcode == Opcode.Binary;

		public bool IsFinal => _fin == Fin.Final;

		public bool IsFragment => _fin == Fin.More || _opcode == Opcode.Cont;

		public bool IsMasked => _mask == Mask.On;

		public bool IsPing => _opcode == Opcode.Ping;

		public bool IsPong => _opcode == Opcode.Pong;

		public bool IsText => _opcode == Opcode.Text;

		public ulong Length => (ulong)(2L + (long)(_extPayloadLength.Length + _maskingKey.Length)) + _payloadData.Length;

		public Mask Mask => _mask;

		public byte[] MaskingKey => _maskingKey;

		public Opcode Opcode => _opcode;

		public PayloadData PayloadData => _payloadData;

		public byte PayloadLength => _payloadLength;

		public Rsv Rsv1 => _rsv1;

		public Rsv Rsv2 => _rsv2;

		public Rsv Rsv3 => _rsv3;

		static WebSocketFrame()
		{
			EmptyPingBytes = CreatePingFrame(mask: false).ToArray();
		}

		private WebSocketFrame()
		{
		}

		internal WebSocketFrame(Opcode opcode, PayloadData payloadData, bool mask)
			: this(Fin.Final, opcode, payloadData, compressed: false, mask)
		{
		}

		internal WebSocketFrame(Fin fin, Opcode opcode, byte[] data, bool compressed, bool mask)
			: this(fin, opcode, new PayloadData(data), compressed, mask)
		{
		}

		internal WebSocketFrame(Fin fin, Opcode opcode, PayloadData payloadData, bool compressed, bool mask)
		{
			_fin = fin;
			_rsv1 = ((opcode.IsData() && compressed) ? Rsv.On : Rsv.Off);
			_rsv2 = Rsv.Off;
			_rsv3 = Rsv.Off;
			_opcode = opcode;
			ulong length = payloadData.Length;
			if (length < 126)
			{
				_payloadLength = (byte)length;
				_extPayloadLength = WebSocket.EmptyBytes;
			}
			else if (length < 65536)
			{
				_payloadLength = 126;
				_extPayloadLength = ((ushort)length).InternalToByteArray(ByteOrder.Big);
			}
			else
			{
				_payloadLength = 127;
				_extPayloadLength = length.InternalToByteArray(ByteOrder.Big);
			}
			if (mask)
			{
				_mask = Mask.On;
				_maskingKey = createMaskingKey();
				payloadData.Mask(_maskingKey);
			}
			else
			{
				_mask = Mask.Off;
				_maskingKey = WebSocket.EmptyBytes;
			}
			_payloadData = payloadData;
		}

		private static byte[] createMaskingKey()
		{
			byte[] array = new byte[4];
			WebSocket.RandomNumber.GetBytes(array);
			return array;
		}

		private static string dump(WebSocketFrame frame)
		{
			ulong length = frame.Length;
			long num = (long)(length / 4);
			int num2 = (int)(length % 4);
			int num3;
			string arg;
			if (num < 10000)
			{
				num3 = 4;
				arg = "{0,4}";
			}
			else if (num < 65536)
			{
				num3 = 4;
				arg = "{0,4:X}";
			}
			else if (num < 4294967296L)
			{
				num3 = 8;
				arg = "{0,8:X}";
			}
			else
			{
				num3 = 16;
				arg = "{0,16:X}";
			}
			string arg2 = $"{{0,{num3}}}";
			string format = string.Format("\r\n{0} 01234567 89ABCDEF 01234567 89ABCDEF\r\n{0}+--------+--------+--------+--------+\\n", arg2);
			string lineFmt = $"{arg}|{{1,8}} {{2,8}} {{3,8}} {{4,8}}|\n";
			string format2 = $"{arg2}+--------+--------+--------+--------+";
			StringBuilder output = new StringBuilder(64);
			Func<Action<string, string, string, string>> func = delegate
			{
				long lineCnt = 0L;
				return delegate(string text, string text2, string text3, string text4)
				{
					output.AppendFormat(lineFmt, ++lineCnt, text, text2, text3, text4);
				};
			};
			Action<string, string, string, string> action = func();
			output.AppendFormat(format, string.Empty);
			byte[] array = frame.ToArray();
			for (long num4 = 0L; num4 <= num; num4++)
			{
				long num5 = num4 * 4;
				if (num4 < num)
				{
					action(Convert.ToString(array[num5], 2).PadLeft(8, '0'), Convert.ToString(array[num5 + 1], 2).PadLeft(8, '0'), Convert.ToString(array[num5 + 2], 2).PadLeft(8, '0'), Convert.ToString(array[num5 + 3], 2).PadLeft(8, '0'));
				}
				else if (num2 > 0)
				{
					action(Convert.ToString(array[num5], 2).PadLeft(8, '0'), (num2 >= 2) ? Convert.ToString(array[num5 + 1], 2).PadLeft(8, '0') : string.Empty, (num2 == 3) ? Convert.ToString(array[num5 + 2], 2).PadLeft(8, '0') : string.Empty, string.Empty);
				}
			}
			output.AppendFormat(format2, string.Empty);
			return output.ToString();
		}

		private static string print(WebSocketFrame frame)
		{
			byte payloadLength = frame._payloadLength;
			string text = ((payloadLength > 125) ? frame.FullPayloadLength.ToString() : string.Empty);
			string text2 = BitConverter.ToString(frame._maskingKey);
			string text3 = ((payloadLength == 0) ? string.Empty : ((payloadLength > 125) ? "---" : ((frame.IsText && !frame.IsFragment && !frame.IsMasked && !frame.IsCompressed) ? frame._payloadData.ApplicationData.UTF8Decode() : frame._payloadData.ToString())));
			string format = "\r\n                    FIN: {0}\r\n                   RSV1: {1}\r\n                   RSV2: {2}\r\n                   RSV3: {3}\r\n                 Opcode: {4}\r\n                   MASK: {5}\r\n         Payload Length: {6}\r\nExtended Payload Length: {7}\r\n            Masking Key: {8}\r\n           Payload Data: {9}";
			return string.Format(format, frame._fin, frame._rsv1, frame._rsv2, frame._rsv3, frame._opcode, frame._mask, payloadLength, text, text2, text3);
		}

		private static WebSocketFrame processHeader(byte[] header)
		{
			if (header.Length != 2)
			{
				throw new WebSocketException("The header of a frame cannot be read from the stream.");
			}
			Fin fin = (((header[0] & 0x80) == 128) ? Fin.Final : Fin.More);
			Rsv rsv = (((header[0] & 0x40) == 64) ? Rsv.On : Rsv.Off);
			Rsv rsv2 = (((header[0] & 0x20) == 32) ? Rsv.On : Rsv.Off);
			Rsv rsv3 = (((header[0] & 0x10) == 16) ? Rsv.On : Rsv.Off);
			byte opcode = (byte)(header[0] & 0xF);
			Mask mask = (((header[1] & 0x80) == 128) ? Mask.On : Mask.Off);
			byte b = (byte)(header[1] & 0x7F);
			string text = ((!opcode.IsSupported()) ? "An unsupported opcode." : ((!opcode.IsData() && rsv == Rsv.On) ? "A non data frame is compressed." : ((opcode.IsControl() && fin == Fin.More) ? "A control frame is fragmented." : ((opcode.IsControl() && b > 125) ? "A control frame has a long payload length." : null))));
			if (text != null)
			{
				throw new WebSocketException(CloseStatusCode.ProtocolError, text);
			}
			WebSocketFrame webSocketFrame = new WebSocketFrame();
			webSocketFrame._fin = fin;
			webSocketFrame._rsv1 = rsv;
			webSocketFrame._rsv2 = rsv2;
			webSocketFrame._rsv3 = rsv3;
			webSocketFrame._opcode = (Opcode)opcode;
			webSocketFrame._mask = mask;
			webSocketFrame._payloadLength = b;
			return webSocketFrame;
		}

		private static WebSocketFrame readExtendedPayloadLength(Stream stream, WebSocketFrame frame)
		{
			int extendedPayloadLengthCount = frame.ExtendedPayloadLengthCount;
			if (extendedPayloadLengthCount == 0)
			{
				frame._extPayloadLength = WebSocket.EmptyBytes;
				return frame;
			}
			byte[] array = stream.ReadBytes(extendedPayloadLengthCount);
			if (array.Length != extendedPayloadLengthCount)
			{
				throw new WebSocketException("The extended payload length of a frame cannot be read from the stream.");
			}
			frame._extPayloadLength = array;
			return frame;
		}

		private static void readExtendedPayloadLengthAsync(Stream stream, WebSocketFrame frame, Action<WebSocketFrame> completed, Action<Exception> error)
		{
			int len = frame.ExtendedPayloadLengthCount;
			if (len == 0)
			{
				frame._extPayloadLength = WebSocket.EmptyBytes;
				completed(frame);
				return;
			}
			stream.ReadBytesAsync(len, delegate(byte[] bytes)
			{
				if (bytes.Length != len)
				{
					throw new WebSocketException("The extended payload length of a frame cannot be read from the stream.");
				}
				frame._extPayloadLength = bytes;
				completed(frame);
			}, error);
		}

		private static WebSocketFrame readHeader(Stream stream)
		{
			return processHeader(stream.ReadBytes(2));
		}

		private static void readHeaderAsync(Stream stream, Action<WebSocketFrame> completed, Action<Exception> error)
		{
			stream.ReadBytesAsync(2, delegate(byte[] bytes)
			{
				completed(processHeader(bytes));
			}, error);
		}

		private static WebSocketFrame readMaskingKey(Stream stream, WebSocketFrame frame)
		{
			int num = (frame.IsMasked ? 4 : 0);
			if (num == 0)
			{
				frame._maskingKey = WebSocket.EmptyBytes;
				return frame;
			}
			byte[] array = stream.ReadBytes(num);
			if (array.Length != num)
			{
				throw new WebSocketException("The masking key of a frame cannot be read from the stream.");
			}
			frame._maskingKey = array;
			return frame;
		}

		private static void readMaskingKeyAsync(Stream stream, WebSocketFrame frame, Action<WebSocketFrame> completed, Action<Exception> error)
		{
			int len = (frame.IsMasked ? 4 : 0);
			if (len == 0)
			{
				frame._maskingKey = WebSocket.EmptyBytes;
				completed(frame);
				return;
			}
			stream.ReadBytesAsync(len, delegate(byte[] bytes)
			{
				if (bytes.Length != len)
				{
					throw new WebSocketException("The masking key of a frame cannot be read from the stream.");
				}
				frame._maskingKey = bytes;
				completed(frame);
			}, error);
		}

		private static WebSocketFrame readPayloadData(Stream stream, WebSocketFrame frame)
		{
			ulong fullPayloadLength = frame.FullPayloadLength;
			if (fullPayloadLength == 0)
			{
				frame._payloadData = PayloadData.Empty;
				return frame;
			}
			if (fullPayloadLength > PayloadData.MaxLength)
			{
				throw new WebSocketException(CloseStatusCode.TooBig, "A frame has a long payload length.");
			}
			long num = (long)fullPayloadLength;
			byte[] array = ((frame._payloadLength < 127) ? stream.ReadBytes((int)fullPayloadLength) : stream.ReadBytes(num, 1024));
			if (array.LongLength != num)
			{
				throw new WebSocketException("The payload data of a frame cannot be read from the stream.");
			}
			frame._payloadData = new PayloadData(array, num);
			return frame;
		}

		private static void readPayloadDataAsync(Stream stream, WebSocketFrame frame, Action<WebSocketFrame> completed, Action<Exception> error)
		{
			ulong fullPayloadLength = frame.FullPayloadLength;
			if (fullPayloadLength == 0)
			{
				frame._payloadData = PayloadData.Empty;
				completed(frame);
				return;
			}
			if (fullPayloadLength > PayloadData.MaxLength)
			{
				throw new WebSocketException(CloseStatusCode.TooBig, "A frame has a long payload length.");
			}
			long llen = (long)fullPayloadLength;
			Action<byte[]> completed2 = delegate(byte[] bytes)
			{
				if (bytes.LongLength != llen)
				{
					throw new WebSocketException("The payload data of a frame cannot be read from the stream.");
				}
				frame._payloadData = new PayloadData(bytes, llen);
				completed(frame);
			};
			if (frame._payloadLength < 127)
			{
				stream.ReadBytesAsync((int)fullPayloadLength, completed2, error);
			}
			else
			{
				stream.ReadBytesAsync(llen, 1024, completed2, error);
			}
		}

		internal static WebSocketFrame CreateCloseFrame(PayloadData payloadData, bool mask)
		{
			return new WebSocketFrame(Fin.Final, Opcode.Close, payloadData, compressed: false, mask);
		}

		internal static WebSocketFrame CreatePingFrame(bool mask)
		{
			return new WebSocketFrame(Fin.Final, Opcode.Ping, PayloadData.Empty, compressed: false, mask);
		}

		internal static WebSocketFrame CreatePingFrame(byte[] data, bool mask)
		{
			return new WebSocketFrame(Fin.Final, Opcode.Ping, new PayloadData(data), compressed: false, mask);
		}

		internal static WebSocketFrame ReadFrame(Stream stream, bool unmask)
		{
			WebSocketFrame webSocketFrame = readHeader(stream);
			readExtendedPayloadLength(stream, webSocketFrame);
			readMaskingKey(stream, webSocketFrame);
			readPayloadData(stream, webSocketFrame);
			if (unmask)
			{
				webSocketFrame.Unmask();
			}
			return webSocketFrame;
		}

		internal static void ReadFrameAsync(Stream stream, bool unmask, Action<WebSocketFrame> completed, Action<Exception> error)
		{
			readHeaderAsync(stream, delegate(WebSocketFrame frame)
			{
				readExtendedPayloadLengthAsync(stream, frame, delegate(WebSocketFrame frame2)
				{
					readMaskingKeyAsync(stream, frame2, delegate(WebSocketFrame frame3)
					{
						readPayloadDataAsync(stream, frame3, delegate(WebSocketFrame webSocketFrame)
						{
							if (unmask)
							{
								webSocketFrame.Unmask();
							}
							completed(webSocketFrame);
						}, error);
					}, error);
				}, error);
			}, error);
		}

		internal void Unmask()
		{
			if (_mask != Mask.Off)
			{
				_mask = Mask.Off;
				_payloadData.Mask(_maskingKey);
				_maskingKey = WebSocket.EmptyBytes;
			}
		}

		public IEnumerator<byte> GetEnumerator()
		{
			byte[] array = ToArray();
			for (int i = 0; i < array.Length; i++)
			{
				yield return array[i];
			}
		}

		public void Print(bool dumped)
		{
			Console.WriteLine(dumped ? dump(this) : print(this));
		}

		public string PrintToString(bool dumped)
		{
			return dumped ? dump(this) : print(this);
		}

		public byte[] ToArray()
		{
			using MemoryStream memoryStream = new MemoryStream();
			int fin = (int)_fin;
			fin = (fin << 1) + (int)_rsv1;
			fin = (fin << 1) + (int)_rsv2;
			fin = (fin << 1) + (int)_rsv3;
			fin = (fin << 4) + (int)_opcode;
			fin = (fin << 1) + (int)_mask;
			fin = (fin << 7) + _payloadLength;
			memoryStream.Write(((ushort)fin).InternalToByteArray(ByteOrder.Big), 0, 2);
			if (_payloadLength > 125)
			{
				memoryStream.Write(_extPayloadLength, 0, (_payloadLength == 126) ? 2 : 8);
			}
			if (_mask == Mask.On)
			{
				memoryStream.Write(_maskingKey, 0, 4);
			}
			if (_payloadLength > 0)
			{
				byte[] array = _payloadData.ToArray();
				if (_payloadLength < 127)
				{
					memoryStream.Write(array, 0, array.Length);
				}
				else
				{
					memoryStream.WriteBytes(array, 1024);
				}
			}
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		public override string ToString()
		{
			return BitConverter.ToString(ToArray());
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	internal abstract class HttpBase
	{
		private NameValueCollection _headers;

		private const int _headersMaxLength = 8192;

		private Version _version;

		internal byte[] EntityBodyData;

		protected const string CrLf = "\r\n";

		public string EntityBody
		{
			get
			{
				if (EntityBodyData == null || EntityBodyData.LongLength == 0)
				{
					return string.Empty;
				}
				Encoding encoding = null;
				string text = _headers["Content-Type"];
				if (text != null && text.Length > 0)
				{
					encoding = HttpUtility.GetEncoding(text);
				}
				return (encoding ?? Encoding.UTF8).GetString(EntityBodyData);
			}
		}

		public NameValueCollection Headers => _headers;

		public Version ProtocolVersion => _version;

		protected HttpBase(Version version, NameValueCollection headers)
		{
			_version = version;
			_headers = headers;
		}

		private static byte[] readEntityBody(Stream stream, string length)
		{
			if (!long.TryParse(length, out var result))
			{
				throw new ArgumentException("Cannot be parsed.", "length");
			}
			if (result < 0)
			{
				throw new ArgumentOutOfRangeException("length", "Less than zero.");
			}
			return (result > 1024) ? stream.ReadBytes(result, 1024) : ((result > 0) ? stream.ReadBytes((int)result) : null);
		}

		private static string[] readHeaders(Stream stream, int maxLength)
		{
			List<byte> buff = new List<byte>();
			int cnt = 0;
			Action<int> action = delegate(int i)
			{
				if (i == -1)
				{
					throw new EndOfStreamException("The header cannot be read from the data source.");
				}
				buff.Add((byte)i);
				cnt++;
			};
			bool flag = false;
			while (cnt < maxLength)
			{
				if (stream.ReadByte().EqualsWith('\r', action) && stream.ReadByte().EqualsWith('\n', action) && stream.ReadByte().EqualsWith('\r', action) && stream.ReadByte().EqualsWith('\n', action))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				throw new WebSocketException("The length of header part is greater than the max length.");
			}
			return Encoding.UTF8.GetString(buff.ToArray()).Replace("\r\n ", " ").Replace("\r\n\t", " ")
				.Split(new string[1] { "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
		}

		protected static T Read<T>(Stream stream, Func<string[], T> parser, int millisecondsTimeout) where T : HttpBase
		{
			bool timeout = false;
			System.Threading.Timer timer = new System.Threading.Timer(delegate
			{
				timeout = true;
				stream.Close();
			}, null, millisecondsTimeout, -1);
			T val = null;
			Exception ex = null;
			try
			{
				val = parser(readHeaders(stream, 8192));
				string text = val.Headers["Content-Length"];
				if (text != null && text.Length > 0)
				{
					val.EntityBodyData = readEntityBody(stream, text);
				}
			}
			catch (Exception ex2)
			{
				ex = ex2;
			}
			finally
			{
				timer.Change(-1, -1);
				timer.Dispose();
			}
			string text2 = (timeout ? "A timeout has occurred while reading an HTTP request/response." : ((ex != null) ? "An exception has occurred while reading an HTTP request/response." : null));
			if (text2 != null)
			{
				throw new WebSocketException(text2, ex);
			}
			return val;
		}

		public byte[] ToByteArray()
		{
			return Encoding.UTF8.GetBytes(ToString());
		}
	}
	internal class HttpRequest : HttpBase
	{
		private string _method;

		private string _uri;

		private bool _websocketRequest;

		private bool _websocketRequestSet;

		public AuthenticationResponse AuthenticationResponse
		{
			get
			{
				string text = base.Headers["Authorization"];
				return (text != null && text.Length > 0) ? AuthenticationResponse.Parse(text) : null;
			}
		}

		public WebSocketSharp.Net.CookieCollection Cookies => base.Headers.GetCookies(response: false);

		public string HttpMethod => _method;

		public bool IsWebSocketRequest
		{
			get
			{
				if (!_websocketRequestSet)
				{
					NameValueCollection headers = base.Headers;
					_websocketRequest = _method == "GET" && base.ProtocolVersion > WebSocketSharp.Net.HttpVersion.Version10 && headers.Contains("Upgrade", "websocket") && headers.Contains("Connection", "Upgrade");
					_websocketRequestSet = true;
				}
				return _websocketRequest;
			}
		}

		public string RequestUri => _uri;

		private HttpRequest(string method, string uri, Version version, NameValueCollection headers)
			: base(version, headers)
		{
			_method = method;
			_uri = uri;
		}

		internal HttpRequest(string method, string uri)
			: this(method, uri, WebSocketSharp.Net.HttpVersion.Version11, new NameValueCollection())
		{
			base.Headers["User-Agent"] = "websocket-sharp/1.0";
		}

		internal static HttpRequest CreateConnectRequest(Uri uri)
		{
			string dnsSafeHost = uri.DnsSafeHost;
			int port = uri.Port;
			string text = $"{dnsSafeHost}:{port}";
			HttpRequest httpRequest = new HttpRequest("CONNECT", text);
			httpRequest.Headers["Host"] = ((port == 80) ? dnsSafeHost : text);
			return httpRequest;
		}

		internal static HttpRequest CreateWebSocketRequest(Uri uri)
		{
			HttpRequest httpRequest = new HttpRequest("GET", uri.PathAndQuery);
			NameValueCollection headers = httpRequest.Headers;
			int port = uri.Port;
			string scheme = uri.Scheme;
			headers["Host"] = (((port == 80 && scheme == "ws") || (port == 443 && scheme == "wss")) ? uri.DnsSafeHost : uri.Authority);
			headers["Upgrade"] = "websocket";
			headers["Connection"] = "Upgrade";
			return httpRequest;
		}

		internal HttpResponse GetResponse(Stream stream, int millisecondsTimeout)
		{
			byte[] array = ToByteArray();
			stream.Write(array, 0, array.Length);
			return HttpBase.Read(stream, HttpResponse.Parse, millisecondsTimeout);
		}

		internal static HttpRequest Parse(string[] headerParts)
		{
			string[] array = headerParts[0].Split(new char[1] { ' ' }, 3);
			if (array.Length != 3)
			{
				throw new ArgumentException("Invalid request line: " + headerParts[0]);
			}
			WebSocketSharp.Net.WebHeaderCollection webHeaderCollection = new WebSocketSharp.Net.WebHeaderCollection();
			for (int i = 1; i < headerParts.Length; i++)
			{
				webHeaderCollection.InternalSet(headerParts[i], response: false);
			}
			return new HttpRequest(array[0], array[1], new Version(array[2].Substring(5)), webHeaderCollection);
		}

		internal static HttpRequest Read(Stream stream, int millisecondsTimeout)
		{
			return HttpBase.Read(stream, Parse, millisecondsTimeout);
		}

		public void SetCookies(WebSocketSharp.Net.CookieCollection cookies)
		{
			if (cookies == null || cookies.Count == 0)
			{
				return;
			}
			StringBuilder stringBuilder = new StringBuilder(64);
			foreach (WebSocketSharp.Net.Cookie item in cookies.Sorted)
			{
				if (!item.Expired)
				{
					stringBuilder.AppendFormat("{0}; ", item.ToString());
				}
			}
			int length = stringBuilder.Length;
			if (length > 2)
			{
				stringBuilder.Length = length - 2;
				base.Headers["Cookie"] = stringBuilder.ToString();
			}
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder(64);
			stringBuilder.AppendFormat("{0} {1} HTTP/{2}{3}", _method, _uri, base.ProtocolVersion, "\r\n");
			NameValueCollection headers = base.Headers;
			string[] allKeys = headers.AllKeys;
			foreach (string text in allKeys)
			{
				stringBuilder.AppendFormat("{0}: {1}{2}", text, headers[text], "\r\n");
			}
			stringBuilder.Append("\r\n");
			string entityBody = base.EntityBody;
			if (entityBody.Length > 0)
			{
				stringBuilder.Append(entityBody);
			}
			return stringBuilder.ToString();
		}
	}
	internal class HttpResponse : HttpBase
	{
		private string _code;

		private string _reason;

		public WebSocketSharp.Net.CookieCollection Cookies => base.Headers.GetCookies(response: true);

		public bool HasConnectionClose => base.Headers.Contains("Connection", "close");

		public bool IsProxyAuthenticationRequired => _code == "407";

		public bool IsRedirect => _code == "301" || _code == "302";

		public bool IsUnauthorized => _code == "401";

		public bool IsWebSocketResponse
		{
			get
			{
				NameValueCollection headers = base.Headers;
				return base.ProtocolVersion > WebSocketSharp.Net.HttpVersion.Version10 && _code == "101" && headers.Contains("Upgrade", "websocket") && headers.Contains("Connection", "Upgrade");
			}
		}

		public string Reason => _reason;

		public string StatusCode => _code;

		private HttpResponse(string code, string reason, Version version, NameValueCollection headers)
			: base(version, headers)
		{
			_code = code;
			_reason = reason;
		}

		internal HttpResponse(WebSocketSharp.Net.HttpStatusCode code)
			: this(code, code.GetDescription())
		{
		}

		internal HttpResponse(WebSocketSharp.Net.HttpStatusCode code, string reason)
			: this(((int)code).ToString(), reason, WebSocketSharp.Net.HttpVersion.Version11, new NameValueCollection())
		{
			base.Headers["Server"] = "websocket-sharp/1.0";
		}

		internal static HttpResponse CreateCloseResponse(WebSocketSharp.Net.HttpStatusCode code)
		{
			HttpResponse httpResponse = new HttpResponse(code);
			httpResponse.Headers["Connection"] = "close";
			return httpResponse;
		}

		internal static HttpResponse CreateUnauthorizedResponse(string challenge)
		{
			HttpResponse httpResponse = new HttpResponse(WebSocketSharp.Net.HttpStatusCode.Unauthorized);
			httpResponse.Headers["WWW-Authenticate"] = challenge;
			return httpResponse;
		}

		internal static HttpResponse CreateWebSocketResponse()
		{
			HttpResponse httpResponse = new HttpResponse(WebSocketSharp.Net.HttpStatusCode.SwitchingProtocols);
			NameValueCollection headers = httpResponse.Headers;
			headers["Upgrade"] = "websocket";
			headers["Connection"] = "Upgrade";
			return httpResponse;
		}

		internal static HttpResponse Parse(string[] headerParts)
		{
			string[] array = headerParts[0].Split(new char[1] { ' ' }, 3);
			if (array.Length != 3)
			{
				throw new ArgumentException("Invalid status line: " + headerParts[0]);
			}
			WebSocketSharp.Net.WebHeaderCollection webHeaderCollection = new WebSocketSharp.Net.WebHeaderCollection();
			for (int i = 1; i < headerParts.Length; i++)
			{
				webHeaderCollection.InternalSet(headerParts[i], response: true);
			}
			return new HttpResponse(array[1], array[2], new Version(array[0].Substring(5)), webHeaderCollection);
		}

		internal static HttpResponse Read(Stream stream, int millisecondsTimeout)
		{
			return HttpBase.Read(stream, Parse, millisecondsTimeout);
		}

		public void SetCookies(WebSocketSharp.Net.CookieCollection cookies)
		{
			if (cookies == null || cookies.Count == 0)
			{
				return;
			}
			NameValueCollection headers = base.Headers;
			foreach (WebSocketSharp.Net.Cookie item in cookies.Sorted)
			{
				headers.Add("Set-Cookie", item.ToResponseString());
			}
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder(64);
			stringBuilder.AppendFormat("HTTP/{0} {1} {2}{3}", base.ProtocolVersion, _code, _reason, "\r\n");
			NameValueCollection headers = base.Headers;
			string[] allKeys = headers.AllKeys;
			foreach (string text in allKeys)
			{
				stringBuilder.AppendFormat("{0}: {1}{2}", text, headers[text], "\r\n");
			}
			stringBuilder.Append("\r\n");
			string entityBody = base.EntityBody;
			if (entityBody.Length > 0)
			{
				stringBuilder.Append(entityBody);
			}
			return stringBuilder.ToString();
		}
	}
}
namespace WebSocketSharp.Net
{
	public enum AuthenticationSchemes
	{
		None = 0,
		Digest = 1,
		Basic = 8,
		Anonymous = 0x8000
	}
	internal class ChunkStream
	{
		private int _chunkRead;

		private int _chunkSize;

		private List<Chunk> _chunks;

		private bool _gotIt;

		private WebHeaderCollection _headers;

		private StringBuilder _saved;

		private bool _sawCr;

		private InputChunkState _state;

		private int _trailerState;

		internal WebHeaderCollection Headers => _headers;

		public int ChunkLeft => _chunkSize - _chunkRead;

		public bool WantMore => _state != InputChunkState.End;

		public ChunkStream(WebHeaderCollection headers)
		{
			_headers = headers;
			_chunkSize = -1;
			_chunks = new List<Chunk>();
			_saved = new StringBuilder();
		}

		public ChunkStream(byte[] buffer, int offset, int count, WebHeaderCollection headers)
			: this(headers)
		{
			Write(buffer, offset, count);
		}

		private int read(byte[] buffer, int offset, int count)
		{
			int num = 0;
			int count2 = _chunks.Count;
			for (int i = 0; i < count2; i++)
			{
				Chunk chunk = _chunks[i];
				if (chunk == null)
				{
					continue;
				}
				if (chunk.ReadLeft == 0)
				{
					_chunks[i] = null;
					continue;
				}
				num += chunk.Read(buffer, offset + num, count - num);
				if (num == count)
				{
					break;
				}
			}
			return num;
		}

		private static string removeChunkExtension(string value)
		{
			int num = value.IndexOf(';');
			return (num > -1) ? value.Substring(0, num) : value;
		}

		private InputChunkState seekCrLf(byte[] buffer, ref int offset, int length)
		{
			if (!_sawCr)
			{
				if (buffer[offset++] != 13)
				{
					throwProtocolViolation("CR is expected.");
				}
				_sawCr = true;
				if (offset == length)
				{
					return InputChunkState.DataEnded;
				}
			}
			if (buffer[offset++] != 10)
			{
				throwProtocolViolation("LF is expected.");
			}
			return InputChunkState.None;
		}

		private InputChunkState setChunkSize(byte[] buffer, ref int offset, int length)
		{
			byte b = 0;
			while (offset < length)
			{
				b = buffer[offset++];
				if (_sawCr)
				{
					if (b != 10)
					{
						throwProtocolViolation("LF is expected.");
					}
					break;
				}
				switch (b)
				{
				case 13:
					_sawCr = true;
					continue;
				case 10:
					throwProtocolViolation("LF is unexpected.");
					break;
				}
				if (b == 32)
				{
					_gotIt = true;
				}
				if (!_gotIt)
				{
					_saved.Append((char)b);
				}
				if (_saved.Length > 20)
				{
					throwProtocolViolation("The chunk size is too long.");
				}
			}
			if (!_sawCr || b != 10)
			{
				return InputChunkState.None;
			}
			_chunkRead = 0;
			try
			{
				_chunkSize = int.Parse(removeChunkExtension(_saved.ToString()), NumberStyles.HexNumber);
			}
			catch
			{
				throwProtocolViolation("The chunk size cannot be parsed.");
			}
			if (_chunkSize == 0)
			{
				_trailerState = 2;
				return InputChunkState.Trailer;
			}
			return InputChunkState.Data;
		}

		private InputChunkState setTrailer(byte[] buffer, ref int offset, int length)
		{
			if (_trailerState == 2 && buffer[offset] == 13 && _saved.Length == 0)
			{
				offset++;
				if (offset < length && buffer[offset] == 10)
				{
					offset++;
					return InputChunkState.End;
				}
				offset--;
			}
			while (offset < length && _trailerState < 4)
			{
				byte b = buffer[offset++];
				_saved.Append((char)b);
				if (_saved.Length > 4196)
				{
					throwProtocolViolation("The trailer is too long.");
				}
				if (_trailerState == 1 || _trailerState == 3)
				{
					if (b != 10)
					{
						throwProtocolViolation("LF is expected.");
					}
					_trailerState++;
					continue;
				}
				switch (b)
				{
				case 13:
					_trailerState++;
					continue;
				case 10:
					throwProtocolViolation("LF is unexpected.");
					break;
				}
				_trailerState = 0;
			}
			if (_trailerState < 4)
			{
				return InputChunkState.Trailer;
			}
			_saved.Length -= 2;
			StringReader stringReader = new StringReader(_saved.ToString());
			string text;
			while ((text = stringReader.ReadLine()) != null && text.Length > 0)
			{
				_headers.Add(text);
			}
			return InputChunkState.End;
		}

		private static void throwProtocolViolation(string message)
		{
			throw new WebException(message, null, WebExceptionStatus.ServerProtocolViolation, null);
		}

		private void write(byte[] buffer, ref int offset, int length)
		{
			if (_state == InputChunkState.End)
			{
				throwProtocolViolation("The chunks were ended.");
			}
			if (_state == InputChunkState.None)
			{
				_state = setChunkSize(buffer, ref offset, length);
				if (_state == InputChunkState.None)
				{
					return;
				}
				_saved.Length = 0;
				_sawCr = false;
				_gotIt = false;
			}
			if (_state == InputChunkState.Data && offset < length)
			{
				_state = writeData(buffer, ref offset, length);
				if (_state == InputChunkState.Data)
				{
					return;
				}
			}
			if (_state == InputChunkState.DataEnded && offset < length)
			{
				_state = seekCrLf(buffer, ref offset, length);
				if (_state == InputChunkState.DataEnded)
				{
					return;
				}
				_sawCr = false;
			}
			if (_state == InputChunkState.Trailer && offset < length)
			{
				_state = setTrailer(buffer, ref offset, length);
				if (_state == InputChunkState.Trailer)
				{
					return;
				}
				_saved.Length = 0;
			}
			if (offset < length)
			{
				write(buffer, ref offset, length);
			}
		}

		private InputChunkState writeData(byte[] buffer, ref int offset, int length)
		{
			int num = length - offset;
			int num2 = _chunkSize - _chunkRead;
			if (num > num2)
			{
				num = num2;
			}
			byte[] array = new byte[num];
			Buffer.BlockCopy(buffer, offset, array, 0, num);
			_chunks.Add(new Chunk(array));
			offset += num;
			_chunkRead += num;
			return (_chunkRead != _chunkSize) ? InputChunkState.Data : InputChunkState.DataEnded;
		}

		internal void ResetBuffer()
		{
			_chunkRead = 0;
			_chunkSize = -1;
			_chunks.Clear();
		}

		internal int WriteAndReadBack(byte[] buffer, int offset, int writeCount, int readCount)
		{
			Write(buffer, offset, writeCount);
			return Read(buffer, offset, readCount);
		}

		public int Read(byte[] buffer, int offset, int count)
		{
			if (count <= 0)
			{
				return 0;
			}
			return read(buffer, offset, count);
		}

		public void Write(byte[] buffer, int offset, int count)
		{
			if (count > 0)
			{
				write(buffer, ref offset, offset + count);
			}
		}
	}
	[Serializable]
	public sealed class Cookie
	{
		private string _comment;

		private Uri _commentUri;

		private bool _discard;

		private string _domain;

		private DateTime _expires;

		private bool _httpOnly;

		private string _name;

		private string _path;

		private string _port;

		private int[] _ports;

		private static readonly char[] _reservedCharsForName;

		private static readonly char[] _reservedCharsForValue;

		private bool _secure;

		private DateTime _timestamp;

		private string _value;

		private int _version;

		internal bool ExactDomain { get; set; }

		internal int MaxAge
		{
			get
			{
				if (_expires == DateTime.MinValue)
				{
					return 0;
				}
				DateTime dateTime = ((_expires.Kind != DateTimeKind.Local) ? _expires.ToLocalTime() : _expires);
				TimeSpan timeSpan = dateTime - DateTime.Now;
				return (timeSpan > TimeSpan.Zero) ? ((int)timeSpan.TotalSeconds) : 0;
			}
		}

		internal int[] Ports => _ports;

		public string Comment
		{
			get
			{
				return _comment;
			}
			set
			{
				_comment = value ?? string.Empty;
			}
		}

		public Uri CommentUri
		{
			get
			{
				return _commentUri;
			}
			set
			{
				_commentUri = value;
			}
		}

		public bool Discard
		{
			get
			{
				return _discard;
			}
			set
			{
				_discard = value;
			}
		}

		public string Domain
		{
			get
			{
				return _domain;
			}
			set
			{
				if (value.IsNullOrEmpty())
				{
					_domain = string.Empty;
					ExactDomain = true;
				}
				else
				{
					_domain = value;
					ExactDomain = value[0] != '.';
				}
			}
		}

		public bool Expired
		{
			get
			{
				return _expires != DateTime.MinValue && _expires <= DateTime.Now;
			}
			set
			{
				_expires = (value ? DateTime.Now : DateTime.MinValue);
			}
		}

		public DateTime Expires
		{
			get
			{
				return _expires;
			}
			set
			{
				_expires = value;
			}
		}

		public bool HttpOnly
		{
			get
			{
				return _httpOnly;
			}
			set
			{
				_httpOnly = value;
			}
		}

		public string Name
		{
			get
			{
				return _name;
			}
			set
			{
				if (!canSetName(value, out var message))
				{
					throw new CookieException(message);
				}
				_name = value;
			}
		}

		public string Path
		{
			get
			{
				return _path;
			}
			set
			{
				_path = value ?? string.Empty;
			}
		}

		public string Port
		{
			get
			{
				return _port;
			}
			set
			{
				if (value.IsNullOrEmpty())
				{
					_port = string.Empty;
					_ports = new int[0];
					return;
				}
				if (!value.IsEnclosedIn('"'))
				{
					throw new CookieException("The value specified for the Port attribute isn't enclosed in double quotes.");
				}
				if (!tryCreatePorts(value, out _ports, out var parseError))
				{
					throw new CookieException($"The value specified for the Port attribute contains an invalid value: {parseError}");
				}
				_port = value;
			}
		}

		public bool Secure
		{
			get
			{
				return _secure;
			}
			set
			{
				_secure = value;
			}
		}

		public DateTime TimeStamp => _timestamp;

		public string Value
		{
			get
			{
				return _value;
			}
			set
			{
				if (!canSetValue(value, out var message))
				{
					throw new CookieException(message);
				}
				_value = ((value.Length > 0) ? value : "\"\"");
			}
		}

		public int Version
		{
			get
			{
				return _version;
			}
			set
			{
				if (value < 0 || value > 1)
				{
					throw new ArgumentOutOfRangeException("value", "Not 0 or 1.");
				}
				_version = value;
			}
		}

		static Cookie()
		{
			_reservedCharsForName = new char[7] { ' ', '=', ';', ',', '\n', '\r', '\t' };
			_reservedCharsForValue = new char[2] { ';', ',' };
		}

		public Cookie()
		{
			_comment = string.Empty;
			_domain = string.Empty;
			_expires = DateTime.MinValue;
			_name = string.Empty;
			_path = string.Empty;
			_port = string.Empty;
			_ports = new int[0];
			_timestamp = DateTime.Now;
			_value = string.Empty;
			_version = 0;
		}

		public Cookie(string name, string value)
			: this()
		{
			Name = name;
			Value = value;
		}

		public Cookie(string name, string value, string path)
			: this(name, value)
		{
			Path = path;
		}

		public Cookie(string name, string value, string path, string domain)
			: this(name, value, path)
		{
			Domain = domain;
		}

		private static bool canSetName(string name, out string message)
		{
			if (name.IsNullOrEmpty())
			{
				message = "The value specified for the Name is null or empty.";
				return false;
			}
			if (name[0] == '$' || name.Contains(_reservedCharsForName))
			{
				message = "The value specified for the Name contains an invalid character.";
				return false;
			}
			message = string.Empty;
			return true;
		}

		private static bool canSetValue(string value, out string message)
		{
			if (value == null)
			{
				message = "The value specified for the Value is null.";
				return false;
			}
			if (value.Contains(_reservedCharsForValue) && !value.IsEnclosedIn('"'))
			{
				message = "The value specified for the Value contains an invalid character.";
				return false;
			}
			message = string.Empty;
			return true;
		}

		private static int hash(int i, int j, int k, int l, int m)
		{
			return i ^ ((j << 13) | (j >> 19)) ^ ((k << 26) | (k >> 6)) ^ ((l << 7) | (l >> 25)) ^ ((m << 20) | (m >> 12));
		}

		private string toResponseStringVersion0()
		{
			StringBuilder stringBuilder = new StringBuilder(64);
			stringBuilder.AppendFormat("{0}={1}", _name, _value);
			if (_expires != DateTime.MinValue)
			{
				stringBuilder.AppendFormat("; Expires={0}", _expires.ToUniversalTime().ToString("ddd, dd'-'MMM'-'yyyy HH':'mm':'ss 'GMT'", CultureInfo.CreateSpecificCulture("en-US")));
			}
			if (!_path.IsNullOrEmpty())
			{
				stringBuilder.AppendFormat("; Path={0}", _path);
			}
			if (!_domain.IsNullOrEmpty())
			{
				stringBuilder.AppendFormat("; Domain={0}", _domain);
			}
			if (_secure)
			{
				stringBuilder.Append("; Secure");
			}
			if (_httpOnly)
			{
				stringBuilder.Append("; HttpOnly");
			}
			return stringBuilder.ToString();
		}

		private string toResponseStringVersion1()
		{
			StringBuilder stringBuilder = new StringBuilder(64);
			stringBuilder.AppendFormat("{0}={1}; Version={2}", _name, _value, _version);
			if (_expires != DateTime.MinValue)
			{
				stringBuilder.AppendFormat("; Max-Age={0}", MaxAge);
			}
			if (!_path.IsNullOrEmpty())
			{
				stringBuilder.AppendFormat("; Path={0}", _path);
			}
			if (!_domain.IsNullOrEmpty())
			{
				stringBuilder.AppendFormat("; Domain={0}", _domain);
			}
			if (!_port.IsNullOrEmpty())
			{
				if (_port == "\"\"")
				{
					stringBuilder.Append("; Port");
				}
				else
				{
					stringBuilder.AppendFormat("; Port={0}", _port);
				}
			}
			if (!_comment.IsNullOrEmpty())
			{
				stringBuilder.AppendFormat("; Comment={0}", _comment.UrlEncode());
			}
			if (_commentUri != null)
			{
				string originalString = _commentUri.OriginalString;
				stringBuilder.AppendFormat("; CommentURL={0}", originalString.IsToken() ? originalString : originalString.Quote());
			}
			if (_discard)
			{
				stringBuilder.Append("; Discard");
			}
			if (_secure)
			{
				stringBuilder.Append("; Secure");
			}
			return stringBuilder.ToString();
		}

		private static bool tryCreatePorts(string value, out int[] result, out string parseError)
		{
			string[] array = value.Trim(new char[1] { '"' }).Split(new char[1] { ',' });
			int num = array.Length;
			int[] array2 = new int[num];
			for (int i = 0; i < num; i++)
			{
				array2[i] = int.MinValue;
				string text = array[i].Trim();
				if (text.Length != 0 && !int.TryParse(text, out array2[i]))
				{
					result = new int[0];
					parseError = text;
					return false;
				}
			}
			result = array2;
			parseError = string.Empty;
			return true;
		}

		internal string ToRequestString(Uri uri)
		{
			if (_name.Length == 0)
			{
				return string.Empty;
			}
			if (_version == 0)
			{
				return $"{_name}={_value}";
			}
			StringBuilder stringBuilder = new StringBuilder(64);
			stringBuilder.AppendFormat("$Version={0}; {1}={2}", _version, _name, _value);
			if (!_path.IsNullOrEmpty())
			{
				stringBuilder.AppendFormat("; $Path={0}", _path);
			}
			else if (uri != null)
			{
				stringBuilder.AppendFormat("; $Path={0}", uri.GetAbsolutePath());
			}
			else
			{
				stringBuilder.Append("; $Path=/");
			}
			if ((uri == null || uri.Host != _domain) && !_domain.IsNullOrEmpty())
			{
				stringBuilder.AppendFormat("; $Domain={0}", _domain);
			}
			if (!_port.IsNullOrEmpty())
			{
				if (_port == "\"\"")
				{
					stringBuilder.Append("; $Port");
				}
				else
				{
					stringBuilder.AppendFormat("; $Port={0}", _port);
				}
			}
			return stringBuilder.ToString();
		}

		internal string ToResponseString()
		{
			return (_name.Length <= 0) ? string.Empty : ((_version == 0) ? toResponseStringVersion0() : toResponseStringVersion1());
		}

		public override bool Equals(object comparand)
		{
			return comparand is Cookie cookie && _name.Equals(cookie.Name, StringComparison.InvariantCultureIgnoreCase) && _value.Equals(cookie.Value, StringComparison.InvariantCulture) && _path.Equals(cookie.Path, StringComparison.InvariantCulture) && _domain.Equals(cookie.Domain, StringComparison.InvariantCultureIgnoreCase) && _version == cookie.Version;
		}

		public override int GetHashCode()
		{
			return hash(StringComparer.InvariantCultureIgnoreCase.GetHashCode(_name), _value.GetHashCode(), _path.GetHashCode(), StringComparer.InvariantCultureIgnoreCase.GetHashCode(_domain), _version);
		}

		public override string ToString()
		{
			return ToRequestString(null);
		}
	}
	[Serializable]
	public class CookieCollection : ICollection, IEnumerable
	{
		private List<Cookie> _list;

		private object _sync;

		internal IList<Cookie> List => _list;

		internal IEnumerable<Cookie> Sorted
		{
			get
			{
				List<Cookie> list = new List<Cookie>(_list);
				if (list.Count > 1)
				{
					list.Sort(compareCookieWithinSorted);
				}
				return list;
			}
		}

		public int Count => _list.Count;

		public bool IsReadOnly => true;

		public bool IsSynchronized => false;

		public Cookie this[int index]
		{
			get
			{
				if (index < 0 || index >= _list.Count)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				return _list[index];
			}
		}

		public Cookie this[string name]
		{
			get
			{
				if (name == null)
				{
					throw new ArgumentNullException("name");
				}
				foreach (Cookie item in Sorted)
				{
					if (item.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
					{
						return item;
					}
				}
				return null;
			}
		}

		public object SyncRoot => _sync ?? (_sync = ((ICollection)_list).SyncRoot);

		public CookieCollection()
		{
			_list = new List<Cookie>();
		}

		private static int compareCookieWithinSort(Cookie x, Cookie y)
		{
			return x.Name.Length + x.Value.Length - (y.Name.Length + y.Value.Length);
		}

		private static int compareCookieWithinSorted(Cookie x, Cookie y)
		{
			int num = 0;
			return ((num = x.Version - y.Version) != 0) ? num : (((num = x.Name.CompareTo(y.Name)) != 0) ? num : (y.Path.Length - x.Path.Length));
		}

		private static CookieCollection parseRequest(string value)
		{
			CookieCollection cookieCollection = new CookieCollection();
			Cookie cookie = null;
			int num = 0;
			string[] array = splitCookieHeaderValue(value);
			for (int i = 0; i < array.Length; i++)
			{
				string text = array[i].Trim();
				if (text.Length == 0)
				{
					continue;
				}
				if (text.StartsWith("$version", StringComparison.InvariantCultureIgnoreCase))
				{
					num = int.Parse(text.GetValue('=', unquote: true));
					continue;
				}
				if (text.StartsWith("$path", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Path = text.GetValue('=');
					}
					continue;
				}
				if (text.StartsWith("$domain", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Domain = text.GetValue('=');
					}
					continue;
				}
				if (text.StartsWith("$port", StringComparison.InvariantCultureIgnoreCase))
				{
					string port = (text.Equals("$port", StringComparison.InvariantCultureIgnoreCase) ? "\"\"" : text.GetValue('='));
					if (cookie != null)
					{
						cookie.Port = port;
					}
					continue;
				}
				if (cookie != null)
				{
					cookieCollection.Add(cookie);
				}
				string value2 = string.Empty;
				int num2 = text.IndexOf('=');
				string name;
				if (num2 == -1)
				{
					name = text;
				}
				else if (num2 == text.Length - 1)
				{
					name = text.Substring(0, num2).TrimEnd(new char[1] { ' ' });
				}
				else
				{
					name = text.Substring(0, num2).TrimEnd(new char[1] { ' ' });
					value2 = text.Substring(num2 + 1).TrimStart(new char[1] { ' ' });
				}
				cookie = new Cookie(name, value2);
				if (num != 0)
				{
					cookie.Version = num;
				}
			}
			if (cookie != null)
			{
				cookieCollection.Add(cookie);
			}
			return cookieCollection;
		}

		private static CookieCollection parseResponse(string value)
		{
			CookieCollection cookieCollection = new CookieCollection();
			Cookie cookie = null;
			string[] array = splitCookieHeaderValue(value);
			for (int i = 0; i < array.Length; i++)
			{
				string text = array[i].Trim();
				if (text.Length == 0)
				{
					continue;
				}
				if (text.StartsWith("version", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Version = int.Parse(text.GetValue('=', unquote: true));
					}
					continue;
				}
				if (text.StartsWith("expires", StringComparison.InvariantCultureIgnoreCase))
				{
					StringBuilder stringBuilder = new StringBuilder(text.GetValue('='), 32);
					if (i < array.Length - 1)
					{
						stringBuilder.AppendFormat(", {0}", array[++i].Trim());
					}
					if (!DateTime.TryParseExact(stringBuilder.ToString(), new string[2] { "ddd, dd'-'MMM'-'yyyy HH':'mm':'ss 'GMT'", "r" }, CultureInfo.CreateSpecificCulture("en-US"), DateTimeStyles.AdjustToUniversal | DateTimeStyles.AssumeUniversal, out var result))
					{
						result = DateTime.Now;
					}
					if (cookie != null && cookie.Expires == DateTime.MinValue)
					{
						cookie.Expires = result.ToLocalTime();
					}
					continue;
				}
				if (text.StartsWith("max-age", StringComparison.InvariantCultureIgnoreCase))
				{
					int num = int.Parse(text.GetValue('=', unquote: true));
					DateTime expires = DateTime.Now.AddSeconds(num);
					if (cookie != null)
					{
						cookie.Expires = expires;
					}
					continue;
				}
				if (text.StartsWith("path", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Path = text.GetValue('=');
					}
					continue;
				}
				if (text.StartsWith("domain", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Domain = text.GetValue('=');
					}
					continue;
				}
				if (text.StartsWith("port", StringComparison.InvariantCultureIgnoreCase))
				{
					string port = (text.Equals("port", StringComparison.InvariantCultureIgnoreCase) ? "\"\"" : text.GetValue('='));
					if (cookie != null)
					{
						cookie.Port = port;
					}
					continue;
				}
				if (text.StartsWith("comment", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Comment = text.GetValue('=').UrlDecode();
					}
					continue;
				}
				if (text.StartsWith("commenturl", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.CommentUri = text.GetValue('=', unquote: true).ToUri();
					}
					continue;
				}
				if (text.StartsWith("discard", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Discard = true;
					}
					continue;
				}
				if (text.StartsWith("secure", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.Secure = true;
					}
					continue;
				}
				if (text.StartsWith("httponly", StringComparison.InvariantCultureIgnoreCase))
				{
					if (cookie != null)
					{
						cookie.HttpOnly = true;
					}
					continue;
				}
				if (cookie != null)
				{
					cookieCollection.Add(cookie);
				}
				string value2 = string.Empty;
				int num2 = text.IndexOf('=');
				string name;
				if (num2 == -1)
				{
					name = text;
				}
				else if (num2 == text.Length - 1)
				{
					name = text.Substring(0, num2).TrimEnd(new char[1] { ' ' });
				}
				else
				{
					name = text.Substring(0, num2).TrimEnd(new char[1] { ' ' });
					value2 = text.Substring(num2 + 1).TrimStart(new char[1] { ' ' });
				}
				cookie = new Cookie(name, value2);
			}
			if (cookie != null)
			{
				cookieCollection.Add(cookie);
			}
			return cookieCollection;
		}

		private int searchCookie(Cookie cookie)
		{
			string name = cookie.Name;
			string path = cookie.Path;
			string domain = cookie.Domain;
			int version = cookie.Version;
			for (int num = _list.Count - 1; num >= 0; num--)
			{
				Cookie cookie2 = _list[num];
				if (cookie2.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase) && cookie2.Path.Equals(path, StringComparison.InvariantCulture) && cookie2.Domain.Equals(domain, StringComparison.InvariantCultureIgnoreCase) && cookie2.Version == version)
				{
					return num;
				}
			}
			return -1;
		}

		private static string[] splitCookieHeaderValue(string value)
		{
			return new List<string>(value.SplitHeaderValue(',', ';')).ToArray();
		}

		internal static CookieCollection Parse(string value, bool response)
		{
			return response ? parseResponse(value) : parseRequest(value);
		}

		internal void SetOrRemove(Cookie cookie)
		{
			int num = searchCookie(cookie);
			if (num == -1)
			{
				if (!cookie.Expired)
				{
					_list.Add(cookie);
				}
			}
			else if (!cookie.Expired)
			{
				_list[num] = cookie;
			}
			else
			{
				_list.RemoveAt(num);
			}
		}

		internal void SetOrRemove(CookieCollection cookies)
		{
			foreach (Cookie cookie in cookies)
			{
				SetOrRemove(cookie);
			}
		}

		internal void Sort()
		{
			if (_list.Count > 1)
			{
				_list.Sort(compareCookieWithinSort);
			}
		}

		public void Add(Cookie cookie)
		{
			if (cookie == null)
			{
				throw new ArgumentNullException("cookie");
			}
			int num = searchCookie(cookie);
			if (num == -1)
			{
				_list.Add(cookie);
			}
			else
			{
				_list[num] = cookie;
			}
		}

		public void Add(CookieCollection cookies)
		{
			if (cookies == null)
			{
				throw new ArgumentNullException("cookies");
			}
			foreach (Cookie cookie in cookies)
			{
				Add(cookie);
			}
		}

		public void CopyTo(Array array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index", "Less than zero.");
			}
			if (array.Rank > 1)
			{
				throw new ArgumentException("Multidimensional.", "array");
			}
			if (array.Length - index < _list.Count)
			{
				throw new ArgumentException("The number of elements in this collection is greater than the available space of the destination array.");
			}
			if (!array.GetType().GetElementType().IsAssignableFrom(typeof(Cookie)))
			{
				throw new InvalidCastException("The elements in this collection cannot be cast automatically to the type of the destination array.");
			}
			((ICollection)_list).CopyTo(array, index);
		}

		public void CopyTo(Cookie[] array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index", "Less than zero.");
			}
			if (array.Length - index < _list.Count)
			{
				throw new ArgumentException("The number of elements in this collection is greater than the available space of the destination array.");
			}
			_list.CopyTo(array, index);
		}

		public IEnumerator GetEnumerator()
		{
			return _list.GetEnumerator();
		}
	}
	[Serializable]
	public class CookieException : FormatException, ISerializable
	{
		internal CookieException(string message)
			: base(message)
		{
		}

		internal CookieException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected CookieException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
		}

		public CookieException()
		{
		}

		[SecurityPermission(System.Security.Permissions.SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			base.GetObjectData(serializationInfo, streamingContext);
		}

		[SecurityPermission(System.Security.Permissions.SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter, SerializationFormatter = true)]
		void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			base.GetObjectData(serializationInfo, streamingContext);
		}
	}
	internal sealed class EndPointListener
	{
		private List<HttpListenerPrefix> _all;

		private static readonly string _defaultCertFolderPath;

		private IPEndPoint _endpoint;

		private Dictionary<HttpListenerPrefix, HttpListener> _prefixes;

		private bool _secure;

		private Socket _socket;

		private ServerSslConfiguration _sslConfig;

		private List<HttpListenerPrefix> _unhandled;

		private Dictionary<HttpConnection, HttpConnection> _unregistered;

		private object _unregisteredSync;

		public IPAddress Address => _endpoint.Address;

		public bool IsSecure => _secure;

		public int Port => _endpoint.Port;

		public ServerSslConfiguration SslConfiguration => _sslConfig;

		static EndPointListener()
		{
			_defaultCertFolderPath = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
		}

		internal EndPointListener(IPEndPoint endpoint, bool secure, string certificateFolderPath, ServerSslConfiguration sslConfig, bool reuseAddress)
		{
			if (secure)
			{
				X509Certificate2 certificate = getCertificate(endpoint.Port, certificateFolderPath, sslConfig.ServerCertificate);
				if (certificate == null)
				{
					throw new ArgumentException("No server certificate could be found.");
				}
				_secure = true;
				_sslConfig = new ServerSslConfiguration(certificate, sslConfig.ClientCertificateRequired, sslConfig.EnabledSslProtocols, sslConfig.CheckCertificateRevocation);
				_sslConfig.ClientCertificateValidationCallback = sslConfig.ClientCertificateValidationCallback;
			}
			_endpoint = endpoint;
			_prefixes = new Dictionary<HttpListenerPrefix, HttpListener>();
			_unregistered = new Dictionary<HttpConnection, HttpConnection>();
			_unregisteredSync = ((ICollection)_unregistered).SyncRoot;
			_socket = new Socket(endpoint.Address.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
			if (reuseAddress)
			{
				_socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, optionValue: true);
			}
			_socket.Bind(endpoint);
			_socket.Listen(500);
			_socket.BeginAccept(onAccept, this);
		}

		private static void addSpecial(List<HttpListenerPrefix> prefixes, HttpListenerPrefix prefix)
		{
			string path = prefix.Path;
			foreach (HttpListenerPrefix prefix2 in prefixes)
			{
				if (prefix2.Path == path)
				{
					throw new HttpListenerException(87, "The prefix is already in use.");
				}
			}
			prefixes.Add(prefix);
		}

		private static RSACryptoServiceProvider createRSAFromFile(string filename)
		{
			byte[] array = null;
			using (FileStream fileStream = File.Open(filename, System.IO.FileMode.Open, FileAccess.Read, FileShare.Read))
			{
				array = new byte[fileStream.Length];
				fileStream.Read(array, 0, array.Length);
			}
			RSACryptoServiceProvider rSACryptoServiceProvider = new RSACryptoServiceProvider();
			rSACryptoServiceProvider.ImportCspBlob(array);
			return rSACryptoServiceProvider;
		}

		private static X509Certificate2 getCertificate(int port, string folderPath, X509Certificate2 defaultCertificate)
		{
			if (folderPath == null || folderPath.Length == 0)
			{
				folderPath = _defaultCertFolderPath;
			}
			try
			{
				string text = Path.Combine(folderPath, $"{port}.cer");
				string text2 = Path.Combine(folderPath, $"{port}.key");
				if (File.Exists(text) && File.Exists(text2))
				{
					X509Certificate2 x509Certificate = new X509Certificate2(text);
					x509Certificate.PrivateKey = createRSAFromFile(text2);
					return x509Certificate;
				}
			}
			catch
			{
			}
			return defaultCertificate;
		}

		private void leaveIfNoPrefix()
		{
			if (_prefixes.Count > 0)
			{
				return;
			}
			List<HttpListenerPrefix> unhandled = _unhandled;
			if (unhandled == null || unhandled.Count <= 0)
			{
				unhandled = _all;
				if (unhandled == null || unhandled.Count <= 0)
				{
					EndPointManager.RemoveEndPoint(_endpoint);
				}
			}
		}

		private static void onAccept(IAsyncResult asyncResult)
		{
			EndPointListener endPointListener = (EndPointListener)asyncResult.AsyncState;
			Socket socket = null;
			try
			{
				socket = endPointListener._socket.EndAccept(asyncResult);
			}
			catch (SocketException)
			{
			}
			catch (ObjectDisposedException)
			{
				return;
			}
			try
			{
				endPointListener._socket.BeginAccept(onAccept, endPointListener);
			}
			catch
			{
				socket?.Close();
				return;
			}
			if (socket != null)
			{
				processAccepted(socket, endPointListener);
			}
		}

		private static void processAccepted(Socket socket, EndPointListener listener)
		{
			HttpConnection httpConnection = null;
			try
			{
				httpConnection = new HttpConnection(socket, listener);
				lock (listener._unregisteredSync)
				{
					listener._unregistered[httpConnection] = httpConnection;
				}
				httpConnection.BeginReadRequest();
			}
			catch
			{
				if (httpConnection != null)
				{
					httpConnection.Close(force: true);
				}
				else
				{
					socket.Close();
				}
			}
		}

		private static bool removeSpecial(List<HttpListenerPrefix> prefixes, HttpListenerPrefix prefix)
		{
			string path = prefix.Path;
			int count = prefixes.Count;
			for (int i = 0; i < count; i++)
			{
				if (prefixes[i].Path == path)
				{
					prefixes.RemoveAt(i);
					return true;
				}
			}
			return false;
		}

		private static HttpListener searchHttpListenerFromSpecial(string path, List<HttpListenerPrefix> prefixes)
		{
			if (prefixes == null)
			{
				return null;
			}
			HttpListener result = null;
			int num = -1;
			foreach (HttpListenerPrefix prefix in prefixes)
			{
				string path2 = prefix.Path;
				int length = path2.Length;
				if (length >= num && path.StartsWith(path2))
				{
					num = length;
					result = prefix.Listener;
				}
			}
			return result;
		}

		internal static bool CertificateExists(int port, string folderPath)
		{
			if (folderPath == null || folderPath.Length == 0)
			{
				folderPath = _defaultCertFolderPath;
			}
			string path = Path.Combine(folderPath, $"{port}.cer");
			string path2 = Path.Combine(folderPath, $"{port}.key");
			return File.Exists(path) && File.Exists(path2);
		}

		internal void RemoveConnection(HttpConnection connection)
		{
			lock (_unregisteredSync)
			{
				_unregistered.Remove(connection);
			}
		}

		internal bool TrySearchHttpListener(Uri uri, out HttpListener listener)
		{
			listener = null;
			if (uri == null)
			{
				return false;
			}
			string host = uri.Host;
			bool flag = Uri.CheckHostName(host) == UriHostNameType.Dns;
			string text = uri.Port.ToString();
			string text2 = HttpUtility.UrlDecode(uri.AbsolutePath);
			string text3 = ((text2[text2.Length - 1] != '/') ? (text2 + "/") : text2);
			if (host != null && host.Length > 0)
			{
				int num = -1;
				foreach (HttpListenerPrefix key in _prefixes.Keys)
				{
					if (flag)
					{
						string host2 = key.Host;
						if (Uri.CheckHostName(host2) == UriHostNameType.Dns && host2 != host)
						{
							continue;
						}
					}
					if (!(key.Port != text))
					{
						string path = key.Path;
						int length = path.Length;
						if (length >= num && (text2.StartsWith(path) || text3.StartsWith(path)))
						{
							num = length;
							listener = _prefixes[key];
						}
					}
				}
				if (num != -1)
				{
					return true;
				}
			}
			List<HttpListenerPrefix> unhandled = _unhandled;
			listener = searchHttpListenerFromSpecial(text2, unhandled);
			if (listener == null && text3 != text2)
			{
				listener = searchHttpListenerFromSpecial(text3, unhandled);
			}
			if (listener != null)
			{
				return true;
			}
			unhandled = _all;
			listener = searchHttpListenerFromSpecial(text2, unhandled);
			if (listener == null && text3 != text2)
			{
				listener = searchHttpListenerFromSpecial(text3, unhandled);
			}
			return listener != null;
		}

		public void AddPrefix(HttpListenerPrefix prefix, HttpListener listener)
		{
			if (prefix.Host == "*")
			{
				List<HttpListenerPrefix> unhandled;
				List<HttpListenerPrefix> list;
				do
				{
					unhandled = _unhandled;
					list = ((unhandled != null) ? new List<HttpListenerPrefix>(unhandled) : new List<HttpListenerPrefix>());
					prefix.Listener = listener;
					addSpecial(list, prefix);
				}
				while (Interlocked.CompareExchange(ref _unhandled, list, unhandled) != unhandled);
				return;
			}
			if (prefix.Host == "+")
			{
				List<HttpListenerPrefix> unhandled;
				List<HttpListenerPrefix> list;
				do
				{
					unhandled = _all;
					list = ((unhandled != null) ? new List<HttpListenerPrefix>(unhandled) : new List<HttpListenerPrefix>());
					prefix.Listener = listener;
					addSpecial(list, prefix);
				}
				while (Interlocked.CompareExchange(ref _all, list, unhandled) != unhandled);
				return;
			}
			Dictionary<HttpListenerPrefix, HttpListener> prefixes;
			Dictionary<HttpListenerPrefix, HttpListener> dictionary;
			do
			{
				prefixes = _prefixes;
				if (prefixes.ContainsKey(prefix))
				{
					if (prefixes[prefix] != listener)
					{
						throw new HttpListenerException(87, $"There's another listener for {prefix}.");
					}
					break;
				}
				dictionary = new Dictionary<HttpListenerPrefix, HttpListener>(prefixes);
				dictionary[prefix] = listener;
			}
			while (Interlocked.CompareExchange(ref _prefixes, dictionary, prefixes) != prefixes);
		}

		public void Close()
		{
			_socket.Close();
			HttpConnection[] array = null;
			lock (_unregisteredSync)
			{
				if (_unregistered.Count == 0)
				{
					return;
				}
				Dictionary<HttpConnection, HttpConnection>.KeyCollection keys = _unregistered.Keys;
				array = new HttpConnection[keys.Count];
				keys.CopyTo(array, 0);
				_unregistered.Clear();
			}
			for (int num = array.Length - 1; num >= 0; num--)
			{
				array[num].Close(force: true);
			}
		}

		public void RemovePrefix(HttpListenerPrefix prefix, HttpListener listener)
		{
			if (prefix.Host == "*")
			{
				List<HttpListenerPrefix> unhandled;
				List<HttpListenerPrefix> list;
				do
				{
					unhandled = _unhandled;
					if (unhandled == null)
					{
						break;
					}
					list = new List<HttpListenerPrefix>(unhandled);
				}
				while (removeSpecial(list, prefix) && Interlocked.CompareExchange(ref _unhandled, list, unhandled) != unhandled);
				leaveIfNoPrefix();
				return;
			}
			if (prefix.Host == "+")
			{
				List<HttpListenerPrefix> unhandled;
				List<HttpListenerPrefix> list;
				do
				{
					unhandled = _all;
					if (unhandled == null)
					{
						break;
					}
					list = new List<HttpListenerPrefix>(unhandled);
				}
				while (removeSpecial(list, prefix) && Interlocked.CompareExchange(ref _all, list, unhandled) != unhandled);
				leaveIfNoPrefix();
				return;
			}
			Dictionary<HttpListenerPrefix, HttpListener> prefixes;
			Dictionary<HttpListenerPrefix, HttpListener> dictionary;
			do
			{
				prefixes = _prefixes;
				if (!prefixes.ContainsKey(prefix))
				{
					break;
				}
				dictionary = new Dictionary<HttpListenerPrefix, HttpListener>(prefixes);
				dictionary.Remove(prefix);
			}
			while (Interlocked.CompareExchange(ref _prefixes, dictionary, prefixes) != prefixes);
			leaveIfNoPrefix();
		}
	}
	internal sealed class EndPointManager
	{
		private static readonly Dictionary<IPEndPoint, EndPointListener> _endpoints;

		static EndPointManager()
		{
			_endpoints = new Dictionary<IPEndPoint, EndPointListener>();
		}

		private EndPointManager()
		{
		}

		private static void addPrefix(string uriPrefix, HttpListener listener)
		{
			HttpListenerPrefix httpListenerPrefix = new HttpListenerPrefix(uriPrefix);
			IPAddress address = convertToIPAddress(httpListenerPrefix.Host);
			if (!address.IsLocal())
			{
				throw new HttpListenerException(87, "Includes an invalid host.");
			}
			if (!int.TryParse(httpListenerPrefix.Port, out var result))
			{
				throw new HttpListenerException(87, "Includes an invalid port.");
			}
			if (!result.IsPortNumber())
			{
				throw new HttpListenerException(87, "Includes an invalid port.");
			}
			string path = httpListenerPrefix.Path;
			if (path.IndexOf('%') != -1)
			{
				throw new HttpListenerException(87, "Includes an invalid path.");
			}
			if (path.IndexOf("//", StringComparison.Ordinal) != -1)
			{
				throw new HttpListenerException(87, "Includes an invalid path.");
			}
			IPEndPoint iPEndPoint = new IPEndPoint(address, result);
			if (_endpoints.TryGetValue(iPEndPoint, out var value))
			{
				if (value.IsSecure ^ httpListenerPrefix.IsSecure)
				{
					throw new HttpListenerException(87, "Includes an invalid scheme.");
				}
			}
			else
			{
				value = new EndPointListener(iPEndPoint, httpListenerPrefix.IsSecure, listener.CertificateFolderPath, listener.SslConfiguration, listener.ReuseAddress);
				_endpoints.Add(iPEndPoint, value);
			}
			value.AddPrefix(httpListenerPrefix, listener);
		}

		private static IPAddress convertToIPAddress(string hostname)
		{
			return (hostname == "*" || hostname == "+") ? IPAddress.Any : hostname.ToIPAddress();
		}

		private static void removePrefix(string uriPrefix, HttpListener listener)
		{
			HttpListenerPrefix httpListenerPrefix = new HttpListenerPrefix(uriPrefix);
			IPAddress address = convertToIPAddress(httpListenerPrefix.Host);
			if (!address.IsLocal() || !int.TryParse(httpListenerPrefix.Port, out var result) || !result.IsPortNumber())
			{
				return;
			}
			string path = httpListenerPrefix.Path;
			if (path.IndexOf('%') == -1 && path.IndexOf("//", StringComparison.Ordinal) == -1)
			{
				IPEndPoint key = new IPEndPoint(address, result);
				if (_endpoints.TryGetValue(key, out var value) && !(value.IsSecure ^ httpListenerPrefix.IsSecure))
				{
					value.RemovePrefix(httpListenerPrefix, listener);
				}
			}
		}

		internal static bool RemoveEndPoint(IPEndPoint endpoint)
		{
			lock (((ICollection)_endpoints).SyncRoot)
			{
				if (!_endpoints.TryGetValue(endpoint, out var value))
				{
					return false;
				}
				_endpoints.Remove(endpoint);
				value.Close();
				return true;
			}
		}

		public static void AddListener(HttpListener listener)
		{
			List<string> list = new List<string>();
			lock (((ICollection)_endpoints).SyncRoot)
			{
				try
				{
					foreach (string prefix in listener.Prefixes)
					{
						addPrefix(prefix, listener);
						list.Add(prefix);
					}
				}
				catch
				{
					foreach (string item in list)
					{
						removePrefix(item, listener);
					}
					throw;
				}
			}
		}

		public static void AddPrefix(string uriPrefix, HttpListener listener)
		{
			lock (((ICollection)_endpoints).SyncRoot)
			{
				addPrefix(uriPrefix, listener);
			}
		}

		public static void RemoveListener(HttpListener listener)
		{
			lock (((ICollection)_endpoints).SyncRoot)
			{
				foreach (string prefix in listener.Prefixes)
				{
					removePrefix(prefix, listener);
				}
			}
		}

		public static void RemovePrefix(string uriPrefix, HttpListener listener)
		{
			lock (((ICollection)_endpoints).SyncRoot)
			{
				removePrefix(uriPrefix, listener);
			}
		}
	}
	internal sealed class HttpConnection
	{
		private byte[] _buffer;

		private const int _bufferLength = 8192;

		private HttpListenerContext _context;

		private bool _contextRegistered;

		private StringBuilder _currentLine;

		private InputState _inputState;

		private RequestStream _inputStream;

		private HttpListener _lastListener;

		private LineState _lineState;

		private EndPointListener _listener;

		private ResponseStream _outputStream;

		private int _position;

		private MemoryStream _requestBuffer;

		private int _reuses;

		private bool _secure;

		private Socket _socket;

		private Stream _stream;

		private object _sync;

		private int _timeout;

		private Dictionary<int, bool> _timeoutCanceled;

		private System.Threading.Timer _timer;

		public bool IsClosed => _socket == null;

		public bool IsSecure => _secure;

		public IPEndPoint LocalEndPoint => (IPEndPoint)_socket.LocalEndPoint;

		public IPEndPoint RemoteEndPoint => (IPEndPoint)_socket.RemoteEndPoint;

		public int Reuses => _reuses;

		public Stream Stream => _stream;

		internal HttpConnection(Socket socket, EndPointListener listener)
		{
			_socket = socket;
			_listener = listener;
			_secure = listener.IsSecure;
			NetworkStream networkStream = new NetworkStream(socket, ownsSocket: false);
			if (_secure)
			{
				ServerSslConfiguration sslConfiguration = listener.SslConfiguration;
				SslStream sslStream = new SslStream(networkStream, leaveInnerStreamOpen: false, sslConfiguration.ClientCertificateValidationCallback);
				sslStream.AuthenticateAsServer(sslConfiguration.ServerCertificate, sslConfiguration.ClientCertificateRequired, sslConfiguration.EnabledSslProtocols, sslConfiguration.CheckCertificateRevocation);
				_stream = sslStream;
			}
			else
			{
				_stream = networkStream;
			}
			_sync = new object();
			_timeout = 90000;
			_timeoutCanceled = new Dictionary<int, bool>();
			_timer = new System.Threading.Timer(onTimeout, this, -1, -1);
			init();
		}

		private void close()
		{
			lock (_sync)
			{
				if (_socket == null)
				{
					return;
				}
				disposeTimer();
				disposeRequestBuffer();
				disposeStream();
				closeSocket();
			}
			unregisterContext();
			removeConnection();
		}

		private void closeSocket()
		{
			try
			{
				_socket.Shutdown(SocketShutdown.Both);
			}
			catch
			{
			}
			_socket.Close();
			_socket = null;
		}

		private void disposeRequestBuffer()
		{
			if (_requestBuffer != null)
			{
				_requestBuffer.Dispose();
				_requestBuffer = null;
			}
		}

		private void disposeStream()
		{
			if (_stream != null)
			{
				_inputStream = null;
				_outputStream = null;
				_stream.Dispose();
				_stream = null;
			}
		}

		private void disposeTimer()
		{
			if (_timer != null)
			{
				try
				{
					_timer.Change(-1, -1);
				}
				catch
				{
				}
				_timer.Dispose();
				_timer = null;
			}
		}

		private void init()
		{
			_context = new HttpListenerContext(this);
			_inputState = InputState.RequestLine;
			_inputStream = null;
			_lineState = LineState.None;
			_outputStream = null;
			_position = 0;
			_requestBuffer = new MemoryStream();
		}

		private static void onRead(IAsyncResult asyncResult)
		{
			HttpConnection httpConnection = (HttpConnection)asyncResult.AsyncState;
			if (httpConnection._socket == null)
			{
				return;
			}
			lock (httpConnection._sync)
			{
				if (httpConnection._socket == null)
				{
					return;
				}
				int num = -1;
				int num2 = 0;
				try
				{
					int reuses = httpConnection._reuses;
					if (!httpConnection._timeoutCanceled[reuses])
					{
						httpConnection._timer.Change(-1, -1);
						httpConnection._timeoutCanceled[reuses] = true;
					}
					num = httpConnection._stream.EndRead(asyncResult);
					httpConnection._requestBuffer.Write(httpConnection._buffer, 0, num);
					num2 = (int)httpConnection._requestBuffer.Length;
				}
				catch (Exception ex)
				{
					if (httpConnection._requestBuffer != null && httpConnection._requestBuffer.Length > 0)
					{
						httpConnection.SendError(ex.Message, 400);
					}
					else
					{
						httpConnection.close();
					}
					return;
				}
				if (num <= 0)
				{
					httpConnection.close();
				}
				else if (httpConnection.processInput(httpConnection._requestBuffer.GetBuffer(), num2))
				{
					if (!httpConnection._context.HasError)
					{
						httpConnection._context.Request.FinishInitialization();
					}
					if (httpConnection._context.HasError)
					{
						httpConnection.SendError();
						return;
					}
					if (!httpConnection._listener.TrySearchHttpListener(httpConnection._context.Request.Url, out var listener))
					{
						httpConnection.SendError(null, 404);
						return;
					}
					if (httpConnection._lastListener != listener)
					{
						httpConnection.removeConnection();
						if (!listener.AddConnection(httpConnection))
						{
							httpConnection.close();
							return;
						}
						httpConnection._lastListener = listener;
					}
					httpConnection._context.Listener = listener;
					if (httpConnection._context.Authenticate() && httpConnection._context.Register())
					{
						httpConnection._contextRegistered = true;
					}
				}
				else
				{
					httpConnection._stream.BeginRead(httpConnection._buffer, 0, 8192, onRead, httpConnection);
				}
			}
		}

		private static void onTimeout(object state)
		{
			HttpConnection httpConnection = (HttpConnection)state;
			int reuses = httpConnection._reuses;
			if (httpConnection._socket == null)
			{
				return;
			}
			lock (httpConnection._sync)
			{
				if (httpConnection._socket != null && !httpConnection._timeoutCanceled[reuses])
				{
					httpConnection.SendError(null, 408);
				}
			}
		}

		private bool processInput(byte[] data, int length)
		{
			if (_currentLine == null)
			{
				_currentLine = new StringBuilder(64);
			}
			int read = 0;
			try
			{
				string text;
				while ((text = readLineFrom(data, _position, length, out read)) != null)
				{
					_position += read;
					if (text.Length == 0)
					{
						if (_inputState != InputState.RequestLine)
						{
							if (_position > 32768)
							{
								_context.ErrorMessage = "Headers too long";
							}
							_currentLine = null;
							return true;
						}
					}
					else
					{
						if (_inputState == InputState.RequestLine)
						{
							_context.Request.SetRequestLine(text);
							_inputState = InputState.Headers;
						}
						else
						{
							_context.Request.AddHeader(text);
						}
						if (_context.HasError)
						{
							return true;
						}
					}
				}
			}
			catch (Exception ex)
			{
				_context.ErrorMessage = ex.Message;
				return true;
			}
			_position += read;
			if (_position >= 32768)
			{
				_context.ErrorMessage = "Headers too long";
				return true;
			}
			return false;
		}

		private string readLineFrom(byte[] buffer, int offset, int length, out int read)
		{
			read = 0;
			for (int i = offset; i < length; i++)
			{
				if (_lineState == LineState.Lf)
				{
					break;
				}
				read++;
				byte b = buffer[i];
				switch (b)
				{
				case 13:
					_lineState = LineState.Cr;
					break;
				case 10:
					_lineState = LineState.Lf;
					break;
				default:
					_currentLine.Append((char)b);
					break;
				}
			}
			if (_lineState != LineState.Lf)
			{
				return null;
			}
			string result = _currentLine.ToString();
			_currentLine.Length = 0;
			_lineState = LineState.None;
			return result;
		}

		private void removeConnection()
		{
			if (_lastListener != null)
			{
				_lastListener.RemoveConnection(this);
			}
			else
			{
				_listener.RemoveConnection(this);
			}
		}

		private void unregisterContext()
		{
			if (_contextRegistered)
			{
				_context.Unregister();
				_contextRegistered = false;
			}
		}

		internal void Close(bool force)
		{
			if (_socket == null)
			{
				return;
			}
			lock (_sync)
			{
				if (_socket == null)
				{
					return;
				}
				if (!force)
				{
					GetResponseStream().Close(force: false);
					if (!_context.Response.CloseConnection && _context.Request.FlushInput())
					{
						_reuses++;
						disposeRequestBuffer();
						unregisterContext();
						init();
						BeginReadRequest();
						return;
					}
				}
				else if (_outputStream != null)
				{
					_outputStream.Close(force: true);
				}
				close();
			}
		}

		public void BeginReadRequest()
		{
			if (_buffer == null)
			{
				_buffer = new byte[8192];
			}
			if (_reuses == 1)
			{
				_timeout = 15000;
			}
			try
			{
				_timeoutCanceled.Add(_reuses, value: false);
				_timer.Change(_timeout, -1);
				_stream.BeginRead(_buffer, 0, 8192, onRead, this);
			}
			catch
			{
				close();
			}
		}

		public void Close()
		{
			Close(force: false);
		}

		public RequestStream GetRequestStream(long contentLength, bool chunked)
		{
			if (_inputStream != null || _socket == null)
			{
				return _inputStream;
			}
			lock (_sync)
			{
				if (_socket == null)
				{
					return _inputStream;
				}
				byte[] buffer = _requestBuffer.GetBuffer();
				int num = (int)_requestBuffer.Length;
				disposeRequestBuffer();
				if (chunked)
				{
					_context.Response.SendChunked = true;
					_inputStream = new ChunkedRequestStream(_stream, buffer, _position, num - _position, _context);
				}
				else
				{
					_inputStream = new RequestStream(_stream, buffer, _position, num - _position, contentLength);
				}
				return _inputStream;
			}
		}

		public ResponseStream GetResponseStream()
		{
			if (_outputStream != null || _socket == null)
			{
				return _outputStream;
			}
			lock (_sync)
			{
				if (_socket == null)
				{
					return _outputStream;
				}
				bool ignoreWriteExceptions = _context.Listener?.IgnoreWriteExceptions ?? true;
				_outputStream = new ResponseStream(_stream, _context.Response, ignoreWriteExceptions);
				return _outputStream;
			}
		}

		public void SendError()
		{
			SendError(_context.ErrorMessage, _context.ErrorStatus);
		}

		public void SendError(string message, int status)
		{
			if (_socket == null)
			{
				return;
			}
			lock (_sync)
			{
				if (_socket == null)
				{
					return;
				}
				try
				{
					HttpListenerResponse response = _context.Response;
					response.StatusCode = status;
					response.ContentType = "text/html";
					StringBuilder stringBuilder = new StringBuilder(64);
					stringBuilder.AppendFormat("<html><body><h1>{0} {1}", status, response.StatusDescription);
					if (message != null && message.Length > 0)
					{
						stringBuilder.AppendFormat(" ({0})</h1></body></html>", message);
					}
					else
					{
						stringBuilder.Append("</h1></body></html>");
					}
					Encoding uTF = Encoding.UTF8;
					byte[] bytes = uTF.GetBytes(stringBuilder.ToString());
					response.ContentEncoding = uTF;
					response.ContentLength64 = bytes.LongLength;
					response.Close(bytes, willBlock: true);
				}
				catch
				{
					Close(force: true);
				}
			}
		}
	}
	public sealed class HttpListener : IDisposable
	{
		private AuthenticationSchemes _authSchemes;

		private Func<HttpListenerRequest, AuthenticationSchemes> _authSchemeSelector;

		private string _certFolderPath;

		private Dictionary<HttpConnection, HttpConnection> _connections;

		private object _connectionsSync;

		private List<HttpListenerContext> _ctxQueue;

		private object _ctxQueueSync;

		private Dictionary<HttpListenerContext, HttpListenerContext> _ctxRegistry;

		private object _ctxRegistrySync;

		private static readonly string _defaultRealm;

		private bool _disposed;

		private bool _ignoreWriteExceptions;

		private volatile bool _listening;

		private Logger _logger;

		private HttpListenerPrefixCollection _prefixes;

		private string _realm;

		private bool _reuseAddress;

		private ServerSslConfiguration _sslConfig;

		private Func<IIdentity, NetworkCredential> _userCredFinder;

		private List<HttpListenerAsyncResult> _waitQueue;

		private object _waitQueueSync;

		internal bool IsDisposed => _disposed;

		internal bool ReuseAddress
		{
			get
			{
				return _reuseAddress;
			}
			set
			{
				_reuseAddress = value;
			}
		}

		public AuthenticationSchemes AuthenticationSchemes
		{
			get
			{
				CheckDisposed();
				return _authSchemes;
			}
			set
			{
				CheckDisposed();
				_authSchemes = value;
			}
		}

		public Func<HttpListenerRequest, AuthenticationSchemes> AuthenticationSchemeSelector
		{
			get
			{
				CheckDisposed();
				return _authSchemeSelector;
			}
			set
			{
				CheckDisposed();
				_authSchemeSelector = value;
			}
		}

		public string CertificateFolderPath
		{
			get
			{
				CheckDisposed();
				return _certFolderPath;
			}
			set
			{
				CheckDisposed();
				_certFolderPath = value;
			}
		}

		public bool IgnoreWriteExceptions
		{
			get
			{
				CheckDisposed();
				return _ignoreWriteExceptions;
			}
			set
			{
				CheckDisposed();
				_ignoreWriteExceptions = value;
			}
		}

		public bool IsListening => _listening;

		public static bool IsSupported => true;

		public Logger Log => _logger;

		public HttpListenerPrefixCollection Prefixes
		{
			get
			{
				CheckDisposed();
				return _prefixes;
			}
		}

		public string Realm
		{
			get
			{
				CheckDisposed();
				return _realm;
			}
			set
			{
				CheckDisposed();
				_realm = value;
			}
		}

		public ServerSslConfiguration SslConfiguration
		{
			get
			{
				CheckDisposed();
				return _sslConfig ?? (_sslConfig = new ServerSslConfiguration(null));
			}
			set
			{
				CheckDisposed();
				_sslConfig = value;
			}
		}

		public bool UnsafeConnectionNtlmAuthentication
		{
			get
			{
				throw new NotSupportedException();
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public Func<IIdentity, NetworkCredential> UserCredentialsFinder
		{
			get
			{
				CheckDisposed();
				return _userCredFinder;
			}
			set
			{
				CheckDisposed();
				_userCredFinder = value;
			}
		}

		static HttpListener()
		{
			_defaultRealm = "SECRET AREA";
		}

		public HttpListener()
		{
			_authSchemes = AuthenticationSchemes.Anonymous;
			_connections = new Dictionary<HttpConnection, HttpConnection>();
			_connectionsSync = ((ICollection)_connections).SyncRoot;
			_ctxQueue = new List<HttpListenerContext>();
			_ctxQueueSync = ((ICollection)_ctxQueue).SyncRoot;
			_ctxRegistry = new Dictionary<HttpListenerContext, HttpListenerContext>();
			_ctxRegistrySync = ((ICollection)_ctxRegistry).SyncRoot;
			_logger = new Logger();
			_prefixes = new HttpListenerPrefixCollection(this);
			_waitQueue = new List<HttpListenerAsyncResult>();
			_waitQueueSync = ((ICollection)_waitQueue).SyncRoot;
		}

		private void cleanupConnections()
		{
			HttpConnection[] array = null;
			lock (_connectionsSync)
			{
				if (_connections.Count == 0)
				{
					return;
				}
				Dictionary<HttpConnection, HttpConnection>.KeyCollection keys = _connections.Keys;
				array = new HttpConnection[keys.Count];
				keys.CopyTo(array, 0);
				_connections.Clear();
			}
			for (int num = array.Length - 1; num >= 0; num--)
			{
				array[num].Close(force: true);
			}
		}

		private void cleanupContextQueue(bool sendServiceUnavailable)
		{
			HttpListenerContext[] array = null;
			lock (_ctxQueueSync)
			{
				if (_ctxQueue.Count == 0)
				{
					return;
				}
				array = _ctxQueue.ToArray();
				_ctxQueue.Clear();
			}
			if (sendServiceUnavailable)
			{
				HttpListenerContext[] array2 = array;
				foreach (HttpListenerContext httpListenerContext in array2)
				{
					HttpListenerResponse response = httpListenerContext.Response;
					response.StatusCode = 503;
					response.Close();
				}
			}
		}

		private void cleanupContextRegistry()
		{
			HttpListenerContext[] array = null;
			lock (_ctxRegistrySync)
			{
				if (_ctxRegistry.Count == 0)
				{
					return;
				}
				Dictionary<HttpListenerContext, HttpListenerContext>.KeyCollection keys = _ctxRegistry.Keys;
				array = new HttpListenerContext[keys.Count];
				keys.CopyTo(array, 0);
				_ctxRegistry.Clear();
			}
			for (int num = array.Length - 1; num >= 0; num--)
			{
				array[num].Connection.Close(force: true);
			}
		}

		private void cleanupWaitQueue(Exception exception)
		{
			HttpListenerAsyncResult[] array = null;
			lock (_waitQueueSync)
			{
				if (_waitQueue.Count == 0)
				{
					return;
				}
				array = _waitQueue.ToArray();
				_waitQueue.Clear();
			}
			HttpListenerAsyncResult[] array2 = array;
			foreach (HttpListenerAsyncResult httpListenerAsyncResult in array2)
			{
				httpListenerAsyncResult.Complete(exception);
			}
		}

		private void close(bool force)
		{
			if (_listening)
			{
				_listening = false;
				EndPointManager.RemoveListener(this);
			}
			lock (_ctxRegistrySync)
			{
				cleanupContextQueue(!force);
			}
			cleanupContextRegistry();
			cleanupConnections();
			cleanupWaitQueue(new ObjectDisposedException(GetType().ToString()));
			_disposed = true;
		}

		private HttpListenerAsyncResult getAsyncResultFromQueue()
		{
			if (_waitQueue.Count == 0)
			{
				return null;
			}
			HttpListenerAsyncResult result = _waitQueue[0];
			_waitQueue.RemoveAt(0);
			return result;
		}

		private HttpListenerContext getContextFromQueue()
		{
			if (_ctxQueue.Count == 0)
			{
				return null;
			}
			HttpListenerContext result = _ctxQueue[0];
			_ctxQueue.RemoveAt(0);
			return result;
		}

		internal bool AddConnection(HttpConnection connection)
		{
			if (!_listening)
			{
				return false;
			}
			lock (_connectionsSync)
			{
				if (!_listening)
				{
					return false;
				}
				_connections[connection] = connection;
				return true;
			}
		}

		internal HttpListenerAsyncResult BeginGetContext(HttpListenerAsyncResult asyncResult)
		{
			lock (_ctxRegistrySync)
			{
				if (!_listening)
				{
					throw new HttpListenerException(995);
				}
				HttpListenerContext contextFromQueue = getContextFromQueue();
				if (contextFromQueue == null)
				{
					_waitQueue.Add(asyncResult);
				}
				else
				{
					asyncResult.Complete(contextFromQueue, syncCompleted: true);
				}
				return asyncResult;
			}
		}

		internal void CheckDisposed()
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
		}

		internal string GetRealm()
		{
			string realm = _realm;
			return (realm != null && realm.Length > 0) ? realm : _defaultRealm;
		}

		internal Func<IIdentity, NetworkCredential> GetUserCredentialsFinder()
		{
			return _userCredFinder;
		}

		internal bool RegisterContext(HttpListenerContext context)
		{
			if (!_listening)
			{
				return false;
			}
			lock (_ctxRegistrySync)
			{
				if (!_listening)
				{
					return false;
				}
				_ctxRegistry[context] = context;
				HttpListenerAsyncResult asyncResultFromQueue = getAsyncResultFromQueue();
				if (asyncResultFromQueue == null)
				{
					_ctxQueue.Add(context);
				}
				else
				{
					asyncResultFromQueue.Complete(context);
				}
				return true;
			}
		}

		internal void RemoveConnection(HttpConnection connection)
		{
			lock (_connectionsSync)
			{
				_connections.Remove(connection);
			}
		}

		internal AuthenticationSchemes SelectAuthenticationScheme(HttpListenerRequest request)
		{
			Func<HttpListenerRequest, AuthenticationSchemes> authSchemeSelector = _authSchemeSelector;
			if (authSchemeSelector == null)
			{
				return _authSchemes;
			}
			try
			{
				return authSchemeSelector(request);
			}
			catch
			{
				return AuthenticationSchemes.None;
			}
		}

		internal void UnregisterContext(HttpListenerContext context)
		{
			lock (_ctxRegistrySync)
			{
				_ctxRegistry.Remove(context);
			}
		}

		public void Abort()
		{
			if (!_disposed)
			{
				close(force: true);
			}
		}

		public IAsyncResult BeginGetContext(AsyncCallback callback, object state)
		{
			CheckDisposed();
			if (_prefixes.Count == 0)
			{
				throw new InvalidOperationException("The listener has no URI prefix on which listens.");
			}
			if (!_listening)
			{
				throw new InvalidOperationException("The listener hasn't been started.");
			}
			return BeginGetContext(new HttpListenerAsyncResult(callback, state));
		}

		public void Close()
		{
			if (!_disposed)
			{
				close(force: false);
			}
		}

		public HttpListenerContext EndGetContext(IAsyncResult asyncResult)
		{
			CheckDisposed();
			if (asyncResult == null)
			{
				throw new ArgumentNullException("asyncResult");
			}
			if (!(asyncResult is HttpListenerAsyncResult httpListenerAsyncResult))
			{
				throw new ArgumentException("A wrong IAsyncResult.", "asyncResult");
			}
			if (httpListenerAsyncResult.EndCalled)
			{
				throw new InvalidOperationException("This IAsyncResult cannot be reused.");
			}
			httpListenerAsyncResult.EndCalled = true;
			if (!httpListenerAsyncResult.IsCompleted)
			{
				httpListenerAsyncResult.AsyncWaitHandle.WaitOne();
			}
			return httpListenerAsyncResult.GetContext();
		}

		public HttpListenerContext GetContext()
		{
			CheckDisposed();
			if (_prefixes.Count == 0)
			{
				throw new InvalidOperationException("The listener has no URI prefix on which listens.");
			}
			if (!_listening)
			{
				throw new InvalidOperationException("The listener hasn't been started.");
			}
			HttpListenerAsyncResult httpListenerAsyncResult = BeginGetContext(new HttpListenerAsyncResult(null, null));
			httpListenerAsyncResult.InGet = true;
			return EndGetContext(httpListenerAsyncResult);
		}

		public void Start()
		{
			CheckDisposed();
			if (!_listening)
			{
				EndPointManager.AddListener(this);
				_listening = true;
			}
		}

		public void Stop()
		{
			CheckDisposed();
			if (_listening)
			{
				_listening = false;
				EndPointManager.RemoveListener(this);
				lock (_ctxRegistrySync)
				{
					cleanupContextQueue(sendServiceUnavailable: true);
				}
				cleanupContextRegistry();
				cleanupConnections();
				cleanupWaitQueue(new HttpListenerException(995, "The listener is stopped."));
			}
		}

		void IDisposable.Dispose()
		{
			if (!_disposed)
			{
				close(force: true);
			}
		}
	}
	public sealed class HttpListenerContext
	{
		private HttpConnection _connection;

		private string _error;

		private int _errorStatus;

		private HttpListener _listener;

		private HttpListenerRequest _request;

		private HttpListenerResponse _response;

		private IPrincipal _user;

		private HttpListenerWebSocketContext _websocketContext;

		internal HttpConnection Connection => _connection;

		internal string ErrorMessage
		{
			get
			{
				return _error;
			}
			set
			{
				_error = value;
			}
		}

		internal int ErrorStatus
		{
			get
			{
				return _errorStatus;
			}
			set
			{
				_errorStatus = value;
			}
		}

		internal bool HasError => _error != null;

		internal HttpListener Listener
		{
			get
			{
				return _listener;
			}
			set
			{
				_listener = value;
			}
		}

		public HttpListenerRequest Request => _request;

		public HttpListenerResponse Response => _response;

		public IPrincipal User => _user;

		internal HttpListenerContext(HttpConnection connection)
		{
			_connection = connection;
			_errorStatus = 400;
			_request = new HttpListenerRequest(this);
			_response = new HttpListenerResponse(this);
		}

		internal bool Authenticate()
		{
			AuthenticationSchemes authenticationSchemes = _listener.SelectAuthenticationScheme(_request);
			switch (authenticationSchemes)
			{
			case AuthenticationSchemes.Anonymous:
				return true;
			case AuthenticationSchemes.None:
				_response.Close(HttpStatusCode.Forbidden);
				return false;
			default:
			{
				string realm = _listener.GetRealm();
				IPrincipal principal = HttpUtility.CreateUser(_request.Headers["Authorization"], authenticationSchemes, realm, _request.HttpMethod, _listener.GetUserCredentialsFinder());
				if (principal == null || !principal.Identity.IsAuthenticated)
				{
					_response.CloseWithAuthChallenge(new AuthenticationChallenge(authenticationSchemes, realm).ToString());
					return false;
				}
				_user = principal;
				return true;
			}
			}
		}

		internal bool Register()
		{
			return _listener.RegisterContext(this);
		}

		internal void Unregister()
		{
			_listener.UnregisterContext(this);
		}

		public HttpListenerWebSocketContext AcceptWebSocket(string protocol)
		{
			if (_websocketContext != null)
			{
				throw new InvalidOperationException("The accepting is already in progress.");
			}
			if (protocol != null)
			{
				if (protocol.Length == 0)
				{
					throw new ArgumentException("An empty string.", "protocol");
				}
				if (!protocol.IsToken())
				{
					throw new ArgumentException("Contains an invalid character.", "protocol");
				}
			}
			_websocketContext = new HttpListenerWebSocketContext(this, protocol);
			return _websocketContext;
		}
	}
	[Serializable]
	public class HttpListenerException : Win32Exception
	{
		public override int ErrorCode => base.NativeErrorCode;

		protected HttpListenerException(SerializationInfo serializationInfo, StreamingContext streamingContext)
			: base(serializationInfo, streamingContext)
		{
		}

		public HttpListenerException()
		{
		}

		public HttpListenerException(int errorCode)
			: base(errorCode)
		{
		}

		public HttpListenerException(int errorCode, string message)
			: base(errorCode, message)
		{
		}
	}
	public class HttpListenerPrefixCollection : ICollection<string>, IEnumerable<string>, IEnumerable
	{
		private HttpListener _listener;

		private List<string> _prefixes;

		public int Count => _prefixes.Count;

		public bool IsReadOnly => false;

		public bool IsSynchronized => false;

		internal HttpListenerPrefixCollection(HttpListener listener)
		{
			_listener = listener;
			_prefixes = new List<string>();
		}

		public void Add(string uriPrefix)
		{
			_listener.CheckDisposed();
			HttpListenerPrefix.CheckPrefix(uriPrefix);
			if (!_prefixes.Contains(uriPrefix))
			{
				_prefixes.Add(uriPrefix);
				if (_listener.IsListening)
				{
					EndPointManager.AddPrefix(uriPrefix, _listener);
				}
			}
		}

		public void Clear()
		{
			_listener.CheckDisposed();
			_prefixes.Clear();
			if (_listener.IsListening)
			{
				EndPointManager.RemoveListener(_listener);
			}
		}

		public bool Contains(string uriPrefix)
		{
			_listener.CheckDisposed();
			if (uriPrefix == null)
			{
				throw new ArgumentNullException("uriPrefix");
			}
			return _prefixes.Contains(uriPrefix);
		}

		public void CopyTo(Array array, int offset)
		{
			_listener.CheckDisposed();
			((ICollection)_prefixes).CopyTo(array, offset);
		}

		public void CopyTo(string[] array, int offset)
		{
			_listener.CheckDisposed();
			_prefixes.CopyTo(array, offset);
		}

		public IEnumerator<string> GetEnumerator()
		{
			return _prefixes.GetEnumerator();
		}

		public bool Remove(string uriPrefix)
		{
			_listener.CheckDisposed();
			if (uriPrefix == null)
			{
				throw new ArgumentNullException("uriPrefix");
			}
			bool flag = _prefixes.Remove(uriPrefix);
			if (flag && _listener.IsListening)
			{
				EndPointManager.RemovePrefix(uriPrefix, _listener);
			}
			return flag;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return _prefixes.GetEnumerator();
		}
	}
	public sealed class HttpListenerRequest
	{
		private static readonly byte[] _100continue;

		private string[] _acceptTypes;

		private bool _chunked;

		private Encoding _contentEncoding;

		private long _contentLength;

		private bool _contentLengthSet;

		private HttpListenerContext _context;

		private CookieCollection _cookies;

		private WebHeaderCollection _headers;

		private Guid _identifier;

		private Stream _inputStream;

		private bool _keepAlive;

		private bool _keepAliveSet;

		private string _method;

		private NameValueCollection _queryString;

		private Uri _referer;

		private string _uri;

		private Uri _url;

		private string[] _userLanguages;

		private Version _version;

		private bool _websocketRequest;

		private bool _websocketRequestSet;

		public string[] AcceptTypes => _acceptTypes;

		public int ClientCertificateError => 0;

		public Encoding ContentEncoding => _contentEncoding ?? (_contentEncoding = Encoding.Default);

		public long ContentLength64 => _contentLength;

		public string ContentType => _headers["Content-Type"];

		public CookieCollection Cookies => _cookies ?? (_cookies = _headers.GetCookies(response: false));

		public bool HasEntityBody => _contentLength > 0 || _chunked;

		public NameValueCollection Headers => _headers;

		public string HttpMethod => _method;

		public Stream InputStream => _inputStream ?? (_inputStream = (HasEntityBody ? _context.Connection.GetRequestStream(_contentLength, _chunked) : Stream.Null));

		public bool IsAuthenticated => _context.User != null;

		public bool IsLocal => RemoteEndPoint.Address.IsLocal();

		public bool IsSecureConnection => _context.Connection.IsSecure;

		public bool IsWebSocketRequest
		{
			get
			{
				if (!_websocketRequestSet)
				{
					_websocketRequest = _method == "GET" && _version > HttpVersion.Version10 && _headers.Contains("Upgrade", "websocket") && _headers.Contains("Connection", "Upgrade");
					_websocketRequestSet = true;
				}
				return _websocketRequest;
			}
		}

		public bool KeepAlive
		{
			get
			{
				if (!_keepAliveSet)
				{
					string text;
					_keepAlive = _version > HttpVersion.Version10 || _headers.Contains("Connection", "keep-alive") || ((text = _headers["Keep-Alive"]) != null && text != "closed");
					_keepAliveSet = true;
				}
				return _keepAlive;
			}
		}

		public IPEndPoint LocalEndPoint => _context.Connection.LocalEndPoint;

		public Version ProtocolVersion => _version;

		public NameValueCollection QueryString => _queryString ?? (_queryString = HttpUtility.InternalParseQueryString(_url.Query, Encoding.UTF8));

		public string RawUrl => _url.PathAndQuery;

		public IPEndPoint RemoteEndPoint => _context.Connection.RemoteEndPoint;

		public Guid RequestTraceIdentifier => _identifier;

		public Uri Url => _url;

		public Uri UrlReferrer => _referer;

		public string UserAgent => _headers["User-Agent"];

		public string UserHostAddress => LocalEndPoint.ToString();

		public string UserHostName => _headers["Host"];

		public string[] UserLanguages => _userLanguages;

		static HttpListenerRequest()
		{
			_100continue = Encoding.ASCII.GetBytes("HTTP/1.1 100 Continue\r\n\r\n");
		}

		internal HttpListenerRequest(HttpListenerContext context)
		{
			_context = context;
			_contentLength = -1L;
			_headers = new WebHeaderCollection();
			_identifier = Guid.NewGuid();
		}

		private static bool tryCreateVersion(string version, out Version result)
		{
			try
			{
				result = new Version(version);
				return true;
			}
			catch
			{
				result = null;
				return false;
			}
		}

		internal void AddHeader(string header)
		{
			int num = header.IndexOf(':');
			if (num == -1)
			{
				_context.ErrorMessage = "Invalid header";
				return;
			}
			string text = header.Substring(0, num).Trim();
			string text2 = header.Substring(num + 1).Trim();
			_headers.InternalSet(text, text2, response: false);
			switch (text.ToLower(CultureInfo.InvariantCulture))
			{
			case "accept":
				_acceptTypes = new List<string>(text2.SplitHeaderValue(',')).ToArray();
				break;
			case "accept-language":
				_userLanguages = text2.Split(new char[1] { ',' });
				break;
			case "content-length":
			{
				if (long.TryParse(text2, out var result) && result >= 0)
				{
					_contentLength = result;
					_contentLengthSet = true;
				}
				else
				{
					_context.ErrorMessage = "Invalid Content-Length header";
				}
				break;
			}
			case "content-type":
				try
				{
					_contentEncoding = HttpUtility.GetEncoding(text2);
					break;
				}
				catch
				{
					_context.ErrorMessage = "Invalid Content-Type header";
					break;
				}
			case "referer":
				_referer = text2.ToUri();
				break;
			}
		}

		internal void FinishInitialization()
		{
			string text = _headers["Host"];
			bool flag = text == null || text.Length == 0;
			if (_version > HttpVersion.Version10 && flag)
			{
				_context.ErrorMessage = "Invalid Host header";
				return;
			}
			if (flag)
			{
				text = UserHostAddress;
			}
			_url = HttpUtility.CreateRequestUrl(_uri, text, IsWebSocketRequest, IsSecureConnection);
			if (_url == null)
			{
				_context.ErrorMessage = "Invalid request url";
				return;
			}
			string text2 = Headers["Transfer-Encoding"];
			if (_version > HttpVersion.Version10 && text2 != null && text2.Length > 0)
			{
				_chunked = text2.ToLower() == "chunked";
				if (!_chunked)
				{
					_context.ErrorMessage = string.Empty;
					_context.ErrorStatus = 501;
					return;
				}
			}
			if (!_chunked && !_contentLengthSet)
			{
				string text3 = _method.ToLower();
				if (text3 == "post" || text3 == "put")
				{
					_context.ErrorMessage = string.Empty;
					_context.ErrorStatus = 411;
					return;
				}
			}
			string text4 = Headers["Expect"];
			if (text4 != null && text4.Length > 0 && text4.ToLower() == "100-continue")
			{
				ResponseStream responseStream = _context.Connection.GetResponseStream();
				responseStream.InternalWrite(_100continue, 0, _100continue.Length);
			}
		}

		internal bool FlushInput()
		{
			if (!HasEntityBody)
			{
				return true;
			}
			int num = 2048;
			if (_contentLength > 0)
			{
				num = (int)Math.Min(_contentLength, num);
			}
			byte[] buffer = new byte[num];
			while (true)
			{
				try
				{
					IAsyncResult asyncResult = InputStream.BeginRead(buffer, 0, num, null, null);
					if (!asyncResult.IsCompleted && !asyncResult.AsyncWaitHandle.WaitOne(100))
					{
						return false;
					}
					if (InputStream.EndRead(asyncResult) <= 0)
					{
						return true;
					}
				}
				catch
				{
					return false;
				}
			}
		}

		internal void SetRequestLine(string requestLine)
		{
			string[] array = requestLine.Split(new char[1] { ' ' }, 3);
			if (array.Length != 3)
			{
				_context.ErrorMessage = "Invalid request line (parts)";
				return;
			}
			_method = array[0];
			if (!_method.IsToken())
			{
				_context.ErrorMessage = "Invalid request line (method)";
				return;
			}
			_uri = array[1];
			string text = array[2];
			if (text.Length != 8 || !text.StartsWith("HTTP/") || !tryCreateVersion(text.Substring(5), out _version) || _version.Major < 1)
			{
				_context.ErrorMessage = "Invalid request line (version)";
			}
		}

		public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state)
		{
			throw new NotImplementedException();
		}

		public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult)
		{
			throw new NotImplementedException();
		}

		public X509Certificate2 GetClientCertificate()
		{
			throw new NotImplementedException();
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder(64);
			stringBuilder.AppendFormat("{0} {1} HTTP/{2}\r\n", _method, _uri, _version);
			stringBuilder.Append(_headers.ToString());
			return stringBuilder.ToString();
		}
	}
	public sealed class HttpListenerResponse : IDisposable
	{
		private bool _closeConnection;

		private Encoding _contentEncoding;

		private long _contentLength;

		private string _contentType;

		private HttpListenerContext _context;

		private CookieCollection _cookies;

		private bool _disposed;

		private WebHeaderCollection _headers;

		private bool _headersSent;

		private bool _keepAlive;

		private string _location;

		private ResponseStream _outputStream;

		private bool _sendChunked;

		private int _statusCode;

		private string _statusDescription;

		private Version _version;

		internal bool CloseConnection
		{
			get
			{
				return _closeConnection;
			}
			set
			{
				_closeConnection = value;
			}
		}

		internal bool HeadersSent
		{
			get
			{
				return _headersSent;
			}
			set
			{
				_headersSent = value;
			}
		}

		public Encoding ContentEncoding
		{
			get
			{
				return _contentEncoding;
			}
			set
			{
				checkDisposed();
				_contentEncoding = value;
			}
		}

		public long ContentLength64
		{
			get
			{
				return _contentLength;
			}
			set
			{
				checkDisposedOrHeadersSent();
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException("Less than zero.", "value");
				}
				_contentLength = value;
			}
		}

		public string ContentType
		{
			get
			{
				return _contentType;
			}
			set
			{
				checkDisposed();
				if (value != null && value.Length == 0)
				{
					throw new ArgumentException("An empty string.", "value");
				}
				_contentType = value;
			}
		}

		public CookieCollection Cookies
		{
			get
			{
				return _cookies ?? (_cookies = new CookieCollection());
			}
			set
			{
				_cookies = value;
			}
		}

		public WebHeaderCollection Headers
		{
			get
			{
				return _headers ?? (_headers = new WebHeaderCollection(HttpHeaderType.Response, internallyUsed: false));
			}
			set
			{
				if (value != null && value.State != HttpHeaderType.Response)
				{
					throw new InvalidOperationException("The specified headers aren't valid for a response.");
				}
				_headers = value;
			}
		}

		public bool KeepAlive
		{
			get
			{
				return _keepAlive;
			}
			set
			{
				checkDisposedOrHeadersSent();
				_keepAlive = value;
			}
		}

		public Stream OutputStream
		{
			get
			{
				checkDisposed();
				return _outputStream ?? (_outputStream = _context.Connection.GetResponseStream());
			}
		}

		public Version ProtocolVersion
		{
			get
			{
				return _version;
			}
			set
			{
				checkDisposedOrHeadersSent();
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				if (value.Major != 1 || (value.Minor != 0 && value.Minor != 1))
				{
					throw new ArgumentException("Not 1.0 or 1.1.", "value");
				}
				_version = value;
			}
		}

		public string RedirectLocation
		{
			get
			{
				return _location;
			}
			set
			{
				checkDisposed();
				if (value == null)
				{
					_location = null;
					return;
				}
				Uri result = null;
				if (!value.MaybeUri() || !Uri.TryCreate(value, UriKind.Absolute, out result))
				{
					throw new ArgumentException("Not an absolute URL.", "value");
				}
				_location = value;
			}
		}

		public bool SendChunked
		{
			get
			{
				return _sendChunked;
			}
			set
			{
				checkDisposedOrHeadersSent();
				_sendChunked = value;
			}
		}

		public int StatusCode
		{
			get
			{
				return _statusCode;
			}
			set
			{
				checkDisposedOrHeadersSent();
				if (value < 100 || value > 999)
				{
					throw new ProtocolViolationException("A value isn't between 100 and 999 inclusive.");
				}
				_statusCode = value;
				_statusDescription = value.GetStatusDescription();
			}
		}

		public string StatusDescription
		{
			get
			{
				return _statusDescription;
			}
			set
			{
				checkDisposedOrHeadersSent();
				if (value == null || value.Length == 0)
				{
					_statusDescription = _statusCode.GetStatusDescription();
					return;
				}
				if (!value.IsText() || value.IndexOfAny(new char[2] { '\r', '\n' }) > -1)
				{
					throw new ArgumentException("Contains invalid characters.", "value");
				}
				_statusDescription = value;
			}
		}

		internal HttpListenerResponse(HttpListenerContext context)
		{
			_context = context;
			_keepAlive = true;
			_statusCode = 200;
			_statusDescription = "OK";
			_version = HttpVersion.Version11;
		}

		private bool canAddOrUpdate(Cookie cookie)
		{
			if (_cookies == null || _cookies.Count == 0)
			{
				return true;
			}
			List<Cookie> list = findCookie(cookie).ToList();
			if (list.Count == 0)
			{
				return true;
			}
			int version = cookie.Version;
			foreach (Cookie item in list)
			{
				if (item.Version == version)
				{
					return true;
				}
			}
			return false;
		}

		private void checkDisposed()
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
		}

		private void checkDisposedOrHeadersSent()
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			if (_headersSent)
			{
				throw new InvalidOperationException("Cannot be changed after the headers are sent.");
			}
		}

		private void close(bool force)
		{
			_disposed = true;
			_context.Connection.Close(force);
		}

		private IEnumerable<Cookie> findCookie(Cookie cookie)
		{
			string name = cookie.Name;
			string domain = cookie.Domain;
			string path = cookie.Path;
			if (_cookies == null)
			{
				yield break;
			}
			foreach (Cookie c in _cookies)
			{
				if (c.Name.Equals(name, StringComparison.OrdinalIgnoreCase) && c.Domain.Equals(domain, StringComparison.OrdinalIgnoreCase) && c.Path.Equals(path, StringComparison.Ordinal))
				{
					yield return c;
				}
			}
		}

		internal WebHeaderCollection WriteHeadersTo(MemoryStream destination)
		{
			WebHeaderCollection webHeaderCollection = new WebHeaderCollection(HttpHeaderType.Response, internallyUsed: true);
			if (_headers != null)
			{
				webHeaderCollection.Add(_headers);
			}
			if (_contentType != null)
			{
				string value = ((_contentType.IndexOf("charset=", StringComparison.Ordinal) == -1 && _contentEncoding != null) ? $"{_contentType}; charset={_contentEncoding.WebName}" : _contentType);
				webHeaderCollection.InternalSet("Content-Type", value, response: true);
			}
			if (webHeaderCollection["Server"] == null)
			{
				webHeaderCollection.InternalSet("Server", "websocket-sharp/1.0", response: true);
			}
			CultureInfo invariantCulture = CultureInfo.InvariantCulture;
			if (webHeaderCollection["Date"] == null)
			{
				webHeaderCollection.InternalSet("Date", DateTime.UtcNow.ToString("r", invariantCulture), response: true);
			}
			if (!_sendChunked)
			{
				webHeaderCollection.InternalSet("Content-Length", _contentLength.ToString(invariantCulture), response: true);
			}
			else
			{
				webHeaderCollection.InternalSet("Transfer-Encoding", "chunked", response: true);
			}
			bool flag = !_context.Request.KeepAlive || !_keepAlive || _statusCode == 400 || _statusCode == 408 || _statusCode == 411 || _statusCode == 413 || _statusCode == 414 || _statusCode == 500 || _statusCode == 503;
			int reuses = _context.Connection.Reuses;
			if (flag || reuses >= 100)
			{
				webHeaderCollection.InternalSet("Connection", "close", response: true);
			}
			else
			{
				webHeaderCollection.InternalSet("Keep-Alive", $"timeout=15,max={100 - reuses}", response: true);
				if (_context.Request.ProtocolVersion < HttpVersion.Version11)
				{
					webHeaderCollection.InternalSet("Connection", "keep-alive", response: true);
				}
			}
			if (_location != null)
			{
				webHeaderCollection.InternalSet("Location", _location, response: true);
			}
			if (_cookies != null)
			{
				foreach (Cookie cookie in _cookies)
				{
					webHeaderCollection.InternalSet("Set-Cookie", cookie.ToResponseString(), response: true);
				}
			}
			Encoding encoding = _contentEncoding ?? Encoding.Default;
			StreamWriter streamWriter = new StreamWriter(destination, encoding, 256);
			streamWriter.Write("HTTP/{0} {1} {2}\r\n", _version, _statusCode, _statusDescription);
			streamWriter.Write(webHeaderCollection.ToStringMultiValue(response: true));
			streamWriter.Flush();
			destination.Position = encoding.GetPreamble().Length;
			return webHeaderCollection;
		}

		public void Abort()
		{
			if (!_disposed)
			{
				close(force: true);
			}
		}

		public void AddHeader(string name, string value)
		{
			Headers.Set(name, value);
		}

		public void AppendCookie(Cookie cookie)
		{
			Cookies.Add(cookie);
		}

		public void AppendHeader(string name, string value)
		{
			Headers.Add(name, value);
		}

		public void Close()
		{
			if (!_disposed)
			{
				close(force: false);
			}
		}

		public void Close(byte[] responseEntity, bool willBlock)
		{
			checkDisposed();
			if (responseEntity == null)
			{
				throw new ArgumentNullException("responseEntity");
			}
			int count = responseEntity.Length;
			Stream output = OutputStream;
			if (willBlock)
			{
				output.Write(responseEntity, 0, count);
				close(force: false);
				return;
			}
			output.BeginWrite(responseEntity, 0, count, delegate(IAsyncResult ar)
			{
				output.EndWrite(ar);
				close(force: false);
			}, null);
		}

		public void CopyFrom(HttpListenerResponse templateResponse)
		{
			if (templateResponse == null)
			{
				throw new ArgumentNullException("templateResponse");
			}
			if (templateResponse._headers != null)
			{
				if (_headers != null)
				{
					_headers.Clear();
				}
				Headers.Add(templateResponse._headers);
			}
			else if (_headers != null)
			{
				_headers = null;
			}
			_contentLength = templateResponse._contentLength;
			_statusCode = templateResponse._statusCode;
			_statusDescription = templateResponse._statusDescription;
			_keepAlive = templateResponse._keepAlive;
			_version = templateResponse._version;
		}

		public void Redirect(string url)
		{
			checkDisposedOrHeadersSent();
			if (url == null)
			{
				throw new ArgumentNullException("url");
			}
			Uri result = null;
			if (!url.MaybeUri() || !Uri.TryCreate(url, UriKind.Absolute, out result))
			{
				throw new ArgumentException("Not an absolute URL.", "url");
			}
			_location = url;
			_statusCode = 302;
			_statusDescription = "Found";
		}

		public void SetCookie(Cookie cookie)
		{
			if (cookie == null)
			{
				throw new ArgumentNullException("cookie");
			}
			if (!canAddOrUpdate(cookie))
			{
				throw new ArgumentException("Cannot be replaced.", "cookie");
			}
			Cookies.Add(cookie);
		}

		void IDisposable.Dispose()
		{
			if (!_disposed)
			{
				close(force: true);
			}
		}
	}
	internal class HttpStreamAsyncResult : IAsyncResult
	{
		private byte[] _buffer;

		private AsyncCallback _callback;

		private bool _completed;

		private int _count;

		private Exception _exception;

		private int _offset;

		private object _state;

		private object _sync;

		private int _syncRead;

		private ManualResetEvent _waitHandle;

		internal byte[] Buffer
		{
			get
			{
				return _buffer;
			}
			set
			{
				_buffer = value;
			}
		}

		internal int Count
		{
			get
			{
				return _count;
			}
			set
			{
				_count = value;
			}
		}

		internal Exception Exception => _exception;

		internal bool HasException => _exception != null;

		internal int Offset
		{
			get
			{
				return _offset;
			}
			set
			{
				_offset = value;
			}
		}

		internal int SyncRead
		{
			get
			{
				return _syncRead;
			}
			set
			{
				_syncRead = value;
			}
		}

		public object AsyncState => _state;

		public WaitHandle AsyncWaitHandle
		{
			get
			{
				lock (_sync)
				{
					return _waitHandle ?? (_waitHandle = new ManualResetEvent(_completed));
				}
			}
		}

		public bool CompletedSynchronously => _syncRead == _count;

		public bool IsCompleted
		{
			get
			{
				lock (_sync)
				{
					return _completed;
				}
			}
		}

		internal HttpStreamAsyncResult(AsyncCallback callback, object state)
		{
			_callback = callback;
			_state = state;
			_sync = new object();
		}

		internal void Complete()
		{
			lock (_sync)
			{
				if (_completed)
				{
					return;
				}
				_completed = true;
				if (_waitHandle != null)
				{
					_waitHandle.Set();
				}
				if (_callback != null)
				{
					_callback.BeginInvoke(this, delegate(IAsyncResult ar)
					{
						_callback.EndInvoke(ar);
					}, null);
				}
			}
		}

		internal void Complete(Exception exception)
		{
			_exception = exception;
			Complete();
		}
	}
	internal sealed class HttpUtility
	{
		private static Dictionary<string, char> _entities;

		private static char[] _hexChars = "0123456789abcdef".ToCharArray();

		private static object _sync = new object();

		private static int getChar(byte[] bytes, int offset, int length)
		{
			int num = 0;
			int num2 = length + offset;
			for (int i = offset; i < num2; i++)
			{
				int num3 = getInt(bytes[i]);
				if (num3 == -1)
				{
					return -1;
				}
				num = (num << 4) + num3;
			}
			return num;
		}

		private static int getChar(string s, int offset, int length)
		{
			int num = 0;
			int num2 = length + offset;
			for (int i = offset; i < num2; i++)
			{
				char c = s[i];
				if (c > '\u007f')
				{
					return -1;
				}
				int num3 = getInt((byte)c);
				if (num3 == -1)
				{
					return -1;
				}
				num = (num << 4) + num3;
			}
			return num;
		}

		private static char[] getChars(MemoryStream buffer, Encoding encoding)
		{
			return encoding.GetChars(buffer.GetBuffer(), 0, (int)buffer.Length);
		}

		private static Dictionary<string, char> getEntities()
		{
			lock (_sync)
			{
				if (_entities == null)
				{
					initEntities();
				}
				return _entities;
			}
		}

		private static int getInt(byte b)
		{
			char c = (char)b;
			return (c >= '0' && c <= '9') ? (c - 48) : ((c >= 'a' && c <= 'f') ? (c - 97 + 10) : ((c >= 'A' && c <= 'F') ? (c - 65 + 10) : (-1)));
		}

		private static void initEntities()
		{
			_entities = new Dictionary<string, char>();
			_entities.Add("nbsp", '\u00a0');
			_entities.Add("iexcl", '');
			_entities.Add("cent", '');
			_entities.Add("pound", '');
			_entities.Add("curren", '');
			_entities.Add("yen", '');
			_entities.Add("brvbar", '');
			_entities.Add("sect", '');
			_entities.Add("uml", '\u00a8');
			_entities.Add("copy", '');
			_entities.Add("ordf", '');
			_entities.Add("laquo", '');
			_entities.Add("not", '');
			_entities.Add("shy", '\u00ad');
			_entities.Add("reg", '');
			_entities.Add("macr", '\u00af');
			_entities.Add("deg", '');
			_entities.Add("plusmn", '');
			_entities.Add("sup2", '');
			_entities.Add("sup3", '');
			_entities.Add("acute", '\u00b4');
			_entities.Add("micro", '');
			_entities.Add("para", '');
			_entities.Add("middot", '');
			_entities.Add("cedil", '\u00b8');
			_entities.Add("sup1", '');
			_entities.Add("ordm", '');
			_entities.Add("raquo", '');
			_entities.Add("frac14", '');
			_entities.Add("frac12", '');
			_entities.Add("frac34", '');
			_entities.Add("iquest", '');
			_entities.Add("Agrave", '');
			_entities.Add("Aacute", '');
			_entities.Add("Acirc", '');
			_entities.Add("Atilde", '');
			_entities.Add("Auml", '');
			_entities.Add("Aring", '');
			_entities.Add("AElig", '');
			_entities.Add("Ccedil", '');
			_entities.Add("Egrave", '');
			_entities.Add("Eacute", '');
			_entities.Add("Ecirc", '');
			_entities.Add("Euml", '');
			_entities.Add("Igrave", '');
			_entities.Add("Iacute", '');
			_entities.Add("Icirc", '');
			_entities.Add("Iuml", '');
			_entities.Add("ETH", '');
			_entities.Add("Ntilde", '');
			_entities.Add("Ograve", '');
			_entities.Add("Oacute", '');
			_entities.Add("Ocirc", '');
			_entities.Add("Otilde", '');
			_entities.Add("Ouml", '');
			_entities.Add("times", '');
			_entities.Add("Oslash", '');
			_entities.Add("Ugrave", '');
			_entities.Add("Uacute", '');
			_entities.Add("Ucirc", '');
			_entities.Add("Uuml", '');
			_entities.Add("Yacute", '');
			_entities.Add("THORN", '');
			_entities.Add("szlig", '');
			_entities.Add("agrave", '');
			_entities.Add("aacute", '');
			_entities.Add("acirc", '');
			_entities.Add("atilde", '');
			_entities.Add("auml", '');
			_entities.Add("aring", '');
			_entities.Add("aelig", '');
			_entities.Add("ccedil", '');
			_entities.Add("egrave", '');
			_entities.Add("eacute", '');
			_entities.Add("ecirc", '');
			_entities.Add("euml", '');
			_entities.Add("igrave", '');
			_entities.Add("iacute", '');
			_entities.Add("icirc", '');
			_entities.Add("iuml", '');
			_entities.Add("eth", '');
			_entities.Add("ntilde", '');
			_entities.Add("ograve", '');
			_entities.Add("oacute", '');
			_entities.Add("ocirc", '');
			_entities.Add("otilde", '');
			_entities.Add("ouml", '');
			_entities.Add("divide", '');
			_entities.Add("oslash", '');
			_entities.Add("ugrave", '');
			_entities.Add("uacute", '');
			_entities.Add("ucirc", '');
			_entities.Add("uuml", '');
			_entities.Add("yacute", '');
			_entities.Add("thorn", '');
			_entities.Add("yuml", '');
			_entities.Add("fnof", '');
			_entities.Add("Alpha", '');
			_entities.Add("Beta", '');
			_entities.Add("Gamma", '');
			_entities.Add("Delta", '');
			_entities.Add("Epsilon", '');
			_entities.Add("Zeta", '');
			_entities.Add("Eta", '');
			_entities.Add("Theta", '');
			_entities.Add("Iota", '');
			_entities.Add("Kappa", '');
			_entities.Add("Lambda", '');
			_entities.Add("Mu", '');
			_entities.Add("Nu", '');
			_entities.Add("Xi", '');
			_entities.Add("Omicron", '');
			_entities.Add("Pi", '');
			_entities.Add("Rho", '');
			_entities.Add("Sigma", '');
			_entities.Add("Tau", '');
			_entities.Add("Upsilon", '');
			_entities.Add("Phi", '');
			_entities.Add("Chi", '');
			_entities.Add("Psi", '');
			_entities.Add("Omega", '');
			_entities.Add("alpha", '');
			_entities.Add("beta", '');
			_entities.Add("gamma", '');
			_entities.Add("delta", '');
			_entities.Add("epsilon", '');
			_entities.Add("zeta", '');
			_entities.Add("eta", '');
			_entities.Add("theta", '');
			_entities.Add("iota", '');
			_entities.Add("kappa", '');
			_entities.Add("lambda", '');
			_entities.Add("mu", '');
			_entities.Add("nu", '');
			_entities.Add("xi", '');
			_entities.Add("omicron", '');
			_entities.Add("pi", '');
			_entities.Add("rho", '');
			_entities.Add("sigmaf", '');
			_entities.Add("sigma", '');
			_entities.Add("tau", '');
			_entities.Add("upsilon", '');
			_entities.Add("phi", '');
			_entities.Add("chi", '');
			_entities.Add("psi", '');
			_entities.Add("omega", '');
			_entities.Add("thetasym", '');
			_entities.Add("upsih", '');
			_entities.Add("piv", '');
			_entities.Add("bull", '');
			_entities.Add("hellip", '');
			_entities.Add("prime", '');
			_entities.Add("Prime", '');
			_entities.Add("oline", '');
			_entities.Add("frasl", '');
			_entities.Add("weierp", '');
			_entities.Add("image", '');
			_entities.Add("real", '');
			_entities.Add("trade", '');
			_entities.Add("alefsym", '');
			_entities.Add("larr", '');
			_entities.Add("uarr", '');
			_entities.Add("rarr", '');
			_entities.Add("darr", '');
			_entities.Add("harr", '');
			_entities.Add("crarr", '');
			_entities.Add("lArr", '');
			_entities.Add("uArr", '');
			_entities.Add("rArr", '');
			_entities.Add("dArr", '');
			_entities.Add("hArr", '');
			_entities.Add("forall", '');
			_entities.Add("part", '');
			_entities.Add("exist", '');
			_entities.Add("empty", '');
			_entities.Add("nabla", '');
			_entities.Add("isin", '');
			_entities.Add("notin", '');
			_entities.Add("ni", '');
			_entities.Add("prod", '');
			_entities.Add("sum", '');
			_entities.Add("minus", '');
			_entities.Add("lowast", '');
			_entities.Add("radic", '');
			_entities.Add("prop", '');
			_entities.Add("infin", '');
			_entities.Add("ang", '');
			_entities.Add("and", '');
			_entities.Add("or", '');
			_entities.Add("cap", '');
			_entities.Add("cup", '');
			_entities.Add("int", '');
			_entities.Add("there4", '');
			_entities.Add("sim", '');
			_entities.Add("cong", '');
			_entities.Add("asymp", '');
			_entities.Add("ne", '');
			_entities.Add("equiv", '');
			_entities.Add("le", '');
			_entities.Add("ge", '');
			_entities.Add("sub", '');
			_entities.Add("sup", '');
			_entities.Add("nsub", '');
			_entities.Add("sube", '');
			_entities.Add("supe", '');
			_entities.Add("oplus", '');
			_entities.Add("otimes", '');
			_entities.Add("perp", '');
			_entities.Add("sdot", '');
			_entities.Add("lceil", '');
			_entities.Add("rceil", '');
			_entities.Add("lfloor", '');
			_entities.Add("rfloor", '');
			_entities.Add("lang", '');
			_entities.Add("rang", '');
			_entities.Add("loz", '');
			_entities.Add("spades", '');
			_entities.Add("clubs", '');
			_entities.Add("hearts", '');
			_entities.Add("diams", '');
			_entities.Add("quot", '"');
			_entities.Add("amp", '&');
			_entities.Add("lt", '<');
			_entities.Add("gt", '>');
			_entities.Add("OElig", '');
			_entities.Add("oelig", '');
			_entities.Add("Scaron", '');
			_entities.Add("scaron", '');
			_entities.Add("Yuml", '');
			_entities.Add("circ", '');
			_entities.Add("tilde", '\u02dc');
			_entities.Add("ensp", '\u2002');
			_entities.Add("emsp", '\u2003');
			_entities.Add("thinsp", '\u2009');
			_entities.Add("zwnj", '\u200c');
			_entities.Add("zwj", '\u200d');
			_entities.Add("lrm", '\u200e');
			_entities.Add("rlm", '\u200f');
			_entities.Add("ndash", '');
			_entities.Add("mdash", '');
			_entities.Add("lsquo", '');
			_entities.Add("rsquo", '');
			_entities.Add("sbquo", '');
			_entities.Add("ldquo", '');
			_entities.Add("rdquo", '');
			_entities.Add("bdquo", '');
			_entities.Add("dagger", '');
			_entities.Add("Dagger", '');
			_entities.Add("permil", '');
			_entities.Add("lsaquo", '');
			_entities.Add("rsaquo", '');
			_entities.Add("euro", '');
		}

		private static bool notEncoded(char c)
		{
			return c == '!' || c == '\'' || c == '(' || c == ')' || c == '*' || c == '-' || c == '.' || c == '_';
		}

		private static void urlEncode(char c, Stream result, bool unicode)
		{
			if (c > '')
			{
				result.WriteByte(37);
				result.WriteByte(117);
				int num = (int)c >> 12;
				result.WriteByte((byte)_hexChars[num]);
				num = ((int)c >> 8) & 0xF;
				result.WriteByte((byte)_hexChars[num]);
				num = ((int)c >> 4) & 0xF;
				result.WriteByte((byte)_hexChars[num]);
				num = c & 0xF;
				result.WriteByte((byte)_hexChars[num]);
			}
			else if (c > ' ' && notEncoded(c))
			{
				result.WriteByte((byte)c);
			}
			else if (c == ' ')
			{
				result.WriteByte(43);
			}
			else if (c < '0' || (c < 'A' && c > '9') || (c > 'Z' && c < 'a') || c > 'z')
			{
				if (unicode && c > '\u007f')
				{
					result.WriteByte(37);
					result.WriteByte(117);
					result.WriteByte(48);
					result.WriteByte(48);
				}
				else
				{
					result.WriteByte(37);
				}
				int num2 = (int)c >> 4;
				result.WriteByte((byte)_hexChars[num2]);
				num2 = c & 0xF;
				result.WriteByte((byte)_hexChars[num2]);
			}
			else
			{
				result.WriteByte((byte)c);
			}
		}

		private static void urlPathEncode(char c, Stream result)
		{
			if (c < '!' || c > '~')
			{
				byte[] bytes = Encoding.UTF8.GetBytes(c.ToString());
				byte[] array = bytes;
				foreach (byte b in array)
				{
					result.WriteByte(37);
					int num = b;
					int num2 = num >> 4;
					result.WriteByte((byte)_hexChars[num2]);
					num2 = num & 0xF;
					result.WriteByte((byte)_hexChars[num2]);
				}
			}
			else if (c == ' ')
			{
				result.WriteByte(37);
				result.WriteByte(50);
				result.WriteByte(48);
			}
			else
			{
				result.WriteByte((byte)c);
			}
		}

		private static void writeCharBytes(char c, IList buffer, Encoding encoding)
		{
			if (c > '')
			{
				byte[] bytes = encoding.GetBytes(new char[1] { c });
				foreach (byte b in bytes)
				{
					buffer.Add(b);
				}
			}
			else
			{
				buffer.Add((byte)c);
			}
		}

		internal static Uri CreateRequestUrl(string requestUri, string host, bool websocketRequest, bool secure)
		{
			if (requestUri == null || requestUri.Length == 0 || host == null || host.Length == 0)
			{
				return null;
			}
			string text = null;
			string arg = null;
			if (requestUri.StartsWith("/"))
			{
				arg = requestUri;
			}
			else if (requestUri.MaybeUri())
			{
				if (!Uri.TryCreate(requestUri, UriKind.Absolute, out var result) || ((!(text = result.Scheme).StartsWith("http") || websocketRequest) && !(text.StartsWith("ws") && websocketRequest)))
				{
					return null;
				}
				host = result.Authority;
				arg = result.PathAndQuery;
			}
			else if (!(requestUri == "*"))
			{
				host = requestUri;
			}
			if (text == null)
			{
				text = (websocketRequest ? "ws" : "http") + (secure ? "s" : string.Empty);
			}
			int num = host.IndexOf(':');
			if (num == -1)
			{
				host = string.Format("{0}:{1}", host, (text == "http" || text == "ws") ? 80 : 443);
			}
			string uriString = $"{text}://{host}{arg}";
			if (!Uri.TryCreate(uriString, UriKind.Absolute, out var result2))
			{
				return null;
			}
			return result2;
		}

		internal static IPrincipal CreateUser(string response, AuthenticationSchemes scheme, string realm, string method, Func<IIdentity, NetworkCredential> credentialsFinder)
		{
			if (response == null || response.Length == 0)
			{
				return null;
			}
			if (credentialsFinder == null)
			{
				return null;
			}
			if (scheme != AuthenticationSchemes.Basic && scheme != AuthenticationSchemes.Digest)
			{
				return null;
			}
			if (scheme == AuthenticationSchemes.Digest)
			{
				if (realm == null || realm.Length == 0)
				{
					return null;
				}
				if (method == null || method.Length == 0)
				{
					return null;
				}
			}
			if (!response.StartsWith(scheme.ToString(), StringComparison.OrdinalIgnoreCase))
			{
				return null;
			}
			AuthenticationResponse authenticationResponse = AuthenticationResponse.Parse(response);
			if (authenticationResponse == null)
			{
				return null;
			}
			IIdentity identity = authenticationResponse.ToIdentity();
			if (identity == null)
			{
				return null;
			}
			NetworkCredential networkCredential = null;
			try
			{
				networkCredential = credentialsFinder(identity);
			}
			catch
			{
			}
			if (networkCredential == null)
			{
				return null;
			}
			if (scheme == AuthenticationSchemes.Basic && ((HttpBasicIdentity)identity).Password != networkCredential.Password)
			{
				return null;
			}
			if (scheme == AuthenticationSchemes.Digest && !((HttpDigestIdentity)identity).IsValid(networkCredential.Password, realm, method, null))
			{
				return null;
			}
			return new GenericPrincipal(identity, networkCredential.Roles);
		}

		internal static Encoding GetEncoding(string contentType)
		{
			string[] array = contentType.Split(new char[1] { ';' });
			string[] array2 = array;
			foreach (string text in array2)
			{
				string text2 = text.Trim();
				if (text2.StartsWith("charset", StringComparison.OrdinalIgnoreCase))
				{
					return Encoding.GetEncoding(text2.GetValue('=', unquote: true));
				}
			}
			return null;
		}

		internal static NameValueCollection InternalParseQueryString(string query, Encoding encoding)
		{
			int length;
			if (query == null || (length = query.Length) == 0 || (length == 1 && query[0] == '?'))
			{
				return new NameValueCollection(1);
			}
			if (query[0] == '?')
			{
				query = query.Substring(1);
			}
			QueryStringCollection queryStringCollection = new QueryStringCollection();
			string[] array = query.Split(new char[1] { '&' });
			string[] array2 = array;
			foreach (string text in array2)
			{
				int num = text.IndexOf('=');
				if (num > -1)
				{
					string name = UrlDecode(text.Substring(0, num), encoding);
					string value = ((text.Length > num + 1) ? UrlDecode(text.Substring(num + 1), encoding) : string.Empty);
					queryStringCollection.Add(name, value);
				}
				else
				{
					queryStringCollection.Add(null, UrlDecode(text, encoding));
				}
			}
			return queryStringCollection;
		}

		internal static string InternalUrlDecode(byte[] bytes, int offset, int count, Encoding encoding)
		{
			StringBuilder stringBuilder = new StringBuilder();
			using (MemoryStream memoryStream = new MemoryStream())
			{
				int num = count + offset;
				for (int i = offset; i < num; i++)
				{
					if (bytes[i] == 37 && i + 2 < count && bytes[i + 1] != 37)
					{
						int num2;
						if (bytes[i + 1] == 117 && i + 5 < num)
						{
							if (memoryStream.Length > 0)
							{
								stringBuilder.Append(getChars(memoryStream, encoding));
								memoryStream.SetLength(0L);
							}
							num2 = getChar(bytes, i + 2, 4);
							if (num2 != -1)
							{
								stringBuilder.Append((char)num2);
								i += 5;
								continue;
							}
						}
						else if ((num2 = getChar(bytes, i + 1, 2)) != -1)
						{
							memoryStream.WriteByte((byte)num2);
							i += 2;
							continue;
						}
					}
					if (memoryStream.Length > 0)
					{
						stringBuilder.Append(getChars(memoryStream, encoding));
						memoryStream.SetLength(0L);
					}
					if (bytes[i] == 43)
					{
						stringBuilder.Append(' ');
					}
					else
					{
						stringBuilder.Append((char)bytes[i]);
					}
				}
				if (memoryStream.Length > 0)
				{
					stringBuilder.Append(getChars(memoryStream, encoding));
				}
			}
			return stringBuilder.ToString();
		}

		internal static byte[] InternalUrlDecodeToBytes(byte[] bytes, int offset, int count)
		{
			using MemoryStream memoryStream = new MemoryStream();
			int num = offset + count;
			for (int i = offset; i < num; i++)
			{
				char c = (char)bytes[i];
				switch (c)
				{
				case '+':
					c = ' ';
					break;
				case '%':
					if (i < num - 2)
					{
						int num2 = getChar(bytes, i + 1, 2);
						if (num2 != -1)
						{
							c = (char)num2;
							i += 2;
						}
					}
					break;
				}
				memoryStream.WriteByte((byte)c);
			}
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		internal static byte[] InternalUrlEncodeToBytes(byte[] bytes, int offset, int count)
		{
			using MemoryStream memoryStream = new MemoryStream();
			int num = offset + count;
			for (int i = offset; i < num; i++)
			{
				urlEncode((char)bytes[i], memoryStream, unicode: false);
			}
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		internal static byte[] InternalUrlEncodeUnicodeToBytes(string s)
		{
			using MemoryStream memoryStream = new MemoryStream();
			foreach (char c in s)
			{
				urlEncode(c, memoryStream, unicode: true);
			}
			memoryStream.Close();
			return memoryStream.ToArray();
		}

		public static string HtmlAttributeEncode(string s)
		{
			if (s == null || s.Length == 0 || !s.Contains('&', '"', '<', '>'))
			{
				return s;
			}
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < s.Length; i++)
			{
				char c = s[i];
				stringBuilder.Append(c switch
				{
					'>' => "&gt;", 
					'<' => "&lt;", 
					'"' => "&quot;", 
					'&' => "&amp;", 
					_ => c.ToString(), 
				});
			}
			return stringBuilder.ToString();
		}

		public static void HtmlAttributeEncode(string s, TextWriter output)
		{
			if (output == null)
			{
				throw new ArgumentNullException("output");
			}
			output.Write(HtmlAttributeEncode(s));
		}

		public static string HtmlDecode(string s)
		{
			if (s == null || s.Length == 0 || !Ext.Contains(s, '&'))
			{
				return s;
			}
			StringBuilder stringBuilder = new StringBuilder();
			StringBuilder stringBuilder2 = new StringBuilder();
			int num = 0;
			int num2 = 0;
			bool flag = false;
			foreach (char c in s)
			{
				if (num == 0)
				{
					if (c == '&')
					{
						stringBuilder.Append(c);
						num = 1;
					}
					else
					{
						stringBuilder2.Append(c);
					}
					continue;
				}
				if (c == '&')
				{
					num = 1;
					if (flag)
					{
						stringBuilder.Append(num2.ToString(CultureInfo.InvariantCulture));
						flag = false;
					}
					stringBuilder2.Append(stringBuilder.ToString());
					stringBuilder.Length = 0;
					stringBuilder.Append('&');
					continue;
				}
				switch (num)
				{
				case 1:
					if (c == ';')
					{
						num = 0;
						stringBuilder2.Append(stringBuilder.ToString());
						stringBuilder2.Append(c);
						stringBuilder.Length = 0;
					}
					else
					{
						num2 = 0;
						num = ((c == '#') ? 3 : 2);
						stringBuilder.Append(c);
					}
					break;
				case 2:
					stringBuilder.Append(c);
					if (c == ';')
					{
						string text = stringBuilder.ToString();
						Dictionary<string, char> entities = getEntities();
						if (text.Length > 1 && entities.ContainsKey(text.Substring(1, text.Length - 2)))
						{
							text = entities[text.Substring(1, text.Length - 2)].ToString();
						}
						stringBuilder2.Append(text);
						num = 0;
						stringBuilder.Length = 0;
					}
					break;
				case 3:
					if (c == ';')
					{
						if (num2 > 65535)
						{
							stringBuilder2.Append("&#");
							stringBuilder2.Append(num2.ToString(CultureInfo.InvariantCulture));
							stringBuilder2.Append(";");
						}
						else
						{
							stringBuilder2.Append((char)num2);
						}
						num = 0;
						stringBuilder.Length = 0;
						flag = false;
					}
					else if (char.IsDigit(c))
					{
						num2 = num2 * 10 + (c - 48);
						flag = true;
					}
					else
					{
						num = 2;
						if (flag)
						{
							stringBuilder.Append(num2.ToString(CultureInfo.InvariantCulture));
							flag = false;
						}
						stringBuilder.Append(c);
					}
					break;
				}
			}
			if (stringBuilder.Length > 0)
			{
				stringBuilder2.Append(stringBuilder.ToString());
			}
			else if (flag)
			{
				stringBuilder2.Append(num2.ToString(CultureInfo.InvariantCulture));
			}
			return stringBuilder2.ToString();
		}

		public static void HtmlDecode(string s, TextWriter output)
		{
			if (output == null)
			{
				throw new ArgumentNullException("output");
			}
			output.Write(HtmlDecode(s));
		}

		public static string HtmlEncode(string s)
		{
			if (s == null || s.Length == 0)
			{
				return s;
			}
			bool flag = false;
			foreach (char c in s)
			{
				if (c == '&' || c == '"' || c == '<' || c == '>' || c > '\u009f')
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return s;
			}
			StringBuilder stringBuilder = new StringBuilder();
			foreach (char c2 in s)
			{
				if (c2 == '&')
				{
					stringBuilder.Append("&amp;");
				}
				else if (c2 == '"')
				{
					stringBuilder.Append("&quot;");
				}
				else if (c2 == '<')
				{
					stringBuilder.Append("&lt;");
				}
				else if (c2 == '>')
				{
					stringBuilder.Append("&gt;");
				}
				else if (c2 > '\u009f')
				{
					stringBuilder.Append("&#");
					int num = c2;
					stringBuilder.Append(num.ToString(CultureInfo.InvariantCulture));
					stringBuilder.Append(";");
				}
				else
				{
					stringBuilder.Append(c2);
				}
			}
			return stringBuilder.ToString();
		}

		public static void HtmlEncode(string s, TextWriter output)
		{
			if (output == null)
			{
				throw new ArgumentNullException("output");
			}
			output.Write(HtmlEncode(s));
		}

		public static NameValueCollection ParseQueryString(string query)
		{
			return ParseQueryString(query, Encoding.UTF8);
		}

		public static NameValueCollection ParseQueryString(string query, Encoding encoding)
		{
			if (query == null)
			{
				throw new ArgumentNullException("query");
			}
			return InternalParseQueryString(query, encoding ?? Encoding.UTF8);
		}

		public static string UrlDecode(string s)
		{
			return UrlDecode(s, Encoding.UTF8);
		}

		public static string UrlDecode(string s, Encoding encoding)
		{
			if (s == null || s.Length == 0 || !s.Contains('%', '+'))
			{
				return s;
			}
			if (encoding == null)
			{
				encoding = Encoding.UTF8;
			}
			List<byte> list = new List<byte>();
			int length = s.Length;
			for (int i = 0; i < length; i++)
			{
				char c = s[i];
				if (c == '%' && i + 2 < length && s[i + 1] != '%')
				{
					int num;
					if (s[i + 1] == 'u' && i + 5 < length)
					{
						num = getChar(s, i + 2, 4);
						if (num != -1)
						{
							writeCharBytes((char)num, list, encoding);
							i += 5;
						}
						else
						{
							writeCharBytes('%', list, encoding);
						}
					}
					else if ((num = getChar(s, i + 1, 2)) != -1)
					{
						writeCharBytes((char)num, list, encoding);
						i += 2;
					}
					else
					{
						writeCharBytes('%', list, encoding);
					}
				}
				else if (c == '+')
				{
					writeCharBytes(' ', list, encoding);
				}
				else
				{
					writeCharBytes(c, list, encoding);
				}
			}
			return encoding.GetString(list.ToArray());
		}

		public static string UrlDecode(byte[] bytes, Encoding encoding)
		{
			int count;
			return (bytes == null) ? null : (((count = bytes.Length) == 0) ? string.Empty : InternalUrlDecode(bytes, 0, count, encoding ?? Encoding.UTF8));
		}

		public static string UrlDecode(byte[] bytes, int offset, int count, Encoding encoding)
		{
			if (bytes == null)
			{
				return null;
			}
			int num = bytes.Length;
			if (num == 0 || count == 0)
			{
				return string.Empty;
			}
			if (offset < 0 || offset >= num)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (count < 0 || count > num - offset)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			return InternalUrlDecode(bytes, offset, count, encoding ?? Encoding.UTF8);
		}

		public static byte[] UrlDecodeToBytes(byte[] bytes)
		{
			int count;
			return (bytes != null && (count = bytes.Length) > 0) ? InternalUrlDecodeToBytes(bytes, 0, count) : bytes;
		}

		public static byte[] UrlDecodeToBytes(string s)
		{
			return UrlDecodeToBytes(s, Encoding.UTF8);
		}

		public static byte[] UrlDecodeToBytes(string s, Encoding encoding)
		{
			if (s == null)
			{
				return null;
			}
			if (s.Length == 0)
			{
				return new byte[0];
			}
			byte[] bytes = (encoding ?? Encoding.UTF8).GetBytes(s);
			return InternalUrlDecodeToBytes(bytes, 0, bytes.Length);
		}

		public static byte[] UrlDecodeToBytes(byte[] bytes, int offset, int count)
		{
			int num;
			if (bytes == null || (num = bytes.Length) == 0)
			{
				return bytes;
			}
			if (count == 0)
			{
				return new byte[0];
			}
			if (offset < 0 || offset >= num)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (count < 0 || count > num - offset)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			return InternalUrlDecodeToBytes(bytes, offset, count);
		}

		public static string UrlEncode(byte[] bytes)
		{
			int count;
			return (bytes == null) ? null : (((count = bytes.Length) == 0) ? string.Empty : Encoding.ASCII.GetString(InternalUrlEncodeToBytes(bytes, 0, count)));
		}

		public static string UrlEncode(string s)
		{
			return UrlEncode(s, Encoding.UTF8);
		}

		public static string UrlEncode(string s, Encoding encoding)
		{
			int length;
			if (s == null || (length = s.Length) == 0)
			{
				return s;
			}
			bool flag = false;
			foreach (char c in s)
			{
				if ((c < '0' || (c < 'A' && c > '9') || (c > 'Z' && c < 'a') || c > 'z') && !notEncoded(c))
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				return s;
			}
			if (encoding == null)
			{
				encoding = Encoding.UTF8;
			}
			byte[] bytes = new byte[encoding.GetMaxByteCount(length)];
			int bytes2 = encoding.GetBytes(s, 0, length, bytes, 0);
			return Encoding.ASCII.GetString(InternalUrlEncodeToBytes(bytes, 0, bytes2));
		}

		public static string UrlEncode(byte[] bytes, int offset, int count)
		{
			byte[] array = UrlEncodeToBytes(bytes, offset, count);
			return (array == null) ? null : ((array.Length == 0) ? string.Empty : Encoding.ASCII.GetString(array));
		}

		public static byte[] UrlEncodeToBytes(byte[] bytes)
		{
			int count;
			return (bytes != null && (count = bytes.Length) > 0) ? InternalUrlEncodeToBytes(bytes, 0, count) : bytes;
		}

		public static byte[] UrlEncodeToBytes(string s)
		{
			return UrlEncodeToBytes(s, Encoding.UTF8);
		}

		public static byte[] UrlEncodeToBytes(string s, Encoding encoding)
		{
			if (s == null)
			{
				return null;
			}
			if (s.Length == 0)
			{
				return new byte[0];
			}
			byte[] bytes = (encoding ?? Encoding.UTF8).GetBytes(s);
			return InternalUrlEncodeToBytes(bytes, 0, bytes.Length);
		}

		public static byte[] UrlEncodeToBytes(byte[] bytes, int offset, int count)
		{
			int num;
			if (bytes == null || (num = bytes.Length) == 0)
			{
				return bytes;
			}
			if (count == 0)
			{
				return new byte[0];
			}
			if (offset < 0 || offset >= num)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (count < 0 || count > num - offset)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			return InternalUrlEncodeToBytes(bytes, offset, count);
		}

		public static string UrlEncodeUnicode(string s)
		{
			return (s != null && s.Length > 0) ? Encoding.ASCII.GetString(InternalUrlEncodeUnicodeToBytes(s)) : s;
		}

		public static byte[] UrlEncodeUnicodeToBytes(string s)
		{
			return (s == null) ? null : ((s.Length == 0) ? new byte[0] : InternalUrlEncodeUnicodeToBytes(s));
		}

		public static string UrlPathEncode(string s)
		{
			if (s == null || s.Length == 0)
			{
				return s;
			}
			using MemoryStream memoryStream = new MemoryStream();
			foreach (char c in s)
			{
				urlPathEncode(c, memoryStream);
			}
			memoryStream.Close();
			return Encoding.ASCII.GetString(memoryStream.ToArray());
		}
	}
	internal class RequestStream : Stream
	{
		private long _bodyLeft;

		private byte[] _buffer;

		private int _count;

		private bool _disposed;

		private int _offset;

		private Stream _stream;

		public override bool CanRead => true;

		public override bool CanSeek => false;

		public override bool CanWrite => false;

		public override long Length
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override long Position
		{
			get
			{
				throw new NotSupportedException();
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		internal RequestStream(Stream stream, byte[] buffer, int offset, int count)
			: this(stream, buffer, offset, count, -1L)
		{
		}

		internal RequestStream(Stream stream, byte[] buffer, int offset, int count, long contentLength)
		{
			_stream = stream;
			_buffer = buffer;
			_offset = offset;
			_count = count;
			_bodyLeft = contentLength;
		}

		private int fillFromBuffer(byte[] buffer, int offset, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", "A negative value.");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", "A negative value.");
			}
			int num = buffer.Length;
			if (offset + count > num)
			{
				throw new ArgumentException("The sum of 'offset' and 'count' is greater than 'buffer' length.");
			}
			if (_bodyLeft == 0)
			{
				return -1;
			}
			if (_count == 0 || count == 0)
			{
				return 0;
			}
			if (count > _count)
			{
				count = _count;
			}
			if (_bodyLeft > 0 && count > _bodyLeft)
			{
				count = (int)_bodyLeft;
			}
			Buffer.BlockCopy(_buffer, _offset, buffer, offset, count);
			_offset += count;
			_count -= count;
			if (_bodyLeft > 0)
			{
				_bodyLeft -= count;
			}
			return count;
		}

		public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			int num = fillFromBuffer(buffer, offset, count);
			if (num > 0 || num == -1)
			{
				HttpStreamAsyncResult httpStreamAsyncResult = new HttpStreamAsyncResult(callback, state);
				httpStreamAsyncResult.Buffer = buffer;
				httpStreamAsyncResult.Offset = offset;
				httpStreamAsyncResult.Count = count;
				httpStreamAsyncResult.SyncRead = ((num > 0) ? num : 0);
				httpStreamAsyncResult.Complete();
				return httpStreamAsyncResult;
			}
			if (_bodyLeft >= 0 && count > _bodyLeft)
			{
				count = (int)_bodyLeft;
			}
			return _stream.BeginRead(buffer, offset, count, callback, state);
		}

		public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			throw new NotSupportedException();
		}

		public override void Close()
		{
			_disposed = true;
		}

		public override int EndRead(IAsyncResult asyncResult)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			if (asyncResult == null)
			{
				throw new ArgumentNullException("asyncResult");
			}
			if (asyncResult is HttpStreamAsyncResult)
			{
				HttpStreamAsyncResult httpStreamAsyncResult = (HttpStreamAsyncResult)asyncResult;
				if (!httpStreamAsyncResult.IsCompleted)
				{
					httpStreamAsyncResult.AsyncWaitHandle.WaitOne();
				}
				return httpStreamAsyncResult.SyncRead;
			}
			int num = _stream.EndRead(asyncResult);
			if (num > 0 && _bodyLeft > 0)
			{
				_bodyLeft -= num;
			}
			return num;
		}

		public override void EndWrite(IAsyncResult asyncResult)
		{
			throw new NotSupportedException();
		}

		public override void Flush()
		{
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			int num = fillFromBuffer(buffer, offset, count);
			if (num == -1)
			{
				return 0;
			}
			if (num > 0)
			{
				return num;
			}
			num = _stream.Read(buffer, offset, count);
			if (num > 0 && _bodyLeft > 0)
			{
				_bodyLeft -= num;
			}
			return num;
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			throw new NotSupportedException();
		}
	}
	internal class ResponseStream : Stream
	{
		private MemoryStream _body;

		private static readonly byte[] _crlf = new byte[2] { 13, 10 };

		private bool _disposed;

		private HttpListenerResponse _response;

		private bool _sendChunked;

		private Stream _stream;

		private Action<byte[], int, int> _write;

		private Action<byte[], int, int> _writeBody;

		private Action<byte[], int, int> _writeChunked;

		public override bool CanRead => false;

		public override bool CanSeek => false;

		public override bool CanWrite => !_disposed;

		public override long Length
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override long Position
		{
			get
			{
				throw new NotSupportedException();
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		internal ResponseStream(Stream stream, HttpListenerResponse response, bool ignoreWriteExceptions)
		{
			_stream = stream;
			_response = response;
			if (ignoreWriteExceptions)
			{
				_write = writeWithoutThrowingException;
				_writeChunked = writeChunkedWithoutThrowingException;
			}
			else
			{
				_write = stream.Write;
				_writeChunked = writeChunked;
			}
			_body = new MemoryStream();
		}

		private bool flush(bool closing)
		{
			if (!_response.HeadersSent)
			{
				if (!flushHeaders(closing))
				{
					if (closing)
					{
						_response.CloseConnection = true;
					}
					return false;
				}
				_sendChunked = _response.SendChunked;
				_writeBody = (_sendChunked ? _writeChunked : _write);
			}
			flushBody(closing);
			if (closing && _sendChunked)
			{
				byte[] chunkSizeBytes = getChunkSizeBytes(0, final: true);
				_write(chunkSizeBytes, 0, chunkSizeBytes.Length);
			}
			return true;
		}

		private void flushBody(bool closing)
		{
			using (_body)
			{
				long length = _body.Length;
				if (length > int.MaxValue)
				{
					_body.Position = 0L;
					int num = 1024;
					byte[] array = new byte[num];
					int num2 = 0;
					while ((num2 = _body.Read(array, 0, num)) > 0)
					{
						_writeBody(array, 0, num2);
					}
				}
				else if (length > 0)
				{
					_writeBody(_body.GetBuffer(), 0, (int)length);
				}
			}
			_body = ((!closing) ? new MemoryStream() : null);
		}

		private bool flushHeaders(bool closing)
		{
			using (MemoryStream memoryStream = new MemoryStream())
			{
				WebHeaderCollection webHeaderCollection = _response.WriteHeadersTo(memoryStream);
				long position = memoryStream.Position;
				long num = memoryStream.Length - position;
				if (num > 32768)
				{
					return false;
				}
				if (!_response.SendChunked && _response.ContentLength64 != _body.Length)
				{
					return false;
				}
				_write(memoryStream.GetBuffer(), (int)position, (int)num);
				_response.CloseConnection = webHeaderCollection["Connection"] == "close";
				_response.HeadersSent = true;
			}
			return true;
		}

		private static byte[] getChunkSizeBytes(int size, bool final)
		{
			return Encoding.ASCII.GetBytes(string.Format("{0:x}\r\n{1}", size, final ? "\r\n" : ""));
		}

		private void writeChunked(byte[] buffer, int offset, int count)
		{
			byte[] chunkSizeBytes = getChunkSizeBytes(count, final: false);
			_stream.Write(chunkSizeBytes, 0, chunkSizeBytes.Length);
			_stream.Write(buffer, offset, count);
			_stream.Write(_crlf, 0, 2);
		}

		private void writeChunkedWithoutThrowingException(byte[] buffer, int offset, int count)
		{
			try
			{
				writeChunked(buffer, offset, count);
			}
			catch
			{
			}
		}

		private void writeWithoutThrowingException(byte[] buffer, int offset, int count)
		{
			try
			{
				_stream.Write(buffer, offset, count);
			}
			catch
			{
			}
		}

		internal void Close(bool force)
		{
			if (_disposed)
			{
				return;
			}
			_disposed = true;
			if (!force && flush(closing: true))
			{
				_response.Close();
			}
			else
			{
				if (_sendChunked)
				{
					byte[] chunkSizeBytes = getChunkSizeBytes(0, final: true);
					_write(chunkSizeBytes, 0, chunkSizeBytes.Length);
				}
				_body.Dispose();
				_body = null;
				_response.Abort();
			}
			_response = null;
			_stream = null;
		}

		internal void InternalWrite(byte[] buffer, int offset, int count)
		{
			_write(buffer, offset, count);
		}

		public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			throw new NotSupportedException();
		}

		public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			return _body.BeginWrite(buffer, offset, count, callback, state);
		}

		public override void Close()
		{
			Close(force: false);
		}

		protected override void Dispose(bool disposing)
		{
			Close(!disposing);
		}

		public override int EndRead(IAsyncResult asyncResult)
		{
			throw new NotSupportedException();
		}

		public override void EndWrite(IAsyncResult asyncResult)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			_body.EndWrite(asyncResult);
		}

		public override void Flush()
		{
			if (!_disposed && (_sendChunked || _response.SendChunked))
			{
				flush(closing: false);
			}
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			throw new NotSupportedException();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			_body.Write(buffer, offset, count);
		}
	}
	[Serializable]
	[ComVisible(true)]
	public class WebHeaderCollection : NameValueCollection, ISerializable
	{
		private static readonly Dictionary<string, HttpHeaderInfo> _headers;

		private bool _internallyUsed;

		private HttpHeaderType _state;

		internal HttpHeaderType State => _state;

		public override string[] AllKeys => base.AllKeys;

		public override int Count => base.Count;

		public string this[HttpRequestHeader header]
		{
			get
			{
				return Get(Convert(header));
			}
			set
			{
				Add(header, value);
			}
		}

		public string this[HttpResponseHeader header]
		{
			get
			{
				return Get(Convert(header));
			}
			set
			{
				Add(header, value);
			}
		}

		public override KeysCollection Keys => base.Keys;

		static WebHeaderCollection()
		{
			_headers = new Dictionary<string, HttpHeaderInfo>(StringComparer.InvariantCultureIgnoreCase)
			{
				{
					"Accept",
					new HttpHeaderInfo("Accept", HttpHeaderType.Request | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
				},
				{
					"AcceptCharset",
					new HttpHeaderInfo("Accept-Charset", HttpHeaderType.Request | HttpHeaderType.MultiValue)
				},
				{
					"AcceptEncoding",
					new HttpHeaderInfo("Accept-Encoding", HttpHeaderType.Request | HttpHeaderType.MultiValue)
				},
				{
					"AcceptLanguage",
					new HttpHeaderInfo("Accept-Language", HttpHeaderType.Request | HttpHeaderType.MultiValue)
				},
				{
					"AcceptRanges",
					new HttpHeaderInfo("Accept-Ranges", HttpHeaderType.Response | HttpHeaderType.MultiValue)
				},
				{
					"Age",
					new HttpHeaderInfo("Age", HttpHeaderType.Response)
				},
				{
					"Allow",
					new HttpHeaderInfo("Allow", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
				},
				{
					"Authorization",
					new HttpHeaderInfo("Authorization", HttpHeaderType.Request | HttpHeaderType.MultiValue)
				},
				{
					"CacheControl",
					new HttpHeaderInfo("Cache-Control", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
				},
				{
					"Connection",
					new HttpHeaderInfo("Connection", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
				},
				{
					"ContentEncoding",
					new HttpHeaderInfo("Content-Encoding", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
				},
				{
					"ContentLanguage",
					new HttpHeaderInfo("Content-Language", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
				},
				{
					"ContentLength",
					new HttpHeaderInfo("Content-Length", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted)
				},
				{
					"ContentLocation",
					new HttpHeaderInfo("Content-Location", HttpHeaderType.Request | HttpHeaderType.Response)
				},
				{
					"ContentMd5",
					new HttpHeaderInfo("Content-MD5", HttpHeaderType.Request | HttpHeaderType.Response)
				},
				{
					"ContentRange",
					new HttpHeaderInfo("Content-Range", HttpHeaderType.Request | HttpHeaderType.Response)
				},
				{
					"ContentType",
					new HttpHeaderInfo("Content-Type", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted)
				},
				{
					"Cookie",
					new HttpHeaderInfo("Cookie", HttpHeaderType.Request)
				},
				{
					"Cookie2",
					new HttpHeaderInfo("Cookie2", HttpHeaderType.Request)
				},
				{
					"Date",
					new HttpHeaderInfo("Date", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted)
				},
				{
					"Expect",
					new HttpHeaderInfo("Expect", HttpHeaderType.Request | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
				},
				{
					"Expires",
					new HttpHeaderInfo("Expires", HttpHeaderType.Request | HttpHeaderType.Response)
				},
				{
					"ETag",
					new HttpHeaderInfo("ETag", HttpHeaderType.Response)
				},
				{
					"From",
					new HttpHeaderInfo("From", HttpHeaderType.Request)
				},
				{
					"Host",
					new HttpHeaderInfo("Host", HttpHeaderType.Request | HttpHeaderType.Restricted)
				},
				{
					"IfMatch",
					new HttpHeaderInfo("If-Match", HttpHeaderType.Request | HttpHeaderType.MultiValue)
				},
				{
					"IfModifiedSince",
					new HttpHeaderInfo("If-Modified-Since", HttpHeaderType.Request | HttpHeaderType.Restricted)
				},
				{
					"IfNoneMatch",
					new HttpHeaderInfo("If-None-Match", HttpHeaderType.Request | HttpHeaderType.MultiValue)
				},
				{
					"IfRange",
					new HttpHeaderInfo("If-Range", HttpHeaderType.Request)
				},
				{
					"IfUnmodifiedSince",
					new HttpHeaderInfo("If-Unmodified-Since", HttpHeaderType.Request)
				},
				{
					"KeepAlive",
					new HttpHeaderInfo("Keep-Alive", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
				},
				{
					"LastModified",
					new HttpHeaderInfo("Last-Modified", HttpHeaderType.Request | HttpHeaderType.Response)
				},
				{
					"Location",
					new HttpHeaderInfo("Location", HttpHeaderType.Response)
				},
				{
					"MaxForwards",
					new HttpHeaderInfo("Max-Forwards", HttpHeaderType.Request)
				},
				{
					"Pragma",
					new HttpHeaderInfo("Pragma", HttpHeaderType.Request | HttpHeaderType.Response)
				},
				{
					"ProxyAuthenticate",
					new HttpHeaderInfo("Proxy-Authenticate", HttpHeaderType.Response | HttpHeaderType.MultiValue)
				},
				{
					"ProxyAuthorization",
					new HttpHeaderInfo("Proxy-Authorization", HttpHeaderType.Request)
				},
				{
					"ProxyConnection",
					new HttpHeaderInfo("Proxy-Connection", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted)
				},
				{
					"Public",
					new HttpHeaderInfo("Public", HttpHeaderType.Response | HttpHeaderType.MultiValue)
				},
				{
					"Range",
					new HttpHeaderInfo("Range", HttpHeaderType.Request | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
				},
				{
					"Referer",
					new HttpHeaderInfo("Referer", HttpHeaderType.Request | HttpHeaderType.Restricted)
				},
				{
					"RetryAfter",
					new HttpHeaderInfo("Retry-After", HttpHeaderType.Response)
				},
				{
					"SecWebSocketAccept",
					new HttpHeaderInfo("Sec-WebSocket-Accept", HttpHeaderType.Response | HttpHeaderType.Restricted)
				},
				{
					"SecWebSocketExtensions",
					new HttpHeaderInfo("Sec-WebSocket-Extensions", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValueInRequest)
				},
				{
					"SecWebSocketKey",
					new HttpHeaderInfo("Sec-WebSocket-Key", HttpHeaderType.Request | HttpHeaderType.Restricted)
				},
				{
					"SecWebSocketProtocol",
					new HttpHeaderInfo("Sec-WebSocket-Protocol", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValueInRequest)
				},
				{
					"SecWebSocketVersion",
					new HttpHeaderInfo("Sec-WebSocket-Version", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValueInResponse)
				},
				{
					"Server",
					new HttpHeaderInfo("Server", HttpHeaderType.Response)
				},
				{
					"SetCookie",
					new HttpHeaderInfo("Set-Cookie", HttpHeaderType.Response | HttpHeaderType.MultiValue)
				},
				{
					"SetCookie2",
					new HttpHeaderInfo("Set-Cookie2", HttpHeaderType.Response | HttpHeaderType.MultiValue)
				},
				{
					"Te",
					new HttpHeaderInfo("TE", HttpHeaderType.Request)
				},
				{
					"Trailer",
					new HttpHeaderInfo("Trailer", HttpHeaderType.Request | HttpHeaderType.Response)
				},
				{
					"TransferEncoding",
					new HttpHeaderInfo("Transfer-Encoding", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
				},
				{
					"Translate",
					new HttpHeaderInfo("Translate", HttpHeaderType.Request)
				},
				{
					"Upgrade",
					new HttpHeaderInfo("Upgrade", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
				},
				{
					"UserAgent",
					new HttpHeaderInfo("User-Agent", HttpHeaderType.Request | HttpHeaderType.Restricted)
				},
				{
					"Vary",
					new HttpHeaderInfo("Vary", HttpHeaderType.Response | HttpHeaderType.MultiValue)
				},
				{
					"Via",
					new HttpHeaderInfo("Via", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
				},
				{
					"Warning",
					new HttpHeaderInfo("Warning", HttpHeaderType.Request | HttpHeaderType.Response | HttpHeaderType.MultiValue)
				},
				{
					"WwwAuthenticate",
					new HttpHeaderInfo("WWW-Authenticate", HttpHeaderType.Response | HttpHeaderType.Restricted | HttpHeaderType.MultiValue)
				}
			};
		}

		internal WebHeaderCollection(HttpHeaderType state, bool internallyUsed)
		{
			_state = state;
			_internallyUsed = internallyUsed;
		}

		protected WebHeaderCollection(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			if (serializationInfo == null)
			{
				throw new ArgumentNullException("serializationInfo");
			}
			try
			{
				_internallyUsed = serializationInfo.GetBoolean("InternallyUsed");
				_state = (HttpHeaderType)serializationInfo.GetInt32("State");
				int @int = serializationInfo.GetInt32("Count");
				for (int i = 0; i < @int; i++)
				{
					base.Add(serializationInfo.GetString(i.ToString()), serializationInfo.GetString((@int + i).ToString()));
				}
			}
			catch (SerializationException ex)
			{
				throw new ArgumentException(ex.Message, "serializationInfo", ex);
			}
		}

		public WebHeaderCollection()
		{
		}

		private void add(string name, string value, bool ignoreRestricted)
		{
			Action<string, string> action = (ignoreRestricted ? new Action<string, string>(addWithoutCheckingNameAndRestricted) : new Action<string, string>(addWithoutCheckingName));
			doWithCheckingState(action, checkName(name), value, setState: true);
		}

		private void addWithoutCheckingName(string name, string value)
		{
			doWithoutCheckingName(base.Add, name, value);
		}

		private void addWithoutCheckingNameAndRestricted(string name, string value)
		{
			base.Add(name, checkValue(value));
		}

		private static int checkColonSeparated(string header)
		{
			int num = header.IndexOf(':');
			if (num == -1)
			{
				throw new ArgumentException("No colon could be found.", "header");
			}
			return num;
		}

		private static HttpHeaderType checkHeaderType(string name)
		{
			HttpHeaderInfo headerInfo = getHeaderInfo(name);
			return (headerInfo != null) ? ((headerInfo.IsRequest && !headerInfo.IsResponse) ? HttpHeaderType.Request : ((!headerInfo.IsRequest && headerInfo.IsResponse) ? HttpHeaderType.Response : HttpHeaderType.Unspecified)) : HttpHeaderType.Unspecified;
		}

		private static string checkName(string name)
		{
			if (name == null || name.Length == 0)
			{
				throw new ArgumentNullException("name");
			}
			name = name.Trim();
			if (!IsHeaderName(name))
			{
				throw new ArgumentException("Contains invalid characters.", "name");
			}
			return name;
		}

		private void checkRestricted(string name)
		{
			if (!_internallyUsed && isRestricted(name, response: true))
			{
				throw new ArgumentException("This header must be modified with the appropiate property.");
			}
		}

		private void checkState(bool response)
		{
			if (_state != HttpHeaderType.Unspecified)
			{
				if (response && _state == HttpHeaderType.Request)
				{
					throw new InvalidOperationException("This collection has already been used to store the request headers.");
				}
				if (!response && _state == HttpHeaderType.Response)
				{
					throw new InvalidOperationException("This collection has already been used to store the response headers.");
				}
			}
		}

		private static string checkValue(string value)
		{
			if (value == null || value.Length == 0)
			{
				return string.Empty;
			}
			value = value.Trim();
			if (value.Length > 65535)
			{
				throw new ArgumentOutOfRangeException("value", "Greater than 65,535 characters.");
			}
			if (!IsHeaderValue(value))
			{
				throw new ArgumentException("Contains invalid characters.", "value");
			}
			return value;
		}

		private static string convert(string key)
		{
			HttpHeaderInfo value;
			return _headers.TryGetValue(key, out value) ? value.Name : string.Empty;
		}

		private void doWithCheckingState(Action<string, string> action, string name, string value, bool setState)
		{
			switch (checkHeaderType(name))
			{
			case HttpHeaderType.Request:
				doWithCheckingState(action, name, value, response: false, setState);
				break;
			case HttpHeaderType.Response:
				doWithCheckingState(action, name, value, response: true, setState);
				break;
			default:
				action(name, value);
				break;
			}
		}

		private void doWithCheckingState(Action<string, string> action, string name, string value, bool response, bool setState)
		{
			checkState(response);
			action(name, value);
			if (setState && _state == HttpHeaderType.Unspecified)
			{
				_state = ((!response) ? HttpHeaderType.Request : HttpHeaderType.Response);
			}
		}

		private void doWithoutCheckingName(Action<string, string> action, string name, string value)
		{
			checkRestricted(name);
			action(name, checkValue(value));
		}

		private static HttpHeaderInfo getHeaderInfo(string name)
		{
			foreach (HttpHeaderInfo value in _headers.Values)
			{
				if (value.Name.Equals(name, StringComparison.InvariantCultureIgnoreCase))
				{
					return value;
				}
			}
			return null;
		}

		private static bool isRestricted(string name, bool response)
		{
			return getHeaderInfo(name)?.IsRestricted(response) ?? false;
		}

		private void removeWithoutCheckingName(string name, string unuse)
		{
			checkRestricted(name);
			base.Remove(name);
		}

		private void setWithoutCheckingName(string name, string value)
		{
			doWithoutCheckingName(base.Set, name, value);
		}

		internal static string Convert(HttpRequestHeader header)
		{
			return convert(header.ToString());
		}

		internal static string Convert(HttpResponseHeader header)
		{
			return convert(header.ToString());
		}

		internal void InternalRemove(string name)
		{
			base.Remove(name);
		}

		internal void InternalSet(string header, bool response)
		{
			int num = checkColonSeparated(header);
			InternalSet(header.Substring(0, num), header.Substring(num + 1), response);
		}

		internal void InternalSet(string name, string value, bool response)
		{
			value = checkValue(value);
			if (IsMultiValue(name, response))
			{
				base.Add(name, value);
			}
			else
			{
				base.Set(name, value);
			}
		}

		internal static bool IsHeaderName(string name)
		{
			return name != null && name.Length > 0 && name.IsToken();
		}

		internal static bool IsHeaderValue(string value)
		{
			return value.IsText();
		}

		internal static bool IsMultiValue(string headerName, bool response)
		{
			if (headerName == null || headerName.Length == 0)
			{
				return false;
			}
			return getHeaderInfo(headerName)?.IsMultiValue(response) ?? false;
		}

		internal string ToStringMultiValue(bool response)
		{
			StringBuilder buff = new StringBuilder();
			Count.Times(delegate(int i)
			{
				string key = GetKey(i);
				if (IsMultiValue(key, response))
				{
					string[] values = GetValues(i);
					foreach (string arg in values)
					{
						buff.AppendFormat("{0}: {1}\r\n", key, arg);
					}
				}
				else
				{
					buff.AppendFormat("{0}: {1}\r\n", key, Get(i));
				}
			});
			return buff.Append("\r\n").ToString();
		}

		protected void AddWithoutValidate(string headerName, string headerValue)
		{
			add(headerName, headerValue, ignoreRestricted: true);
		}

		public void Add(string header)
		{
			if (header == null || header.Length == 0)
			{
				throw new ArgumentNullException("header");
			}
			int num = checkColonSeparated(header);
			add(header.Substring(0, num), header.Substring(num + 1), ignoreRestricted: false);
		}

		public void Add(HttpRequestHeader header, string value)
		{
			doWithCheckingState(addWithoutCheckingName, Convert(header), value, response: false, setState: true);
		}

		public void Add(HttpResponseHeader header, string value)
		{
			doWithCheckingState(addWithoutCheckingName, Convert(header), value, response: true, setState: true);
		}

		public override void Add(string name, string value)
		{
			add(name, value, ignoreRestricted: false);
		}

		public override void Clear()
		{
			base.Clear();
			_state = HttpHeaderType.Unspecified;
		}

		public override string Get(int index)
		{
			return base.Get(index);
		}

		public override string Get(string name)
		{
			return base.Get(name);
		}

		public override IEnumerator GetEnumerator()
		{
			return base.GetEnumerator();
		}

		public override string GetKey(int index)
		{
			return base.GetKey(index);
		}

		public override string[] GetValues(int index)
		{
			string[] values = base.GetValues(index);
			return (values != null && values.Length != 0) ? values : null;
		}

		public override string[] GetValues(string header)
		{
			string[] values = base.GetValues(header);
			return (values != null && values.Length != 0) ? values : null;
		}

		[SecurityPermission(System.Security.Permissions.SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		public override void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			if (serializationInfo == null)
			{
				throw new ArgumentNullException("serializationInfo");
			}
			serializationInfo.AddValue("InternallyUsed", _internallyUsed);
			serializationInfo.AddValue("State", (int)_state);
			int cnt = Count;
			serializationInfo.AddValue("Count", cnt);
			cnt.Times(delegate(int i)
			{
				serializationInfo.AddValue(i.ToString(), GetKey(i));
				serializationInfo.AddValue((cnt + i).ToString(), Get(i));
			});
		}

		public static bool IsRestricted(string headerName)
		{
			return isRestricted(checkName(headerName), response: false);
		}

		public static bool IsRestricted(string headerName, bool response)
		{
			return isRestricted(checkName(headerName), response);
		}

		public override void OnDeserialization(object sender)
		{
		}

		public void Remove(HttpRequestHeader header)
		{
			doWithCheckingState(removeWithoutCheckingName, Convert(header), null, response: false, setState: false);
		}

		public void Remove(HttpResponseHeader header)
		{
			doWithCheckingState(removeWithoutCheckingName, Convert(header), null, response: true, setState: false);
		}

		public override void Remove(string name)
		{
			doWithCheckingState(removeWithoutCheckingName, checkName(name), null, setState: false);
		}

		public void Set(HttpRequestHeader header, string value)
		{
			doWithCheckingState(setWithoutCheckingName, Convert(header), value, response: false, setState: true);
		}

		public void Set(HttpResponseHeader header, string value)
		{
			doWithCheckingState(setWithoutCheckingName, Convert(header), value, response: true, setState: true);
		}

		public override void Set(string name, string value)
		{
			doWithCheckingState(setWithoutCheckingName, checkName(name), value, setState: true);
		}

		public byte[] ToByteArray()
		{
			return Encoding.UTF8.GetBytes(ToString());
		}

		public override string ToString()
		{
			StringBuilder buff = new StringBuilder();
			Count.Times(delegate(int i)
			{
				buff.AppendFormat("{0}: {1}\r\n", GetKey(i), Get(i));
			});
			return buff.Append("\r\n").ToString();
		}

		[SecurityPermission(System.Security.Permissions.SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter, SerializationFormatter = true)]
		void ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			GetObjectData(serializationInfo, streamingContext);
		}
	}
	public class HttpVersion
	{
		public static readonly Version Version10 = new Version(1, 0);

		public static readonly Version Version11 = new Version(1, 1);
	}
	public enum HttpStatusCode
	{
		Continue = 100,
		SwitchingProtocols = 101,
		OK = 200,
		Created = 201,
		Accepted = 202,
		NonAuthoritativeInformation = 203,
		NoContent = 204,
		ResetContent = 205,
		PartialContent = 206,
		MultipleChoices = 300,
		Ambiguous = 300,
		MovedPermanently = 301,
		Moved = 301,
		Found = 302,
		Redirect = 302,
		SeeOther = 303,
		RedirectMethod = 303,
		NotModified = 304,
		UseProxy = 305,
		Unused = 306,
		TemporaryRedirect = 307,
		RedirectKeepVerb = 307,
		BadRequest = 400,
		Unauthorized = 401,
		PaymentRequired = 402,
		Forbidden = 403,
		NotFound = 404,
		MethodNotAllowed = 405,
		NotAcceptable = 406,
		ProxyAuthenticationRequired = 407,
		RequestTimeout = 408,
		Conflict = 409,
		Gone = 410,
		LengthRequired = 411,
		PreconditionFailed = 412,
		RequestEntityTooLarge = 413,
		RequestUriTooLong = 414,
		UnsupportedMediaType = 415,
		RequestedRangeNotSatisfiable = 416,
		ExpectationFailed = 417,
		InternalServerError = 500,
		NotImplemented = 501,
		BadGateway = 502,
		ServiceUnavailable = 503,
		GatewayTimeout = 504,
		HttpVersionNotSupported = 505
	}
	[Flags]
	internal enum HttpHeaderType
	{
		Unspecified = 0,
		Request = 1,
		Response = 2,
		Restricted = 4,
		MultiValue = 8,
		MultiValueInRequest = 0x10,
		MultiValueInResponse = 0x20
	}
	internal class HttpHeaderInfo
	{
		private string _name;

		private HttpHeaderType _type;

		internal bool IsMultiValueInRequest => (_type & HttpHeaderType.MultiValueInRequest) == HttpHeaderType.MultiValueInRequest;

		internal bool IsMultiValueInResponse => (_type & HttpHeaderType.MultiValueInResponse) == HttpHeaderType.MultiValueInResponse;

		public bool IsRequest => (_type & HttpHeaderType.Request) == HttpHeaderType.Request;

		public bool IsResponse => (_type & HttpHeaderType.Response) == HttpHeaderType.Response;

		public string Name => _name;

		public HttpHeaderType Type => _type;

		internal HttpHeaderInfo(string name, HttpHeaderType type)
		{
			_name = name;
			_type = type;
		}

		public bool IsMultiValue(bool response)
		{
			return ((_type & HttpHeaderType.MultiValue) != HttpHeaderType.MultiValue) ? (response ? IsMultiValueInResponse : IsMultiValueInRequest) : (response ? IsResponse : IsRequest);
		}

		public bool IsRestricted(bool response)
		{
			return (_type & HttpHeaderType.Restricted) == HttpHeaderType.Restricted && (response ? IsResponse : IsRequest);
		}
	}
	public class HttpBasicIdentity : GenericIdentity
	{
		private string _password;

		public virtual string Password => _password;

		internal HttpBasicIdentity(string username, string password)
			: base(username, "Basic")
		{
			_password = password;
		}
	}
	public class HttpDigestIdentity : GenericIdentity
	{
		private NameValueCollection _parameters;

		public string Algorithm => _parameters["algorithm"];

		public string Cnonce => _parameters["cnonce"];

		public string Nc => _parameters["nc"];

		public string Nonce => _parameters["nonce"];

		public string Opaque => _parameters["opaque"];

		public string Qop => _parameters["qop"];

		public string Realm => _parameters["realm"];

		public string Response => _parameters["response"];

		public string Uri => _parameters["uri"];

		internal HttpDigestIdentity(NameValueCollection parameters)
			: base(parameters["username"], "Digest")
		{
			_parameters = parameters;
		}

		internal bool IsValid(string password, string realm, string method, string entity)
		{
			NameValueCollection nameValueCollection = new NameValueCollection(_parameters);
			nameValueCollection["password"] = password;
			nameValueCollection["realm"] = realm;
			nameValueCollection["method"] = method;
			nameValueCollection["entity"] = entity;
			return _parameters["response"] == AuthenticationResponse.CreateRequestDigest(nameValueCollection);
		}
	}
	public class NetworkCredential
	{
		private string _domain;

		private string _password;

		private string[] _roles;

		private string _userName;

		public string Domain
		{
			get
			{
				return _domain ?? string.Empty;
			}
			internal set
			{
				_domain = value;
			}
		}

		public string Password
		{
			get
			{
				return _password ?? string.Empty;
			}
			internal set
			{
				_password = value;
			}
		}

		public string[] Roles
		{
			get
			{
				return _roles ?? (_roles = new string[0]);
			}
			internal set
			{
				_roles = value;
			}
		}

		public string UserName
		{
			get
			{
				return _userName;
			}
			internal set
			{
				_userName = value;
			}
		}

		public NetworkCredential(string userName, string password)
			: this(userName, password, (string)null, (string[])null)
		{
		}

		public NetworkCredential(string userName, string password, string domain, params string[] roles)
		{
			if (userName == null)
			{
				throw new ArgumentNullException("userName");
			}
			if (userName.Length == 0)
			{
				throw new ArgumentException("An empty string.", "userName");
			}
			_userName = userName;
			_password = password;
			_domain = domain;
			_roles = roles;
		}
	}
	internal enum InputState
	{
		RequestLine,
		Headers
	}
	internal enum LineState
	{
		None,
		Cr,
		Lf
	}
	internal class ReadBufferState
	{
		private HttpStreamAsyncResult _asyncResult;

		private byte[] _buffer;

		private int _count;

		private int _initialCount;

		private int _offset;

		public HttpStreamAsyncResult AsyncResult
		{
			get
			{
				return _asyncResult;
			}
			set
			{
				_asyncResult = value;
			}
		}

		public byte[] Buffer
		{
			get
			{
				return _buffer;
			}
			set
			{
				_buffer = value;
			}
		}

		public int Count
		{
			get
			{
				return _count;
			}
			set
			{
				_count = value;
			}
		}

		public int InitialCount
		{
			get
			{
				return _initialCount;
			}
			set
			{
				_initialCount = value;
			}
		}

		public int Offset
		{
			get
			{
				return _offset;
			}
			set
			{
				_offset = value;
			}
		}

		public ReadBufferState(byte[] buffer, int offset, int count, HttpStreamAsyncResult asyncResult)
		{
			_buffer = buffer;
			_offset = offset;
			_count = count;
			_initialCount = count;
			_asyncResult = asyncResult;
		}
	}
	internal class Chunk
	{
		private byte[] _data;

		private int _offset;

		public int ReadLeft => _data.Length - _offset;

		public Chunk(byte[] data)
		{
			_data = data;
		}

		public int Read(byte[] buffer, int offset, int count)
		{
			int num = _data.Length - _offset;
			if (num == 0)
			{
				return num;
			}
			if (count > num)
			{
				count = num;
			}
			Buffer.BlockCopy(_data, _offset, buffer, offset, count);
			_offset += count;
			return count;
		}
	}
	internal enum InputChunkState
	{
		None,
		Data,
		DataEnded,
		Trailer,
		End
	}
	internal class ChunkedRequestStream : RequestStream
	{
		private const int _bufferLength = 8192;

		private HttpListenerContext _context;

		private ChunkStream _decoder;

		private bool _disposed;

		private bool _noMoreData;

		internal ChunkStream Decoder
		{
			get
			{
				return _decoder;
			}
			set
			{
				_decoder = value;
			}
		}

		internal ChunkedRequestStream(Stream stream, byte[] buffer, int offset, int count, HttpListenerContext context)
			: base(stream, buffer, offset, count)
		{
			_context = context;
			_decoder = new ChunkStream((WebHeaderCollection)context.Request.Headers);
		}

		private void onRead(IAsyncResult asyncResult)
		{
			ReadBufferState readBufferState = (ReadBufferState)asyncResult.AsyncState;
			HttpStreamAsyncResult asyncResult2 = readBufferState.AsyncResult;
			try
			{
				int count = base.EndRead(asyncResult);
				_decoder.Write(asyncResult2.Buffer, asyncResult2.Offset, count);
				count = _decoder.Read(readBufferState.Buffer, readBufferState.Offset, readBufferState.Count);
				readBufferState.Offset += count;
				readBufferState.Count -= count;
				if (readBufferState.Count == 0 || !_decoder.WantMore || count == 0)
				{
					_noMoreData = !_decoder.WantMore && count == 0;
					asyncResult2.Count = readBufferState.InitialCount - readBufferState.Count;
					asyncResult2.Complete();
				}
				else
				{
					asyncResult2.Offset = 0;
					asyncResult2.Count = Math.Min(8192, _decoder.ChunkLeft + 6);
					base.BeginRead(asyncResult2.Buffer, asyncResult2.Offset, asyncResult2.Count, (AsyncCallback)onRead, (object)readBufferState);
				}
			}
			catch (Exception ex)
			{
				_context.Connection.SendError(ex.Message, 400);
				asyncResult2.Complete(ex);
			}
		}

		public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", "A negative value.");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", "A negative value.");
			}
			int num = buffer.Length;
			if (offset + count > num)
			{
				throw new ArgumentException("The sum of 'offset' and 'count' is greater than 'buffer' length.");
			}
			HttpStreamAsyncResult httpStreamAsyncResult = new HttpStreamAsyncResult(callback, state);
			if (_noMoreData)
			{
				httpStreamAsyncResult.Complete();
				return httpStreamAsyncResult;
			}
			int num2 = _decoder.Read(buffer, offset, count);
			offset += num2;
			count -= num2;
			if (count == 0)
			{
				httpStreamAsyncResult.Count = num2;
				httpStreamAsyncResult.Complete();
				return httpStreamAsyncResult;
			}
			if (!_decoder.WantMore)
			{
				_noMoreData = num2 == 0;
				httpStreamAsyncResult.Count = num2;
				httpStreamAsyncResult.Complete();
				return httpStreamAsyncResult;
			}
			httpStreamAsyncResult.Buffer = new byte[8192];
			httpStreamAsyncResult.Offset = 0;
			httpStreamAsyncResult.Count = 8192;
			ReadBufferState readBufferState = new ReadBufferState(buffer, offset, count, httpStreamAsyncResult);
			readBufferState.InitialCount += num2;
			base.BeginRead(httpStreamAsyncResult.Buffer, httpStreamAsyncResult.Offset, httpStreamAsyncResult.Count, (AsyncCallback)onRead, (object)readBufferState);
			return httpStreamAsyncResult;
		}

		public override void Close()
		{
			if (!_disposed)
			{
				_disposed = true;
				base.Close();
			}
		}

		public override int EndRead(IAsyncResult asyncResult)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(GetType().ToString());
			}
			if (asyncResult == null)
			{
				throw new ArgumentNullException("asyncResult");
			}
			if (!(asyncResult is HttpStreamAsyncResult httpStreamAsyncResult))
			{
				throw new ArgumentException("A wrong IAsyncResult.", "asyncResult");
			}
			if (!httpStreamAsyncResult.IsCompleted)
			{
				httpStreamAsyncResult.AsyncWaitHandle.WaitOne();
			}
			if (httpStreamAsyncResult.HasException)
			{
				throw new HttpListenerException(400, "I/O operation aborted.");
			}
			return httpStreamAsyncResult.Count;
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			IAsyncResult asyncResult = BeginRead(buffer, offset, count, null, null);
			return EndRead(asyncResult);
		}
	}
	internal sealed class QueryStringCollection : NameValueCollection
	{
		public override string ToString()
		{
			if (Count == 0)
			{
				return string.Empty;
			}
			StringBuilder stringBuilder = new StringBuilder();
			string[] allKeys = AllKeys;
			string[] array = allKeys;
			foreach (string text in array)
			{
				stringBuilder.AppendFormat("{0}={1}&", text, base[text]);
			}
			if (stringBuilder.Length > 0)
			{
				stringBuilder.Length--;
			}
			return stringBuilder.ToString();
		}
	}
	internal class AuthenticationChallenge : AuthenticationBase
	{
		public string Domain => Parameters["domain"];

		public string Stale => Parameters["stale"];

		private AuthenticationChallenge(AuthenticationSchemes scheme, NameValueCollection parameters)
			: base(scheme, parameters)
		{
		}

		internal AuthenticationChallenge(AuthenticationSchemes scheme, string realm)
			: base(scheme, new NameValueCollection())
		{
			Parameters["realm"] = realm;
			if (scheme == AuthenticationSchemes.Digest)
			{
				Parameters["nonce"] = AuthenticationBase.CreateNonceValue();
				Parameters["algorithm"] = "MD5";
				Parameters["qop"] = "auth";
			}
		}

		internal static AuthenticationChallenge CreateBasicChallenge(string realm)
		{
			return new AuthenticationChallenge(AuthenticationSchemes.Basic, realm);
		}

		internal static AuthenticationChallenge CreateDigestChallenge(string realm)
		{
			return new AuthenticationChallenge(AuthenticationSchemes.Digest, realm);
		}

		internal static AuthenticationChallenge Parse(string value)
		{
			string[] array = value.Split(new char[1] { ' ' }, 2);
			if (array.Length != 2)
			{
				return null;
			}
			string text = array[0].ToLower();
			return (text == "basic") ? new AuthenticationChallenge(AuthenticationSchemes.Basic, AuthenticationBase.ParseParameters(array[1])) : ((text == "digest") ? new AuthenticationChallenge(AuthenticationSchemes.Digest, AuthenticationBase.ParseParameters(array[1])) : null);
		}

		internal override string ToBasicString()
		{
			return string.Format("Basic realm=\"{0}\"", Parameters["realm"]);
		}

		internal override string ToDigestString()
		{
			StringBuilder stringBuilder = new StringBuilder(128);
			string text = Parameters["domain"];
			if (text != null)
			{
				stringBuilder.AppendFormat("Digest realm=\"{0}\", domain=\"{1}\", nonce=\"{2}\"", Parameters["realm"], text, Parameters["nonce"]);
			}
			else
			{
				stringBuilder.AppendFormat("Digest realm=\"{0}\", nonce=\"{1}\"", Parameters["realm"], Parameters["nonce"]);
			}
			string text2 = Parameters["opaque"];
			if (text2 != null)
			{
				stringBuilder.AppendFormat(", opaque=\"{0}\"", text2);
			}
			string text3 = Parameters["stale"];
			if (text3 != null)
			{
				stringBuilder.AppendFormat(", stale={0}", text3);
			}
			string text4 = Parameters["algorithm"];
			if (text4 != null)
			{
				stringBuilder.AppendFormat(", algorithm={0}", text4);
			}
			string text5 = Parameters["qop"];
			if (text5 != null)
			{
				stringBuilder.AppendFormat(", qop=\"{0}\"", text5);
			}
			return stringBuilder.ToString();
		}
	}
	internal class AuthenticationResponse : AuthenticationBase
	{
		private uint _nonceCount;

		internal uint NonceCount => (_nonceCount < uint.MaxValue) ? _nonceCount : 0u;

		public string Cnonce => Parameters["cnonce"];

		public string Nc => Parameters["nc"];

		public string Password => Parameters["password"];

		public string Response => Parameters["response"];

		public string Uri => Parameters["uri"];

		public string UserName => Parameters["username"];

		private AuthenticationResponse(AuthenticationSchemes scheme, NameValueCollection parameters)
			: base(scheme, parameters)
		{
		}

		internal AuthenticationResponse(NetworkCredential credentials)
			: this(AuthenticationSchemes.Basic, new NameValueCollection(), credentials, 0u)
		{
		}

		internal AuthenticationResponse(AuthenticationChallenge challenge, NetworkCredential credentials, uint nonceCount)
			: this(challenge.Scheme, challenge.Parameters, credentials, nonceCount)
		{
		}

		internal AuthenticationResponse(AuthenticationSchemes scheme, NameValueCollection parameters, NetworkCredential credentials, uint nonceCount)
			: base(scheme, parameters)
		{
			Parameters["username"] = credentials.UserName;
			Parameters["password"] = credentials.Password;
			Parameters["uri"] = credentials.Domain;
			_nonceCount = nonceCount;
			if (scheme == AuthenticationSchemes.Digest)
			{
				initAsDigest();
			}
		}

		private static string createA1(string username, string password, string realm)
		{
			return $"{username}:{realm}:{password}";
		}

		private static string createA1(string username, string password, string realm, string nonce, string cnonce)
		{
			return $"{hash(createA1(username, password, realm))}:{nonce}:{cnonce}";
		}

		private static string createA2(string method, string uri)
		{
			return $"{method}:{uri}";
		}

		private static string createA2(string method, string uri, string entity)
		{
			return $"{method}:{uri}:{hash(entity)}";
		}

		private static string hash(string value)
		{
			byte[] bytes = Encoding.UTF8.GetBytes(value);
			MD5 mD = MD5.Create();
			byte[] array = mD.ComputeHash(bytes);
			StringBuilder stringBuilder = new StringBuilder(64);
			byte[] array2 = array;
			foreach (byte b in array2)
			{
				stringBuilder.Append(b.ToString("x2"));
			}
			return stringBuilder.ToString();
		}

		private void initAsDigest()
		{
			string text = Parameters["qop"];
			if (text != null)
			{
				if (text.Split(new char[1] { ',' }).Contains((string qop) => qop.Trim().ToLower() == "auth"))
				{
					Parameters["qop"] = "auth";
					Parameters["cnonce"] = AuthenticationBase.CreateNonceValue();
					Parameters["nc"] = $"{++_nonceCount:x8}";
				}
				else
				{
					Parameters["qop"] = null;
				}
			}
			Parameters["method"] = "GET";
			Parameters["response"] = CreateRequestDigest(Parameters);
		}

		internal static string CreateRequestDigest(NameValueCollection parameters)
		{
			string username = parameters["username"];
			string password = parameters["password"];
			string realm = parameters["realm"];
			string text = parameters["nonce"];
			string uri = parameters["uri"];
			string text2 = parameters["algorithm"];
			string text3 = parameters["qop"];
			string text4 = parameters["cnonce"];
			string text5 = parameters["nc"];
			string method = parameters["method"];
			string value = ((text2 != null && text2.ToLower() == "md5-sess") ? createA1(username, password, realm, text, text4) : createA1(username, password, realm));
			string value2 = ((text3 != null && text3.ToLower() == "auth-int") ? createA2(method, uri, parameters["entity"]) : createA2(method, uri));
			string arg = hash(value);
			string arg2 = ((text3 != null) ? $"{text}:{text5}:{text4}:{text3}:{hash(value2)}" : $"{text}:{hash(value2)}");
			return hash($"{arg}:{arg2}");
		}

		internal static AuthenticationResponse Parse(string value)
		{
			try
			{
				string[] array = value.Split(new char[1] { ' ' }, 2);
				if (array.Length != 2)
				{
					return null;
				}
				string text = array[0].ToLower();
				return (text == "basic") ? new AuthenticationResponse(AuthenticationSchemes.Basic, ParseBasicCredentials(array[1])) : ((text == "digest") ? new AuthenticationResponse(AuthenticationSchemes.Digest, AuthenticationBase.ParseParameters(array[1])) : null);
			}
			catch
			{
			}
			return null;
		}

		internal static NameValueCollection ParseBasicCredentials(string value)
		{
			string text = Encoding.Default.GetString(Convert.FromBase64String(value));
			int num = text.IndexOf(':');
			string text2 = text.Substring(0, num);
			string value2 = ((num < text.Length - 1) ? text.Substring(num + 1) : string.Empty);
			num = text2.IndexOf('\\');
			if (num > -1)
			{
				text2 = text2.Substring(num + 1);
			}
			NameValueCollection nameValueCollection = new NameValueCollection();
			nameValueCollection["username"] = text2;
			nameValueCollection["password"] = value2;
			return nameValueCollection;
		}

		internal override string ToBasicString()
		{
			string s = string.Format("{0}:{1}", Parameters["username"], Parameters["password"]);
			string text = Convert.ToBase64String(Encoding.UTF8.GetBytes(s));
			return "Basic " + text;
		}

		internal override string ToDigestString()
		{
			StringBuilder stringBuilder = new StringBuilder(256);
			stringBuilder.AppendFormat("Digest username=\"{0}\", realm=\"{1}\", nonce=\"{2}\", uri=\"{3}\", response=\"{4}\"", Parameters["username"], Parameters["realm"], Parameters["nonce"], Parameters["uri"], Parameters["response"]);
			string text = Parameters["opaque"];
			if (text != null)
			{
				stringBuilder.AppendFormat(", opaque=\"{0}\"", text);
			}
			string text2 = Parameters["algorithm"];
			if (text2 != null)
			{
				stringBuilder.AppendFormat(", algorithm={0}", text2);
			}
			string text3 = Parameters["qop"];
			if (text3 != null)
			{
				stringBuilder.AppendFormat(", qop={0}, cnonce=\"{1}\", nc={2}", text3, Parameters["cnonce"], Parameters["nc"]);
			}
			return stringBuilder.ToString();
		}

		public IIdentity ToIdentity()
		{
			AuthenticationSchemes scheme = base.Scheme;
			IIdentity result;
			if (scheme != AuthenticationSchemes.Basic)
			{
				IIdentity identity = ((scheme == AuthenticationSchemes.Digest) ? new HttpDigestIdentity(Parameters) : null);
				result = identity;
			}
			else
			{
				IIdentity identity = new HttpBasicIdentity(Parameters["username"], Parameters["password"]);
				result = identity;
			}
			return result;
		}
	}
	internal abstract class AuthenticationBase
	{
		private AuthenticationSchemes _scheme;

		internal NameValueCollection Parameters;

		public string Algorithm => Parameters["algorithm"];

		public string Nonce => Parameters["nonce"];

		public string Opaque => Parameters["opaque"];

		public string Qop => Parameters["qop"];

		public string Realm => Parameters["realm"];

		public AuthenticationSchemes Scheme => _scheme;

		protected AuthenticationBase(AuthenticationSchemes scheme, NameValueCollection parameters)
		{
			_scheme = scheme;
			Parameters = parameters;
		}

		internal static string CreateNonceValue()
		{
			byte[] array = new byte[16];
			System.Random random = new System.Random();
			random.NextBytes(array);
			StringBuilder stringBuilder = new StringBuilder(32);
			byte[] array2 = array;
			foreach (byte b in array2)
			{
				stringBuilder.Append(b.ToString("x2"));
			}
			return stringBuilder.ToString();
		}

		internal static NameValueCollection ParseParameters(string value)
		{
			NameValueCollection nameValueCollection = new NameValueCollection();
			foreach (string item in value.SplitHeaderValue(','))
			{
				int num = item.IndexOf('=');
				string name = ((num > 0) ? item.Substring(0, num).Trim() : null);
				string value2 = ((num < 0) ? item.Trim().Trim(new char[1] { '"' }) : ((num < item.Length - 1) ? item.Substring(num + 1).Trim().Trim(new char[1] { '"' }) : string.Empty));
				nameValueCollection.Add(name, value2);
			}
			return nameValueCollection;
		}

		internal abstract string ToBasicString();

		internal abstract string ToDigestString();

		public override string ToString()
		{
			return (_scheme == AuthenticationSchemes.Basic) ? ToBasicString() : ((_scheme == AuthenticationSchemes.Digest) ? ToDigestString() : string.Empty);
		}
	}
	internal sealed class HttpListenerPrefix
	{
		private string _host;

		private HttpListener _listener;

		private string _original;

		private string _path;

		private string _port;

		private string _prefix;

		private bool _secure;

		public string Host => _host;

		public bool IsSecure => _secure;

		public HttpListener Listener
		{
			get
			{
				return _listener;
			}
			set
			{
				_listener = value;
			}
		}

		public string Original => _original;

		public string Path => _path;

		public string Port => _port;

		internal HttpListenerPrefix(string uriPrefix)
		{
			_original = uriPrefix;
			parse(uriPrefix);
		}

		private void parse(string uriPrefix)
		{
			if (uriPrefix.StartsWith("https"))
			{
				_secure = true;
			}
			int length = uriPrefix.Length;
			int num = uriPrefix.IndexOf(':') + 3;
			int num2 = uriPrefix.IndexOf('/', num + 1, length - num - 1);
			int num3 = uriPrefix.LastIndexOf(':', num2 - 1, num2 - num - 1);
			if (uriPrefix[num2 - 1] != ']' && num3 > num)
			{
				_host = uriPrefix.Substring(num, num3 - num);
				_port = uriPrefix.Substring(num3 + 1, num2 - num3 - 1);
			}
			else
			{
				_host = uriPrefix.Substring(num, num2 - num);
				_port = (_secure ? "443" : "80");
			}
			_path = uriPrefix.Substring(num2);
			_prefix = string.Format("http{0}://{1}:{2}{3}", _secure ? "s" : "", _host, _port, _path);
		}

		public static void CheckPrefix(string uriPrefix)
		{
			if (uriPrefix == null)
			{
				throw new ArgumentNullException("uriPrefix");
			}
			int length = uriPrefix.Length;
			if (length == 0)
			{
				throw new ArgumentException("An empty string.", "uriPrefix");
			}
			if (!uriPrefix.StartsWith("http://") && !uriPrefix.StartsWith("https://"))
			{
				throw new ArgumentException("The scheme isn't 'http' or 'https'.", "uriPrefix");
			}
			int num = uriPrefix.IndexOf(':') + 3;
			if (num >= length)
			{
				throw new ArgumentException("No host is specified.", "uriPrefix");
			}
			if (uriPrefix[num] == ':')
			{
				throw new ArgumentException("No host is specified.", "uriPrefix");
			}
			int num2 = uriPrefix.IndexOf('/', num, length - num);
			if (num2 == num)
			{
				throw new ArgumentException("No host is specified.", "uriPrefix");
			}
			if (num2 == -1 || uriPrefix[length - 1] != '/')
			{
				throw new ArgumentException("Ends without '/'.", "uriPrefix");
			}
			if (uriPrefix[num2 - 1] == ':')
			{
				throw new ArgumentException("No port is specified.", "uriPrefix");
			}
			if (num2 == length - 2)
			{
				throw new ArgumentException("No path is specified.", "uriPrefix");
			}
		}

		public override bool Equals(object obj)
		{
			return obj is HttpListenerPrefix httpListenerPrefix && httpListenerPrefix._prefix == _prefix;
		}

		public override int GetHashCode()
		{
			return _prefix.GetHashCode();
		}

		public override string ToString()
		{
			return _prefix;
		}
	}
	public class ClientSslConfiguration : SslConfiguration
	{
		private X509CertificateCollection _certs;

		private string _host;

		public X509CertificateCollection ClientCertificates
		{
			get
			{
				return _certs;
			}
			set
			{
				_certs = value;
			}
		}

		public LocalCertificateSelectionCallback ClientCertificateSelectionCallback
		{
			get
			{
				return base.CertificateSelectionCallback;
			}
			set
			{
				base.CertificateSelectionCallback = value;
			}
		}

		public RemoteCertificateValidationCallback ServerCertificateValidationCallback
		{
			get
			{
				return base.CertificateValidationCallback;
			}
			set
			{
				base.CertificateValidationCallback = value;
			}
		}

		public string TargetHost
		{
			get
			{
				return _host;
			}
			set
			{
				_host = value;
			}
		}

		public ClientSslConfiguration(string targetHost)
			: this(targetHost, null, SslProtocols.Default, checkCertificateRevocation: false)
		{
		}

		public ClientSslConfiguration(string targetHost, X509CertificateCollection clientCertificates, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
			: base(enabledSslProtocols, checkCertificateRevocation)
		{
			_host = targetHost;
			_certs = clientCertificates;
		}
	}
	public class ServerSslConfiguration : SslConfiguration
	{
		private X509Certificate2 _cert;

		private bool _clientCertRequired;

		public bool ClientCertificateRequired
		{
			get
			{
				return _clientCertRequired;
			}
			set
			{
				_clientCertRequired = value;
			}
		}

		public RemoteCertificateValidationCallback ClientCertificateValidationCallback
		{
			get
			{
				return base.CertificateValidationCallback;
			}
			set
			{
				base.CertificateValidationCallback = value;
			}
		}

		public X509Certificate2 ServerCertificate
		{
			get
			{
				return _cert;
			}
			set
			{
				_cert = value;
			}
		}

		public ServerSslConfiguration(X509Certificate2 serverCertificate)
			: this(serverCertificate, clientCertificateRequired: false, SslProtocols.Default, checkCertificateRevocation: false)
		{
		}

		public ServerSslConfiguration(X509Certificate2 serverCertificate, bool clientCertificateRequired, SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
			: base(enabledSslProtocols, checkCertificateRevocation)
		{
			_cert = serverCertificate;
			_clientCertRequired = clientCertificateRequired;
		}
	}
	public abstract class SslConfiguration
	{
		private LocalCertificateSelectionCallback _certSelectionCallback;

		private RemoteCertificateValidationCallback _certValidationCallback;

		private bool _checkCertRevocation;

		private SslProtocols _enabledProtocols;

		protected LocalCertificateSelectionCallback CertificateSelectionCallback
		{
			get
			{
				return (object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, string[] acceptableIssuers) => (X509Certificate)null;
			}
			set
			{
				_certSelectionCallback = value;
			}
		}

		protected RemoteCertificateValidationCallback CertificateValidationCallback
		{
			get
			{
				return (object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors) => true;
			}
			set
			{
				_certValidationCallback = value;
			}
		}

		public bool CheckCertificateRevocation
		{
			get
			{
				return _checkCertRevocation;
			}
			set
			{
				_checkCertRevocation = value;
			}
		}

		public SslProtocols EnabledSslProtocols
		{
			get
			{
				return _enabledProtocols;
			}
			set
			{
				_enabledProtocols = value;
			}
		}

		protected SslConfiguration(SslProtocols enabledSslProtocols, bool checkCertificateRevocation)
		{
			_enabledProtocols = enabledSslProtocols;
			_checkCertRevocation = checkCertificateRevocation;
		}
	}
	internal class HttpListenerAsyncResult : IAsyncResult
	{
		private AsyncCallback _callback;

		private bool _completed;

		private HttpListenerContext _context;

		private bool _endCalled;

		private Exception _exception;

		private bool _inGet;

		private object _state;

		private object _sync;

		private bool _syncCompleted;

		private ManualResetEvent _waitHandle;

		internal bool EndCalled
		{
			get
			{
				return _endCalled;
			}
			set
			{
				_endCalled = value;
			}
		}

		internal bool InGet
		{
			get
			{
				return _inGet;
			}
			set
			{
				_inGet = value;
			}
		}

		public object AsyncState => _state;

		public WaitHandle AsyncWaitHandle
		{
			get
			{
				lock (_sync)
				{
					return _waitHandle ?? (_waitHandle = new ManualResetEvent(_completed));
				}
			}
		}

		public bool CompletedSynchronously => _syncCompleted;

		public bool IsCompleted
		{
			get
			{
				lock (_sync)
				{
					return _completed;
				}
			}
		}

		internal HttpListenerAsyncResult(AsyncCallback callback, object state)
		{
			_callback = callback;
			_state = state;
			_sync = new object();
		}

		private static void complete(HttpListenerAsyncResult asyncResult)
		{
			lock (asyncResult._sync)
			{
				asyncResult._completed = true;
				asyncResult._waitHandle?.Set();
			}
			AsyncCallback callback = asyncResult._callback;
			if (callback == null)
			{
				return;
			}
			ThreadPool.QueueUserWorkItem(delegate
			{
				try
				{
					callback(asyncResult);
				}
				catch
				{
				}
			}, null);
		}

		internal void Complete(Exception exception)
		{
			_exception = ((_inGet && exception is ObjectDisposedException) ? new HttpListenerException(995, "The listener is closed.") : exception);
			complete(this);
		}

		internal void Complete(HttpListenerContext context)
		{
			Complete(context, syncCompleted: false);
		}

		internal void Complete(HttpListenerContext context, bool syncCompleted)
		{
			_context = context;
			_syncCompleted = syncCompleted;
			complete(this);
		}

		internal HttpListenerContext GetContext()
		{
			if (_exception != null)
			{
				throw _exception;
			}
			return _context;
		}
	}
	public enum HttpRequestHeader
	{
		CacheControl,
		Connection,
		Date,
		KeepAlive,
		Pragma,
		Trailer,
		TransferEncoding,
		Upgrade,
		Via,
		Warning,
		Allow,
		ContentLength,
		ContentType,
		ContentEncoding,
		ContentLanguage,
		ContentLocation,
		ContentMd5,
		ContentRange,
		Expires,
		LastModified,
		Accept,
		AcceptCharset,
		AcceptEncoding,
		AcceptLanguage,
		Authorization,
		Cookie,
		Expect,
		From,
		Host,
		IfMatch,
		IfModifiedSince,
		IfNoneMatch,
		IfRange,
		IfUnmodifiedSince,
		MaxForwards,
		ProxyAuthorization,
		Referer,
		Range,
		Te,
		Translate,
		UserAgent,
		SecWebSocketKey,
		SecWebSocketExtensions,
		SecWebSocketProtocol,
		SecWebSocketVersion
	}
	public enum HttpResponseHeader
	{
		CacheControl,
		Connection,
		Date,
		KeepAlive,
		Pragma,
		Trailer,
		TransferEncoding,
		Upgrade,
		Via,
		Warning,
		Allow,
		ContentLength,
		ContentType,
		ContentEncoding,
		ContentLanguage,
		ContentLocation,
		ContentMd5,
		ContentRange,
		Expires,
		LastModified,
		AcceptRanges,
		Age,
		ETag,
		Location,
		ProxyAuthenticate,
		RetryAfter,
		Server,
		SetCookie,
		Vary,
		WwwAuthenticate,
		SecWebSocketExtensions,
		SecWebSocketAccept,
		SecWebSocketProtocol,
		SecWebSocketVersion
	}
}
namespace WebSocketSharp.Net.WebSockets
{
	public class HttpListenerWebSocketContext : WebSocketContext
	{
		private HttpListenerContext _context;

		private WebSocket _websocket;

		internal Logger Log => _context.Listener.Log;

		internal Stream Stream => _context.Connection.Stream;

		public override CookieCollection CookieCollection => _context.Request.Cookies;

		public override NameValueCollection Headers => _context.Request.Headers;

		public override string Host => _context.Request.Headers["Host"];

		public override bool IsAuthenticated => _context.User != null;

		public override bool IsLocal => _context.Request.IsLocal;

		public override bool IsSecureConnection => _context.Connection.IsSecure;

		public override bool IsWebSocketRequest => _context.Request.IsWebSocketRequest;

		public override string Origin => _context.Request.Headers["Origin"];

		public override NameValueCollection QueryString => _context.Request.QueryString;

		public override Uri RequestUri => _context.Request.Url;

		public override string SecWebSocketKey => _context.Request.Headers["Sec-WebSocket-Key"];

		public override IEnumerable<string> SecWebSocketProtocols
		{
			get
			{
				string protocols = _context.Request.Headers["Sec-WebSocket-Protocol"];
				if (protocols != null)
				{
					string[] array = protocols.Split(new char[1] { ',' });
					foreach (string protocol in array)
					{
						yield return protocol.Trim();
					}
				}
			}
		}

		public override string SecWebSocketVersion => _context.Request.Headers["Sec-WebSocket-Version"];

		public override IPEndPoint ServerEndPoint => _context.Connection.LocalEndPoint;

		public override IPrincipal User => _context.User;

		public override IPEndPoint UserEndPoint => _context.Connection.RemoteEndPoint;

		public override WebSocket WebSocket => _websocket;

		internal HttpListenerWebSocketContext(HttpListenerContext context, string protocol)
		{
			_context = context;
			_websocket = new WebSocket(this, protocol);
		}

		internal void Close()
		{
			_context.Connection.Close(force: true);
		}

		internal void Close(HttpStatusCode code)
		{
			_context.Response.Close(code);
		}

		public override string ToString()
		{
			return _context.Request.ToString();
		}
	}
	internal class TcpListenerWebSocketContext : WebSocketContext
	{
		private CookieCollection _cookies;

		private Logger _logger;

		private NameValueCollection _queryString;

		private HttpRequest _request;

		private bool _secure;

		private Stream _stream;

		private TcpClient _tcpClient;

		private Uri _uri;

		private IPrincipal _user;

		private WebSocket _websocket;

		internal Logger Log => _logger;

		internal Stream Stream => _stream;

		public override CookieCollection CookieCollection => _cookies ?? (_cookies = _request.Cookies);

		public override NameValueCollection Headers => _request.Headers;

		public override string Host => _request.Headers["Host"];

		public override bool IsAuthenticated => _user != null;

		public override bool IsLocal => UserEndPoint.Address.IsLocal();

		public override bool IsSecureConnection => _secure;

		public override bool IsWebSocketRequest => _request.IsWebSocketRequest;

		public override string Origin => _request.Headers["Origin"];

		public override NameValueCollection QueryString => _queryString ?? (_queryString = HttpUtility.InternalParseQueryString((_uri != null) ? _uri.Query : null, Encoding.UTF8));

		public override Uri RequestUri => _uri;

		public override string SecWebSocketKey => _request.Headers["Sec-WebSocket-Key"];

		public override IEnumerable<string> SecWebSocketProtocols
		{
			get
			{
				string protocols = _request.Headers["Sec-WebSocket-Protocol"];
				if (protocols != null)
				{
					string[] array = protocols.Split(new char[1] { ',' });
					foreach (string protocol in array)
					{
						yield return protocol.Trim();
					}
				}
			}
		}

		public override string SecWebSocketVersion => _request.Headers["Sec-WebSocket-Version"];

		public override IPEndPoint ServerEndPoint => (IPEndPoint)_tcpClient.Client.LocalEndPoint;

		public override IPrincipal User => _user;

		public override IPEndPoint UserEndPoint => (IPEndPoint)_tcpClient.Client.RemoteEndPoint;

		public override WebSocket WebSocket => _websocket;

		internal TcpListenerWebSocketContext(TcpClient tcpClient, string protocol, bool secure, ServerSslConfiguration sslConfig, Logger logger)
		{
			_tcpClient = tcpClient;
			_secure = secure;
			_logger = logger;
			NetworkStream stream = tcpClient.GetStream();
			if (secure)
			{
				SslStream sslStream = new SslStream(stream, leaveInnerStreamOpen: false, sslConfig.ClientCertificateValidationCallback);
				sslStream.AuthenticateAsServer(sslConfig.ServerCertificate, sslConfig.ClientCertificateRequired, sslConfig.EnabledSslProtocols, sslConfig.CheckCertificateRevocation);
				_stream = sslStream;
			}
			else
			{
				_stream = stream;
			}
			_request = HttpRequest.Read(_stream, 90000);
			_uri = HttpUtility.CreateRequestUrl(_request.RequestUri, _request.Headers["Host"], _request.IsWebSocketRequest, secure);
			_websocket = new WebSocket(this, protocol);
		}

		internal bool Authenticate(AuthenticationSchemes scheme, string realm, Func<IIdentity, NetworkCredential> credentialsFinder)
		{
			if (scheme == AuthenticationSchemes.Anonymous)
			{
				return true;
			}
			if (scheme == AuthenticationSchemes.None)
			{
				Close(HttpStatusCode.Forbidden);
				return false;
			}
			string chal = new AuthenticationChallenge(scheme, realm).ToString();
			int retry = -1;
			Func<bool> auth = null;
			auth = delegate
			{
				retry++;
				if (retry > 99)
				{
					Close(HttpStatusCode.Forbidden);
					return false;
				}
				IPrincipal principal = HttpUtility.CreateUser(_request.Headers["Authorization"], scheme, realm, _request.HttpMethod, credentialsFinder);
				if (principal == null || !principal.Identity.IsAuthenticated)
				{
					SendAuthenticationChallenge(chal);
					return auth();
				}
				_user = principal;
				return true;
			};
			return auth();
		}

		internal void Close()
		{
			_stream.Close();
			_tcpClient.Close();
		}

		internal void Close(HttpStatusCode code)
		{
			_websocket.Close(HttpResponse.CreateCloseResponse(code));
		}

		internal void SendAuthenticationChallenge(string challenge)
		{
			byte[] array = HttpResponse.CreateUnauthorizedResponse(challenge).ToByteArray();
			_stream.Write(array, 0, array.Length);
			_request = HttpRequest.Read(_stream, 15000);
		}

		public override string ToString()
		{
			return _request.ToString();
		}
	}
	public abstract class WebSocketContext
	{
		public abstract CookieCollection CookieCollection { get; }

		public abstract NameValueCollection Headers { get; }

		public abstract string Host { get; }

		public abstract bool IsAuthenticated { get; }

		public abstract bool IsLocal { get; }

		public abstract bool IsSecureConnection { get; }

		public abstract bool IsWebSocketRequest { get; }

		public abstract string Origin { get; }

		public abstract NameValueCollection QueryString { get; }

		public abstract Uri RequestUri { get; }

		public abstract string SecWebSocketKey { get; }

		public abstract IEnumerable<string> SecWebSocketProtocols { get; }

		public abstract string SecWebSocketVersion { get; }

		public abstract IPEndPoint ServerEndPoint { get; }

		public abstract IPrincipal User { get; }

		public abstract IPEndPoint UserEndPoint { get; }

		public abstract WebSocket WebSocket { get; }
	}
}
namespace WebSocketSharp.Server
{
	public class WebSocketServer
	{
		private IPAddress _address;

		private WebSocketSharp.Net.AuthenticationSchemes _authSchemes;

		private static readonly string _defaultRealm;

		private bool _dnsStyle;

		private string _hostname;

		private TcpListener _listener;

		private Logger _logger;

		private int _port;

		private string _realm;

		private Thread _receiveThread;

		private bool _reuseAddress;

		private bool _secure;

		private WebSocketServiceManager _services;

		private ServerSslConfiguration _sslConfig;

		private volatile ServerState _state;

		private object _sync;

		private Func<IIdentity, WebSocketSharp.Net.NetworkCredential> _userCredFinder;

		public IPAddress Address => _address;

		public WebSocketSharp.Net.AuthenticationSchemes AuthenticationSchemes
		{
			get
			{
				return _authSchemes;
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_authSchemes = value;
				}
			}
		}

		public bool IsListening => _state == ServerState.Start;

		public bool IsSecure => _secure;

		public bool KeepClean
		{
			get
			{
				return _services.KeepClean;
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_services.KeepClean = value;
				}
			}
		}

		public Logger Log => _logger;

		public int Port => _port;

		public string Realm
		{
			get
			{
				return _realm;
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_realm = value;
				}
			}
		}

		public bool ReuseAddress
		{
			get
			{
				return _reuseAddress;
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_reuseAddress = value;
				}
			}
		}

		public ServerSslConfiguration SslConfiguration
		{
			get
			{
				return _sslConfig ?? (_sslConfig = new ServerSslConfiguration(null));
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_sslConfig = value;
				}
			}
		}

		public Func<IIdentity, WebSocketSharp.Net.NetworkCredential> UserCredentialsFinder
		{
			get
			{
				return _userCredFinder;
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_userCredFinder = value;
				}
			}
		}

		public TimeSpan WaitTime
		{
			get
			{
				return _services.WaitTime;
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false) ?? value.CheckIfValidWaitTime();
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_services.WaitTime = value;
				}
			}
		}

		public WebSocketServiceManager WebSocketServices => _services;

		static WebSocketServer()
		{
			_defaultRealm = "SECRET AREA";
		}

		public WebSocketServer()
		{
			init(null, IPAddress.Any, 80, secure: false);
		}

		public WebSocketServer(int port)
			: this(port, port == 443)
		{
		}

		public WebSocketServer(string url)
		{
			if (url == null)
			{
				throw new ArgumentNullException("url");
			}
			if (url.Length == 0)
			{
				throw new ArgumentException("An empty string.", "url");
			}
			if (!tryCreateUri(url, out var result, out var message))
			{
				throw new ArgumentException(message, "url");
			}
			string dnsSafeHost = result.DnsSafeHost;
			IPAddress address = dnsSafeHost.ToIPAddress();
			if (!address.IsLocal())
			{
				throw new ArgumentException("The host part isn't a local host name: " + url, "url");
			}
			init(dnsSafeHost, address, result.Port, result.Scheme == "wss");
		}

		public WebSocketServer(int port, bool secure)
		{
			if (!port.IsPortNumber())
			{
				throw new ArgumentOutOfRangeException("port", "Not between 1 and 65535 inclusive: " + port);
			}
			init(null, IPAddress.Any, port, secure);
		}

		public WebSocketServer(IPAddress address, int port)
			: this(address, port, port == 443)
		{
		}

		public WebSocketServer(IPAddress address, int port, bool secure)
		{
			if (address == null)
			{
				throw new ArgumentNullException("address");
			}
			if (!address.IsLocal())
			{
				throw new ArgumentException("Not a local IP address: " + address, "address");
			}
			if (!port.IsPortNumber())
			{
				throw new ArgumentOutOfRangeException("port", "Not between 1 and 65535 inclusive: " + port);
			}
			init(null, address, port, secure);
		}

		private void abort()
		{
			lock (_sync)
			{
				if (!IsListening)
				{
					return;
				}
				_state = ServerState.ShuttingDown;
			}
			_listener.Stop();
			_services.Stop(new CloseEventArgs(CloseStatusCode.ServerError), send: true, receive: false);
			_state = ServerState.Stop;
		}

		private bool checkIfAvailable(bool ready, bool start, bool shutting, bool stop, out string message)
		{
			message = null;
			if (!ready && _state == ServerState.Ready)
			{
				message = "This operation is not available in: ready";
				return false;
			}
			if (!start && _state == ServerState.Start)
			{
				message = "This operation is not available in: start";
				return false;
			}
			if (!shutting && _state == ServerState.ShuttingDown)
			{
				message = "This operation is not available in: shutting down";
				return false;
			}
			if (!stop && _state == ServerState.Stop)
			{
				message = "This operation is not available in: stop";
				return false;
			}
			return true;
		}

		private string checkIfCertificateExists()
		{
			return (_secure && (_sslConfig == null || _sslConfig.ServerCertificate == null)) ? "The secure connection requires a server certificate." : null;
		}

		private string getRealm()
		{
			string realm = _realm;
			return (realm != null && realm.Length > 0) ? realm : _defaultRealm;
		}

		private void init(string hostname, IPAddress address, int port, bool secure)
		{
			_hostname = hostname ?? address.ToString();
			_address = address;
			_port = port;
			_secure = secure;
			_authSchemes = WebSocketSharp.Net.AuthenticationSchemes.Anonymous;
			_dnsStyle = Uri.CheckHostName(hostname) == UriHostNameType.Dns;
			_listener = new TcpListener(address, port);
			_logger = new Logger();
			_services = new WebSocketServiceManager(_logger);
			_sync = new object();
		}

		private void processRequest(TcpListenerWebSocketContext context)
		{
			Uri requestUri = context.RequestUri;
			if (requestUri == null || requestUri.Port != _port)
			{
				context.Close(WebSocketSharp.Net.HttpStatusCode.BadRequest);
				return;
			}
			if (_dnsStyle)
			{
				string dnsSafeHost = requestUri.DnsSafeHost;
				if (Uri.CheckHostName(dnsSafeHost) == UriHostNameType.Dns && dnsSafeHost != _hostname)
				{
					context.Close(WebSocketSharp.Net.HttpStatusCode.NotFound);
					return;
				}
			}
			if (!_services.InternalTryGetServiceHost(requestUri.AbsolutePath, out var host))
			{
				context.Close(WebSocketSharp.Net.HttpStatusCode.NotImplemented);
			}
			else
			{
				host.StartSession(context);
			}
		}

		private void receiveRequest()
		{
			while (true)
			{
				try
				{
					TcpClient cl = _listener.AcceptTcpClient();
					ThreadPool.QueueUserWorkItem(delegate
					{
						try
						{
							TcpListenerWebSocketContext webSocketContext = cl.GetWebSocketContext(null, _secure, _sslConfig, _logger);
							if (webSocketContext.Authenticate(_authSchemes, getRealm(), _userCredFinder))
							{
								processRequest(webSocketContext);
							}
						}
						catch (Exception ex3)
						{
							_logger.Fatal(ex3.ToString());
							cl.Close();
						}
					});
				}
				catch (SocketException ex)
				{
					_logger.Warn("Receiving has been stopped.\n  reason: " + ex.Message);
					break;
				}
				catch (Exception ex2)
				{
					_logger.Fatal(ex2.ToString());
					break;
				}
			}
			if (IsListening)
			{
				abort();
			}
		}

		private void startReceiving()
		{
			if (_reuseAddress)
			{
				_listener.Server.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, optionValue: true);
			}
			_listener.Start();
			_receiveThread = new Thread(receiveRequest);
			_receiveThread.IsBackground = true;
			_receiveThread.Start();
		}

		private void stopReceiving(int millisecondsTimeout)
		{
			_listener.Stop();
			_receiveThread.Join(millisecondsTimeout);
		}

		private static bool tryCreateUri(string uriString, out Uri result, out string message)
		{
			if (!uriString.TryCreateWebSocketUri(out result, out message))
			{
				return false;
			}
			if (result.PathAndQuery != "/")
			{
				result = null;
				message = "Includes the path or query component: " + uriString;
				return false;
			}
			return true;
		}

		public void AddWebSocketService<TBehavior>(string path, Func<TBehavior> initializer) where TBehavior : WebSocketBehavior
		{
			string text = path.CheckIfValidServicePath() ?? ((initializer == null) ? "'initializer' is null." : null);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_services.Add(path, initializer);
			}
		}

		public void AddWebSocketService<TBehaviorWithNew>(string path) where TBehaviorWithNew : WebSocketBehavior, new()
		{
			AddWebSocketService(path, () => new TBehaviorWithNew());
		}

		public bool RemoveWebSocketService(string path)
		{
			string text = path.CheckIfValidServicePath();
			if (text != null)
			{
				_logger.Error(text);
				return false;
			}
			return _services.Remove(path);
		}

		public void Start()
		{
			lock (_sync)
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false) ?? checkIfCertificateExists();
				if (text != null)
				{
					_logger.Error(text);
					return;
				}
				_services.Start();
				startReceiving();
				_state = ServerState.Start;
			}
		}

		public void Stop()
		{
			if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out var message))
			{
				_logger.Error(message);
				return;
			}
			lock (_sync)
			{
				if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out message))
				{
					_logger.Error(message);
					return;
				}
				_state = ServerState.ShuttingDown;
			}
			stopReceiving(5000);
			_services.Stop(new CloseEventArgs(), send: true, receive: true);
			_state = ServerState.Stop;
		}

		public void Stop(ushort code, string reason)
		{
			if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out var message))
			{
				_logger.Error(message);
				return;
			}
			if (!WebSocket.CheckParametersForClose(code, reason, client: false, out message))
			{
				_logger.Error(message);
				return;
			}
			lock (_sync)
			{
				if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out message))
				{
					_logger.Error(message);
					return;
				}
				_state = ServerState.ShuttingDown;
			}
			stopReceiving(5000);
			if (code == 1005)
			{
				_services.Stop(new CloseEventArgs(), send: true, receive: true);
			}
			else
			{
				bool flag = !code.IsReserved();
				_services.Stop(new CloseEventArgs(code, reason), flag, flag);
			}
			_state = ServerState.Stop;
		}

		public void Stop(CloseStatusCode code, string reason)
		{
			if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out var message))
			{
				_logger.Error(message);
				return;
			}
			if (!WebSocket.CheckParametersForClose(code, reason, client: false, out message))
			{
				_logger.Error(message);
				return;
			}
			lock (_sync)
			{
				if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out message))
				{
					_logger.Error(message);
					return;
				}
				_state = ServerState.ShuttingDown;
			}
			stopReceiving(5000);
			if (code == CloseStatusCode.NoStatus)
			{
				_services.Stop(new CloseEventArgs(), send: true, receive: true);
			}
			else
			{
				bool flag = !code.IsReserved();
				_services.Stop(new CloseEventArgs(code, reason), flag, flag);
			}
			_state = ServerState.Stop;
		}
	}
	public class HttpServer
	{
		private IPAddress _address;

		private string _hostname;

		private WebSocketSharp.Net.HttpListener _listener;

		private Logger _logger;

		private int _port;

		private Thread _receiveThread;

		private string _rootPath;

		private bool _secure;

		private WebSocketServiceManager _services;

		private volatile ServerState _state;

		private object _sync;

		private bool _windows;

		public IPAddress Address => _address;

		public WebSocketSharp.Net.AuthenticationSchemes AuthenticationSchemes
		{
			get
			{
				return _listener.AuthenticationSchemes;
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_listener.AuthenticationSchemes = value;
				}
			}
		}

		public bool IsListening => _state == ServerState.Start;

		public bool IsSecure => _secure;

		public bool KeepClean
		{
			get
			{
				return _services.KeepClean;
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_services.KeepClean = value;
				}
			}
		}

		public Logger Log => _logger;

		public int Port => _port;

		public string Realm
		{
			get
			{
				return _listener.Realm;
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_listener.Realm = value;
				}
			}
		}

		public bool ReuseAddress
		{
			get
			{
				return _listener.ReuseAddress;
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_listener.ReuseAddress = value;
				}
			}
		}

		public string RootPath
		{
			get
			{
				return (_rootPath != null && _rootPath.Length > 0) ? _rootPath : (_rootPath = "./Public");
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_rootPath = value;
				}
			}
		}

		public ServerSslConfiguration SslConfiguration
		{
			get
			{
				return _listener.SslConfiguration;
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_listener.SslConfiguration = value;
				}
			}
		}

		public Func<IIdentity, WebSocketSharp.Net.NetworkCredential> UserCredentialsFinder
		{
			get
			{
				return _listener.UserCredentialsFinder;
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false);
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_listener.UserCredentialsFinder = value;
				}
			}
		}

		public TimeSpan WaitTime
		{
			get
			{
				return _services.WaitTime;
			}
			set
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false) ?? value.CheckIfValidWaitTime();
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_services.WaitTime = value;
				}
			}
		}

		public WebSocketServiceManager WebSocketServices => _services;

		public event EventHandler<HttpRequestEventArgs> OnConnect;

		public event EventHandler<HttpRequestEventArgs> OnDelete;

		public event EventHandler<HttpRequestEventArgs> OnGet;

		public event EventHandler<HttpRequestEventArgs> OnHead;

		public event EventHandler<HttpRequestEventArgs> OnOptions;

		public event EventHandler<HttpRequestEventArgs> OnPatch;

		public event EventHandler<HttpRequestEventArgs> OnPost;

		public event EventHandler<HttpRequestEventArgs> OnPut;

		public event EventHandler<HttpRequestEventArgs> OnTrace;

		public HttpServer()
		{
			init("*", IPAddress.Any, 80, secure: false);
		}

		public HttpServer(int port)
			: this(port, port == 443)
		{
		}

		public HttpServer(string url)
		{
			if (url == null)
			{
				throw new ArgumentNullException("url");
			}
			if (url.Length == 0)
			{
				throw new ArgumentException("An empty string.", "url");
			}
			if (!tryCreateUri(url, out var result, out var message))
			{
				throw new ArgumentException(message, "url");
			}
			string host = getHost(result);
			IPAddress address = host.ToIPAddress();
			if (!address.IsLocal())
			{
				throw new ArgumentException("The host part isn't a local host name: " + url, "url");
			}
			init(host, address, result.Port, result.Scheme == "https");
		}

		public HttpServer(int port, bool secure)
		{
			if (!port.IsPortNumber())
			{
				throw new ArgumentOutOfRangeException("port", "Not between 1 and 65535 inclusive: " + port);
			}
			init("*", IPAddress.Any, port, secure);
		}

		public HttpServer(IPAddress address, int port)
			: this(address, port, port == 443)
		{
		}

		public HttpServer(IPAddress address, int port, bool secure)
		{
			if (address == null)
			{
				throw new ArgumentNullException("address");
			}
			if (!address.IsLocal())
			{
				throw new ArgumentException("Not a local IP address: " + address, "address");
			}
			if (!port.IsPortNumber())
			{
				throw new ArgumentOutOfRangeException("port", "Not between 1 and 65535 inclusive: " + port);
			}
			init(null, address, port, secure);
		}

		private void abort()
		{
			lock (_sync)
			{
				if (!IsListening)
				{
					return;
				}
				_state = ServerState.ShuttingDown;
			}
			_services.Stop(new CloseEventArgs(CloseStatusCode.ServerError), send: true, receive: false);
			_listener.Abort();
			_state = ServerState.Stop;
		}

		private bool checkIfAvailable(bool ready, bool start, bool shutting, bool stop, out string message)
		{
			message = null;
			if (!ready && _state == ServerState.Ready)
			{
				message = "This operation is not available in: ready";
				return false;
			}
			if (!start && _state == ServerState.Start)
			{
				message = "This operation is not available in: start";
				return false;
			}
			if (!shutting && _state == ServerState.ShuttingDown)
			{
				message = "This operation is not available in: shutting down";
				return false;
			}
			if (!stop && _state == ServerState.Stop)
			{
				message = "This operation is not available in: stop";
				return false;
			}
			return true;
		}

		private string checkIfCertificateExists()
		{
			if (!_secure)
			{
				return null;
			}
			bool flag = _listener.SslConfiguration.ServerCertificate != null;
			bool flag2 = EndPointListener.CertificateExists(_port, _listener.CertificateFolderPath);
			if (flag && flag2)
			{
				_logger.Warn("The server certificate associated with the port number already exists.");
				return null;
			}
			return (!(flag || flag2)) ? "The secure connection requires a server certificate." : null;
		}

		private static string convertToString(IPAddress address)
		{
			return (address.AddressFamily == AddressFamily.InterNetworkV6) ? $"[{address.ToString()}]" : address.ToString();
		}

		private static string getHost(Uri uri)
		{
			return (uri.HostNameType == UriHostNameType.IPv6) ? uri.Host : uri.DnsSafeHost;
		}

		private void init(string hostname, IPAddress address, int port, bool secure)
		{
			_hostname = hostname ?? convertToString(address);
			_address = address;
			_port = port;
			_secure = secure;
			_listener = new WebSocketSharp.Net.HttpListener();
			_listener.Prefixes.Add(string.Format("http{0}://{1}:{2}/", secure ? "s" : "", _hostname, port));
			_logger = _listener.Log;
			_services = new WebSocketServiceManager(_logger);
			_sync = new object();
			OperatingSystem oSVersion = Environment.OSVersion;
			_windows = oSVersion.Platform != PlatformID.Unix && oSVersion.Platform != PlatformID.MacOSX;
		}

		private void processRequest(WebSocketSharp.Net.HttpListenerContext context)
		{
			EventHandler<HttpRequestEventArgs> eventHandler = context.Request.HttpMethod switch
			{
				"PATCH" => this.OnPatch, 
				"CONNECT" => this.OnConnect, 
				"TRACE" => this.OnTrace, 
				"OPTIONS" => this.OnOptions, 
				"DELETE" => this.OnDelete, 
				"PUT" => this.OnPut, 
				"POST" => this.OnPost, 
				"HEAD" => this.OnHead, 
				"GET" => this.OnGet, 
				_ => null, 
			};
			if (eventHandler != null)
			{
				eventHandler(this, new HttpRequestEventArgs(context));
			}
			else
			{
				context.Response.StatusCode = 501;
			}
			context.Response.Close();
		}

		private void processRequest(HttpListenerWebSocketContext context)
		{
			if (!_services.InternalTryGetServiceHost(context.RequestUri.AbsolutePath, out var host))
			{
				context.Close(WebSocketSharp.Net.HttpStatusCode.NotImplemented);
			}
			else
			{
				host.StartSession(context);
			}
		}

		private void receiveRequest()
		{
			while (true)
			{
				try
				{
					WebSocketSharp.Net.HttpListenerContext ctx = _listener.GetContext();
					ThreadPool.QueueUserWorkItem(delegate
					{
						try
						{
							if (ctx.Request.IsUpgradeTo("websocket"))
							{
								processRequest(ctx.AcceptWebSocket(null));
							}
							else
							{
								processRequest(ctx);
							}
						}
						catch (Exception ex3)
						{
							_logger.Fatal(ex3.ToString());
							ctx.Connection.Close(force: true);
						}
					});
				}
				catch (WebSocketSharp.Net.HttpListenerException ex)
				{
					_logger.Warn("Receiving has been stopped.\n  reason: " + ex.Message);
					break;
				}
				catch (Exception ex2)
				{
					_logger.Fatal(ex2.ToString());
					break;
				}
			}
			if (IsListening)
			{
				abort();
			}
		}

		private void startReceiving()
		{
			_listener.Start();
			_receiveThread = new Thread(receiveRequest);
			_receiveThread.IsBackground = true;
			_receiveThread.Start();
		}

		private void stopReceiving(int millisecondsTimeout)
		{
			_listener.Close();
			_receiveThread.Join(millisecondsTimeout);
		}

		private static bool tryCreateUri(string uriString, out Uri result, out string message)
		{
			result = null;
			Uri uri = uriString.ToUri();
			if (uri == null)
			{
				message = "An invalid URI string: " + uriString;
				return false;
			}
			if (!uri.IsAbsoluteUri)
			{
				message = "Not an absolute URI: " + uriString;
				return false;
			}
			string scheme = uri.Scheme;
			if (!(scheme == "http") && !(scheme == "https"))
			{
				message = "The scheme part isn't 'http' or 'https': " + uriString;
				return false;
			}
			if (uri.PathAndQuery != "/")
			{
				message = "Includes the path or query component: " + uriString;
				return false;
			}
			if (uri.Fragment.Length > 0)
			{
				message = "Includes the fragment component: " + uriString;
				return false;
			}
			if (uri.Port == 0)
			{
				message = "The port part is zero: " + uriString;
				return false;
			}
			result = uri;
			message = string.Empty;
			return true;
		}

		public void AddWebSocketService<TBehavior>(string path, Func<TBehavior> initializer) where TBehavior : WebSocketBehavior
		{
			string text = path.CheckIfValidServicePath() ?? ((initializer == null) ? "'initializer' is null." : null);
			if (text != null)
			{
				_logger.Error(text);
			}
			else
			{
				_services.Add(path, initializer);
			}
		}

		public void AddWebSocketService<TBehaviorWithNew>(string path) where TBehaviorWithNew : WebSocketBehavior, new()
		{
			AddWebSocketService(path, () => new TBehaviorWithNew());
		}

		public byte[] GetFile(string path)
		{
			path = RootPath + path;
			if (_windows)
			{
				path = path.Replace("/", "\\");
			}
			return File.Exists(path) ? File.ReadAllBytes(path) : null;
		}

		public bool RemoveWebSocketService(string path)
		{
			string text = path.CheckIfValidServicePath();
			if (text != null)
			{
				_logger.Error(text);
				return false;
			}
			return _services.Remove(path);
		}

		public void Start()
		{
			lock (_sync)
			{
				string text = _state.CheckIfAvailable(ready: true, start: false, shutting: false) ?? checkIfCertificateExists();
				if (text != null)
				{
					_logger.Error(text);
					return;
				}
				_services.Start();
				startReceiving();
				_state = ServerState.Start;
			}
		}

		public void Stop()
		{
			if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out var message))
			{
				_logger.Error(message);
				return;
			}
			lock (_sync)
			{
				if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out message))
				{
					_logger.Error(message);
					return;
				}
				_state = ServerState.ShuttingDown;
			}
			_services.Stop(new CloseEventArgs(), send: true, receive: true);
			stopReceiving(5000);
			_state = ServerState.Stop;
		}

		public void Stop(ushort code, string reason)
		{
			if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out var message))
			{
				_logger.Error(message);
				return;
			}
			if (!WebSocket.CheckParametersForClose(code, reason, client: false, out message))
			{
				_logger.Error(message);
				return;
			}
			lock (_sync)
			{
				if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out message))
				{
					_logger.Error(message);
					return;
				}
				_state = ServerState.ShuttingDown;
			}
			if (code == 1005)
			{
				_services.Stop(new CloseEventArgs(), send: true, receive: true);
			}
			else
			{
				bool flag = !code.IsReserved();
				_services.Stop(new CloseEventArgs(code, reason), flag, flag);
			}
			stopReceiving(5000);
			_state = ServerState.Stop;
		}

		public void Stop(CloseStatusCode code, string reason)
		{
			if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out var message))
			{
				_logger.Error(message);
				return;
			}
			if (!WebSocket.CheckParametersForClose(code, reason, client: false, out message))
			{
				_logger.Error(message);
				return;
			}
			lock (_sync)
			{
				if (!checkIfAvailable(ready: false, start: true, shutting: false, stop: false, out message))
				{
					_logger.Error(message);
					return;
				}
				_state = ServerState.ShuttingDown;
			}
			if (code == CloseStatusCode.NoStatus)
			{
				_services.Stop(new CloseEventArgs(), send: true, receive: true);
			}
			else
			{
				bool flag = !code.IsReserved();
				_services.Stop(new CloseEventArgs(code, reason), flag, flag);
			}
			stopReceiving(5000);
			_state = ServerState.Stop;
		}
	}
	public abstract class WebSocketServiceHost
	{
		internal ServerState State => Sessions.State;

		public abstract bool KeepClean { get; set; }

		public abstract string Path { get; }

		public abstract WebSocketSessionManager Sessions { get; }

		public abstract Type Type { get; }

		public abstract TimeSpan WaitTime { get; set; }

		internal void Start()
		{
			Sessions.Start();
		}

		internal void StartSession(WebSocketContext context)
		{
			CreateSession().Start(context, Sessions);
		}

		internal void Stop(ushort code, string reason)
		{
			CloseEventArgs e = new CloseEventArgs(code, reason);
			bool flag = !code.IsReserved();
			byte[] frameAsBytes = (flag ? WebSocketFrame.CreateCloseFrame(e.PayloadData, mask: false).ToArray() : null);
			Sessions.Stop(e, frameAsBytes, flag);
		}

		protected abstract WebSocketBehavior CreateSession();
	}
	public class HttpRequestEventArgs : EventArgs
	{
		private WebSocketSharp.Net.HttpListenerRequest _request;

		private WebSocketSharp.Net.HttpListenerResponse _response;

		public WebSocketSharp.Net.HttpListenerRequest Request => _request;

		public WebSocketSharp.Net.HttpListenerResponse Response => _response;

		internal HttpRequestEventArgs(WebSocketSharp.Net.HttpListenerContext context)
		{
			_request = context.Request;
			_response = context.Response;
		}
	}
	public interface IWebSocketSession
	{
		WebSocketContext Context { get; }

		string ID { get; }

		string Protocol { get; }

		DateTime StartTime { get; }

		WebSocketState State { get; }
	}
	public class WebSocketSessionManager
	{
		private volatile bool _clean;

		private object _forSweep;

		private Logger _logger;

		private Dictionary<string, IWebSocketSession> _sessions;

		private volatile ServerState _state;

		private volatile bool _sweeping;

		private System.Timers.Timer _sweepTimer;

		private object _sync;

		private TimeSpan _waitTime;

		internal ServerState State => _state;

		public IEnumerable<string> ActiveIDs
		{
			get
			{
				foreach (KeyValuePair<string, bool> res in Broadping(WebSocketFrame.EmptyPingBytes, _waitTime))
				{
					if (res.Value)
					{
						yield return res.Key;
					}
				}
			}
		}

		public int Count
		{
			get
			{
				lock (_sync)
				{
					return _sessions.Count;
				}
			}
		}

		public IEnumerable<string> IDs
		{
			get
			{
				if (_state == ServerState.ShuttingDown)
				{
					return new string[0];
				}
				lock (_sync)
				{
					return _sessions.Keys.ToList();
				}
			}
		}

		public IEnumerable<string> InactiveIDs
		{
			get
			{
				foreach (KeyValuePair<string, bool> res in Broadping(WebSocketFrame.EmptyPingBytes, _waitTime))
				{
					if (!res.Value)
					{
						yield return res.Key;
					}
				}
			}
		}

		public IWebSocketSession this[string id]
		{
			get
			{
				TryGetSession(id, out var session);
				return session;
			}
		}

		public bool KeepClean
		{
			get
			{
				return _clean;
			}
			internal set
			{
				if (value != _clean)
				{
					_clean = value;
					if (_state == ServerState.Start)
					{
						_sweepTimer.Enabled = value;
					}
				}
			}
		}

		public IEnumerable<IWebSocketSession> Sessions
		{
			get
			{
				if (_state == ServerState.ShuttingDown)
				{
					return new IWebSocketSession[0];
				}
				lock (_sync)
				{
					return _sessions.Values.ToList();
				}
			}
		}

		public TimeSpan WaitTime
		{
			get
			{
				return _waitTime;
			}
			internal set
			{
				if (value == _waitTime)
				{
					return;
				}
				_waitTime = value;
				foreach (IWebSocketSession session in Sessions)
				{
					session.Context.WebSocket.WaitTime = value;
				}
			}
		}

		internal WebSocketSessionManager()
			: this(new Logger())
		{
		}

		internal WebSocketSessionManager(Logger logger)
		{
			_logger = logger;
			_clean = true;
			_forSweep = new object();
			_sessions = new Dictionary<string, IWebSocketSession>();
			_state = ServerState.Ready;
			_sync = ((ICollection)_sessions).SyncRoot;
			_waitTime = TimeSpan.FromSeconds(1.0);
			setSweepTimer(60000.0);
		}

		private void broadcast(Opcode opcode, byte[] data, Action completed)
		{
			Dictionary<CompressionMethod, byte[]> dictionary = new Dictionary<CompressionMethod, byte[]>();
			try
			{
				Broadcast(opcode, data, dictionary);
				completed?.Invoke();
			}
			catch (Exception ex)
			{
				_logger.Fatal(ex.ToString());
			}
			finally
			{
				dictionary.Clear();
			}
		}

		private void broadcast(Opcode opcode, Stream stream, Action completed)
		{
			Dictionary<CompressionMethod, Stream> dictionary = new Dictionary<CompressionMethod, Stream>();
			try
			{
				Broadcast(opcode, stream, dictionary);
				completed?.Invoke();
			}
			catch (Exception ex)
			{
				_logger.Fatal(ex.ToString());
			}
			finally
			{
				foreach (Stream value in dictionary.Values)
				{
					value.Dispose();
				}
				dictionary.Clear();
			}
		}

		private void broadcastAsync(Opcode opcode, byte[] data, Action completed)
		{
			ThreadPool.QueueUserWorkItem(delegate
			{
				broadcast(opcode, data, completed);
			});
		}

		private void broadcastAsync(Opcode opcode, Stream stream, Action completed)
		{
			ThreadPool.QueueUserWorkItem(delegate
			{
				broadcast(opcode, stream, completed);
			});
		}

		private static string createID()
		{
			return Guid.NewGuid().ToString("N");
		}

		private void setSweepTimer(double interval)
		{
			_sweepTimer = new System.Timers.Timer(interval);
			_sweepTimer.Elapsed += delegate
			{
				Sweep();
			};
		}

		private bool tryGetSession(string id, out IWebSocketSession session)
		{
			bool flag;
			lock (_sync)
			{
				flag = _sessions.TryGetValue(id, out session);
			}
			if (!flag)
			{
				_logger.Error("A session with the specified ID isn't found:\n  ID: " + id);
			}
			return flag;
		}

		internal string Add(IWebSocketSession session)
		{
			lock (_sync)
			{
				if (_state != ServerState.Start)
				{
					return null;
				}
				string text = createID();
				_sessions.Add(text, session);
				return text;
			}
		}

		internal void Broadcast(Opcode opcode, byte[] data, Dictionary<CompressionMethod, byte[]> cache)
		{
			foreach (IWebSocketSession session in Sessions)
			{
				if (_state != ServerState.Start)
				{
					break;
				}
				session.Context.WebSocket.Send(opcode, data, cache);
			}
		}

		internal void Broadcast(Opcode opcode, Stream stream, Dictionary<CompressionMethod, Stream> cache)
		{
			foreach (IWebSocketSession session in Sessions)
			{
				if (_state != ServerState.Start)
				{
					break;
				}
				session.Context.WebSocket.Send(opcode, stream, cache);
			}
		}

		internal Dictionary<string, bool> Broadping(byte[] frameAsBytes, TimeSpan timeout)
		{
			Dictionary<string, bool> dictionary = new Dictionary<string, bool>();
			foreach (IWebSocketSession session in Sessions)
			{
				if (_state != ServerState.Start)
				{
					break;
				}
				dictionary.Add(session.ID, session.Context.WebSocket.Ping(frameAsBytes, timeout));
			}
			return dictionary;
		}

		internal bool Remove(string id)
		{
			lock (_sync)
			{
				return _sessions.Remove(id);
			}
		}

		internal void Start()
		{
			lock (_sync)
			{
				_sweepTimer.Enabled = _clean;
				_state = ServerState.Start;
			}
		}

		internal void Stop(CloseEventArgs e, byte[] frameAsBytes, bool receive)
		{
			lock (_sync)
			{
				_state = ServerState.ShuttingDown;
				_sweepTimer.Enabled = false;
				foreach (IWebSocketSession item in _sessions.Values.ToList())
				{
					item.Context.WebSocket.Close(e, frameAsBytes, receive);
				}
				_state = ServerState.Stop;
			}
		}

		public void Broadcast(byte[] data)
		{
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
			if (text != null)
			{
				_logger.Error(text);
			}
			else if (data.LongLength <= WebSocket.FragmentLength)
			{
				broadcast(Opcode.Binary, data, null);
			}
			else
			{
				broadcast(Opcode.Binary, new MemoryStream(data), null);
			}
		}

		public void Broadcast(string data)
		{
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
			if (text != null)
			{
				_logger.Error(text);
				return;
			}
			byte[] array = data.UTF8Encode();
			if (array.LongLength <= WebSocket.FragmentLength)
			{
				broadcast(Opcode.Text, array, null);
			}
			else
			{
				broadcast(Opcode.Text, new MemoryStream(array), null);
			}
		}

		public void BroadcastAsync(byte[] data, Action completed)
		{
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
			if (text != null)
			{
				_logger.Error(text);
			}
			else if (data.LongLength <= WebSocket.FragmentLength)
			{
				broadcastAsync(Opcode.Binary, data, completed);
			}
			else
			{
				broadcastAsync(Opcode.Binary, new MemoryStream(data), completed);
			}
		}

		public void BroadcastAsync(string data, Action completed)
		{
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
			if (text != null)
			{
				_logger.Error(text);
				return;
			}
			byte[] array = data.UTF8Encode();
			if (array.LongLength <= WebSocket.FragmentLength)
			{
				broadcastAsync(Opcode.Text, array, completed);
			}
			else
			{
				broadcastAsync(Opcode.Text, new MemoryStream(array), completed);
			}
		}

		public void BroadcastAsync(Stream stream, int length, Action completed)
		{
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameters(stream, length);
			if (text != null)
			{
				_logger.Error(text);
				return;
			}
			stream.ReadBytesAsync(length, delegate(byte[] data)
			{
				int num = data.Length;
				if (num == 0)
				{
					_logger.Error("The data cannot be read from 'stream'.");
				}
				else
				{
					if (num < length)
					{
						_logger.Warn($"The data with 'length' cannot be read from 'stream':\n  expected: {length}\n  actual: {num}");
					}
					if (num <= WebSocket.FragmentLength)
					{
						broadcast(Opcode.Binary, data, completed);
					}
					else
					{
						broadcast(Opcode.Binary, new MemoryStream(data), completed);
					}
				}
			}, delegate(Exception ex)
			{
				_logger.Fatal(ex.ToString());
			});
		}

		public Dictionary<string, bool> Broadping()
		{
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
				return null;
			}
			return Broadping(WebSocketFrame.EmptyPingBytes, _waitTime);
		}

		public Dictionary<string, bool> Broadping(string message)
		{
			if (message == null || message.Length == 0)
			{
				return Broadping();
			}
			byte[] bytes = null;
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckPingParameter(message, out bytes);
			if (text != null)
			{
				_logger.Error(text);
				return null;
			}
			return Broadping(WebSocketFrame.CreatePingFrame(bytes, mask: false).ToArray(), _waitTime);
		}

		public void CloseSession(string id)
		{
			if (TryGetSession(id, out var session))
			{
				session.Context.WebSocket.Close();
			}
		}

		public void CloseSession(string id, ushort code, string reason)
		{
			if (TryGetSession(id, out var session))
			{
				session.Context.WebSocket.Close(code, reason);
			}
		}

		public void CloseSession(string id, CloseStatusCode code, string reason)
		{
			if (TryGetSession(id, out var session))
			{
				session.Context.WebSocket.Close(code, reason);
			}
		}

		public bool PingTo(string id)
		{
			IWebSocketSession session;
			return TryGetSession(id, out session) && session.Context.WebSocket.Ping();
		}

		public bool PingTo(string message, string id)
		{
			IWebSocketSession session;
			return TryGetSession(id, out session) && session.Context.WebSocket.Ping(message);
		}

		public void SendTo(byte[] data, string id)
		{
			if (TryGetSession(id, out var session))
			{
				session.Context.WebSocket.Send(data);
			}
		}

		public void SendTo(string data, string id)
		{
			if (TryGetSession(id, out var session))
			{
				session.Context.WebSocket.Send(data);
			}
		}

		public void SendToAsync(byte[] data, string id, Action<bool> completed)
		{
			if (TryGetSession(id, out var session))
			{
				session.Context.WebSocket.SendAsync(data, completed);
			}
		}

		public void SendToAsync(string data, string id, Action<bool> completed)
		{
			if (TryGetSession(id, out var session))
			{
				session.Context.WebSocket.SendAsync(data, completed);
			}
		}

		public void SendToAsync(Stream stream, int length, string id, Action<bool> completed)
		{
			if (TryGetSession(id, out var session))
			{
				session.Context.WebSocket.SendAsync(stream, length, completed);
			}
		}

		public void Sweep()
		{
			if (_state != ServerState.Start || _sweeping || Count == 0)
			{
				return;
			}
			lock (_forSweep)
			{
				_sweeping = true;
				foreach (string inactiveID in InactiveIDs)
				{
					if (_state != ServerState.Start)
					{
						break;
					}
					lock (_sync)
					{
						if (_sessions.TryGetValue(inactiveID, out var value))
						{
							switch (value.State)
							{
							case WebSocketState.Open:
								value.Context.WebSocket.Close(CloseStatusCode.ProtocolError);
								break;
							case WebSocketState.Closing:
								break;
							default:
								_sessions.Remove(inactiveID);
								break;
							}
						}
					}
				}
				_sweeping = false;
			}
		}

		public bool TryGetSession(string id, out IWebSocketSession session)
		{
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? id.CheckIfValidSessionID();
			if (text != null)
			{
				_logger.Error(text);
				session = null;
				return false;
			}
			return tryGetSession(id, out session);
		}
	}
	internal enum ServerState
	{
		Ready,
		Start,
		ShuttingDown,
		Stop
	}
	public class WebSocketServiceManager
	{
		private volatile bool _clean;

		private Dictionary<string, WebSocketServiceHost> _hosts;

		private Logger _logger;

		private volatile ServerState _state;

		private object _sync;

		private TimeSpan _waitTime;

		public int Count
		{
			get
			{
				lock (_sync)
				{
					return _hosts.Count;
				}
			}
		}

		public IEnumerable<WebSocketServiceHost> Hosts
		{
			get
			{
				lock (_sync)
				{
					return _hosts.Values.ToList();
				}
			}
		}

		public WebSocketServiceHost this[string path]
		{
			get
			{
				TryGetServiceHost(path, out var host);
				return host;
			}
		}

		public bool KeepClean
		{
			get
			{
				return _clean;
			}
			internal set
			{
				lock (_sync)
				{
					if (value == _clean)
					{
						return;
					}
					_clean = value;
					foreach (WebSocketServiceHost value2 in _hosts.Values)
					{
						value2.KeepClean = value;
					}
				}
			}
		}

		public IEnumerable<string> Paths
		{
			get
			{
				lock (_sync)
				{
					return _hosts.Keys.ToList();
				}
			}
		}

		public int SessionCount
		{
			get
			{
				int num = 0;
				foreach (WebSocketServiceHost host in Hosts)
				{
					if (_state != ServerState.Start)
					{
						break;
					}
					num += host.Sessions.Count;
				}
				return num;
			}
		}

		public TimeSpan WaitTime
		{
			get
			{
				return _waitTime;
			}
			internal set
			{
				lock (_sync)
				{
					if (value == _waitTime)
					{
						return;
					}
					_waitTime = value;
					foreach (WebSocketServiceHost value2 in _hosts.Values)
					{
						value2.WaitTime = value;
					}
				}
			}
		}

		internal WebSocketServiceManager()
			: this(new Logger())
		{
		}

		internal WebSocketServiceManager(Logger logger)
		{
			_logger = logger;
			_clean = true;
			_hosts = new Dictionary<string, WebSocketServiceHost>();
			_state = ServerState.Ready;
			_sync = ((ICollection)_hosts).SyncRoot;
			_waitTime = TimeSpan.FromSeconds(1.0);
		}

		private void broadcast(Opcode opcode, byte[] data, Action completed)
		{
			Dictionary<CompressionMethod, byte[]> dictionary = new Dictionary<CompressionMethod, byte[]>();
			try
			{
				foreach (WebSocketServiceHost host in Hosts)
				{
					if (_state != ServerState.Start)
					{
						break;
					}
					host.Sessions.Broadcast(opcode, data, dictionary);
				}
				completed?.Invoke();
			}
			catch (Exception ex)
			{
				_logger.Fatal(ex.ToString());
			}
			finally
			{
				dictionary.Clear();
			}
		}

		private void broadcast(Opcode opcode, Stream stream, Action completed)
		{
			Dictionary<CompressionMethod, Stream> dictionary = new Dictionary<CompressionMethod, Stream>();
			try
			{
				foreach (WebSocketServiceHost host in Hosts)
				{
					if (_state != ServerState.Start)
					{
						break;
					}
					host.Sessions.Broadcast(opcode, stream, dictionary);
				}
				completed?.Invoke();
			}
			catch (Exception ex)
			{
				_logger.Fatal(ex.ToString());
			}
			finally
			{
				foreach (Stream value in dictionary.Values)
				{
					value.Dispose();
				}
				dictionary.Clear();
			}
		}

		private void broadcastAsync(Opcode opcode, byte[] data, Action completed)
		{
			ThreadPool.QueueUserWorkItem(delegate
			{
				broadcast(opcode, data, completed);
			});
		}

		private void broadcastAsync(Opcode opcode, Stream stream, Action completed)
		{
			ThreadPool.QueueUserWorkItem(delegate
			{
				broadcast(opcode, stream, completed);
			});
		}

		private Dictionary<string, Dictionary<string, bool>> broadping(byte[] frameAsBytes, TimeSpan timeout)
		{
			Dictionary<string, Dictionary<string, bool>> dictionary = new Dictionary<string, Dictionary<string, bool>>();
			foreach (WebSocketServiceHost host in Hosts)
			{
				if (_state != ServerState.Start)
				{
					break;
				}
				dictionary.Add(host.Path, host.Sessions.Broadping(frameAsBytes, timeout));
			}
			return dictionary;
		}

		internal void Add<TBehavior>(string path, Func<TBehavior> initializer) where TBehavior : WebSocketBehavior
		{
			lock (_sync)
			{
				path = HttpUtility.UrlDecode(path).TrimEndSlash();
				if (_hosts.TryGetValue(path, out var value))
				{
					_logger.Error("A WebSocket service with the specified path already exists:\n  path: " + path);
					return;
				}
				value = new WebSocketServiceHost<TBehavior>(path, initializer, _logger);
				if (!_clean)
				{
					value.KeepClean = false;
				}
				if (_waitTime != value.WaitTime)
				{
					value.WaitTime = _waitTime;
				}
				if (_state == ServerState.Start)
				{
					value.Start();
				}
				_hosts.Add(path, value);
			}
		}

		internal bool InternalTryGetServiceHost(string path, out WebSocketServiceHost host)
		{
			bool flag;
			lock (_sync)
			{
				path = HttpUtility.UrlDecode(path).TrimEndSlash();
				flag = _hosts.TryGetValue(path, out host);
			}
			if (!flag)
			{
				_logger.Error("A WebSocket service with the specified path isn't found:\n  path: " + path);
			}
			return flag;
		}

		internal bool Remove(string path)
		{
			WebSocketServiceHost value;
			lock (_sync)
			{
				path = HttpUtility.UrlDecode(path).TrimEndSlash();
				if (!_hosts.TryGetValue(path, out value))
				{
					_logger.Error("A WebSocket service with the specified path isn't found:\n  path: " + path);
					return false;
				}
				_hosts.Remove(path);
			}
			if (value.State == ServerState.Start)
			{
				value.Stop(1001, null);
			}
			return true;
		}

		internal void Start()
		{
			lock (_sync)
			{
				foreach (WebSocketServiceHost value in _hosts.Values)
				{
					value.Start();
				}
				_state = ServerState.Start;
			}
		}

		internal void Stop(CloseEventArgs e, bool send, bool receive)
		{
			lock (_sync)
			{
				_state = ServerState.ShuttingDown;
				byte[] frameAsBytes = (send ? WebSocketFrame.CreateCloseFrame(e.PayloadData, mask: false).ToArray() : null);
				foreach (WebSocketServiceHost value in _hosts.Values)
				{
					value.Sessions.Stop(e, frameAsBytes, receive);
				}
				_hosts.Clear();
				_state = ServerState.Stop;
			}
		}

		public void Broadcast(byte[] data)
		{
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
			if (text != null)
			{
				_logger.Error(text);
			}
			else if (data.LongLength <= WebSocket.FragmentLength)
			{
				broadcast(Opcode.Binary, data, null);
			}
			else
			{
				broadcast(Opcode.Binary, new MemoryStream(data), null);
			}
		}

		public void Broadcast(string data)
		{
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
			if (text != null)
			{
				_logger.Error(text);
				return;
			}
			byte[] array = data.UTF8Encode();
			if (array.LongLength <= WebSocket.FragmentLength)
			{
				broadcast(Opcode.Text, array, null);
			}
			else
			{
				broadcast(Opcode.Text, new MemoryStream(array), null);
			}
		}

		public void BroadcastAsync(byte[] data, Action completed)
		{
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
			if (text != null)
			{
				_logger.Error(text);
			}
			else if (data.LongLength <= WebSocket.FragmentLength)
			{
				broadcastAsync(Opcode.Binary, data, completed);
			}
			else
			{
				broadcastAsync(Opcode.Binary, new MemoryStream(data), completed);
			}
		}

		public void BroadcastAsync(string data, Action completed)
		{
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameter(data);
			if (text != null)
			{
				_logger.Error(text);
				return;
			}
			byte[] array = data.UTF8Encode();
			if (array.LongLength <= WebSocket.FragmentLength)
			{
				broadcastAsync(Opcode.Text, array, completed);
			}
			else
			{
				broadcastAsync(Opcode.Text, new MemoryStream(array), completed);
			}
		}

		public void BroadcastAsync(Stream stream, int length, Action completed)
		{
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckSendParameters(stream, length);
			if (text != null)
			{
				_logger.Error(text);
				return;
			}
			stream.ReadBytesAsync(length, delegate(byte[] data)
			{
				int num = data.Length;
				if (num == 0)
				{
					_logger.Error("The data cannot be read from 'stream'.");
				}
				else
				{
					if (num < length)
					{
						_logger.Warn($"The data with 'length' cannot be read from 'stream':\n  expected: {length}\n  actual: {num}");
					}
					if (num <= WebSocket.FragmentLength)
					{
						broadcast(Opcode.Binary, data, completed);
					}
					else
					{
						broadcast(Opcode.Binary, new MemoryStream(data), completed);
					}
				}
			}, delegate(Exception ex)
			{
				_logger.Fatal(ex.ToString());
			});
		}

		public Dictionary<string, Dictionary<string, bool>> Broadping()
		{
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false);
			if (text != null)
			{
				_logger.Error(text);
				return null;
			}
			return broadping(WebSocketFrame.EmptyPingBytes, _waitTime);
		}

		public Dictionary<string, Dictionary<string, bool>> Broadping(string message)
		{
			if (message == null || message.Length == 0)
			{
				return Broadping();
			}
			byte[] bytes = null;
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? WebSocket.CheckPingParameter(message, out bytes);
			if (text != null)
			{
				_logger.Error(text);
				return null;
			}
			return broadping(WebSocketFrame.CreatePingFrame(bytes, mask: false).ToArray(), _waitTime);
		}

		public bool TryGetServiceHost(string path, out WebSocketServiceHost host)
		{
			string text = _state.CheckIfAvailable(ready: false, start: true, shutting: false) ?? path.CheckIfValidServicePath();
			if (text != null)
			{
				_logger.Error(text);
				host = null;
				return false;
			}
			return InternalTryGetServiceHost(path, out host);
		}
	}
	public abstract class WebSocketBehavior : IWebSocketSession
	{
		private WebSocketContext _context;

		private Func<WebSocketSharp.Net.CookieCollection, WebSocketSharp.Net.CookieCollection, bool> _cookiesValidator;

		private bool _emitOnPing;

		private string _id;

		private bool _ignoreExtensions;

		private Func<string, bool> _originValidator;

		private string _protocol;

		private WebSocketSessionManager _sessions;

		private DateTime _startTime;

		private WebSocket _websocket;

		protected Logger Log => (_websocket != null) ? _websocket.Log : null;

		protected WebSocketSessionManager Sessions => _sessions;

		public WebSocketContext Context => _context;

		public Func<WebSocketSharp.Net.CookieCollection, WebSocketSharp.Net.CookieCollection, bool> CookiesValidator
		{
			get
			{
				return _cookiesValidator;
			}
			set
			{
				_cookiesValidator = value;
			}
		}

		public bool EmitOnPing
		{
			get
			{
				return (_websocket != null) ? _websocket.EmitOnPing : _emitOnPing;
			}
			set
			{
				if (_websocket != null)
				{
					_websocket.EmitOnPing = value;
				}
				else
				{
					_emitOnPing = value;
				}
			}
		}

		public string ID => _id;

		public bool IgnoreExtensions
		{
			get
			{
				return _ignoreExtensions;
			}
			set
			{
				_ignoreExtensions = value;
			}
		}

		public Func<string, bool> OriginValidator
		{
			get
			{
				return _originValidator;
			}
			set
			{
				_originValidator = value;
			}
		}

		public string Protocol
		{
			get
			{
				return (_websocket != null) ? _websocket.Protocol : (_protocol ?? string.Empty);
			}
			set
			{
				if (State == WebSocketState.Connecting && (value == null || (value.Length != 0 && value.IsToken())))
				{
					_protocol = value;
				}
			}
		}

		public DateTime StartTime => _startTime;

		public WebSocketState State => (_websocket != null) ? _websocket.ReadyState : WebSocketState.Connecting;

		protected WebSocketBehavior()
		{
			_startTime = DateTime.MaxValue;
		}

		private string checkHandshakeRequest(WebSocketContext context)
		{
			return (_originValidator != null && !_originValidator(context.Origin)) ? "Includes no Origin header, or it has an invalid value." : ((_cookiesValidator != null && !_cookiesValidator(context.CookieCollection, context.WebSocket.CookieCollection)) ? "Includes no cookie, or an invalid cookie exists." : null);
		}

		private void onClose(object sender, CloseEventArgs e)
		{
			if (_id != null)
			{
				_sessions.Remove(_id);
				OnClose(e);
			}
		}

		private void onError(object sender, ErrorEventArgs e)
		{
			OnError(e);
		}

		private void onMessage(object sender, MessageEventArgs e)
		{
			OnMessage(e);
		}

		private void onOpen(object sender, EventArgs e)
		{
			_id = _sessions.Add(this);
			if (_id == null)
			{
				_websocket.Close(CloseStatusCode.Away);
				return;
			}
			_startTime = DateTime.Now;
			OnOpen();
		}

		internal void Start(WebSocketContext context, WebSocketSessionManager sessions)
		{
			if (_websocket != null)
			{
				_websocket.Log.Error("This session has already been started.");
				context.WebSocket.Close(WebSocketSharp.Net.HttpStatusCode.ServiceUnavailable);
				return;
			}
			_context = context;
			_sessions = sessions;
			_websocket = context.WebSocket;
			_websocket.CustomHandshakeRequestChecker = checkHandshakeRequest;
			_websocket.EmitOnPing = _emitOnPing;
			_websocket.IgnoreExtensions = _ignoreExtensions;
			_websocket.Protocol = _protocol;
			TimeSpan waitTime = sessions.WaitTime;
			if (waitTime != _websocket.WaitTime)
			{
				_websocket.WaitTime = waitTime;
			}
			_websocket.OnOpen += onOpen;
			_websocket.OnMessage += onMessage;
			_websocket.OnError += onError;
			_websocket.OnClose += onClose;
			_websocket.InternalAccept();
		}

		protected void Error(string message, Exception exception)
		{
			if (message != null && message.Length > 0)
			{
				OnError(new ErrorEventArgs(message, exception));
			}
		}

		protected virtual void OnClose(CloseEventArgs e)
		{
		}

		protected virtual void OnError(ErrorEventArgs e)
		{
		}

		protected virtual void OnMessage(MessageEventArgs e)
		{
		}

		protected virtual void OnOpen()
		{
		}

		protected void Send(byte[] data)
		{
			if (_websocket != null)
			{
				_websocket.Send(data);
			}
		}

		protected void Send(FileInfo file)
		{
			if (_websocket != null)
			{
				_websocket.Send(file);
			}
		}

		protected void Send(string data)
		{
			if (_websocket != null)
			{
				_websocket.Send(data);
			}
		}

		protected void SendAsync(byte[] data, Action<bool> completed)
		{
			if (_websocket != null)
			{
				_websocket.SendAsync(data, completed);
			}
		}

		protected void SendAsync(FileInfo file, Action<bool> completed)
		{
			if (_websocket != null)
			{
				_websocket.SendAsync(file, completed);
			}
		}

		protected void SendAsync(string data, Action<bool> completed)
		{
			if (_websocket != null)
			{
				_websocket.SendAsync(data, completed);
			}
		}

		protected void SendAsync(Stream stream, int length, Action<bool> completed)
		{
			if (_websocket != null)
			{
				_websocket.SendAsync(stream, length, completed);
			}
		}
	}
	internal class WebSocketServiceHost<TBehavior> : WebSocketServiceHost where TBehavior : WebSocketBehavior
	{
		private Func<TBehavior> _initializer;

		private Logger _logger;

		private string _path;

		private WebSocketSessionManager _sessions;

		public override bool KeepClean
		{
			get
			{
				return _sessions.KeepClean;
			}
			set
			{
				string text = _sessions.State.CheckIfAvailable(ready: true, start: false, shutting: false);
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_sessions.KeepClean = value;
				}
			}
		}

		public override string Path => _path;

		public override WebSocketSessionManager Sessions => _sessions;

		public override Type Type => typeof(TBehavior);

		public override TimeSpan WaitTime
		{
			get
			{
				return _sessions.WaitTime;
			}
			set
			{
				string text = _sessions.State.CheckIfAvailable(ready: true, start: false, shutting: false) ?? value.CheckIfValidWaitTime();
				if (text != null)
				{
					_logger.Error(text);
				}
				else
				{
					_sessions.WaitTime = value;
				}
			}
		}

		internal WebSocketServiceHost(string path, Func<TBehavior> initializer, Logger logger)
		{
			_path = path;
			_initializer = initializer;
			_logger = logger;
			_sessions = new WebSocketSessionManager(logger);
		}

		protected override WebSocketBehavior CreateSession()
		{
			return _initializer();
		}
	}
}
[CompilerGenerated]
internal sealed class <35d1ffca-3c70-4a84-83d7-0680f018ddea><PrivateImplementationDetails>
{
	[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 14)]
	private struct __StaticArrayInitTypeSize=14
	{
	}

	internal static readonly __StaticArrayInitTypeSize=14 49BE292FEFD2E3B7218C9123B9A016847C2A5C96/* Not supported: data(20 00 3D 00 3B 00 2C 00 0A 00 0D 00 09 00) */;

	internal static readonly long 6532575F81314AADD4BCFD96F1517D5BBFF2B60B/* Not supported: data(26 00 22 00 3C 00 3E 00) */;
}
internal static class Consts
{
	public const string MonoVersion = "2.6.5.0";

	public const string MonoCompany = "MONO development team";

	public const string MonoProduct = "MONO Common language infrastructure";

	public const string MonoCopyright = "(c) various MONO Authors";

	public const string FxVersion = "2.0.0.0";

	public const string VsVersion = "8.0.0.0";

	public const string FxFileVersion = "2.0.50727.1433";

	public const string VsFileVersion = "8.0.50727.1433";

	public const string AssemblyI18N = "I18N, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMicrosoft_VisualStudio = "Microsoft.VisualStudio, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblyMicrosoft_VisualStudio_Web = "Microsoft.VisualStudio.Web, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblyMicrosoft_VSDesigner = "Microsoft.VSDesigner, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblyMono_Http = "Mono.Http, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMono_Posix = "Mono.Posix, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMono_Security = "Mono.Security, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMono_Messaging_RabbitMQ = "Mono.Messaging.RabbitMQ, Version=2.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyCorlib = "mscorlib, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem = "System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem_Data = "System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem_Design = "System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_DirectoryServices = "System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Drawing = "System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Drawing_Design = "System.Drawing.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Messaging = "System.Messaging, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Security = "System.Security, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_ServiceProcess = "System.ServiceProcess, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Web = "System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Windows_Forms = "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem_Core = "System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
}
internal sealed class Locale
{
	private Locale()
	{
	}

	public static string GetText(string msg)
	{
		return msg;
	}

	public static string GetText(string fmt, params object[] args)
	{
		return string.Format(fmt, args);
	}
}
namespace Mono.Unix
{
	[Serializable]
	public class AbstractUnixEndPoint : EndPoint
	{
		private string path;

		public string Path
		{
			get
			{
				return path;
			}
			set
			{
				path = value;
			}
		}

		public override AddressFamily AddressFamily => AddressFamily.Unix;

		public AbstractUnixEndPoint(string path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			if (path == string.Empty)
			{
				throw new ArgumentException("Cannot be empty.", "path");
			}
			this.path = path;
		}

		public override EndPoint Create(SocketAddress socketAddress)
		{
			byte[] array = new byte[socketAddress.Size - 2 - 1];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = socketAddress[3 + i];
			}
			string text = Encoding.Default.GetString(array);
			return new AbstractUnixEndPoint(text);
		}

		public override SocketAddress Serialize()
		{
			byte[] bytes = Encoding.Default.GetBytes(path);
			SocketAddress socketAddress = new SocketAddress(AddressFamily, 3 + bytes.Length);
			socketAddress[2] = 0;
			for (int i = 0; i < bytes.Length; i++)
			{
				socketAddress[i + 2 + 1] = bytes[i];
			}
			return socketAddress;
		}

		public override string ToString()
		{
			return path;
		}

		public override int GetHashCode()
		{
			return path.GetHashCode();
		}

		public override bool Equals(object o)
		{
			if (!(o is AbstractUnixEndPoint abstractUnixEndPoint))
			{
				return false;
			}
			return abstractUnixEndPoint.path == path;
		}
	}
	public class Catalog
	{
		private Catalog()
		{
		}

		[DllImport("intl")]
		private static extern IntPtr bindtextdomain(IntPtr domainname, IntPtr dirname);

		[DllImport("intl")]
		private static extern IntPtr bind_textdomain_codeset(IntPtr domainname, IntPtr codeset);

		[DllImport("intl")]
		private static extern IntPtr textdomain(IntPtr domainname);

		public static void Init(string package, string localedir)
		{
			MarshalStrings(package, out var p, localedir, out var p2, "UTF-8", out var p3);
			try
			{
				if (bindtextdomain(p, p2) == IntPtr.Zero)
				{
					throw new UnixIOException(Errno.ENOMEM);
				}
				if (bind_textdomain_codeset(p, p3) == IntPtr.Zero)
				{
					throw new UnixIOException(Errno.ENOMEM);
				}
				if (textdomain(p) == IntPtr.Zero)
				{
					throw new UnixIOException(Errno.ENOMEM);
				}
			}
			finally
			{
				UnixMarshal.FreeHeap(p);
				UnixMarshal.FreeHeap(p2);
				UnixMarshal.FreeHeap(p3);
			}
		}

		private static void MarshalStrings(string s1, out IntPtr p1, string s2, out IntPtr p2, string s3, out IntPtr p3)
		{
			p1 = (p2 = (p3 = IntPtr.Zero));
			bool flag = true;
			try
			{
				p1 = UnixMarshal.StringToHeap(s1);
				p2 = UnixMarshal.StringToHeap(s2);
				if (s3 != null)
				{
					p3 = UnixMarshal.StringToHeap(s3);
				}
				flag = false;
			}
			finally
			{
				if (flag)
				{
					UnixMarshal.FreeHeap(p1);
					UnixMarshal.FreeHeap(p2);
					UnixMarshal.FreeHeap(p3);
				}
			}
		}

		[DllImport("intl")]
		private static extern IntPtr gettext(IntPtr instring);

		public static string GetString(string s)
		{
			IntPtr intPtr = UnixMarshal.StringToHeap(s);
			try
			{
				IntPtr intPtr2 = gettext(intPtr);
				if (intPtr2 != intPtr)
				{
					return UnixMarshal.PtrToStringUnix(intPtr2);
				}
				return s;
			}
			finally
			{
				UnixMarshal.FreeHeap(intPtr);
			}
		}

		[DllImport("intl")]
		private static extern IntPtr ngettext(IntPtr singular, IntPtr plural, int n);

		public static string GetPluralString(string s, string p, int n)
		{
			MarshalStrings(s, out var p2, p, out var p3, null, out var _);
			try
			{
				IntPtr intPtr = ngettext(p2, p3, n);
				if (intPtr == p2)
				{
					return s;
				}
				if (intPtr == p3)
				{
					return p;
				}
				return UnixMarshal.PtrToStringUnix(intPtr);
			}
			finally
			{
				UnixMarshal.FreeHeap(p2);
				UnixMarshal.FreeHeap(p3);
			}
		}
	}
	[Flags]
	public enum FileAccessPermissions
	{
		UserReadWriteExecute = 0x1C0,
		UserRead = 0x100,
		UserWrite = 0x80,
		UserExecute = 0x40,
		GroupReadWriteExecute = 0x38,
		GroupRead = 0x20,
		GroupWrite = 0x10,
		GroupExecute = 8,
		OtherReadWriteExecute = 7,
		OtherRead = 4,
		OtherWrite = 2,
		OtherExecute = 1,
		DefaultPermissions = 0x1B6,
		AllPermissions = 0x1FF
	}
	public enum FileAccessPattern
	{
		Normal = 0,
		Sequential = 2,
		Random = 1,
		NoReuse = 5,
		PreLoad = 3,
		FlushCache = 4
	}
	public sealed class FileHandleOperations
	{
		private FileHandleOperations()
		{
		}

		public static void AdviseFileAccessPattern(int fd, FileAccessPattern pattern, long offset, long len)
		{
			int retval = Mono.Unix.Native.Syscall.posix_fadvise(fd, offset, len, (PosixFadviseAdvice)pattern);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}

		public static void AdviseFileAccessPattern(int fd, FileAccessPattern pattern)
		{
			AdviseFileAccessPattern(fd, pattern, 0L, 0L);
		}

		public static void AdviseFileAccessPattern(FileStream file, FileAccessPattern pattern, long offset, long len)
		{
			if (file == null)
			{
				throw new ArgumentNullException("file");
			}
			int retval = Mono.Unix.Native.Syscall.posix_fadvise(file.Handle.ToInt32(), offset, len, (PosixFadviseAdvice)pattern);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}

		public static void AdviseFileAccessPattern(FileStream file, FileAccessPattern pattern)
		{
			AdviseFileAccessPattern(file, pattern, 0L, 0L);
		}

		public static void AdviseFileAccessPattern(UnixStream stream, FileAccessPattern pattern, long offset, long len)
		{
			if (stream == null)
			{
				throw new ArgumentNullException("stream");
			}
			int retval = Mono.Unix.Native.Syscall.posix_fadvise(stream.Handle, offset, len, (PosixFadviseAdvice)pattern);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}

		public static void AdviseFileAccessPattern(UnixStream stream, FileAccessPattern pattern)
		{
			AdviseFileAccessPattern(stream, pattern, 0L, 0L);
		}
	}
	[Flags]
	public enum FileSpecialAttributes
	{
		SetUserId = 0x800,
		SetGroupId = 0x400,
		Sticky = 0x200
	}
	public enum FileTypes
	{
		Directory = 16384,
		CharacterDevice = 8192,
		BlockDevice = 24576,
		RegularFile = 32768,
		Fifo = 4096,
		SymbolicLink = 40960,
		Socket = 49152
	}
	public class PeerCred
	{
		private const int so_peercred = 10001;

		private PeerCredData data;

		public int ProcessID => data.pid;

		public int UserID => data.uid;

		public int GroupID => data.gid;

		public PeerCred(Socket sock)
		{
			if (sock.AddressFamily != AddressFamily.Unix)
			{
				throw new ArgumentException("Only Unix sockets are supported", "sock");
			}
			data = (PeerCredData)sock.GetSocketOption(SocketOptionLevel.Socket, (SocketOptionName)10001);
		}
	}
	public class StdioFileStream : Stream
	{
		public static readonly IntPtr InvalidFileStream = IntPtr.Zero;

		public static readonly IntPtr StandardInput = Stdlib.stdin;

		public static readonly IntPtr StandardOutput = Stdlib.stdout;

		public static readonly IntPtr StandardError = Stdlib.stderr;

		private bool canSeek;

		private bool canRead;

		private bool canWrite;

		private bool owner = true;

		private IntPtr file = InvalidFileStream;

		public IntPtr Handle
		{
			get
			{
				AssertNotDisposed();
				GC.KeepAlive(this);
				return file;
			}
		}

		public override bool CanRead => canRead;

		public override bool CanSeek => canSeek;

		public override bool CanWrite => canWrite;

		public override long Length
		{
			get
			{
				AssertNotDisposed();
				if (!CanSeek)
				{
					throw new NotSupportedException("File Stream doesn't support seeking");
				}
				long num = Stdlib.ftell(file);
				if (num == -1)
				{
					throw new NotSupportedException("Unable to obtain current file position");
				}
				int retval = Stdlib.fseek(file, 0L, SeekFlags.SEEK_END);
				UnixMarshal.ThrowExceptionForLastErrorIf(retval);
				long num2 = Stdlib.ftell(file);
				if (num2 == -1)
				{
					UnixMarshal.ThrowExceptionForLastError();
				}
				retval = Stdlib.fseek(file, num, SeekFlags.SEEK_SET);
				UnixMarshal.ThrowExceptionForLastErrorIf(retval);
				GC.KeepAlive(this);
				return num2;
			}
		}

		public override long Position
		{
			get
			{
				AssertNotDisposed();
				if (!CanSeek)
				{
					throw new NotSupportedException("The stream does not support seeking");
				}
				long num = Stdlib.ftell(file);
				if (num == -1)
				{
					UnixMarshal.ThrowExceptionForLastError();
				}
				GC.KeepAlive(this);
				return num;
			}
			set
			{
				AssertNotDisposed();
				Seek(value, SeekOrigin.Begin);
			}
		}

		public StdioFileStream(IntPtr fileStream)
			: this(fileStream, ownsHandle: true)
		{
		}

		public StdioFileStream(IntPtr fileStream, bool ownsHandle)
		{
			InitStream(fileStream, ownsHandle);
		}

		public StdioFileStream(IntPtr fileStream, FileAccess access)
			: this(fileStream, access, ownsHandle: true)
		{
		}

		public StdioFileStream(IntPtr fileStream, FileAccess access, bool ownsHandle)
		{
			InitStream(fileStream, ownsHandle);
			InitCanReadWrite(access);
		}

		public StdioFileStream(string path)
		{
			InitStream(Fopen(path, "rb"), ownsHandle: true);
		}

		public StdioFileStream(string path, string mode)
		{
			InitStream(Fopen(path, mode), ownsHandle: true);
		}

		public StdioFileStream(string path, System.IO.FileMode mode)
		{
			InitStream(Fopen(path, ToFopenMode(path, mode)), ownsHandle: true);
		}

		public StdioFileStream(string path, FileAccess access)
		{
			InitStream(Fopen(path, ToFopenMode(path, access)), ownsHandle: true);
			InitCanReadWrite(access);
		}

		public StdioFileStream(string path, System.IO.FileMode mode, FileAccess access)
		{
			InitStream(Fopen(path, ToFopenMode(path, mode, access)), ownsHandle: true);
			InitCanReadWrite(access);
		}

		private static IntPtr Fopen(string path, string mode)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			if (path.Length == 0)
			{
				throw new ArgumentException("path");
			}
			if (mode == null)
			{
				throw new ArgumentNullException("mode");
			}
			IntPtr intPtr = Stdlib.fopen(path, mode);
			if (intPtr == IntPtr.Zero)
			{
				throw new DirectoryNotFoundException("path", UnixMarshal.CreateExceptionForLastError());
			}
			return intPtr;
		}

		private void InitStream(IntPtr fileStream, bool ownsHandle)
		{
			if (InvalidFileStream == fileStream)
			{
				throw new ArgumentException(global::Locale.GetText("Invalid file stream"), "fileStream");
			}
			file = fileStream;
			owner = ownsHandle;
			try
			{
				long num = Stdlib.fseek(file, 0L, SeekFlags.SEEK_CUR);
				if (num != -1)
				{
					canSeek = true;
				}
				Stdlib.fread(IntPtr.Zero, 0uL, 0uL, file);
				if (Stdlib.ferror(file) == 0)
				{
					canRead = true;
				}
				Stdlib.fwrite(IntPtr.Zero, 0uL, 0uL, file);
				if (Stdlib.ferror(file) == 0)
				{
					canWrite = true;
				}
				Stdlib.clearerr(file);
			}
			catch (Exception)
			{
				throw new ArgumentException(global::Locale.GetText("Invalid file stream"), "fileStream");
			}
			GC.KeepAlive(this);
		}

		private void InitCanReadWrite(FileAccess access)
		{
			canRead = canRead && (access == FileAccess.Read || access == FileAccess.ReadWrite);
			canWrite = canWrite && (access == FileAccess.Write || access == FileAccess.ReadWrite);
		}

		private static string ToFopenMode(string file, System.IO.FileMode mode)
		{
			string result = NativeConvert.ToFopenMode(mode);
			AssertFileMode(file, mode);
			return result;
		}

		private static string ToFopenMode(string file, FileAccess access)
		{
			return NativeConvert.ToFopenMode(access);
		}

		private static string ToFopenMode(string file, System.IO.FileMode mode, FileAccess access)
		{
			string result = NativeConvert.ToFopenMode(mode, access);
			bool flag = AssertFileMode(file, mode);
			if (mode == System.IO.FileMode.OpenOrCreate && access == FileAccess.Read && !flag)
			{
				result = "w+b";
			}
			return result;
		}

		private static bool AssertFileMode(string file, System.IO.FileMode mode)
		{
			bool flag = FileExists(file);
			if (mode == System.IO.FileMode.CreateNew && flag)
			{
				throw new IOException("File exists and FileMode.CreateNew specified");
			}
			if ((mode == System.IO.FileMode.Open || mode == System.IO.FileMode.Truncate) && !flag)
			{
				throw new FileNotFoundException("File doesn't exist and FileMode.Open specified", file);
			}
			return flag;
		}

		private static bool FileExists(string file)
		{
			bool flag = false;
			IntPtr intPtr = Stdlib.fopen(file, "r");
			flag = intPtr != IntPtr.Zero;
			if (intPtr != IntPtr.Zero)
			{
				Stdlib.fclose(intPtr);
			}
			return flag;
		}

		private void AssertNotDisposed()
		{
			if (file == InvalidFileStream)
			{
				throw new ObjectDisposedException("Invalid File Stream");
			}
			GC.KeepAlive(this);
		}

		public void SaveFilePosition(FilePosition pos)
		{
			AssertNotDisposed();
			int retval = Stdlib.fgetpos(file, pos);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			GC.KeepAlive(this);
		}

		public void RestoreFilePosition(FilePosition pos)
		{
			AssertNotDisposed();
			if (pos == null)
			{
				throw new ArgumentNullException("value");
			}
			int retval = Stdlib.fsetpos(file, pos);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			GC.KeepAlive(this);
		}

		public override void Flush()
		{
			AssertNotDisposed();
			if (Stdlib.fflush(file) != 0)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			GC.KeepAlive(this);
		}

		public unsafe override int Read([In][Out] byte[] buffer, int offset, int count)
		{
			AssertNotDisposed();
			AssertValidBuffer(buffer, offset, count);
			if (!CanRead)
			{
				throw new NotSupportedException("Stream does not support reading");
			}
			ulong num = 0uL;
			fixed (byte* ptr = &buffer[offset])
			{
				num = Stdlib.fread(ptr, 1uL, (ulong)count, file);
			}
			if (num != (ulong)count && Stdlib.ferror(file) != 0)
			{
				throw new IOException();
			}
			GC.KeepAlive(this);
			return (int)num;
		}

		private void AssertValidBuffer(byte[] buffer, int offset, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", "< 0");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", "< 0");
			}
			if (offset > buffer.Length)
			{
				throw new ArgumentException("destination offset is beyond array size");
			}
			if (offset > buffer.Length - count)
			{
				throw new ArgumentException("would overrun buffer");
			}
		}

		public void Rewind()
		{
			AssertNotDisposed();
			Stdlib.rewind(file);
			GC.KeepAlive(this);
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			AssertNotDisposed();
			if (!CanSeek)
			{
				throw new NotSupportedException("The File Stream does not support seeking");
			}
			SeekFlags seekFlags = SeekFlags.SEEK_CUR;
			if (Stdlib.fseek(origin: origin switch
			{
				SeekOrigin.Begin => SeekFlags.SEEK_SET, 
				SeekOrigin.Current => SeekFlags.SEEK_CUR, 
				SeekOrigin.End => SeekFlags.SEEK_END, 
				_ => throw new ArgumentException("origin"), 
			}, stream: file, offset: offset) != 0)
			{
				throw new IOException("Unable to seek", UnixMarshal.CreateExceptionForLastError());
			}
			long num = Stdlib.ftell(file);
			if (num == -1)
			{
				throw new IOException("Unable to get current file position", UnixMarshal.CreateExceptionForLastError());
			}
			GC.KeepAlive(this);
			return num;
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException("ANSI C doesn't provide a way to truncate a file");
		}

		public unsafe override void Write(byte[] buffer, int offset, int count)
		{
			AssertNotDisposed();
			AssertValidBuffer(buffer, offset, count);
			if (!CanWrite)
			{
				throw new NotSupportedException("File Stream does not support writing");
			}
			ulong num = 0uL;
			fixed (byte* ptr = &buffer[offset])
			{
				num = Stdlib.fwrite(ptr, 1uL, (ulong)count, file);
			}
			if (num != (ulong)count)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			GC.KeepAlive(this);
		}

		~StdioFileStream()
		{
			Close();
		}

		public override void Close()
		{
			if (file == InvalidFileStream)
			{
				return;
			}
			if (owner)
			{
				if (Stdlib.fclose(file) != 0)
				{
					UnixMarshal.ThrowExceptionForLastError();
				}
			}
			else
			{
				Flush();
			}
			file = InvalidFileStream;
			canRead = false;
			canSeek = false;
			canWrite = false;
			GC.SuppressFinalize(this);
			GC.KeepAlive(this);
		}
	}
	public class UnixClient : MarshalByRefObject, IDisposable
	{
		private NetworkStream stream;

		private Socket client;

		private bool disposed;

		public Socket Client
		{
			get
			{
				return client;
			}
			set
			{
				client = value;
				stream = null;
			}
		}

		public PeerCred PeerCredential
		{
			get
			{
				CheckDisposed();
				return new PeerCred(client);
			}
		}

		public LingerOption LingerState
		{
			get
			{
				CheckDisposed();
				return (LingerOption)client.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Linger);
			}
			set
			{
				CheckDisposed();
				client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Linger, value);
			}
		}

		public int ReceiveBufferSize
		{
			get
			{
				CheckDisposed();
				return (int)client.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer);
			}
			set
			{
				CheckDisposed();
				client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveBuffer, value);
			}
		}

		public int ReceiveTimeout
		{
			get
			{
				CheckDisposed();
				return (int)client.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout);
			}
			set
			{
				CheckDisposed();
				client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReceiveTimeout, value);
			}
		}

		public int SendBufferSize
		{
			get
			{
				CheckDisposed();
				return (int)client.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer);
			}
			set
			{
				CheckDisposed();
				client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendBuffer, value);
			}
		}

		public int SendTimeout
		{
			get
			{
				CheckDisposed();
				return (int)client.GetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout);
			}
			set
			{
				CheckDisposed();
				client.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.SendTimeout, value);
			}
		}

		public UnixClient()
		{
			if (client != null)
			{
				client.Close();
				client = null;
			}
			client = new Socket(AddressFamily.Unix, SocketType.Stream, ProtocolType.IP);
		}

		public UnixClient(string path)
			: this()
		{
			if (path == null)
			{
				throw new ArgumentNullException("ep");
			}
			Connect(path);
		}

		public UnixClient(UnixEndPoint ep)
			: this()
		{
			if (ep == null)
			{
				throw new ArgumentNullException("ep");
			}
			Connect(ep);
		}

		internal UnixClient(Socket sock)
		{
			Client = sock;
		}

		public void Close()
		{
			CheckDisposed();
			Dispose();
		}

		public void Connect(UnixEndPoint remoteEndPoint)
		{
			CheckDisposed();
			client.Connect(remoteEndPoint);
			stream = new NetworkStream(client, ownsSocket: true);
		}

		public void Connect(string path)
		{
			CheckDisposed();
			Connect(new UnixEndPoint(path));
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (disposed)
			{
				return;
			}
			if (disposing)
			{
				NetworkStream networkStream = stream;
				stream = null;
				if (networkStream != null)
				{
					networkStream.Close();
					networkStream = null;
				}
				else if (client != null)
				{
					client.Close();
				}
				client = null;
			}
			disposed = true;
		}

		public NetworkStream GetStream()
		{
			CheckDisposed();
			if (stream == null)
			{
				stream = new NetworkStream(client, ownsSocket: true);
			}
			return stream;
		}

		private void CheckDisposed()
		{
			if (disposed)
			{
				throw new ObjectDisposedException(GetType().FullName);
			}
		}

		~UnixClient()
		{
			Dispose(disposing: false);
		}
	}
	public sealed class UnixDirectoryInfo : UnixFileSystemInfo
	{
		public override string Name
		{
			get
			{
				string fileName = UnixPath.GetFileName(base.FullPath);
				if (fileName == null || fileName.Length == 0)
				{
					return base.FullPath;
				}
				return fileName;
			}
		}

		public UnixDirectoryInfo Parent
		{
			get
			{
				if (base.FullPath == "/")
				{
					return this;
				}
				string directoryName = UnixPath.GetDirectoryName(base.FullPath);
				if (directoryName == string.Empty)
				{
					throw new InvalidOperationException("Do not know parent directory for path `" + base.FullPath + "'");
				}
				return new UnixDirectoryInfo(directoryName);
			}
		}

		public UnixDirectoryInfo Root
		{
			get
			{
				string pathRoot = UnixPath.GetPathRoot(base.FullPath);
				if (pathRoot == null)
				{
					return null;
				}
				return new UnixDirectoryInfo(pathRoot);
			}
		}

		public UnixDirectoryInfo(string path)
			: base(path)
		{
		}

		internal UnixDirectoryInfo(string path, Mono.Unix.Native.Stat stat)
			: base(path, stat)
		{
		}

		[CLSCompliant(false)]
		public void Create(FilePermissions mode)
		{
			int retval = Mono.Unix.Native.Syscall.mkdir(base.FullPath, mode);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			Refresh();
		}

		public void Create(FileAccessPermissions mode)
		{
			Create((FilePermissions)mode);
		}

		public void Create()
		{
			FilePermissions mode = FilePermissions.ACCESSPERMS;
			Create(mode);
		}

		public override void Delete()
		{
			Delete(recursive: false);
		}

		public void Delete(bool recursive)
		{
			if (recursive)
			{
				UnixFileSystemInfo[] fileSystemEntries = GetFileSystemEntries();
				foreach (UnixFileSystemInfo unixFileSystemInfo in fileSystemEntries)
				{
					if (unixFileSystemInfo is UnixDirectoryInfo unixDirectoryInfo)
					{
						unixDirectoryInfo.Delete(recursive: true);
					}
					else
					{
						unixFileSystemInfo.Delete();
					}
				}
			}
			int retval = Mono.Unix.Native.Syscall.rmdir(base.FullPath);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			Refresh();
		}

		public Dirent[] GetEntries()
		{
			IntPtr intPtr = Mono.Unix.Native.Syscall.opendir(base.FullPath);
			if (intPtr == IntPtr.Zero)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			bool flag = false;
			try
			{
				Dirent[] entries = GetEntries(intPtr);
				flag = true;
				return entries;
			}
			finally
			{
				int retval = Mono.Unix.Native.Syscall.closedir(intPtr);
				if (flag)
				{
					UnixMarshal.ThrowExceptionForLastErrorIf(retval);
				}
			}
		}

		private static Dirent[] GetEntries(IntPtr dirp)
		{
			ArrayList arrayList = new ArrayList();
			int num;
			IntPtr result;
			do
			{
				Dirent dirent = new Dirent();
				num = Mono.Unix.Native.Syscall.readdir_r(dirp, dirent, out result);
				if (num == 0 && result != IntPtr.Zero && dirent.d_name != "." && dirent.d_name != "..")
				{
					arrayList.Add(dirent);
				}
			}
			while (num == 0 && result != IntPtr.Zero);
			if (num != 0)
			{
				UnixMarshal.ThrowExceptionForLastErrorIf(num);
			}
			return (Dirent[])arrayList.ToArray(typeof(Dirent));
		}

		public Dirent[] GetEntries(Regex regex)
		{
			IntPtr intPtr = Mono.Unix.Native.Syscall.opendir(base.FullPath);
			if (intPtr == IntPtr.Zero)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			try
			{
				return GetEntries(intPtr, regex);
			}
			finally
			{
				int retval = Mono.Unix.Native.Syscall.closedir(intPtr);
				UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			}
		}

		private static Dirent[] GetEntries(IntPtr dirp, Regex regex)
		{
			ArrayList arrayList = new ArrayList();
			int num;
			IntPtr result;
			do
			{
				Dirent dirent = new Dirent();
				num = Mono.Unix.Native.Syscall.readdir_r(dirp, dirent, out result);
				if (num == 0 && result != IntPtr.Zero && regex.Match(dirent.d_name).Success && dirent.d_name != "." && dirent.d_name != "..")
				{
					arrayList.Add(dirent);
				}
			}
			while (num == 0 && result != IntPtr.Zero);
			if (num != 0)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			return (Dirent[])arrayList.ToArray(typeof(Dirent));
		}

		public Dirent[] GetEntries(string regex)
		{
			Regex regex2 = new Regex(regex);
			return GetEntries(regex2);
		}

		public UnixFileSystemInfo[] GetFileSystemEntries()
		{
			Dirent[] entries = GetEntries();
			return GetFileSystemEntries(entries);
		}

		private UnixFileSystemInfo[] GetFileSystemEntries(Dirent[] dentries)
		{
			UnixFileSystemInfo[] array = new UnixFileSystemInfo[dentries.Length];
			for (int i = 0; i != array.Length; i++)
			{
				array[i] = UnixFileSystemInfo.GetFileSystemEntry(UnixPath.Combine(base.FullPath, dentries[i].d_name));
			}
			return array;
		}

		public UnixFileSystemInfo[] GetFileSystemEntries(Regex regex)
		{
			Dirent[] entries = GetEntries(regex);
			return GetFileSystemEntries(entries);
		}

		public UnixFileSystemInfo[] GetFileSystemEntries(string regex)
		{
			Regex regex2 = new Regex(regex);
			return GetFileSystemEntries(regex2);
		}

		public static string GetCurrentDirectory()
		{
			StringBuilder stringBuilder = new StringBuilder(16);
			IntPtr zero = IntPtr.Zero;
			do
			{
				stringBuilder.Capacity *= 2;
				zero = Mono.Unix.Native.Syscall.getcwd(stringBuilder, (ulong)stringBuilder.Capacity);
			}
			while (zero == IntPtr.Zero && Stdlib.GetLastError() == Errno.ERANGE);
			if (zero == IntPtr.Zero)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			return stringBuilder.ToString();
		}

		public static void SetCurrentDirectory(string path)
		{
			int retval = Mono.Unix.Native.Syscall.chdir(path);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}
	}
	public enum UnixDriveType
	{
		Unknown,
		NoRootDirectory,
		Removable,
		Fixed,
		Network,
		CDRom,
		Ram
	}
	public sealed class UnixDriveInfo
	{
		private Statvfs stat;

		private string fstype;

		private string mount_point;

		private string block_device;

		public long AvailableFreeSpace
		{
			get
			{
				Refresh();
				return Convert.ToInt64(stat.f_bavail * stat.f_frsize);
			}
		}

		public string DriveFormat => fstype;

		public UnixDriveType DriveType => UnixDriveType.Unknown;

		public bool IsReady
		{
			get
			{
				bool flag = Refresh(throwException: false);
				if (mount_point == "/" || !flag)
				{
					return flag;
				}
				if (Mono.Unix.Native.Syscall.statvfs(RootDirectory.Parent.FullName, out var buf) != 0)
				{
					return false;
				}
				return buf.f_fsid != stat.f_fsid;
			}
		}

		public string Name => mount_point;

		public UnixDirectoryInfo RootDirectory => new UnixDirectoryInfo(mount_point);

		public long TotalFreeSpace
		{
			get
			{
				Refresh();
				return (long)(stat.f_bfree * stat.f_frsize);
			}
		}

		public long TotalSize
		{
			get
			{
				Refresh();
				return (long)(stat.f_frsize * stat.f_blocks);
			}
		}

		public string VolumeLabel => block_device;

		public long MaximumFilenameLength
		{
			get
			{
				Refresh();
				return Convert.ToInt64(stat.f_namemax);
			}
		}

		public UnixDriveInfo(string mountPoint)
		{
			if (mountPoint == null)
			{
				throw new ArgumentNullException("mountPoint");
			}
			Fstab fstab = Mono.Unix.Native.Syscall.getfsfile(mountPoint);
			if (fstab != null)
			{
				FromFstab(fstab);
				return;
			}
			mount_point = mountPoint;
			block_device = string.Empty;
			fstype = "Unknown";
		}

		private UnixDriveInfo(Fstab fstab)
		{
			FromFstab(fstab);
		}

		private void FromFstab(Fstab fstab)
		{
			fstype = fstab.fs_vfstype;
			mount_point = fstab.fs_file;
			block_device = fstab.fs_spec;
		}

		public static UnixDriveInfo GetForSpecialFile(string specialFile)
		{
			if (specialFile == null)
			{
				throw new ArgumentNullException("specialFile");
			}
			Fstab fstab = Mono.Unix.Native.Syscall.getfsspec(specialFile);
			if (fstab == null)
			{
				throw new ArgumentException("specialFile isn't valid: " + specialFile);
			}
			return new UnixDriveInfo(fstab);
		}

		public static UnixDriveInfo[] GetDrives()
		{
			ArrayList arrayList = new ArrayList();
			lock (Mono.Unix.Native.Syscall.fstab_lock)
			{
				int num = Mono.Unix.Native.Syscall.setfsent();
				if (num != 1)
				{
					throw new IOException("Error calling setfsent(3)", new UnixIOException());
				}
				try
				{
					Fstab fstab;
					while ((fstab = Mono.Unix.Native.Syscall.getfsent()) != null)
					{
						if (fstab.fs_file.StartsWith("/"))
						{
							arrayList.Add(new UnixDriveInfo(fstab));
						}
					}
				}
				finally
				{
					Mono.Unix.Native.Syscall.endfsent();
				}
			}
			return (UnixDriveInfo[])arrayList.ToArray(typeof(UnixDriveInfo));
		}

		public override string ToString()
		{
			return VolumeLabel;
		}

		private void Refresh()
		{
			Refresh(throwException: true);
		}

		private bool Refresh(bool throwException)
		{
			int num = Mono.Unix.Native.Syscall.statvfs(mount_point, out stat);
			if (num == -1 && throwException)
			{
				Errno lastError = Stdlib.GetLastError();
				throw new InvalidOperationException(UnixMarshal.GetErrorDescription(lastError), new UnixIOException(lastError));
			}
			if (num == -1)
			{
				return false;
			}
			return true;
		}
	}
	[Serializable]
	public class UnixEncoding : Encoding
	{
		[Serializable]
		private class UnixDecoder : Decoder
		{
			private uint leftOverBits;

			private uint leftOverCount;

			public UnixDecoder()
			{
				leftOverBits = 0u;
				leftOverCount = 0u;
			}

			public override int GetCharCount(byte[] bytes, int index, int count)
			{
				return InternalGetCharCount(bytes, index, count, leftOverBits, leftOverCount, throwOnInvalid: true, flush: false);
			}

			public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
			{
				return InternalGetChars(bytes, byteIndex, byteCount, chars, charIndex, ref leftOverBits, ref leftOverCount, throwOnInvalid: true, flush: false);
			}
		}

		[Serializable]
		private class UnixEncoder : Encoder
		{
			private uint leftOver;

			public UnixEncoder()
			{
				leftOver = 0u;
			}

			public override int GetByteCount(char[] chars, int index, int count, bool flush)
			{
				return InternalGetByteCount(chars, index, count, leftOver, flush);
			}

			public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteCount, bool flush)
			{
				return InternalGetBytes(chars, charIndex, charCount, bytes, byteCount, ref leftOver, flush);
			}
		}

		public static readonly Encoding Instance = new UnixEncoding();

		public static readonly char EscapeByte = '\0';

		private static int InternalGetByteCount(char[] chars, int index, int count, uint leftOver, bool flush)
		{
			if (chars == null)
			{
				throw new ArgumentNullException("chars");
			}
			if (index < 0 || index > chars.Length)
			{
				throw new ArgumentOutOfRangeException("index", _("ArgRange_Array"));
			}
			if (count < 0 || count > chars.Length - index)
			{
				throw new ArgumentOutOfRangeException("count", _("ArgRange_Array"));
			}
			int num = 0;
			uint num2 = leftOver;
			while (count > 0)
			{
				char c = chars[index];
				if (num2 == 0)
				{
					if (c == EscapeByte && count > 1)
					{
						num++;
						index++;
						count--;
					}
					else if (c < '\u0080')
					{
						num++;
					}
					else if (c < '')
					{
						num += 2;
					}
					else if (c >= '\ud800' && c <= '\udbff')
					{
						num2 = c;
					}
					else
					{
						num += 3;
					}
				}
				else
				{
					if (c < '\udc00' || c > '\udfff')
					{
						num += 3;
						num2 = 0u;
						continue;
					}
					num += 4;
					num2 = 0u;
				}
				index++;
				count--;
			}
			if (flush && num2 != 0)
			{
				num += 3;
			}
			return num;
		}

		public override int GetByteCount(char[] chars, int index, int count)
		{
			return InternalGetByteCount(chars, index, count, 0u, flush: true);
		}

		public override int GetByteCount(string s)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			int num = 0;
			int num2 = s.Length;
			int num3 = 0;
			while (num2 > 0)
			{
				char c = s[num++];
				if (c == EscapeByte && num2 > 1)
				{
					num3++;
					num++;
					num2--;
				}
				else if (c < '\u0080')
				{
					num3++;
				}
				else if (c < '')
				{
					num3 += 2;
				}
				else if (c >= '\ud800' && c <= '\udbff' && num2 > 1)
				{
					uint num4 = s[num];
					if (num4 >= 56320 && num4 <= 57343)
					{
						num3 += 4;
						num++;
						num2--;
					}
					else
					{
						num3 += 3;
					}
				}
				else
				{
					num3 += 3;
				}
				num2--;
			}
			return num3;
		}

		private static int InternalGetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, ref uint leftOver, bool flush)
		{
			if (chars == null)
			{
				throw new ArgumentNullException("chars");
			}
			if (bytes == null)
			{
				throw new ArgumentNullException("bytes");
			}
			if (charIndex < 0 || charIndex > chars.Length)
			{
				throw new ArgumentOutOfRangeException("charIndex", _("ArgRange_Array"));
			}
			if (charCount < 0 || charCount > chars.Length - charIndex)
			{
				throw new ArgumentOutOfRangeException("charCount", _("ArgRange_Array"));
			}
			if (byteIndex < 0 || byteIndex > bytes.Length)
			{
				throw new ArgumentOutOfRangeException("byteIndex", _("ArgRange_Array"));
			}
			int num = bytes.Length;
			uint num2 = leftOver;
			int num3 = byteIndex;
			while (charCount > 0)
			{
				char c = chars[charIndex++];
				charCount--;
				uint num4;
				if (num2 == 0)
				{
					if (c >= '\ud800' && c <= '\udbff')
					{
						num2 = c;
						continue;
					}
					if (c == EscapeByte)
					{
						if (num3 >= num)
						{
							throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
						}
						if (--charCount >= 0)
						{
							bytes[num3++] = (byte)chars[charIndex++];
						}
						continue;
					}
					num4 = c;
				}
				else if (c >= '\udc00' && c <= '\udfff')
				{
					num4 = (uint)((int)(num2 - 55296 << 10) + (c - 56320) + 65536);
					num2 = 0u;
				}
				else
				{
					num4 = num2;
					num2 = 0u;
					charIndex--;
					charCount++;
				}
				if (num4 < 128)
				{
					if (num3 >= num)
					{
						throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
					}
					bytes[num3++] = (byte)num4;
					continue;
				}
				if (num4 < 2048)
				{
					if (num3 + 2 > num)
					{
						throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
					}
					bytes[num3++] = (byte)(0xC0 | (num4 >> 6));
					bytes[num3++] = (byte)(0x80 | (num4 & 0x3F));
					continue;
				}
				if (num4 < 65536)
				{
					if (num3 + 3 > num)
					{
						throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
					}
					bytes[num3++] = (byte)(0xE0 | (num4 >> 12));
					bytes[num3++] = (byte)(0x80 | ((num4 >> 6) & 0x3F));
					bytes[num3++] = (byte)(0x80 | (num4 & 0x3F));
					continue;
				}
				if (num3 + 4 > num)
				{
					throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
				}
				bytes[num3++] = (byte)(0xF0 | (num4 >> 18));
				bytes[num3++] = (byte)(0x80 | ((num4 >> 12) & 0x3F));
				bytes[num3++] = (byte)(0x80 | ((num4 >> 6) & 0x3F));
				bytes[num3++] = (byte)(0x80 | (num4 & 0x3F));
			}
			if (flush && num2 != 0)
			{
				if (num3 + 3 > num)
				{
					throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
				}
				bytes[num3++] = (byte)(0xE0 | (num2 >> 12));
				bytes[num3++] = (byte)(0x80 | ((num2 >> 6) & 0x3F));
				bytes[num3++] = (byte)(0x80 | (num2 & 0x3F));
				num2 = 0u;
			}
			leftOver = num2;
			return num3 - byteIndex;
		}

		public override int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex)
		{
			uint leftOver = 0u;
			return InternalGetBytes(chars, charIndex, charCount, bytes, byteIndex, ref leftOver, flush: true);
		}

		public override int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (bytes == null)
			{
				throw new ArgumentNullException("bytes");
			}
			if (charIndex < 0 || charIndex > s.Length)
			{
				throw new ArgumentOutOfRangeException("charIndex", _("ArgRange_StringIndex"));
			}
			if (charCount < 0 || charCount > s.Length - charIndex)
			{
				throw new ArgumentOutOfRangeException("charCount", _("ArgRange_StringRange"));
			}
			if (byteIndex < 0 || byteIndex > bytes.Length)
			{
				throw new ArgumentOutOfRangeException("byteIndex", _("ArgRange_Array"));
			}
			int num = bytes.Length;
			int num2 = byteIndex;
			while (charCount > 0)
			{
				char c = s[charIndex++];
				uint num3;
				if (c >= '\ud800' && c <= '\udbff' && charCount > 1)
				{
					num3 = s[charIndex];
					if (num3 >= 56320 && num3 <= 57343)
					{
						num3 = (uint)((int)(num3 - 56320) + (c - 55296 << 10) + 65536);
						charIndex++;
						charCount--;
					}
					else
					{
						num3 = c;
					}
				}
				else
				{
					if (c == EscapeByte && charCount > 1)
					{
						if (num2 >= num)
						{
							throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
						}
						charCount -= 2;
						if (charCount >= 0)
						{
							bytes[num2++] = (byte)s[charIndex++];
						}
						continue;
					}
					num3 = c;
				}
				charCount--;
				if (num3 < 128)
				{
					if (num2 >= num)
					{
						throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
					}
					bytes[num2++] = (byte)num3;
					continue;
				}
				if (num3 < 2048)
				{
					if (num2 + 2 > num)
					{
						throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
					}
					bytes[num2++] = (byte)(0xC0 | (num3 >> 6));
					bytes[num2++] = (byte)(0x80 | (num3 & 0x3F));
					continue;
				}
				if (num3 < 65536)
				{
					if (num2 + 3 > num)
					{
						throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
					}
					bytes[num2++] = (byte)(0xE0 | (num3 >> 12));
					bytes[num2++] = (byte)(0x80 | ((num3 >> 6) & 0x3F));
					bytes[num2++] = (byte)(0x80 | (num3 & 0x3F));
					continue;
				}
				if (num2 + 4 > num)
				{
					throw new ArgumentException(_("Arg_InsufficientSpace"), "bytes");
				}
				bytes[num2++] = (byte)(0xF0 | (num3 >> 18));
				bytes[num2++] = (byte)(0x80 | ((num3 >> 12) & 0x3F));
				bytes[num2++] = (byte)(0x80 | ((num3 >> 6) & 0x3F));
				bytes[num2++] = (byte)(0x80 | (num3 & 0x3F));
			}
			return num2 - byteIndex;
		}

		private static int InternalGetCharCount(byte[] bytes, int index, int count, uint leftOverBits, uint leftOverCount, bool throwOnInvalid, bool flush)
		{
			if (bytes == null)
			{
				throw new ArgumentNullException("bytes");
			}
			if (index < 0 || index > bytes.Length)
			{
				throw new ArgumentOutOfRangeException("index", _("ArgRange_Array"));
			}
			if (count < 0 || count > bytes.Length - index)
			{
				throw new ArgumentOutOfRangeException("count", _("ArgRange_Array"));
			}
			int num = 0;
			int num2 = 0;
			uint num3 = leftOverBits;
			uint num4 = leftOverCount & 0xF;
			uint num5 = (leftOverCount >> 4) & 0xF;
			while (count > 0)
			{
				uint num6 = bytes[index++];
				num++;
				count--;
				if (num5 == 0)
				{
					if (num6 < 128)
					{
						num2++;
						num = 0;
						continue;
					}
					if ((num6 & 0xE0) == 192)
					{
						num3 = num6 & 0x1F;
						num4 = 1u;
						num5 = 2u;
						continue;
					}
					if ((num6 & 0xF0) == 224)
					{
						num3 = num6 & 0xF;
						num4 = 1u;
						num5 = 3u;
						continue;
					}
					if ((num6 & 0xF8) == 240)
					{
						num3 = num6 & 7;
						num4 = 1u;
						num5 = 4u;
						continue;
					}
					if ((num6 & 0xFC) == 248)
					{
						num3 = num6 & 3;
						num4 = 1u;
						num5 = 5u;
						continue;
					}
					if ((num6 & 0xFE) == 252)
					{
						num3 = num6 & 3;
						num4 = 1u;
						num5 = 6u;
						continue;
					}
					if (throwOnInvalid)
					{
					}
					num2 += num * 2;
					num = 0;
				}
				else if ((num6 & 0xC0) == 128)
				{
					num3 = (num3 << 6) | (num6 & 0x3F);
					if (++num4 < num5)
					{
						continue;
					}
					if (num3 < 65536)
					{
						bool flag = false;
						switch (num5)
						{
						case 2u:
							flag = num3 <= 127;
							break;
						case 3u:
							flag = num3 <= 2047;
							break;
						case 4u:
							flag = num3 <= 65535;
							break;
						case 5u:
							flag = num3 <= 2097151;
							break;
						case 6u:
							flag = num3 <= 67108863;
							break;
						}
						num2 = ((!flag) ? (num2 + 1) : (num2 + num * 2));
					}
					else if (num3 < 1114112)
					{
						num2 += 2;
					}
					else if (throwOnInvalid)
					{
						num2 += num * 2;
					}
					num5 = 0u;
					num = 0;
				}
				else
				{
					if (throwOnInvalid)
					{
					}
					if (num6 < 128)
					{
						index--;
						count++;
						num--;
					}
					num2 += num * 2;
					num5 = 0u;
					num = 0;
				}
			}
			if (flush && num5 != 0 && throwOnInvalid)
			{
				num2 += num * 2;
			}
			return num2;
		}

		public override int GetCharCount(byte[] bytes, int index, int count)
		{
			return InternalGetCharCount(bytes, index, count, 0u, 0u, throwOnInvalid: true, flush: true);
		}

		private static int InternalGetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, ref uint leftOverBits, ref uint leftOverCount, bool throwOnInvalid, bool flush)
		{
			if (bytes == null)
			{
				throw new ArgumentNullException("bytes");
			}
			if (chars == null)
			{
				throw new ArgumentNullException("chars");
			}
			if (byteIndex < 0 || byteIndex > bytes.Length)
			{
				throw new ArgumentOutOfRangeException("byteIndex", _("ArgRange_Array"));
			}
			if (byteCount < 0 || byteCount > bytes.Length - byteIndex)
			{
				throw new ArgumentOutOfRangeException("byteCount", _("ArgRange_Array"));
			}
			if (charIndex < 0 || charIndex > chars.Length)
			{
				throw new ArgumentOutOfRangeException("charIndex", _("ArgRange_Array"));
			}
			if (charIndex == chars.Length)
			{
				return 0;
			}
			byte[] array = new byte[6];
			int next_raw = 0;
			int num = chars.Length;
			int posn = charIndex;
			uint num2 = leftOverBits;
			uint num3 = leftOverCount & 0xF;
			uint num4 = (leftOverCount >> 4) & 0xF;
			while (byteCount > 0)
			{
				uint num5 = bytes[byteIndex++];
				array[next_raw++] = (byte)num5;
				byteCount--;
				if (num4 == 0)
				{
					if (num5 < 128)
					{
						if (posn >= num)
						{
							throw new ArgumentException(_("Arg_InsufficientSpace"), "chars");
						}
						next_raw = 0;
						chars[posn++] = (char)num5;
						continue;
					}
					if ((num5 & 0xE0) == 192)
					{
						num2 = num5 & 0x1F;
						num3 = 1u;
						num4 = 2u;
						continue;
					}
					if ((num5 & 0xF0) == 224)
					{
						num2 = num5 & 0xF;
						num3 = 1u;
						num4 = 3u;
						continue;
					}
					if ((num5 & 0xF8) == 240)
					{
						num2 = num5 & 7;
						num3 = 1u;
						num4 = 4u;
						continue;
					}
					if ((num5 & 0xFC) == 248)
					{
						num2 = num5 & 3;
						num3 = 1u;
						num4 = 5u;
						continue;
					}
					if ((num5 & 0xFE) == 252)
					{
						num2 = num5 & 3;
						num3 = 1u;
						num4 = 6u;
						continue;
					}
					if (throwOnInvalid)
					{
					}
					next_raw = 0;
					chars[posn++] = EscapeByte;
					chars[posn++] = (char)num5;
				}
				else if ((num5 & 0xC0) == 128)
				{
					num2 = (num2 << 6) | (num5 & 0x3F);
					if (++num3 < num4)
					{
						continue;
					}
					if (num2 < 65536)
					{
						bool flag = false;
						switch (num4)
						{
						case 2u:
							flag = num2 <= 127;
							break;
						case 3u:
							flag = num2 <= 2047;
							break;
						case 4u:
							flag = num2 <= 65535;
							break;
						case 5u:
							flag = num2 <= 2097151;
							break;
						case 6u:
							flag = num2 <= 67108863;
							break;
						}
						if (flag)
						{
							CopyRaw(array, ref next_raw, chars, ref posn, num);
						}
						else
						{
							if (posn >= num)
							{
								throw new ArgumentException(_("Arg_InsufficientSpace"), "chars");
							}
							chars[posn++] = (char)num2;
						}
					}
					else if (num2 < 1114112)
					{
						if (posn + 2 > num)
						{
							throw new ArgumentException(_("Arg_InsufficientSpace"), "chars");
						}
						num2 -= 65536;
						chars[posn++] = (char)((num2 >> 10) + 55296);
						chars[posn++] = (char)((num2 & 0x3FF) + 56320);
					}
					else if (throwOnInvalid)
					{
						CopyRaw(array, ref next_raw, chars, ref posn, num);
					}
					num4 = 0u;
					next_raw = 0;
				}
				else
				{
					if (throwOnInvalid)
					{
					}
					if (num5 < 128)
					{
						byteIndex--;
						byteCount++;
						next_raw--;
					}
					CopyRaw(array, ref next_raw, chars, ref posn, num);
					num4 = 0u;
					next_raw = 0;
				}
			}
			if (flush && num4 != 0 && throwOnInvalid)
			{
				CopyRaw(array, ref next_raw, chars, ref posn, num);
			}
			leftOverBits = num2;
			leftOverCount = num3 | (num4 << 4);
			return posn - charIndex;
		}

		private static void CopyRaw(byte[] raw, ref int next_raw, char[] chars, ref int posn, int length)
		{
			if (posn + next_raw * 2 > length)
			{
				throw new ArgumentException(_("Arg_InsufficientSpace"), "chars");
			}
			for (int i = 0; i < next_raw; i++)
			{
				chars[posn++] = EscapeByte;
				chars[posn++] = (char)raw[i];
			}
			next_raw = 0;
		}

		public override int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex)
		{
			uint leftOverBits = 0u;
			uint leftOverCount = 0u;
			return InternalGetChars(bytes, byteIndex, byteCount, chars, charIndex, ref leftOverBits, ref leftOverCount, throwOnInvalid: true, flush: true);
		}

		public override int GetMaxByteCount(int charCount)
		{
			if (charCount < 0)
			{
				throw new ArgumentOutOfRangeException("charCount", _("ArgRange_NonNegative"));
			}
			return charCount * 4;
		}

		public override int GetMaxCharCount(int byteCount)
		{
			if (byteCount < 0)
			{
				throw new ArgumentOutOfRangeException("byteCount", _("ArgRange_NonNegative"));
			}
			return byteCount;
		}

		public override Decoder GetDecoder()
		{
			return new UnixDecoder();
		}

		public override Encoder GetEncoder()
		{
			return new UnixEncoder();
		}

		public override byte[] GetPreamble()
		{
			return new byte[0];
		}

		public override bool Equals(object value)
		{
			if (value is UnixEncoding)
			{
				return true;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public override byte[] GetBytes(string s)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			int byteCount = GetByteCount(s);
			byte[] array = new byte[byteCount];
			GetBytes(s, 0, s.Length, array, 0);
			return array;
		}

		private static string _(string arg)
		{
			return arg;
		}
	}
	public sealed class UnixEnvironment
	{
		public static string CurrentDirectory
		{
			get
			{
				return UnixDirectoryInfo.GetCurrentDirectory();
			}
			set
			{
				UnixDirectoryInfo.SetCurrentDirectory(value);
			}
		}

		public static string MachineName
		{
			get
			{
				if (Mono.Unix.Native.Syscall.uname(out var buf) != 0)
				{
					throw UnixMarshal.CreateExceptionForLastError();
				}
				return buf.nodename;
			}
			set
			{
				int retval = Mono.Unix.Native.Syscall.sethostname(value);
				UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			}
		}

		public static string UserName => UnixUserInfo.GetRealUser().UserName;

		public static UnixGroupInfo RealGroup => new UnixGroupInfo(RealGroupId);

		public static long RealGroupId => Mono.Unix.Native.Syscall.getgid();

		public static UnixUserInfo RealUser => new UnixUserInfo(RealUserId);

		public static long RealUserId => Mono.Unix.Native.Syscall.getuid();

		public static UnixGroupInfo EffectiveGroup
		{
			get
			{
				return new UnixGroupInfo(EffectiveGroupId);
			}
			set
			{
				EffectiveGroupId = value.GroupId;
			}
		}

		public static long EffectiveGroupId
		{
			get
			{
				return Mono.Unix.Native.Syscall.getegid();
			}
			set
			{
				Mono.Unix.Native.Syscall.setegid(Convert.ToUInt32(value));
			}
		}

		public static UnixUserInfo EffectiveUser
		{
			get
			{
				return new UnixUserInfo(EffectiveUserId);
			}
			set
			{
				EffectiveUserId = value.UserId;
			}
		}

		public static long EffectiveUserId
		{
			get
			{
				return Mono.Unix.Native.Syscall.geteuid();
			}
			set
			{
				Mono.Unix.Native.Syscall.seteuid(Convert.ToUInt32(value));
			}
		}

		public static string Login => UnixUserInfo.GetRealUser().UserName;

		private UnixEnvironment()
		{
		}

		[CLSCompliant(false)]
		public static long GetConfigurationValue(SysconfName name)
		{
			long num = Mono.Unix.Native.Syscall.sysconf(name);
			if (num == -1 && Stdlib.GetLastError() != 0)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			return num;
		}

		[CLSCompliant(false)]
		public static string GetConfigurationString(ConfstrName name)
		{
			ulong num = Mono.Unix.Native.Syscall.confstr(name, null, 0uL);
			if (num == ulong.MaxValue)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			if (num == 0L)
			{
				return string.Empty;
			}
			StringBuilder stringBuilder = new StringBuilder((int)num + 1);
			num = Mono.Unix.Native.Syscall.confstr(name, stringBuilder, num);
			if (num == ulong.MaxValue)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			return stringBuilder.ToString();
		}

		public static void SetNiceValue(int inc)
		{
			int retval = Mono.Unix.Native.Syscall.nice(inc);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}

		public static int CreateSession()
		{
			int num = Mono.Unix.Native.Syscall.setsid();
			UnixMarshal.ThrowExceptionForLastErrorIf(num);
			return num;
		}

		public static void SetProcessGroup()
		{
			int retval = Mono.Unix.Native.Syscall.setpgrp();
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}

		public static int GetProcessGroup()
		{
			return Mono.Unix.Native.Syscall.getpgrp();
		}

		public static UnixGroupInfo[] GetSupplementaryGroups()
		{
			uint[] array = _GetSupplementaryGroupIds();
			UnixGroupInfo[] array2 = new UnixGroupInfo[array.Length];
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = new UnixGroupInfo(array[i]);
			}
			return array2;
		}

		private static uint[] _GetSupplementaryGroupIds()
		{
			int num = Mono.Unix.Native.Syscall.getgroups(0, new uint[0]);
			if (num == -1)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			uint[] array = new uint[num];
			int retval = Mono.Unix.Native.Syscall.getgroups(array);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			return array;
		}

		public static void SetSupplementaryGroups(UnixGroupInfo[] groups)
		{
			uint[] array = new uint[groups.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = Convert.ToUInt32(groups[i].GroupId);
			}
			int retval = Mono.Unix.Native.Syscall.setgroups(array);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}

		public static long[] GetSupplementaryGroupIds()
		{
			uint[] array = _GetSupplementaryGroupIds();
			long[] array2 = new long[array.Length];
			for (int i = 0; i < array2.Length; i++)
			{
				array2[i] = array[i];
			}
			return array2;
		}

		public static void SetSupplementaryGroupIds(long[] list)
		{
			uint[] array = new uint[list.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = Convert.ToUInt32(list[i]);
			}
			int retval = Mono.Unix.Native.Syscall.setgroups(array);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}

		public static int GetParentProcessId()
		{
			return Mono.Unix.Native.Syscall.getppid();
		}

		public static UnixProcess GetParentProcess()
		{
			return new UnixProcess(GetParentProcessId());
		}

		public static string[] GetUserShells()
		{
			ArrayList arrayList = new ArrayList();
			lock (Mono.Unix.Native.Syscall.usershell_lock)
			{
				try
				{
					if (Mono.Unix.Native.Syscall.setusershell() != 0)
					{
						UnixMarshal.ThrowExceptionForLastError();
					}
					string value;
					while ((value = Mono.Unix.Native.Syscall.getusershell()) != null)
					{
						arrayList.Add(value);
					}
				}
				finally
				{
					Mono.Unix.Native.Syscall.endusershell();
				}
			}
			return (string[])arrayList.ToArray(typeof(string));
		}
	}
	[Serializable]
	public class UnixEndPoint : EndPoint
	{
		private string filename;

		public string Filename
		{
			get
			{
				return filename;
			}
			set
			{
				filename = value;
			}
		}

		public override AddressFamily AddressFamily => AddressFamily.Unix;

		public UnixEndPoint(string filename)
		{
			if (filename == null)
			{
				throw new ArgumentNullException("filename");
			}
			if (filename == string.Empty)
			{
				throw new ArgumentException("Cannot be empty.", "filename");
			}
			this.filename = filename;
		}

		public override EndPoint Create(SocketAddress socketAddress)
		{
			byte[] array = new byte[socketAddress.Size - 2 - 1];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = socketAddress[i + 2];
			}
			string text = Encoding.Default.GetString(array);
			return new UnixEndPoint(text);
		}

		public override SocketAddress Serialize()
		{
			byte[] bytes = Encoding.Default.GetBytes(filename);
			SocketAddress socketAddress = new SocketAddress(AddressFamily, 2 + bytes.Length + 1);
			for (int i = 0; i < bytes.Length; i++)
			{
				socketAddress[2 + i] = bytes[i];
			}
			socketAddress[2 + bytes.Length] = 0;
			return socketAddress;
		}

		public override string ToString()
		{
			return filename;
		}

		public override int GetHashCode()
		{
			return filename.GetHashCode();
		}

		public override bool Equals(object o)
		{
			if (!(o is UnixEndPoint unixEndPoint))
			{
				return false;
			}
			return unixEndPoint.filename == filename;
		}
	}
	public sealed class UnixFileInfo : UnixFileSystemInfo
	{
		public override string Name => UnixPath.GetFileName(base.FullPath);

		public string DirectoryName => UnixPath.GetDirectoryName(base.FullPath);

		public UnixDirectoryInfo Directory => new UnixDirectoryInfo(DirectoryName);

		public UnixFileInfo(string path)
			: base(path)
		{
		}

		internal UnixFileInfo(string path, Mono.Unix.Native.Stat stat)
			: base(path, stat)
		{
		}

		public override void Delete()
		{
			int retval = Mono.Unix.Native.Syscall.unlink(base.FullPath);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			Refresh();
		}

		public UnixStream Create()
		{
			FilePermissions mode = FilePermissions.S_IRUSR | FilePermissions.S_IWUSR | FilePermissions.S_IRGRP | FilePermissions.S_IROTH;
			return Create(mode);
		}

		[CLSCompliant(false)]
		public UnixStream Create(FilePermissions mode)
		{
			int num = Mono.Unix.Native.Syscall.creat(base.FullPath, mode);
			if (num < 0)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			Refresh();
			return new UnixStream(num);
		}

		public UnixStream Create(FileAccessPermissions mode)
		{
			return Create((FilePermissions)mode);
		}

		[CLSCompliant(false)]
		public UnixStream Open(Mono.Unix.Native.OpenFlags flags)
		{
			if ((flags & Mono.Unix.Native.OpenFlags.O_CREAT) != Mono.Unix.Native.OpenFlags.O_RDONLY)
			{
				throw new ArgumentException("Cannot specify OpenFlags.O_CREAT without providing FilePermissions.  Use the Open(OpenFlags, FilePermissions) method instead");
			}
			int num = Mono.Unix.Native.Syscall.open(base.FullPath, flags);
			if (num < 0)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			return new UnixStream(num);
		}

		[CLSCompliant(false)]
		public UnixStream Open(Mono.Unix.Native.OpenFlags flags, FilePermissions mode)
		{
			int num = Mono.Unix.Native.Syscall.open(base.FullPath, flags, mode);
			if (num < 0)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			return new UnixStream(num);
		}

		public UnixStream Open(System.IO.FileMode mode)
		{
			Mono.Unix.Native.OpenFlags flags = NativeConvert.ToOpenFlags(mode, FileAccess.ReadWrite);
			return Open(flags);
		}

		public UnixStream Open(System.IO.FileMode mode, FileAccess access)
		{
			Mono.Unix.Native.OpenFlags flags = NativeConvert.ToOpenFlags(mode, access);
			return Open(flags);
		}

		[CLSCompliant(false)]
		public UnixStream Open(System.IO.FileMode mode, FileAccess access, FilePermissions perms)
		{
			Mono.Unix.Native.OpenFlags flags = NativeConvert.ToOpenFlags(mode, access);
			int num = Mono.Unix.Native.Syscall.open(base.FullPath, flags, perms);
			if (num < 0)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			return new UnixStream(num);
		}

		public UnixStream OpenRead()
		{
			return Open(System.IO.FileMode.Open, FileAccess.Read);
		}

		public UnixStream OpenWrite()
		{
			return Open(System.IO.FileMode.OpenOrCreate, FileAccess.Write);
		}
	}
	public abstract class UnixFileSystemInfo
	{
		internal const FileSpecialAttributes AllSpecialAttributes = FileSpecialAttributes.SetUserId | FileSpecialAttributes.SetGroupId | FileSpecialAttributes.Sticky;

		internal const FileTypes AllFileTypes = (FileTypes)61440;

		private Mono.Unix.Native.Stat stat;

		private string fullPath;

		private string originalPath;

		private bool valid;

		protected string FullPath
		{
			get
			{
				return fullPath;
			}
			set
			{
				if (fullPath != value)
				{
					UnixPath.CheckPath(value);
					valid = false;
					fullPath = value;
				}
			}
		}

		protected string OriginalPath
		{
			get
			{
				return originalPath;
			}
			set
			{
				originalPath = value;
			}
		}

		public virtual string FullName => FullPath;

		public abstract string Name { get; }

		public bool Exists
		{
			get
			{
				Refresh(force: true);
				return valid;
			}
		}

		public long Device
		{
			get
			{
				AssertValid();
				return Convert.ToInt64(stat.st_dev);
			}
		}

		public long Inode
		{
			get
			{
				AssertValid();
				return Convert.ToInt64(stat.st_ino);
			}
		}

		[CLSCompliant(false)]
		public FilePermissions Protection
		{
			get
			{
				AssertValid();
				return stat.st_mode;
			}
			set
			{
				int retval = Mono.Unix.Native.Syscall.chmod(FullPath, value);
				UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			}
		}

		public FileTypes FileType
		{
			get
			{
				AssertValid();
				return (FileTypes)(stat.st_mode & FilePermissions.S_IFMT);
			}
		}

		public FileAccessPermissions FileAccessPermissions
		{
			get
			{
				AssertValid();
				int st_mode = (int)stat.st_mode;
				return (FileAccessPermissions)(st_mode & 0x1FF);
			}
			set
			{
				AssertValid();
				int st_mode = (int)stat.st_mode;
				st_mode &= -512;
				st_mode |= (int)value;
				Protection = (FilePermissions)st_mode;
			}
		}

		public FileSpecialAttributes FileSpecialAttributes
		{
			get
			{
				AssertValid();
				int st_mode = (int)stat.st_mode;
				return (FileSpecialAttributes)(st_mode & 0xE00);
			}
			set
			{
				AssertValid();
				int st_mode = (int)stat.st_mode;
				st_mode &= -3585;
				st_mode |= (int)value;
				Protection = (FilePermissions)st_mode;
			}
		}

		public long LinkCount
		{
			get
			{
				AssertValid();
				return Convert.ToInt64(stat.st_nlink);
			}
		}

		public UnixUserInfo OwnerUser
		{
			get
			{
				AssertValid();
				return new UnixUserInfo(stat.st_uid);
			}
		}

		public long OwnerUserId
		{
			get
			{
				AssertValid();
				return stat.st_uid;
			}
		}

		public UnixGroupInfo OwnerGroup
		{
			get
			{
				AssertValid();
				return new UnixGroupInfo(stat.st_gid);
			}
		}

		public long OwnerGroupId
		{
			get
			{
				AssertValid();
				return stat.st_gid;
			}
		}

		public long DeviceType
		{
			get
			{
				AssertValid();
				return Convert.ToInt64(stat.st_rdev);
			}
		}

		public long Length
		{
			get
			{
				AssertValid();
				return stat.st_size;
			}
		}

		public long BlockSize
		{
			get
			{
				AssertValid();
				return stat.st_blksize;
			}
		}

		public long BlocksAllocated
		{
			get
			{
				AssertValid();
				return stat.st_blocks;
			}
		}

		public DateTime LastAccessTime
		{
			get
			{
				AssertValid();
				return NativeConvert.ToDateTime(stat.st_atime);
			}
		}

		public DateTime LastAccessTimeUtc => LastAccessTime.ToUniversalTime();

		public DateTime LastWriteTime
		{
			get
			{
				AssertValid();
				return NativeConvert.ToDateTime(stat.st_mtime);
			}
		}

		public DateTime LastWriteTimeUtc => LastWriteTime.ToUniversalTime();

		public DateTime LastStatusChangeTime
		{
			get
			{
				AssertValid();
				return NativeConvert.ToDateTime(stat.st_ctime);
			}
		}

		public DateTime LastStatusChangeTimeUtc => LastStatusChangeTime.ToUniversalTime();

		public bool IsDirectory
		{
			get
			{
				AssertValid();
				return IsFileType(stat.st_mode, FilePermissions.S_IFDIR);
			}
		}

		public bool IsCharacterDevice
		{
			get
			{
				AssertValid();
				return IsFileType(stat.st_mode, FilePermissions.S_IFCHR);
			}
		}

		public bool IsBlockDevice
		{
			get
			{
				AssertValid();
				return IsFileType(stat.st_mode, FilePermissions.S_IFBLK);
			}
		}

		public bool IsRegularFile
		{
			get
			{
				AssertValid();
				return IsFileType(stat.st_mode, FilePermissions.S_IFREG);
			}
		}

		public bool IsFifo
		{
			get
			{
				AssertValid();
				return IsFileType(stat.st_mode, FilePermissions.S_IFIFO);
			}
		}

		public bool IsSymbolicLink
		{
			get
			{
				AssertValid();
				return IsFileType(stat.st_mode, FilePermissions.S_IFLNK);
			}
		}

		public bool IsSocket
		{
			get
			{
				AssertValid();
				return IsFileType(stat.st_mode, FilePermissions.S_IFSOCK);
			}
		}

		public bool IsSetUser
		{
			get
			{
				AssertValid();
				return IsSet(stat.st_mode, FilePermissions.S_ISUID);
			}
		}

		public bool IsSetGroup
		{
			get
			{
				AssertValid();
				return IsSet(stat.st_mode, FilePermissions.S_ISGID);
			}
		}

		public bool IsSticky
		{
			get
			{
				AssertValid();
				return IsSet(stat.st_mode, FilePermissions.S_ISVTX);
			}
		}

		protected UnixFileSystemInfo(string path)
		{
			UnixPath.CheckPath(path);
			originalPath = path;
			fullPath = UnixPath.GetFullPath(path);
			Refresh(force: true);
		}

		internal UnixFileSystemInfo(string path, Mono.Unix.Native.Stat stat)
		{
			originalPath = path;
			fullPath = UnixPath.GetFullPath(path);
			this.stat = stat;
			valid = true;
		}

		private void AssertValid()
		{
			Refresh(force: false);
			if (!valid)
			{
				throw new InvalidOperationException("Path doesn't exist!");
			}
		}

		internal static bool IsFileType(FilePermissions mode, FilePermissions type)
		{
			return (mode & FilePermissions.S_IFMT) == type;
		}

		internal static bool IsSet(FilePermissions mode, FilePermissions type)
		{
			return (mode & type) == type;
		}

		[CLSCompliant(false)]
		public bool CanAccess(AccessModes mode)
		{
			int num = Mono.Unix.Native.Syscall.access(FullPath, mode);
			return num == 0;
		}

		public UnixFileSystemInfo CreateLink(string path)
		{
			int retval = Mono.Unix.Native.Syscall.link(FullName, path);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			return GetFileSystemEntry(path);
		}

		public UnixSymbolicLinkInfo CreateSymbolicLink(string path)
		{
			int retval = Mono.Unix.Native.Syscall.symlink(FullName, path);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			return new UnixSymbolicLinkInfo(path);
		}

		public abstract void Delete();

		[CLSCompliant(false)]
		public long GetConfigurationValue(PathconfName name)
		{
			long num = Mono.Unix.Native.Syscall.pathconf(FullPath, name);
			if (num == -1 && Stdlib.GetLastError() != 0)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			return num;
		}

		public void Refresh()
		{
			Refresh(force: true);
		}

		internal void Refresh(bool force)
		{
			if (!valid || force)
			{
				valid = GetFileStatus(FullPath, out stat);
			}
		}

		protected virtual bool GetFileStatus(string path, out Mono.Unix.Native.Stat stat)
		{
			return Mono.Unix.Native.Syscall.stat(path, out stat) == 0;
		}

		public void SetLength(long length)
		{
			int num;
			do
			{
				num = Mono.Unix.Native.Syscall.truncate(FullPath, length);
			}
			while (UnixMarshal.ShouldRetrySyscall(num));
			UnixMarshal.ThrowExceptionForLastErrorIf(num);
		}

		public virtual void SetOwner(long owner, long group)
		{
			uint owner2 = Convert.ToUInt32(owner);
			uint num = Convert.ToUInt32(group);
			int retval = Mono.Unix.Native.Syscall.chown(FullPath, owner2, num);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}

		public void SetOwner(string owner)
		{
			Passwd passwd = Mono.Unix.Native.Syscall.getpwnam(owner);
			if (passwd == null)
			{
				throw new ArgumentException(global::Locale.GetText("invalid username"), "owner");
			}
			uint pw_uid = passwd.pw_uid;
			uint pw_gid = passwd.pw_gid;
			SetOwner(pw_uid, pw_gid);
		}

		public void SetOwner(string owner, string group)
		{
			long owner2 = -1L;
			if (owner != null)
			{
				owner2 = new UnixUserInfo(owner).UserId;
			}
			long num = -1L;
			if (group != null)
			{
				num = new UnixGroupInfo(group).GroupId;
			}
			SetOwner(owner2, num);
		}

		public void SetOwner(UnixUserInfo owner)
		{
			long num;
			long owner2 = (num = -1L);
			if (owner != null)
			{
				owner2 = owner.UserId;
				num = owner.GroupId;
			}
			SetOwner(owner2, num);
		}

		public void SetOwner(UnixUserInfo owner, UnixGroupInfo group)
		{
			long num;
			long owner2 = (num = -1L);
			if (owner != null)
			{
				owner2 = owner.UserId;
			}
			if (group != null)
			{
				num = owner.GroupId;
			}
			SetOwner(owner2, num);
		}

		public override string ToString()
		{
			return FullPath;
		}

		public Mono.Unix.Native.Stat ToStat()
		{
			AssertValid();
			return stat;
		}

		public static UnixFileSystemInfo GetFileSystemEntry(string path)
		{
			Mono.Unix.Native.Stat buf;
			int num = Mono.Unix.Native.Syscall.lstat(path, out buf);
			if (num == -1 && Stdlib.GetLastError() == Errno.ENOENT)
			{
				return new UnixFileInfo(path);
			}
			UnixMarshal.ThrowExceptionForLastErrorIf(num);
			if (IsFileType(buf.st_mode, FilePermissions.S_IFDIR))
			{
				return new UnixDirectoryInfo(path, buf);
			}
			if (IsFileType(buf.st_mode, FilePermissions.S_IFLNK))
			{
				return new UnixSymbolicLinkInfo(path, buf);
			}
			return new UnixFileInfo(path, buf);
		}
	}
	public sealed class UnixGroupInfo
	{
		private Mono.Unix.Native.Group group;

		public string GroupName => group.gr_name;

		public string Password => group.gr_passwd;

		public long GroupId => group.gr_gid;

		public UnixGroupInfo(string group)
		{
			this.group = new Mono.Unix.Native.Group();
			if (Mono.Unix.Native.Syscall.getgrnam_r(group, this.group, out var grbufp) != 0 || grbufp == null)
			{
				throw new ArgumentException(global::Locale.GetText("invalid group name"), "group");
			}
		}

		public UnixGroupInfo(long group)
		{
			this.group = new Mono.Unix.Native.Group();
			if (Mono.Unix.Native.Syscall.getgrgid_r(Convert.ToUInt32(group), this.group, out var grbufp) != 0 || grbufp == null)
			{
				throw new ArgumentException(global::Locale.GetText("invalid group id"), "group");
			}
		}

		public UnixGroupInfo(Mono.Unix.Native.Group group)
		{
			this.group = CopyGroup(group);
		}

		private static Mono.Unix.Native.Group CopyGroup(Mono.Unix.Native.Group group)
		{
			Mono.Unix.Native.Group obj = new Mono.Unix.Native.Group();
			obj.gr_gid = group.gr_gid;
			obj.gr_mem = group.gr_mem;
			obj.gr_name = group.gr_name;
			obj.gr_passwd = group.gr_passwd;
			return obj;
		}

		public UnixUserInfo[] GetMembers()
		{
			ArrayList arrayList = new ArrayList(group.gr_mem.Length);
			for (int i = 0; i < group.gr_mem.Length; i++)
			{
				try
				{
					arrayList.Add(new UnixUserInfo(group.gr_mem[i]));
				}
				catch (ArgumentException)
				{
				}
			}
			return (UnixUserInfo[])arrayList.ToArray(typeof(UnixUserInfo));
		}

		public string[] GetMemberNames()
		{
			return (string[])group.gr_mem.Clone();
		}

		public override int GetHashCode()
		{
			return group.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)GetType() != obj.GetType())
			{
				return false;
			}
			return group.Equals(((UnixGroupInfo)obj).group);
		}

		public override string ToString()
		{
			return group.ToString();
		}

		public Mono.Unix.Native.Group ToGroup()
		{
			return CopyGroup(group);
		}

		public static UnixGroupInfo[] GetLocalGroups()
		{
			ArrayList arrayList = new ArrayList();
			lock (Mono.Unix.Native.Syscall.grp_lock)
			{
				if (Mono.Unix.Native.Syscall.setgrent() != 0)
				{
					UnixMarshal.ThrowExceptionForLastError();
				}
				try
				{
					Mono.Unix.Native.Group obj;
					while ((obj = Mono.Unix.Native.Syscall.getgrent()) != null)
					{
						arrayList.Add(new UnixGroupInfo(obj));
					}
					if (Stdlib.GetLastError() != 0)
					{
						UnixMarshal.ThrowExceptionForLastError();
					}
				}
				finally
				{
					Mono.Unix.Native.Syscall.endgrent();
				}
			}
			return (UnixGroupInfo[])arrayList.ToArray(typeof(UnixGroupInfo));
		}
	}
	[Serializable]
	public class UnixIOException : IOException
	{
		private int errno;

		public int NativeErrorCode => errno;

		public Errno ErrorCode => NativeConvert.ToErrno(errno);

		public UnixIOException()
			: this(Marshal.GetLastWin32Error())
		{
		}

		public UnixIOException(int errno)
			: base(GetMessage(NativeConvert.ToErrno(errno)))
		{
			this.errno = errno;
		}

		public UnixIOException(int errno, Exception inner)
			: base(GetMessage(NativeConvert.ToErrno(errno)), inner)
		{
			this.errno = errno;
		}

		public UnixIOException(Errno errno)
			: base(GetMessage(errno))
		{
			this.errno = NativeConvert.FromErrno(errno);
		}

		public UnixIOException(Errno errno, Exception inner)
			: base(GetMessage(errno), inner)
		{
			this.errno = NativeConvert.FromErrno(errno);
		}

		public UnixIOException(string message)
			: base(message)
		{
			errno = 0;
		}

		public UnixIOException(string message, Exception inner)
			: base(message, inner)
		{
			errno = 0;
		}

		protected UnixIOException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		private static string GetMessage(Errno errno)
		{
			return $"{UnixMarshal.GetErrorDescription(errno)} [{errno}].";
		}
	}
	public class UnixListener : MarshalByRefObject, IDisposable
	{
		private bool disposed;

		private bool listening;

		private Socket server;

		private EndPoint savedEP;

		public EndPoint LocalEndpoint => savedEP;

		protected Socket Server => server;

		public UnixListener(string path)
		{
			if (!Directory.Exists(Path.GetDirectoryName(path)))
			{
				Directory.CreateDirectory(Path.GetDirectoryName(path));
			}
			Init(new UnixEndPoint(path));
		}

		public UnixListener(UnixEndPoint localEndPoint)
		{
			if (localEndPoint == null)
			{
				throw new ArgumentNullException("localendPoint");
			}
			Init(localEndPoint);
		}

		private void Init(UnixEndPoint ep)
		{
			listening = false;
			string filename = ep.Filename;
			if (File.Exists(filename))
			{
				Socket socket = new Socket(AddressFamily.Unix, SocketType.Stream, ProtocolType.IP);
				try
				{
					socket.Connect(ep);
					socket.Close();
					throw new InvalidOperationException("There's already a server listening on " + filename);
				}
				catch (SocketException)
				{
				}
				File.Delete(filename);
			}
			server = new Socket(AddressFamily.Unix, SocketType.Stream, ProtocolType.IP);
			server.Bind(ep);
			savedEP = server.LocalEndPoint;
		}

		public Socket AcceptSocket()
		{
			CheckDisposed();
			if (!listening)
			{
				throw new InvalidOperationException("Socket is not listening");
			}
			return server.Accept();
		}

		public UnixClient AcceptUnixClient()
		{
			CheckDisposed();
			if (!listening)
			{
				throw new InvalidOperationException("Socket is not listening");
			}
			return new UnixClient(AcceptSocket());
		}

		~UnixListener()
		{
			Dispose(disposing: false);
		}

		public bool Pending()
		{
			CheckDisposed();
			if (!listening)
			{
				throw new InvalidOperationException("Socket is not listening");
			}
			return server.Poll(1000, SelectMode.SelectRead);
		}

		public void Start()
		{
			Start(5);
		}

		public void Start(int backlog)
		{
			CheckDisposed();
			if (!listening)
			{
				server.Listen(backlog);
				listening = true;
			}
		}

		public void Stop()
		{
			CheckDisposed();
			Dispose(disposing: true);
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected void Dispose(bool disposing)
		{
			if (disposed)
			{
				return;
			}
			if (disposing)
			{
				if (server != null)
				{
					server.Close();
				}
				server = null;
			}
			disposed = true;
		}

		private void CheckDisposed()
		{
			if (disposed)
			{
				throw new ObjectDisposedException(GetType().FullName);
			}
		}
	}
	internal class ErrorMarshal
	{
		internal delegate string ErrorTranslator(Errno errno);

		internal static readonly ErrorTranslator Translate;

		static ErrorMarshal()
		{
			try
			{
				Translate = strerror_r;
				Translate(Errno.ERANGE);
			}
			catch (EntryPointNotFoundException)
			{
				Translate = strerror;
			}
		}

		private static string strerror(Errno errno)
		{
			return Stdlib.strerror(errno);
		}

		private static string strerror_r(Errno errno)
		{
			StringBuilder stringBuilder = new StringBuilder(16);
			int num = 0;
			do
			{
				stringBuilder.Capacity *= 2;
				num = Mono.Unix.Native.Syscall.strerror_r(errno, stringBuilder);
			}
			while (num == -1 && Stdlib.GetLastError() == Errno.ERANGE);
			if (num == -1)
			{
				return "** Unknown error code: " + (int)errno + "**";
			}
			return stringBuilder.ToString();
		}
	}
	public sealed class UnixMarshal
	{
		private UnixMarshal()
		{
		}

		[CLSCompliant(false)]
		public static string GetErrorDescription(Errno errno)
		{
			return ErrorMarshal.Translate(errno);
		}

		public static IntPtr AllocHeap(long size)
		{
			if (size < 0)
			{
				throw new ArgumentOutOfRangeException("size", "< 0");
			}
			return Stdlib.malloc((ulong)size);
		}

		public static IntPtr ReAllocHeap(IntPtr ptr, long size)
		{
			if (size < 0)
			{
				throw new ArgumentOutOfRangeException("size", "< 0");
			}
			return Stdlib.realloc(ptr, (ulong)size);
		}

		public static void FreeHeap(IntPtr ptr)
		{
			Stdlib.free(ptr);
		}

		public unsafe static string PtrToStringUnix(IntPtr p)
		{
			if (p == IntPtr.Zero)
			{
				return null;
			}
			int length = checked((int)Stdlib.strlen(p));
			return new string((sbyte*)(void*)p, 0, length, UnixEncoding.Instance);
		}

		public static string PtrToString(IntPtr p)
		{
			if (p == IntPtr.Zero)
			{
				return null;
			}
			return PtrToString(p, UnixEncoding.Instance);
		}

		public unsafe static string PtrToString(IntPtr p, Encoding encoding)
		{
			if (p == IntPtr.Zero)
			{
				return null;
			}
			if (encoding == null)
			{
				throw new ArgumentNullException("encoding");
			}
			int stringByteLength = GetStringByteLength(p, encoding);
			string text = new string((sbyte*)(void*)p, 0, stringByteLength, encoding);
			stringByteLength = text.Length;
			while (stringByteLength > 0 && text[stringByteLength - 1] == '\0')
			{
				stringByteLength--;
			}
			if (stringByteLength == text.Length)
			{
				return text;
			}
			return text.Substring(0, stringByteLength);
		}

		private static int GetStringByteLength(IntPtr p, Encoding encoding)
		{
			Type type = encoding.GetType();
			int num = -1;
			num = ((typeof(UTF8Encoding).IsAssignableFrom(type) || typeof(UTF7Encoding).IsAssignableFrom(type) || typeof(UnixEncoding).IsAssignableFrom(type) || typeof(ASCIIEncoding).IsAssignableFrom(type)) ? checked((int)Stdlib.strlen(p)) : ((!typeof(UnicodeEncoding).IsAssignableFrom(type)) ? GetRandomBufferLength(p, encoding.GetMaxByteCount(1)) : GetInt16BufferLength(p)));
			if (num == -1)
			{
				throw new NotSupportedException("Unable to determine native string buffer length");
			}
			return num;
		}

		private static int GetInt16BufferLength(IntPtr p)
		{
			int i;
			for (i = 0; Marshal.ReadInt16(p, i * 2) != 0; i = checked(i + 1))
			{
			}
			return checked(i * 2);
		}

		private static int GetInt32BufferLength(IntPtr p)
		{
			int i;
			for (i = 0; Marshal.ReadInt32(p, i * 4) != 0; i = checked(i + 1))
			{
			}
			return checked(i * 4);
		}

		private static int GetRandomBufferLength(IntPtr p, int nullLength)
		{
			switch (nullLength)
			{
			case 1:
				return checked((int)Stdlib.strlen(p));
			case 2:
				return GetInt16BufferLength(p);
			case 4:
				return GetInt32BufferLength(p);
			default:
			{
				int result = 0;
				int num = 0;
				do
				{
					num = ((Marshal.ReadByte(p, result++) == 0) ? (num + 1) : 0);
				}
				while (num != nullLength);
				return result;
			}
			}
		}

		public static string[] PtrToStringArray(IntPtr stringArray)
		{
			return PtrToStringArray(stringArray, UnixEncoding.Instance);
		}

		public static string[] PtrToStringArray(IntPtr stringArray, Encoding encoding)
		{
			if (stringArray == IntPtr.Zero)
			{
				return new string[0];
			}
			int count = CountStrings(stringArray);
			return PtrToStringArray(count, stringArray, encoding);
		}

		private static int CountStrings(IntPtr stringArray)
		{
			int i;
			for (i = 0; Marshal.ReadIntPtr(stringArray, i * IntPtr.Size) != IntPtr.Zero; i++)
			{
			}
			return i;
		}

		public static string[] PtrToStringArray(int count, IntPtr stringArray)
		{
			return PtrToStringArray(count, stringArray, UnixEncoding.Instance);
		}

		public static string[] PtrToStringArray(int count, IntPtr stringArray, Encoding encoding)
		{
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", "< 0");
			}
			if (encoding == null)
			{
				throw new ArgumentNullException("encoding");
			}
			if (stringArray == IntPtr.Zero)
			{
				return new string[count];
			}
			string[] array = new string[count];
			for (int i = 0; i < count; i++)
			{
				IntPtr p = Marshal.ReadIntPtr(stringArray, i * IntPtr.Size);
				array[i] = PtrToString(p, encoding);
			}
			return array;
		}

		public static IntPtr StringToHeap(string s)
		{
			return StringToHeap(s, UnixEncoding.Instance);
		}

		public static IntPtr StringToHeap(string s, Encoding encoding)
		{
			return StringToHeap(s, 0, s.Length, encoding);
		}

		public static IntPtr StringToHeap(string s, int index, int count)
		{
			return StringToHeap(s, index, count, UnixEncoding.Instance);
		}

		public static IntPtr StringToHeap(string s, int index, int count, Encoding encoding)
		{
			if (s == null)
			{
				return IntPtr.Zero;
			}
			if (encoding == null)
			{
				throw new ArgumentNullException("encoding");
			}
			int maxByteCount = encoding.GetMaxByteCount(1);
			char[] array = s.ToCharArray(index, count);
			byte[] array2 = new byte[encoding.GetByteCount(array) + maxByteCount];
			int bytes = encoding.GetBytes(array, 0, array.Length, array2, 0);
			if (bytes != array2.Length - maxByteCount)
			{
				throw new NotSupportedException("encoding.GetBytes() doesn't equal encoding.GetByteCount()!");
			}
			IntPtr intPtr = AllocHeap(array2.Length);
			if (intPtr == IntPtr.Zero)
			{
				throw new UnixIOException(Errno.ENOMEM);
			}
			bool flag = false;
			try
			{
				Marshal.Copy(array2, 0, intPtr, array2.Length);
				flag = true;
			}
			finally
			{
				if (!flag)
				{
					FreeHeap(intPtr);
				}
			}
			return intPtr;
		}

		public static bool ShouldRetrySyscall(int r)
		{
			if (r == -1 && Stdlib.GetLastError() == Errno.EINTR)
			{
				return true;
			}
			return false;
		}

		[CLSCompliant(false)]
		public static bool ShouldRetrySyscall(int r, out Errno errno)
		{
			errno = (Errno)0;
			if (r == -1 && (errno = Stdlib.GetLastError()) == Errno.EINTR)
			{
				return true;
			}
			return false;
		}

		internal static string EscapeFormatString(string message, char[] permitted)
		{
			if (message == null)
			{
				return string.Empty;
			}
			StringBuilder stringBuilder = new StringBuilder(message.Length);
			for (int i = 0; i < message.Length; i++)
			{
				char c = message[i];
				stringBuilder.Append(c);
				if (c == '%' && i + 1 < message.Length)
				{
					char c2 = message[i + 1];
					if (c2 == '%' || IsCharPresent(permitted, c2))
					{
						stringBuilder.Append(c2);
					}
					else
					{
						stringBuilder.Append('%').Append(c2);
					}
					i++;
				}
				else if (c == '%')
				{
					stringBuilder.Append('%');
				}
			}
			return stringBuilder.ToString();
		}

		private static bool IsCharPresent(char[] array, char c)
		{
			if (array == null)
			{
				return false;
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] == c)
				{
					return true;
				}
			}
			return false;
		}

		internal static Exception CreateExceptionForError(Errno errno)
		{
			string errorDescription = GetErrorDescription(errno);
			UnixIOException ex = new UnixIOException(errno);
			switch (errno)
			{
			case Errno.EBADF:
			case Errno.EINVAL:
				return new ArgumentException(errorDescription, ex);
			case Errno.ERANGE:
				return new ArgumentOutOfRangeException(errorDescription);
			case Errno.ENOTDIR:
				return new DirectoryNotFoundException(errorDescription, ex);
			case Errno.ENOENT:
				return new FileNotFoundException(errorDescription, ex);
			case Errno.EPERM:
			case Errno.EOPNOTSUPP:
				return new InvalidOperationException(errorDescription, ex);
			case Errno.ENOEXEC:
				return new InvalidProgramException(errorDescription, ex);
			case Errno.EIO:
			case Errno.ENXIO:
			case Errno.ENOSPC:
			case Errno.ESPIPE:
			case Errno.EROFS:
			case Errno.ENOTEMPTY:
				return new IOException(errorDescription, ex);
			case Errno.EFAULT:
				return new NullReferenceException(errorDescription, ex);
			case Errno.EOVERFLOW:
				return new OverflowException(errorDescription, ex);
			case Errno.ENAMETOOLONG:
				return new PathTooLongException(errorDescription, ex);
			case Errno.EACCES:
			case Errno.EISDIR:
				return new UnauthorizedAccessException(errorDescription, ex);
			default:
				return ex;
			}
		}

		internal static Exception CreateExceptionForLastError()
		{
			return CreateExceptionForError(Stdlib.GetLastError());
		}

		[CLSCompliant(false)]
		public static void ThrowExceptionForError(Errno errno)
		{
			throw CreateExceptionForError(errno);
		}

		public static void ThrowExceptionForLastError()
		{
			throw CreateExceptionForLastError();
		}

		[CLSCompliant(false)]
		public static void ThrowExceptionForErrorIf(int retval, Errno errno)
		{
			if (retval == -1)
			{
				ThrowExceptionForError(errno);
			}
		}

		public static void ThrowExceptionForLastErrorIf(int retval)
		{
			if (retval == -1)
			{
				ThrowExceptionForLastError();
			}
		}
	}
	public sealed class UnixPath
	{
		public static readonly char DirectorySeparatorChar = '/';

		public static readonly char AltDirectorySeparatorChar = '/';

		public static readonly char PathSeparator = ':';

		public static readonly char VolumeSeparatorChar = '/';

		private static readonly char[] _InvalidPathChars = new char[0];

		private UnixPath()
		{
		}

		public static char[] GetInvalidPathChars()
		{
			return (char[])_InvalidPathChars.Clone();
		}

		public static string Combine(string path1, params string[] paths)
		{
			if (path1 == null)
			{
				throw new ArgumentNullException("path1");
			}
			if (paths == null)
			{
				throw new ArgumentNullException("paths");
			}
			if (path1.IndexOfAny(_InvalidPathChars) != -1)
			{
				throw new ArgumentException("Illegal characters in path", "path1");
			}
			int num = path1.Length;
			int num2 = -1;
			for (int i = 0; i < paths.Length; i++)
			{
				if (paths[i] == null)
				{
					throw new ArgumentNullException("paths[" + i + "]");
				}
				if (paths[i].IndexOfAny(_InvalidPathChars) != -1)
				{
					throw new ArgumentException("Illegal characters in path", "paths[" + i + "]");
				}
				if (IsPathRooted(paths[i]))
				{
					num = 0;
					num2 = i;
				}
				num += paths[i].Length + 1;
			}
			StringBuilder stringBuilder = new StringBuilder(num);
			if (num2 == -1)
			{
				stringBuilder.Append(path1);
				num2 = 0;
			}
			for (int j = num2; j < paths.Length; j++)
			{
				Combine(stringBuilder, paths[j]);
			}
			return stringBuilder.ToString();
		}

		private static void Combine(StringBuilder path, string part)
		{
			if (path.Length > 0 && part.Length > 0)
			{
				char c = path[path.Length - 1];
				if (c != DirectorySeparatorChar && c != AltDirectorySeparatorChar && c != VolumeSeparatorChar)
				{
					path.Append(DirectorySeparatorChar);
				}
			}
			path.Append(part);
		}

		public static string GetDirectoryName(string path)
		{
			CheckPath(path);
			int num = path.LastIndexOf(DirectorySeparatorChar);
			if (num > 0)
			{
				return path.Substring(0, num);
			}
			if (num == 0)
			{
				return "/";
			}
			return string.Empty;
		}

		public static string GetFileName(string path)
		{
			if (path == null || path.Length == 0)
			{
				return path;
			}
			int num = path.LastIndexOf(DirectorySeparatorChar);
			if (num >= 0)
			{
				return path.Substring(num + 1);
			}
			return path;
		}

		public static string GetFullPath(string path)
		{
			path = _GetFullPath(path);
			return GetCanonicalPath(path);
		}

		private static string _GetFullPath(string path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			if (!IsPathRooted(path))
			{
				path = UnixDirectoryInfo.GetCurrentDirectory() + DirectorySeparatorChar + path;
			}
			return path;
		}

		public static string GetCanonicalPath(string path)
		{
			GetPathComponents(path, out var components, out var lastIndex);
			string text = string.Join("/", components, 0, lastIndex);
			return (!IsPathRooted(path)) ? text : ("/" + text);
		}

		private static void GetPathComponents(string path, out string[] components, out int lastIndex)
		{
			string[] array = path.Split(new char[1] { DirectorySeparatorChar });
			int num = 0;
			for (int i = 0; i < array.Length; i++)
			{
				if (!(array[i] == ".") && !(array[i] == string.Empty))
				{
					if (array[i] == "..")
					{
						num = ((num == 0) ? (num + 1) : (num - 1));
					}
					else
					{
						array[num++] = array[i];
					}
				}
			}
			components = array;
			lastIndex = num;
		}

		public static string GetPathRoot(string path)
		{
			if (path == null)
			{
				return null;
			}
			if (!IsPathRooted(path))
			{
				return string.Empty;
			}
			return "/";
		}

		public static string GetCompleteRealPath(string path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			GetPathComponents(path, out var components, out var lastIndex);
			StringBuilder stringBuilder = new StringBuilder();
			if (components.Length > 0)
			{
				string text = ((!IsPathRooted(path)) ? string.Empty : "/");
				text += components[0];
				stringBuilder.Append(GetRealPath(text));
			}
			for (int i = 1; i < lastIndex; i++)
			{
				stringBuilder.Append("/").Append(components[i]);
				string realPath = GetRealPath(stringBuilder.ToString());
				stringBuilder.Remove(0, stringBuilder.Length);
				stringBuilder.Append(realPath);
			}
			return stringBuilder.ToString();
		}

		public static string GetRealPath(string path)
		{
			while (true)
			{
				string text = ReadSymbolicLink(path);
				if (text == null)
				{
					break;
				}
				if (IsPathRooted(text))
				{
					path = text;
					continue;
				}
				path = GetDirectoryName(path) + DirectorySeparatorChar + text;
				path = GetCanonicalPath(path);
			}
			return path;
		}

		internal static string ReadSymbolicLink(string path)
		{
			StringBuilder stringBuilder = new StringBuilder(256);
			int num;
			while (true)
			{
				num = Mono.Unix.Native.Syscall.readlink(path, stringBuilder);
				if (num < 0)
				{
					Errno lastError;
					Errno errno = (lastError = Stdlib.GetLastError());
					if (errno == Errno.EINVAL)
					{
						return null;
					}
					UnixMarshal.ThrowExceptionForError(lastError);
				}
				else
				{
					if (num != stringBuilder.Capacity)
					{
						break;
					}
					stringBuilder.Capacity *= 2;
				}
			}
			return stringBuilder.ToString(0, num);
		}

		private static string ReadSymbolicLink(string path, out Errno errno)
		{
			errno = (Errno)0;
			StringBuilder stringBuilder = new StringBuilder(256);
			int num;
			while (true)
			{
				num = Mono.Unix.Native.Syscall.readlink(path, stringBuilder);
				if (num < 0)
				{
					errno = Stdlib.GetLastError();
					return null;
				}
				if (num != stringBuilder.Capacity)
				{
					break;
				}
				stringBuilder.Capacity *= 2;
			}
			return stringBuilder.ToString(0, num);
		}

		public static string TryReadLink(string path)
		{
			Errno errno;
			return ReadSymbolicLink(path, out errno);
		}

		public static string ReadLink(string path)
		{
			path = ReadSymbolicLink(path, out var errno);
			if (errno != 0)
			{
				UnixMarshal.ThrowExceptionForError(errno);
			}
			return path;
		}

		public static bool IsPathRooted(string path)
		{
			if (path == null || path.Length == 0)
			{
				return false;
			}
			return path[0] == DirectorySeparatorChar;
		}

		internal static void CheckPath(string path)
		{
			if (path == null)
			{
				throw new ArgumentNullException();
			}
			if (path.Length == 0)
			{
				throw new ArgumentException("Path cannot contain a zero-length string", "path");
			}
			if (path.IndexOfAny(_InvalidPathChars) != -1)
			{
				throw new ArgumentException("Invalid characters in path.", "path");
			}
		}
	}
	public struct UnixPipes : IEquatable<UnixPipes>
	{
		public UnixStream Reading;

		public UnixStream Writing;

		public UnixPipes(UnixStream reading, UnixStream writing)
		{
			Reading = reading;
			Writing = writing;
		}

		public static UnixPipes CreatePipes()
		{
			int reading;
			int writing;
			int retval = Mono.Unix.Native.Syscall.pipe(out reading, out writing);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			return new UnixPipes(new UnixStream(reading), new UnixStream(writing));
		}

		public override bool Equals(object value)
		{
			if (value == null || (object)value.GetType() != GetType())
			{
				return false;
			}
			UnixPipes unixPipes = (UnixPipes)value;
			return Reading.Handle == unixPipes.Reading.Handle && Writing.Handle == unixPipes.Writing.Handle;
		}

		public bool Equals(UnixPipes value)
		{
			return Reading.Handle == value.Reading.Handle && Writing.Handle == value.Writing.Handle;
		}

		public override int GetHashCode()
		{
			return Reading.Handle.GetHashCode() ^ Writing.Handle.GetHashCode();
		}

		public static bool operator ==(UnixPipes lhs, UnixPipes rhs)
		{
			return lhs.Equals(rhs);
		}

		public static bool operator !=(UnixPipes lhs, UnixPipes rhs)
		{
			return !lhs.Equals(rhs);
		}
	}
	public sealed class UnixProcess
	{
		private int pid;

		public int Id => pid;

		public bool HasExited
		{
			get
			{
				int processStatus = GetProcessStatus();
				return Mono.Unix.Native.Syscall.WIFEXITED(processStatus);
			}
		}

		public int ExitCode
		{
			get
			{
				if (!HasExited)
				{
					throw new InvalidOperationException(global::Locale.GetText("Process hasn't exited"));
				}
				int processStatus = GetProcessStatus();
				return Mono.Unix.Native.Syscall.WEXITSTATUS(processStatus);
			}
		}

		public bool HasSignaled
		{
			get
			{
				int processStatus = GetProcessStatus();
				return Mono.Unix.Native.Syscall.WIFSIGNALED(processStatus);
			}
		}

		public Signum TerminationSignal
		{
			get
			{
				if (!HasSignaled)
				{
					throw new InvalidOperationException(global::Locale.GetText("Process wasn't terminated by a signal"));
				}
				int processStatus = GetProcessStatus();
				return Mono.Unix.Native.Syscall.WTERMSIG(processStatus);
			}
		}

		public bool HasStopped
		{
			get
			{
				int processStatus = GetProcessStatus();
				return Mono.Unix.Native.Syscall.WIFSTOPPED(processStatus);
			}
		}

		public Signum StopSignal
		{
			get
			{
				if (!HasStopped)
				{
					throw new InvalidOperationException(global::Locale.GetText("Process isn't stopped"));
				}
				int processStatus = GetProcessStatus();
				return Mono.Unix.Native.Syscall.WSTOPSIG(processStatus);
			}
		}

		public int ProcessGroupId
		{
			get
			{
				return Mono.Unix.Native.Syscall.getpgid(pid);
			}
			set
			{
				int retval = Mono.Unix.Native.Syscall.setpgid(pid, value);
				UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			}
		}

		public int SessionId
		{
			get
			{
				int num = Mono.Unix.Native.Syscall.getsid(pid);
				UnixMarshal.ThrowExceptionForLastErrorIf(num);
				return num;
			}
		}

		internal UnixProcess(int pid)
		{
			this.pid = pid;
		}

		private int GetProcessStatus()
		{
			int status;
			int num = Mono.Unix.Native.Syscall.waitpid(pid, out status, Mono.Unix.Native.WaitOptions.WNOHANG | Mono.Unix.Native.WaitOptions.WUNTRACED);
			UnixMarshal.ThrowExceptionForLastErrorIf(num);
			return num;
		}

		public static UnixProcess GetCurrentProcess()
		{
			return new UnixProcess(GetCurrentProcessId());
		}

		public static int GetCurrentProcessId()
		{
			return Mono.Unix.Native.Syscall.getpid();
		}

		public void Kill()
		{
			Signal(Signum.SIGKILL);
		}

		[CLSCompliant(false)]
		public void Signal(Signum signal)
		{
			int retval = Mono.Unix.Native.Syscall.kill(pid, signal);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}

		public void WaitForExit()
		{
			int num;
			do
			{
				num = Mono.Unix.Native.Syscall.waitpid(pid, out var _, (Mono.Unix.Native.WaitOptions)0);
			}
			while (UnixMarshal.ShouldRetrySyscall(num));
			UnixMarshal.ThrowExceptionForLastErrorIf(num);
		}
	}
	public class UnixSignal : WaitHandle
	{
		[Map]
		private struct SignalInfo
		{
			public int signum;

			public int count;

			public int read_fd;

			public int write_fd;

			public int have_handler;

			public int pipecnt;

			public IntPtr handler;
		}

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate int Mono_Posix_RuntimeIsShuttingDown();

		private int signum;

		private IntPtr signal_info;

		public Signum Signum
		{
			get
			{
				if (IsRealTimeSignal)
				{
					throw new InvalidOperationException("This signal is a RealTimeSignum");
				}
				return NativeConvert.ToSignum(signum);
			}
		}

		public RealTimeSignum RealTimeSignum
		{
			get
			{
				if (!IsRealTimeSignal)
				{
					throw new InvalidOperationException("This signal is not a RealTimeSignum");
				}
				return NativeConvert.ToRealTimeSignum(signum - GetSIGRTMIN());
			}
		}

		public bool IsRealTimeSignal
		{
			get
			{
				AssertValid();
				int sIGRTMIN = GetSIGRTMIN();
				if (sIGRTMIN == -1)
				{
					return false;
				}
				return signum >= sIGRTMIN;
			}
		}

		private unsafe SignalInfo* Info
		{
			get
			{
				AssertValid();
				return (SignalInfo*)(void*)signal_info;
			}
		}

		public bool IsSet => Count > 0;

		public unsafe int Count
		{
			get
			{
				return Info->count;
			}
			set
			{
				Interlocked.Exchange(ref Info->count, value);
			}
		}

		public UnixSignal(Signum signum)
		{
			this.signum = NativeConvert.FromSignum(signum);
			signal_info = install(this.signum);
			if (signal_info == IntPtr.Zero)
			{
				throw new ArgumentException("Unable to handle signal", "signum");
			}
		}

		public UnixSignal(RealTimeSignum rtsig)
		{
			signum = NativeConvert.FromRealTimeSignum(rtsig);
			signal_info = install(signum);
			Errno lastError = Stdlib.GetLastError();
			if (signal_info == IntPtr.Zero)
			{
				if (lastError == Errno.EADDRINUSE)
				{
					throw new ArgumentException("Signal registered outside of Mono.Posix", "signum");
				}
				throw new ArgumentException("Unable to handle signal", "signum");
			}
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Unix_UnixSignal_install", SetLastError = true)]
		private static extern IntPtr install(int signum);

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Unix_UnixSignal_uninstall")]
		private static extern int uninstall(IntPtr info);

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Unix_UnixSignal_WaitAny")]
		private static extern int WaitAny(IntPtr[] infos, int count, int timeout, Mono_Posix_RuntimeIsShuttingDown shutting_down);

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_SIGRTMIN")]
		internal static extern int GetSIGRTMIN();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_SIGRTMAX")]
		internal static extern int GetSIGRTMAX();

		private void AssertValid()
		{
			if (signal_info == IntPtr.Zero)
			{
				throw new ObjectDisposedException(GetType().FullName);
			}
		}

		public unsafe bool Reset()
		{
			int num = Interlocked.Exchange(ref Info->count, 0);
			return num != 0;
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (!(signal_info == IntPtr.Zero))
			{
				uninstall(signal_info);
				signal_info = IntPtr.Zero;
			}
		}

		public override bool WaitOne()
		{
			return WaitOne(-1, exitContext: false);
		}

		public override bool WaitOne(TimeSpan timeout, bool exitContext)
		{
			long num = (long)timeout.TotalMilliseconds;
			if (num < -1 || num > int.MaxValue)
			{
				throw new ArgumentOutOfRangeException("timeout");
			}
			return WaitOne((int)num, exitContext);
		}

		public override bool WaitOne(int millisecondsTimeout, bool exitContext)
		{
			AssertValid();
			if (exitContext)
			{
				throw new InvalidOperationException("exitContext is not supported");
			}
			return WaitAny(new UnixSignal[1] { this }, millisecondsTimeout) == 0;
		}

		public static int WaitAny(UnixSignal[] signals)
		{
			return WaitAny(signals, -1);
		}

		public static int WaitAny(UnixSignal[] signals, TimeSpan timeout)
		{
			long num = (long)timeout.TotalMilliseconds;
			if (num < -1 || num > int.MaxValue)
			{
				throw new ArgumentOutOfRangeException("timeout");
			}
			return WaitAny(signals, (int)num);
		}

		public static int WaitAny(UnixSignal[] signals, int millisecondsTimeout)
		{
			if (signals == null)
			{
				throw new ArgumentNullException("signals");
			}
			if (millisecondsTimeout < -1)
			{
				throw new ArgumentOutOfRangeException("millisecondsTimeout");
			}
			IntPtr[] array = new IntPtr[signals.Length];
			for (int i = 0; i < signals.Length; i++)
			{
				ref IntPtr reference = ref array[i];
				reference = signals[i].signal_info;
				if (array[i] == IntPtr.Zero)
				{
					throw new InvalidOperationException("Disposed UnixSignal");
				}
			}
			return WaitAny(array, array.Length, millisecondsTimeout, () => Environment.HasShutdownStarted ? 1 : 0);
		}
	}
	public sealed class UnixStream : Stream, IDisposable
	{
		public const int InvalidFileDescriptor = -1;

		public const int StandardInputFileDescriptor = 0;

		public const int StandardOutputFileDescriptor = 1;

		public const int StandardErrorFileDescriptor = 2;

		private bool canSeek;

		private bool canRead;

		private bool canWrite;

		private bool owner = true;

		private int fileDescriptor = -1;

		private Mono.Unix.Native.Stat stat;

		public int Handle => fileDescriptor;

		public override bool CanRead => canRead;

		public override bool CanSeek => canSeek;

		public override bool CanWrite => canWrite;

		public override long Length
		{
			get
			{
				AssertNotDisposed();
				if (!CanSeek)
				{
					throw new NotSupportedException("File descriptor doesn't support seeking");
				}
				RefreshStat();
				return stat.st_size;
			}
		}

		public override long Position
		{
			get
			{
				AssertNotDisposed();
				if (!CanSeek)
				{
					throw new NotSupportedException("The stream does not support seeking");
				}
				long num = Mono.Unix.Native.Syscall.lseek(fileDescriptor, 0L, SeekFlags.SEEK_CUR);
				if (num == -1)
				{
					UnixMarshal.ThrowExceptionForLastError();
				}
				return num;
			}
			set
			{
				Seek(value, SeekOrigin.Begin);
			}
		}

		[CLSCompliant(false)]
		public FilePermissions Protection
		{
			get
			{
				RefreshStat();
				return stat.st_mode;
			}
			set
			{
				value = (FilePermissions)((uint)value & 0xFFFF0FFFu);
				int retval = Mono.Unix.Native.Syscall.fchmod(fileDescriptor, value);
				UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			}
		}

		public FileTypes FileType
		{
			get
			{
				int protection = (int)Protection;
				return (FileTypes)(protection & 0xF000);
			}
		}

		public FileAccessPermissions FileAccessPermissions
		{
			get
			{
				int protection = (int)Protection;
				return (FileAccessPermissions)(protection & 0x1FF);
			}
			set
			{
				int protection = (int)Protection;
				protection &= -512;
				protection |= (int)value;
				Protection = (FilePermissions)protection;
			}
		}

		public FileSpecialAttributes FileSpecialAttributes
		{
			get
			{
				int protection = (int)Protection;
				return (FileSpecialAttributes)(protection & 0xE00);
			}
			set
			{
				int protection = (int)Protection;
				protection &= -3585;
				protection |= (int)value;
				Protection = (FilePermissions)protection;
			}
		}

		public UnixUserInfo OwnerUser
		{
			get
			{
				RefreshStat();
				return new UnixUserInfo(stat.st_uid);
			}
		}

		public long OwnerUserId
		{
			get
			{
				RefreshStat();
				return stat.st_uid;
			}
		}

		public UnixGroupInfo OwnerGroup
		{
			get
			{
				RefreshStat();
				return new UnixGroupInfo(stat.st_gid);
			}
		}

		public long OwnerGroupId
		{
			get
			{
				RefreshStat();
				return stat.st_gid;
			}
		}

		public UnixStream(int fileDescriptor)
			: this(fileDescriptor, ownsHandle: true)
		{
		}

		public UnixStream(int fileDescriptor, bool ownsHandle)
		{
			if (fileDescriptor == -1)
			{
				throw new ArgumentException(global::Locale.GetText("Invalid file descriptor"), "fileDescriptor");
			}
			this.fileDescriptor = fileDescriptor;
			owner = ownsHandle;
			long num = Mono.Unix.Native.Syscall.lseek(fileDescriptor, 0L, SeekFlags.SEEK_CUR);
			if (num != -1)
			{
				canSeek = true;
			}
			long num2 = Mono.Unix.Native.Syscall.read(fileDescriptor, IntPtr.Zero, 0uL);
			if (num2 != -1)
			{
				canRead = true;
			}
			long num3 = Mono.Unix.Native.Syscall.write(fileDescriptor, IntPtr.Zero, 0uL);
			if (num3 != -1)
			{
				canWrite = true;
			}
		}

		void IDisposable.Dispose()
		{
			AssertNotDisposed();
			if (owner)
			{
				Close();
			}
			GC.SuppressFinalize(this);
		}

		private void AssertNotDisposed()
		{
			if (fileDescriptor == -1)
			{
				throw new ObjectDisposedException("Invalid File Descriptor");
			}
		}

		private void RefreshStat()
		{
			AssertNotDisposed();
			int retval = Mono.Unix.Native.Syscall.fstat(fileDescriptor, out stat);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}

		public void AdviseFileAccessPattern(FileAccessPattern pattern, long offset, long len)
		{
			FileHandleOperations.AdviseFileAccessPattern(fileDescriptor, pattern, offset, len);
		}

		public void AdviseFileAccessPattern(FileAccessPattern pattern)
		{
			AdviseFileAccessPattern(pattern, 0L, 0L);
		}

		public override void Flush()
		{
		}

		public unsafe override int Read([In][Out] byte[] buffer, int offset, int count)
		{
			AssertNotDisposed();
			AssertValidBuffer(buffer, offset, count);
			if (!CanRead)
			{
				throw new NotSupportedException("Stream does not support reading");
			}
			if (buffer.Length == 0)
			{
				return 0;
			}
			long num = 0L;
			fixed (byte* buf = &buffer[offset])
			{
				do
				{
					num = Mono.Unix.Native.Syscall.read(fileDescriptor, buf, (ulong)count);
				}
				while (UnixMarshal.ShouldRetrySyscall((int)num));
			}
			if (num == -1)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			return (int)num;
		}

		private void AssertValidBuffer(byte[] buffer, int offset, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", "< 0");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", "< 0");
			}
			if (offset > buffer.Length)
			{
				throw new ArgumentException("destination offset is beyond array size");
			}
			if (offset > buffer.Length - count)
			{
				throw new ArgumentException("would overrun buffer");
			}
		}

		public unsafe int ReadAtOffset([In][Out] byte[] buffer, int offset, int count, long fileOffset)
		{
			AssertNotDisposed();
			AssertValidBuffer(buffer, offset, count);
			if (!CanRead)
			{
				throw new NotSupportedException("Stream does not support reading");
			}
			if (buffer.Length == 0)
			{
				return 0;
			}
			long num = 0L;
			fixed (byte* buf = &buffer[offset])
			{
				do
				{
					num = Mono.Unix.Native.Syscall.pread(fileDescriptor, buf, (ulong)count, fileOffset);
				}
				while (UnixMarshal.ShouldRetrySyscall((int)num));
			}
			if (num == -1)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			return (int)num;
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			AssertNotDisposed();
			if (!CanSeek)
			{
				throw new NotSupportedException("The File Descriptor does not support seeking");
			}
			SeekFlags whence = SeekFlags.SEEK_CUR;
			switch (origin)
			{
			case SeekOrigin.Begin:
				whence = SeekFlags.SEEK_SET;
				break;
			case SeekOrigin.Current:
				whence = SeekFlags.SEEK_CUR;
				break;
			case SeekOrigin.End:
				whence = SeekFlags.SEEK_END;
				break;
			}
			long num = Mono.Unix.Native.Syscall.lseek(fileDescriptor, offset, whence);
			if (num == -1)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			return num;
		}

		public override void SetLength(long value)
		{
			AssertNotDisposed();
			if (value < 0)
			{
				throw new ArgumentOutOfRangeException("value", "< 0");
			}
			if (!CanSeek && !CanWrite)
			{
				throw new NotSupportedException("You can't truncating the current file descriptor");
			}
			int num;
			do
			{
				num = Mono.Unix.Native.Syscall.ftruncate(fileDescriptor, value);
			}
			while (UnixMarshal.ShouldRetrySyscall(num));
			UnixMarshal.ThrowExceptionForLastErrorIf(num);
		}

		public unsafe override void Write(byte[] buffer, int offset, int count)
		{
			AssertNotDisposed();
			AssertValidBuffer(buffer, offset, count);
			if (!CanWrite)
			{
				throw new NotSupportedException("File Descriptor does not support writing");
			}
			if (buffer.Length == 0)
			{
				return;
			}
			long num = 0L;
			fixed (byte* buf = &buffer[offset])
			{
				do
				{
					num = Mono.Unix.Native.Syscall.write(fileDescriptor, buf, (ulong)count);
				}
				while (UnixMarshal.ShouldRetrySyscall((int)num));
			}
			if (num == -1)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
		}

		public unsafe void WriteAtOffset(byte[] buffer, int offset, int count, long fileOffset)
		{
			AssertNotDisposed();
			AssertValidBuffer(buffer, offset, count);
			if (!CanWrite)
			{
				throw new NotSupportedException("File Descriptor does not support writing");
			}
			if (buffer.Length == 0)
			{
				return;
			}
			long num = 0L;
			fixed (byte* buf = &buffer[offset])
			{
				do
				{
					num = Mono.Unix.Native.Syscall.pwrite(fileDescriptor, buf, (ulong)count, fileOffset);
				}
				while (UnixMarshal.ShouldRetrySyscall((int)num));
			}
			if (num == -1)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
		}

		public void SendTo(UnixStream output)
		{
			SendTo(output, (ulong)output.Length);
		}

		[CLSCompliant(false)]
		public void SendTo(UnixStream output, ulong count)
		{
			SendTo(output.Handle, count);
		}

		[CLSCompliant(false)]
		public void SendTo(int out_fd, ulong count)
		{
			if (!CanWrite)
			{
				throw new NotSupportedException("Unable to write to the current file descriptor");
			}
			long offset = Position;
			long num = Mono.Unix.Native.Syscall.sendfile(out_fd, fileDescriptor, ref offset, count);
			if (num == -1)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
		}

		public void SetOwner(long user, long group)
		{
			AssertNotDisposed();
			int retval = Mono.Unix.Native.Syscall.fchown(fileDescriptor, Convert.ToUInt32(user), Convert.ToUInt32(group));
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}

		public void SetOwner(string user, string group)
		{
			AssertNotDisposed();
			long userId = new UnixUserInfo(user).UserId;
			long groupId = new UnixGroupInfo(group).GroupId;
			SetOwner(userId, groupId);
		}

		public void SetOwner(string user)
		{
			AssertNotDisposed();
			Passwd passwd = Mono.Unix.Native.Syscall.getpwnam(user);
			if (passwd == null)
			{
				throw new ArgumentException(global::Locale.GetText("invalid username"), "user");
			}
			long user2 = passwd.pw_uid;
			long num = passwd.pw_gid;
			SetOwner(user2, num);
		}

		[CLSCompliant(false)]
		public long GetConfigurationValue(PathconfName name)
		{
			AssertNotDisposed();
			long num = Mono.Unix.Native.Syscall.fpathconf(fileDescriptor, name);
			if (num == -1 && Stdlib.GetLastError() != 0)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			return num;
		}

		~UnixStream()
		{
			Close();
		}

		public override void Close()
		{
			if (fileDescriptor == -1)
			{
				return;
			}
			Flush();
			if (owner)
			{
				int num;
				do
				{
					num = Mono.Unix.Native.Syscall.close(fileDescriptor);
				}
				while (UnixMarshal.ShouldRetrySyscall(num));
				UnixMarshal.ThrowExceptionForLastErrorIf(num);
				fileDescriptor = -1;
				GC.SuppressFinalize(this);
			}
		}
	}
	public sealed class UnixSymbolicLinkInfo : UnixFileSystemInfo
	{
		public override string Name => UnixPath.GetFileName(base.FullPath);

		[Obsolete("Use GetContents()")]
		public UnixFileSystemInfo Contents => GetContents();

		public string ContentsPath => ReadLink();

		public bool HasContents => TryReadLink() != null;

		public UnixSymbolicLinkInfo(string path)
			: base(path)
		{
		}

		internal UnixSymbolicLinkInfo(string path, Mono.Unix.Native.Stat stat)
			: base(path, stat)
		{
		}

		public UnixFileSystemInfo GetContents()
		{
			string text = ReadLink();
			return UnixFileSystemInfo.GetFileSystemEntry(UnixPath.Combine(UnixPath.GetDirectoryName(base.FullPath), ContentsPath));
		}

		public void CreateSymbolicLinkTo(string path)
		{
			int retval = Mono.Unix.Native.Syscall.symlink(path, FullName);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}

		public void CreateSymbolicLinkTo(UnixFileSystemInfo path)
		{
			int retval = Mono.Unix.Native.Syscall.symlink(path.FullName, FullName);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}

		public override void Delete()
		{
			int retval = Mono.Unix.Native.Syscall.unlink(base.FullPath);
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
			Refresh();
		}

		public override void SetOwner(long owner, long group)
		{
			int retval = Mono.Unix.Native.Syscall.lchown(base.FullPath, Convert.ToUInt32(owner), Convert.ToUInt32(group));
			UnixMarshal.ThrowExceptionForLastErrorIf(retval);
		}

		protected override bool GetFileStatus(string path, out Mono.Unix.Native.Stat stat)
		{
			return Mono.Unix.Native.Syscall.lstat(path, out stat) == 0;
		}

		private string ReadLink()
		{
			string text = TryReadLink();
			if (text == null)
			{
				UnixMarshal.ThrowExceptionForLastError();
			}
			return text;
		}

		private string TryReadLink()
		{
			StringBuilder stringBuilder = new StringBuilder((int)base.Length + 1);
			int num = Mono.Unix.Native.Syscall.readlink(base.FullPath, stringBuilder);
			if (num == -1)
			{
				return null;
			}
			return stringBuilder.ToString(0, num);
		}
	}
	public sealed class UnixUserInfo
	{
		private Passwd passwd;

		public string UserName => passwd.pw_name;

		public string Password => passwd.pw_passwd;

		public long UserId => passwd.pw_uid;

		public UnixGroupInfo Group => new UnixGroupInfo(passwd.pw_gid);

		public long GroupId => passwd.pw_gid;

		public string GroupName => Group.GroupName;

		public string RealName => passwd.pw_gecos;

		public string HomeDirectory => passwd.pw_dir;

		public string ShellProgram => passwd.pw_shell;

		public UnixUserInfo(string user)
		{
			passwd = new Passwd();
			if (Mono.Unix.Native.Syscall.getpwnam_r(user, passwd, out var pwbufp) != 0 || pwbufp == null)
			{
				throw new ArgumentException(global::Locale.GetText("invalid username"), "user");
			}
		}

		[CLSCompliant(false)]
		public UnixUserInfo(uint user)
		{
			passwd = new Passwd();
			if (Mono.Unix.Native.Syscall.getpwuid_r(user, passwd, out var pwbufp) != 0 || pwbufp == null)
			{
				throw new ArgumentException(global::Locale.GetText("invalid user id"), "user");
			}
		}

		public UnixUserInfo(long user)
		{
			passwd = new Passwd();
			if (Mono.Unix.Native.Syscall.getpwuid_r(Convert.ToUInt32(user), passwd, out var pwbufp) != 0 || pwbufp == null)
			{
				throw new ArgumentException(global::Locale.GetText("invalid user id"), "user");
			}
		}

		public UnixUserInfo(Passwd passwd)
		{
			this.passwd = CopyPasswd(passwd);
		}

		private static Passwd CopyPasswd(Passwd pw)
		{
			Passwd passwd = new Passwd();
			passwd.pw_name = pw.pw_name;
			passwd.pw_passwd = pw.pw_passwd;
			passwd.pw_uid = pw.pw_uid;
			passwd.pw_gid = pw.pw_gid;
			passwd.pw_gecos = pw.pw_gecos;
			passwd.pw_dir = pw.pw_dir;
			passwd.pw_shell = pw.pw_shell;
			return passwd;
		}

		public override int GetHashCode()
		{
			return passwd.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)GetType() != obj.GetType())
			{
				return false;
			}
			return passwd.Equals(((UnixUserInfo)obj).passwd);
		}

		public override string ToString()
		{
			return passwd.ToString();
		}

		public static UnixUserInfo GetRealUser()
		{
			return new UnixUserInfo(GetRealUserId());
		}

		public static long GetRealUserId()
		{
			return Mono.Unix.Native.Syscall.getuid();
		}

		public static string GetLoginName()
		{
			StringBuilder stringBuilder = new StringBuilder(4);
			int num;
			do
			{
				stringBuilder.Capacity *= 2;
				num = Mono.Unix.Native.Syscall.getlogin_r(stringBuilder, (ulong)stringBuilder.Capacity);
			}
			while (num == -1 && Stdlib.GetLastError() == Errno.ERANGE);
			UnixMarshal.ThrowExceptionForLastErrorIf(num);
			return stringBuilder.ToString();
		}

		public Passwd ToPasswd()
		{
			return CopyPasswd(passwd);
		}

		public static UnixUserInfo[] GetLocalUsers()
		{
			ArrayList arrayList = new ArrayList();
			lock (Mono.Unix.Native.Syscall.pwd_lock)
			{
				if (Mono.Unix.Native.Syscall.setpwent() != 0)
				{
					UnixMarshal.ThrowExceptionForLastError();
				}
				try
				{
					Passwd passwd;
					while ((passwd = Mono.Unix.Native.Syscall.getpwent()) != null)
					{
						arrayList.Add(new UnixUserInfo(passwd));
					}
					if (Stdlib.GetLastError() != 0)
					{
						UnixMarshal.ThrowExceptionForLastError();
					}
				}
				finally
				{
					Mono.Unix.Native.Syscall.endpwent();
				}
			}
			return (UnixUserInfo[])arrayList.ToArray(typeof(UnixUserInfo));
		}
	}
}
namespace Mono.Unix.Native
{
	public sealed class CdeclFunction
	{
		private readonly string library;

		private readonly string method;

		private readonly Type returnType;

		private readonly AssemblyName assemblyName;

		private readonly AssemblyBuilder assemblyBuilder;

		private readonly ModuleBuilder moduleBuilder;

		private Hashtable overloads;

		public CdeclFunction(string library, string method)
			: this(library, method, typeof(void))
		{
		}

		public CdeclFunction(string library, string method, Type returnType)
		{
			this.library = library;
			this.method = method;
			this.returnType = returnType;
			overloads = new Hashtable();
			assemblyName = new AssemblyName();
			assemblyName.Name = "Mono.Posix.Imports." + library;
			assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
			moduleBuilder = assemblyBuilder.DefineDynamicModule(assemblyName.Name);
		}

		public object Invoke(object[] parameters)
		{
			Type[] parameterTypes = GetParameterTypes(parameters);
			MethodInfo methodInfo = CreateMethod(parameterTypes);
			return methodInfo.Invoke(null, parameters);
		}

		private MethodInfo CreateMethod(Type[] parameterTypes)
		{
			string typeName = GetTypeName(parameterTypes);
			lock (overloads)
			{
				MethodInfo methodInfo = (MethodInfo)overloads[typeName];
				if ((object)methodInfo != null)
				{
					return methodInfo;
				}
				TypeBuilder typeBuilder = CreateType(typeName);
				typeBuilder.DefinePInvokeMethod(method, library, System.Reflection.MethodAttributes.Public | System.Reflection.MethodAttributes.Static | System.Reflection.MethodAttributes.PinvokeImpl, CallingConventions.Standard, returnType, parameterTypes, CallingConvention.Cdecl, CharSet.Ansi);
				methodInfo = typeBuilder.CreateType().GetMethod(method);
				overloads.Add(typeName, methodInfo);
				return methodInfo;
			}
		}

		private TypeBuilder CreateType(string typeName)
		{
			return moduleBuilder.DefineType(typeName, System.Reflection.TypeAttributes.Public);
		}

		private static Type GetMarshalType(Type t)
		{
			switch (Type.GetTypeCode(t))
			{
			case TypeCode.Boolean:
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Int16:
			case TypeCode.Int32:
				return typeof(int);
			case TypeCode.Byte:
			case TypeCode.UInt16:
			case TypeCode.UInt32:
				return typeof(uint);
			case TypeCode.Int64:
				return typeof(long);
			case TypeCode.UInt64:
				return typeof(ulong);
			case TypeCode.Single:
			case TypeCode.Double:
				return typeof(double);
			default:
				return t;
			}
		}

		private string GetTypeName(Type[] parameterTypes)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append("[").Append(library).Append("] ")
				.Append(method);
			stringBuilder.Append("(");
			if (parameterTypes.Length > 0)
			{
				stringBuilder.Append(parameterTypes[0]);
			}
			for (int i = 1; i < parameterTypes.Length; i++)
			{
				stringBuilder.Append(",").Append(parameterTypes[i]);
			}
			stringBuilder.Append(") : ").Append(returnType.FullName);
			return stringBuilder.ToString();
		}

		private static Type[] GetParameterTypes(object[] parameters)
		{
			Type[] array = new Type[parameters.Length];
			for (int i = 0; i < parameters.Length; i++)
			{
				array[i] = GetMarshalType(parameters[i].GetType());
			}
			return array;
		}
	}
	internal class FileNameMarshaler : ICustomMarshaler
	{
		private static FileNameMarshaler Instance = new FileNameMarshaler();

		public static ICustomMarshaler GetInstance(string s)
		{
			return Instance;
		}

		public void CleanUpManagedData(object o)
		{
		}

		public void CleanUpNativeData(IntPtr pNativeData)
		{
			UnixMarshal.FreeHeap(pNativeData);
		}

		public int GetNativeDataSize()
		{
			return IntPtr.Size;
		}

		public IntPtr MarshalManagedToNative(object obj)
		{
			if (!(obj is string s))
			{
				return IntPtr.Zero;
			}
			return UnixMarshal.StringToHeap(s, UnixEncoding.Instance);
		}

		public object MarshalNativeToManaged(IntPtr pNativeData)
		{
			return UnixMarshal.PtrToString(pNativeData, UnixEncoding.Instance);
		}
	}
}
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Field | AttributeTargets.Delegate)]
internal class MapAttribute : Attribute
{
	private string nativeType;

	private string suppressFlags;

	public string NativeType => nativeType;

	public string SuppressFlags
	{
		get
		{
			return suppressFlags;
		}
		set
		{
			suppressFlags = value;
		}
	}

	public MapAttribute()
	{
	}

	public MapAttribute(string nativeType)
	{
		this.nativeType = nativeType;
	}
}
namespace Mono.Unix.Native
{
	[CLSCompliant(false)]
	public sealed class NativeConvert
	{
		private const string LIB = "MonoPosixHelper";

		public static readonly DateTime LocalUnixEpoch = new DateTime(1970, 1, 1);

		public static readonly TimeSpan LocalUtcOffset = TimeZone.CurrentTimeZone.GetUtcOffset(DateTime.UtcNow);

		private static readonly string[][] fopen_modes = new string[6][]
		{
			new string[3] { "Can't Read+Create", "wb", "w+b" },
			new string[3] { "Can't Read+Create", "wb", "w+b" },
			new string[3] { "rb", "wb", "r+b" },
			new string[3] { "rb", "wb", "r+b" },
			new string[3] { "Cannot Truncate and Read", "wb", "w+b" },
			new string[3] { "Cannot Append and Read", "ab", "a+b" }
		};

		private NativeConvert()
		{
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromRealTimeSignum")]
		private static extern int FromRealTimeSignum(int offset, out int rval);

		public static int FromRealTimeSignum(RealTimeSignum sig)
		{
			if (FromRealTimeSignum(sig.Offset, out var rval) == -1)
			{
				ThrowArgumentException(sig.Offset);
			}
			return rval;
		}

		public static RealTimeSignum ToRealTimeSignum(int offset)
		{
			return new RealTimeSignum(offset);
		}

		public static FilePermissions FromOctalPermissionString(string value)
		{
			uint value2 = Convert.ToUInt32(value, 8);
			return ToFilePermissions(value2);
		}

		public static string ToOctalPermissionString(FilePermissions value)
		{
			string text = Convert.ToString((int)value & -61441, 8);
			return new string('0', 4 - text.Length) + text;
		}

		public static FilePermissions FromUnixPermissionString(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (value.Length != 9 && value.Length != 10)
			{
				throw new ArgumentException("value", "must contain 9 or 10 characters");
			}
			int num = 0;
			FilePermissions filePermissions = (FilePermissions)0u;
			if (value.Length == 10)
			{
				filePermissions |= GetUnixPermissionDevice(value[num]);
				num++;
			}
			filePermissions |= GetUnixPermissionGroup(value[num++], FilePermissions.S_IRUSR, value[num++], FilePermissions.S_IWUSR, value[num++], FilePermissions.S_IXUSR, 's', 'S', FilePermissions.S_ISUID);
			filePermissions |= GetUnixPermissionGroup(value[num++], FilePermissions.S_IRGRP, value[num++], FilePermissions.S_IWGRP, value[num++], FilePermissions.S_IXGRP, 's', 'S', FilePermissions.S_ISGID);
			return filePermissions | GetUnixPermissionGroup(value[num++], FilePermissions.S_IROTH, value[num++], FilePermissions.S_IWOTH, value[num++], FilePermissions.S_IXOTH, 't', 'T', FilePermissions.S_ISVTX);
		}

		private static FilePermissions GetUnixPermissionDevice(char value)
		{
			return value switch
			{
				'd' => FilePermissions.S_IFDIR, 
				'c' => FilePermissions.S_IFCHR, 
				'b' => FilePermissions.S_IFBLK, 
				'-' => FilePermissions.S_IFREG, 
				'p' => FilePermissions.S_IFIFO, 
				'l' => FilePermissions.S_IFLNK, 
				's' => FilePermissions.S_IFSOCK, 
				_ => throw new ArgumentException("value", "invalid device specification: " + value), 
			};
		}

		private static FilePermissions GetUnixPermissionGroup(char read, FilePermissions readb, char write, FilePermissions writeb, char exec, FilePermissions execb, char xboth, char xbitonly, FilePermissions xbit)
		{
			FilePermissions filePermissions = (FilePermissions)0u;
			if (read == 'r')
			{
				filePermissions |= readb;
			}
			if (write == 'w')
			{
				filePermissions |= writeb;
			}
			if (exec == 'x')
			{
				filePermissions |= execb;
			}
			else if (exec == xbitonly)
			{
				filePermissions |= xbit;
			}
			else if (exec == xboth)
			{
				filePermissions |= execb | xbit;
			}
			return filePermissions;
		}

		public static string ToUnixPermissionString(FilePermissions value)
		{
			char[] array = new char[10] { '-', '-', '-', '-', '-', '-', '-', '-', '-', '-' };
			bool flag = true;
			switch (value & FilePermissions.S_IFMT)
			{
			case FilePermissions.S_IFDIR:
				array[0] = 'd';
				break;
			case FilePermissions.S_IFCHR:
				array[0] = 'c';
				break;
			case FilePermissions.S_IFBLK:
				array[0] = 'b';
				break;
			case FilePermissions.S_IFREG:
				array[0] = '-';
				break;
			case FilePermissions.S_IFIFO:
				array[0] = 'p';
				break;
			case FilePermissions.S_IFLNK:
				array[0] = 'l';
				break;
			case FilePermissions.S_IFSOCK:
				array[0] = 's';
				break;
			default:
				flag = false;
				break;
			}
			SetUnixPermissionGroup(value, array, 1, FilePermissions.S_IRUSR, FilePermissions.S_IWUSR, FilePermissions.S_IXUSR, 's', 'S', FilePermissions.S_ISUID);
			SetUnixPermissionGroup(value, array, 4, FilePermissions.S_IRGRP, FilePermissions.S_IWGRP, FilePermissions.S_IXGRP, 's', 'S', FilePermissions.S_ISGID);
			SetUnixPermissionGroup(value, array, 7, FilePermissions.S_IROTH, FilePermissions.S_IWOTH, FilePermissions.S_IXOTH, 't', 'T', FilePermissions.S_ISVTX);
			return (!flag) ? new string(array, 1, 9) : new string(array);
		}

		private static void SetUnixPermissionGroup(FilePermissions value, char[] access, int index, FilePermissions read, FilePermissions write, FilePermissions exec, char both, char setonly, FilePermissions setxbit)
		{
			if (UnixFileSystemInfo.IsSet(value, read))
			{
				access[index] = 'r';
			}
			if (UnixFileSystemInfo.IsSet(value, write))
			{
				access[index + 1] = 'w';
			}
			access[index + 2] = GetSymbolicMode(value, exec, both, setonly, setxbit);
		}

		private static char GetSymbolicMode(FilePermissions value, FilePermissions xbit, char both, char setonly, FilePermissions setxbit)
		{
			bool flag = UnixFileSystemInfo.IsSet(value, xbit);
			bool flag2 = UnixFileSystemInfo.IsSet(value, setxbit);
			if (flag && flag2)
			{
				return both;
			}
			if (flag2)
			{
				return setonly;
			}
			if (flag)
			{
				return 'x';
			}
			return '-';
		}

		public static DateTime ToDateTime(long time)
		{
			return FromTimeT(time);
		}

		public static long FromDateTime(DateTime time)
		{
			return ToTimeT(time);
		}

		public static DateTime FromTimeT(long time)
		{
			DateTime localUnixEpoch = LocalUnixEpoch;
			double num = time;
			TimeSpan localUtcOffset = LocalUtcOffset;
			return localUnixEpoch.AddSeconds(num + localUtcOffset.TotalSeconds);
		}

		public static long ToTimeT(DateTime time)
		{
			return (long)(time.Subtract(LocalUnixEpoch) - LocalUtcOffset).TotalSeconds;
		}

		public static OpenFlags ToOpenFlags(System.IO.FileMode mode, FileAccess access)
		{
			OpenFlags openFlags = OpenFlags.O_RDONLY;
			switch (mode)
			{
			case System.IO.FileMode.CreateNew:
				openFlags = OpenFlags.O_CREAT | OpenFlags.O_EXCL;
				break;
			case System.IO.FileMode.Create:
				openFlags = OpenFlags.O_CREAT | OpenFlags.O_TRUNC;
				break;
			case System.IO.FileMode.OpenOrCreate:
				openFlags = OpenFlags.O_CREAT;
				break;
			case System.IO.FileMode.Truncate:
				openFlags = OpenFlags.O_TRUNC;
				break;
			case System.IO.FileMode.Append:
				openFlags = OpenFlags.O_APPEND;
				break;
			default:
				throw new ArgumentException(global::Locale.GetText("Unsupported mode value"), "mode");
			case System.IO.FileMode.Open:
				break;
			}
			if (TryFromOpenFlags(OpenFlags.O_LARGEFILE, out var _))
			{
				openFlags |= OpenFlags.O_LARGEFILE;
			}
			return access switch
			{
				FileAccess.Read => openFlags | OpenFlags.O_RDONLY, 
				FileAccess.Write => openFlags | OpenFlags.O_WRONLY, 
				FileAccess.ReadWrite => openFlags | OpenFlags.O_RDWR, 
				_ => throw new ArgumentOutOfRangeException(global::Locale.GetText("Unsupported access value"), "access"), 
			};
		}

		public static string ToFopenMode(FileAccess access)
		{
			return access switch
			{
				FileAccess.Read => "rb", 
				FileAccess.Write => "wb", 
				FileAccess.ReadWrite => "r+b", 
				_ => throw new ArgumentOutOfRangeException("access"), 
			};
		}

		public static string ToFopenMode(System.IO.FileMode mode)
		{
			switch (mode)
			{
			case System.IO.FileMode.CreateNew:
			case System.IO.FileMode.Create:
				return "w+b";
			case System.IO.FileMode.Open:
			case System.IO.FileMode.OpenOrCreate:
				return "r+b";
			case System.IO.FileMode.Truncate:
				return "w+b";
			case System.IO.FileMode.Append:
				return "a+b";
			default:
				throw new ArgumentOutOfRangeException("mode");
			}
		}

		public static string ToFopenMode(System.IO.FileMode mode, FileAccess access)
		{
			int num = -1;
			int num2 = -1;
			switch (mode)
			{
			case System.IO.FileMode.CreateNew:
				num = 0;
				break;
			case System.IO.FileMode.Create:
				num = 1;
				break;
			case System.IO.FileMode.Open:
				num = 2;
				break;
			case System.IO.FileMode.OpenOrCreate:
				num = 3;
				break;
			case System.IO.FileMode.Truncate:
				num = 4;
				break;
			case System.IO.FileMode.Append:
				num = 5;
				break;
			}
			switch (access)
			{
			case FileAccess.Read:
				num2 = 0;
				break;
			case FileAccess.Write:
				num2 = 1;
				break;
			case FileAccess.ReadWrite:
				num2 = 2;
				break;
			}
			if (num == -1)
			{
				throw new ArgumentOutOfRangeException("mode");
			}
			if (num2 == -1)
			{
				throw new ArgumentOutOfRangeException("access");
			}
			string text = fopen_modes[num][num2];
			if (text[0] != 'r' && text[0] != 'w' && text[0] != 'a')
			{
				throw new ArgumentException(text);
			}
			return text;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromStatvfs")]
		private static extern int FromStatvfs(ref Statvfs source, IntPtr destination);

		public static bool TryCopy(ref Statvfs source, IntPtr destination)
		{
			return FromStatvfs(ref source, destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToStatvfs")]
		private static extern int ToStatvfs(IntPtr source, out Statvfs destination);

		public static bool TryCopy(IntPtr source, out Statvfs destination)
		{
			return ToStatvfs(source, out destination) == 0;
		}

		private static void ThrowArgumentException(object value)
		{
			throw new ArgumentOutOfRangeException("value", value, global::Locale.GetText("Current platform doesn't support this value."));
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromAccessModes")]
		private static extern int FromAccessModes(AccessModes value, out int rval);

		public static bool TryFromAccessModes(AccessModes value, out int rval)
		{
			return FromAccessModes(value, out rval) == 0;
		}

		public static int FromAccessModes(AccessModes value)
		{
			if (FromAccessModes(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToAccessModes")]
		private static extern int ToAccessModes(int value, out AccessModes rval);

		public static bool TryToAccessModes(int value, out AccessModes rval)
		{
			return ToAccessModes(value, out rval) == 0;
		}

		public static AccessModes ToAccessModes(int value)
		{
			if (ToAccessModes(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromConfstrName")]
		private static extern int FromConfstrName(ConfstrName value, out int rval);

		public static bool TryFromConfstrName(ConfstrName value, out int rval)
		{
			return FromConfstrName(value, out rval) == 0;
		}

		public static int FromConfstrName(ConfstrName value)
		{
			if (FromConfstrName(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToConfstrName")]
		private static extern int ToConfstrName(int value, out ConfstrName rval);

		public static bool TryToConfstrName(int value, out ConfstrName rval)
		{
			return ToConfstrName(value, out rval) == 0;
		}

		public static ConfstrName ToConfstrName(int value)
		{
			if (ToConfstrName(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromDirectoryNotifyFlags")]
		private static extern int FromDirectoryNotifyFlags(DirectoryNotifyFlags value, out int rval);

		public static bool TryFromDirectoryNotifyFlags(DirectoryNotifyFlags value, out int rval)
		{
			return FromDirectoryNotifyFlags(value, out rval) == 0;
		}

		public static int FromDirectoryNotifyFlags(DirectoryNotifyFlags value)
		{
			if (FromDirectoryNotifyFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToDirectoryNotifyFlags")]
		private static extern int ToDirectoryNotifyFlags(int value, out DirectoryNotifyFlags rval);

		public static bool TryToDirectoryNotifyFlags(int value, out DirectoryNotifyFlags rval)
		{
			return ToDirectoryNotifyFlags(value, out rval) == 0;
		}

		public static DirectoryNotifyFlags ToDirectoryNotifyFlags(int value)
		{
			if (ToDirectoryNotifyFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromErrno")]
		private static extern int FromErrno(Errno value, out int rval);

		public static bool TryFromErrno(Errno value, out int rval)
		{
			return FromErrno(value, out rval) == 0;
		}

		public static int FromErrno(Errno value)
		{
			if (FromErrno(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToErrno")]
		private static extern int ToErrno(int value, out Errno rval);

		public static bool TryToErrno(int value, out Errno rval)
		{
			return ToErrno(value, out rval) == 0;
		}

		public static Errno ToErrno(int value)
		{
			if (ToErrno(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromFcntlCommand")]
		private static extern int FromFcntlCommand(FcntlCommand value, out int rval);

		public static bool TryFromFcntlCommand(FcntlCommand value, out int rval)
		{
			return FromFcntlCommand(value, out rval) == 0;
		}

		public static int FromFcntlCommand(FcntlCommand value)
		{
			if (FromFcntlCommand(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToFcntlCommand")]
		private static extern int ToFcntlCommand(int value, out FcntlCommand rval);

		public static bool TryToFcntlCommand(int value, out FcntlCommand rval)
		{
			return ToFcntlCommand(value, out rval) == 0;
		}

		public static FcntlCommand ToFcntlCommand(int value)
		{
			if (ToFcntlCommand(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromFilePermissions")]
		private static extern int FromFilePermissions(FilePermissions value, out uint rval);

		public static bool TryFromFilePermissions(FilePermissions value, out uint rval)
		{
			return FromFilePermissions(value, out rval) == 0;
		}

		public static uint FromFilePermissions(FilePermissions value)
		{
			if (FromFilePermissions(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToFilePermissions")]
		private static extern int ToFilePermissions(uint value, out FilePermissions rval);

		public static bool TryToFilePermissions(uint value, out FilePermissions rval)
		{
			return ToFilePermissions(value, out rval) == 0;
		}

		public static FilePermissions ToFilePermissions(uint value)
		{
			if (ToFilePermissions(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromFlock")]
		private static extern int FromFlock(ref Flock source, IntPtr destination);

		public static bool TryCopy(ref Flock source, IntPtr destination)
		{
			return FromFlock(ref source, destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToFlock")]
		private static extern int ToFlock(IntPtr source, out Flock destination);

		public static bool TryCopy(IntPtr source, out Flock destination)
		{
			return ToFlock(source, out destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromLockType")]
		private static extern int FromLockType(LockType value, out short rval);

		public static bool TryFromLockType(LockType value, out short rval)
		{
			return FromLockType(value, out rval) == 0;
		}

		public static short FromLockType(LockType value)
		{
			if (FromLockType(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToLockType")]
		private static extern int ToLockType(short value, out LockType rval);

		public static bool TryToLockType(short value, out LockType rval)
		{
			return ToLockType(value, out rval) == 0;
		}

		public static LockType ToLockType(short value)
		{
			if (ToLockType(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromLockfCommand")]
		private static extern int FromLockfCommand(LockfCommand value, out int rval);

		public static bool TryFromLockfCommand(LockfCommand value, out int rval)
		{
			return FromLockfCommand(value, out rval) == 0;
		}

		public static int FromLockfCommand(LockfCommand value)
		{
			if (FromLockfCommand(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToLockfCommand")]
		private static extern int ToLockfCommand(int value, out LockfCommand rval);

		public static bool TryToLockfCommand(int value, out LockfCommand rval)
		{
			return ToLockfCommand(value, out rval) == 0;
		}

		public static LockfCommand ToLockfCommand(int value)
		{
			if (ToLockfCommand(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromMlockallFlags")]
		private static extern int FromMlockallFlags(MlockallFlags value, out int rval);

		public static bool TryFromMlockallFlags(MlockallFlags value, out int rval)
		{
			return FromMlockallFlags(value, out rval) == 0;
		}

		public static int FromMlockallFlags(MlockallFlags value)
		{
			if (FromMlockallFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToMlockallFlags")]
		private static extern int ToMlockallFlags(int value, out MlockallFlags rval);

		public static bool TryToMlockallFlags(int value, out MlockallFlags rval)
		{
			return ToMlockallFlags(value, out rval) == 0;
		}

		public static MlockallFlags ToMlockallFlags(int value)
		{
			if (ToMlockallFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromMmapFlags")]
		private static extern int FromMmapFlags(MmapFlags value, out int rval);

		public static bool TryFromMmapFlags(MmapFlags value, out int rval)
		{
			return FromMmapFlags(value, out rval) == 0;
		}

		public static int FromMmapFlags(MmapFlags value)
		{
			if (FromMmapFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToMmapFlags")]
		private static extern int ToMmapFlags(int value, out MmapFlags rval);

		public static bool TryToMmapFlags(int value, out MmapFlags rval)
		{
			return ToMmapFlags(value, out rval) == 0;
		}

		public static MmapFlags ToMmapFlags(int value)
		{
			if (ToMmapFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromMmapProts")]
		private static extern int FromMmapProts(MmapProts value, out int rval);

		public static bool TryFromMmapProts(MmapProts value, out int rval)
		{
			return FromMmapProts(value, out rval) == 0;
		}

		public static int FromMmapProts(MmapProts value)
		{
			if (FromMmapProts(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToMmapProts")]
		private static extern int ToMmapProts(int value, out MmapProts rval);

		public static bool TryToMmapProts(int value, out MmapProts rval)
		{
			return ToMmapProts(value, out rval) == 0;
		}

		public static MmapProts ToMmapProts(int value)
		{
			if (ToMmapProts(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromMountFlags")]
		private static extern int FromMountFlags(MountFlags value, out ulong rval);

		public static bool TryFromMountFlags(MountFlags value, out ulong rval)
		{
			return FromMountFlags(value, out rval) == 0;
		}

		public static ulong FromMountFlags(MountFlags value)
		{
			if (FromMountFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToMountFlags")]
		private static extern int ToMountFlags(ulong value, out MountFlags rval);

		public static bool TryToMountFlags(ulong value, out MountFlags rval)
		{
			return ToMountFlags(value, out rval) == 0;
		}

		public static MountFlags ToMountFlags(ulong value)
		{
			if (ToMountFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromMremapFlags")]
		private static extern int FromMremapFlags(MremapFlags value, out ulong rval);

		public static bool TryFromMremapFlags(MremapFlags value, out ulong rval)
		{
			return FromMremapFlags(value, out rval) == 0;
		}

		public static ulong FromMremapFlags(MremapFlags value)
		{
			if (FromMremapFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToMremapFlags")]
		private static extern int ToMremapFlags(ulong value, out MremapFlags rval);

		public static bool TryToMremapFlags(ulong value, out MremapFlags rval)
		{
			return ToMremapFlags(value, out rval) == 0;
		}

		public static MremapFlags ToMremapFlags(ulong value)
		{
			if (ToMremapFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromMsyncFlags")]
		private static extern int FromMsyncFlags(MsyncFlags value, out int rval);

		public static bool TryFromMsyncFlags(MsyncFlags value, out int rval)
		{
			return FromMsyncFlags(value, out rval) == 0;
		}

		public static int FromMsyncFlags(MsyncFlags value)
		{
			if (FromMsyncFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToMsyncFlags")]
		private static extern int ToMsyncFlags(int value, out MsyncFlags rval);

		public static bool TryToMsyncFlags(int value, out MsyncFlags rval)
		{
			return ToMsyncFlags(value, out rval) == 0;
		}

		public static MsyncFlags ToMsyncFlags(int value)
		{
			if (ToMsyncFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromOpenFlags")]
		private static extern int FromOpenFlags(OpenFlags value, out int rval);

		public static bool TryFromOpenFlags(OpenFlags value, out int rval)
		{
			return FromOpenFlags(value, out rval) == 0;
		}

		public static int FromOpenFlags(OpenFlags value)
		{
			if (FromOpenFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToOpenFlags")]
		private static extern int ToOpenFlags(int value, out OpenFlags rval);

		public static bool TryToOpenFlags(int value, out OpenFlags rval)
		{
			return ToOpenFlags(value, out rval) == 0;
		}

		public static OpenFlags ToOpenFlags(int value)
		{
			if (ToOpenFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromPathconfName")]
		private static extern int FromPathconfName(PathconfName value, out int rval);

		public static bool TryFromPathconfName(PathconfName value, out int rval)
		{
			return FromPathconfName(value, out rval) == 0;
		}

		public static int FromPathconfName(PathconfName value)
		{
			if (FromPathconfName(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToPathconfName")]
		private static extern int ToPathconfName(int value, out PathconfName rval);

		public static bool TryToPathconfName(int value, out PathconfName rval)
		{
			return ToPathconfName(value, out rval) == 0;
		}

		public static PathconfName ToPathconfName(int value)
		{
			if (ToPathconfName(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromPollEvents")]
		private static extern int FromPollEvents(PollEvents value, out short rval);

		public static bool TryFromPollEvents(PollEvents value, out short rval)
		{
			return FromPollEvents(value, out rval) == 0;
		}

		public static short FromPollEvents(PollEvents value)
		{
			if (FromPollEvents(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToPollEvents")]
		private static extern int ToPollEvents(short value, out PollEvents rval);

		public static bool TryToPollEvents(short value, out PollEvents rval)
		{
			return ToPollEvents(value, out rval) == 0;
		}

		public static PollEvents ToPollEvents(short value)
		{
			if (ToPollEvents(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromPollfd")]
		private static extern int FromPollfd(ref Pollfd source, IntPtr destination);

		public static bool TryCopy(ref Pollfd source, IntPtr destination)
		{
			return FromPollfd(ref source, destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToPollfd")]
		private static extern int ToPollfd(IntPtr source, out Pollfd destination);

		public static bool TryCopy(IntPtr source, out Pollfd destination)
		{
			return ToPollfd(source, out destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromPosixFadviseAdvice")]
		private static extern int FromPosixFadviseAdvice(PosixFadviseAdvice value, out int rval);

		public static bool TryFromPosixFadviseAdvice(PosixFadviseAdvice value, out int rval)
		{
			return FromPosixFadviseAdvice(value, out rval) == 0;
		}

		public static int FromPosixFadviseAdvice(PosixFadviseAdvice value)
		{
			if (FromPosixFadviseAdvice(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToPosixFadviseAdvice")]
		private static extern int ToPosixFadviseAdvice(int value, out PosixFadviseAdvice rval);

		public static bool TryToPosixFadviseAdvice(int value, out PosixFadviseAdvice rval)
		{
			return ToPosixFadviseAdvice(value, out rval) == 0;
		}

		public static PosixFadviseAdvice ToPosixFadviseAdvice(int value)
		{
			if (ToPosixFadviseAdvice(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromPosixMadviseAdvice")]
		private static extern int FromPosixMadviseAdvice(PosixMadviseAdvice value, out int rval);

		public static bool TryFromPosixMadviseAdvice(PosixMadviseAdvice value, out int rval)
		{
			return FromPosixMadviseAdvice(value, out rval) == 0;
		}

		public static int FromPosixMadviseAdvice(PosixMadviseAdvice value)
		{
			if (FromPosixMadviseAdvice(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToPosixMadviseAdvice")]
		private static extern int ToPosixMadviseAdvice(int value, out PosixMadviseAdvice rval);

		public static bool TryToPosixMadviseAdvice(int value, out PosixMadviseAdvice rval)
		{
			return ToPosixMadviseAdvice(value, out rval) == 0;
		}

		public static PosixMadviseAdvice ToPosixMadviseAdvice(int value)
		{
			if (ToPosixMadviseAdvice(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromSeekFlags")]
		private static extern int FromSeekFlags(SeekFlags value, out short rval);

		public static bool TryFromSeekFlags(SeekFlags value, out short rval)
		{
			return FromSeekFlags(value, out rval) == 0;
		}

		public static short FromSeekFlags(SeekFlags value)
		{
			if (FromSeekFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToSeekFlags")]
		private static extern int ToSeekFlags(short value, out SeekFlags rval);

		public static bool TryToSeekFlags(short value, out SeekFlags rval)
		{
			return ToSeekFlags(value, out rval) == 0;
		}

		public static SeekFlags ToSeekFlags(short value)
		{
			if (ToSeekFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromSignum")]
		private static extern int FromSignum(Signum value, out int rval);

		public static bool TryFromSignum(Signum value, out int rval)
		{
			return FromSignum(value, out rval) == 0;
		}

		public static int FromSignum(Signum value)
		{
			if (FromSignum(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToSignum")]
		private static extern int ToSignum(int value, out Signum rval);

		public static bool TryToSignum(int value, out Signum rval)
		{
			return ToSignum(value, out rval) == 0;
		}

		public static Signum ToSignum(int value)
		{
			if (ToSignum(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromStat")]
		private static extern int FromStat(ref Stat source, IntPtr destination);

		public static bool TryCopy(ref Stat source, IntPtr destination)
		{
			return FromStat(ref source, destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToStat")]
		private static extern int ToStat(IntPtr source, out Stat destination);

		public static bool TryCopy(IntPtr source, out Stat destination)
		{
			return ToStat(source, out destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromSysconfName")]
		private static extern int FromSysconfName(SysconfName value, out int rval);

		public static bool TryFromSysconfName(SysconfName value, out int rval)
		{
			return FromSysconfName(value, out rval) == 0;
		}

		public static int FromSysconfName(SysconfName value)
		{
			if (FromSysconfName(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToSysconfName")]
		private static extern int ToSysconfName(int value, out SysconfName rval);

		public static bool TryToSysconfName(int value, out SysconfName rval)
		{
			return ToSysconfName(value, out rval) == 0;
		}

		public static SysconfName ToSysconfName(int value)
		{
			if (ToSysconfName(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromSyslogFacility")]
		private static extern int FromSyslogFacility(SyslogFacility value, out int rval);

		public static bool TryFromSyslogFacility(SyslogFacility value, out int rval)
		{
			return FromSyslogFacility(value, out rval) == 0;
		}

		public static int FromSyslogFacility(SyslogFacility value)
		{
			if (FromSyslogFacility(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToSyslogFacility")]
		private static extern int ToSyslogFacility(int value, out SyslogFacility rval);

		public static bool TryToSyslogFacility(int value, out SyslogFacility rval)
		{
			return ToSyslogFacility(value, out rval) == 0;
		}

		public static SyslogFacility ToSyslogFacility(int value)
		{
			if (ToSyslogFacility(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromSyslogLevel")]
		private static extern int FromSyslogLevel(SyslogLevel value, out int rval);

		public static bool TryFromSyslogLevel(SyslogLevel value, out int rval)
		{
			return FromSyslogLevel(value, out rval) == 0;
		}

		public static int FromSyslogLevel(SyslogLevel value)
		{
			if (FromSyslogLevel(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToSyslogLevel")]
		private static extern int ToSyslogLevel(int value, out SyslogLevel rval);

		public static bool TryToSyslogLevel(int value, out SyslogLevel rval)
		{
			return ToSyslogLevel(value, out rval) == 0;
		}

		public static SyslogLevel ToSyslogLevel(int value)
		{
			if (ToSyslogLevel(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromSyslogOptions")]
		private static extern int FromSyslogOptions(SyslogOptions value, out int rval);

		public static bool TryFromSyslogOptions(SyslogOptions value, out int rval)
		{
			return FromSyslogOptions(value, out rval) == 0;
		}

		public static int FromSyslogOptions(SyslogOptions value)
		{
			if (FromSyslogOptions(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToSyslogOptions")]
		private static extern int ToSyslogOptions(int value, out SyslogOptions rval);

		public static bool TryToSyslogOptions(int value, out SyslogOptions rval)
		{
			return ToSyslogOptions(value, out rval) == 0;
		}

		public static SyslogOptions ToSyslogOptions(int value)
		{
			if (ToSyslogOptions(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromTimespec")]
		private static extern int FromTimespec(ref Timespec source, IntPtr destination);

		public static bool TryCopy(ref Timespec source, IntPtr destination)
		{
			return FromTimespec(ref source, destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToTimespec")]
		private static extern int ToTimespec(IntPtr source, out Timespec destination);

		public static bool TryCopy(IntPtr source, out Timespec destination)
		{
			return ToTimespec(source, out destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromTimeval")]
		private static extern int FromTimeval(ref Timeval source, IntPtr destination);

		public static bool TryCopy(ref Timeval source, IntPtr destination)
		{
			return FromTimeval(ref source, destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToTimeval")]
		private static extern int ToTimeval(IntPtr source, out Timeval destination);

		public static bool TryCopy(IntPtr source, out Timeval destination)
		{
			return ToTimeval(source, out destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromTimezone")]
		private static extern int FromTimezone(ref Timezone source, IntPtr destination);

		public static bool TryCopy(ref Timezone source, IntPtr destination)
		{
			return FromTimezone(ref source, destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToTimezone")]
		private static extern int ToTimezone(IntPtr source, out Timezone destination);

		public static bool TryCopy(IntPtr source, out Timezone destination)
		{
			return ToTimezone(source, out destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromUtimbuf")]
		private static extern int FromUtimbuf(ref Utimbuf source, IntPtr destination);

		public static bool TryCopy(ref Utimbuf source, IntPtr destination)
		{
			return FromUtimbuf(ref source, destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToUtimbuf")]
		private static extern int ToUtimbuf(IntPtr source, out Utimbuf destination);

		public static bool TryCopy(IntPtr source, out Utimbuf destination)
		{
			return ToUtimbuf(source, out destination) == 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromWaitOptions")]
		private static extern int FromWaitOptions(WaitOptions value, out int rval);

		public static bool TryFromWaitOptions(WaitOptions value, out int rval)
		{
			return FromWaitOptions(value, out rval) == 0;
		}

		public static int FromWaitOptions(WaitOptions value)
		{
			if (FromWaitOptions(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToWaitOptions")]
		private static extern int ToWaitOptions(int value, out WaitOptions rval);

		public static bool TryToWaitOptions(int value, out WaitOptions rval)
		{
			return ToWaitOptions(value, out rval) == 0;
		}

		public static WaitOptions ToWaitOptions(int value)
		{
			if (ToWaitOptions(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_FromXattrFlags")]
		private static extern int FromXattrFlags(XattrFlags value, out int rval);

		public static bool TryFromXattrFlags(XattrFlags value, out int rval)
		{
			return FromXattrFlags(value, out rval) == 0;
		}

		public static int FromXattrFlags(XattrFlags value)
		{
			if (FromXattrFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_ToXattrFlags")]
		private static extern int ToXattrFlags(int value, out XattrFlags rval);

		public static bool TryToXattrFlags(int value, out XattrFlags rval)
		{
			return ToXattrFlags(value, out rval) == 0;
		}

		public static XattrFlags ToXattrFlags(int value)
		{
			if (ToXattrFlags(value, out var rval) == -1)
			{
				ThrowArgumentException(value);
			}
			return rval;
		}
	}
	public struct RealTimeSignum : IEquatable<RealTimeSignum>
	{
		private int rt_offset;

		private static readonly int MaxOffset = UnixSignal.GetSIGRTMAX() - UnixSignal.GetSIGRTMIN() - 1;

		public static readonly RealTimeSignum MinValue = new RealTimeSignum(0);

		public static readonly RealTimeSignum MaxValue = new RealTimeSignum(MaxOffset);

		public int Offset => rt_offset;

		public RealTimeSignum(int offset)
		{
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("Offset cannot be negative");
			}
			if (offset > MaxOffset)
			{
				throw new ArgumentOutOfRangeException("Offset greater than maximum supported SIGRT");
			}
			rt_offset = offset;
		}

		public override int GetHashCode()
		{
			return rt_offset.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)obj.GetType() != GetType())
			{
				return false;
			}
			return Equals((RealTimeSignum)obj);
		}

		public bool Equals(RealTimeSignum value)
		{
			return Offset == value.Offset;
		}

		public static bool operator ==(RealTimeSignum lhs, RealTimeSignum rhs)
		{
			return lhs.Equals(rhs);
		}

		public static bool operator !=(RealTimeSignum lhs, RealTimeSignum rhs)
		{
			return !lhs.Equals(rhs);
		}
	}
	[Map]
	public enum Errno
	{
		EPERM = 1,
		ENOENT = 2,
		ESRCH = 3,
		EINTR = 4,
		EIO = 5,
		ENXIO = 6,
		E2BIG = 7,
		ENOEXEC = 8,
		EBADF = 9,
		ECHILD = 10,
		EAGAIN = 11,
		ENOMEM = 12,
		EACCES = 13,
		EFAULT = 14,
		ENOTBLK = 15,
		EBUSY = 16,
		EEXIST = 17,
		EXDEV = 18,
		ENODEV = 19,
		ENOTDIR = 20,
		EISDIR = 21,
		EINVAL = 22,
		ENFILE = 23,
		EMFILE = 24,
		ENOTTY = 25,
		ETXTBSY = 26,
		EFBIG = 27,
		ENOSPC = 28,
		ESPIPE = 29,
		EROFS = 30,
		EMLINK = 31,
		EPIPE = 32,
		EDOM = 33,
		ERANGE = 34,
		EDEADLK = 35,
		ENAMETOOLONG = 36,
		ENOLCK = 37,
		ENOSYS = 38,
		ENOTEMPTY = 39,
		ELOOP = 40,
		EWOULDBLOCK = 11,
		ENOMSG = 42,
		EIDRM = 43,
		ECHRNG = 44,
		EL2NSYNC = 45,
		EL3HLT = 46,
		EL3RST = 47,
		ELNRNG = 48,
		EUNATCH = 49,
		ENOCSI = 50,
		EL2HLT = 51,
		EBADE = 52,
		EBADR = 53,
		EXFULL = 54,
		ENOANO = 55,
		EBADRQC = 56,
		EBADSLT = 57,
		EDEADLOCK = 35,
		EBFONT = 59,
		ENOSTR = 60,
		ENODATA = 61,
		ETIME = 62,
		ENOSR = 63,
		ENONET = 64,
		ENOPKG = 65,
		EREMOTE = 66,
		ENOLINK = 67,
		EADV = 68,
		ESRMNT = 69,
		ECOMM = 70,
		EPROTO = 71,
		EMULTIHOP = 72,
		EDOTDOT = 73,
		EBADMSG = 74,
		EOVERFLOW = 75,
		ENOTUNIQ = 76,
		EBADFD = 77,
		EREMCHG = 78,
		ELIBACC = 79,
		ELIBBAD = 80,
		ELIBSCN = 81,
		ELIBMAX = 82,
		ELIBEXEC = 83,
		EILSEQ = 84,
		ERESTART = 85,
		ESTRPIPE = 86,
		EUSERS = 87,
		ENOTSOCK = 88,
		EDESTADDRREQ = 89,
		EMSGSIZE = 90,
		EPROTOTYPE = 91,
		ENOPROTOOPT = 92,
		EPROTONOSUPPORT = 93,
		ESOCKTNOSUPPORT = 94,
		EOPNOTSUPP = 95,
		EPFNOSUPPORT = 96,
		EAFNOSUPPORT = 97,
		EADDRINUSE = 98,
		EADDRNOTAVAIL = 99,
		ENETDOWN = 100,
		ENETUNREACH = 101,
		ENETRESET = 102,
		ECONNABORTED = 103,
		ECONNRESET = 104,
		ENOBUFS = 105,
		EISCONN = 106,
		ENOTCONN = 107,
		ESHUTDOWN = 108,
		ETOOMANYREFS = 109,
		ETIMEDOUT = 110,
		ECONNREFUSED = 111,
		EHOSTDOWN = 112,
		EHOSTUNREACH = 113,
		EALREADY = 114,
		EINPROGRESS = 115,
		ESTALE = 116,
		EUCLEAN = 117,
		ENOTNAM = 118,
		ENAVAIL = 119,
		EISNAM = 120,
		EREMOTEIO = 121,
		EDQUOT = 122,
		ENOMEDIUM = 123,
		EMEDIUMTYPE = 124
	}
	public sealed class FilePosition : MarshalByRefObject, IEquatable<FilePosition>, IDisposable
	{
		private static readonly int FilePositionDumpSize = Stdlib.DumpFilePosition(null, new HandleRef(null, IntPtr.Zero), 0);

		private HandleRef pos;

		internal HandleRef Handle => pos;

		public FilePosition()
		{
			IntPtr intPtr = Stdlib.CreateFilePosition();
			if (intPtr == IntPtr.Zero)
			{
				throw new OutOfMemoryException("Unable to malloc fpos_t!");
			}
			pos = new HandleRef(this, intPtr);
		}

		public void Dispose()
		{
			Cleanup();
			GC.SuppressFinalize(this);
		}

		private void Cleanup()
		{
			if (pos.Handle != IntPtr.Zero)
			{
				Stdlib.free(pos.Handle);
				pos = new HandleRef(this, IntPtr.Zero);
			}
		}

		public override string ToString()
		{
			return "(" + base.ToString() + " " + GetDump() + ")";
		}

		private string GetDump()
		{
			if (FilePositionDumpSize <= 0)
			{
				return "internal error";
			}
			StringBuilder stringBuilder = new StringBuilder(FilePositionDumpSize + 1);
			if (Stdlib.DumpFilePosition(stringBuilder, Handle, FilePositionDumpSize + 1) <= 0)
			{
				return "internal error dumping fpos_t";
			}
			return stringBuilder.ToString();
		}

		public override bool Equals(object obj)
		{
			FilePosition filePosition = obj as FilePosition;
			if (obj == null || filePosition == null)
			{
				return false;
			}
			return ToString().Equals(obj.ToString());
		}

		public bool Equals(FilePosition value)
		{
			if (object.ReferenceEquals(this, value))
			{
				return true;
			}
			return ToString().Equals(value.ToString());
		}

		public override int GetHashCode()
		{
			return ToString().GetHashCode();
		}

		~FilePosition()
		{
			Cleanup();
		}

		public static bool operator ==(FilePosition lhs, FilePosition rhs)
		{
			return object.Equals(lhs, rhs);
		}

		public static bool operator !=(FilePosition lhs, FilePosition rhs)
		{
			return !object.Equals(lhs, rhs);
		}
	}
	public enum SignalAction
	{
		Default,
		Ignore,
		Error
	}
	internal class XPrintfFunctions
	{
		internal delegate object XPrintf(object[] parameters);

		internal static XPrintf printf;

		internal static XPrintf fprintf;

		internal static XPrintf snprintf;

		internal static XPrintf syslog;

		static XPrintfFunctions()
		{
			CdeclFunction cdeclFunction = new CdeclFunction("msvcrt", "printf", typeof(int));
			printf = cdeclFunction.Invoke;
			CdeclFunction cdeclFunction2 = new CdeclFunction("msvcrt", "fprintf", typeof(int));
			fprintf = cdeclFunction2.Invoke;
			CdeclFunction cdeclFunction3 = new CdeclFunction("MonoPosixHelper", "Mono_Posix_Stdlib_snprintf", typeof(int));
			snprintf = cdeclFunction3.Invoke;
			CdeclFunction cdeclFunction4 = new CdeclFunction("MonoPosixHelper", "Mono_Posix_Stdlib_syslog2", typeof(int));
			syslog = cdeclFunction4.Invoke;
		}
	}
	public class Stdlib
	{
		internal const string LIBC = "msvcrt";

		internal const string MPH = "MonoPosixHelper";

		private static readonly IntPtr _SIG_DFL;

		private static readonly IntPtr _SIG_ERR;

		private static readonly IntPtr _SIG_IGN;

		[CLSCompliant(false)]
		public static readonly SignalHandler SIG_DFL;

		[CLSCompliant(false)]
		public static readonly SignalHandler SIG_ERR;

		[CLSCompliant(false)]
		public static readonly SignalHandler SIG_IGN;

		private static readonly SignalHandler[] registered_signals;

		[CLSCompliant(false)]
		public static readonly int _IOFBF;

		[CLSCompliant(false)]
		public static readonly int _IOLBF;

		[CLSCompliant(false)]
		public static readonly int _IONBF;

		[CLSCompliant(false)]
		public static readonly int BUFSIZ;

		[CLSCompliant(false)]
		public static readonly int EOF;

		[CLSCompliant(false)]
		public static readonly int FOPEN_MAX;

		[CLSCompliant(false)]
		public static readonly int FILENAME_MAX;

		[CLSCompliant(false)]
		public static readonly int L_tmpnam;

		public static readonly IntPtr stderr;

		public static readonly IntPtr stdin;

		public static readonly IntPtr stdout;

		[CLSCompliant(false)]
		public static readonly int TMP_MAX;

		private static object tmpnam_lock;

		[CLSCompliant(false)]
		public static readonly int EXIT_FAILURE;

		[CLSCompliant(false)]
		public static readonly int EXIT_SUCCESS;

		[CLSCompliant(false)]
		public static readonly int MB_CUR_MAX;

		[CLSCompliant(false)]
		public static readonly int RAND_MAX;

		private static object strerror_lock;

		internal Stdlib()
		{
		}

		static Stdlib()
		{
			_SIG_DFL = GetDefaultSignal();
			_SIG_ERR = GetErrorSignal();
			_SIG_IGN = GetIgnoreSignal();
			SIG_DFL = _DefaultHandler;
			SIG_ERR = _ErrorHandler;
			SIG_IGN = _IgnoreHandler;
			_IOFBF = GetFullyBuffered();
			_IOLBF = GetLineBuffered();
			_IONBF = GetNonBuffered();
			BUFSIZ = GetBufferSize();
			EOF = GetEOF();
			FOPEN_MAX = GetFopenMax();
			FILENAME_MAX = GetFilenameMax();
			L_tmpnam = GetTmpnamLength();
			stderr = GetStandardError();
			stdin = GetStandardInput();
			stdout = GetStandardOutput();
			TMP_MAX = GetTmpMax();
			tmpnam_lock = new object();
			EXIT_FAILURE = GetExitFailure();
			EXIT_SUCCESS = GetExitSuccess();
			MB_CUR_MAX = GetMbCurMax();
			RAND_MAX = GetRandMax();
			strerror_lock = new object();
			Array values = Enum.GetValues(typeof(Signum));
			registered_signals = new SignalHandler[(int)values.GetValue(values.Length - 1)];
		}

		public static Errno GetLastError()
		{
			int lastWin32Error = Marshal.GetLastWin32Error();
			return NativeConvert.ToErrno(lastWin32Error);
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_SetLastError")]
		private static extern void SetLastError(int error);

		protected static void SetLastError(Errno error)
		{
			int lastError = NativeConvert.FromErrno(error);
			SetLastError(lastError);
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_InvokeSignalHandler")]
		internal static extern void InvokeSignalHandler(int signum, IntPtr handler);

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_SIG_DFL")]
		private static extern IntPtr GetDefaultSignal();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_SIG_ERR")]
		private static extern IntPtr GetErrorSignal();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_SIG_IGN")]
		private static extern IntPtr GetIgnoreSignal();

		private static void _ErrorHandler(int signum)
		{
			Console.Error.WriteLine("Error handler invoked for signum " + signum + ".  Don't do that.");
		}

		private static void _DefaultHandler(int signum)
		{
			Console.Error.WriteLine("Default handler invoked for signum " + signum + ".  Don't do that.");
		}

		private static void _IgnoreHandler(int signum)
		{
			Console.Error.WriteLine("Ignore handler invoked for signum " + signum + ".  Don't do that.");
		}

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "signal", SetLastError = true)]
		private static extern IntPtr sys_signal(int signum, SignalHandler handler);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "signal", SetLastError = true)]
		private static extern IntPtr sys_signal(int signum, IntPtr handler);

		[Obsolete("This is not safe; use Mono.Unix.UnixSignal for signal delivery or SetSignalAction()")]
		[CLSCompliant(false)]
		public static SignalHandler signal(Signum signum, SignalHandler handler)
		{
			int signum2 = NativeConvert.FromSignum(signum);
			Delegate[] invocationList = handler.GetInvocationList();
			for (int i = 0; i < invocationList.Length; i++)
			{
				Marshal.Prelink(invocationList[i].Method);
			}
			lock (registered_signals)
			{
				registered_signals[(int)signum] = handler;
			}
			IntPtr handler2 = ((handler == SIG_DFL) ? sys_signal(signum2, _SIG_DFL) : ((handler == SIG_ERR) ? sys_signal(signum2, _SIG_ERR) : ((!(handler == SIG_IGN)) ? sys_signal(signum2, handler) : sys_signal(signum2, _SIG_IGN))));
			return TranslateHandler(handler2);
		}

		private static SignalHandler TranslateHandler(IntPtr handler)
		{
			if (handler == _SIG_DFL)
			{
				return SIG_DFL;
			}
			if (handler == _SIG_ERR)
			{
				return SIG_ERR;
			}
			if (handler == _SIG_IGN)
			{
				return SIG_IGN;
			}
			return (SignalHandler)Marshal.GetDelegateForFunctionPointer(handler, typeof(SignalHandler));
		}

		public static int SetSignalAction(Signum signal, SignalAction action)
		{
			return SetSignalAction(NativeConvert.FromSignum(signal), action);
		}

		public static int SetSignalAction(RealTimeSignum rts, SignalAction action)
		{
			return SetSignalAction(NativeConvert.FromRealTimeSignum(rts), action);
		}

		private static int SetSignalAction(int signum, SignalAction action)
		{
			IntPtr zero = IntPtr.Zero;
			IntPtr intPtr = sys_signal(signum, action switch
			{
				SignalAction.Default => _SIG_DFL, 
				SignalAction.Ignore => _SIG_IGN, 
				SignalAction.Error => _SIG_ERR, 
				_ => throw new ArgumentException("Invalid action value.", "action"), 
			});
			if (intPtr == _SIG_ERR)
			{
				return -1;
			}
			return 0;
		}

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "raise")]
		private static extern int sys_raise(int sig);

		[CLSCompliant(false)]
		public static int raise(Signum sig)
		{
			return sys_raise(NativeConvert.FromSignum(sig));
		}

		public static int raise(RealTimeSignum rts)
		{
			return sys_raise(NativeConvert.FromRealTimeSignum(rts));
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib__IOFBF")]
		private static extern int GetFullyBuffered();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib__IOLBF")]
		private static extern int GetLineBuffered();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib__IONBF")]
		private static extern int GetNonBuffered();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_BUFSIZ")]
		private static extern int GetBufferSize();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_CreateFilePosition")]
		internal static extern IntPtr CreateFilePosition();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_DumpFilePosition")]
		internal static extern int DumpFilePosition(StringBuilder buf, HandleRef handle, int len);

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_EOF")]
		private static extern int GetEOF();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_FILENAME_MAX")]
		private static extern int GetFilenameMax();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_FOPEN_MAX")]
		private static extern int GetFopenMax();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_L_tmpnam")]
		private static extern int GetTmpnamLength();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_stdin")]
		private static extern IntPtr GetStandardInput();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_stdout")]
		private static extern IntPtr GetStandardOutput();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_stderr")]
		private static extern IntPtr GetStandardError();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_TMP_MAX")]
		private static extern int GetTmpMax();

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern int remove([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string filename);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern int rename([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string oldpath, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string newpath);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern IntPtr tmpfile();

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "tmpnam", SetLastError = true)]
		private static extern IntPtr sys_tmpnam(StringBuilder s);

		[Obsolete("Syscall.mkstemp() should be preferred.")]
		public static string tmpnam(StringBuilder s)
		{
			if (s != null && s.Capacity < L_tmpnam)
			{
				throw new ArgumentOutOfRangeException("s", "s.Capacity < L_tmpnam");
			}
			lock (tmpnam_lock)
			{
				IntPtr p = sys_tmpnam(s);
				return UnixMarshal.PtrToString(p);
			}
		}

		[Obsolete("Syscall.mkstemp() should be preferred.")]
		public static string tmpnam()
		{
			lock (tmpnam_lock)
			{
				IntPtr p = sys_tmpnam(null);
				return UnixMarshal.PtrToString(p);
			}
		}

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern int fclose(IntPtr stream);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern int fflush(IntPtr stream);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern IntPtr fopen([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, string mode);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern IntPtr freopen([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, string mode, IntPtr stream);

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_setbuf", SetLastError = true)]
		public static extern int setbuf(IntPtr stream, IntPtr buf);

		[CLSCompliant(false)]
		public unsafe static int setbuf(IntPtr stream, byte* buf)
		{
			return setbuf(stream, (IntPtr)buf);
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_setvbuf", SetLastError = true)]
		[CLSCompliant(false)]
		public static extern int setvbuf(IntPtr stream, IntPtr buf, int mode, ulong size);

		[CLSCompliant(false)]
		public unsafe static int setvbuf(IntPtr stream, byte* buf, int mode, ulong size)
		{
			return setvbuf(stream, (IntPtr)buf, mode, size);
		}

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fprintf")]
		private static extern int sys_fprintf(IntPtr stream, string format, string message);

		public static int fprintf(IntPtr stream, string message)
		{
			return sys_fprintf(stream, "%s", message);
		}

		[Obsolete("Not necessarily portable due to cdecl restrictions.\nUse fprintf (IntPtr, string) instead.")]
		public static int fprintf(IntPtr stream, string format, params object[] parameters)
		{
			object[] array = new object[checked(parameters.Length + 2)];
			array[0] = stream;
			array[1] = format;
			Array.Copy(parameters, 0, array, 2, parameters.Length);
			return (int)XPrintfFunctions.fprintf(array);
		}

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "printf")]
		private static extern int sys_printf(string format, string message);

		public static int printf(string message)
		{
			return sys_printf("%s", message);
		}

		[Obsolete("Not necessarily portable due to cdecl restrictions.\nUse printf (string) instead.")]
		public static int printf(string format, params object[] parameters)
		{
			object[] array = new object[checked(parameters.Length + 1)];
			array[0] = format;
			Array.Copy(parameters, 0, array, 1, parameters.Length);
			return (int)XPrintfFunctions.printf(array);
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_snprintf")]
		private static extern int sys_snprintf(StringBuilder s, ulong n, string format, string message);

		[CLSCompliant(false)]
		public static int snprintf(StringBuilder s, ulong n, string message)
		{
			if (n > (ulong)s.Capacity)
			{
				throw new ArgumentOutOfRangeException("n", "n must be <= s.Capacity");
			}
			return sys_snprintf(s, n, "%s", message);
		}

		public static int snprintf(StringBuilder s, string message)
		{
			return sys_snprintf(s, (ulong)s.Capacity, "%s", message);
		}

		[Obsolete("Not necessarily portable due to cdecl restrictions.\nUse snprintf (StringBuilder, string) instead.")]
		[CLSCompliant(false)]
		public static int snprintf(StringBuilder s, ulong n, string format, params object[] parameters)
		{
			if (n > (ulong)s.Capacity)
			{
				throw new ArgumentOutOfRangeException("n", "n must be <= s.Capacity");
			}
			object[] array = new object[checked(parameters.Length + 3)];
			array[0] = s;
			array[1] = n;
			array[2] = format;
			Array.Copy(parameters, 0, array, 3, parameters.Length);
			return (int)XPrintfFunctions.snprintf(array);
		}

		[CLSCompliant(false)]
		[Obsolete("Not necessarily portable due to cdecl restrictions.\nUse snprintf (StringBuilder, string) instead.")]
		public static int snprintf(StringBuilder s, string format, params object[] parameters)
		{
			object[] array = new object[checked(parameters.Length + 3)];
			array[0] = s;
			array[1] = (ulong)s.Capacity;
			array[2] = format;
			Array.Copy(parameters, 0, array, 3, parameters.Length);
			return (int)XPrintfFunctions.snprintf(array);
		}

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern int fgetc(IntPtr stream);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "fgets", SetLastError = true)]
		private static extern IntPtr sys_fgets(StringBuilder sb, int size, IntPtr stream);

		public static StringBuilder fgets(StringBuilder sb, int size, IntPtr stream)
		{
			IntPtr intPtr = sys_fgets(sb, size, stream);
			if (intPtr == IntPtr.Zero)
			{
				return null;
			}
			return sb;
		}

		public static StringBuilder fgets(StringBuilder sb, IntPtr stream)
		{
			return fgets(sb, sb.Capacity, stream);
		}

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern int fputc(int c, IntPtr stream);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern int fputs(string s, IntPtr stream);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern int getc(IntPtr stream);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern int getchar();

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern int putc(int c, IntPtr stream);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern int putchar(int c);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern int puts(string s);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		public static extern int ungetc(int c, IntPtr stream);

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_fread", SetLastError = true)]
		[CLSCompliant(false)]
		public static extern ulong fread(IntPtr ptr, ulong size, ulong nmemb, IntPtr stream);

		[CLSCompliant(false)]
		public unsafe static ulong fread(void* ptr, ulong size, ulong nmemb, IntPtr stream)
		{
			return fread((IntPtr)ptr, size, nmemb, stream);
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_fread", SetLastError = true)]
		private static extern ulong sys_fread([Out] byte[] ptr, ulong size, ulong nmemb, IntPtr stream);

		[CLSCompliant(false)]
		public static ulong fread(byte[] ptr, ulong size, ulong nmemb, IntPtr stream)
		{
			if (size * nmemb > (ulong)ptr.Length)
			{
				throw new ArgumentOutOfRangeException("nmemb");
			}
			return sys_fread(ptr, size, nmemb, stream);
		}

		[CLSCompliant(false)]
		public static ulong fread(byte[] ptr, IntPtr stream)
		{
			return fread(ptr, 1uL, (ulong)ptr.Length, stream);
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_fwrite", SetLastError = true)]
		[CLSCompliant(false)]
		public static extern ulong fwrite(IntPtr ptr, ulong size, ulong nmemb, IntPtr stream);

		[CLSCompliant(false)]
		public unsafe static ulong fwrite(void* ptr, ulong size, ulong nmemb, IntPtr stream)
		{
			return fwrite((IntPtr)ptr, size, nmemb, stream);
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_fwrite", SetLastError = true)]
		private static extern ulong sys_fwrite(byte[] ptr, ulong size, ulong nmemb, IntPtr stream);

		[CLSCompliant(false)]
		public static ulong fwrite(byte[] ptr, ulong size, ulong nmemb, IntPtr stream)
		{
			if (size * nmemb > (ulong)ptr.Length)
			{
				throw new ArgumentOutOfRangeException("nmemb");
			}
			return sys_fwrite(ptr, size, nmemb, stream);
		}

		[CLSCompliant(false)]
		public static ulong fwrite(byte[] ptr, IntPtr stream)
		{
			return fwrite(ptr, 1uL, (ulong)ptr.Length, stream);
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_fgetpos", SetLastError = true)]
		private static extern int sys_fgetpos(IntPtr stream, HandleRef pos);

		public static int fgetpos(IntPtr stream, FilePosition pos)
		{
			return sys_fgetpos(stream, pos.Handle);
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_fseek", SetLastError = true)]
		private static extern int sys_fseek(IntPtr stream, long offset, int origin);

		[CLSCompliant(false)]
		public static int fseek(IntPtr stream, long offset, SeekFlags origin)
		{
			int origin2 = NativeConvert.FromSeekFlags(origin);
			return sys_fseek(stream, offset, origin2);
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_fsetpos", SetLastError = true)]
		private static extern int sys_fsetpos(IntPtr stream, HandleRef pos);

		public static int fsetpos(IntPtr stream, FilePosition pos)
		{
			return sys_fsetpos(stream, pos.Handle);
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_ftell", SetLastError = true)]
		public static extern long ftell(IntPtr stream);

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_rewind", SetLastError = true)]
		public static extern int rewind(IntPtr stream);

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_clearerr", SetLastError = true)]
		public static extern int clearerr(IntPtr stream);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
		public static extern int feof(IntPtr stream);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
		public static extern int ferror(IntPtr stream);

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_perror", SetLastError = true)]
		private static extern int perror(string s, int err);

		public static int perror(string s)
		{
			return perror(s, Marshal.GetLastWin32Error());
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_EXIT_FAILURE")]
		private static extern int GetExitFailure();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_EXIT_SUCCESS")]
		private static extern int GetExitSuccess();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_MB_CUR_MAX")]
		private static extern int GetMbCurMax();

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_RAND_MAX")]
		private static extern int GetRandMax();

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
		public static extern int rand();

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
		[CLSCompliant(false)]
		public static extern void srand(uint seed);

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_calloc", SetLastError = true)]
		[CLSCompliant(false)]
		public static extern IntPtr calloc(ulong nmemb, ulong size);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
		public static extern void free(IntPtr ptr);

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_malloc", SetLastError = true)]
		[CLSCompliant(false)]
		public static extern IntPtr malloc(ulong size);

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_realloc", SetLastError = true)]
		[CLSCompliant(false)]
		public static extern IntPtr realloc(IntPtr ptr, ulong size);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
		public static extern void abort();

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
		public static extern void exit(int status);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl)]
		[CLSCompliant(false)]
		public static extern void _Exit(int status);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "getenv")]
		private static extern IntPtr sys_getenv(string name);

		public static string getenv(string name)
		{
			IntPtr p = sys_getenv(name);
			return UnixMarshal.PtrToString(p);
		}

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, SetLastError = true)]
		[CLSCompliant(false)]
		public static extern int system(string @string);

		[DllImport("msvcrt", CallingConvention = CallingConvention.Cdecl, EntryPoint = "strerror", SetLastError = true)]
		private static extern IntPtr sys_strerror(int errnum);

		[CLSCompliant(false)]
		public static string strerror(Errno errnum)
		{
			int errnum2 = NativeConvert.FromErrno(errnum);
			lock (strerror_lock)
			{
				IntPtr p = sys_strerror(errnum2);
				return UnixMarshal.PtrToString(p);
			}
		}

		[DllImport("MonoPosixHelper", CallingConvention = CallingConvention.Cdecl, EntryPoint = "Mono_Posix_Stdlib_strlen", SetLastError = true)]
		[CLSCompliant(false)]
		public static extern ulong strlen(IntPtr s);
	}
	[Map]
	[CLSCompliant(false)]
	[Flags]
	public enum SyslogOptions
	{
		LOG_PID = 1,
		LOG_CONS = 2,
		LOG_ODELAY = 4,
		LOG_NDELAY = 8,
		LOG_NOWAIT = 0x10,
		LOG_PERROR = 0x20
	}
	[CLSCompliant(false)]
	[Map]
	public enum SyslogFacility
	{
		LOG_KERN = 0,
		LOG_USER = 8,
		LOG_MAIL = 16,
		LOG_DAEMON = 24,
		LOG_AUTH = 32,
		LOG_SYSLOG = 40,
		LOG_LPR = 48,
		LOG_NEWS = 56,
		LOG_UUCP = 64,
		LOG_CRON = 72,
		LOG_AUTHPRIV = 80,
		LOG_FTP = 88,
		LOG_LOCAL0 = 128,
		LOG_LOCAL1 = 136,
		LOG_LOCAL2 = 144,
		LOG_LOCAL3 = 152,
		LOG_LOCAL4 = 160,
		LOG_LOCAL5 = 168,
		LOG_LOCAL6 = 176,
		LOG_LOCAL7 = 184
	}
	[Map]
	[CLSCompliant(false)]
	public enum SyslogLevel
	{
		LOG_EMERG,
		LOG_ALERT,
		LOG_CRIT,
		LOG_ERR,
		LOG_WARNING,
		LOG_NOTICE,
		LOG_INFO,
		LOG_DEBUG
	}
	[Map]
	[CLSCompliant(false)]
	[Flags]
	public enum OpenFlags
	{
		O_RDONLY = 0,
		O_WRONLY = 1,
		O_RDWR = 2,
		O_CREAT = 0x40,
		O_EXCL = 0x80,
		O_NOCTTY = 0x100,
		O_TRUNC = 0x200,
		O_APPEND = 0x400,
		O_NONBLOCK = 0x800,
		O_SYNC = 0x1000,
		O_NOFOLLOW = 0x20000,
		O_DIRECTORY = 0x10000,
		O_DIRECT = 0x4000,
		O_ASYNC = 0x2000,
		O_LARGEFILE = 0x8000
	}
	[CLSCompliant(false)]
	[Flags]
	[Map]
	public enum FilePermissions : uint
	{
		S_ISUID = 0x800u,
		S_ISGID = 0x400u,
		S_ISVTX = 0x200u,
		S_IRUSR = 0x100u,
		S_IWUSR = 0x80u,
		S_IXUSR = 0x40u,
		S_IRGRP = 0x20u,
		S_IWGRP = 0x10u,
		S_IXGRP = 8u,
		S_IROTH = 4u,
		S_IWOTH = 2u,
		S_IXOTH = 1u,
		S_IRWXG = 0x38u,
		S_IRWXU = 0x1C0u,
		S_IRWXO = 7u,
		ACCESSPERMS = 0x1FFu,
		ALLPERMS = 0xFFFu,
		DEFFILEMODE = 0x1B6u,
		S_IFMT = 0xF000u,
		[Map(SuppressFlags = "S_IFMT")]
		S_IFDIR = 0x4000u,
		[Map(SuppressFlags = "S_IFMT")]
		S_IFCHR = 0x2000u,
		[Map(SuppressFlags = "S_IFMT")]
		S_IFBLK = 0x6000u,
		[Map(SuppressFlags = "S_IFMT")]
		S_IFREG = 0x8000u,
		[Map(SuppressFlags = "S_IFMT")]
		S_IFIFO = 0x1000u,
		[Map(SuppressFlags = "S_IFMT")]
		S_IFLNK = 0xA000u,
		[Map(SuppressFlags = "S_IFMT")]
		S_IFSOCK = 0xC000u
	}
	[CLSCompliant(false)]
	[Map]
	public enum FcntlCommand
	{
		F_DUPFD = 0,
		F_GETFD = 1,
		F_SETFD = 2,
		F_GETFL = 3,
		F_SETFL = 4,
		F_GETLK = 12,
		F_SETLK = 13,
		F_SETLKW = 14,
		F_SETOWN = 8,
		F_GETOWN = 9,
		F_SETSIG = 10,
		F_GETSIG = 11,
		F_SETLEASE = 1024,
		F_GETLEASE = 1025,
		F_NOTIFY = 1026
	}
	[Map]
	[CLSCompliant(false)]
	public enum LockType : short
	{
		F_RDLCK,
		F_WRLCK,
		F_UNLCK
	}
	[CLSCompliant(false)]
	[Map]
	public enum SeekFlags : short
	{
		SEEK_SET = 0,
		SEEK_CUR = 1,
		SEEK_END = 2,
		L_SET = 0,
		L_INCR = 1,
		L_XTND = 2
	}
	[CLSCompliant(false)]
	[Flags]
	[Map]
	public enum DirectoryNotifyFlags
	{
		DN_ACCESS = 1,
		DN_MODIFY = 2,
		DN_CREATE = 4,
		DN_DELETE = 8,
		DN_RENAME = 0x10,
		DN_ATTRIB = 0x20,
		DN_MULTISHOT = int.MinValue
	}
	[Map]
	[CLSCompliant(false)]
	public enum PosixFadviseAdvice
	{
		POSIX_FADV_NORMAL,
		POSIX_FADV_RANDOM,
		POSIX_FADV_SEQUENTIAL,
		POSIX_FADV_WILLNEED,
		POSIX_FADV_DONTNEED,
		POSIX_FADV_NOREUSE
	}
	[CLSCompliant(false)]
	[Map]
	public enum PosixMadviseAdvice
	{
		POSIX_MADV_NORMAL,
		POSIX_MADV_RANDOM,
		POSIX_MADV_SEQUENTIAL,
		POSIX_MADV_WILLNEED,
		POSIX_MADV_DONTNEED
	}
	[Map]
	public enum Signum
	{
		SIGHUP = 1,
		SIGINT = 2,
		SIGQUIT = 3,
		SIGILL = 4,
		SIGTRAP = 5,
		SIGABRT = 6,
		SIGIOT = 6,
		SIGBUS = 7,
		SIGFPE = 8,
		SIGKILL = 9,
		SIGUSR1 = 10,
		SIGSEGV = 11,
		SIGUSR2 = 12,
		SIGPIPE = 13,
		SIGALRM = 14,
		SIGTERM = 15,
		SIGSTKFLT = 16,
		SIGCLD = 17,
		SIGCHLD = 17,
		SIGCONT = 18,
		SIGSTOP = 19,
		SIGTSTP = 20,
		SIGTTIN = 21,
		SIGTTOU = 22,
		SIGURG = 23,
		SIGXCPU = 24,
		SIGXFSZ = 25,
		SIGVTALRM = 26,
		SIGPROF = 27,
		SIGWINCH = 28,
		SIGPOLL = 29,
		SIGIO = 29,
		SIGPWR = 30,
		SIGSYS = 31,
		SIGUNUSED = 31
	}
	[Flags]
	[Map]
	public enum WaitOptions
	{
		WNOHANG = 1,
		WUNTRACED = 2
	}
	[CLSCompliant(false)]
	[Map]
	[Flags]
	public enum AccessModes
	{
		R_OK = 1,
		W_OK = 2,
		X_OK = 4,
		F_OK = 8
	}
	[Map]
	[CLSCompliant(false)]
	public enum PathconfName
	{
		_PC_LINK_MAX,
		_PC_MAX_CANON,
		_PC_MAX_INPUT,
		_PC_NAME_MAX,
		_PC_PATH_MAX,
		_PC_PIPE_BUF,
		_PC_CHOWN_RESTRICTED,
		_PC_NO_TRUNC,
		_PC_VDISABLE,
		_PC_SYNC_IO,
		_PC_ASYNC_IO,
		_PC_PRIO_IO,
		_PC_SOCK_MAXBUF,
		_PC_FILESIZEBITS,
		_PC_REC_INCR_XFER_SIZE,
		_PC_REC_MAX_XFER_SIZE,
		_PC_REC_MIN_XFER_SIZE,
		_PC_REC_XFER_ALIGN,
		_PC_ALLOC_SIZE_MIN,
		_PC_SYMLINK_MAX,
		_PC_2_SYMLINKS
	}
	[Map]
	[CLSCompliant(false)]
	public enum SysconfName
	{
		_SC_ARG_MAX = 0,
		_SC_CHILD_MAX = 1,
		_SC_CLK_TCK = 2,
		_SC_NGROUPS_MAX = 3,
		_SC_OPEN_MAX = 4,
		_SC_STREAM_MAX = 5,
		_SC_TZNAME_MAX = 6,
		_SC_JOB_CONTROL = 7,
		_SC_SAVED_IDS = 8,
		_SC_REALTIME_SIGNALS = 9,
		_SC_PRIORITY_SCHEDULING = 10,
		_SC_TIMERS = 11,
		_SC_ASYNCHRONOUS_IO = 12,
		_SC_PRIORITIZED_IO = 13,
		_SC_SYNCHRONIZED_IO = 14,
		_SC_FSYNC = 15,
		_SC_MAPPED_FILES = 16,
		_SC_MEMLOCK = 17,
		_SC_MEMLOCK_RANGE = 18,
		_SC_MEMORY_PROTECTION = 19,
		_SC_MESSAGE_PASSING = 20,
		_SC_SEMAPHORES = 21,
		_SC_SHARED_MEMORY_OBJECTS = 22,
		_SC_AIO_LISTIO_MAX = 23,
		_SC_AIO_MAX = 24,
		_SC_AIO_PRIO_DELTA_MAX = 25,
		_SC_DELAYTIMER_MAX = 26,
		_SC_MQ_OPEN_MAX = 27,
		_SC_MQ_PRIO_MAX = 28,
		_SC_VERSION = 29,
		_SC_PAGESIZE = 30,
		_SC_RTSIG_MAX = 31,
		_SC_SEM_NSEMS_MAX = 32,
		_SC_SEM_VALUE_MAX = 33,
		_SC_SIGQUEUE_MAX = 34,
		_SC_TIMER_MAX = 35,
		_SC_BC_BASE_MAX = 36,
		_SC_BC_DIM_MAX = 37,
		_SC_BC_SCALE_MAX = 38,
		_SC_BC_STRING_MAX = 39,
		_SC_COLL_WEIGHTS_MAX = 40,
		_SC_EQUIV_CLASS_MAX = 41,
		_SC_EXPR_NEST_MAX = 42,
		_SC_LINE_MAX = 43,
		_SC_RE_DUP_MAX = 44,
		_SC_CHARCLASS_NAME_MAX = 45,
		_SC_2_VERSION = 46,
		_SC_2_C_BIND = 47,
		_SC_2_C_DEV = 48,
		_SC_2_FORT_DEV = 49,
		_SC_2_FORT_RUN = 50,
		_SC_2_SW_DEV = 51,
		_SC_2_LOCALEDEF = 52,
		_SC_PII = 53,
		_SC_PII_XTI = 54,
		_SC_PII_SOCKET = 55,
		_SC_PII_INTERNET = 56,
		_SC_PII_OSI = 57,
		_SC_POLL = 58,
		_SC_SELECT = 59,
		_SC_UIO_MAXIOV = 60,
		_SC_IOV_MAX = 60,
		_SC_PII_INTERNET_STREAM = 61,
		_SC_PII_INTERNET_DGRAM = 62,
		_SC_PII_OSI_COTS = 63,
		_SC_PII_OSI_CLTS = 64,
		_SC_PII_OSI_M = 65,
		_SC_T_IOV_MAX = 66,
		_SC_THREADS = 67,
		_SC_THREAD_SAFE_FUNCTIONS = 68,
		_SC_GETGR_R_SIZE_MAX = 69,
		_SC_GETPW_R_SIZE_MAX = 70,
		_SC_LOGIN_NAME_MAX = 71,
		_SC_TTY_NAME_MAX = 72,
		_SC_THREAD_DESTRUCTOR_ITERATIONS = 73,
		_SC_THREAD_KEYS_MAX = 74,
		_SC_THREAD_STACK_MIN = 75,
		_SC_THREAD_THREADS_MAX = 76,
		_SC_THREAD_ATTR_STACKADDR = 77,
		_SC_THREAD_ATTR_STACKSIZE = 78,
		_SC_THREAD_PRIORITY_SCHEDULING = 79,
		_SC_THREAD_PRIO_INHERIT = 80,
		_SC_THREAD_PRIO_PROTECT = 81,
		_SC_THREAD_PROCESS_SHARED = 82,
		_SC_NPROCESSORS_CONF = 83,
		_SC_NPROCESSORS_ONLN = 84,
		_SC_PHYS_PAGES = 85,
		_SC_AVPHYS_PAGES = 86,
		_SC_ATEXIT_MAX = 87,
		_SC_PASS_MAX = 88,
		_SC_XOPEN_VERSION = 89,
		_SC_XOPEN_XCU_VERSION = 90,
		_SC_XOPEN_UNIX = 91,
		_SC_XOPEN_CRYPT = 92,
		_SC_XOPEN_ENH_I18N = 93,
		_SC_XOPEN_SHM = 94,
		_SC_2_CHAR_TERM = 95,
		_SC_2_C_VERSION = 96,
		_SC_2_UPE = 97,
		_SC_XOPEN_XPG2 = 98,
		_SC_XOPEN_XPG3 = 99,
		_SC_XOPEN_XPG4 = 100,
		_SC_CHAR_BIT = 101,
		_SC_CHAR_MAX = 102,
		_SC_CHAR_MIN = 103,
		_SC_INT_MAX = 104,
		_SC_INT_MIN = 105,
		_SC_LONG_BIT = 106,
		_SC_WORD_BIT = 107,
		_SC_MB_LEN_MAX = 108,
		_SC_NZERO = 109,
		_SC_SSIZE_MAX = 110,
		_SC_SCHAR_MAX = 111,
		_SC_SCHAR_MIN = 112,
		_SC_SHRT_MAX = 113,
		_SC_SHRT_MIN = 114,
		_SC_UCHAR_MAX = 115,
		_SC_UINT_MAX = 116,
		_SC_ULONG_MAX = 117,
		_SC_USHRT_MAX = 118,
		_SC_NL_ARGMAX = 119,
		_SC_NL_LANGMAX = 120,
		_SC_NL_MSGMAX = 121,
		_SC_NL_NMAX = 122,
		_SC_NL_SETMAX = 123,
		_SC_NL_TEXTMAX = 124,
		_SC_XBS5_ILP32_OFF32 = 125,
		_SC_XBS5_ILP32_OFFBIG = 126,
		_SC_XBS5_LP64_OFF64 = 127,
		_SC_XBS5_LPBIG_OFFBIG = 128,
		_SC_XOPEN_LEGACY = 129,
		_SC_XOPEN_REALTIME = 130,
		_SC_XOPEN_REALTIME_THREADS = 131,
		_SC_ADVISORY_INFO = 132,
		_SC_BARRIERS = 133,
		_SC_BASE = 134,
		_SC_C_LANG_SUPPORT = 135,
		_SC_C_LANG_SUPPORT_R = 136,
		_SC_CLOCK_SELECTION = 137,
		_SC_CPUTIME = 138,
		_SC_THREAD_CPUTIME = 139,
		_SC_DEVICE_IO = 140,
		_SC_DEVICE_SPECIFIC = 141,
		_SC_DEVICE_SPECIFIC_R = 142,
		_SC_FD_MGMT = 143,
		_SC_FIFO = 144,
		_SC_PIPE = 145,
		_SC_FILE_ATTRIBUTES = 146,
		_SC_FILE_LOCKING = 147,
		_SC_FILE_SYSTEM = 148,
		_SC_MONOTONIC_CLOCK = 149,
		_SC_MULTI_PROCESS = 150,
		_SC_SINGLE_PROCESS = 151,
		_SC_NETWORKING = 152,
		_SC_READER_WRITER_LOCKS = 153,
		_SC_SPIN_LOCKS = 154,
		_SC_REGEXP = 155,
		_SC_REGEX_VERSION = 156,
		_SC_SHELL = 157,
		_SC_SIGNALS = 158,
		_SC_SPAWN = 159,
		_SC_SPORADIC_SERVER = 160,
		_SC_THREAD_SPORADIC_SERVER = 161,
		_SC_SYSTEM_DATABASE = 162,
		_SC_SYSTEM_DATABASE_R = 163,
		_SC_TIMEOUTS = 164,
		_SC_TYPED_MEMORY_OBJECTS = 165,
		_SC_USER_GROUPS = 166,
		_SC_USER_GROUPS_R = 167,
		_SC_2_PBS = 168,
		_SC_2_PBS_ACCOUNTING = 169,
		_SC_2_PBS_LOCATE = 170,
		_SC_2_PBS_MESSAGE = 171,
		_SC_2_PBS_TRACK = 172,
		_SC_SYMLOOP_MAX = 173,
		_SC_STREAMS = 174,
		_SC_2_PBS_CHECKPOINT = 175,
		_SC_V6_ILP32_OFF32 = 176,
		_SC_V6_ILP32_OFFBIG = 177,
		_SC_V6_LP64_OFF64 = 178,
		_SC_V6_LPBIG_OFFBIG = 179,
		_SC_HOST_NAME_MAX = 180,
		_SC_TRACE = 181,
		_SC_TRACE_EVENT_FILTER = 182,
		_SC_TRACE_INHERIT = 183,
		_SC_TRACE_LOG = 184,
		_SC_LEVEL1_ICACHE_SIZE = 185,
		_SC_LEVEL1_ICACHE_ASSOC = 186,
		_SC_LEVEL1_ICACHE_LINESIZE = 187,
		_SC_LEVEL1_DCACHE_SIZE = 188,
		_SC_LEVEL1_DCACHE_ASSOC = 189,
		_SC_LEVEL1_DCACHE_LINESIZE = 190,
		_SC_LEVEL2_CACHE_SIZE = 191,
		_SC_LEVEL2_CACHE_ASSOC = 192,
		_SC_LEVEL2_CACHE_LINESIZE = 193,
		_SC_LEVEL3_CACHE_SIZE = 194,
		_SC_LEVEL3_CACHE_ASSOC = 195,
		_SC_LEVEL3_CACHE_LINESIZE = 196,
		_SC_LEVEL4_CACHE_SIZE = 197,
		_SC_LEVEL4_CACHE_ASSOC = 198,
		_SC_LEVEL4_CACHE_LINESIZE = 199
	}
	[Map]
	[CLSCompliant(false)]
	public enum ConfstrName
	{
		_CS_PATH = 0,
		_CS_V6_WIDTH_RESTRICTED_ENVS = 1,
		_CS_GNU_LIBC_VERSION = 2,
		_CS_GNU_LIBPTHREAD_VERSION = 3,
		_CS_LFS_CFLAGS = 1000,
		_CS_LFS_LDFLAGS = 1001,
		_CS_LFS_LIBS = 1002,
		_CS_LFS_LINTFLAGS = 1003,
		_CS_LFS64_CFLAGS = 1004,
		_CS_LFS64_LDFLAGS = 1005,
		_CS_LFS64_LIBS = 1006,
		_CS_LFS64_LINTFLAGS = 1007,
		_CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
		_CS_XBS5_ILP32_OFF32_LDFLAGS = 1101,
		_CS_XBS5_ILP32_OFF32_LIBS = 1102,
		_CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103,
		_CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104,
		_CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105,
		_CS_XBS5_ILP32_OFFBIG_LIBS = 1106,
		_CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107,
		_CS_XBS5_LP64_OFF64_CFLAGS = 1108,
		_CS_XBS5_LP64_OFF64_LDFLAGS = 1109,
		_CS_XBS5_LP64_OFF64_LIBS = 1110,
		_CS_XBS5_LP64_OFF64_LINTFLAGS = 1111,
		_CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112,
		_CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113,
		_CS_XBS5_LPBIG_OFFBIG_LIBS = 1114,
		_CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115,
		_CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
		_CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117,
		_CS_POSIX_V6_ILP32_OFF32_LIBS = 1118,
		_CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119,
		_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120,
		_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121,
		_CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122,
		_CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123,
		_CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124,
		_CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125,
		_CS_POSIX_V6_LP64_OFF64_LIBS = 1126,
		_CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127,
		_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128,
		_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129,
		_CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130,
		_CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131
	}
	[CLSCompliant(false)]
	[Map]
	public enum LockfCommand
	{
		F_ULOCK,
		F_LOCK,
		F_TLOCK,
		F_TEST
	}
	[Map]
	[Flags]
	public enum PollEvents : short
	{
		POLLIN = 1,
		POLLPRI = 2,
		POLLOUT = 4,
		POLLERR = 8,
		POLLHUP = 0x10,
		POLLNVAL = 0x20,
		POLLRDNORM = 0x40,
		POLLRDBAND = 0x80,
		POLLWRNORM = 0x100,
		POLLWRBAND = 0x200
	}
	[CLSCompliant(false)]
	[Flags]
	[Map]
	public enum XattrFlags
	{
		XATTR_AUTO = 0,
		XATTR_CREATE = 1,
		XATTR_REPLACE = 2
	}
	[Map]
	[Flags]
	[CLSCompliant(false)]
	public enum MountFlags : ulong
	{
		ST_RDONLY = 1uL,
		ST_NOSUID = 2uL,
		ST_NODEV = 4uL,
		ST_NOEXEC = 8uL,
		ST_SYNCHRONOUS = 0x10uL,
		ST_REMOUNT = 0x20uL,
		ST_MANDLOCK = 0x40uL,
		ST_WRITE = 0x80uL,
		ST_APPEND = 0x100uL,
		ST_IMMUTABLE = 0x200uL,
		ST_NOATIME = 0x400uL,
		ST_NODIRATIME = 0x800uL,
		ST_BIND = 0x1000uL
	}
	[Map]
	[Flags]
	[CLSCompliant(false)]
	public enum MmapFlags
	{
		MAP_SHARED = 1,
		MAP_PRIVATE = 2,
		MAP_TYPE = 0xF,
		MAP_FIXED = 0x10,
		MAP_FILE = 0,
		MAP_ANONYMOUS = 0x20,
		MAP_ANON = 0x20,
		MAP_GROWSDOWN = 0x100,
		MAP_DENYWRITE = 0x800,
		MAP_EXECUTABLE = 0x1000,
		MAP_LOCKED = 0x2000,
		MAP_NORESERVE = 0x4000,
		MAP_POPULATE = 0x8000,
		MAP_NONBLOCK = 0x10000
	}
	[CLSCompliant(false)]
	[Map]
	[Flags]
	public enum MmapProts
	{
		PROT_READ = 1,
		PROT_WRITE = 2,
		PROT_EXEC = 4,
		PROT_NONE = 0,
		PROT_GROWSDOWN = 0x1000000,
		PROT_GROWSUP = 0x2000000
	}
	[Flags]
	[CLSCompliant(false)]
	[Map]
	public enum MsyncFlags
	{
		MS_ASYNC = 1,
		MS_SYNC = 4,
		MS_INVALIDATE = 2
	}
	[CLSCompliant(false)]
	[Flags]
	[Map]
	public enum MlockallFlags
	{
		MCL_CURRENT = 1,
		MCL_FUTURE = 2
	}
	[CLSCompliant(false)]
	[Map]
	[Flags]
	public enum MremapFlags : ulong
	{
		MREMAP_MAYMOVE = 1uL
	}
	[Map("struct flock")]
	public struct Flock : IEquatable<Flock>
	{
		[CLSCompliant(false)]
		public LockType l_type;

		[CLSCompliant(false)]
		public SeekFlags l_whence;

		[off_t]
		public long l_start;

		[off_t]
		public long l_len;

		[pid_t]
		public int l_pid;

		public override int GetHashCode()
		{
			return l_type.GetHashCode() ^ l_whence.GetHashCode() ^ l_start.GetHashCode() ^ l_len.GetHashCode() ^ l_pid.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)obj.GetType() != GetType())
			{
				return false;
			}
			Flock flock = (Flock)obj;
			return l_type == flock.l_type && l_whence == flock.l_whence && l_start == flock.l_start && l_len == flock.l_len && l_pid == flock.l_pid;
		}

		public bool Equals(Flock value)
		{
			return l_type == value.l_type && l_whence == value.l_whence && l_start == value.l_start && l_len == value.l_len && l_pid == value.l_pid;
		}

		public static bool operator ==(Flock lhs, Flock rhs)
		{
			return lhs.Equals(rhs);
		}

		public static bool operator !=(Flock lhs, Flock rhs)
		{
			return !lhs.Equals(rhs);
		}
	}
	[Map("struct pollfd")]
	public struct Pollfd : IEquatable<Pollfd>
	{
		public int fd;

		[CLSCompliant(false)]
		public PollEvents events;

		[CLSCompliant(false)]
		public PollEvents revents;

		public override int GetHashCode()
		{
			return events.GetHashCode() ^ revents.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)obj.GetType() != GetType())
			{
				return false;
			}
			Pollfd pollfd = (Pollfd)obj;
			return pollfd.events == events && pollfd.revents == revents;
		}

		public bool Equals(Pollfd value)
		{
			return value.events == events && value.revents == revents;
		}

		public static bool operator ==(Pollfd lhs, Pollfd rhs)
		{
			return lhs.Equals(rhs);
		}

		public static bool operator !=(Pollfd lhs, Pollfd rhs)
		{
			return !lhs.Equals(rhs);
		}
	}
	[Map("struct stat")]
	public struct Stat : IEquatable<Stat>
	{
		[dev_t]
		[CLSCompliant(false)]
		public ulong st_dev;

		[ino_t]
		[CLSCompliant(false)]
		public ulong st_ino;

		[CLSCompliant(false)]
		public FilePermissions st_mode;

		[NonSerialized]
		private uint _padding_;

		[nlink_t]
		[CLSCompliant(false)]
		public ulong st_nlink;

		[CLSCompliant(false)]
		[uid_t]
		public uint st_uid;

		[gid_t]
		[CLSCompliant(false)]
		public uint st_gid;

		[CLSCompliant(false)]
		[dev_t]
		public ulong st_rdev;

		[off_t]
		public long st_size;

		[blksize_t]
		public long st_blksize;

		[blkcnt_t]
		public long st_blocks;

		[time_t]
		public long st_atime;

		[time_t]
		public long st_mtime;

		[time_t]
		public long st_ctime;

		public override int GetHashCode()
		{
			return st_dev.GetHashCode() ^ st_ino.GetHashCode() ^ st_mode.GetHashCode() ^ st_nlink.GetHashCode() ^ st_uid.GetHashCode() ^ st_gid.GetHashCode() ^ st_rdev.GetHashCode() ^ st_size.GetHashCode() ^ st_blksize.GetHashCode() ^ st_blocks.GetHashCode() ^ st_atime.GetHashCode() ^ st_mtime.GetHashCode() ^ st_ctime.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)obj.GetType() != GetType())
			{
				return false;
			}
			Stat stat = (Stat)obj;
			return stat.st_dev == st_dev && stat.st_ino == st_ino && stat.st_mode == st_mode && stat.st_nlink == st_nlink && stat.st_uid == st_uid && stat.st_gid == st_gid && stat.st_rdev == st_rdev && stat.st_size == st_size && stat.st_blksize == st_blksize && stat.st_blocks == st_blocks && stat.st_atime == st_atime && stat.st_mtime == st_mtime && stat.st_ctime == st_ctime;
		}

		public bool Equals(Stat value)
		{
			return value.st_dev == st_dev && value.st_ino == st_ino && value.st_mode == st_mode && value.st_nlink == st_nlink && value.st_uid == st_uid && value.st_gid == st_gid && value.st_rdev == st_rdev && value.st_size == st_size && value.st_blksize == st_blksize && value.st_blocks == st_blocks && value.st_atime == st_atime && value.st_mtime == st_mtime && value.st_ctime == st_ctime;
		}

		public static bool operator ==(Stat lhs, Stat rhs)
		{
			return lhs.Equals(rhs);
		}

		public static bool operator !=(Stat lhs, Stat rhs)
		{
			return !lhs.Equals(rhs);
		}
	}
	[CLSCompliant(false)]
	[Map]
	public struct Statvfs : IEquatable<Statvfs>
	{
		public ulong f_bsize;

		public ulong f_frsize;

		[fsblkcnt_t]
		public ulong f_blocks;

		[fsblkcnt_t]
		public ulong f_bfree;

		[fsblkcnt_t]
		public ulong f_bavail;

		[fsfilcnt_t]
		public ulong f_files;

		[fsfilcnt_t]
		public ulong f_ffree;

		[fsfilcnt_t]
		public ulong f_favail;

		public ulong f_fsid;

		public MountFlags f_flag;

		public ulong f_namemax;

		public override int GetHashCode()
		{
			return f_bsize.GetHashCode() ^ f_frsize.GetHashCode() ^ f_blocks.GetHashCode() ^ f_bfree.GetHashCode() ^ f_bavail.GetHashCode() ^ f_files.GetHashCode() ^ f_ffree.GetHashCode() ^ f_favail.GetHashCode() ^ f_fsid.GetHashCode() ^ f_flag.GetHashCode() ^ f_namemax.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)obj.GetType() != GetType())
			{
				return false;
			}
			Statvfs statvfs = (Statvfs)obj;
			return statvfs.f_bsize == f_bsize && statvfs.f_frsize == f_frsize && statvfs.f_blocks == f_blocks && statvfs.f_bfree == f_bfree && statvfs.f_bavail == f_bavail && statvfs.f_files == f_files && statvfs.f_ffree == f_ffree && statvfs.f_favail == f_favail && statvfs.f_fsid == f_fsid && statvfs.f_flag == f_flag && statvfs.f_namemax == f_namemax;
		}

		public bool Equals(Statvfs value)
		{
			return value.f_bsize == f_bsize && value.f_frsize == f_frsize && value.f_blocks == f_blocks && value.f_bfree == f_bfree && value.f_bavail == f_bavail && value.f_files == f_files && value.f_ffree == f_ffree && value.f_favail == f_favail && value.f_fsid == f_fsid && value.f_flag == f_flag && value.f_namemax == f_namemax;
		}

		public static bool operator ==(Statvfs lhs, Statvfs rhs)
		{
			return lhs.Equals(rhs);
		}

		public static bool operator !=(Statvfs lhs, Statvfs rhs)
		{
			return !lhs.Equals(rhs);
		}
	}
	[Map("struct timeval")]
	public struct Timeval : IEquatable<Timeval>
	{
		[time_t]
		public long tv_sec;

		[suseconds_t]
		public long tv_usec;

		public override int GetHashCode()
		{
			return tv_sec.GetHashCode() ^ tv_usec.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)obj.GetType() != GetType())
			{
				return false;
			}
			Timeval timeval = (Timeval)obj;
			return timeval.tv_sec == tv_sec && timeval.tv_usec == tv_usec;
		}

		public bool Equals(Timeval value)
		{
			return value.tv_sec == tv_sec && value.tv_usec == tv_usec;
		}

		public static bool operator ==(Timeval lhs, Timeval rhs)
		{
			return lhs.Equals(rhs);
		}

		public static bool operator !=(Timeval lhs, Timeval rhs)
		{
			return !lhs.Equals(rhs);
		}
	}
	[Map("struct timezone")]
	public struct Timezone : IEquatable<Timezone>
	{
		public int tz_minuteswest;

		private int tz_dsttime;

		public override int GetHashCode()
		{
			return tz_minuteswest.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)obj.GetType() != GetType())
			{
				return false;
			}
			return ((Timezone)obj).tz_minuteswest == tz_minuteswest;
		}

		public bool Equals(Timezone value)
		{
			return value.tz_minuteswest == tz_minuteswest;
		}

		public static bool operator ==(Timezone lhs, Timezone rhs)
		{
			return lhs.Equals(rhs);
		}

		public static bool operator !=(Timezone lhs, Timezone rhs)
		{
			return !lhs.Equals(rhs);
		}
	}
	[Map("struct utimbuf")]
	public struct Utimbuf : IEquatable<Utimbuf>
	{
		[time_t]
		public long actime;

		[time_t]
		public long modtime;

		public override int GetHashCode()
		{
			return actime.GetHashCode() ^ modtime.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)obj.GetType() != GetType())
			{
				return false;
			}
			Utimbuf utimbuf = (Utimbuf)obj;
			return utimbuf.actime == actime && utimbuf.modtime == modtime;
		}

		public bool Equals(Utimbuf value)
		{
			return value.actime == actime && value.modtime == modtime;
		}

		public static bool operator ==(Utimbuf lhs, Utimbuf rhs)
		{
			return lhs.Equals(rhs);
		}

		public static bool operator !=(Utimbuf lhs, Utimbuf rhs)
		{
			return !lhs.Equals(rhs);
		}
	}
	[Map("struct timespec")]
	public struct Timespec : IEquatable<Timespec>
	{
		[time_t]
		public long tv_sec;

		public long tv_nsec;

		public override int GetHashCode()
		{
			return tv_sec.GetHashCode() ^ tv_nsec.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)obj.GetType() != GetType())
			{
				return false;
			}
			Timespec timespec = (Timespec)obj;
			return timespec.tv_sec == tv_sec && timespec.tv_nsec == tv_nsec;
		}

		public bool Equals(Timespec value)
		{
			return value.tv_sec == tv_sec && value.tv_nsec == tv_nsec;
		}

		public static bool operator ==(Timespec lhs, Timespec rhs)
		{
			return lhs.Equals(rhs);
		}

		public static bool operator !=(Timespec lhs, Timespec rhs)
		{
			return !lhs.Equals(rhs);
		}
	}
	public sealed class Dirent : IEquatable<Dirent>
	{
		[CLSCompliant(false)]
		public ulong d_ino;

		public long d_off;

		[CLSCompliant(false)]
		public ushort d_reclen;

		public byte d_type;

		public string d_name;

		public override int GetHashCode()
		{
			return d_ino.GetHashCode() ^ d_off.GetHashCode() ^ d_reclen.GetHashCode() ^ d_type.GetHashCode() ^ d_name.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)GetType() != obj.GetType())
			{
				return false;
			}
			Dirent value = (Dirent)obj;
			return Equals(value);
		}

		public bool Equals(Dirent value)
		{
			if (value == null)
			{
				return false;
			}
			return value.d_ino == d_ino && value.d_off == d_off && value.d_reclen == d_reclen && value.d_type == d_type && value.d_name == d_name;
		}

		public override string ToString()
		{
			return d_name;
		}

		public static bool operator ==(Dirent lhs, Dirent rhs)
		{
			return object.Equals(lhs, rhs);
		}

		public static bool operator !=(Dirent lhs, Dirent rhs)
		{
			return !object.Equals(lhs, rhs);
		}
	}
	public sealed class Fstab : IEquatable<Fstab>
	{
		public string fs_spec;

		public string fs_file;

		public string fs_vfstype;

		public string fs_mntops;

		public string fs_type;

		public int fs_freq;

		public int fs_passno;

		public override int GetHashCode()
		{
			return fs_spec.GetHashCode() ^ fs_file.GetHashCode() ^ fs_vfstype.GetHashCode() ^ fs_mntops.GetHashCode() ^ fs_type.GetHashCode() ^ fs_freq ^ fs_passno;
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)GetType() != obj.GetType())
			{
				return false;
			}
			Fstab value = (Fstab)obj;
			return Equals(value);
		}

		public bool Equals(Fstab value)
		{
			if (value == null)
			{
				return false;
			}
			return value.fs_spec == fs_spec && value.fs_file == fs_file && value.fs_vfstype == fs_vfstype && value.fs_mntops == fs_mntops && value.fs_type == fs_type && value.fs_freq == fs_freq && value.fs_passno == fs_passno;
		}

		public override string ToString()
		{
			return fs_spec;
		}

		public static bool operator ==(Fstab lhs, Fstab rhs)
		{
			return object.Equals(lhs, rhs);
		}

		public static bool operator !=(Fstab lhs, Fstab rhs)
		{
			return !object.Equals(lhs, rhs);
		}
	}
	public sealed class Group : IEquatable<Group>
	{
		public string gr_name;

		public string gr_passwd;

		[CLSCompliant(false)]
		public uint gr_gid;

		public string[] gr_mem;

		public override int GetHashCode()
		{
			int num = 0;
			for (int i = 0; i < gr_mem.Length; i++)
			{
				num ^= gr_mem[i].GetHashCode();
			}
			return gr_name.GetHashCode() ^ gr_passwd.GetHashCode() ^ gr_gid.GetHashCode() ^ num;
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)GetType() != obj.GetType())
			{
				return false;
			}
			Group value = (Group)obj;
			return Equals(value);
		}

		public bool Equals(Group value)
		{
			if (value == null)
			{
				return false;
			}
			if (value.gr_gid != gr_gid)
			{
				return false;
			}
			if (value.gr_gid == gr_gid && value.gr_name == gr_name && value.gr_passwd == gr_passwd)
			{
				if (value.gr_mem == gr_mem)
				{
					return true;
				}
				if (value.gr_mem == null || gr_mem == null)
				{
					return false;
				}
				if (value.gr_mem.Length != gr_mem.Length)
				{
					return false;
				}
				for (int i = 0; i < gr_mem.Length; i++)
				{
					if (gr_mem[i] != value.gr_mem[i])
					{
						return false;
					}
				}
				return true;
			}
			return false;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(gr_name).Append(":").Append(gr_passwd)
				.Append(":");
			stringBuilder.Append(gr_gid).Append(":");
			GetMembers(stringBuilder, gr_mem);
			return stringBuilder.ToString();
		}

		private static void GetMembers(StringBuilder sb, string[] members)
		{
			if (members.Length > 0)
			{
				sb.Append(members[0]);
			}
			for (int i = 1; i < members.Length; i++)
			{
				sb.Append(",");
				sb.Append(members[i]);
			}
		}

		public static bool operator ==(Group lhs, Group rhs)
		{
			return object.Equals(lhs, rhs);
		}

		public static bool operator !=(Group lhs, Group rhs)
		{
			return !object.Equals(lhs, rhs);
		}
	}
	public sealed class Passwd : IEquatable<Passwd>
	{
		public string pw_name;

		public string pw_passwd;

		[CLSCompliant(false)]
		public uint pw_uid;

		[CLSCompliant(false)]
		public uint pw_gid;

		public string pw_gecos;

		public string pw_dir;

		public string pw_shell;

		public override int GetHashCode()
		{
			return pw_name.GetHashCode() ^ pw_passwd.GetHashCode() ^ pw_uid.GetHashCode() ^ pw_gid.GetHashCode() ^ pw_gecos.GetHashCode() ^ pw_dir.GetHashCode() ^ pw_dir.GetHashCode() ^ pw_shell.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)GetType() != obj.GetType())
			{
				return false;
			}
			Passwd value = (Passwd)obj;
			return Equals(value);
		}

		public bool Equals(Passwd value)
		{
			if (value == null)
			{
				return false;
			}
			return value.pw_uid == pw_uid && value.pw_gid == pw_gid && value.pw_name == pw_name && value.pw_passwd == pw_passwd && value.pw_gecos == pw_gecos && value.pw_dir == pw_dir && value.pw_shell == pw_shell;
		}

		public override string ToString()
		{
			return $"{pw_name}:{pw_passwd}:{pw_uid}:{pw_gid}:{pw_gecos}:{pw_dir}:{pw_shell}";
		}

		public static bool operator ==(Passwd lhs, Passwd rhs)
		{
			return object.Equals(lhs, rhs);
		}

		public static bool operator !=(Passwd lhs, Passwd rhs)
		{
			return !object.Equals(lhs, rhs);
		}
	}
	public sealed class Utsname : IEquatable<Utsname>
	{
		public string sysname;

		public string nodename;

		public string release;

		public string version;

		public string machine;

		public string domainname;

		public override int GetHashCode()
		{
			return sysname.GetHashCode() ^ nodename.GetHashCode() ^ release.GetHashCode() ^ version.GetHashCode() ^ machine.GetHashCode() ^ domainname.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (obj == null || (object)GetType() != obj.GetType())
			{
				return false;
			}
			Utsname value = (Utsname)obj;
			return Equals(value);
		}

		public bool Equals(Utsname value)
		{
			return value.sysname == sysname && value.nodename == nodename && value.release == release && value.version == version && value.machine == machine && value.domainname == domainname;
		}

		public override string ToString()
		{
			return $"{sysname} {nodename} {release} {version} {machine}";
		}

		public static bool operator ==(Utsname lhs, Utsname rhs)
		{
			return object.Equals(lhs, rhs);
		}

		public static bool operator !=(Utsname lhs, Utsname rhs)
		{
			return !object.Equals(lhs, rhs);
		}
	}
	[CLSCompliant(false)]
	public sealed class Syscall : Stdlib
	{
		private struct _Dirent
		{
			[ino_t]
			public ulong d_ino;

			[off_t]
			public long d_off;

			public ushort d_reclen;

			public byte d_type;

			public IntPtr d_name;
		}

		[Map]
		private struct _Fstab
		{
			public IntPtr fs_spec;

			public IntPtr fs_file;

			public IntPtr fs_vfstype;

			public IntPtr fs_mntops;

			public IntPtr fs_type;

			public int fs_freq;

			public int fs_passno;

			public IntPtr _fs_buf_;
		}

		[Map]
		private struct _Group
		{
			public IntPtr gr_name;

			public IntPtr gr_passwd;

			[gid_t]
			public uint gr_gid;

			public int _gr_nmem_;

			public IntPtr gr_mem;

			public IntPtr _gr_buf_;
		}

		[Map]
		private struct _Passwd
		{
			public IntPtr pw_name;

			public IntPtr pw_passwd;

			[uid_t]
			public uint pw_uid;

			[gid_t]
			public uint pw_gid;

			public IntPtr pw_gecos;

			public IntPtr pw_dir;

			public IntPtr pw_shell;

			public IntPtr _pw_buf_;
		}

		private struct _pollfd
		{
			public int fd;

			public short events;

			public short revents;
		}

		[Map]
		private struct _Utsname
		{
			public IntPtr sysname;

			public IntPtr nodename;

			public IntPtr release;

			public IntPtr version;

			public IntPtr machine;

			public IntPtr domainname;

			public IntPtr _buf_;
		}

		internal new const string LIBC = "libc";

		internal static object readdir_lock = new object();

		internal static object fstab_lock = new object();

		internal static object grp_lock = new object();

		internal static object pwd_lock = new object();

		private static object signal_lock = new object();

		public static readonly int L_ctermid = _L_ctermid();

		public static readonly int L_cuserid = _L_cuserid();

		internal static object getlogin_lock = new object();

		public static readonly IntPtr MAP_FAILED = (IntPtr)(-1);

		private static object tty_lock = new object();

		internal static object usershell_lock = new object();

		private Syscall()
		{
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_setxattr", SetLastError = true)]
		public static extern int setxattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, byte[] value, ulong size, XattrFlags flags);

		public static int setxattr(string path, string name, byte[] value, ulong size)
		{
			return setxattr(path, name, value, size, XattrFlags.XATTR_AUTO);
		}

		public static int setxattr(string path, string name, byte[] value, XattrFlags flags)
		{
			return setxattr(path, name, value, (ulong)value.Length, flags);
		}

		public static int setxattr(string path, string name, byte[] value)
		{
			return setxattr(path, name, value, (ulong)value.Length);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_lsetxattr", SetLastError = true)]
		public static extern int lsetxattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, byte[] value, ulong size, XattrFlags flags);

		public static int lsetxattr(string path, string name, byte[] value, ulong size)
		{
			return lsetxattr(path, name, value, size, XattrFlags.XATTR_AUTO);
		}

		public static int lsetxattr(string path, string name, byte[] value, XattrFlags flags)
		{
			return lsetxattr(path, name, value, (ulong)value.Length, flags);
		}

		public static int lsetxattr(string path, string name, byte[] value)
		{
			return lsetxattr(path, name, value, (ulong)value.Length);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fsetxattr", SetLastError = true)]
		public static extern int fsetxattr(int fd, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, byte[] value, ulong size, XattrFlags flags);

		public static int fsetxattr(int fd, string name, byte[] value, ulong size)
		{
			return fsetxattr(fd, name, value, size, XattrFlags.XATTR_AUTO);
		}

		public static int fsetxattr(int fd, string name, byte[] value, XattrFlags flags)
		{
			return fsetxattr(fd, name, value, (ulong)value.Length, flags);
		}

		public static int fsetxattr(int fd, string name, byte[] value)
		{
			return fsetxattr(fd, name, value, (ulong)value.Length);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getxattr", SetLastError = true)]
		public static extern long getxattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, byte[] value, ulong size);

		public static long getxattr(string path, string name, byte[] value)
		{
			return getxattr(path, name, value, (ulong)value.Length);
		}

		public static long getxattr(string path, string name, out byte[] value)
		{
			value = null;
			long num = getxattr(path, name, value, 0uL);
			if (num <= 0)
			{
				return num;
			}
			value = new byte[num];
			return getxattr(path, name, value, (ulong)num);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_lgetxattr", SetLastError = true)]
		public static extern long lgetxattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, byte[] value, ulong size);

		public static long lgetxattr(string path, string name, byte[] value)
		{
			return lgetxattr(path, name, value, (ulong)value.Length);
		}

		public static long lgetxattr(string path, string name, out byte[] value)
		{
			value = null;
			long num = lgetxattr(path, name, value, 0uL);
			if (num <= 0)
			{
				return num;
			}
			value = new byte[num];
			return lgetxattr(path, name, value, (ulong)num);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fgetxattr", SetLastError = true)]
		public static extern long fgetxattr(int fd, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, byte[] value, ulong size);

		public static long fgetxattr(int fd, string name, byte[] value)
		{
			return fgetxattr(fd, name, value, (ulong)value.Length);
		}

		public static long fgetxattr(int fd, string name, out byte[] value)
		{
			value = null;
			long num = fgetxattr(fd, name, value, 0uL);
			if (num <= 0)
			{
				return num;
			}
			value = new byte[num];
			return fgetxattr(fd, name, value, (ulong)num);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_listxattr", SetLastError = true)]
		public static extern long listxattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, byte[] list, ulong size);

		public static long listxattr(string path, Encoding encoding, out string[] values)
		{
			values = null;
			long num = listxattr(path, null, 0uL);
			if (num == 0L)
			{
				values = new string[0];
			}
			if (num <= 0)
			{
				return (int)num;
			}
			byte[] list = new byte[num];
			long num2 = listxattr(path, list, (ulong)num);
			if (num2 < 0)
			{
				return (int)num2;
			}
			GetValues(list, encoding, out values);
			return 0L;
		}

		public static long listxattr(string path, out string[] values)
		{
			return listxattr(path, UnixEncoding.Instance, out values);
		}

		private static void GetValues(byte[] list, Encoding encoding, out string[] values)
		{
			int num = 0;
			for (int i = 0; i < list.Length; i++)
			{
				if (list[i] == 0)
				{
					num++;
				}
			}
			values = new string[num];
			num = 0;
			int num2 = 0;
			for (int j = 0; j < list.Length; j++)
			{
				if (list[j] == 0)
				{
					values[num++] = encoding.GetString(list, num2, j - num2);
					num2 = j + 1;
				}
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_llistxattr", SetLastError = true)]
		public static extern long llistxattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, byte[] list, ulong size);

		public static long llistxattr(string path, Encoding encoding, out string[] values)
		{
			values = null;
			long num = llistxattr(path, null, 0uL);
			if (num == 0L)
			{
				values = new string[0];
			}
			if (num <= 0)
			{
				return (int)num;
			}
			byte[] list = new byte[num];
			long num2 = llistxattr(path, list, (ulong)num);
			if (num2 < 0)
			{
				return (int)num2;
			}
			GetValues(list, encoding, out values);
			return 0L;
		}

		public static long llistxattr(string path, out string[] values)
		{
			return llistxattr(path, UnixEncoding.Instance, out values);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_flistxattr", SetLastError = true)]
		public static extern long flistxattr(int fd, byte[] list, ulong size);

		public static long flistxattr(int fd, Encoding encoding, out string[] values)
		{
			values = null;
			long num = flistxattr(fd, null, 0uL);
			if (num == 0L)
			{
				values = new string[0];
			}
			if (num <= 0)
			{
				return (int)num;
			}
			byte[] list = new byte[num];
			long num2 = flistxattr(fd, list, (ulong)num);
			if (num2 < 0)
			{
				return (int)num2;
			}
			GetValues(list, encoding, out values);
			return 0L;
		}

		public static long flistxattr(int fd, out string[] values)
		{
			return flistxattr(fd, UnixEncoding.Instance, out values);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_removexattr", SetLastError = true)]
		public static extern int removexattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_lremovexattr", SetLastError = true)]
		public static extern int lremovexattr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fremovexattr", SetLastError = true)]
		public static extern int fremovexattr(int fd, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name);

		[DllImport("libc", SetLastError = true)]
		public static extern IntPtr opendir([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name);

		[DllImport("libc", SetLastError = true)]
		public static extern int closedir(IntPtr dir);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_seekdir", SetLastError = true)]
		public static extern int seekdir(IntPtr dir, long offset);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_telldir", SetLastError = true)]
		public static extern long telldir(IntPtr dir);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_rewinddir", SetLastError = true)]
		public static extern int rewinddir(IntPtr dir);

		private static void CopyDirent(Dirent to, ref _Dirent from)
		{
			try
			{
				to.d_ino = from.d_ino;
				to.d_off = from.d_off;
				to.d_reclen = from.d_reclen;
				to.d_type = from.d_type;
				to.d_name = UnixMarshal.PtrToString(from.d_name);
			}
			finally
			{
				Stdlib.free(from.d_name);
				from.d_name = IntPtr.Zero;
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_readdir", SetLastError = true)]
		private static extern int sys_readdir(IntPtr dir, out _Dirent dentry);

		public static Dirent readdir(IntPtr dir)
		{
			int num;
			_Dirent dentry;
			lock (readdir_lock)
			{
				num = sys_readdir(dir, out dentry);
			}
			if (num != 0)
			{
				return null;
			}
			Dirent dirent = new Dirent();
			CopyDirent(dirent, ref dentry);
			return dirent;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_readdir_r", SetLastError = true)]
		private static extern int sys_readdir_r(IntPtr dirp, out _Dirent entry, out IntPtr result);

		public static int readdir_r(IntPtr dirp, Dirent entry, out IntPtr result)
		{
			entry.d_ino = 0uL;
			entry.d_off = 0L;
			entry.d_reclen = 0;
			entry.d_type = 0;
			entry.d_name = null;
			_Dirent entry2;
			int num = sys_readdir_r(dirp, out entry2, out result);
			if (num == 0 && result != IntPtr.Zero)
			{
				CopyDirent(entry, ref entry2);
			}
			return num;
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int dirfd(IntPtr dir);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fcntl", SetLastError = true)]
		public static extern int fcntl(int fd, FcntlCommand cmd);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fcntl_arg", SetLastError = true)]
		public static extern int fcntl(int fd, FcntlCommand cmd, long arg);

		public static int fcntl(int fd, FcntlCommand cmd, DirectoryNotifyFlags arg)
		{
			if (cmd != FcntlCommand.F_NOTIFY)
			{
				Stdlib.SetLastError(Errno.EINVAL);
				return -1;
			}
			long arg2 = NativeConvert.FromDirectoryNotifyFlags(arg);
			return fcntl(fd, FcntlCommand.F_NOTIFY, arg2);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fcntl_lock", SetLastError = true)]
		public static extern int fcntl(int fd, FcntlCommand cmd, ref Flock @lock);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_open", SetLastError = true)]
		public static extern int open([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname, OpenFlags flags);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_open_mode", SetLastError = true)]
		public static extern int open([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname, OpenFlags flags, FilePermissions mode);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_creat", SetLastError = true)]
		public static extern int creat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname, FilePermissions mode);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_posix_fadvise", SetLastError = true)]
		public static extern int posix_fadvise(int fd, long offset, long len, PosixFadviseAdvice advice);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_posix_fallocate", SetLastError = true)]
		public static extern int posix_fallocate(int fd, long offset, ulong len);

		private static void CopyFstab(Fstab to, ref _Fstab from)
		{
			try
			{
				to.fs_spec = UnixMarshal.PtrToString(from.fs_spec);
				to.fs_file = UnixMarshal.PtrToString(from.fs_file);
				to.fs_vfstype = UnixMarshal.PtrToString(from.fs_vfstype);
				to.fs_mntops = UnixMarshal.PtrToString(from.fs_mntops);
				to.fs_type = UnixMarshal.PtrToString(from.fs_type);
				to.fs_freq = from.fs_freq;
				to.fs_passno = from.fs_passno;
			}
			finally
			{
				Stdlib.free(from._fs_buf_);
				from._fs_buf_ = IntPtr.Zero;
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_endfsent", SetLastError = true)]
		private static extern int sys_endfsent();

		public static int endfsent()
		{
			lock (fstab_lock)
			{
				return sys_endfsent();
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getfsent", SetLastError = true)]
		private static extern int sys_getfsent(out _Fstab fs);

		public static Fstab getfsent()
		{
			int num;
			_Fstab fs;
			lock (fstab_lock)
			{
				num = sys_getfsent(out fs);
			}
			if (num != 0)
			{
				return null;
			}
			Fstab fstab = new Fstab();
			CopyFstab(fstab, ref fs);
			return fstab;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getfsfile", SetLastError = true)]
		private static extern int sys_getfsfile([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string mount_point, out _Fstab fs);

		public static Fstab getfsfile(string mount_point)
		{
			int num;
			_Fstab fs;
			lock (fstab_lock)
			{
				num = sys_getfsfile(mount_point, out fs);
			}
			if (num != 0)
			{
				return null;
			}
			Fstab fstab = new Fstab();
			CopyFstab(fstab, ref fs);
			return fstab;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getfsspec", SetLastError = true)]
		private static extern int sys_getfsspec([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string special_file, out _Fstab fs);

		public static Fstab getfsspec(string special_file)
		{
			int num;
			_Fstab fs;
			lock (fstab_lock)
			{
				num = sys_getfsspec(special_file, out fs);
			}
			if (num != 0)
			{
				return null;
			}
			Fstab fstab = new Fstab();
			CopyFstab(fstab, ref fs);
			return fstab;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_setfsent", SetLastError = true)]
		private static extern int sys_setfsent();

		public static int setfsent()
		{
			lock (fstab_lock)
			{
				return sys_setfsent();
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_setgroups", SetLastError = true)]
		public static extern int setgroups(ulong size, uint[] list);

		public static int setgroups(uint[] list)
		{
			return setgroups((ulong)list.Length, list);
		}

		private static void CopyGroup(Group to, ref _Group from)
		{
			try
			{
				to.gr_gid = from.gr_gid;
				to.gr_name = UnixMarshal.PtrToString(from.gr_name);
				to.gr_passwd = UnixMarshal.PtrToString(from.gr_passwd);
				to.gr_mem = UnixMarshal.PtrToStringArray(from._gr_nmem_, from.gr_mem);
			}
			finally
			{
				Stdlib.free(from.gr_mem);
				Stdlib.free(from._gr_buf_);
				from.gr_mem = IntPtr.Zero;
				from._gr_buf_ = IntPtr.Zero;
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getgrnam", SetLastError = true)]
		private static extern int sys_getgrnam(string name, out _Group group);

		public static Group getgrnam(string name)
		{
			int num;
			_Group group;
			lock (grp_lock)
			{
				num = sys_getgrnam(name, out group);
			}
			if (num != 0)
			{
				return null;
			}
			Group obj = new Group();
			CopyGroup(obj, ref group);
			return obj;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getgrgid", SetLastError = true)]
		private static extern int sys_getgrgid(uint uid, out _Group group);

		public static Group getgrgid(uint uid)
		{
			int num;
			_Group group;
			lock (grp_lock)
			{
				num = sys_getgrgid(uid, out group);
			}
			if (num != 0)
			{
				return null;
			}
			Group obj = new Group();
			CopyGroup(obj, ref group);
			return obj;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getgrnam_r", SetLastError = true)]
		private static extern int sys_getgrnam_r([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, out _Group grbuf, out IntPtr grbufp);

		public static int getgrnam_r(string name, Group grbuf, out Group grbufp)
		{
			grbufp = null;
			_Group grbuf2;
			IntPtr grbufp2;
			int num = sys_getgrnam_r(name, out grbuf2, out grbufp2);
			if (num == 0 && grbufp2 != IntPtr.Zero)
			{
				CopyGroup(grbuf, ref grbuf2);
				grbufp = grbuf;
			}
			return num;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getgrgid_r", SetLastError = true)]
		private static extern int sys_getgrgid_r(uint uid, out _Group grbuf, out IntPtr grbufp);

		public static int getgrgid_r(uint uid, Group grbuf, out Group grbufp)
		{
			grbufp = null;
			_Group grbuf2;
			IntPtr grbufp2;
			int num = sys_getgrgid_r(uid, out grbuf2, out grbufp2);
			if (num == 0 && grbufp2 != IntPtr.Zero)
			{
				CopyGroup(grbuf, ref grbuf2);
				grbufp = grbuf;
			}
			return num;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getgrent", SetLastError = true)]
		private static extern int sys_getgrent(out _Group grbuf);

		public static Group getgrent()
		{
			int num;
			_Group grbuf;
			lock (grp_lock)
			{
				num = sys_getgrent(out grbuf);
			}
			if (num != 0)
			{
				return null;
			}
			Group obj = new Group();
			CopyGroup(obj, ref grbuf);
			return obj;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_setgrent", SetLastError = true)]
		private static extern int sys_setgrent();

		public static int setgrent()
		{
			lock (grp_lock)
			{
				return sys_setgrent();
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_endgrent", SetLastError = true)]
		private static extern int sys_endgrent();

		public static int endgrent()
		{
			lock (grp_lock)
			{
				return sys_endgrent();
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fgetgrent", SetLastError = true)]
		private static extern int sys_fgetgrent(IntPtr stream, out _Group grbuf);

		public static Group fgetgrent(IntPtr stream)
		{
			int num;
			_Group grbuf;
			lock (grp_lock)
			{
				num = sys_fgetgrent(stream, out grbuf);
			}
			if (num != 0)
			{
				return null;
			}
			Group obj = new Group();
			CopyGroup(obj, ref grbuf);
			return obj;
		}

		private static void CopyPasswd(Passwd to, ref _Passwd from)
		{
			try
			{
				to.pw_name = UnixMarshal.PtrToString(from.pw_name);
				to.pw_passwd = UnixMarshal.PtrToString(from.pw_passwd);
				to.pw_uid = from.pw_uid;
				to.pw_gid = from.pw_gid;
				to.pw_gecos = UnixMarshal.PtrToString(from.pw_gecos);
				to.pw_dir = UnixMarshal.PtrToString(from.pw_dir);
				to.pw_shell = UnixMarshal.PtrToString(from.pw_shell);
			}
			finally
			{
				Stdlib.free(from._pw_buf_);
				from._pw_buf_ = IntPtr.Zero;
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getpwnam", SetLastError = true)]
		private static extern int sys_getpwnam(string name, out _Passwd passwd);

		public static Passwd getpwnam(string name)
		{
			int num;
			_Passwd passwd;
			lock (pwd_lock)
			{
				num = sys_getpwnam(name, out passwd);
			}
			if (num != 0)
			{
				return null;
			}
			Passwd passwd2 = new Passwd();
			CopyPasswd(passwd2, ref passwd);
			return passwd2;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getpwuid", SetLastError = true)]
		private static extern int sys_getpwuid(uint uid, out _Passwd passwd);

		public static Passwd getpwuid(uint uid)
		{
			int num;
			_Passwd passwd;
			lock (pwd_lock)
			{
				num = sys_getpwuid(uid, out passwd);
			}
			if (num != 0)
			{
				return null;
			}
			Passwd passwd2 = new Passwd();
			CopyPasswd(passwd2, ref passwd);
			return passwd2;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getpwnam_r", SetLastError = true)]
		private static extern int sys_getpwnam_r([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string name, out _Passwd pwbuf, out IntPtr pwbufp);

		public static int getpwnam_r(string name, Passwd pwbuf, out Passwd pwbufp)
		{
			pwbufp = null;
			_Passwd pwbuf2;
			IntPtr pwbufp2;
			int num = sys_getpwnam_r(name, out pwbuf2, out pwbufp2);
			if (num == 0 && pwbufp2 != IntPtr.Zero)
			{
				CopyPasswd(pwbuf, ref pwbuf2);
				pwbufp = pwbuf;
			}
			return num;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getpwuid_r", SetLastError = true)]
		private static extern int sys_getpwuid_r(uint uid, out _Passwd pwbuf, out IntPtr pwbufp);

		public static int getpwuid_r(uint uid, Passwd pwbuf, out Passwd pwbufp)
		{
			pwbufp = null;
			_Passwd pwbuf2;
			IntPtr pwbufp2;
			int num = sys_getpwuid_r(uid, out pwbuf2, out pwbufp2);
			if (num == 0 && pwbufp2 != IntPtr.Zero)
			{
				CopyPasswd(pwbuf, ref pwbuf2);
				pwbufp = pwbuf;
			}
			return num;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getpwent", SetLastError = true)]
		private static extern int sys_getpwent(out _Passwd pwbuf);

		public static Passwd getpwent()
		{
			int num;
			_Passwd pwbuf;
			lock (pwd_lock)
			{
				num = sys_getpwent(out pwbuf);
			}
			if (num != 0)
			{
				return null;
			}
			Passwd passwd = new Passwd();
			CopyPasswd(passwd, ref pwbuf);
			return passwd;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_setpwent", SetLastError = true)]
		private static extern int sys_setpwent();

		public static int setpwent()
		{
			lock (pwd_lock)
			{
				return sys_setpwent();
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_endpwent", SetLastError = true)]
		private static extern int sys_endpwent();

		public static int endpwent()
		{
			lock (pwd_lock)
			{
				return sys_endpwent();
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fgetpwent", SetLastError = true)]
		private static extern int sys_fgetpwent(IntPtr stream, out _Passwd pwbuf);

		public static Passwd fgetpwent(IntPtr stream)
		{
			int num;
			_Passwd pwbuf;
			lock (pwd_lock)
			{
				num = sys_fgetpwent(stream, out pwbuf);
			}
			if (num != 0)
			{
				return null;
			}
			Passwd passwd = new Passwd();
			CopyPasswd(passwd, ref pwbuf);
			return passwd;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_psignal", SetLastError = true)]
		private static extern int psignal(int sig, string s);

		public static int psignal(Signum sig, string s)
		{
			int sig2 = NativeConvert.FromSignum(sig);
			return psignal(sig2, s);
		}

		[DllImport("libc", EntryPoint = "kill", SetLastError = true)]
		private static extern int sys_kill(int pid, int sig);

		public static int kill(int pid, Signum sig)
		{
			int sig2 = NativeConvert.FromSignum(sig);
			return sys_kill(pid, sig2);
		}

		[DllImport("libc", EntryPoint = "strsignal", SetLastError = true)]
		private static extern IntPtr sys_strsignal(int sig);

		public static string strsignal(Signum sig)
		{
			int sig2 = NativeConvert.FromSignum(sig);
			lock (signal_lock)
			{
				IntPtr p = sys_strsignal(sig2);
				return UnixMarshal.PtrToString(p);
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_L_ctermid")]
		private static extern int _L_ctermid();

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_L_cuserid")]
		private static extern int _L_cuserid();

		[DllImport("libc", EntryPoint = "cuserid", SetLastError = true)]
		private static extern IntPtr sys_cuserid([Out] StringBuilder @string);

		[Obsolete("\"Nobody knows precisely what cuserid() does... DO NOT USE cuserid().\n`string' must hold L_cuserid characters.  Use getlogin_r instead.")]
		public static string cuserid(StringBuilder @string)
		{
			if (@string.Capacity < L_cuserid)
			{
				throw new ArgumentOutOfRangeException("string", "string.Capacity < L_cuserid");
			}
			lock (getlogin_lock)
			{
				IntPtr p = sys_cuserid(@string);
				return UnixMarshal.PtrToString(p);
			}
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int mkstemp(StringBuilder template);

		[DllImport("libc", SetLastError = true)]
		public static extern int ttyslot();

		[Obsolete("This is insecure and should not be used", true)]
		public static int setkey(string key)
		{
			throw new SecurityException("crypt(3) has been broken.  Use something more secure.");
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_strerror_r", SetLastError = true)]
		private static extern int sys_strerror_r(int errnum, [Out] StringBuilder buf, ulong n);

		public static int strerror_r(Errno errnum, StringBuilder buf, ulong n)
		{
			int errnum2 = NativeConvert.FromErrno(errnum);
			return sys_strerror_r(errnum2, buf, n);
		}

		public static int strerror_r(Errno errnum, StringBuilder buf)
		{
			return strerror_r(errnum, buf, (ulong)buf.Capacity);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_posix_madvise", SetLastError = true)]
		public static extern int posix_madvise(IntPtr addr, ulong len, PosixMadviseAdvice advice);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_mmap", SetLastError = true)]
		public static extern IntPtr mmap(IntPtr start, ulong length, MmapProts prot, MmapFlags flags, int fd, long offset);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_munmap", SetLastError = true)]
		public static extern int munmap(IntPtr start, ulong length);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_mprotect", SetLastError = true)]
		public static extern int mprotect(IntPtr start, ulong len, MmapProts prot);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_msync", SetLastError = true)]
		public static extern int msync(IntPtr start, ulong len, MsyncFlags flags);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_mlock", SetLastError = true)]
		public static extern int mlock(IntPtr start, ulong len);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_munlock", SetLastError = true)]
		public static extern int munlock(IntPtr start, ulong len);

		[DllImport("libc", EntryPoint = "mlockall", SetLastError = true)]
		private static extern int sys_mlockall(int flags);

		public static int mlockall(MlockallFlags flags)
		{
			int flags2 = NativeConvert.FromMlockallFlags(flags);
			return sys_mlockall(flags2);
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int munlockall();

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_mremap", SetLastError = true)]
		public static extern IntPtr mremap(IntPtr old_address, ulong old_size, ulong new_size, MremapFlags flags);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_mincore", SetLastError = true)]
		public static extern int mincore(IntPtr start, ulong length, byte[] vec);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_remap_file_pages", SetLastError = true)]
		public static extern int remap_file_pages(IntPtr start, ulong size, MmapProts prot, long pgoff, MmapFlags flags);

		[DllImport("libc", EntryPoint = "poll", SetLastError = true)]
		private static extern int sys_poll(_pollfd[] ufds, uint nfds, int timeout);

		public static int poll(Pollfd[] fds, uint nfds, int timeout)
		{
			if (fds.Length < nfds)
			{
				throw new ArgumentOutOfRangeException("fds", "Must refer to at least `nfds' elements");
			}
			_pollfd[] array = new _pollfd[nfds];
			for (int i = 0; i < array.Length; i++)
			{
				array[i].fd = fds[i].fd;
				array[i].events = NativeConvert.FromPollEvents(fds[i].events);
			}
			int result = sys_poll(array, nfds, timeout);
			for (int j = 0; j < array.Length; j++)
			{
				fds[j].revents = NativeConvert.ToPollEvents(array[j].revents);
			}
			return result;
		}

		public static int poll(Pollfd[] fds, int timeout)
		{
			return poll(fds, (uint)fds.Length, timeout);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_sendfile", SetLastError = true)]
		public static extern long sendfile(int out_fd, int in_fd, ref long offset, ulong count);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_stat", SetLastError = true)]
		public static extern int stat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string file_name, out Stat buf);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fstat", SetLastError = true)]
		public static extern int fstat(int filedes, out Stat buf);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_lstat", SetLastError = true)]
		public static extern int lstat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string file_name, out Stat buf);

		[DllImport("libc", EntryPoint = "chmod", SetLastError = true)]
		private static extern int sys_chmod([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, uint mode);

		public static int chmod(string path, FilePermissions mode)
		{
			uint mode2 = NativeConvert.FromFilePermissions(mode);
			return sys_chmod(path, mode2);
		}

		[DllImport("libc", EntryPoint = "fchmod", SetLastError = true)]
		private static extern int sys_fchmod(int filedes, uint mode);

		public static int fchmod(int filedes, FilePermissions mode)
		{
			uint mode2 = NativeConvert.FromFilePermissions(mode);
			return sys_fchmod(filedes, mode2);
		}

		[DllImport("libc", EntryPoint = "umask", SetLastError = true)]
		private static extern uint sys_umask(uint mask);

		public static FilePermissions umask(FilePermissions mask)
		{
			uint mask2 = NativeConvert.FromFilePermissions(mask);
			uint value = sys_umask(mask2);
			return NativeConvert.ToFilePermissions(value);
		}

		[DllImport("libc", EntryPoint = "mkdir", SetLastError = true)]
		private static extern int sys_mkdir([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string oldpath, uint mode);

		public static int mkdir(string oldpath, FilePermissions mode)
		{
			uint mode2 = NativeConvert.FromFilePermissions(mode);
			return sys_mkdir(oldpath, mode2);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_mknod", SetLastError = true)]
		public static extern int mknod([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname, FilePermissions mode, ulong dev);

		[DllImport("libc", EntryPoint = "mkfifo", SetLastError = true)]
		private static extern int sys_mkfifo([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname, uint mode);

		public static int mkfifo(string pathname, FilePermissions mode)
		{
			uint mode2 = NativeConvert.FromFilePermissions(mode);
			return sys_mkfifo(pathname, mode2);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_statvfs", SetLastError = true)]
		public static extern int statvfs([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, out Statvfs buf);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fstatvfs", SetLastError = true)]
		public static extern int fstatvfs(int fd, out Statvfs buf);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_gettimeofday", SetLastError = true)]
		public static extern int gettimeofday(out Timeval tv, out Timezone tz);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_gettimeofday", SetLastError = true)]
		private static extern int gettimeofday(out Timeval tv, IntPtr ignore);

		public static int gettimeofday(out Timeval tv)
		{
			return gettimeofday(out tv, IntPtr.Zero);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_gettimeofday", SetLastError = true)]
		private static extern int gettimeofday(IntPtr ignore, out Timezone tz);

		public static int gettimeofday(out Timezone tz)
		{
			return gettimeofday(IntPtr.Zero, out tz);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_settimeofday", SetLastError = true)]
		public static extern int settimeofday(ref Timeval tv, ref Timezone tz);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_gettimeofday", SetLastError = true)]
		private static extern int settimeofday(ref Timeval tv, IntPtr ignore);

		public static int settimeofday(ref Timeval tv)
		{
			return settimeofday(ref tv, IntPtr.Zero);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_utimes", SetLastError = true)]
		private static extern int sys_utimes([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string filename, Timeval[] tvp);

		public static int utimes(string filename, Timeval[] tvp)
		{
			if (tvp != null && tvp.Length != 2)
			{
				Stdlib.SetLastError(Errno.EINVAL);
				return -1;
			}
			return sys_utimes(filename, tvp);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_lutimes", SetLastError = true)]
		private static extern int sys_lutimes([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string filename, Timeval[] tvp);

		public static int lutimes(string filename, Timeval[] tvp)
		{
			if (tvp != null && tvp.Length != 2)
			{
				Stdlib.SetLastError(Errno.EINVAL);
				return -1;
			}
			return sys_lutimes(filename, tvp);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_futimes", SetLastError = true)]
		private static extern int sys_futimes(int fd, Timeval[] tvp);

		public static int futimes(int fd, Timeval[] tvp)
		{
			if (tvp != null && tvp.Length != 2)
			{
				Stdlib.SetLastError(Errno.EINVAL);
				return -1;
			}
			return sys_futimes(fd, tvp);
		}

		private static void CopyUtsname(ref Utsname to, ref _Utsname from)
		{
			try
			{
				to = new Utsname();
				to.sysname = UnixMarshal.PtrToString(from.sysname);
				to.nodename = UnixMarshal.PtrToString(from.nodename);
				to.release = UnixMarshal.PtrToString(from.release);
				to.version = UnixMarshal.PtrToString(from.version);
				to.machine = UnixMarshal.PtrToString(from.machine);
				to.domainname = UnixMarshal.PtrToString(from.domainname);
			}
			finally
			{
				Stdlib.free(from._buf_);
				from._buf_ = IntPtr.Zero;
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_uname", SetLastError = true)]
		private static extern int sys_uname(out _Utsname buf);

		public static int uname(out Utsname buf)
		{
			_Utsname buf2;
			int num = sys_uname(out buf2);
			buf = new Utsname();
			if (num == 0)
			{
				CopyUtsname(ref buf, ref buf2);
			}
			return num;
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int wait(out int status);

		[DllImport("libc", SetLastError = true)]
		private static extern int waitpid(int pid, out int status, int options);

		public static int waitpid(int pid, out int status, WaitOptions options)
		{
			int options2 = NativeConvert.FromWaitOptions(options);
			return waitpid(pid, out status, options2);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_WIFEXITED")]
		private static extern int _WIFEXITED(int status);

		public static bool WIFEXITED(int status)
		{
			return _WIFEXITED(status) != 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_WEXITSTATUS")]
		public static extern int WEXITSTATUS(int status);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_WIFSIGNALED")]
		private static extern int _WIFSIGNALED(int status);

		public static bool WIFSIGNALED(int status)
		{
			return _WIFSIGNALED(status) != 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_WTERMSIG")]
		private static extern int _WTERMSIG(int status);

		public static Signum WTERMSIG(int status)
		{
			int value = _WTERMSIG(status);
			return NativeConvert.ToSignum(value);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_WIFSTOPPED")]
		private static extern int _WIFSTOPPED(int status);

		public static bool WIFSTOPPED(int status)
		{
			return _WIFSTOPPED(status) != 0;
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_WSTOPSIG")]
		private static extern int _WSTOPSIG(int status);

		public static Signum WSTOPSIG(int status)
		{
			int value = _WSTOPSIG(status);
			return NativeConvert.ToSignum(value);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_openlog", SetLastError = true)]
		private static extern int sys_openlog(IntPtr ident, int option, int facility);

		public static int openlog(IntPtr ident, SyslogOptions option, SyslogFacility defaultFacility)
		{
			int option2 = NativeConvert.FromSyslogOptions(option);
			int facility = NativeConvert.FromSyslogFacility(defaultFacility);
			return sys_openlog(ident, option2, facility);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_syslog", SetLastError = true)]
		private static extern int sys_syslog(int priority, string message);

		public static int syslog(SyslogFacility facility, SyslogLevel level, string message)
		{
			int num = NativeConvert.FromSyslogFacility(facility);
			int num2 = NativeConvert.FromSyslogLevel(level);
			return sys_syslog(num | num2, GetSyslogMessage(message));
		}

		public static int syslog(SyslogLevel level, string message)
		{
			int priority = NativeConvert.FromSyslogLevel(level);
			return sys_syslog(priority, GetSyslogMessage(message));
		}

		private static string GetSyslogMessage(string message)
		{
			return UnixMarshal.EscapeFormatString(message, new char[1] { 'm' });
		}

		[Obsolete("Not necessarily portable due to cdecl restrictions.\nUse syslog(SyslogFacility, SyslogLevel, string) instead.")]
		public static int syslog(SyslogFacility facility, SyslogLevel level, string format, params object[] parameters)
		{
			int num = NativeConvert.FromSyslogFacility(facility);
			int num2 = NativeConvert.FromSyslogLevel(level);
			object[] array = new object[checked(parameters.Length + 2)];
			array[0] = num | num2;
			array[1] = format;
			Array.Copy(parameters, 0, array, 2, parameters.Length);
			return (int)XPrintfFunctions.syslog(array);
		}

		[Obsolete("Not necessarily portable due to cdecl restrictions.\nUse syslog(SyslogLevel, string) instead.")]
		public static int syslog(SyslogLevel level, string format, params object[] parameters)
		{
			int num = NativeConvert.FromSyslogLevel(level);
			object[] array = new object[checked(parameters.Length + 2)];
			array[0] = num;
			array[1] = format;
			Array.Copy(parameters, 0, array, 2, parameters.Length);
			return (int)XPrintfFunctions.syslog(array);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_closelog", SetLastError = true)]
		public static extern int closelog();

		[DllImport("libc", EntryPoint = "setlogmask", SetLastError = true)]
		private static extern int sys_setlogmask(int mask);

		public static int setlogmask(SyslogLevel mask)
		{
			int mask2 = NativeConvert.FromSyslogLevel(mask);
			return sys_setlogmask(mask2);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_nanosleep", SetLastError = true)]
		public static extern int nanosleep(ref Timespec req, ref Timespec rem);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_stime", SetLastError = true)]
		public static extern int stime(ref long t);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_time", SetLastError = true)]
		public static extern long time(out long t);

		[DllImport("libc", EntryPoint = "access", SetLastError = true)]
		private static extern int sys_access([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname, int mode);

		public static int access(string pathname, AccessModes mode)
		{
			int mode2 = NativeConvert.FromAccessModes(mode);
			return sys_access(pathname, mode2);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_lseek", SetLastError = true)]
		private static extern long sys_lseek(int fd, long offset, int whence);

		public static long lseek(int fd, long offset, SeekFlags whence)
		{
			short whence2 = NativeConvert.FromSeekFlags(whence);
			return sys_lseek(fd, offset, whence2);
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int close(int fd);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_read", SetLastError = true)]
		public static extern long read(int fd, IntPtr buf, ulong count);

		public unsafe static long read(int fd, void* buf, ulong count)
		{
			return read(fd, (IntPtr)buf, count);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_write", SetLastError = true)]
		public static extern long write(int fd, IntPtr buf, ulong count);

		public unsafe static long write(int fd, void* buf, ulong count)
		{
			return write(fd, (IntPtr)buf, count);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_pread", SetLastError = true)]
		public static extern long pread(int fd, IntPtr buf, ulong count, long offset);

		public unsafe static long pread(int fd, void* buf, ulong count, long offset)
		{
			return pread(fd, (IntPtr)buf, count, offset);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_pwrite", SetLastError = true)]
		public static extern long pwrite(int fd, IntPtr buf, ulong count, long offset);

		public unsafe static long pwrite(int fd, void* buf, ulong count, long offset)
		{
			return pwrite(fd, (IntPtr)buf, count, offset);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_pipe", SetLastError = true)]
		public static extern int pipe(out int reading, out int writing);

		public static int pipe(int[] filedes)
		{
			if (filedes == null || filedes.Length != 2)
			{
				return -1;
			}
			int reading;
			int writing;
			int result = pipe(out reading, out writing);
			filedes[0] = reading;
			filedes[1] = writing;
			return result;
		}

		[DllImport("libc", SetLastError = true)]
		public static extern uint alarm(uint seconds);

		[DllImport("libc", SetLastError = true)]
		public static extern uint sleep(uint seconds);

		[DllImport("libc", SetLastError = true)]
		public static extern uint ualarm(uint usecs, uint interval);

		[DllImport("libc", SetLastError = true)]
		public static extern int pause();

		[DllImport("libc", SetLastError = true)]
		public static extern int chown([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, uint owner, uint group);

		[DllImport("libc", SetLastError = true)]
		public static extern int fchown(int fd, uint owner, uint group);

		[DllImport("libc", SetLastError = true)]
		public static extern int lchown([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, uint owner, uint group);

		[DllImport("libc", SetLastError = true)]
		public static extern int chdir([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path);

		[DllImport("libc", SetLastError = true)]
		public static extern int fchdir(int fd);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getcwd", SetLastError = true)]
		public static extern IntPtr getcwd([Out] StringBuilder buf, ulong size);

		public static StringBuilder getcwd(StringBuilder buf)
		{
			getcwd(buf, (ulong)buf.Capacity);
			return buf;
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int dup(int fd);

		[DllImport("libc", SetLastError = true)]
		public static extern int dup2(int fd, int fd2);

		[DllImport("libc", SetLastError = true)]
		public static extern int execve([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, string[] argv, string[] envp);

		[DllImport("libc", SetLastError = true)]
		public static extern int fexecve(int fd, string[] argv, string[] envp);

		[DllImport("libc", SetLastError = true)]
		public static extern int execv([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, string[] argv);

		[DllImport("libc", SetLastError = true)]
		public static extern int execvp([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, string[] argv);

		[DllImport("libc", SetLastError = true)]
		public static extern int nice(int inc);

		[DllImport("libc", SetLastError = true)]
		[CLSCompliant(false)]
		public static extern int _exit(int status);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_fpathconf", SetLastError = true)]
		public static extern long fpathconf(int filedes, PathconfName name, Errno defaultError);

		public static long fpathconf(int filedes, PathconfName name)
		{
			return fpathconf(filedes, name, (Errno)0);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_pathconf", SetLastError = true)]
		public static extern long pathconf([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, PathconfName name, Errno defaultError);

		public static long pathconf(string path, PathconfName name)
		{
			return pathconf(path, name, (Errno)0);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_sysconf", SetLastError = true)]
		public static extern long sysconf(SysconfName name, Errno defaultError);

		public static long sysconf(SysconfName name)
		{
			return sysconf(name, (Errno)0);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_confstr", SetLastError = true)]
		public static extern ulong confstr(ConfstrName name, [Out] StringBuilder buf, ulong len);

		[DllImport("libc", SetLastError = true)]
		public static extern int getpid();

		[DllImport("libc", SetLastError = true)]
		public static extern int getppid();

		[DllImport("libc", SetLastError = true)]
		public static extern int setpgid(int pid, int pgid);

		[DllImport("libc", SetLastError = true)]
		public static extern int getpgid(int pid);

		[DllImport("libc", SetLastError = true)]
		public static extern int setpgrp();

		[DllImport("libc", SetLastError = true)]
		public static extern int getpgrp();

		[DllImport("libc", SetLastError = true)]
		public static extern int setsid();

		[DllImport("libc", SetLastError = true)]
		public static extern int getsid(int pid);

		[DllImport("libc", SetLastError = true)]
		public static extern uint getuid();

		[DllImport("libc", SetLastError = true)]
		public static extern uint geteuid();

		[DllImport("libc", SetLastError = true)]
		public static extern uint getgid();

		[DllImport("libc", SetLastError = true)]
		public static extern uint getegid();

		[DllImport("libc", SetLastError = true)]
		public static extern int getgroups(int size, uint[] list);

		public static int getgroups(uint[] list)
		{
			return getgroups(list.Length, list);
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int setuid(uint uid);

		[DllImport("libc", SetLastError = true)]
		public static extern int setreuid(uint ruid, uint euid);

		[DllImport("libc", SetLastError = true)]
		public static extern int setregid(uint rgid, uint egid);

		[DllImport("libc", SetLastError = true)]
		public static extern int seteuid(uint euid);

		[DllImport("libc", SetLastError = true)]
		public static extern int setegid(uint uid);

		[DllImport("libc", SetLastError = true)]
		public static extern int setgid(uint gid);

		[DllImport("libc", SetLastError = true)]
		public static extern int getresuid(out uint ruid, out uint euid, out uint suid);

		[DllImport("libc", SetLastError = true)]
		public static extern int getresgid(out uint rgid, out uint egid, out uint sgid);

		[DllImport("libc", SetLastError = true)]
		public static extern int setresuid(uint ruid, uint euid, uint suid);

		[DllImport("libc", SetLastError = true)]
		public static extern int setresgid(uint rgid, uint egid, uint sgid);

		[DllImport("libc", EntryPoint = "ttyname", SetLastError = true)]
		private static extern IntPtr sys_ttyname(int fd);

		public static string ttyname(int fd)
		{
			lock (tty_lock)
			{
				IntPtr p = sys_ttyname(fd);
				return UnixMarshal.PtrToString(p);
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_ttyname_r", SetLastError = true)]
		public static extern int ttyname_r(int fd, [Out] StringBuilder buf, ulong buflen);

		public static int ttyname_r(int fd, StringBuilder buf)
		{
			return ttyname_r(fd, buf, (ulong)buf.Capacity);
		}

		[DllImport("libc", EntryPoint = "isatty")]
		private static extern int sys_isatty(int fd);

		public static bool isatty(int fd)
		{
			return sys_isatty(fd) == 1;
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int link([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string oldpath, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string newpath);

		[DllImport("libc", SetLastError = true)]
		public static extern int symlink([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string oldpath, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string newpath);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_readlink", SetLastError = true)]
		public static extern int readlink([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, [Out] StringBuilder buf, ulong bufsiz);

		public static int readlink(string path, [Out] StringBuilder buf)
		{
			return readlink(path, buf, (ulong)buf.Capacity);
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int unlink([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname);

		[DllImport("libc", SetLastError = true)]
		public static extern int rmdir([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string pathname);

		[DllImport("libc", SetLastError = true)]
		public static extern int tcgetpgrp(int fd);

		[DllImport("libc", SetLastError = true)]
		public static extern int tcsetpgrp(int fd, int pgrp);

		[DllImport("libc", EntryPoint = "getlogin", SetLastError = true)]
		private static extern IntPtr sys_getlogin();

		public static string getlogin()
		{
			lock (getlogin_lock)
			{
				IntPtr p = sys_getlogin();
				return UnixMarshal.PtrToString(p);
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getlogin_r", SetLastError = true)]
		public static extern int getlogin_r([Out] StringBuilder name, ulong bufsize);

		public static int getlogin_r(StringBuilder name)
		{
			return getlogin_r(name, (ulong)name.Capacity);
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int setlogin(string name);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_gethostname", SetLastError = true)]
		public static extern int gethostname([Out] StringBuilder name, ulong len);

		public static int gethostname(StringBuilder name)
		{
			return gethostname(name, (ulong)name.Capacity);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_sethostname", SetLastError = true)]
		public static extern int sethostname(string name, ulong len);

		public static int sethostname(string name)
		{
			return sethostname(name, (ulong)name.Length);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_gethostid", SetLastError = true)]
		public static extern long gethostid();

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_sethostid", SetLastError = true)]
		public static extern int sethostid(long hostid);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_getdomainname", SetLastError = true)]
		public static extern int getdomainname([Out] StringBuilder name, ulong len);

		public static int getdomainname(StringBuilder name)
		{
			return getdomainname(name, (ulong)name.Capacity);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_setdomainname", SetLastError = true)]
		public static extern int setdomainname(string name, ulong len);

		public static int setdomainname(string name)
		{
			return setdomainname(name, (ulong)name.Length);
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int vhangup();

		[DllImport("libc", SetLastError = true)]
		public static extern int revoke([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string file);

		[DllImport("libc", SetLastError = true)]
		public static extern int acct([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string filename);

		[DllImport("libc", EntryPoint = "getusershell", SetLastError = true)]
		private static extern IntPtr sys_getusershell();

		public static string getusershell()
		{
			lock (usershell_lock)
			{
				IntPtr p = sys_getusershell();
				return UnixMarshal.PtrToString(p);
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_setusershell", SetLastError = true)]
		private static extern int sys_setusershell();

		public static int setusershell()
		{
			lock (usershell_lock)
			{
				return sys_setusershell();
			}
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_endusershell", SetLastError = true)]
		private static extern int sys_endusershell();

		public static int endusershell()
		{
			lock (usershell_lock)
			{
				return sys_endusershell();
			}
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int chroot([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path);

		[DllImport("libc", SetLastError = true)]
		public static extern int fsync(int fd);

		[DllImport("libc", SetLastError = true)]
		public static extern int fdatasync(int fd);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_sync", SetLastError = true)]
		public static extern int sync();

		[DllImport("libc", SetLastError = true)]
		[Obsolete("Dropped in POSIX 1003.1-2001.  Use Syscall.sysconf (SysconfName._SC_PAGESIZE).")]
		public static extern int getpagesize();

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_truncate", SetLastError = true)]
		public static extern int truncate([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string path, long length);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_ftruncate", SetLastError = true)]
		public static extern int ftruncate(int fd, long length);

		[DllImport("libc", SetLastError = true)]
		public static extern int getdtablesize();

		[DllImport("libc", SetLastError = true)]
		public static extern int brk(IntPtr end_data_segment);

		[DllImport("libc", SetLastError = true)]
		public static extern IntPtr sbrk(IntPtr increment);

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_lockf", SetLastError = true)]
		public static extern int lockf(int fd, LockfCommand cmd, long len);

		[Obsolete("This is insecure and should not be used", true)]
		public static string crypt(string key, string salt)
		{
			throw new SecurityException("crypt(3) has been broken.  Use something more secure.");
		}

		[Obsolete("This is insecure and should not be used", true)]
		public static int encrypt(byte[] block, bool decode)
		{
			throw new SecurityException("crypt(3) has been broken.  Use something more secure.");
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_swab", SetLastError = true)]
		public static extern int swab(IntPtr from, IntPtr to, long n);

		public unsafe static void swab(void* from, void* to, long n)
		{
			swab((IntPtr)from, (IntPtr)to, n);
		}

		[DllImport("MonoPosixHelper", EntryPoint = "Mono_Posix_Syscall_utime", SetLastError = true)]
		private static extern int sys_utime([MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Mono.Unix.Native.FileNameMarshaler")] string filename, ref Utimbuf buf, int use_buf);

		public static int utime(string filename, ref Utimbuf buf)
		{
			return sys_utime(filename, ref buf, 1);
		}

		public static int utime(string filename)
		{
			Utimbuf buf = default(Utimbuf);
			return sys_utime(filename, ref buf, 0);
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	internal class blkcnt_tAttribute : MapAttribute
	{
		public blkcnt_tAttribute()
			: base("blkcnt_t")
		{
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	internal class blksize_tAttribute : MapAttribute
	{
		public blksize_tAttribute()
			: base("blksize_t")
		{
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	internal class dev_tAttribute : MapAttribute
	{
		public dev_tAttribute()
			: base("dev_t")
		{
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	internal class gid_tAttribute : MapAttribute
	{
		public gid_tAttribute()
			: base("gid_t")
		{
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	internal class fsblkcnt_tAttribute : MapAttribute
	{
		public fsblkcnt_tAttribute()
			: base("fsblkcnt_t")
		{
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	internal class fsfilcnt_tAttribute : MapAttribute
	{
		public fsfilcnt_tAttribute()
			: base("fsfilcnt_t")
		{
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	internal class ino_tAttribute : MapAttribute
	{
		public ino_tAttribute()
			: base("ino_t")
		{
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	internal class nlink_tAttribute : MapAttribute
	{
		public nlink_tAttribute()
			: base("nlink_t")
		{
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	internal class off_tAttribute : MapAttribute
	{
		public off_tAttribute()
			: base("off_t")
		{
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	internal class pid_tAttribute : MapAttribute
	{
		public pid_tAttribute()
			: base("pid_t")
		{
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	internal class suseconds_tAttribute : MapAttribute
	{
		public suseconds_tAttribute()
			: base("suseconds_t")
		{
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	internal class uid_tAttribute : MapAttribute
	{
		public uid_tAttribute()
			: base("uid_t")
		{
		}
	}
	[AttributeUsage(AttributeTargets.Field)]
	internal class time_tAttribute : MapAttribute
	{
		public time_tAttribute()
			: base("time_t")
		{
		}
	}
}
namespace Mono.Posix
{
	[Obsolete("Use Mono.Unix.Catalog")]
	public class Catalog
	{
		[DllImport("intl")]
		private static extern IntPtr bindtextdomain(IntPtr domainname, IntPtr dirname);

		[DllImport("intl")]
		private static extern IntPtr bind_textdomain_codeset(IntPtr domainname, IntPtr codeset);

		[DllImport("intl")]
		private static extern IntPtr textdomain(IntPtr domainname);

		public static void Init(string package, string localedir)
		{
			IntPtr intPtr = Marshal.StringToHGlobalAuto(package);
			IntPtr intPtr2 = Marshal.StringToHGlobalAuto(localedir);
			IntPtr intPtr3 = Marshal.StringToHGlobalAuto("UTF-8");
			bindtextdomain(intPtr, intPtr2);
			bind_textdomain_codeset(intPtr, intPtr3);
			textdomain(intPtr);
			Marshal.FreeHGlobal(intPtr);
			Marshal.FreeHGlobal(intPtr2);
			Marshal.FreeHGlobal(intPtr3);
		}

		[DllImport("intl")]
		private static extern IntPtr gettext(IntPtr instring);

		public static string GetString(string s)
		{
			IntPtr intPtr = Marshal.StringToHGlobalAuto(s);
			string result = Marshal.PtrToStringAuto(gettext(intPtr));
			Marshal.FreeHGlobal(intPtr);
			return result;
		}

		[DllImport("intl")]
		private static extern IntPtr ngettext(IntPtr singular, IntPtr plural, int n);

		public static string GetPluralString(string s, string p, int n)
		{
			IntPtr intPtr = Marshal.StringToHGlobalAuto(s);
			IntPtr intPtr2 = Marshal.StringToHGlobalAuto(p);
			string result = Marshal.PtrToStringAnsi(ngettext(intPtr, intPtr2, n));
			Marshal.FreeHGlobal(intPtr);
			Marshal.FreeHGlobal(intPtr2);
			return result;
		}
	}
	internal struct PeerCredData
	{
		public int pid;

		public int uid;

		public int gid;
	}
	[Obsolete("Use Mono.Unix.PeerCred")]
	public class PeerCred
	{
		private const int so_peercred = 10001;

		private PeerCredData data;

		public int ProcessID => data.pid;

		public int UserID => data.uid;

		public int GroupID => data.gid;

		public PeerCred(Socket sock)
		{
			if (sock.AddressFamily != AddressFamily.Unix)
			{
				throw new ArgumentException("Only Unix sockets are supported", "sock");
			}
			data = (PeerCredData)sock.GetSocketOption(SocketOptionLevel.Socket, (SocketOptionName)10001);
		}
	}
	[Obsolete("Use Mono.Unix.Native.OpenFlags")]
	[CLSCompliant(false)]
	[Flags]
	public enum OpenFlags
	{
		O_RDONLY = 0,
		O_WRONLY = 1,
		O_RDWR = 2,
		O_CREAT = 4,
		O_EXCL = 8,
		O_NOCTTY = 0x10,
		O_TRUNC = 0x20,
		O_APPEND = 0x40,
		O_NONBLOCK = 0x80,
		O_SYNC = 0x100
	}
	[Obsolete("Use Mono.Unix.Native.FilePermissions")]
	[Flags]
	[CLSCompliant(false)]
	public enum FileMode
	{
		S_ISUID = 0x800,
		S_ISGID = 0x400,
		S_ISVTX = 0x200,
		S_IRUSR = 0x100,
		S_IWUSR = 0x80,
		S_IXUSR = 0x40,
		S_IRGRP = 0x20,
		S_IWGRP = 0x10,
		S_IXGRP = 8,
		S_IROTH = 4,
		S_IWOTH = 2,
		S_IXOTH = 1
	}
	[Flags]
	[Obsolete("Use Mono.Unix.Native.WaitOptions")]
	[CLSCompliant(false)]
	public enum WaitOptions
	{
		WNOHANG = 0,
		WUNTRACED = 1
	}
	[Flags]
	[CLSCompliant(false)]
	[Obsolete("Use Mono.Unix.Native.AccessModes")]
	public enum AccessMode
	{
		R_OK = 1,
		W_OK = 2,
		X_OK = 4,
		F_OK = 8
	}
	[Obsolete("Use Mono.Unix.Native.Signum")]
	[CLSCompliant(false)]
	public enum Signals
	{
		SIGHUP,
		SIGINT,
		SIGQUIT,
		SIGILL,
		SIGTRAP,
		SIGABRT,
		SIGBUS,
		SIGFPE,
		SIGKILL,
		SIGUSR1,
		SIGSEGV,
		SIGUSR2,
		SIGPIPE,
		SIGALRM,
		SIGTERM,
		SIGCHLD,
		SIGCONT,
		SIGSTOP,
		SIGTSTP,
		SIGTTIN,
		SIGTTOU,
		SIGURG,
		SIGXCPU,
		SIGXFSZ,
		SIGVTALRM,
		SIGPROF,
		SIGWINCH,
		SIGIO,
		SIGSYS
	}
	[CLSCompliant(false)]
	[Obsolete("Use Mono.Unix.Native.Syscall.")]
	public class Syscall
	{
		public delegate void sighandler_t(int v);

		[DllImport("libc", SetLastError = true)]
		public static extern int exit(int status);

		[DllImport("libc", SetLastError = true)]
		public static extern int fork();

		[DllImport("libc", SetLastError = true)]
		public unsafe static extern IntPtr read(int fileDescriptor, void* buf, IntPtr count);

		[DllImport("libc", SetLastError = true)]
		public unsafe static extern IntPtr write(int fileDescriptor, void* buf, IntPtr count);

		[DllImport("libc", EntryPoint = "open", SetLastError = true)]
		internal static extern int syscall_open(string pathname, int flags, int mode);

		[DllImport("MonoPosixHelper")]
		internal static extern int map_Mono_Posix_OpenFlags(OpenFlags flags);

		[DllImport("MonoPosixHelper")]
		internal static extern int map_Mono_Posix_FileMode(FileMode mode);

		public static int open(string pathname, OpenFlags flags)
		{
			if ((flags & OpenFlags.O_CREAT) != OpenFlags.O_RDONLY)
			{
				throw new ArgumentException("If you pass O_CREAT, you must call the method with the mode flag");
			}
			int flags2 = map_Mono_Posix_OpenFlags(flags);
			return syscall_open(pathname, flags2, 0);
		}

		public static int open(string pathname, OpenFlags flags, FileMode mode)
		{
			int flags2 = map_Mono_Posix_OpenFlags(flags);
			int mode2 = map_Mono_Posix_FileMode(mode);
			return syscall_open(pathname, flags2, mode2);
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int close(int fileDescriptor);

		[DllImport("libc", EntryPoint = "waitpid", SetLastError = true)]
		internal unsafe static extern int syscall_waitpid(int pid, int* status, int options);

		[DllImport("MonoPosixHelper")]
		internal static extern int map_Mono_Posix_WaitOptions(WaitOptions wait_options);

		public unsafe static int waitpid(int pid, out int status, WaitOptions options)
		{
			int num = 0;
			int result = syscall_waitpid(pid, &num, map_Mono_Posix_WaitOptions(options));
			status = num;
			return result;
		}

		public unsafe static int waitpid(int pid, WaitOptions options)
		{
			return syscall_waitpid(pid, null, map_Mono_Posix_WaitOptions(options));
		}

		[DllImport("MonoPosixHelper", EntryPoint = "wifexited")]
		public static extern int WIFEXITED(int status);

		[DllImport("MonoPosixHelper", EntryPoint = "wexitstatus")]
		public static extern int WEXITSTATUS(int status);

		[DllImport("MonoPosixHelper", EntryPoint = "wifsignaled")]
		public static extern int WIFSIGNALED(int status);

		[DllImport("MonoPosixHelper", EntryPoint = "wtermsig")]
		public static extern int WTERMSIG(int status);

		[DllImport("MonoPosixHelper", EntryPoint = "wifstopped")]
		public static extern int WIFSTOPPED(int status);

		[DllImport("MonoPosixHelper", EntryPoint = "wstopsig")]
		public static extern int WSTOPSIG(int status);

		[DllImport("libc", EntryPoint = "creat", SetLastError = true)]
		internal static extern int syscall_creat(string pathname, int flags);

		public static int creat(string pathname, FileMode flags)
		{
			return syscall_creat(pathname, map_Mono_Posix_FileMode(flags));
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int link(string oldPath, string newPath);

		[DllImport("libc", SetLastError = true)]
		public static extern int unlink(string path);

		[DllImport("libc", SetLastError = true)]
		public static extern int symlink(string oldpath, string newpath);

		[DllImport("libc", SetLastError = true)]
		public static extern int chdir(string path);

		[DllImport("libc", EntryPoint = "chmod", SetLastError = true)]
		internal static extern int syscall_chmod(string path, int mode);

		public static int chmod(string path, FileMode mode)
		{
			return syscall_chmod(path, map_Mono_Posix_FileMode(mode));
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int chown(string path, int owner, int group);

		[DllImport("libc", SetLastError = true)]
		public static extern int lchown(string path, int owner, int group);

		[DllImport("libc", SetLastError = true)]
		public static extern int lseek(int fileDescriptor, int offset, int whence);

		[DllImport("libc", SetLastError = true)]
		public static extern int getpid();

		[DllImport("libc", SetLastError = true)]
		public static extern int setuid(int uid);

		[DllImport("libc", SetLastError = true)]
		public static extern int getuid();

		[DllImport("libc")]
		public static extern uint alarm(uint seconds);

		[DllImport("libc", SetLastError = true)]
		public static extern int pause();

		[DllImport("libc", EntryPoint = "access", SetLastError = true)]
		internal static extern int syscall_access(string pathname, int mode);

		[DllImport("MonoPosixHelper")]
		internal static extern int map_Mono_Posix_AccessMode(AccessMode mode);

		public static int access(string pathname, AccessMode mode)
		{
			return syscall_access(pathname, map_Mono_Posix_AccessMode(mode));
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int nice(int increment);

		[DllImport("libc")]
		public static extern void sync();

		[DllImport("libc", SetLastError = true)]
		public static extern void kill(int pid, int sig);

		[DllImport("libc", SetLastError = true)]
		public static extern int rename(string oldPath, string newPath);

		[DllImport("libc", EntryPoint = "mkdir", SetLastError = true)]
		internal static extern int syscall_mkdir(string pathname, int mode);

		public static int mkdir(string pathname, FileMode mode)
		{
			return syscall_mkdir(pathname, map_Mono_Posix_FileMode(mode));
		}

		[DllImport("libc", SetLastError = true)]
		public static extern int rmdir(string path);

		[DllImport("libc", SetLastError = true)]
		public static extern int dup(int fileDescriptor);

		[DllImport("libc", SetLastError = true)]
		public static extern int setgid(int gid);

		[DllImport("libc", SetLastError = true)]
		public static extern int getgid();

		[DllImport("libc", SetLastError = true)]
		public static extern int signal(int signum, sighandler_t handler);

		[DllImport("libc", SetLastError = true)]
		public static extern int geteuid();

		[DllImport("libc", SetLastError = true)]
		public static extern int getegid();

		[DllImport("libc", SetLastError = true)]
		public static extern int setpgid(int pid, int pgid);

		[DllImport("libc")]
		public static extern int umask(int umask);

		[DllImport("libc", SetLastError = true)]
		public static extern int chroot(string path);

		[DllImport("libc", SetLastError = true)]
		public static extern int dup2(int oldFileDescriptor, int newFileDescriptor);

		[DllImport("libc", SetLastError = true)]
		public static extern int getppid();

		[DllImport("libc", SetLastError = true)]
		public static extern int getpgrp();

		[DllImport("libc", SetLastError = true)]
		public static extern int setsid();

		[DllImport("libc", SetLastError = true)]
		public static extern int setreuid(int ruid, int euid);

		[DllImport("libc", SetLastError = true)]
		public static extern int setregid(int rgid, int egid);

		[DllImport("MonoPosixHelper", SetLastError = true)]
		private static extern string helper_Mono_Posix_GetUserName(int uid);

		[DllImport("MonoPosixHelper", SetLastError = true)]
		private static extern string helper_Mono_Posix_GetGroupName(int gid);

		public static string getusername(int uid)
		{
			return helper_Mono_Posix_GetUserName(uid);
		}

		public static string getgroupname(int gid)
		{
			return helper_Mono_Posix_GetGroupName(gid);
		}

		[DllImport("libc", EntryPoint = "gethostname", SetLastError = true)]
		private static extern int syscall_gethostname(byte[] p, int len);

		public static string GetHostName()
		{
			byte[] array = new byte[256];
			int num = syscall_gethostname(array, array.Length);
			if (num == -1)
			{
				return "localhost";
			}
			for (num = 0; num < array.Length && array[num] != 0; num++)
			{
			}
			return Encoding.UTF8.GetString(array, 0, num);
		}

		[CLSCompliant(false)]
		public static string gethostname()
		{
			return GetHostName();
		}

		[DllImport("libc", EntryPoint = "isatty")]
		private static extern int syscall_isatty(int desc);

		public static bool isatty(int desc)
		{
			int num = syscall_isatty(desc);
			if (num == 1)
			{
				return true;
			}
			return false;
		}

		[DllImport("MonoPosixHelper")]
		internal static extern int helper_Mono_Posix_Stat(string filename, bool dereference, out int device, out int inode, out int mode, out int nlinks, out int uid, out int gid, out int rdev, out long size, out long blksize, out long blocks, out long atime, out long mtime, out long ctime);

		private static int stat2(string filename, bool dereference, out Stat stat)
		{
			int device;
			int inode;
			int mode;
			int nlinks;
			int uid;
			int gid;
			int rdev;
			long size;
			long blksize;
			long blocks;
			long atime;
			long mtime;
			long ctime;
			int num = helper_Mono_Posix_Stat(filename, dereference, out device, out inode, out mode, out nlinks, out uid, out gid, out rdev, out size, out blksize, out blocks, out atime, out mtime, out ctime);
			stat = new Stat(device, inode, mode, nlinks, uid, gid, rdev, size, blksize, blocks, atime, mtime, ctime);
			if (num != 0)
			{
				return num;
			}
			return 0;
		}

		public static int stat(string filename, out Stat stat)
		{
			return stat2(filename, dereference: false, out stat);
		}

		public static int lstat(string filename, out Stat stat)
		{
			return stat2(filename, dereference: true, out stat);
		}

		[DllImport("libc")]
		private static extern int readlink(string path, byte[] buffer, int buflen);

		public static string readlink(string path)
		{
			byte[] array = new byte[512];
			int num = readlink(path, array, array.Length);
			if (num == -1)
			{
				return null;
			}
			char[] array2 = new char[512];
			int chars = Encoding.Default.GetChars(array, 0, num, array2, 0);
			return new string(array2, 0, chars);
		}

		[DllImport("libc", EntryPoint = "strerror")]
		private static extern IntPtr _strerror(int errnum);

		public static string strerror(int errnum)
		{
			return Marshal.PtrToStringAnsi(_strerror(errnum));
		}

		[DllImport("libc")]
		public static extern IntPtr opendir(string path);

		[DllImport("libc")]
		public static extern int closedir(IntPtr dir);

		[DllImport("MonoPosixHelper", EntryPoint = "helper_Mono_Posix_readdir")]
		public static extern string readdir(IntPtr dir);
	}
	[Obsolete("Use Mono.Unix.Native.FilePermissions")]
	public enum StatModeMasks
	{
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFMT")]
		TypeMask = 61440,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_RWXU")]
		OwnerMask = 448,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_RWXG")]
		GroupMask = 56,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_RWXO")]
		OthersMask = 7
	}
	[Flags]
	[Obsolete("Use Mono.Unix.Native.FilePermissions")]
	public enum StatMode
	{
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFSOCK")]
		Socket = 0xC000,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFLNK")]
		SymLink = 0xA000,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFREG")]
		Regular = 0x8000,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFBLK")]
		BlockDevice = 0x6000,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFDIR")]
		Directory = 0x4000,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFCHR")]
		CharDevice = 0x2000,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IFIFO")]
		FIFO = 0x1000,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_ISUID")]
		SUid = 0x800,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_ISGID")]
		SGid = 0x400,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_ISVTX")]
		Sticky = 0x200,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IRUSR")]
		OwnerRead = 0x100,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IWUSR")]
		OwnerWrite = 0x80,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IXUSR")]
		OwnerExecute = 0x40,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IRGRP")]
		GroupRead = 0x20,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IWGRP")]
		GroupWrite = 0x10,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IXGRP")]
		GroupExecute = 8,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IROTH")]
		OthersRead = 4,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IWOTH")]
		OthersWrite = 2,
		[Obsolete("Use Mono.Unix.Native.FilePermissions.S_IXOTH")]
		OthersExecute = 1
	}
	[Obsolete("Use Mono.Unix.Native.Stat")]
	public struct Stat
	{
		[Obsolete("Use Mono.Unix.Native.Stat.st_dev")]
		public readonly int Device;

		[Obsolete("Use Mono.Unix.Native.Stat.st_ino")]
		public readonly int INode;

		[Obsolete("Use Mono.Unix.Native.Stat.st_mode")]
		public readonly StatMode Mode;

		[Obsolete("Use Mono.Unix.Native.Stat.st_nlink")]
		public readonly int NLinks;

		[Obsolete("Use Mono.Unix.Native.Stat.st_uid")]
		public readonly int Uid;

		[Obsolete("Use Mono.Unix.Native.Stat.st_gid")]
		public readonly int Gid;

		[Obsolete("Use Mono.Unix.Native.Stat.st_rdev")]
		public readonly long DeviceType;

		[Obsolete("Use Mono.Unix.Native.Stat.st_size")]
		public readonly long Size;

		[Obsolete("Use Mono.Unix.Native.Stat.st_blksize")]
		public readonly long BlockSize;

		[Obsolete("Use Mono.Unix.Native.Stat.st_blocks")]
		public readonly long Blocks;

		[Obsolete("Use Mono.Unix.Native.Stat.st_atime")]
		public readonly DateTime ATime;

		[Obsolete("Use Mono.Unix.Native.Stat.st_mtime")]
		public readonly DateTime MTime;

		[Obsolete("Use Mono.Unix.Native.Stat.st_ctime")]
		public readonly DateTime CTime;

		[Obsolete("Use Mono.Unix.Native.NativeConvert.LocalUnixEpoch")]
		public static readonly DateTime UnixEpoch = new DateTime(1970, 1, 1);

		internal Stat(int device, int inode, int mode, int nlinks, int uid, int gid, int rdev, long size, long blksize, long blocks, long atime, long mtime, long ctime)
		{
			Device = device;
			INode = inode;
			Mode = (StatMode)mode;
			NLinks = nlinks;
			Uid = uid;
			Gid = gid;
			DeviceType = rdev;
			Size = size;
			BlockSize = blksize;
			Blocks = blocks;
			if (atime != 0L)
			{
				ATime = UnixToDateTime(atime);
			}
			else
			{
				ATime = default(DateTime);
			}
			if (mtime != 0L)
			{
				MTime = UnixToDateTime(mtime);
			}
			else
			{
				MTime = default(DateTime);
			}
			if (ctime != 0L)
			{
				CTime = UnixToDateTime(ctime);
			}
			else
			{
				CTime = default(DateTime);
			}
		}

		[Obsolete("Use Mono.Unix.Native.NativeConvert.ToDateTime")]
		public static DateTime UnixToDateTime(long unix)
		{
			DateTime unixEpoch = UnixEpoch;
			return unixEpoch.Add(TimeSpan.FromSeconds(unix)).ToLocalTime();
		}
	}
	[Serializable]
	[Obsolete("Use Mono.Unix.UnixEndPoint")]
	public class UnixEndPoint : EndPoint
	{
		private string filename;

		public string Filename
		{
			get
			{
				return filename;
			}
			set
			{
				filename = value;
			}
		}

		public override AddressFamily AddressFamily => AddressFamily.Unix;

		public UnixEndPoint(string filename)
		{
			if (filename == null)
			{
				throw new ArgumentNullException("filename");
			}
			if (filename == string.Empty)
			{
				throw new ArgumentException("Cannot be empty.", "filename");
			}
			this.filename = filename;
		}

		public override EndPoint Create(SocketAddress socketAddress)
		{
			byte[] array = new byte[socketAddress.Size - 2];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = socketAddress[i + 2];
			}
			string text = Encoding.Default.GetString(array);
			return new UnixEndPoint(text);
		}

		public override SocketAddress Serialize()
		{
			byte[] bytes = Encoding.Default.GetBytes(filename);
			SocketAddress socketAddress = new SocketAddress(AddressFamily, bytes.Length + 2);
			for (int i = 0; i < bytes.Length; i++)
			{
				socketAddress[i + 2] = bytes[i];
			}
			return socketAddress;
		}

		public override string ToString()
		{
			return filename;
		}

		public override int GetHashCode()
		{
			return filename.GetHashCode();
		}

		public override bool Equals(object o)
		{
			if (!(o is UnixEndPoint unixEndPoint))
			{
				return false;
			}
			return unixEndPoint.filename == filename;
		}
	}
}
namespace Mono.Remoting.Channels.Unix
{
	internal class UnixBinaryClientFormatterSink : IClientChannelSink, IMessageSink, IChannelSinkBase, IClientFormatterSink
	{
		private UnixBinaryCore _binaryCore = UnixBinaryCore.DefaultInstance;

		private IClientChannelSink _nextInChain;

		internal UnixBinaryCore BinaryCore
		{
			get
			{
				return _binaryCore;
			}
			set
			{
				_binaryCore = value;
			}
		}

		public IClientChannelSink NextChannelSink => _nextInChain;

		public IMessageSink NextSink => null;

		public IDictionary Properties => null;

		public UnixBinaryClientFormatterSink(IClientChannelSink nextSink)
		{
			_nextInChain = nextSink;
		}

		public void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream stream)
		{
			throw new NotSupportedException("UnixBinaryClientFormatterSink must be the first sink in the IClientChannelSink chain");
		}

		public void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream)
		{
			IMessage msg = (IMessage)_binaryCore.Deserializer.DeserializeMethodResponse(stream, null, (IMethodCallMessage)state);
			sinkStack.DispatchReplyMessage(msg);
		}

		public Stream GetRequestStream(IMessage msg, ITransportHeaders headers)
		{
			throw new NotSupportedException();
		}

		public void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, out ITransportHeaders responseHeaders, out Stream responseStream)
		{
			throw new NotSupportedException();
		}

		public IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink)
		{
			ITransportHeaders headers = new TransportHeaders();
			Stream stream = _nextInChain.GetRequestStream(msg, headers);
			if (stream == null)
			{
				stream = new MemoryStream();
			}
			_binaryCore.Serializer.Serialize(stream, msg, null);
			if (stream is MemoryStream)
			{
				stream.Position = 0L;
			}
			ClientChannelSinkStack clientChannelSinkStack = new ClientChannelSinkStack(replySink);
			clientChannelSinkStack.Push(this, msg);
			_nextInChain.AsyncProcessRequest(clientChannelSinkStack, msg, headers, stream);
			return null;
		}

		public IMessage SyncProcessMessage(IMessage msg)
		{
			try
			{
				ITransportHeaders transportHeaders = new TransportHeaders();
				transportHeaders["__RequestUri"] = ((IMethodCallMessage)msg).Uri;
				transportHeaders["Content-Type"] = "application/octet-stream";
				Stream stream = _nextInChain.GetRequestStream(msg, transportHeaders);
				if (stream == null)
				{
					stream = new MemoryStream();
				}
				_binaryCore.Serializer.Serialize(stream, msg, null);
				if (stream is MemoryStream)
				{
					stream.Position = 0L;
				}
				_nextInChain.ProcessMessage(msg, transportHeaders, stream, out var _, out var responseStream);
				return (IMessage)_binaryCore.Deserializer.DeserializeMethodResponse(responseStream, null, (IMethodCallMessage)msg);
			}
			catch (Exception e)
			{
				return new ReturnMessage(e, (IMethodCallMessage)msg);
			}
		}
	}
	internal class UnixBinaryClientFormatterSinkProvider : IClientChannelSinkProvider, IClientFormatterSinkProvider
	{
		private IClientChannelSinkProvider next;

		private UnixBinaryCore _binaryCore;

		private static string[] allowedProperties = new string[2] { "includeVersions", "strictBinding" };

		public IClientChannelSinkProvider Next
		{
			get
			{
				return next;
			}
			set
			{
				next = value;
			}
		}

		public UnixBinaryClientFormatterSinkProvider()
		{
			_binaryCore = UnixBinaryCore.DefaultInstance;
		}

		public UnixBinaryClientFormatterSinkProvider(IDictionary properties, ICollection providerData)
		{
			_binaryCore = new UnixBinaryCore(this, properties, allowedProperties);
		}

		public IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData)
		{
			IClientChannelSink nextSink = null;
			if (next != null)
			{
				nextSink = next.CreateSink(channel, url, remoteChannelData);
			}
			UnixBinaryClientFormatterSink unixBinaryClientFormatterSink = new UnixBinaryClientFormatterSink(nextSink);
			unixBinaryClientFormatterSink.BinaryCore = _binaryCore;
			return unixBinaryClientFormatterSink;
		}
	}
	internal class UnixBinaryCore
	{
		private BinaryFormatter _serializationFormatter;

		private BinaryFormatter _deserializationFormatter;

		private bool _includeVersions = true;

		private bool _strictBinding;

		private IDictionary _properties;

		public static UnixBinaryCore DefaultInstance = new UnixBinaryCore();

		public BinaryFormatter Serializer => _serializationFormatter;

		public BinaryFormatter Deserializer => _deserializationFormatter;

		public IDictionary Properties => _properties;

		public UnixBinaryCore(object owner, IDictionary properties, string[] allowedProperties)
		{
			_properties = properties;
			foreach (DictionaryEntry property in properties)
			{
				string text = (string)property.Key;
				if (Array.IndexOf(allowedProperties, text) == -1)
				{
					throw new RemotingException(owner.GetType().Name + " does not recognize '" + text + "' configuration property");
				}
				switch (text)
				{
				case "includeVersions":
					_includeVersions = Convert.ToBoolean(property.Value);
					break;
				case "strictBinding":
					_strictBinding = Convert.ToBoolean(property.Value);
					break;
				}
			}
			Init();
		}

		public UnixBinaryCore()
		{
			_properties = new Hashtable();
			Init();
		}

		public void Init()
		{
			RemotingSurrogateSelector selector = new RemotingSurrogateSelector();
			StreamingContext context = new StreamingContext(StreamingContextStates.Remoting, null);
			_serializationFormatter = new BinaryFormatter(selector, context);
			_deserializationFormatter = new BinaryFormatter(null, context);
			if (!_includeVersions)
			{
				_serializationFormatter.AssemblyFormat = FormatterAssemblyStyle.Simple;
				_deserializationFormatter.AssemblyFormat = FormatterAssemblyStyle.Simple;
			}
			if (!_strictBinding)
			{
				_serializationFormatter.Binder = SimpleBinder.Instance;
				_deserializationFormatter.Binder = SimpleBinder.Instance;
			}
		}
	}
	internal class SimpleBinder : SerializationBinder
	{
		public static SimpleBinder Instance = new SimpleBinder();

		public override Type BindToType(string assemblyName, string typeName)
		{
			if (assemblyName.IndexOf(',') != -1)
			{
				try
				{
					Assembly assembly = Assembly.Load(assemblyName);
					if ((object)assembly == null)
					{
						return null;
					}
					Type type = assembly.GetType(typeName);
					if ((object)type != null)
					{
						return type;
					}
				}
				catch
				{
				}
			}
			return Assembly.LoadWithPartialName(assemblyName)?.GetType(typeName, throwOnError: true);
		}
	}
	internal class UnixBinaryServerFormatterSink : IServerChannelSink, IChannelSinkBase
	{
		private UnixBinaryCore _binaryCore = UnixBinaryCore.DefaultInstance;

		private IServerChannelSink next_sink;

		private IChannelReceiver receiver;

		internal UnixBinaryCore BinaryCore
		{
			get
			{
				return _binaryCore;
			}
			set
			{
				_binaryCore = value;
			}
		}

		public IServerChannelSink NextChannelSink => next_sink;

		public IDictionary Properties => null;

		public UnixBinaryServerFormatterSink(IServerChannelSink nextSink, IChannelReceiver receiver)
		{
			next_sink = nextSink;
			this.receiver = receiver;
		}

		public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage message, ITransportHeaders headers, Stream stream)
		{
			ITransportHeaders headers2 = new TransportHeaders();
			if (sinkStack != null)
			{
				stream = sinkStack.GetResponseStream(message, headers2);
			}
			if (stream == null)
			{
				stream = new MemoryStream();
			}
			_binaryCore.Serializer.Serialize(stream, message, null);
			if (stream is MemoryStream)
			{
				stream.Position = 0L;
			}
			sinkStack.AsyncProcessResponse(message, headers2, stream);
		}

		public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers)
		{
			return null;
		}

		public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, out IMessage responseMsg, out ITransportHeaders responseHeaders, out Stream responseStream)
		{
			sinkStack.Push(this, null);
			ServerProcessing serverProcessing;
			try
			{
				string text = (string)requestHeaders["__RequestUri"];
				receiver.Parse(text, out var objectURI);
				if (objectURI == null)
				{
					objectURI = text;
				}
				MethodCallHeaderHandler methodCallHeaderHandler = new MethodCallHeaderHandler(objectURI);
				requestMsg = (IMessage)_binaryCore.Deserializer.Deserialize(requestStream, methodCallHeaderHandler.HandleHeaders);
				serverProcessing = next_sink.ProcessMessage(sinkStack, requestMsg, requestHeaders, null, out responseMsg, out responseHeaders, out responseStream);
			}
			catch (Exception e)
			{
				responseMsg = new ReturnMessage(e, (IMethodCallMessage)requestMsg);
				serverProcessing = ServerProcessing.Complete;
				responseHeaders = null;
				responseStream = null;
			}
			if (serverProcessing == ServerProcessing.Complete)
			{
				for (int i = 0; i < 3; i++)
				{
					responseStream = null;
					responseHeaders = new TransportHeaders();
					if (sinkStack != null)
					{
						responseStream = sinkStack.GetResponseStream(responseMsg, responseHeaders);
					}
					if (responseStream == null)
					{
						responseStream = new MemoryStream();
					}
					try
					{
						_binaryCore.Serializer.Serialize(responseStream, responseMsg);
					}
					catch (Exception ex)
					{
						if (i == 2)
						{
							throw ex;
						}
						responseMsg = new ReturnMessage(ex, (IMethodCallMessage)requestMsg);
						continue;
					}
					break;
				}
				if (responseStream is MemoryStream)
				{
					responseStream.Position = 0L;
				}
				sinkStack.Pop(this);
			}
			return serverProcessing;
		}
	}
	internal class MethodCallHeaderHandler
	{
		private string _uri;

		public MethodCallHeaderHandler(string uri)
		{
			_uri = uri;
		}

		public object HandleHeaders(Header[] headers)
		{
			return _uri;
		}
	}
	internal class UnixBinaryServerFormatterSinkProvider : IServerChannelSinkProvider, IServerFormatterSinkProvider
	{
		private IServerChannelSinkProvider next;

		private UnixBinaryCore _binaryCore;

		internal static string[] AllowedProperties = new string[2] { "includeVersions", "strictBinding" };

		public IServerChannelSinkProvider Next
		{
			get
			{
				return next;
			}
			set
			{
				next = value;
			}
		}

		public UnixBinaryServerFormatterSinkProvider()
		{
			_binaryCore = UnixBinaryCore.DefaultInstance;
		}

		public UnixBinaryServerFormatterSinkProvider(IDictionary properties, ICollection providerData)
		{
			_binaryCore = new UnixBinaryCore(this, properties, AllowedProperties);
		}

		public IServerChannelSink CreateSink(IChannelReceiver channel)
		{
			IServerChannelSink nextSink = null;
			if (next != null)
			{
				nextSink = next.CreateSink(channel);
			}
			UnixBinaryServerFormatterSink unixBinaryServerFormatterSink = new UnixBinaryServerFormatterSink(nextSink, channel);
			unixBinaryServerFormatterSink.BinaryCore = _binaryCore;
			return unixBinaryServerFormatterSink;
		}

		public void GetChannelData(IChannelDataStore channelData)
		{
		}
	}
	public class UnixChannel : IChannelSender, IChannel, IChannelReceiver
	{
		private UnixClientChannel _clientChannel;

		private UnixServerChannel _serverChannel;

		private string _name = "unix";

		private int _priority = 1;

		public string ChannelName => _name;

		public int ChannelPriority => _priority;

		public object ChannelData
		{
			get
			{
				if (_serverChannel != null)
				{
					return _serverChannel.ChannelData;
				}
				return null;
			}
		}

		public UnixChannel()
			: this(null)
		{
		}

		public UnixChannel(string path)
		{
			Init(new Hashtable { ["path"] = path }, null, null);
		}

		public UnixChannel(IDictionary properties, IClientChannelSinkProvider clientSinkProvider, IServerChannelSinkProvider serverSinkProvider)
		{
			Init(properties, clientSinkProvider, serverSinkProvider);
		}

		private void Init(IDictionary properties, IClientChannelSinkProvider clientSink, IServerChannelSinkProvider serverSink)
		{
			_clientChannel = new UnixClientChannel(properties, clientSink);
			if (properties["path"] != null)
			{
				_serverChannel = new UnixServerChannel(properties, serverSink);
			}
			object obj = properties["name"];
			if (obj != null)
			{
				_name = obj as string;
			}
			obj = properties["priority"];
			if (obj != null)
			{
				_priority = Convert.ToInt32(obj);
			}
		}

		public IMessageSink CreateMessageSink(string url, object remoteChannelData, out string objectURI)
		{
			return _clientChannel.CreateMessageSink(url, remoteChannelData, out objectURI);
		}

		public void StartListening(object data)
		{
			if (_serverChannel != null)
			{
				_serverChannel.StartListening(data);
			}
		}

		public void StopListening(object data)
		{
			if (_serverChannel != null)
			{
				_serverChannel.StopListening(data);
			}
		}

		public string[] GetUrlsForUri(string uri)
		{
			if (_serverChannel != null)
			{
				return _serverChannel.GetUrlsForUri(uri);
			}
			return null;
		}

		public string Parse(string url, out string objectURI)
		{
			return ParseUnixURL(url, out objectURI);
		}

		internal static string ParseUnixURL(string url, out string objectURI)
		{
			objectURI = null;
			if (!url.StartsWith("unix://"))
			{
				return null;
			}
			int num = url.IndexOf('?');
			if (num == -1)
			{
				return url.Substring(7);
			}
			objectURI = url.Substring(num + 1);
			if (objectURI.Length == 0)
			{
				objectURI = null;
			}
			return url.Substring(7, num - 7);
		}
	}
	public class UnixClientChannel : IChannelSender, IChannel
	{
		private int priority = 1;

		private string name = "unix";

		private IClientChannelSinkProvider _sinkProvider;

		public string ChannelName => name;

		public int ChannelPriority => priority;

		public UnixClientChannel()
		{
			_sinkProvider = new UnixBinaryClientFormatterSinkProvider();
			_sinkProvider.Next = new UnixClientTransportSinkProvider();
		}

		public UnixClientChannel(IDictionary properties, IClientChannelSinkProvider sinkProvider)
		{
			object obj = properties["name"];
			if (obj != null)
			{
				name = obj as string;
			}
			obj = properties["priority"];
			if (obj != null)
			{
				priority = Convert.ToInt32(obj);
			}
			if (sinkProvider != null)
			{
				_sinkProvider = sinkProvider;
				IClientChannelSinkProvider clientChannelSinkProvider = sinkProvider;
				while (clientChannelSinkProvider.Next != null)
				{
					clientChannelSinkProvider = clientChannelSinkProvider.Next;
				}
				clientChannelSinkProvider.Next = new UnixClientTransportSinkProvider();
			}
			else
			{
				_sinkProvider = new UnixBinaryClientFormatterSinkProvider();
				_sinkProvider.Next = new UnixClientTransportSinkProvider();
			}
		}

		public UnixClientChannel(string name, IClientChannelSinkProvider sinkProvider)
		{
			this.name = name;
			_sinkProvider = sinkProvider;
			IClientChannelSinkProvider clientChannelSinkProvider = sinkProvider;
			while (clientChannelSinkProvider.Next != null)
			{
				clientChannelSinkProvider = clientChannelSinkProvider.Next;
			}
			clientChannelSinkProvider.Next = new UnixClientTransportSinkProvider();
		}

		public IMessageSink CreateMessageSink(string url, object remoteChannelData, out string objectURI)
		{
			if (url != null && Parse(url, out objectURI) != null)
			{
				return (IMessageSink)_sinkProvider.CreateSink(this, url, remoteChannelData);
			}
			if (remoteChannelData != null)
			{
				if (!(remoteChannelData is IChannelDataStore channelDataStore) || channelDataStore.ChannelUris.Length <= 0)
				{
					objectURI = null;
					return null;
				}
				url = channelDataStore.ChannelUris[0];
			}
			if (Parse(url, out objectURI) == null)
			{
				return null;
			}
			return (IMessageSink)_sinkProvider.CreateSink(this, url, remoteChannelData);
		}

		public string Parse(string url, out string objectURI)
		{
			return UnixChannel.ParseUnixURL(url, out objectURI);
		}
	}
	internal class UnixClientTransportSink : IClientChannelSink, IChannelSinkBase
	{
		private string _path;

		public IDictionary Properties => null;

		public IClientChannelSink NextChannelSink => null;

		public UnixClientTransportSink(string url)
		{
			_path = UnixChannel.ParseUnixURL(url, out var _);
		}

		public void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream requestStream)
		{
			UnixConnection unixConnection = null;
			bool flag = RemotingServices.IsOneWay(((IMethodMessage)msg).MethodBase);
			try
			{
				if (headers == null)
				{
					headers = new TransportHeaders();
				}
				headers["__RequestUri"] = ((IMethodMessage)msg).Uri;
				unixConnection = UnixConnectionPool.GetConnection(_path);
				UnixMessageIO.SendMessageStream(unixConnection.Stream, requestStream, headers, unixConnection.Buffer);
				unixConnection.Stream.Flush();
				if (!flag)
				{
					sinkStack.Push(this, unixConnection);
					ThreadPool.QueueUserWorkItem(ReadAsyncUnixMessage, sinkStack);
				}
				else
				{
					unixConnection.Release();
				}
			}
			catch
			{
				unixConnection?.Release();
				if (!flag)
				{
					throw;
				}
			}
		}

		private void ReadAsyncUnixMessage(object data)
		{
			IClientChannelSinkStack clientChannelSinkStack = (IClientChannelSinkStack)data;
			UnixConnection unixConnection = (UnixConnection)clientChannelSinkStack.Pop(this);
			try
			{
				if (UnixMessageIO.ReceiveMessageStatus(unixConnection.Stream, unixConnection.Buffer) != MessageStatus.MethodMessage)
				{
					throw new RemotingException("Unknown response message from server");
				}
				ITransportHeaders headers;
				Stream stream = UnixMessageIO.ReceiveMessageStream(unixConnection.Stream, out headers, unixConnection.Buffer);
				unixConnection.Release();
				unixConnection = null;
				clientChannelSinkStack.AsyncProcessResponse(headers, stream);
			}
			catch
			{
				unixConnection?.Release();
				throw;
			}
		}

		public void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream)
		{
			throw new NotSupportedException();
		}

		public Stream GetRequestStream(IMessage msg, ITransportHeaders headers)
		{
			return null;
		}

		public void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, out ITransportHeaders responseHeaders, out Stream responseStream)
		{
			UnixConnection unixConnection = null;
			try
			{
				if (requestHeaders == null)
				{
					requestHeaders = new TransportHeaders();
				}
				requestHeaders["__RequestUri"] = ((IMethodMessage)msg).Uri;
				unixConnection = UnixConnectionPool.GetConnection(_path);
				UnixMessageIO.SendMessageStream(unixConnection.Stream, requestStream, requestHeaders, unixConnection.Buffer);
				unixConnection.Stream.Flush();
				if (UnixMessageIO.ReceiveMessageStatus(unixConnection.Stream, unixConnection.Buffer) != MessageStatus.MethodMessage)
				{
					throw new RemotingException("Unknown response message from server");
				}
				responseStream = UnixMessageIO.ReceiveMessageStream(unixConnection.Stream, out responseHeaders, unixConnection.Buffer);
			}
			finally
			{
				unixConnection?.Release();
			}
		}
	}
	internal class UnixClientTransportSinkProvider : IClientChannelSinkProvider
	{
		public IClientChannelSinkProvider Next
		{
			get
			{
				return null;
			}
			set
			{
			}
		}

		public IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData)
		{
			return new UnixClientTransportSink(url);
		}
	}
	internal enum MessageStatus
	{
		MethodMessage = 0,
		CancelSignal = 1,
		Unknown = 10
	}
	internal class UnixMessageIO
	{
		private static byte[][] _msgHeaders = new byte[2][]
		{
			new byte[6] { 46, 78, 69, 84, 1, 0 },
			new byte[6] { 255, 255, 255, 255, 255, 255 }
		};

		public static int DefaultStreamBufferSize = 1000;

		private static byte[] msgUriTransportKey = new byte[4] { 4, 0, 1, 1 };

		private static byte[] msgContentTypeTransportKey = new byte[4] { 6, 0, 1, 1 };

		private static byte[] msgDefaultTransportKey = new byte[3] { 1, 0, 1 };

		private static byte[] msgHeaderTerminator = new byte[2];

		public static MessageStatus ReceiveMessageStatus(Stream networkStream, byte[] buffer)
		{
			try
			{
				StreamRead(networkStream, buffer, 6);
			}
			catch (Exception innerException)
			{
				throw new RemotingException("Unix transport error.", innerException);
			}
			try
			{
				bool[] array = new bool[_msgHeaders.Length];
				bool flag = true;
				int num = 0;
				while (flag)
				{
					flag = false;
					byte b = buffer[num];
					for (int i = 0; i < _msgHeaders.Length; i++)
					{
						if (num <= 0 || array[i])
						{
							array[i] = b == _msgHeaders[i][num];
							if (array[i] && num == _msgHeaders[i].Length - 1)
							{
								return (MessageStatus)i;
							}
							flag = flag || array[i];
						}
					}
					num++;
				}
				return MessageStatus.Unknown;
			}
			catch (Exception innerException2)
			{
				throw new RemotingException("Unix transport error.", innerException2);
			}
		}

		private static bool StreamRead(Stream networkStream, byte[] buffer, int count)
		{
			int num = 0;
			do
			{
				int num2 = networkStream.Read(buffer, num, count - num);
				if (num2 == 0)
				{
					throw new RemotingException("Connection closed");
				}
				num += num2;
			}
			while (num < count);
			return true;
		}

		public static void SendMessageStream(Stream networkStream, Stream data, ITransportHeaders requestHeaders, byte[] buffer)
		{
			if (buffer == null)
			{
				buffer = new byte[DefaultStreamBufferSize];
			}
			byte[] array = _msgHeaders[0];
			networkStream.Write(array, 0, array.Length);
			if (requestHeaders["__RequestUri"] != null)
			{
				buffer[0] = 0;
			}
			else
			{
				buffer[0] = 2;
			}
			buffer[1] = 0;
			buffer[2] = 0;
			buffer[3] = 0;
			int num = (int)data.Length;
			buffer[4] = (byte)num;
			buffer[5] = (byte)(num >> 8);
			buffer[6] = (byte)(num >> 16);
			buffer[7] = (byte)(num >> 24);
			networkStream.Write(buffer, 0, 8);
			SendHeaders(networkStream, requestHeaders, buffer);
			if (data is MemoryStream)
			{
				MemoryStream memoryStream = (MemoryStream)data;
				networkStream.Write(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
				return;
			}
			for (int num2 = data.Read(buffer, 0, buffer.Length); num2 > 0; num2 = data.Read(buffer, 0, buffer.Length))
			{
				networkStream.Write(buffer, 0, num2);
			}
		}

		private static void SendHeaders(Stream networkStream, ITransportHeaders requestHeaders, byte[] buffer)
		{
			if (networkStream != null)
			{
				IEnumerator enumerator = requestHeaders.GetEnumerator();
				while (enumerator.MoveNext())
				{
					DictionaryEntry dictionaryEntry = (DictionaryEntry)enumerator.Current;
					switch (dictionaryEntry.Key.ToString())
					{
					case "__RequestUri":
						networkStream.Write(msgUriTransportKey, 0, 4);
						break;
					case "Content-Type":
						networkStream.Write(msgContentTypeTransportKey, 0, 4);
						break;
					default:
						networkStream.Write(msgDefaultTransportKey, 0, 3);
						SendString(networkStream, dictionaryEntry.Key.ToString(), buffer);
						networkStream.WriteByte(1);
						break;
					}
					SendString(networkStream, dictionaryEntry.Value.ToString(), buffer);
				}
			}
			networkStream.Write(msgHeaderTerminator, 0, 2);
		}

		public static ITransportHeaders ReceiveHeaders(Stream networkStream, byte[] buffer)
		{
			StreamRead(networkStream, buffer, 2);
			byte b = buffer[0];
			TransportHeaders transportHeaders = new TransportHeaders();
			while (b != 0)
			{
				StreamRead(networkStream, buffer, 1);
				string key = b switch
				{
					4 => "__RequestUri", 
					6 => "Content-Type", 
					1 => ReceiveString(networkStream, buffer), 
					_ => throw new NotSupportedException("Unknown header code: " + b), 
				};
				StreamRead(networkStream, buffer, 1);
				transportHeaders[key] = ReceiveString(networkStream, buffer);
				StreamRead(networkStream, buffer, 2);
				b = buffer[0];
			}
			return transportHeaders;
		}

		public static Stream ReceiveMessageStream(Stream networkStream, out ITransportHeaders headers, byte[] buffer)
		{
			headers = null;
			if (buffer == null)
			{
				buffer = new byte[DefaultStreamBufferSize];
			}
			StreamRead(networkStream, buffer, 8);
			int num = buffer[4] | (buffer[5] << 8) | (buffer[6] << 16) | (buffer[7] << 24);
			headers = ReceiveHeaders(networkStream, buffer);
			byte[] buffer2 = new byte[num];
			StreamRead(networkStream, buffer2, num);
			return new MemoryStream(buffer2);
		}

		private static void SendString(Stream networkStream, string str, byte[] buffer)
		{
			int num = Encoding.UTF8.GetMaxByteCount(str.Length) + 4;
			if (num > buffer.Length)
			{
				buffer = new byte[num];
			}
			int bytes = Encoding.UTF8.GetBytes(str, 0, str.Length, buffer, 4);
			buffer[0] = (byte)bytes;
			buffer[1] = (byte)(bytes >> 8);
			buffer[2] = (byte)(bytes >> 16);
			buffer[3] = (byte)(bytes >> 24);
			networkStream.Write(buffer, 0, bytes + 4);
		}

		private static string ReceiveString(Stream networkStream, byte[] buffer)
		{
			StreamRead(networkStream, buffer, 4);
			int num = buffer[0] | (buffer[1] << 8) | (buffer[2] << 16) | (buffer[3] << 24);
			if (num == 0)
			{
				return string.Empty;
			}
			if (num > buffer.Length)
			{
				buffer = new byte[num];
			}
			StreamRead(networkStream, buffer, num);
			char[] chars = Encoding.UTF8.GetChars(buffer, 0, num);
			return new string(chars);
		}
	}
	public class UnixServerChannel : IChannel, IChannelReceiver
	{
		private string path;

		private string name = "unix";

		private int priority = 1;

		private bool supressChannelData;

		private Thread server_thread;

		private UnixListener listener;

		private UnixServerTransportSink sink;

		private ChannelDataStore channel_data;

		private int _maxConcurrentConnections = 100;

		private ArrayList _activeConnections = new ArrayList();

		public object ChannelData
		{
			get
			{
				if (supressChannelData)
				{
					return null;
				}
				return channel_data;
			}
		}

		public string ChannelName => name;

		public int ChannelPriority => priority;

		public UnixServerChannel(string path)
		{
			this.path = path;
			Init(null);
		}

		public UnixServerChannel(IDictionary properties, IServerChannelSinkProvider serverSinkProvider)
		{
			foreach (DictionaryEntry property in properties)
			{
				switch ((string)property.Key)
				{
				case "path":
					path = property.Value as string;
					break;
				case "priority":
					priority = Convert.ToInt32(property.Value);
					break;
				case "supressChannelData":
					supressChannelData = Convert.ToBoolean(property.Value);
					break;
				}
			}
			Init(serverSinkProvider);
		}

		public UnixServerChannel(string name, string path, IServerChannelSinkProvider serverSinkProvider)
		{
			this.name = name;
			this.path = path;
			Init(serverSinkProvider);
		}

		public UnixServerChannel(string name, string path)
		{
			this.name = name;
			this.path = path;
			Init(null);
		}

		private void Init(IServerChannelSinkProvider serverSinkProvider)
		{
			if (serverSinkProvider == null)
			{
				serverSinkProvider = new UnixBinaryServerFormatterSinkProvider();
			}
			channel_data = new ChannelDataStore(null);
			for (IServerChannelSinkProvider serverChannelSinkProvider = serverSinkProvider; serverChannelSinkProvider != null; serverChannelSinkProvider = serverChannelSinkProvider.Next)
			{
				serverChannelSinkProvider.GetChannelData(channel_data);
			}
			IServerChannelSink next = ChannelServices.CreateServerChannelSinkChain(serverSinkProvider, this);
			sink = new UnixServerTransportSink(next);
			StartListening(null);
		}

		public string GetChannelUri()
		{
			return "unix://" + path;
		}

		public string[] GetUrlsForUri(string uri)
		{
			if (!uri.StartsWith("/"))
			{
				uri = "/" + uri;
			}
			string[] channelUris = channel_data.ChannelUris;
			string[] array = new string[channelUris.Length];
			for (int i = 0; i < channelUris.Length; i++)
			{
				array[i] = channelUris[i] + "?" + uri;
			}
			return array;
		}

		public string Parse(string url, out string objectURI)
		{
			return UnixChannel.ParseUnixURL(url, out objectURI);
		}

		private void WaitForConnections()
		{
			try
			{
				while (true)
				{
					Socket client = listener.AcceptSocket();
					CreateListenerConnection(client);
				}
			}
			catch
			{
			}
		}

		internal void CreateListenerConnection(Socket client)
		{
			lock (_activeConnections)
			{
				if (_activeConnections.Count >= _maxConcurrentConnections)
				{
					Monitor.Wait(_activeConnections);
				}
				if (server_thread != null)
				{
					ClientConnection clientConnection = new ClientConnection(this, client, sink);
					Thread thread = new Thread(clientConnection.ProcessMessages);
					thread.Start();
					thread.IsBackground = true;
					_activeConnections.Add(thread);
				}
			}
		}

		internal void ReleaseConnection(Thread thread)
		{
			lock (_activeConnections)
			{
				_activeConnections.Remove(thread);
				Monitor.Pulse(_activeConnections);
			}
		}

		public void StartListening(object data)
		{
			listener = new UnixListener(path);
			Mono.Unix.Native.Syscall.chmod(path, FilePermissions.DEFFILEMODE);
			if (server_thread == null)
			{
				listener.Start();
				string[] array = new string[1];
				array = new string[1] { GetChannelUri() };
				channel_data.ChannelUris = array;
				server_thread = new Thread(WaitForConnections);
				server_thread.IsBackground = true;
				server_thread.Start();
			}
		}

		public void StopListening(object data)
		{
			if (server_thread == null)
			{
				return;
			}
			lock (_activeConnections)
			{
				server_thread.Abort();
				server_thread = null;
				listener.Stop();
				foreach (Thread activeConnection in _activeConnections)
				{
					activeConnection.Abort();
				}
				_activeConnections.Clear();
				Monitor.PulseAll(_activeConnections);
			}
		}
	}
	internal class ClientConnection
	{
		private Socket _client;

		private UnixServerTransportSink _sink;

		private Stream _stream;

		private UnixServerChannel _serverChannel;

		private byte[] _buffer = new byte[UnixMessageIO.DefaultStreamBufferSize];

		public Socket Client => _client;

		public byte[] Buffer => _buffer;

		public bool IsLocal => true;

		public ClientConnection(UnixServerChannel serverChannel, Socket client, UnixServerTransportSink sink)
		{
			_serverChannel = serverChannel;
			_client = client;
			_sink = sink;
		}

		public void ProcessMessages()
		{
			byte[] buffer = new byte[256];
			_stream = new BufferedStream(new NetworkStream(_client));
			try
			{
				bool flag = false;
				while (!flag)
				{
					switch (UnixMessageIO.ReceiveMessageStatus(_stream, buffer))
					{
					case MessageStatus.MethodMessage:
						_sink.InternalProcessMessage(this, _stream);
						break;
					case MessageStatus.CancelSignal:
					case MessageStatus.Unknown:
						flag = true;
						break;
					}
				}
			}
			catch (Exception)
			{
			}
			finally
			{
				_stream.Close();
				_client.Close();
				_serverChannel.ReleaseConnection(Thread.CurrentThread);
			}
		}
	}
	internal class UnixServerTransportSink : IServerChannelSink, IChannelSinkBase
	{
		private IServerChannelSink next_sink;

		public IServerChannelSink NextChannelSink => next_sink;

		public IDictionary Properties
		{
			get
			{
				if (next_sink != null)
				{
					return next_sink.Properties;
				}
				return null;
			}
		}

		public UnixServerTransportSink(IServerChannelSink next)
		{
			next_sink = next;
		}

		public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream responseStream)
		{
			ClientConnection clientConnection = (ClientConnection)state;
			NetworkStream networkStream = new NetworkStream(clientConnection.Client);
			UnixMessageIO.SendMessageStream(networkStream, responseStream, headers, clientConnection.Buffer);
			networkStream.Flush();
			networkStream.Close();
		}

		public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers)
		{
			return null;
		}

		public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, out IMessage responseMsg, out ITransportHeaders responseHeaders, out Stream responseStream)
		{
			throw new NotSupportedException();
		}

		internal void InternalProcessMessage(ClientConnection connection, Stream stream)
		{
			ITransportHeaders headers;
			Stream requestStream = UnixMessageIO.ReceiveMessageStream(stream, out headers, connection.Buffer);
			ServerChannelSinkStack serverChannelSinkStack = new ServerChannelSinkStack();
			serverChannelSinkStack.Push(this, connection);
			IMessage responseMsg;
			ITransportHeaders responseHeaders;
			Stream responseStream;
			switch (next_sink.ProcessMessage(serverChannelSinkStack, null, headers, requestStream, out responseMsg, out responseHeaders, out responseStream))
			{
			case ServerProcessing.Complete:
				UnixMessageIO.SendMessageStream(stream, responseStream, responseHeaders, connection.Buffer);
				stream.Flush();
				break;
			case ServerProcessing.OneWay:
			case ServerProcessing.Async:
				break;
			}
		}
	}
	internal class UnixConnectionPool
	{
		private static Hashtable _pools;

		private static int _maxOpenConnections;

		private static int _keepAliveSeconds;

		private static Thread _poolThread;

		public static int MaxOpenConnections
		{
			get
			{
				return _maxOpenConnections;
			}
			set
			{
				if (value < 1)
				{
					throw new RemotingException("MaxOpenConnections must be greater than zero");
				}
				_maxOpenConnections = value;
			}
		}

		public static int KeepAliveSeconds
		{
			get
			{
				return _keepAliveSeconds;
			}
			set
			{
				_keepAliveSeconds = value;
			}
		}

		static UnixConnectionPool()
		{
			_pools = new Hashtable();
			_maxOpenConnections = int.MaxValue;
			_keepAliveSeconds = 15;
			_poolThread = new Thread(ConnectionCollector);
			_poolThread.Start();
			_poolThread.IsBackground = true;
		}

		public static void Shutdown()
		{
			if (_poolThread != null)
			{
				_poolThread.Abort();
			}
		}

		public static UnixConnection GetConnection(string path)
		{
			HostConnectionPool hostConnectionPool;
			lock (_pools)
			{
				hostConnectionPool = (HostConnectionPool)_pools[path];
				if (hostConnectionPool == null)
				{
					hostConnectionPool = new HostConnectionPool(path);
					_pools[path] = hostConnectionPool;
				}
			}
			return hostConnectionPool.GetConnection();
		}

		private static void ConnectionCollector()
		{
			while (true)
			{
				Thread.Sleep(3000);
				lock (_pools)
				{
					ICollection values = _pools.Values;
					foreach (HostConnectionPool item in values)
					{
						item.PurgeConnections();
					}
				}
			}
		}
	}
	internal class ReusableUnixClient : UnixClient
	{
		public bool IsAlive => !base.Client.Poll(0, SelectMode.SelectRead);

		public ReusableUnixClient(string path)
			: base(path)
		{
		}
	}
	internal class UnixConnection
	{
		private DateTime _controlTime;

		private Stream _stream;

		private ReusableUnixClient _client;

		private HostConnectionPool _pool;

		private byte[] _buffer;

		public Stream Stream => _stream;

		public DateTime ControlTime
		{
			get
			{
				return _controlTime;
			}
			set
			{
				_controlTime = value;
			}
		}

		public bool IsAlive => _client.IsAlive;

		public byte[] Buffer => _buffer;

		public UnixConnection(HostConnectionPool pool, ReusableUnixClient client)
		{
			_pool = pool;
			_client = client;
			_stream = new BufferedStream(client.GetStream());
			_controlTime = DateTime.Now;
			_buffer = new byte[UnixMessageIO.DefaultStreamBufferSize];
		}

		public void Release()
		{
			_pool.ReleaseConnection(this);
		}

		public void Close()
		{
			_client.Close();
		}
	}
	internal class HostConnectionPool
	{
		private ArrayList _pool = new ArrayList();

		private int _activeConnections;

		private string _path;

		public HostConnectionPool(string path)
		{
			_path = path;
		}

		public UnixConnection GetConnection()
		{
			UnixConnection unixConnection = null;
			lock (_pool)
			{
				do
				{
					if (_pool.Count > 0)
					{
						unixConnection = (UnixConnection)_pool[_pool.Count - 1];
						_pool.RemoveAt(_pool.Count - 1);
						if (!unixConnection.IsAlive)
						{
							CancelConnection(unixConnection);
							unixConnection = null;
							continue;
						}
					}
					if (unixConnection == null && _activeConnections < UnixConnectionPool.MaxOpenConnections)
					{
						break;
					}
					if (unixConnection == null)
					{
						Monitor.Wait(_pool);
					}
				}
				while (unixConnection == null);
			}
			if (unixConnection == null)
			{
				return CreateConnection();
			}
			return unixConnection;
		}

		private UnixConnection CreateConnection()
		{
			try
			{
				ReusableUnixClient client = new ReusableUnixClient(_path);
				UnixConnection result = new UnixConnection(this, client);
				_activeConnections++;
				return result;
			}
			catch (Exception ex)
			{
				throw new RemotingException(ex.Message);
			}
		}

		public void ReleaseConnection(UnixConnection entry)
		{
			lock (_pool)
			{
				entry.ControlTime = DateTime.Now;
				_pool.Add(entry);
				Monitor.Pulse(_pool);
			}
		}

		private void CancelConnection(UnixConnection entry)
		{
			try
			{
				entry.Stream.Close();
				_activeConnections--;
			}
			catch
			{
			}
		}

		public void PurgeConnections()
		{
			lock (_pool)
			{
				for (int i = 0; i < _pool.Count; i++)
				{
					UnixConnection unixConnection = (UnixConnection)_pool[i];
					if ((DateTime.Now - unixConnection.ControlTime).TotalSeconds > (double)UnixConnectionPool.KeepAliveSeconds)
					{
						CancelConnection(unixConnection);
						_pool.RemoveAt(i);
						i--;
					}
				}
			}
		}
	}
}
namespace Mono.Unix.Native
{
	public delegate void SignalHandler(int signal);
}
[CompilerGenerated]
internal class <56523a34-2ad1-4b32-8174-674792234a6e><PrivateImplementationDetails>
{
	[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 20)]
	private struct $ArrayType$20
	{
	}

	[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 8)]
	private struct $ArrayType$8
	{
	}

	internal static $ArrayType$20 $$field-0/* Not supported: data(2D 00 2D 00 2D 00 2D 00 2D 00 2D 00 2D 00 2D 00 2D 00 2D 00) */;

	internal static $ArrayType$8 $$field-1/* Not supported: data(2E 4E 45 54 01 00 00 00) */;

	internal static $ArrayType$8 $$field-2/* Not supported: data(FF FF FF FF FF FF 00 00) */;
}
namespace System.ComponentModel
{
	[Preserve]
	public class AddingNewEventArgs
	{
		public object NewObject { get; set; }

		public AddingNewEventArgs()
		{
		}

		public AddingNewEventArgs(object newObject)
		{
			NewObject = newObject;
		}
	}
	[Preserve]
	public delegate void AddingNewEventHandler(object sender, AddingNewEventArgs e);
	[Preserve]
	public interface INotifyCollectionChanged
	{
		event NotifyCollectionChangedEventHandler CollectionChanged;
	}
	[Preserve]
	public interface INotifyPropertyChanging
	{
		event PropertyChangingEventHandler PropertyChanging;
	}
	[Preserve]
	public enum NotifyCollectionChangedAction
	{
		Add,
		Remove,
		Replace,
		Move,
		Reset
	}
	[Preserve]
	public class NotifyCollectionChangedEventArgs
	{
		internal NotifyCollectionChangedAction Action { get; set; }

		internal IList NewItems { get; set; }

		internal int NewStartingIndex { get; set; }

		internal IList OldItems { get; set; }

		internal int OldStartingIndex { get; set; }

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action)
		{
			Action = action;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems)
			: this(action)
		{
			NewItems = changedItems;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem)
			: this(action)
		{
			NewItems = new List<object> { changedItem };
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems)
			: this(action, newItems)
		{
			OldItems = oldItems;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int startingIndex)
			: this(action, changedItems)
		{
			NewStartingIndex = startingIndex;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index)
			: this(action, changedItem)
		{
			NewStartingIndex = index;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem)
			: this(action, newItem)
		{
			OldItems = new List<object> { oldItem };
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList newItems, IList oldItems, int startingIndex)
			: this(action, newItems, oldItems)
		{
			NewStartingIndex = startingIndex;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, IList changedItems, int index, int oldIndex)
			: this(action, changedItems, index)
		{
			OldStartingIndex = oldIndex;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object changedItem, int index, int oldIndex)
			: this(action, changedItem, index)
		{
			OldStartingIndex = oldIndex;
		}

		internal NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction action, object newItem, object oldItem, int index)
			: this(action, newItem, oldItem)
		{
			NewStartingIndex = index;
		}
	}
	[Preserve]
	public delegate void NotifyCollectionChangedEventHandler(object sender, NotifyCollectionChangedEventArgs e);
	[Preserve]
	public class PropertyChangingEventArgs : EventArgs
	{
		public virtual string PropertyName { get; set; }

		public PropertyChangingEventArgs(string propertyName)
		{
			PropertyName = propertyName;
		}
	}
	[Preserve]
	public delegate void PropertyChangingEventHandler(object sender, PropertyChangingEventArgs e);
}
namespace Newtonsoft.Json
{
	[Preserve]
	public enum ConstructorHandling
	{
		Default,
		AllowNonPublicDefaultConstructor
	}
	[Preserve]
	public enum DateFormatHandling
	{
		IsoDateFormat,
		MicrosoftDateFormat
	}
	[Preserve]
	public enum DateParseHandling
	{
		None,
		DateTime,
		DateTimeOffset
	}
	[Preserve]
	public enum DateTimeZoneHandling
	{
		Local,
		Utc,
		Unspecified,
		RoundtripKind
	}
	[Preserve]
	public enum FloatFormatHandling
	{
		String,
		Symbol,
		DefaultValue
	}
	[Preserve]
	public enum FloatParseHandling
	{
		Double,
		Decimal
	}
	[Preserve]
	public enum Formatting
	{
		None,
		Indented
	}
	[Preserve]
	public interface IArrayPool<T>
	{
		T[] Rent(int minimumLength);

		void Return(T[] array);
	}
	[Preserve]
	[AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false)]
	public sealed class JsonConstructorAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
	[Preserve]
	public sealed class JsonDictionaryAttribute : JsonContainerAttribute
	{
		public JsonDictionaryAttribute()
		{
		}

		public JsonDictionaryAttribute(string id)
			: base(id)
		{
		}
	}
	[Serializable]
	[Preserve]
	public class JsonException : Exception
	{
		public JsonException()
		{
		}

		public JsonException(string message)
			: base(message)
		{
		}

		public JsonException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		public JsonException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		internal static JsonException Create(IJsonLineInfo lineInfo, string path, string message)
		{
			message = JsonPosition.FormatMessage(lineInfo, path, message);
			return new JsonException(message);
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	[Preserve]
	public class JsonExtensionDataAttribute : Attribute
	{
		public bool WriteData { get; set; }

		public bool ReadData { get; set; }

		public JsonExtensionDataAttribute()
		{
			WriteData = true;
			ReadData = true;
		}
	}
	[Preserve]
	internal enum JsonContainerType
	{
		None,
		Object,
		Array,
		Constructor
	}
	[Preserve]
	internal struct JsonPosition
	{
		private static readonly char[] SpecialCharacters = new char[6] { '.', ' ', '[', ']', '(', ')' };

		internal JsonContainerType Type;

		internal int Position;

		internal string PropertyName;

		internal bool HasIndex;

		public JsonPosition(JsonContainerType type)
		{
			Type = type;
			HasIndex = TypeHasIndex(type);
			Position = -1;
			PropertyName = null;
		}

		internal int CalculateLength()
		{
			switch (Type)
			{
			case JsonContainerType.Object:
				return PropertyName.Length + 5;
			case JsonContainerType.Array:
			case JsonContainerType.Constructor:
				return MathUtils.IntLength((ulong)Position) + 2;
			default:
				throw new ArgumentOutOfRangeException("Type");
			}
		}

		internal void WriteTo(StringBuilder sb)
		{
			switch (Type)
			{
			case JsonContainerType.Object:
			{
				string propertyName = PropertyName;
				if (propertyName.IndexOfAny(SpecialCharacters) != -1)
				{
					sb.Append("['");
					sb.Append(propertyName);
					sb.Append("']");
					break;
				}
				if (sb.Length > 0)
				{
					sb.Append('.');
				}
				sb.Append(propertyName);
				break;
			}
			case JsonContainerType.Array:
			case JsonContainerType.Constructor:
				sb.Append('[');
				sb.Append(Position);
				sb.Append(']');
				break;
			}
		}

		internal static bool TypeHasIndex(JsonContainerType type)
		{
			if (type != JsonContainerType.Array)
			{
				return type == JsonContainerType.Constructor;
			}
			return true;
		}

		internal static string BuildPath(List<JsonPosition> positions, JsonPosition? currentPosition)
		{
			int num = 0;
			if (positions != null)
			{
				for (int i = 0; i < positions.Count; i++)
				{
					num += positions[i].CalculateLength();
				}
			}
			if (currentPosition.HasValue)
			{
				num += currentPosition.GetValueOrDefault().CalculateLength();
			}
			StringBuilder stringBuilder = new StringBuilder(num);
			if (positions != null)
			{
				foreach (JsonPosition position in positions)
				{
					position.WriteTo(stringBuilder);
				}
			}
			currentPosition?.WriteTo(stringBuilder);
			return stringBuilder.ToString();
		}

		internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message)
		{
			if (!message.EndsWith(Environment.NewLine, StringComparison.Ordinal))
			{
				message = message.Trim();
				if (!StringUtils.EndsWith(message, '.'))
				{
					message += ".";
				}
				message += " ";
			}
			message += "Path '{0}'".FormatWith(CultureInfo.InvariantCulture, path);
			if (lineInfo != null && lineInfo.HasLineInfo())
			{
				message += ", line {0}, position {1}".FormatWith(CultureInfo.InvariantCulture, lineInfo.LineNumber, lineInfo.LinePosition);
			}
			message += ".";
			return message;
		}
	}
	[Preserve]
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	public sealed class JsonRequiredAttribute : Attribute
	{
	}
	[Preserve]
	public enum MetadataPropertyHandling
	{
		Default,
		ReadAhead,
		Ignore
	}
	[Preserve]
	public enum StringEscapeHandling
	{
		Default,
		EscapeNonAscii,
		EscapeHtml
	}
	[Preserve]
	public enum Required
	{
		Default,
		AllowNull,
		Always,
		DisallowNull
	}
	[Preserve]
	[Flags]
	public enum PreserveReferencesHandling
	{
		None = 0,
		Objects = 1,
		Arrays = 2,
		All = 3
	}
	[Preserve]
	public interface IJsonLineInfo
	{
		int LineNumber { get; }

		int LinePosition { get; }

		bool HasLineInfo();
	}
	[Preserve]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
	public sealed class JsonArrayAttribute : JsonContainerAttribute
	{
		private bool _allowNullItems;

		public bool AllowNullItems
		{
			get
			{
				return _allowNullItems;
			}
			set
			{
				_allowNullItems = value;
			}
		}

		public JsonArrayAttribute()
		{
		}

		public JsonArrayAttribute(bool allowNullItems)
		{
			_allowNullItems = allowNullItems;
		}

		public JsonArrayAttribute(string id)
			: base(id)
		{
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
	[Preserve]
	public abstract class JsonContainerAttribute : Attribute
	{
		internal bool? _isReference;

		internal bool? _itemIsReference;

		internal ReferenceLoopHandling? _itemReferenceLoopHandling;

		internal TypeNameHandling? _itemTypeNameHandling;

		public string Id { get; set; }

		public string Title { get; set; }

		public string Description { get; set; }

		public Type ItemConverterType { get; set; }

		public object[] ItemConverterParameters { get; set; }

		public bool IsReference
		{
			get
			{
				return _isReference ?? false;
			}
			set
			{
				_isReference = value;
			}
		}

		public bool ItemIsReference
		{
			get
			{
				return _itemIsReference ?? false;
			}
			set
			{
				_itemIsReference = value;
			}
		}

		public ReferenceLoopHandling ItemReferenceLoopHandling
		{
			get
			{
				return _itemReferenceLoopHandling ?? ReferenceLoopHandling.Error;
			}
			set
			{
				_itemReferenceLoopHandling = value;
			}
		}

		public TypeNameHandling ItemTypeNameHandling
		{
			get
			{
				return _itemTypeNameHandling ?? TypeNameHandling.None;
			}
			set
			{
				_itemTypeNameHandling = value;
			}
		}

		protected JsonContainerAttribute()
		{
		}

		protected JsonContainerAttribute(string id)
		{
			Id = id;
		}
	}
	[Preserve]
	[Flags]
	public enum DefaultValueHandling
	{
		Include = 0,
		Ignore = 1,
		Populate = 2,
		IgnoreAndPopulate = 3
	}
	[Preserve]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Interface | AttributeTargets.Parameter, AllowMultiple = false)]
	public sealed class JsonConverterAttribute : Attribute
	{
		private readonly Type _converterType;

		public Type ConverterType => _converterType;

		public object[] ConverterParameters { get; private set; }

		public JsonConverterAttribute(Type converterType)
		{
			if ((object)converterType == null)
			{
				throw new ArgumentNullException("converterType");
			}
			_converterType = converterType;
		}

		public JsonConverterAttribute(Type converterType, params object[] converterParameters)
			: this(converterType)
		{
			ConverterParameters = converterParameters;
		}
	}
	[Preserve]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface, AllowMultiple = false)]
	public sealed class JsonObjectAttribute : JsonContainerAttribute
	{
		private MemberSerialization _memberSerialization;

		internal Required? _itemRequired;

		public MemberSerialization MemberSerialization
		{
			get
			{
				return _memberSerialization;
			}
			set
			{
				_memberSerialization = value;
			}
		}

		public Required ItemRequired
		{
			get
			{
				return _itemRequired ?? Required.Default;
			}
			set
			{
				_itemRequired = value;
			}
		}

		public JsonObjectAttribute()
		{
		}

		public JsonObjectAttribute(MemberSerialization memberSerialization)
		{
			MemberSerialization = memberSerialization;
		}

		public JsonObjectAttribute(string id)
			: base(id)
		{
		}
	}
	[Preserve]
	public class JsonSerializerSettings
	{
		internal const ReferenceLoopHandling DefaultReferenceLoopHandling = ReferenceLoopHandling.Error;

		internal const MissingMemberHandling DefaultMissingMemberHandling = MissingMemberHandling.Ignore;

		internal const NullValueHandling DefaultNullValueHandling = NullValueHandling.Include;

		internal const DefaultValueHandling DefaultDefaultValueHandling = DefaultValueHandling.Include;

		internal const ObjectCreationHandling DefaultObjectCreationHandling = ObjectCreationHandling.Auto;

		internal const PreserveReferencesHandling DefaultPreserveReferencesHandling = PreserveReferencesHandling.None;

		internal const ConstructorHandling DefaultConstructorHandling = ConstructorHandling.Default;

		internal const TypeNameHandling DefaultTypeNameHandling = TypeNameHandling.None;

		internal const MetadataPropertyHandling DefaultMetadataPropertyHandling = MetadataPropertyHandling.Default;

		internal const FormatterAssemblyStyle DefaultTypeNameAssemblyFormat = FormatterAssemblyStyle.Simple;

		internal static readonly StreamingContext DefaultContext;

		internal const Formatting DefaultFormatting = Formatting.None;

		internal const DateFormatHandling DefaultDateFormatHandling = DateFormatHandling.IsoDateFormat;

		internal const DateTimeZoneHandling DefaultDateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;

		internal const DateParseHandling DefaultDateParseHandling = DateParseHandling.DateTime;

		internal const FloatParseHandling DefaultFloatParseHandling = FloatParseHandling.Double;

		internal const FloatFormatHandling DefaultFloatFormatHandling = FloatFormatHandling.String;

		internal const StringEscapeHandling DefaultStringEscapeHandling = StringEscapeHandling.Default;

		internal const FormatterAssemblyStyle DefaultFormatterAssemblyStyle = FormatterAssemblyStyle.Simple;

		internal static readonly CultureInfo DefaultCulture;

		internal const bool DefaultCheckAdditionalContent = false;

		internal const string DefaultDateFormatString = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

		internal Formatting? _formatting;

		internal DateFormatHandling? _dateFormatHandling;

		internal DateTimeZoneHandling? _dateTimeZoneHandling;

		internal DateParseHandling? _dateParseHandling;

		internal FloatFormatHandling? _floatFormatHandling;

		internal FloatParseHandling? _floatParseHandling;

		internal StringEscapeHandling? _stringEscapeHandling;

		internal CultureInfo _culture;

		internal bool? _checkAdditionalContent;

		internal int? _maxDepth;

		internal bool _maxDepthSet;

		internal string _dateFormatString;

		internal bool _dateFormatStringSet;

		internal FormatterAssemblyStyle? _typeNameAssemblyFormat;

		internal DefaultValueHandling? _defaultValueHandling;

		internal PreserveReferencesHandling? _preserveReferencesHandling;

		internal NullValueHandling? _nullValueHandling;

		internal ObjectCreationHandling? _objectCreationHandling;

		internal MissingMemberHandling? _missingMemberHandling;

		internal ReferenceLoopHandling? _referenceLoopHandling;

		internal StreamingContext? _context;

		internal ConstructorHandling? _constructorHandling;

		internal TypeNameHandling? _typeNameHandling;

		internal MetadataPropertyHandling? _metadataPropertyHandling;

		public ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				return _referenceLoopHandling ?? ReferenceLoopHandling.Error;
			}
			set
			{
				_referenceLoopHandling = value;
			}
		}

		public MissingMemberHandling MissingMemberHandling
		{
			get
			{
				return _missingMemberHandling ?? MissingMemberHandling.Ignore;
			}
			set
			{
				_missingMemberHandling = value;
			}
		}

		public ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				return _objectCreationHandling ?? ObjectCreationHandling.Auto;
			}
			set
			{
				_objectCreationHandling = value;
			}
		}

		public NullValueHandling NullValueHandling
		{
			get
			{
				return _nullValueHandling ?? NullValueHandling.Include;
			}
			set
			{
				_nullValueHandling = value;
			}
		}

		public DefaultValueHandling DefaultValueHandling
		{
			get
			{
				return _defaultValueHandling ?? DefaultValueHandling.Include;
			}
			set
			{
				_defaultValueHandling = value;
			}
		}

		public IList<JsonConverter> Converters { get; set; }

		public PreserveReferencesHandling PreserveReferencesHandling
		{
			get
			{
				return _preserveReferencesHandling ?? PreserveReferencesHandling.None;
			}
			set
			{
				_preserveReferencesHandling = value;
			}
		}

		public TypeNameHandling TypeNameHandling
		{
			get
			{
				return _typeNameHandling ?? TypeNameHandling.None;
			}
			set
			{
				_typeNameHandling = value;
			}
		}

		public MetadataPropertyHandling MetadataPropertyHandling
		{
			get
			{
				return _metadataPropertyHandling ?? MetadataPropertyHandling.Default;
			}
			set
			{
				_metadataPropertyHandling = value;
			}
		}

		public FormatterAssemblyStyle TypeNameAssemblyFormat
		{
			get
			{
				return _typeNameAssemblyFormat ?? FormatterAssemblyStyle.Simple;
			}
			set
			{
				_typeNameAssemblyFormat = value;
			}
		}

		public ConstructorHandling ConstructorHandling
		{
			get
			{
				return _constructorHandling ?? ConstructorHandling.Default;
			}
			set
			{
				_constructorHandling = value;
			}
		}

		public IContractResolver ContractResolver { get; set; }

		public IEqualityComparer EqualityComparer { get; set; }

		[Obsolete("ReferenceResolver property is obsolete. Use the ReferenceResolverProvider property to set the IReferenceResolver: settings.ReferenceResolverProvider = () => resolver")]
		public IReferenceResolver ReferenceResolver
		{
			get
			{
				if (ReferenceResolverProvider == null)
				{
					return null;
				}
				return ReferenceResolverProvider();
			}
			set
			{
				ReferenceResolverProvider = ((value != null) ? ((Func<IReferenceResolver>)(() => value)) : null);
			}
		}

		public Func<IReferenceResolver> ReferenceResolverProvider { get; set; }

		public ITraceWriter TraceWriter { get; set; }

		public SerializationBinder Binder { get; set; }

		public EventHandler<Newtonsoft.Json.Serialization.ErrorEventArgs> Error { get; set; }

		public StreamingContext Context
		{
			get
			{
				return _context ?? DefaultContext;
			}
			set
			{
				_context = value;
			}
		}

		public string DateFormatString
		{
			get
			{
				return _dateFormatString ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";
			}
			set
			{
				_dateFormatString = value;
				_dateFormatStringSet = true;
			}
		}

		public int? MaxDepth
		{
			get
			{
				return _maxDepth;
			}
			set
			{
				if (value <= 0)
				{
					throw new ArgumentException("Value must be positive.", "value");
				}
				_maxDepth = value;
				_maxDepthSet = true;
			}
		}

		public Formatting Formatting
		{
			get
			{
				return _formatting ?? Formatting.None;
			}
			set
			{
				_formatting = value;
			}
		}

		public DateFormatHandling DateFormatHandling
		{
			get
			{
				return _dateFormatHandling ?? DateFormatHandling.IsoDateFormat;
			}
			set
			{
				_dateFormatHandling = value;
			}
		}

		public DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				return _dateTimeZoneHandling ?? DateTimeZoneHandling.RoundtripKind;
			}
			set
			{
				_dateTimeZoneHandling = value;
			}
		}

		public DateParseHandling DateParseHandling
		{
			get
			{
				return _dateParseHandling ?? DateParseHandling.DateTime;
			}
			set
			{
				_dateParseHandling = value;
			}
		}

		public FloatFormatHandling FloatFormatHandling
		{
			get
			{
				return _floatFormatHandling ?? FloatFormatHandling.String;
			}
			set
			{
				_floatFormatHandling = value;
			}
		}

		public FloatParseHandling FloatParseHandling
		{
			get
			{
				return _floatParseHandling ?? FloatParseHandling.Double;
			}
			set
			{
				_floatParseHandling = value;
			}
		}

		public StringEscapeHandling StringEscapeHandling
		{
			get
			{
				return _stringEscapeHandling ?? StringEscapeHandling.Default;
			}
			set
			{
				_stringEscapeHandling = value;
			}
		}

		public CultureInfo Culture
		{
			get
			{
				return _culture ?? DefaultCulture;
			}
			set
			{
				_culture = value;
			}
		}

		public bool CheckAdditionalContent
		{
			get
			{
				return _checkAdditionalContent ?? false;
			}
			set
			{
				_checkAdditionalContent = value;
			}
		}

		static JsonSerializerSettings()
		{
			DefaultContext = default(StreamingContext);
			DefaultCulture = CultureInfo.InvariantCulture;
		}

		public JsonSerializerSettings()
		{
			Converters = new List<JsonConverter>
			{
				new VectorConverter()
			};
			Converters.Add(new HashSetConverter());
		}
	}
	[Preserve]
	public enum MemberSerialization
	{
		OptOut,
		OptIn,
		Fields
	}
	[Preserve]
	public enum ObjectCreationHandling
	{
		Auto,
		Reuse,
		Replace
	}
	[Preserve]
	internal enum ReadType
	{
		Read,
		ReadAsInt32,
		ReadAsBytes,
		ReadAsString,
		ReadAsDecimal,
		ReadAsDateTime,
		ReadAsDateTimeOffset,
		ReadAsDouble,
		ReadAsBoolean
	}
	[Preserve]
	public class JsonTextReader : JsonReader, IJsonLineInfo
	{
		private const char UnicodeReplacementChar = '\ufffd';

		private const int MaximumJavascriptIntegerCharacterLength = 380;

		private readonly TextReader _reader;

		private char[] _chars;

		private int _charsUsed;

		private int _charPos;

		private int _lineStartPos;

		private int _lineNumber;

		private bool _isEndOfFile;

		private StringBuffer _stringBuffer;

		private StringReference _stringReference;

		private IArrayPool<char> _arrayPool;

		internal PropertyNameTable NameTable;

		public IArrayPool<char> ArrayPool
		{
			get
			{
				return _arrayPool;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				_arrayPool = value;
			}
		}

		public int LineNumber
		{
			get
			{
				if (base.CurrentState == State.Start && LinePosition == 0 && TokenType != JsonToken.Comment)
				{
					return 0;
				}
				return _lineNumber;
			}
		}

		public int LinePosition => _charPos - _lineStartPos;

		public JsonTextReader(TextReader reader)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			_reader = reader;
			_lineNumber = 1;
		}

		private void EnsureBufferNotEmpty()
		{
			if (_stringBuffer.IsEmpty)
			{
				_stringBuffer = new StringBuffer(_arrayPool, 1024);
			}
		}

		private void OnNewLine(int pos)
		{
			_lineNumber++;
			_lineStartPos = pos;
		}

		private void ParseString(char quote, ReadType readType)
		{
			_charPos++;
			ShiftBufferIfNeeded();
			ReadStringIntoBuffer(quote);
			SetPostValueState(updateIndex: true);
			switch (readType)
			{
			case ReadType.ReadAsBytes:
			{
				Guid g;
				byte[] value2 = ((_stringReference.Length == 0) ? new byte[0] : ((_stringReference.Length != 36 || !ConvertUtils.TryConvertGuid(_stringReference.ToString(), out g)) ? Convert.FromBase64CharArray(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length) : g.ToByteArray()));
				SetToken(JsonToken.Bytes, value2, updateIndex: false);
				return;
			}
			case ReadType.ReadAsString:
			{
				string value = _stringReference.ToString();
				SetToken(JsonToken.String, value, updateIndex: false);
				_quoteChar = quote;
				return;
			}
			case ReadType.ReadAsInt32:
			case ReadType.ReadAsDecimal:
			case ReadType.ReadAsBoolean:
				return;
			}
			if (_dateParseHandling != DateParseHandling.None)
			{
				DateTimeOffset dt2;
				if (readType switch
				{
					ReadType.ReadAsDateTime => 1, 
					ReadType.ReadAsDateTimeOffset => 2, 
					_ => (int)_dateParseHandling, 
				} == 1)
				{
					if (DateTimeUtils.TryParseDateTime(_stringReference, base.DateTimeZoneHandling, base.DateFormatString, base.Culture, out var dt))
					{
						SetToken(JsonToken.Date, dt, updateIndex: false);
						return;
					}
				}
				else if (DateTimeUtils.TryParseDateTimeOffset(_stringReference, base.DateFormatString, base.Culture, out dt2))
				{
					SetToken(JsonToken.Date, dt2, updateIndex: false);
					return;
				}
			}
			SetToken(JsonToken.String, _stringReference.ToString(), updateIndex: false);
			_quoteChar = quote;
		}

		private static void BlockCopyChars(char[] src, int srcOffset, char[] dst, int dstOffset, int count)
		{
			Buffer.BlockCopy(src, srcOffset * 2, dst, dstOffset * 2, count * 2);
		}

		private void ShiftBufferIfNeeded()
		{
			int num = _chars.Length;
			if ((double)(num - _charPos) <= (double)num * 0.1)
			{
				int num2 = _charsUsed - _charPos;
				if (num2 > 0)
				{
					BlockCopyChars(_chars, _charPos, _chars, 0, num2);
				}
				_lineStartPos -= _charPos;
				_charPos = 0;
				_charsUsed = num2;
				_chars[_charsUsed] = '\0';
			}
		}

		private int ReadData(bool append)
		{
			return ReadData(append, 0);
		}

		private int ReadData(bool append, int charsRequired)
		{
			if (_isEndOfFile)
			{
				return 0;
			}
			if (_charsUsed + charsRequired >= _chars.Length - 1)
			{
				if (append)
				{
					int minSize = Math.Max(_chars.Length * 2, _charsUsed + charsRequired + 1);
					char[] array = BufferUtils.RentBuffer(_arrayPool, minSize);
					BlockCopyChars(_chars, 0, array, 0, _chars.Length);
					BufferUtils.ReturnBuffer(_arrayPool, _chars);
					_chars = array;
				}
				else
				{
					int num = _charsUsed - _charPos;
					if (num + charsRequired + 1 >= _chars.Length)
					{
						char[] array2 = BufferUtils.RentBuffer(_arrayPool, num + charsRequired + 1);
						if (num > 0)
						{
							BlockCopyChars(_chars, _charPos, array2, 0, num);
						}
						BufferUtils.ReturnBuffer(_arrayPool, _chars);
						_chars = array2;
					}
					else if (num > 0)
					{
						BlockCopyChars(_chars, _charPos, _chars, 0, num);
					}
					_lineStartPos -= _charPos;
					_charPos = 0;
					_charsUsed = num;
				}
			}
			int count = _chars.Length - _charsUsed - 1;
			int num2 = _reader.Read(_chars, _charsUsed, count);
			_charsUsed += num2;
			if (num2 == 0)
			{
				_isEndOfFile = true;
			}
			_chars[_charsUsed] = '\0';
			return num2;
		}

		private bool EnsureChars(int relativePosition, bool append)
		{
			if (_charPos + relativePosition >= _charsUsed)
			{
				return ReadChars(relativePosition, append);
			}
			return true;
		}

		private bool ReadChars(int relativePosition, bool append)
		{
			if (_isEndOfFile)
			{
				return false;
			}
			int num = _charPos + relativePosition - _charsUsed + 1;
			int num2 = 0;
			do
			{
				int num3 = ReadData(append, num - num2);
				if (num3 == 0)
				{
					break;
				}
				num2 += num3;
			}
			while (num2 < num);
			if (num2 < num)
			{
				return false;
			}
			return true;
		}

		public override bool Read()
		{
			EnsureBuffer();
			do
			{
				switch (_currentState)
				{
				case State.Start:
				case State.Property:
				case State.ArrayStart:
				case State.Array:
				case State.ConstructorStart:
				case State.Constructor:
					return ParseValue();
				case State.ObjectStart:
				case State.Object:
					return ParseObject();
				case State.PostValue:
					break;
				case State.Finished:
					if (EnsureChars(0, append: false))
					{
						EatWhitespace(oneOrMore: false);
						if (_isEndOfFile)
						{
							SetToken(JsonToken.None);
							return false;
						}
						if (_chars[_charPos] == '/')
						{
							ParseComment(setToken: true);
							return true;
						}
						throw JsonReaderException.Create(this, "Additional text encountered after finished reading JSON content: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
					}
					SetToken(JsonToken.None);
					return false;
				default:
					throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
				}
			}
			while (!ParsePostValue());
			return true;
		}

		public override int? ReadAsInt32()
		{
			return (int?)ReadNumberValue(ReadType.ReadAsInt32);
		}

		public override DateTime? ReadAsDateTime()
		{
			return (DateTime?)ReadStringValue(ReadType.ReadAsDateTime);
		}

		public override string ReadAsString()
		{
			return (string)ReadStringValue(ReadType.ReadAsString);
		}

		public override byte[] ReadAsBytes()
		{
			EnsureBuffer();
			bool flag = false;
			switch (_currentState)
			{
			case State.Start:
			case State.Property:
			case State.ArrayStart:
			case State.Array:
			case State.PostValue:
			case State.ConstructorStart:
			case State.Constructor:
				while (true)
				{
					char c = _chars[_charPos];
					switch (c)
					{
					case '\0':
						if (ReadNullChar())
						{
							SetToken(JsonToken.None, null, updateIndex: false);
							return null;
						}
						break;
					case '"':
					case '\'':
					{
						ParseString(c, ReadType.ReadAsBytes);
						byte[] array = (byte[])Value;
						if (flag)
						{
							ReaderReadAndAssert();
							if (TokenType != JsonToken.EndObject)
							{
								throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
							}
							SetToken(JsonToken.Bytes, array, updateIndex: false);
						}
						return array;
					}
					case '{':
						_charPos++;
						SetToken(JsonToken.StartObject);
						ReadIntoWrappedTypeObject();
						flag = true;
						break;
					case '[':
						_charPos++;
						SetToken(JsonToken.StartArray);
						return ReadArrayIntoByteArray();
					case 'n':
						HandleNull();
						return null;
					case '/':
						ParseComment(setToken: false);
						break;
					case ',':
						ProcessValueComma();
						break;
					case ']':
						_charPos++;
						if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
						{
							SetToken(JsonToken.EndArray);
							return null;
						}
						throw CreateUnexpectedCharacterException(c);
					case '\r':
						ProcessCarriageReturn(append: false);
						break;
					case '\n':
						ProcessLineFeed();
						break;
					case '\t':
					case ' ':
						_charPos++;
						break;
					default:
						_charPos++;
						if (!char.IsWhiteSpace(c))
						{
							throw CreateUnexpectedCharacterException(c);
						}
						break;
					}
				}
			case State.Finished:
				ReadFinished();
				return null;
			default:
				throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
			}
		}

		private object ReadStringValue(ReadType readType)
		{
			EnsureBuffer();
			switch (_currentState)
			{
			case State.Start:
			case State.Property:
			case State.ArrayStart:
			case State.Array:
			case State.PostValue:
			case State.ConstructorStart:
			case State.Constructor:
				while (true)
				{
					char c = _chars[_charPos];
					switch (c)
					{
					case '\0':
						if (ReadNullChar())
						{
							SetToken(JsonToken.None, null, updateIndex: false);
							return null;
						}
						break;
					case '"':
					case '\'':
						ParseString(c, readType);
						switch (readType)
						{
						case ReadType.ReadAsBytes:
							return Value;
						case ReadType.ReadAsString:
							return Value;
						case ReadType.ReadAsDateTime:
							if (Value is DateTime)
							{
								return (DateTime)Value;
							}
							return ReadDateTimeString((string)Value);
						case ReadType.ReadAsDateTimeOffset:
							if (Value is DateTimeOffset)
							{
								return (DateTimeOffset)Value;
							}
							return ReadDateTimeOffsetString((string)Value);
						default:
							throw new ArgumentOutOfRangeException("readType");
						}
					case '-':
						if (EnsureChars(1, append: true) && _chars[_charPos + 1] == 'I')
						{
							return ParseNumberNegativeInfinity(readType);
						}
						ParseNumber(readType);
						return Value;
					case '.':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						if (readType != ReadType.ReadAsString)
						{
							_charPos++;
							throw CreateUnexpectedCharacterException(c);
						}
						ParseNumber(ReadType.ReadAsString);
						return Value;
					case 'f':
					case 't':
					{
						if (readType != ReadType.ReadAsString)
						{
							_charPos++;
							throw CreateUnexpectedCharacterException(c);
						}
						string text = ((c == 't') ? JsonConvert.True : JsonConvert.False);
						if (!MatchValueWithTrailingSeparator(text))
						{
							throw CreateUnexpectedCharacterException(_chars[_charPos]);
						}
						SetToken(JsonToken.String, text);
						return text;
					}
					case 'I':
						return ParseNumberPositiveInfinity(readType);
					case 'N':
						return ParseNumberNaN(readType);
					case 'n':
						HandleNull();
						return null;
					case '/':
						ParseComment(setToken: false);
						break;
					case ',':
						ProcessValueComma();
						break;
					case ']':
						_charPos++;
						if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
						{
							SetToken(JsonToken.EndArray);
							return null;
						}
						throw CreateUnexpectedCharacterException(c);
					case '\r':
						ProcessCarriageReturn(append: false);
						break;
					case '\n':
						ProcessLineFeed();
						break;
					case '\t':
					case ' ':
						_charPos++;
						break;
					default:
						_charPos++;
						if (!char.IsWhiteSpace(c))
						{
							throw CreateUnexpectedCharacterException(c);
						}
						break;
					}
				}
			case State.Finished:
				ReadFinished();
				return null;
			default:
				throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
			}
		}

		private JsonReaderException CreateUnexpectedCharacterException(char c)
		{
			return JsonReaderException.Create(this, "Unexpected character encountered while parsing value: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
		}

		public override bool? ReadAsBoolean()
		{
			EnsureBuffer();
			switch (_currentState)
			{
			case State.Start:
			case State.Property:
			case State.ArrayStart:
			case State.Array:
			case State.PostValue:
			case State.ConstructorStart:
			case State.Constructor:
				while (true)
				{
					char c = _chars[_charPos];
					switch (c)
					{
					case '\0':
						if (ReadNullChar())
						{
							SetToken(JsonToken.None, null, updateIndex: false);
							return null;
						}
						break;
					case '"':
					case '\'':
						ParseString(c, ReadType.Read);
						return ReadBooleanString(_stringReference.ToString());
					case 'n':
						HandleNull();
						return null;
					case '-':
					case '.':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
					{
						ParseNumber(ReadType.Read);
						bool flag2 = Convert.ToBoolean(Value, CultureInfo.InvariantCulture);
						SetToken(JsonToken.Boolean, flag2, updateIndex: false);
						return flag2;
					}
					case 'f':
					case 't':
					{
						bool flag = c == 't';
						string value = (flag ? JsonConvert.True : JsonConvert.False);
						if (!MatchValueWithTrailingSeparator(value))
						{
							throw CreateUnexpectedCharacterException(_chars[_charPos]);
						}
						SetToken(JsonToken.Boolean, flag);
						return flag;
					}
					case '/':
						ParseComment(setToken: false);
						break;
					case ',':
						ProcessValueComma();
						break;
					case ']':
						_charPos++;
						if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
						{
							SetToken(JsonToken.EndArray);
							return null;
						}
						throw CreateUnexpectedCharacterException(c);
					case '\r':
						ProcessCarriageReturn(append: false);
						break;
					case '\n':
						ProcessLineFeed();
						break;
					case '\t':
					case ' ':
						_charPos++;
						break;
					default:
						_charPos++;
						if (!char.IsWhiteSpace(c))
						{
							throw CreateUnexpectedCharacterException(c);
						}
						break;
					}
				}
			case State.Finished:
				ReadFinished();
				return null;
			default:
				throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
			}
		}

		private void ProcessValueComma()
		{
			_charPos++;
			if (_currentState != State.PostValue)
			{
				SetToken(JsonToken.Undefined);
				throw CreateUnexpectedCharacterException(',');
			}
			SetStateBasedOnCurrent();
		}

		private object ReadNumberValue(ReadType readType)
		{
			EnsureBuffer();
			switch (_currentState)
			{
			case State.Start:
			case State.Property:
			case State.ArrayStart:
			case State.Array:
			case State.PostValue:
			case State.ConstructorStart:
			case State.Constructor:
				while (true)
				{
					char c = _chars[_charPos];
					switch (c)
					{
					case '\0':
						if (ReadNullChar())
						{
							SetToken(JsonToken.None, null, updateIndex: false);
							return null;
						}
						break;
					case '"':
					case '\'':
						ParseString(c, readType);
						return readType switch
						{
							ReadType.ReadAsInt32 => ReadInt32String(_stringReference.ToString()), 
							ReadType.ReadAsDecimal => ReadDecimalString(_stringReference.ToString()), 
							ReadType.ReadAsDouble => ReadDoubleString(_stringReference.ToString()), 
							_ => throw new ArgumentOutOfRangeException("readType"), 
						};
					case 'n':
						HandleNull();
						return null;
					case 'N':
						return ParseNumberNaN(readType);
					case 'I':
						return ParseNumberPositiveInfinity(readType);
					case '-':
						if (EnsureChars(1, append: true) && _chars[_charPos + 1] == 'I')
						{
							return ParseNumberNegativeInfinity(readType);
						}
						ParseNumber(readType);
						return Value;
					case '.':
					case '0':
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9':
						ParseNumber(readType);
						return Value;
					case '/':
						ParseComment(setToken: false);
						break;
					case ',':
						ProcessValueComma();
						break;
					case ']':
						_charPos++;
						if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)
						{
							SetToken(JsonToken.EndArray);
							return null;
						}
						throw CreateUnexpectedCharacterException(c);
					case '\r':
						ProcessCarriageReturn(append: false);
						break;
					case '\n':
						ProcessLineFeed();
						break;
					case '\t':
					case ' ':
						_charPos++;
						break;
					default:
						_charPos++;
						if (!char.IsWhiteSpace(c))
						{
							throw CreateUnexpectedCharacterException(c);
						}
						break;
					}
				}
			case State.Finished:
				ReadFinished();
				return null;
			default:
				throw JsonReaderException.Create(this, "Unexpected state: {0}.".FormatWith(CultureInfo.InvariantCulture, base.CurrentState));
			}
		}

		public override DateTimeOffset? ReadAsDateTimeOffset()
		{
			return (DateTimeOffset?)ReadStringValue(ReadType.ReadAsDateTimeOffset);
		}

		public override decimal? ReadAsDecimal()
		{
			return (decimal?)ReadNumberValue(ReadType.ReadAsDecimal);
		}

		public override double? ReadAsDouble()
		{
			return (double?)ReadNumberValue(ReadType.ReadAsDouble);
		}

		private void HandleNull()
		{
			if (EnsureChars(1, append: true))
			{
				if (_chars[_charPos + 1] == 'u')
				{
					ParseNull();
					return;
				}
				_charPos += 2;
				throw CreateUnexpectedCharacterException(_chars[_charPos - 1]);
			}
			_charPos = _charsUsed;
			throw CreateUnexpectedEndException();
		}

		private void ReadFinished()
		{
			if (EnsureChars(0, append: false))
			{
				EatWhitespace(oneOrMore: false);
				if (_isEndOfFile)
				{
					return;
				}
				if (_chars[_charPos] != '/')
				{
					throw JsonReaderException.Create(this, "Additional text encountered after finished reading JSON content: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				ParseComment(setToken: false);
			}
			SetToken(JsonToken.None);
		}

		private bool ReadNullChar()
		{
			if (_charsUsed == _charPos)
			{
				if (ReadData(append: false) == 0)
				{
					_isEndOfFile = true;
					return true;
				}
			}
			else
			{
				_charPos++;
			}
			return false;
		}

		private void EnsureBuffer()
		{
			if (_chars == null)
			{
				_chars = BufferUtils.RentBuffer(_arrayPool, 1024);
				_chars[0] = '\0';
			}
		}

		private void ReadStringIntoBuffer(char quote)
		{
			int num = _charPos;
			int charPos = _charPos;
			int num2 = _charPos;
			_stringBuffer.Position = 0;
			while (true)
			{
				switch (_chars[num++])
				{
				case '\0':
					if (_charsUsed == num - 1)
					{
						num--;
						if (ReadData(append: true) == 0)
						{
							_charPos = num;
							throw JsonReaderException.Create(this, "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture, quote));
						}
					}
					break;
				case '\\':
				{
					_charPos = num;
					if (!EnsureChars(0, append: true))
					{
						throw JsonReaderException.Create(this, "Unterminated string. Expected delimiter: {0}.".FormatWith(CultureInfo.InvariantCulture, quote));
					}
					int writeToPosition = num - 1;
					char c = _chars[num];
					num++;
					char c2;
					switch (c)
					{
					case 'b':
						c2 = '\b';
						break;
					case 't':
						c2 = '\t';
						break;
					case 'n':
						c2 = '\n';
						break;
					case 'f':
						c2 = '\f';
						break;
					case 'r':
						c2 = '\r';
						break;
					case '\\':
						c2 = '\\';
						break;
					case '"':
					case '\'':
					case '/':
						c2 = c;
						break;
					case 'u':
						_charPos = num;
						c2 = ParseUnicode();
						if (StringUtils.IsLowSurrogate(c2))
						{
							c2 = '\ufffd';
						}
						else if (StringUtils.IsHighSurrogate(c2))
						{
							bool flag;
							do
							{
								flag = false;
								if (EnsureChars(2, append: true) && _chars[_charPos] == '\\' && _chars[_charPos + 1] == 'u')
								{
									char writeChar = c2;
									_charPos += 2;
									c2 = ParseUnicode();
									if (!StringUtils.IsLowSurrogate(c2))
									{
										if (StringUtils.IsHighSurrogate(c2))
										{
											writeChar = '\ufffd';
											flag = true;
										}
										else
										{
											writeChar = '\ufffd';
										}
									}
									EnsureBufferNotEmpty();
									WriteCharToBuffer(writeChar, num2, writeToPosition);
									num2 = _charPos;
								}
								else
								{
									c2 = '\ufffd';
								}
							}
							while (flag);
						}
						num = _charPos;
						break;
					default:
						_charPos = num;
						throw JsonReaderException.Create(this, "Bad JSON escape sequence: {0}.".FormatWith(CultureInfo.InvariantCulture, "\\" + c));
					}
					EnsureBufferNotEmpty();
					WriteCharToBuffer(c2, num2, writeToPosition);
					num2 = num;
					break;
				}
				case '\r':
					_charPos = num - 1;
					ProcessCarriageReturn(append: true);
					num = _charPos;
					break;
				case '\n':
					_charPos = num - 1;
					ProcessLineFeed();
					num = _charPos;
					break;
				case '"':
				case '\'':
					if (_chars[num - 1] != quote)
					{
						break;
					}
					num--;
					if (charPos == num2)
					{
						_stringReference = new StringReference(_chars, charPos, num - charPos);
					}
					else
					{
						EnsureBufferNotEmpty();
						if (num > num2)
						{
							_stringBuffer.Append(_arrayPool, _chars, num2, num - num2);
						}
						_stringReference = new StringReference(_stringBuffer.InternalBuffer, 0, _stringBuffer.Position);
					}
					num++;
					_charPos = num;
					return;
				}
			}
		}

		private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition)
		{
			if (writeToPosition > lastWritePosition)
			{
				_stringBuffer.Append(_arrayPool, _chars, lastWritePosition, writeToPosition - lastWritePosition);
			}
			_stringBuffer.Append(_arrayPool, writeChar);
		}

		private char ParseUnicode()
		{
			if (EnsureChars(4, append: true))
			{
				char result = Convert.ToChar(ConvertUtils.HexTextToInt(_chars, _charPos, _charPos + 4));
				_charPos += 4;
				return result;
			}
			throw JsonReaderException.Create(this, "Unexpected end while parsing unicode character.");
		}

		private void ReadNumberIntoBuffer()
		{
			int num = _charPos;
			while (true)
			{
				switch (_chars[num])
				{
				case '\0':
					_charPos = num;
					if (_charsUsed != num || ReadData(append: true) == 0)
					{
						return;
					}
					continue;
				case '+':
				case '-':
				case '.':
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'X':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'x':
					num++;
					continue;
				}
				_charPos = num;
				char c = _chars[_charPos];
				if (char.IsWhiteSpace(c) || c == ',' || c == '}' || c == ']' || c == ')' || c == '/')
				{
					return;
				}
				throw JsonReaderException.Create(this, "Unexpected character encountered while parsing number: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
			}
		}

		private void ClearRecentString()
		{
			_stringBuffer.Position = 0;
			_stringReference = default(StringReference);
		}

		private bool ParsePostValue()
		{
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: false) == 0)
						{
							_currentState = State.Finished;
							return false;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '}':
					_charPos++;
					SetToken(JsonToken.EndObject);
					return true;
				case ']':
					_charPos++;
					SetToken(JsonToken.EndArray);
					return true;
				case ')':
					_charPos++;
					SetToken(JsonToken.EndConstructor);
					return true;
				case '/':
					ParseComment(setToken: true);
					return true;
				case ',':
					_charPos++;
					SetStateBasedOnCurrent();
					return false;
				case '\t':
				case ' ':
					_charPos++;
					break;
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				default:
					if (char.IsWhiteSpace(c))
					{
						_charPos++;
						break;
					}
					throw JsonReaderException.Create(this, "After parsing a value an unexpected character was encountered: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
				}
			}
		}

		private bool ParseObject()
		{
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: false) == 0)
						{
							return false;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '}':
					SetToken(JsonToken.EndObject);
					_charPos++;
					return true;
				case '/':
					ParseComment(setToken: true);
					return true;
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				case '\t':
				case ' ':
					_charPos++;
					break;
				default:
					if (char.IsWhiteSpace(c))
					{
						_charPos++;
						break;
					}
					return ParseProperty();
				}
			}
		}

		private bool ParseProperty()
		{
			char c = _chars[_charPos];
			char c2;
			if (c == '"' || c == '\'')
			{
				_charPos++;
				c2 = c;
				ShiftBufferIfNeeded();
				ReadStringIntoBuffer(c2);
			}
			else
			{
				if (!ValidIdentifierChar(c))
				{
					throw JsonReaderException.Create(this, "Invalid property identifier character: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				c2 = '\0';
				ShiftBufferIfNeeded();
				ParseUnquotedProperty();
			}
			string text;
			if (NameTable != null)
			{
				text = NameTable.Get(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length);
				if (text == null)
				{
					text = _stringReference.ToString();
				}
			}
			else
			{
				text = _stringReference.ToString();
			}
			EatWhitespace(oneOrMore: false);
			if (_chars[_charPos] != ':')
			{
				throw JsonReaderException.Create(this, "Invalid character after parsing property name. Expected ':' but got: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
			}
			_charPos++;
			SetToken(JsonToken.PropertyName, text);
			_quoteChar = c2;
			ClearRecentString();
			return true;
		}

		private bool ValidIdentifierChar(char value)
		{
			if (!char.IsLetterOrDigit(value) && value != '_')
			{
				return value == '$';
			}
			return true;
		}

		private void ParseUnquotedProperty()
		{
			int charPos = _charPos;
			char c;
			while (true)
			{
				if (_chars[_charPos] == '\0')
				{
					if (_charsUsed != _charPos)
					{
						_stringReference = new StringReference(_chars, charPos, _charPos - charPos);
						return;
					}
					if (ReadData(append: true) == 0)
					{
						throw JsonReaderException.Create(this, "Unexpected end while parsing unquoted property name.");
					}
				}
				else
				{
					c = _chars[_charPos];
					if (!ValidIdentifierChar(c))
					{
						break;
					}
					_charPos++;
				}
			}
			if (char.IsWhiteSpace(c) || c == ':')
			{
				_stringReference = new StringReference(_chars, charPos, _charPos - charPos);
				return;
			}
			throw JsonReaderException.Create(this, "Invalid JavaScript property identifier character: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
		}

		private bool ParseValue()
		{
			while (true)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: false) == 0)
						{
							return false;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '"':
				case '\'':
					ParseString(c, ReadType.Read);
					return true;
				case 't':
					ParseTrue();
					return true;
				case 'f':
					ParseFalse();
					return true;
				case 'n':
					if (EnsureChars(1, append: true))
					{
						switch (_chars[_charPos + 1])
						{
						case 'u':
							ParseNull();
							break;
						case 'e':
							ParseConstructor();
							break;
						default:
							throw CreateUnexpectedCharacterException(_chars[_charPos]);
						}
						return true;
					}
					_charPos++;
					throw CreateUnexpectedEndException();
				case 'N':
					ParseNumberNaN(ReadType.Read);
					return true;
				case 'I':
					ParseNumberPositiveInfinity(ReadType.Read);
					return true;
				case '-':
					if (EnsureChars(1, append: true) && _chars[_charPos + 1] == 'I')
					{
						ParseNumberNegativeInfinity(ReadType.Read);
					}
					else
					{
						ParseNumber(ReadType.Read);
					}
					return true;
				case '/':
					ParseComment(setToken: true);
					return true;
				case 'u':
					ParseUndefined();
					return true;
				case '{':
					_charPos++;
					SetToken(JsonToken.StartObject);
					return true;
				case '[':
					_charPos++;
					SetToken(JsonToken.StartArray);
					return true;
				case ']':
					_charPos++;
					SetToken(JsonToken.EndArray);
					return true;
				case ',':
					SetToken(JsonToken.Undefined);
					return true;
				case ')':
					_charPos++;
					SetToken(JsonToken.EndConstructor);
					return true;
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				case '\t':
				case ' ':
					_charPos++;
					break;
				default:
					if (char.IsWhiteSpace(c))
					{
						_charPos++;
						break;
					}
					if (char.IsNumber(c) || c == '-' || c == '.')
					{
						ParseNumber(ReadType.Read);
						return true;
					}
					throw CreateUnexpectedCharacterException(c);
				}
			}
		}

		private void ProcessLineFeed()
		{
			_charPos++;
			OnNewLine(_charPos);
		}

		private void ProcessCarriageReturn(bool append)
		{
			_charPos++;
			if (EnsureChars(1, append) && _chars[_charPos] == '\n')
			{
				_charPos++;
			}
			OnNewLine(_charPos);
		}

		private bool EatWhitespace(bool oneOrMore)
		{
			bool flag = false;
			bool flag2 = false;
			while (!flag)
			{
				char c = _chars[_charPos];
				switch (c)
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: false) == 0)
						{
							flag = true;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '\r':
					ProcessCarriageReturn(append: false);
					break;
				case '\n':
					ProcessLineFeed();
					break;
				default:
					if (!char.IsWhiteSpace(c))
					{
						flag = true;
						break;
					}
					goto case ' ';
				case ' ':
					flag2 = true;
					_charPos++;
					break;
				}
			}
			return !oneOrMore || flag2;
		}

		private void ParseConstructor()
		{
			if (MatchValueWithTrailingSeparator("new"))
			{
				EatWhitespace(oneOrMore: false);
				int charPos = _charPos;
				int charPos2;
				while (true)
				{
					char c = _chars[_charPos];
					if (c == '\0')
					{
						if (_charsUsed == _charPos)
						{
							if (ReadData(append: true) == 0)
							{
								throw JsonReaderException.Create(this, "Unexpected end while parsing constructor.");
							}
							continue;
						}
						charPos2 = _charPos;
						_charPos++;
						break;
					}
					if (char.IsLetterOrDigit(c))
					{
						_charPos++;
						continue;
					}
					switch (c)
					{
					case '\r':
						charPos2 = _charPos;
						ProcessCarriageReturn(append: true);
						break;
					case '\n':
						charPos2 = _charPos;
						ProcessLineFeed();
						break;
					default:
						if (char.IsWhiteSpace(c))
						{
							charPos2 = _charPos;
							_charPos++;
							break;
						}
						if (c == '(')
						{
							charPos2 = _charPos;
							break;
						}
						throw JsonReaderException.Create(this, "Unexpected character while parsing constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, c));
					}
					break;
				}
				_stringReference = new StringReference(_chars, charPos, charPos2 - charPos);
				string value = _stringReference.ToString();
				EatWhitespace(oneOrMore: false);
				if (_chars[_charPos] != '(')
				{
					throw JsonReaderException.Create(this, "Unexpected character while parsing constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				_charPos++;
				ClearRecentString();
				SetToken(JsonToken.StartConstructor, value);
				return;
			}
			throw JsonReaderException.Create(this, "Unexpected content while parsing JSON.");
		}

		private void ParseNumber(ReadType readType)
		{
			ShiftBufferIfNeeded();
			char c = _chars[_charPos];
			int charPos = _charPos;
			ReadNumberIntoBuffer();
			SetPostValueState(updateIndex: true);
			_stringReference = new StringReference(_chars, charPos, _charPos - charPos);
			bool flag = char.IsDigit(c) && _stringReference.Length == 1;
			bool flag2 = c == '0' && _stringReference.Length > 1 && _stringReference.Chars[_stringReference.StartIndex + 1] != '.' && _stringReference.Chars[_stringReference.StartIndex + 1] != 'e' && _stringReference.Chars[_stringReference.StartIndex + 1] != 'E';
			JsonToken newToken;
			object value;
			switch (readType)
			{
			case ReadType.ReadAsString:
			{
				string text5 = _stringReference.ToString();
				double result5;
				if (flag2)
				{
					try
					{
						if (text5.StartsWith("0x", StringComparison.OrdinalIgnoreCase))
						{
							Convert.ToInt64(text5, 16);
						}
						else
						{
							Convert.ToInt64(text5, 8);
						}
					}
					catch (Exception ex4)
					{
						throw JsonReaderException.Create(this, "Input string '{0}' is not a valid number.".FormatWith(CultureInfo.InvariantCulture, text5), ex4);
					}
				}
				else if (!double.TryParse(text5, NumberStyles.Float, CultureInfo.InvariantCulture, out result5))
				{
					throw JsonReaderException.Create(this, "Input string '{0}' is not a valid number.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
				}
				newToken = JsonToken.String;
				value = text5;
				break;
			}
			case ReadType.ReadAsInt32:
				if (flag)
				{
					value = c - 48;
				}
				else if (flag2)
				{
					string text6 = _stringReference.ToString();
					try
					{
						value = (text6.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt32(text6, 16) : Convert.ToInt32(text6, 8));
					}
					catch (Exception ex5)
					{
						throw JsonReaderException.Create(this, "Input string '{0}' is not a valid integer.".FormatWith(CultureInfo.InvariantCulture, text6), ex5);
					}
				}
				else
				{
					int value3;
					switch (ConvertUtils.Int32TryParse(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length, out value3))
					{
					case ParseResult.Success:
						break;
					case ParseResult.Overflow:
						throw JsonReaderException.Create(this, "JSON integer {0} is too large or small for an Int32.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
					default:
						throw JsonReaderException.Create(this, "Input string '{0}' is not a valid integer.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
					}
					value = value3;
				}
				newToken = JsonToken.Integer;
				break;
			case ReadType.ReadAsDecimal:
				if (flag)
				{
					value = (decimal)c - 48m;
				}
				else if (flag2)
				{
					string text3 = _stringReference.ToString();
					try
					{
						value = Convert.ToDecimal(text3.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt64(text3, 16) : Convert.ToInt64(text3, 8));
					}
					catch (Exception ex2)
					{
						throw JsonReaderException.Create(this, "Input string '{0}' is not a valid decimal.".FormatWith(CultureInfo.InvariantCulture, text3), ex2);
					}
				}
				else
				{
					if (!decimal.TryParse(_stringReference.ToString(), NumberStyles.Number | NumberStyles.AllowExponent, CultureInfo.InvariantCulture, out var result3))
					{
						throw JsonReaderException.Create(this, "Input string '{0}' is not a valid decimal.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
					}
					value = result3;
				}
				newToken = JsonToken.Float;
				break;
			case ReadType.ReadAsDouble:
				if (flag)
				{
					value = (double)(int)c - 48.0;
				}
				else if (flag2)
				{
					string text4 = _stringReference.ToString();
					try
					{
						value = Convert.ToDouble(text4.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt64(text4, 16) : Convert.ToInt64(text4, 8));
					}
					catch (Exception ex3)
					{
						throw JsonReaderException.Create(this, "Input string '{0}' is not a valid double.".FormatWith(CultureInfo.InvariantCulture, text4), ex3);
					}
				}
				else
				{
					if (!double.TryParse(_stringReference.ToString(), NumberStyles.Float, CultureInfo.InvariantCulture, out var result4))
					{
						throw JsonReaderException.Create(this, "Input string '{0}' is not a valid double.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
					}
					value = result4;
				}
				newToken = JsonToken.Float;
				break;
			default:
			{
				if (flag)
				{
					value = (long)c - 48L;
					newToken = JsonToken.Integer;
					break;
				}
				if (flag2)
				{
					string text = _stringReference.ToString();
					try
					{
						value = (text.StartsWith("0x", StringComparison.OrdinalIgnoreCase) ? Convert.ToInt64(text, 16) : Convert.ToInt64(text, 8));
					}
					catch (Exception ex)
					{
						throw JsonReaderException.Create(this, "Input string '{0}' is not a valid number.".FormatWith(CultureInfo.InvariantCulture, text), ex);
					}
					newToken = JsonToken.Integer;
					break;
				}
				long value2;
				switch (ConvertUtils.Int64TryParse(_stringReference.Chars, _stringReference.StartIndex, _stringReference.Length, out value2))
				{
				case ParseResult.Success:
					value = value2;
					newToken = JsonToken.Integer;
					break;
				case ParseResult.Overflow:
					throw JsonReaderException.Create(this, "JSON integer {0} is too large or small for an Int64.".FormatWith(CultureInfo.InvariantCulture, _stringReference.ToString()));
				default:
				{
					string text2 = _stringReference.ToString();
					if (_floatParseHandling == FloatParseHandling.Decimal)
					{
						if (!decimal.TryParse(text2, NumberStyles.Number | NumberStyles.AllowExponent, CultureInfo.InvariantCulture, out var result))
						{
							throw JsonReaderException.Create(this, "Input string '{0}' is not a valid decimal.".FormatWith(CultureInfo.InvariantCulture, text2));
						}
						value = result;
					}
					else
					{
						if (!double.TryParse(text2, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out var result2))
						{
							throw JsonReaderException.Create(this, "Input string '{0}' is not a valid number.".FormatWith(CultureInfo.InvariantCulture, text2));
						}
						value = result2;
					}
					newToken = JsonToken.Float;
					break;
				}
				}
				break;
			}
			}
			ClearRecentString();
			SetToken(newToken, value, updateIndex: false);
		}

		private void ParseComment(bool setToken)
		{
			_charPos++;
			if (!EnsureChars(1, append: false))
			{
				throw JsonReaderException.Create(this, "Unexpected end while parsing comment.");
			}
			bool flag;
			if (_chars[_charPos] == '*')
			{
				flag = false;
			}
			else
			{
				if (_chars[_charPos] != '/')
				{
					throw JsonReaderException.Create(this, "Error parsing comment. Expected: *, got {0}.".FormatWith(CultureInfo.InvariantCulture, _chars[_charPos]));
				}
				flag = true;
			}
			_charPos++;
			int charPos = _charPos;
			while (true)
			{
				switch (_chars[_charPos])
				{
				case '\0':
					if (_charsUsed == _charPos)
					{
						if (ReadData(append: true) == 0)
						{
							if (!flag)
							{
								throw JsonReaderException.Create(this, "Unexpected end while parsing comment.");
							}
							EndComment(setToken, charPos, _charPos);
							return;
						}
					}
					else
					{
						_charPos++;
					}
					break;
				case '*':
					_charPos++;
					if (!flag && EnsureChars(0, append: true) && _chars[_charPos] == '/')
					{
						EndComment(setToken, charPos, _charPos - 1);
						_charPos++;
						return;
					}
					break;
				case '\r':
					if (flag)
					{
						EndComment(setToken, charPos, _charPos);
						return;
					}
					ProcessCarriageReturn(append: true);
					break;
				case '\n':
					if (flag)
					{
						EndComment(setToken, charPos, _charPos);
						return;
					}
					ProcessLineFeed();
					break;
				default:
					_charPos++;
					break;
				}
			}
		}

		private void EndComment(bool setToken, int initialPosition, int endPosition)
		{
			if (setToken)
			{
				SetToken(JsonToken.Comment, new string(_chars, initialPosition, endPosition - initialPosition));
			}
		}

		private bool MatchValue(string value)
		{
			if (!EnsureChars(value.Length - 1, append: true))
			{
				_charPos = _charsUsed;
				throw CreateUnexpectedEndException();
			}
			for (int i = 0; i < value.Length; i++)
			{
				if (_chars[_charPos + i] != value[i])
				{
					_charPos += i;
					return false;
				}
			}
			_charPos += value.Length;
			return true;
		}

		private bool MatchValueWithTrailingSeparator(string value)
		{
			if (!MatchValue(value))
			{
				return false;
			}
			if (!EnsureChars(0, append: false))
			{
				return true;
			}
			if (!IsSeparator(_chars[_charPos]))
			{
				return _chars[_charPos] == '\0';
			}
			return true;
		}

		private bool IsSeparator(char c)
		{
			switch (c)
			{
			case ',':
			case ']':
			case '}':
				return true;
			case '/':
			{
				if (!EnsureChars(1, append: false))
				{
					return false;
				}
				char c2 = _chars[_charPos + 1];
				if (c2 != '*')
				{
					return c2 == '/';
				}
				return true;
			}
			case ')':
				if (base.CurrentState == State.Constructor || base.CurrentState == State.ConstructorStart)
				{
					return true;
				}
				break;
			case '\t':
			case '\n':
			case '\r':
			case ' ':
				return true;
			default:
				if (char.IsWhiteSpace(c))
				{
					return true;
				}
				break;
			}
			return false;
		}

		private void ParseTrue()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.True))
			{
				SetToken(JsonToken.Boolean, true);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing boolean value.");
		}

		private void ParseNull()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.Null))
			{
				SetToken(JsonToken.Null);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing null value.");
		}

		private void ParseUndefined()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.Undefined))
			{
				SetToken(JsonToken.Undefined);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing undefined value.");
		}

		private void ParseFalse()
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.False))
			{
				SetToken(JsonToken.Boolean, false);
				return;
			}
			throw JsonReaderException.Create(this, "Error parsing boolean value.");
		}

		private object ParseNumberNegativeInfinity(ReadType readType)
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.NegativeInfinity))
			{
				switch (readType)
				{
				case ReadType.Read:
				case ReadType.ReadAsDouble:
					if (_floatParseHandling == FloatParseHandling.Double)
					{
						SetToken(JsonToken.Float, double.NegativeInfinity);
						return double.NegativeInfinity;
					}
					break;
				case ReadType.ReadAsString:
					SetToken(JsonToken.String, JsonConvert.NegativeInfinity);
					return JsonConvert.NegativeInfinity;
				}
				throw JsonReaderException.Create(this, "Cannot read -Infinity value.");
			}
			throw JsonReaderException.Create(this, "Error parsing -Infinity value.");
		}

		private object ParseNumberPositiveInfinity(ReadType readType)
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.PositiveInfinity))
			{
				switch (readType)
				{
				case ReadType.Read:
				case ReadType.ReadAsDouble:
					if (_floatParseHandling == FloatParseHandling.Double)
					{
						SetToken(JsonToken.Float, double.PositiveInfinity);
						return double.PositiveInfinity;
					}
					break;
				case ReadType.ReadAsString:
					SetToken(JsonToken.String, JsonConvert.PositiveInfinity);
					return JsonConvert.PositiveInfinity;
				}
				throw JsonReaderException.Create(this, "Cannot read Infinity value.");
			}
			throw JsonReaderException.Create(this, "Error parsing Infinity value.");
		}

		private object ParseNumberNaN(ReadType readType)
		{
			if (MatchValueWithTrailingSeparator(JsonConvert.NaN))
			{
				switch (readType)
				{
				case ReadType.Read:
				case ReadType.ReadAsDouble:
					if (_floatParseHandling == FloatParseHandling.Double)
					{
						SetToken(JsonToken.Float, double.NaN);
						return double.NaN;
					}
					break;
				case ReadType.ReadAsString:
					SetToken(JsonToken.String, JsonConvert.NaN);
					return JsonConvert.NaN;
				}
				throw JsonReaderException.Create(this, "Cannot read NaN value.");
			}
			throw JsonReaderException.Create(this, "Error parsing NaN value.");
		}

		public override void Close()
		{
			base.Close();
			if (_chars != null)
			{
				BufferUtils.ReturnBuffer(_arrayPool, _chars);
				_chars = null;
			}
			if (base.CloseInput && _reader != null)
			{
				_reader.Close();
			}
			_stringBuffer.Clear(_arrayPool);
		}

		public bool HasLineInfo()
		{
			return true;
		}
	}
	[Preserve]
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
	public sealed class JsonPropertyAttribute : Attribute
	{
		internal NullValueHandling? _nullValueHandling;

		internal DefaultValueHandling? _defaultValueHandling;

		internal ReferenceLoopHandling? _referenceLoopHandling;

		internal ObjectCreationHandling? _objectCreationHandling;

		internal TypeNameHandling? _typeNameHandling;

		internal bool? _isReference;

		internal int? _order;

		internal Required? _required;

		internal bool? _itemIsReference;

		internal ReferenceLoopHandling? _itemReferenceLoopHandling;

		internal TypeNameHandling? _itemTypeNameHandling;

		public Type ItemConverterType { get; set; }

		public object[] ItemConverterParameters { get; set; }

		public NullValueHandling NullValueHandling
		{
			get
			{
				return _nullValueHandling ?? NullValueHandling.Include;
			}
			set
			{
				_nullValueHandling = value;
			}
		}

		public DefaultValueHandling DefaultValueHandling
		{
			get
			{
				return _defaultValueHandling ?? DefaultValueHandling.Include;
			}
			set
			{
				_defaultValueHandling = value;
			}
		}

		public ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				return _referenceLoopHandling ?? ReferenceLoopHandling.Error;
			}
			set
			{
				_referenceLoopHandling = value;
			}
		}

		public ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				return _objectCreationHandling ?? ObjectCreationHandling.Auto;
			}
			set
			{
				_objectCreationHandling = value;
			}
		}

		public TypeNameHandling TypeNameHandling
		{
			get
			{
				return _typeNameHandling ?? TypeNameHandling.None;
			}
			set
			{
				_typeNameHandling = value;
			}
		}

		public bool IsReference
		{
			get
			{
				return _isReference ?? false;
			}
			set
			{
				_isReference = value;
			}
		}

		public int Order
		{
			get
			{
				return _order ?? 0;
			}
			set
			{
				_order = value;
			}
		}

		public Required Required
		{
			get
			{
				return _required ?? Required.Default;
			}
			set
			{
				_required = value;
			}
		}

		public string PropertyName { get; set; }

		public ReferenceLoopHandling ItemReferenceLoopHandling
		{
			get
			{
				return _itemReferenceLoopHandling ?? ReferenceLoopHandling.Error;
			}
			set
			{
				_itemReferenceLoopHandling = value;
			}
		}

		public TypeNameHandling ItemTypeNameHandling
		{
			get
			{
				return _itemTypeNameHandling ?? TypeNameHandling.None;
			}
			set
			{
				_itemTypeNameHandling = value;
			}
		}

		public bool ItemIsReference
		{
			get
			{
				return _itemIsReference ?? false;
			}
			set
			{
				_itemIsReference = value;
			}
		}

		public JsonPropertyAttribute()
		{
		}

		public JsonPropertyAttribute(string propertyName)
		{
			PropertyName = propertyName;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	[Preserve]
	public sealed class JsonIgnoreAttribute : Attribute
	{
	}
	[Preserve]
	public class JsonTextWriter : JsonWriter
	{
		private readonly TextWriter _writer;

		private Base64Encoder _base64Encoder;

		private char _indentChar;

		private int _indentation;

		private char _quoteChar;

		private bool _quoteName;

		private bool[] _charEscapeFlags;

		private char[] _writeBuffer;

		private IArrayPool<char> _arrayPool;

		private char[] _indentChars;

		private Base64Encoder Base64Encoder
		{
			get
			{
				if (_base64Encoder == null)
				{
					_base64Encoder = new Base64Encoder(_writer);
				}
				return _base64Encoder;
			}
		}

		public IArrayPool<char> ArrayPool
		{
			get
			{
				return _arrayPool;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				_arrayPool = value;
			}
		}

		public int Indentation
		{
			get
			{
				return _indentation;
			}
			set
			{
				if (value < 0)
				{
					throw new ArgumentException("Indentation value must be greater than 0.");
				}
				_indentation = value;
			}
		}

		public char QuoteChar
		{
			get
			{
				return _quoteChar;
			}
			set
			{
				if (value != '"' && value != '\'')
				{
					throw new ArgumentException("Invalid JavaScript string quote character. Valid quote characters are ' and \".");
				}
				_quoteChar = value;
				UpdateCharEscapeFlags();
			}
		}

		public char IndentChar
		{
			get
			{
				return _indentChar;
			}
			set
			{
				if (value != _indentChar)
				{
					_indentChar = value;
					_indentChars = null;
				}
			}
		}

		public bool QuoteName
		{
			get
			{
				return _quoteName;
			}
			set
			{
				_quoteName = value;
			}
		}

		public JsonTextWriter(TextWriter textWriter)
		{
			if (textWriter == null)
			{
				throw new ArgumentNullException("textWriter");
			}
			_writer = textWriter;
			_quoteChar = '"';
			_quoteName = true;
			_indentChar = ' ';
			_indentation = 2;
			UpdateCharEscapeFlags();
		}

		public override void Flush()
		{
			_writer.Flush();
		}

		public override void Close()
		{
			base.Close();
			if (_writeBuffer != null)
			{
				BufferUtils.ReturnBuffer(_arrayPool, _writeBuffer);
				_writeBuffer = null;
			}
			if (base.CloseOutput && _writer != null)
			{
				_writer.Close();
			}
		}

		public override void WriteStartObject()
		{
			InternalWriteStart(JsonToken.StartObject, JsonContainerType.Object);
			_writer.Write('{');
		}

		public override void WriteStartArray()
		{
			InternalWriteStart(JsonToken.StartArray, JsonContainerType.Array);
			_writer.Write('[');
		}

		public override void WriteStartConstructor(string name)
		{
			InternalWriteStart(JsonToken.StartConstructor, JsonContainerType.Constructor);
			_writer.Write("new ");
			_writer.Write(name);
			_writer.Write('(');
		}

		protected override void WriteEnd(JsonToken token)
		{
			switch (token)
			{
			case JsonToken.EndObject:
				_writer.Write('}');
				break;
			case JsonToken.EndArray:
				_writer.Write(']');
				break;
			case JsonToken.EndConstructor:
				_writer.Write(')');
				break;
			default:
				throw JsonWriterException.Create(this, "Invalid JsonToken: " + token, null);
			}
		}

		public override void WritePropertyName(string name)
		{
			InternalWritePropertyName(name);
			WriteEscapedString(name, _quoteName);
			_writer.Write(':');
		}

		public override void WritePropertyName(string name, bool escape)
		{
			InternalWritePropertyName(name);
			if (escape)
			{
				WriteEscapedString(name, _quoteName);
			}
			else
			{
				if (_quoteName)
				{
					_writer.Write(_quoteChar);
				}
				_writer.Write(name);
				if (_quoteName)
				{
					_writer.Write(_quoteChar);
				}
			}
			_writer.Write(':');
		}

		internal override void OnStringEscapeHandlingChanged()
		{
			UpdateCharEscapeFlags();
		}

		private void UpdateCharEscapeFlags()
		{
			_charEscapeFlags = JavaScriptUtils.GetCharEscapeFlags(base.StringEscapeHandling, _quoteChar);
		}

		protected override void WriteIndent()
		{
			_writer.WriteLine();
			int num = base.Top * _indentation;
			if (num > 0)
			{
				if (_indentChars == null)
				{
					_indentChars = new string(_indentChar, 10).ToCharArray();
				}
				while (num > 0)
				{
					int num2 = Math.Min(num, 10);
					_writer.Write(_indentChars, 0, num2);
					num -= num2;
				}
			}
		}

		protected override void WriteValueDelimiter()
		{
			_writer.Write(',');
		}

		protected override void WriteIndentSpace()
		{
			_writer.Write(' ');
		}

		private void WriteValueInternal(string value, JsonToken token)
		{
			_writer.Write(value);
		}

		public override void WriteValue(object value)
		{
			base.WriteValue(value);
		}

		public override void WriteNull()
		{
			InternalWriteValue(JsonToken.Null);
			WriteValueInternal(JsonConvert.Null, JsonToken.Null);
		}

		public override void WriteUndefined()
		{
			InternalWriteValue(JsonToken.Undefined);
			WriteValueInternal(JsonConvert.Undefined, JsonToken.Undefined);
		}

		public override void WriteRaw(string json)
		{
			InternalWriteRaw();
			_writer.Write(json);
		}

		public override void WriteValue(string value)
		{
			InternalWriteValue(JsonToken.String);
			if (value == null)
			{
				WriteValueInternal(JsonConvert.Null, JsonToken.Null);
			}
			else
			{
				WriteEscapedString(value, quote: true);
			}
		}

		private void WriteEscapedString(string value, bool quote)
		{
			EnsureWriteBuffer();
			JavaScriptUtils.WriteEscapedJavaScriptString(_writer, value, _quoteChar, quote, _charEscapeFlags, base.StringEscapeHandling, _arrayPool, ref _writeBuffer);
		}

		public override void WriteValue(int value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		[CLSCompliant(false)]
		public override void WriteValue(uint value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		public override void WriteValue(long value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		[CLSCompliant(false)]
		public override void WriteValue(ulong value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		public override void WriteValue(float value)
		{
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value, base.FloatFormatHandling, QuoteChar, nullable: false), JsonToken.Float);
		}

		public override void WriteValue(float? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
				return;
			}
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value.GetValueOrDefault(), base.FloatFormatHandling, QuoteChar, nullable: true), JsonToken.Float);
		}

		public override void WriteValue(double value)
		{
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value, base.FloatFormatHandling, QuoteChar, nullable: false), JsonToken.Float);
		}

		public override void WriteValue(double? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
				return;
			}
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value.GetValueOrDefault(), base.FloatFormatHandling, QuoteChar, nullable: true), JsonToken.Float);
		}

		public override void WriteValue(bool value)
		{
			InternalWriteValue(JsonToken.Boolean);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Boolean);
		}

		public override void WriteValue(short value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		[CLSCompliant(false)]
		public override void WriteValue(ushort value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		public override void WriteValue(char value)
		{
			InternalWriteValue(JsonToken.String);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.String);
		}

		public override void WriteValue(byte value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		[CLSCompliant(false)]
		public override void WriteValue(sbyte value)
		{
			InternalWriteValue(JsonToken.Integer);
			WriteIntegerValue(value);
		}

		public override void WriteValue(decimal value)
		{
			InternalWriteValue(JsonToken.Float);
			WriteValueInternal(JsonConvert.ToString(value), JsonToken.Float);
		}

		public override void WriteValue(DateTime value)
		{
			InternalWriteValue(JsonToken.Date);
			value = DateTimeUtils.EnsureDateTime(value, base.DateTimeZoneHandling);
			if (string.IsNullOrEmpty(base.DateFormatString))
			{
				EnsureWriteBuffer();
				int start = 0;
				_writeBuffer[start++] = _quoteChar;
				start = DateTimeUtils.WriteDateTimeString(_writeBuffer, start, value, null, value.Kind, base.DateFormatHandling);
				_writeBuffer[start++] = _quoteChar;
				_writer.Write(_writeBuffer, 0, start);
			}
			else
			{
				_writer.Write(_quoteChar);
				_writer.Write(value.ToString(base.DateFormatString, base.Culture));
				_writer.Write(_quoteChar);
			}
		}

		public override void WriteValue(byte[] value)
		{
			if (value == null)
			{
				WriteNull();
				return;
			}
			InternalWriteValue(JsonToken.Bytes);
			_writer.Write(_quoteChar);
			Base64Encoder.Encode(value, 0, value.Length);
			Base64Encoder.Flush();
			_writer.Write(_quoteChar);
		}

		public override void WriteValue(DateTimeOffset value)
		{
			InternalWriteValue(JsonToken.Date);
			if (string.IsNullOrEmpty(base.DateFormatString))
			{
				EnsureWriteBuffer();
				int start = 0;
				_writeBuffer[start++] = _quoteChar;
				start = DateTimeUtils.WriteDateTimeString(_writeBuffer, start, (base.DateFormatHandling == DateFormatHandling.IsoDateFormat) ? value.DateTime : value.UtcDateTime, value.Offset, DateTimeKind.Local, base.DateFormatHandling);
				_writeBuffer[start++] = _quoteChar;
				_writer.Write(_writeBuffer, 0, start);
			}
			else
			{
				_writer.Write(_quoteChar);
				_writer.Write(value.ToString(base.DateFormatString, base.Culture));
				_writer.Write(_quoteChar);
			}
		}

		public override void WriteValue(Guid value)
		{
			InternalWriteValue(JsonToken.String);
			string text = null;
			text = value.ToString("D", CultureInfo.InvariantCulture);
			_writer.Write(_quoteChar);
			_writer.Write(text);
			_writer.Write(_quoteChar);
		}

		public override void WriteValue(TimeSpan value)
		{
			InternalWriteValue(JsonToken.String);
			string value2 = value.ToString();
			_writer.Write(_quoteChar);
			_writer.Write(value2);
			_writer.Write(_quoteChar);
		}

		public override void WriteValue(Uri value)
		{
			if (value == null)
			{
				WriteNull();
				return;
			}
			InternalWriteValue(JsonToken.String);
			WriteEscapedString(value.OriginalString, quote: true);
		}

		public override void WriteComment(string text)
		{
			InternalWriteComment();
			_writer.Write("/*");
			_writer.Write(text);
			_writer.Write("*/");
		}

		public override void WriteWhitespace(string ws)
		{
			InternalWriteWhitespace(ws);
			_writer.Write(ws);
		}

		private void EnsureWriteBuffer()
		{
			if (_writeBuffer == null)
			{
				_writeBuffer = BufferUtils.RentBuffer(_arrayPool, 35);
			}
		}

		private void WriteIntegerValue(long value)
		{
			if (value >= 0 && value <= 9)
			{
				_writer.Write((char)(48 + value));
				return;
			}
			ulong uvalue = (ulong)((value < 0) ? (-value) : value);
			if (value < 0)
			{
				_writer.Write('-');
			}
			WriteIntegerValue(uvalue);
		}

		private void WriteIntegerValue(ulong uvalue)
		{
			if (uvalue <= 9)
			{
				_writer.Write((char)(48 + uvalue));
				return;
			}
			EnsureWriteBuffer();
			int num = MathUtils.IntLength(uvalue);
			int num2 = 0;
			do
			{
				_writeBuffer[num - ++num2] = (char)(48 + uvalue % 10);
				uvalue /= 10;
			}
			while (uvalue != 0L);
			_writer.Write(_writeBuffer, 0, num2);
		}
	}
	[Serializable]
	[Preserve]
	public class JsonWriterException : JsonException
	{
		public string Path { get; private set; }

		public JsonWriterException()
		{
		}

		public JsonWriterException(string message)
			: base(message)
		{
		}

		public JsonWriterException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		public JsonWriterException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		internal JsonWriterException(string message, Exception innerException, string path)
			: base(message, innerException)
		{
			Path = path;
		}

		internal static JsonWriterException Create(JsonWriter writer, string message, Exception ex)
		{
			return Create(writer.ContainerPath, message, ex);
		}

		internal static JsonWriterException Create(string path, string message, Exception ex)
		{
			message = JsonPosition.FormatMessage(null, path, message);
			return new JsonWriterException(message, ex, path);
		}
	}
	[Serializable]
	[Preserve]
	public class JsonReaderException : JsonException
	{
		public int LineNumber { get; private set; }

		public int LinePosition { get; private set; }

		public string Path { get; private set; }

		public JsonReaderException()
		{
		}

		public JsonReaderException(string message)
			: base(message)
		{
		}

		public JsonReaderException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		public JsonReaderException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		internal JsonReaderException(string message, Exception innerException, string path, int lineNumber, int linePosition)
			: base(message, innerException)
		{
			Path = path;
			LineNumber = lineNumber;
			LinePosition = linePosition;
		}

		internal static JsonReaderException Create(JsonReader reader, string message)
		{
			return Create(reader, message, null);
		}

		internal static JsonReaderException Create(JsonReader reader, string message, Exception ex)
		{
			return Create(reader as IJsonLineInfo, reader.Path, message, ex);
		}

		internal static JsonReaderException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex)
		{
			message = JsonPosition.FormatMessage(lineInfo, path, message);
			int lineNumber;
			int linePosition;
			if (lineInfo != null && lineInfo.HasLineInfo())
			{
				lineNumber = lineInfo.LineNumber;
				linePosition = lineInfo.LinePosition;
			}
			else
			{
				lineNumber = 0;
				linePosition = 0;
			}
			return new JsonReaderException(message, ex, path, lineNumber, linePosition);
		}
	}
	[Preserve]
	public abstract class JsonConverter
	{
		public virtual bool CanRead => true;

		public virtual bool CanWrite => true;

		public abstract void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);

		public abstract object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);

		public abstract bool CanConvert(Type objectType);
	}
	[Preserve]
	public class JsonConverterCollection : System.Collections.ObjectModel.Collection<JsonConverter>
	{
	}
	[Preserve]
	public abstract class JsonReader : IDisposable
	{
		protected internal enum State
		{
			Start,
			Complete,
			Property,
			ObjectStart,
			Object,
			ArrayStart,
			Array,
			Closed,
			PostValue,
			ConstructorStart,
			Constructor,
			Error,
			Finished
		}

		private JsonToken _tokenType;

		private object _value;

		internal char _quoteChar;

		internal State _currentState;

		private JsonPosition _currentPosition;

		private CultureInfo _culture;

		private DateTimeZoneHandling _dateTimeZoneHandling;

		private int? _maxDepth;

		private bool _hasExceededMaxDepth;

		internal DateParseHandling _dateParseHandling;

		internal FloatParseHandling _floatParseHandling;

		private string _dateFormatString;

		private List<JsonPosition> _stack;

		protected State CurrentState => _currentState;

		public bool CloseInput { get; set; }

		public bool SupportMultipleContent { get; set; }

		public virtual char QuoteChar
		{
			get
			{
				return _quoteChar;
			}
			protected internal set
			{
				_quoteChar = value;
			}
		}

		public DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				return _dateTimeZoneHandling;
			}
			set
			{
				if (value < DateTimeZoneHandling.Local || value > DateTimeZoneHandling.RoundtripKind)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_dateTimeZoneHandling = value;
			}
		}

		public DateParseHandling DateParseHandling
		{
			get
			{
				return _dateParseHandling;
			}
			set
			{
				if (value < DateParseHandling.None || value > DateParseHandling.DateTimeOffset)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_dateParseHandling = value;
			}
		}

		public FloatParseHandling FloatParseHandling
		{
			get
			{
				return _floatParseHandling;
			}
			set
			{
				if (value < FloatParseHandling.Double || value > FloatParseHandling.Decimal)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_floatParseHandling = value;
			}
		}

		public string DateFormatString
		{
			get
			{
				return _dateFormatString;
			}
			set
			{
				_dateFormatString = value;
			}
		}

		public int? MaxDepth
		{
			get
			{
				return _maxDepth;
			}
			set
			{
				if (value <= 0)
				{
					throw new ArgumentException("Value must be positive.", "value");
				}
				_maxDepth = value;
			}
		}

		public virtual JsonToken TokenType => _tokenType;

		public virtual object Value => _value;

		public virtual Type ValueType
		{
			get
			{
				if (_value == null)
				{
					return null;
				}
				return _value.GetType();
			}
		}

		public virtual int Depth
		{
			get
			{
				int num = ((_stack != null) ? _stack.Count : 0);
				if (JsonTokenUtils.IsStartToken(TokenType) || _currentPosition.Type == JsonContainerType.None)
				{
					return num;
				}
				return num + 1;
			}
		}

		public virtual string Path
		{
			get
			{
				if (_currentPosition.Type == JsonContainerType.None)
				{
					return string.Empty;
				}
				JsonPosition? currentPosition = ((_currentState != State.ArrayStart && _currentState != State.ConstructorStart && _currentState != State.ObjectStart) ? new JsonPosition?(_currentPosition) : ((JsonPosition?)null));
				return JsonPosition.BuildPath(_stack, currentPosition);
			}
		}

		public CultureInfo Culture
		{
			get
			{
				return _culture ?? CultureInfo.InvariantCulture;
			}
			set
			{
				_culture = value;
			}
		}

		internal JsonPosition GetPosition(int depth)
		{
			if (_stack != null && depth < _stack.Count)
			{
				return _stack[depth];
			}
			return _currentPosition;
		}

		protected JsonReader()
		{
			_currentState = State.Start;
			_dateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;
			_dateParseHandling = DateParseHandling.DateTime;
			_floatParseHandling = FloatParseHandling.Double;
			CloseInput = true;
		}

		private void Push(JsonContainerType value)
		{
			UpdateScopeWithFinishedValue();
			if (_currentPosition.Type == JsonContainerType.None)
			{
				_currentPosition = new JsonPosition(value);
				return;
			}
			if (_stack == null)
			{
				_stack = new List<JsonPosition>();
			}
			_stack.Add(_currentPosition);
			_currentPosition = new JsonPosition(value);
			if (_maxDepth.HasValue)
			{
				int num = Depth + 1;
				int? maxDepth = _maxDepth;
				if (num > maxDepth.GetValueOrDefault() && maxDepth.HasValue && !_hasExceededMaxDepth)
				{
					_hasExceededMaxDepth = true;
					throw JsonReaderException.Create(this, "The reader's MaxDepth of {0} has been exceeded.".FormatWith(CultureInfo.InvariantCulture, _maxDepth));
				}
			}
		}

		private JsonContainerType Pop()
		{
			JsonPosition currentPosition;
			if (_stack != null && _stack.Count > 0)
			{
				currentPosition = _currentPosition;
				_currentPosition = _stack[_stack.Count - 1];
				_stack.RemoveAt(_stack.Count - 1);
			}
			else
			{
				currentPosition = _currentPosition;
				_currentPosition = default(JsonPosition);
			}
			if (_maxDepth.HasValue && Depth <= _maxDepth)
			{
				_hasExceededMaxDepth = false;
			}
			return currentPosition.Type;
		}

		private JsonContainerType Peek()
		{
			return _currentPosition.Type;
		}

		public abstract bool Read();

		public virtual int? ReadAsInt32()
		{
			JsonToken contentToken = GetContentToken();
			switch (contentToken)
			{
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.Integer:
			case JsonToken.Float:
				if (!(Value is int))
				{
					SetToken(JsonToken.Integer, Convert.ToInt32(Value, CultureInfo.InvariantCulture), updateIndex: false);
				}
				return (int)Value;
			case JsonToken.String:
			{
				string s = (string)Value;
				return ReadInt32String(s);
			}
			default:
				throw JsonReaderException.Create(this, "Error reading integer. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
		}

		internal int? ReadInt32String(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				SetToken(JsonToken.Null, null, updateIndex: false);
				return null;
			}
			if (int.TryParse(s, NumberStyles.Integer, Culture, out var result))
			{
				SetToken(JsonToken.Integer, result, updateIndex: false);
				return result;
			}
			SetToken(JsonToken.String, s, updateIndex: false);
			throw JsonReaderException.Create(this, "Could not convert string to integer: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
		}

		public virtual string ReadAsString()
		{
			JsonToken contentToken = GetContentToken();
			switch (contentToken)
			{
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.String:
				return (string)Value;
			default:
				if (JsonTokenUtils.IsPrimitiveToken(contentToken) && Value != null)
				{
					string text = ((Value is IFormattable) ? ((IFormattable)Value).ToString(null, Culture) : ((!(Value is Uri)) ? Value.ToString() : ((Uri)Value).OriginalString));
					SetToken(JsonToken.String, text, updateIndex: false);
					return text;
				}
				throw JsonReaderException.Create(this, "Error reading string. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
		}

		public virtual byte[] ReadAsBytes()
		{
			JsonToken contentToken = GetContentToken();
			if (contentToken == JsonToken.None)
			{
				return null;
			}
			if (TokenType == JsonToken.StartObject)
			{
				ReadIntoWrappedTypeObject();
				byte[] array = ReadAsBytes();
				ReaderReadAndAssert();
				if (TokenType != JsonToken.EndObject)
				{
					throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
				}
				SetToken(JsonToken.Bytes, array, updateIndex: false);
				return array;
			}
			switch (contentToken)
			{
			case JsonToken.String:
			{
				string text = (string)Value;
				Guid g;
				byte[] array3 = ((text.Length == 0) ? new byte[0] : ((!ConvertUtils.TryConvertGuid(text, out g)) ? Convert.FromBase64String(text) : g.ToByteArray()));
				SetToken(JsonToken.Bytes, array3, updateIndex: false);
				return array3;
			}
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.Bytes:
				if ((object)ValueType == typeof(Guid))
				{
					byte[] array2 = ((Guid)Value).ToByteArray();
					SetToken(JsonToken.Bytes, array2, updateIndex: false);
					return array2;
				}
				return (byte[])Value;
			case JsonToken.StartArray:
				return ReadArrayIntoByteArray();
			default:
				throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
		}

		internal byte[] ReadArrayIntoByteArray()
		{
			List<byte> list = new List<byte>();
			while (true)
			{
				JsonToken contentToken = GetContentToken();
				switch (contentToken)
				{
				case JsonToken.None:
					throw JsonReaderException.Create(this, "Unexpected end when reading bytes.");
				case JsonToken.Integer:
					break;
				case JsonToken.EndArray:
				{
					byte[] array = list.ToArray();
					SetToken(JsonToken.Bytes, array, updateIndex: false);
					return array;
				}
				default:
					throw JsonReaderException.Create(this, "Unexpected token when reading bytes: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
				}
				list.Add(Convert.ToByte(Value, CultureInfo.InvariantCulture));
			}
		}

		public virtual double? ReadAsDouble()
		{
			JsonToken contentToken = GetContentToken();
			switch (contentToken)
			{
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.Integer:
			case JsonToken.Float:
				if (!(Value is double))
				{
					double num = Convert.ToDouble(Value, CultureInfo.InvariantCulture);
					SetToken(JsonToken.Float, num, updateIndex: false);
				}
				return (double)Value;
			case JsonToken.String:
				return ReadDoubleString((string)Value);
			default:
				throw JsonReaderException.Create(this, "Error reading double. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
		}

		internal double? ReadDoubleString(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				SetToken(JsonToken.Null, null, updateIndex: false);
				return null;
			}
			if (double.TryParse(s, NumberStyles.Float | NumberStyles.AllowThousands, Culture, out var result))
			{
				SetToken(JsonToken.Float, result, updateIndex: false);
				return result;
			}
			SetToken(JsonToken.String, s, updateIndex: false);
			throw JsonReaderException.Create(this, "Could not convert string to double: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
		}

		public virtual bool? ReadAsBoolean()
		{
			JsonToken contentToken = GetContentToken();
			switch (contentToken)
			{
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.Integer:
			case JsonToken.Float:
			{
				bool flag = Convert.ToBoolean(Value, CultureInfo.InvariantCulture);
				SetToken(JsonToken.Boolean, flag, updateIndex: false);
				return flag;
			}
			case JsonToken.String:
				return ReadBooleanString((string)Value);
			case JsonToken.Boolean:
				return (bool)Value;
			default:
				throw JsonReaderException.Create(this, "Error reading boolean. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
		}

		internal bool? ReadBooleanString(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				SetToken(JsonToken.Null, null, updateIndex: false);
				return null;
			}
			if (bool.TryParse(s, out var result))
			{
				SetToken(JsonToken.Boolean, result, updateIndex: false);
				return result;
			}
			SetToken(JsonToken.String, s, updateIndex: false);
			throw JsonReaderException.Create(this, "Could not convert string to boolean: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
		}

		public virtual decimal? ReadAsDecimal()
		{
			JsonToken contentToken = GetContentToken();
			switch (contentToken)
			{
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.Integer:
			case JsonToken.Float:
				if (!(Value is decimal))
				{
					SetToken(JsonToken.Float, Convert.ToDecimal(Value, CultureInfo.InvariantCulture), updateIndex: false);
				}
				return (decimal)Value;
			case JsonToken.String:
				return ReadDecimalString((string)Value);
			default:
				throw JsonReaderException.Create(this, "Error reading decimal. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
		}

		internal decimal? ReadDecimalString(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				SetToken(JsonToken.Null, null, updateIndex: false);
				return null;
			}
			if (decimal.TryParse(s, NumberStyles.Number, Culture, out var result))
			{
				SetToken(JsonToken.Float, result, updateIndex: false);
				return result;
			}
			SetToken(JsonToken.String, s, updateIndex: false);
			throw JsonReaderException.Create(this, "Could not convert string to decimal: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
		}

		public virtual DateTime? ReadAsDateTime()
		{
			switch (GetContentToken())
			{
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.Date:
				if (Value is DateTimeOffset)
				{
					SetToken(JsonToken.Date, ((DateTimeOffset)Value).DateTime, updateIndex: false);
				}
				return (DateTime)Value;
			case JsonToken.String:
			{
				string s = (string)Value;
				return ReadDateTimeString(s);
			}
			default:
				throw JsonReaderException.Create(this, "Error reading date. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, TokenType));
			}
		}

		internal DateTime? ReadDateTimeString(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				SetToken(JsonToken.Null, null, updateIndex: false);
				return null;
			}
			if (DateTimeUtils.TryParseDateTime(s, DateTimeZoneHandling, _dateFormatString, Culture, out var dt))
			{
				dt = DateTimeUtils.EnsureDateTime(dt, DateTimeZoneHandling);
				SetToken(JsonToken.Date, dt, updateIndex: false);
				return dt;
			}
			if (DateTime.TryParse(s, Culture, DateTimeStyles.RoundtripKind, out dt))
			{
				dt = DateTimeUtils.EnsureDateTime(dt, DateTimeZoneHandling);
				SetToken(JsonToken.Date, dt, updateIndex: false);
				return dt;
			}
			throw JsonReaderException.Create(this, "Could not convert string to DateTime: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
		}

		public virtual DateTimeOffset? ReadAsDateTimeOffset()
		{
			JsonToken contentToken = GetContentToken();
			switch (contentToken)
			{
			case JsonToken.None:
			case JsonToken.Null:
			case JsonToken.EndArray:
				return null;
			case JsonToken.Date:
				if (Value is DateTime)
				{
					SetToken(JsonToken.Date, new DateTimeOffset((DateTime)Value), updateIndex: false);
				}
				return (DateTimeOffset)Value;
			case JsonToken.String:
			{
				string s = (string)Value;
				return ReadDateTimeOffsetString(s);
			}
			default:
				throw JsonReaderException.Create(this, "Error reading date. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, contentToken));
			}
		}

		internal DateTimeOffset? ReadDateTimeOffsetString(string s)
		{
			if (string.IsNullOrEmpty(s))
			{
				SetToken(JsonToken.Null, null, updateIndex: false);
				return null;
			}
			if (DateTimeUtils.TryParseDateTimeOffset(s, _dateFormatString, Culture, out var dt))
			{
				SetToken(JsonToken.Date, dt, updateIndex: false);
				return dt;
			}
			if (DateTimeOffset.TryParse(s, Culture, DateTimeStyles.RoundtripKind, out dt))
			{
				SetToken(JsonToken.Date, dt, updateIndex: false);
				return dt;
			}
			SetToken(JsonToken.String, s, updateIndex: false);
			throw JsonReaderException.Create(this, "Could not convert string to DateTimeOffset: {0}.".FormatWith(CultureInfo.InvariantCulture, s));
		}

		internal void ReaderReadAndAssert()
		{
			if (!Read())
			{
				throw CreateUnexpectedEndException();
			}
		}

		internal JsonReaderException CreateUnexpectedEndException()
		{
			return JsonReaderException.Create(this, "Unexpected end when reading JSON.");
		}

		internal void ReadIntoWrappedTypeObject()
		{
			ReaderReadAndAssert();
			if (Value.ToString() == "$type")
			{
				ReaderReadAndAssert();
				if (Value != null && Value.ToString().StartsWith("System.Byte[]", StringComparison.Ordinal))
				{
					ReaderReadAndAssert();
					if (Value.ToString() == "$value")
					{
						return;
					}
				}
			}
			throw JsonReaderException.Create(this, "Error reading bytes. Unexpected token: {0}.".FormatWith(CultureInfo.InvariantCulture, JsonToken.StartObject));
		}

		public void Skip()
		{
			if (TokenType == JsonToken.PropertyName)
			{
				Read();
			}
			if (JsonTokenUtils.IsStartToken(TokenType))
			{
				int depth = Depth;
				while (Read() && depth < Depth)
				{
				}
			}
		}

		protected void SetToken(JsonToken newToken)
		{
			SetToken(newToken, null, updateIndex: true);
		}

		protected void SetToken(JsonToken newToken, object value)
		{
			SetToken(newToken, value, updateIndex: true);
		}

		internal void SetToken(JsonToken newToken, object value, bool updateIndex)
		{
			_tokenType = newToken;
			_value = value;
			switch (newToken)
			{
			case JsonToken.StartObject:
				_currentState = State.ObjectStart;
				Push(JsonContainerType.Object);
				break;
			case JsonToken.StartArray:
				_currentState = State.ArrayStart;
				Push(JsonContainerType.Array);
				break;
			case JsonToken.StartConstructor:
				_currentState = State.ConstructorStart;
				Push(JsonContainerType.Constructor);
				break;
			case JsonToken.EndObject:
				ValidateEnd(JsonToken.EndObject);
				break;
			case JsonToken.EndArray:
				ValidateEnd(JsonToken.EndArray);
				break;
			case JsonToken.EndConstructor:
				ValidateEnd(JsonToken.EndConstructor);
				break;
			case JsonToken.PropertyName:
				_currentState = State.Property;
				_currentPosition.PropertyName = (string)value;
				break;
			case JsonToken.Raw:
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Null:
			case JsonToken.Undefined:
			case JsonToken.Date:
			case JsonToken.Bytes:
				SetPostValueState(updateIndex);
				break;
			case JsonToken.Comment:
				break;
			}
		}

		internal void SetPostValueState(bool updateIndex)
		{
			if (Peek() != JsonContainerType.None)
			{
				_currentState = State.PostValue;
			}
			else
			{
				SetFinished();
			}
			if (updateIndex)
			{
				UpdateScopeWithFinishedValue();
			}
		}

		private void UpdateScopeWithFinishedValue()
		{
			if (_currentPosition.HasIndex)
			{
				_currentPosition.Position++;
			}
		}

		private void ValidateEnd(JsonToken endToken)
		{
			JsonContainerType jsonContainerType = Pop();
			if (GetTypeForCloseToken(endToken) != jsonContainerType)
			{
				throw JsonReaderException.Create(this, "JsonToken {0} is not valid for closing JsonType {1}.".FormatWith(CultureInfo.InvariantCulture, endToken, jsonContainerType));
			}
			if (Peek() != JsonContainerType.None)
			{
				_currentState = State.PostValue;
			}
			else
			{
				SetFinished();
			}
		}

		protected void SetStateBasedOnCurrent()
		{
			JsonContainerType jsonContainerType = Peek();
			switch (jsonContainerType)
			{
			case JsonContainerType.Object:
				_currentState = State.Object;
				break;
			case JsonContainerType.Array:
				_currentState = State.Array;
				break;
			case JsonContainerType.Constructor:
				_currentState = State.Constructor;
				break;
			case JsonContainerType.None:
				SetFinished();
				break;
			default:
				throw JsonReaderException.Create(this, "While setting the reader state back to current object an unexpected JsonType was encountered: {0}".FormatWith(CultureInfo.InvariantCulture, jsonContainerType));
			}
		}

		private void SetFinished()
		{
			if (SupportMultipleContent)
			{
				_currentState = State.Start;
			}
			else
			{
				_currentState = State.Finished;
			}
		}

		private JsonContainerType GetTypeForCloseToken(JsonToken token)
		{
			return token switch
			{
				JsonToken.EndObject => JsonContainerType.Object, 
				JsonToken.EndArray => JsonContainerType.Array, 
				JsonToken.EndConstructor => JsonContainerType.Constructor, 
				_ => throw JsonReaderException.Create(this, "Not a valid close JsonToken: {0}".FormatWith(CultureInfo.InvariantCulture, token)), 
			};
		}

		void IDisposable.Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (_currentState != State.Closed && disposing)
			{
				Close();
			}
		}

		public virtual void Close()
		{
			_currentState = State.Closed;
			_tokenType = JsonToken.None;
			_value = null;
		}

		internal void ReadAndAssert()
		{
			if (!Read())
			{
				throw JsonSerializationException.Create(this, "Unexpected end when reading JSON.");
			}
		}

		internal bool ReadAndMoveToContent()
		{
			if (Read())
			{
				return MoveToContent();
			}
			return false;
		}

		internal bool MoveToContent()
		{
			JsonToken tokenType = TokenType;
			while (tokenType == JsonToken.None || tokenType == JsonToken.Comment)
			{
				if (!Read())
				{
					return false;
				}
				tokenType = TokenType;
			}
			return true;
		}

		private JsonToken GetContentToken()
		{
			JsonToken tokenType;
			do
			{
				if (!Read())
				{
					SetToken(JsonToken.None);
					return JsonToken.None;
				}
				tokenType = TokenType;
			}
			while (tokenType == JsonToken.Comment);
			return tokenType;
		}
	}
	[Preserve]
	public static class JsonConvert
	{
		public static readonly string True;

		public static readonly string False;

		public static readonly string Null;

		public static readonly string Undefined;

		public static readonly string PositiveInfinity;

		public static readonly string NegativeInfinity;

		public static readonly string NaN;

		private static readonly JsonSerializerSettings InitialSerializerSettings;

		public static Func<JsonSerializerSettings> DefaultSettings { get; set; }

		static JsonConvert()
		{
			True = "true";
			False = "false";
			Null = "null";
			Undefined = "undefined";
			PositiveInfinity = "Infinity";
			NegativeInfinity = "-Infinity";
			NaN = "NaN";
			InitialSerializerSettings = new JsonSerializerSettings();
			DefaultSettings = GetDefaultSettings;
		}

		internal static JsonSerializerSettings GetDefaultSettings()
		{
			return InitialSerializerSettings;
		}

		public static string ToString(DateTime value)
		{
			return ToString(value, DateFormatHandling.IsoDateFormat, DateTimeZoneHandling.RoundtripKind);
		}

		public static string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling)
		{
			DateTime value2 = DateTimeUtils.EnsureDateTime(value, timeZoneHandling);
			using StringWriter stringWriter = StringUtils.CreateStringWriter(64);
			stringWriter.Write('"');
			DateTimeUtils.WriteDateTimeString(stringWriter, value2, format, null, CultureInfo.InvariantCulture);
			stringWriter.Write('"');
			return stringWriter.ToString();
		}

		public static string ToString(DateTimeOffset value)
		{
			return ToString(value, DateFormatHandling.IsoDateFormat);
		}

		public static string ToString(DateTimeOffset value, DateFormatHandling format)
		{
			using StringWriter stringWriter = StringUtils.CreateStringWriter(64);
			stringWriter.Write('"');
			DateTimeUtils.WriteDateTimeOffsetString(stringWriter, value, format, null, CultureInfo.InvariantCulture);
			stringWriter.Write('"');
			return stringWriter.ToString();
		}

		public static string ToString(bool value)
		{
			if (!value)
			{
				return False;
			}
			return True;
		}

		public static string ToString(char value)
		{
			return ToString(char.ToString(value));
		}

		public static string ToString(Enum value)
		{
			return value.ToString("D");
		}

		public static string ToString(int value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(short value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static string ToString(ushort value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static string ToString(uint value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(long value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static string ToString(ulong value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(float value)
		{
			return EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture));
		}

		internal static string ToString(float value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
		{
			return EnsureFloatFormat(value, EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture)), floatFormatHandling, quoteChar, nullable);
		}

		private static string EnsureFloatFormat(double value, string text, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
		{
			if (floatFormatHandling == FloatFormatHandling.Symbol || (!double.IsInfinity(value) && !double.IsNaN(value)))
			{
				return text;
			}
			if (floatFormatHandling == FloatFormatHandling.DefaultValue)
			{
				if (nullable)
				{
					return Null;
				}
				return "0.0";
			}
			return quoteChar + text + quoteChar;
		}

		public static string ToString(double value)
		{
			return EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture));
		}

		internal static string ToString(double value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable)
		{
			return EnsureFloatFormat(value, EnsureDecimalPlace(value, value.ToString("R", CultureInfo.InvariantCulture)), floatFormatHandling, quoteChar, nullable);
		}

		private static string EnsureDecimalPlace(double value, string text)
		{
			if (double.IsNaN(value) || double.IsInfinity(value) || text.IndexOf('.') != -1 || text.IndexOf('E') != -1 || text.IndexOf('e') != -1)
			{
				return text;
			}
			return text + ".0";
		}

		private static string EnsureDecimalPlace(string text)
		{
			if (text.IndexOf('.') != -1)
			{
				return text;
			}
			return text + ".0";
		}

		public static string ToString(byte value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static string ToString(sbyte value)
		{
			return value.ToString(null, CultureInfo.InvariantCulture);
		}

		public static string ToString(decimal value)
		{
			return EnsureDecimalPlace(value.ToString(null, CultureInfo.InvariantCulture));
		}

		public static string ToString(Guid value)
		{
			return ToString(value, '"');
		}

		internal static string ToString(Guid value, char quoteChar)
		{
			string text = value.ToString("D", CultureInfo.InvariantCulture);
			string text2 = quoteChar.ToString(CultureInfo.InvariantCulture);
			return text2 + text + text2;
		}

		public static string ToString(TimeSpan value)
		{
			return ToString(value, '"');
		}

		internal static string ToString(TimeSpan value, char quoteChar)
		{
			return ToString(value.ToString(), quoteChar);
		}

		public static string ToString(Uri value)
		{
			if (value == null)
			{
				return Null;
			}
			return ToString(value, '"');
		}

		internal static string ToString(Uri value, char quoteChar)
		{
			return ToString(value.OriginalString, quoteChar);
		}

		public static string ToString(string value)
		{
			return ToString(value, '"');
		}

		public static string ToString(string value, char delimiter)
		{
			return ToString(value, delimiter, StringEscapeHandling.Default);
		}

		public static string ToString(string value, char delimiter, StringEscapeHandling stringEscapeHandling)
		{
			if (delimiter != '"' && delimiter != '\'')
			{
				throw new ArgumentException("Delimiter must be a single or double quote.", "delimiter");
			}
			return JavaScriptUtils.ToEscapedJavaScriptString(value, delimiter, appendDelimiters: true, stringEscapeHandling);
		}

		public static string ToString(object value)
		{
			if (value == null)
			{
				return Null;
			}
			return ConvertUtils.GetTypeCode(value.GetType()) switch
			{
				PrimitiveTypeCode.String => ToString((string)value), 
				PrimitiveTypeCode.Char => ToString((char)value), 
				PrimitiveTypeCode.Boolean => ToString((bool)value), 
				PrimitiveTypeCode.SByte => ToString((sbyte)value), 
				PrimitiveTypeCode.Int16 => ToString((short)value), 
				PrimitiveTypeCode.UInt16 => ToString((ushort)value), 
				PrimitiveTypeCode.Int32 => ToString((int)value), 
				PrimitiveTypeCode.Byte => ToString((byte)value), 
				PrimitiveTypeCode.UInt32 => ToString((uint)value), 
				PrimitiveTypeCode.Int64 => ToString((long)value), 
				PrimitiveTypeCode.UInt64 => ToString((ulong)value), 
				PrimitiveTypeCode.Single => ToString((float)value), 
				PrimitiveTypeCode.Double => ToString((double)value), 
				PrimitiveTypeCode.DateTime => ToString((DateTime)value), 
				PrimitiveTypeCode.Decimal => ToString((decimal)value), 
				PrimitiveTypeCode.DBNull => Null, 
				PrimitiveTypeCode.DateTimeOffset => ToString((DateTimeOffset)value), 
				PrimitiveTypeCode.Guid => ToString((Guid)value), 
				PrimitiveTypeCode.Uri => ToString((Uri)value), 
				PrimitiveTypeCode.TimeSpan => ToString((TimeSpan)value), 
				_ => throw new ArgumentException("Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.".FormatWith(CultureInfo.InvariantCulture, value.GetType())), 
			};
		}

		public static string SerializeObject(object value)
		{
			return SerializeObject(value, (Type)null, (JsonSerializerSettings)null);
		}

		public static string SerializeObject(object value, Formatting formatting)
		{
			return SerializeObject(value, formatting, (JsonSerializerSettings)null);
		}

		public static string SerializeObject(object value, params JsonConverter[] converters)
		{
			JsonSerializerSettings settings = ((converters != null && converters.Length != 0) ? new JsonSerializerSettings
			{
				Converters = converters
			} : null);
			return SerializeObject(value, null, settings);
		}

		public static string SerializeObject(object value, Formatting formatting, params JsonConverter[] converters)
		{
			JsonSerializerSettings settings = ((converters != null && converters.Length != 0) ? new JsonSerializerSettings
			{
				Converters = converters
			} : null);
			return SerializeObject(value, null, formatting, settings);
		}

		public static string SerializeObject(object value, JsonSerializerSettings settings)
		{
			return SerializeObject(value, null, settings);
		}

		public static string SerializeObject(object value, Type type, JsonSerializerSettings settings)
		{
			JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
			return SerializeObjectInternal(value, type, jsonSerializer);
		}

		public static string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings)
		{
			return SerializeObject(value, null, formatting, settings);
		}

		public static string SerializeObject(object value, Type type, Formatting formatting, JsonSerializerSettings settings)
		{
			JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
			jsonSerializer.Formatting = formatting;
			return SerializeObjectInternal(value, type, jsonSerializer);
		}

		private static string SerializeObjectInternal(object value, Type type, JsonSerializer jsonSerializer)
		{
			StringWriter stringWriter = new StringWriter(new StringBuilder(256), CultureInfo.InvariantCulture);
			using (JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter))
			{
				jsonTextWriter.Formatting = jsonSerializer.Formatting;
				jsonSerializer.Serialize(jsonTextWriter, value, type);
			}
			return stringWriter.ToString();
		}

		public static object DeserializeObject(string value)
		{
			return DeserializeObject(value, (Type)null, (JsonSerializerSettings)null);
		}

		public static object DeserializeObject(string value, JsonSerializerSettings settings)
		{
			return DeserializeObject(value, null, settings);
		}

		public static object DeserializeObject(string value, Type type)
		{
			return DeserializeObject(value, type, (JsonSerializerSettings)null);
		}

		public static T DeserializeObject<T>(string value)
		{
			return JsonConvert.DeserializeObject<T>(value, (JsonSerializerSettings)null);
		}

		public static T DeserializeAnonymousType<T>(string value, T anonymousTypeObject)
		{
			return DeserializeObject<T>(value);
		}

		public static T DeserializeAnonymousType<T>(string value, T anonymousTypeObject, JsonSerializerSettings settings)
		{
			return DeserializeObject<T>(value, settings);
		}

		public static T DeserializeObject<T>(string value, params JsonConverter[] converters)
		{
			return (T)DeserializeObject(value, typeof(T), converters);
		}

		public static T DeserializeObject<T>(string value, JsonSerializerSettings settings)
		{
			return (T)DeserializeObject(value, typeof(T), settings);
		}

		public static object DeserializeObject(string value, Type type, params JsonConverter[] converters)
		{
			JsonSerializerSettings settings = ((converters != null && converters.Length != 0) ? new JsonSerializerSettings
			{
				Converters = converters
			} : null);
			return DeserializeObject(value, type, settings);
		}

		public static object DeserializeObject(string value, Type type, JsonSerializerSettings settings)
		{
			ValidationUtils.ArgumentNotNull(value, "value");
			JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
			if (!jsonSerializer.IsCheckAdditionalContentSet())
			{
				jsonSerializer.CheckAdditionalContent = true;
			}
			using JsonTextReader reader = new JsonTextReader(new StringReader(value));
			return jsonSerializer.Deserialize(reader, type);
		}

		public static void PopulateObject(string value, object target)
		{
			PopulateObject(value, target, null);
		}

		public static void PopulateObject(string value, object target, JsonSerializerSettings settings)
		{
			JsonSerializer jsonSerializer = JsonSerializer.CreateDefault(settings);
			using JsonReader jsonReader = new JsonTextReader(new StringReader(value));
			jsonSerializer.Populate(jsonReader, target);
			if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
			{
				throw new JsonSerializationException("Additional text found in JSON string after finishing deserializing object.");
			}
		}

		public static string SerializeXmlNode(XmlNode node)
		{
			return SerializeXmlNode(node, Formatting.None);
		}

		public static string SerializeXmlNode(XmlNode node, Formatting formatting)
		{
			XmlNodeConverter xmlNodeConverter = new XmlNodeConverter();
			return SerializeObject(node, formatting, xmlNodeConverter);
		}

		public static string SerializeXmlNode(XmlNode node, Formatting formatting, bool omitRootObject)
		{
			XmlNodeConverter xmlNodeConverter = new XmlNodeConverter
			{
				OmitRootObject = omitRootObject
			};
			return SerializeObject(node, formatting, xmlNodeConverter);
		}

		public static XmlDocument DeserializeXmlNode(string value)
		{
			return DeserializeXmlNode(value, null);
		}

		public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName)
		{
			return DeserializeXmlNode(value, deserializeRootElementName, writeArrayAttribute: false);
		}

		public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute)
		{
			XmlNodeConverter xmlNodeConverter = new XmlNodeConverter();
			xmlNodeConverter.DeserializeRootElementName = deserializeRootElementName;
			xmlNodeConverter.WriteArrayAttribute = writeArrayAttribute;
			return (XmlDocument)DeserializeObject(value, typeof(XmlDocument), xmlNodeConverter);
		}

		public static string SerializeXNode(XObject node)
		{
			return SerializeXNode(node, Formatting.None);
		}

		public static string SerializeXNode(XObject node, Formatting formatting)
		{
			return SerializeXNode(node, formatting, omitRootObject: false);
		}

		public static string SerializeXNode(XObject node, Formatting formatting, bool omitRootObject)
		{
			XmlNodeConverter xmlNodeConverter = new XmlNodeConverter
			{
				OmitRootObject = omitRootObject
			};
			return SerializeObject(node, formatting, xmlNodeConverter);
		}

		public static XDocument DeserializeXNode(string value)
		{
			return DeserializeXNode(value, null);
		}

		public static XDocument DeserializeXNode(string value, string deserializeRootElementName)
		{
			return DeserializeXNode(value, deserializeRootElementName, writeArrayAttribute: false);
		}

		public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute)
		{
			XmlNodeConverter xmlNodeConverter = new XmlNodeConverter();
			xmlNodeConverter.DeserializeRootElementName = deserializeRootElementName;
			xmlNodeConverter.WriteArrayAttribute = writeArrayAttribute;
			return (XDocument)DeserializeObject(value, typeof(XDocument), xmlNodeConverter);
		}
	}
	[Serializable]
	[Preserve]
	public class JsonSerializationException : JsonException
	{
		public JsonSerializationException()
		{
		}

		public JsonSerializationException(string message)
			: base(message)
		{
		}

		public JsonSerializationException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		public JsonSerializationException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}

		internal static JsonSerializationException Create(JsonReader reader, string message)
		{
			return Create(reader, message, null);
		}

		internal static JsonSerializationException Create(JsonReader reader, string message, Exception ex)
		{
			return Create(reader as IJsonLineInfo, reader.Path, message, ex);
		}

		internal static JsonSerializationException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex)
		{
			message = JsonPosition.FormatMessage(lineInfo, path, message);
			return new JsonSerializationException(message, ex);
		}
	}
	[Preserve]
	public class JsonSerializer
	{
		internal TypeNameHandling _typeNameHandling;

		internal FormatterAssemblyStyle _typeNameAssemblyFormat;

		internal PreserveReferencesHandling _preserveReferencesHandling;

		internal ReferenceLoopHandling _referenceLoopHandling;

		internal MissingMemberHandling _missingMemberHandling;

		internal ObjectCreationHandling _objectCreationHandling;

		internal NullValueHandling _nullValueHandling;

		internal DefaultValueHandling _defaultValueHandling;

		internal ConstructorHandling _constructorHandling;

		internal MetadataPropertyHandling _metadataPropertyHandling;

		internal JsonConverterCollection _converters;

		internal IContractResolver _contractResolver;

		internal ITraceWriter _traceWriter;

		internal IEqualityComparer _equalityComparer;

		internal SerializationBinder _binder;

		internal StreamingContext _context;

		private IReferenceResolver _referenceResolver;

		private Formatting? _formatting;

		private DateFormatHandling? _dateFormatHandling;

		private DateTimeZoneHandling? _dateTimeZoneHandling;

		private DateParseHandling? _dateParseHandling;

		private FloatFormatHandling? _floatFormatHandling;

		private FloatParseHandling? _floatParseHandling;

		private StringEscapeHandling? _stringEscapeHandling;

		private CultureInfo _culture;

		private int? _maxDepth;

		private bool _maxDepthSet;

		private bool? _checkAdditionalContent;

		private string _dateFormatString;

		private bool _dateFormatStringSet;

		public virtual IReferenceResolver ReferenceResolver
		{
			get
			{
				return GetReferenceResolver();
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value", "Reference resolver cannot be null.");
				}
				_referenceResolver = value;
			}
		}

		public virtual SerializationBinder Binder
		{
			get
			{
				return _binder;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value", "Serialization binder cannot be null.");
				}
				_binder = value;
			}
		}

		public virtual ITraceWriter TraceWriter
		{
			get
			{
				return _traceWriter;
			}
			set
			{
				_traceWriter = value;
			}
		}

		public virtual IEqualityComparer EqualityComparer
		{
			get
			{
				return _equalityComparer;
			}
			set
			{
				_equalityComparer = value;
			}
		}

		public virtual TypeNameHandling TypeNameHandling
		{
			get
			{
				return _typeNameHandling;
			}
			set
			{
				if (value < TypeNameHandling.None || value > TypeNameHandling.Auto)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_typeNameHandling = value;
			}
		}

		public virtual FormatterAssemblyStyle TypeNameAssemblyFormat
		{
			get
			{
				return _typeNameAssemblyFormat;
			}
			set
			{
				if (value < FormatterAssemblyStyle.Simple || value > FormatterAssemblyStyle.Full)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_typeNameAssemblyFormat = value;
			}
		}

		public virtual PreserveReferencesHandling PreserveReferencesHandling
		{
			get
			{
				return _preserveReferencesHandling;
			}
			set
			{
				if (value < PreserveReferencesHandling.None || value > PreserveReferencesHandling.All)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_preserveReferencesHandling = value;
			}
		}

		public virtual ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				return _referenceLoopHandling;
			}
			set
			{
				if (value < ReferenceLoopHandling.Error || value > ReferenceLoopHandling.Serialize)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_referenceLoopHandling = value;
			}
		}

		public virtual MissingMemberHandling MissingMemberHandling
		{
			get
			{
				return _missingMemberHandling;
			}
			set
			{
				if (value < MissingMemberHandling.Ignore || value > MissingMemberHandling.Error)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_missingMemberHandling = value;
			}
		}

		public virtual NullValueHandling NullValueHandling
		{
			get
			{
				return _nullValueHandling;
			}
			set
			{
				if (value < NullValueHandling.Include || value > NullValueHandling.Ignore)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_nullValueHandling = value;
			}
		}

		public virtual DefaultValueHandling DefaultValueHandling
		{
			get
			{
				return _defaultValueHandling;
			}
			set
			{
				if (value < DefaultValueHandling.Include || value > DefaultValueHandling.IgnoreAndPopulate)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_defaultValueHandling = value;
			}
		}

		public virtual ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				return _objectCreationHandling;
			}
			set
			{
				if (value < ObjectCreationHandling.Auto || value > ObjectCreationHandling.Replace)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_objectCreationHandling = value;
			}
		}

		public virtual ConstructorHandling ConstructorHandling
		{
			get
			{
				return _constructorHandling;
			}
			set
			{
				if (value < ConstructorHandling.Default || value > ConstructorHandling.AllowNonPublicDefaultConstructor)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_constructorHandling = value;
			}
		}

		public virtual MetadataPropertyHandling MetadataPropertyHandling
		{
			get
			{
				return _metadataPropertyHandling;
			}
			set
			{
				if (value < MetadataPropertyHandling.Default || value > MetadataPropertyHandling.Ignore)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_metadataPropertyHandling = value;
			}
		}

		public virtual JsonConverterCollection Converters
		{
			get
			{
				if (_converters == null)
				{
					_converters = new JsonConverterCollection();
				}
				return _converters;
			}
		}

		public virtual IContractResolver ContractResolver
		{
			get
			{
				return _contractResolver;
			}
			set
			{
				_contractResolver = value ?? DefaultContractResolver.Instance;
			}
		}

		public virtual StreamingContext Context
		{
			get
			{
				return _context;
			}
			set
			{
				_context = value;
			}
		}

		public virtual Formatting Formatting
		{
			get
			{
				return _formatting ?? Formatting.None;
			}
			set
			{
				_formatting = value;
			}
		}

		public virtual DateFormatHandling DateFormatHandling
		{
			get
			{
				return _dateFormatHandling ?? DateFormatHandling.IsoDateFormat;
			}
			set
			{
				_dateFormatHandling = value;
			}
		}

		public virtual DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				return _dateTimeZoneHandling ?? DateTimeZoneHandling.RoundtripKind;
			}
			set
			{
				_dateTimeZoneHandling = value;
			}
		}

		public virtual DateParseHandling DateParseHandling
		{
			get
			{
				return _dateParseHandling ?? DateParseHandling.DateTime;
			}
			set
			{
				_dateParseHandling = value;
			}
		}

		public virtual FloatParseHandling FloatParseHandling
		{
			get
			{
				return _floatParseHandling ?? FloatParseHandling.Double;
			}
			set
			{
				_floatParseHandling = value;
			}
		}

		public virtual FloatFormatHandling FloatFormatHandling
		{
			get
			{
				return _floatFormatHandling ?? FloatFormatHandling.String;
			}
			set
			{
				_floatFormatHandling = value;
			}
		}

		public virtual StringEscapeHandling StringEscapeHandling
		{
			get
			{
				return _stringEscapeHandling ?? StringEscapeHandling.Default;
			}
			set
			{
				_stringEscapeHandling = value;
			}
		}

		public virtual string DateFormatString
		{
			get
			{
				return _dateFormatString ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";
			}
			set
			{
				_dateFormatString = value;
				_dateFormatStringSet = true;
			}
		}

		public virtual CultureInfo Culture
		{
			get
			{
				return _culture ?? JsonSerializerSettings.DefaultCulture;
			}
			set
			{
				_culture = value;
			}
		}

		public virtual int? MaxDepth
		{
			get
			{
				return _maxDepth;
			}
			set
			{
				if (value <= 0)
				{
					throw new ArgumentException("Value must be positive.", "value");
				}
				_maxDepth = value;
				_maxDepthSet = true;
			}
		}

		public virtual bool CheckAdditionalContent
		{
			get
			{
				return _checkAdditionalContent ?? false;
			}
			set
			{
				_checkAdditionalContent = value;
			}
		}

		public virtual event EventHandler<Newtonsoft.Json.Serialization.ErrorEventArgs> Error;

		internal bool IsCheckAdditionalContentSet()
		{
			return _checkAdditionalContent.HasValue;
		}

		public JsonSerializer()
		{
			_referenceLoopHandling = ReferenceLoopHandling.Error;
			_missingMemberHandling = MissingMemberHandling.Ignore;
			_nullValueHandling = NullValueHandling.Include;
			_defaultValueHandling = DefaultValueHandling.Include;
			_objectCreationHandling = ObjectCreationHandling.Auto;
			_preserveReferencesHandling = PreserveReferencesHandling.None;
			_constructorHandling = ConstructorHandling.Default;
			_typeNameHandling = TypeNameHandling.None;
			_metadataPropertyHandling = MetadataPropertyHandling.Default;
			_context = JsonSerializerSettings.DefaultContext;
			_binder = DefaultSerializationBinder.Instance;
			_culture = JsonSerializerSettings.DefaultCulture;
			_contractResolver = DefaultContractResolver.Instance;
		}

		public static JsonSerializer Create()
		{
			return new JsonSerializer();
		}

		public static JsonSerializer Create(JsonSerializerSettings settings)
		{
			JsonSerializer jsonSerializer = Create();
			if (settings != null)
			{
				ApplySerializerSettings(jsonSerializer, settings);
			}
			return jsonSerializer;
		}

		public static JsonSerializer CreateDefault()
		{
			return Create(JsonConvert.DefaultSettings?.Invoke());
		}

		public static JsonSerializer CreateDefault(JsonSerializerSettings settings)
		{
			JsonSerializer jsonSerializer = CreateDefault();
			if (settings != null)
			{
				ApplySerializerSettings(jsonSerializer, settings);
			}
			return jsonSerializer;
		}

		private static void ApplySerializerSettings(JsonSerializer serializer, JsonSerializerSettings settings)
		{
			if (!CollectionUtils.IsNullOrEmpty(settings.Converters))
			{
				for (int i = 0; i < settings.Converters.Count; i++)
				{
					serializer.Converters.Insert(i, settings.Converters[i]);
				}
			}
			if (settings._typeNameHandling.HasValue)
			{
				serializer.TypeNameHandling = settings.TypeNameHandling;
			}
			if (settings._metadataPropertyHandling.HasValue)
			{
				serializer.MetadataPropertyHandling = settings.MetadataPropertyHandling;
			}
			if (settings._typeNameAssemblyFormat.HasValue)
			{
				serializer.TypeNameAssemblyFormat = settings.TypeNameAssemblyFormat;
			}
			if (settings._preserveReferencesHandling.HasValue)
			{
				serializer.PreserveReferencesHandling = settings.PreserveReferencesHandling;
			}
			if (settings._referenceLoopHandling.HasValue)
			{
				serializer.ReferenceLoopHandling = settings.ReferenceLoopHandling;
			}
			if (settings._missingMemberHandling.HasValue)
			{
				serializer.MissingMemberHandling = settings.MissingMemberHandling;
			}
			if (settings._objectCreationHandling.HasValue)
			{
				serializer.ObjectCreationHandling = settings.ObjectCreationHandling;
			}
			if (settings._nullValueHandling.HasValue)
			{
				serializer.NullValueHandling = settings.NullValueHandling;
			}
			if (settings._defaultValueHandling.HasValue)
			{
				serializer.DefaultValueHandling = settings.DefaultValueHandling;
			}
			if (settings._constructorHandling.HasValue)
			{
				serializer.ConstructorHandling = settings.ConstructorHandling;
			}
			if (settings._context.HasValue)
			{
				serializer.Context = settings.Context;
			}
			if (settings._checkAdditionalContent.HasValue)
			{
				serializer._checkAdditionalContent = settings._checkAdditionalContent;
			}
			if (settings.Error != null)
			{
				serializer.Error += settings.Error;
			}
			if (settings.ContractResolver != null)
			{
				serializer.ContractResolver = settings.ContractResolver;
			}
			if (settings.ReferenceResolverProvider != null)
			{
				serializer.ReferenceResolver = settings.ReferenceResolverProvider();
			}
			if (settings.TraceWriter != null)
			{
				serializer.TraceWriter = settings.TraceWriter;
			}
			if (settings.EqualityComparer != null)
			{
				serializer.EqualityComparer = settings.EqualityComparer;
			}
			if (settings.Binder != null)
			{
				serializer.Binder = settings.Binder;
			}
			if (settings._formatting.HasValue)
			{
				serializer._formatting = settings._formatting;
			}
			if (settings._dateFormatHandling.HasValue)
			{
				serializer._dateFormatHandling = settings._dateFormatHandling;
			}
			if (settings._dateTimeZoneHandling.HasValue)
			{
				serializer._dateTimeZoneHandling = settings._dateTimeZoneHandling;
			}
			if (settings._dateParseHandling.HasValue)
			{
				serializer._dateParseHandling = settings._dateParseHandling;
			}
			if (settings._dateFormatStringSet)
			{
				serializer._dateFormatString = settings._dateFormatString;
				serializer._dateFormatStringSet = settings._dateFormatStringSet;
			}
			if (settings._floatFormatHandling.HasValue)
			{
				serializer._floatFormatHandling = settings._floatFormatHandling;
			}
			if (settings._floatParseHandling.HasValue)
			{
				serializer._floatParseHandling = settings._floatParseHandling;
			}
			if (settings._stringEscapeHandling.HasValue)
			{
				serializer._stringEscapeHandling = settings._stringEscapeHandling;
			}
			if (settings._culture != null)
			{
				serializer._culture = settings._culture;
			}
			if (settings._maxDepthSet)
			{
				serializer._maxDepth = settings._maxDepth;
				serializer._maxDepthSet = settings._maxDepthSet;
			}
		}

		public void Populate(TextReader reader, object target)
		{
			Populate(new JsonTextReader(reader), target);
		}

		public void Populate(JsonReader reader, object target)
		{
			PopulateInternal(reader, target);
		}

		internal virtual void PopulateInternal(JsonReader reader, object target)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			ValidationUtils.ArgumentNotNull(target, "target");
			SetupReader(reader, out var previousCulture, out var previousDateTimeZoneHandling, out var previousDateParseHandling, out var previousFloatParseHandling, out var previousMaxDepth, out var previousDateFormatString);
			TraceJsonReader traceJsonReader = ((TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose) ? new TraceJsonReader(reader) : null);
			new JsonSerializerInternalReader(this).Populate(traceJsonReader ?? reader, target);
			if (traceJsonReader != null)
			{
				TraceWriter.Trace(TraceLevel.Verbose, traceJsonReader.GetDeserializedJsonMessage(), null);
			}
			ResetReader(reader, previousCulture, previousDateTimeZoneHandling, previousDateParseHandling, previousFloatParseHandling, previousMaxDepth, previousDateFormatString);
		}

		public object Deserialize(JsonReader reader)
		{
			return Deserialize(reader, null);
		}

		public object Deserialize(TextReader reader, Type objectType)
		{
			return Deserialize(new JsonTextReader(reader), objectType);
		}

		public T Deserialize<T>(JsonReader reader)
		{
			return (T)Deserialize(reader, typeof(T));
		}

		public object Deserialize(JsonReader reader, Type objectType)
		{
			return DeserializeInternal(reader, objectType);
		}

		internal virtual object DeserializeInternal(JsonReader reader, Type objectType)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			SetupReader(reader, out var previousCulture, out var previousDateTimeZoneHandling, out var previousDateParseHandling, out var previousFloatParseHandling, out var previousMaxDepth, out var previousDateFormatString);
			TraceJsonReader traceJsonReader = ((TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose) ? new TraceJsonReader(reader) : null);
			object result = new JsonSerializerInternalReader(this).Deserialize(traceJsonReader ?? reader, objectType, CheckAdditionalContent);
			if (traceJsonReader != null)
			{
				TraceWriter.Trace(TraceLevel.Verbose, traceJsonReader.GetDeserializedJsonMessage(), null);
			}
			ResetReader(reader, previousCulture, previousDateTimeZoneHandling, previousDateParseHandling, previousFloatParseHandling, previousMaxDepth, previousDateFormatString);
			return result;
		}

		private void SetupReader(JsonReader reader, out CultureInfo previousCulture, out DateTimeZoneHandling? previousDateTimeZoneHandling, out DateParseHandling? previousDateParseHandling, out FloatParseHandling? previousFloatParseHandling, out int? previousMaxDepth, out string previousDateFormatString)
		{
			if (_culture != null && !_culture.Equals(reader.Culture))
			{
				previousCulture = reader.Culture;
				reader.Culture = _culture;
			}
			else
			{
				previousCulture = null;
			}
			if (_dateTimeZoneHandling.HasValue && reader.DateTimeZoneHandling != _dateTimeZoneHandling)
			{
				previousDateTimeZoneHandling = reader.DateTimeZoneHandling;
				reader.DateTimeZoneHandling = _dateTimeZoneHandling.GetValueOrDefault();
			}
			else
			{
				previousDateTimeZoneHandling = null;
			}
			if (_dateParseHandling.HasValue && reader.DateParseHandling != _dateParseHandling)
			{
				previousDateParseHandling = reader.DateParseHandling;
				reader.DateParseHandling = _dateParseHandling.GetValueOrDefault();
			}
			else
			{
				previousDateParseHandling = null;
			}
			if (_floatParseHandling.HasValue && reader.FloatParseHandling != _floatParseHandling)
			{
				previousFloatParseHandling = reader.FloatParseHandling;
				reader.FloatParseHandling = _floatParseHandling.GetValueOrDefault();
			}
			else
			{
				previousFloatParseHandling = null;
			}
			if (_maxDepthSet && reader.MaxDepth != _maxDepth)
			{
				previousMaxDepth = reader.MaxDepth;
				reader.MaxDepth = _maxDepth;
			}
			else
			{
				previousMaxDepth = null;
			}
			if (_dateFormatStringSet && reader.DateFormatString != _dateFormatString)
			{
				previousDateFormatString = reader.DateFormatString;
				reader.DateFormatString = _dateFormatString;
			}
			else
			{
				previousDateFormatString = null;
			}
			if (reader is JsonTextReader jsonTextReader && _contractResolver is DefaultContractResolver defaultContractResolver)
			{
				jsonTextReader.NameTable = defaultContractResolver.GetState().NameTable;
			}
		}

		private void ResetReader(JsonReader reader, CultureInfo previousCulture, DateTimeZoneHandling? previousDateTimeZoneHandling, DateParseHandling? previousDateParseHandling, FloatParseHandling? previousFloatParseHandling, int? previousMaxDepth, string previousDateFormatString)
		{
			if (previousCulture != null)
			{
				reader.Culture = previousCulture;
			}
			if (previousDateTimeZoneHandling.HasValue)
			{
				reader.DateTimeZoneHandling = previousDateTimeZoneHandling.GetValueOrDefault();
			}
			if (previousDateParseHandling.HasValue)
			{
				reader.DateParseHandling = previousDateParseHandling.GetValueOrDefault();
			}
			if (previousFloatParseHandling.HasValue)
			{
				reader.FloatParseHandling = previousFloatParseHandling.GetValueOrDefault();
			}
			if (_maxDepthSet)
			{
				reader.MaxDepth = previousMaxDepth;
			}
			if (_dateFormatStringSet)
			{
				reader.DateFormatString = previousDateFormatString;
			}
			if (reader is JsonTextReader jsonTextReader)
			{
				jsonTextReader.NameTable = null;
			}
		}

		public void Serialize(TextWriter textWriter, object value)
		{
			Serialize(new JsonTextWriter(textWriter), value);
		}

		public void Serialize(JsonWriter jsonWriter, object value, Type objectType)
		{
			SerializeInternal(jsonWriter, value, objectType);
		}

		public void Serialize(TextWriter textWriter, object value, Type objectType)
		{
			Serialize(new JsonTextWriter(textWriter), value, objectType);
		}

		public void Serialize(JsonWriter jsonWriter, object value)
		{
			SerializeInternal(jsonWriter, value, null);
		}

		internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type objectType)
		{
			ValidationUtils.ArgumentNotNull(jsonWriter, "jsonWriter");
			Formatting? formatting = null;
			if (_formatting.HasValue && jsonWriter.Formatting != _formatting)
			{
				formatting = jsonWriter.Formatting;
				jsonWriter.Formatting = _formatting.GetValueOrDefault();
			}
			DateFormatHandling? dateFormatHandling = null;
			if (_dateFormatHandling.HasValue && jsonWriter.DateFormatHandling != _dateFormatHandling)
			{
				dateFormatHandling = jsonWriter.DateFormatHandling;
				jsonWriter.DateFormatHandling = _dateFormatHandling.GetValueOrDefault();
			}
			DateTimeZoneHandling? dateTimeZoneHandling = null;
			if (_dateTimeZoneHandling.HasValue && jsonWriter.DateTimeZoneHandling != _dateTimeZoneHandling)
			{
				dateTimeZoneHandling = jsonWriter.DateTimeZoneHandling;
				jsonWriter.DateTimeZoneHandling = _dateTimeZoneHandling.GetValueOrDefault();
			}
			FloatFormatHandling? floatFormatHandling = null;
			if (_floatFormatHandling.HasValue && jsonWriter.FloatFormatHandling != _floatFormatHandling)
			{
				floatFormatHandling = jsonWriter.FloatFormatHandling;
				jsonWriter.FloatFormatHandling = _floatFormatHandling.GetValueOrDefault();
			}
			StringEscapeHandling? stringEscapeHandling = null;
			if (_stringEscapeHandling.HasValue && jsonWriter.StringEscapeHandling != _stringEscapeHandling)
			{
				stringEscapeHandling = jsonWriter.StringEscapeHandling;
				jsonWriter.StringEscapeHandling = _stringEscapeHandling.GetValueOrDefault();
			}
			CultureInfo cultureInfo = null;
			if (_culture != null && !_culture.Equals(jsonWriter.Culture))
			{
				cultureInfo = jsonWriter.Culture;
				jsonWriter.Culture = _culture;
			}
			string dateFormatString = null;
			if (_dateFormatStringSet && jsonWriter.DateFormatString != _dateFormatString)
			{
				dateFormatString = jsonWriter.DateFormatString;
				jsonWriter.DateFormatString = _dateFormatString;
			}
			TraceJsonWriter traceJsonWriter = ((TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose) ? new TraceJsonWriter(jsonWriter) : null);
			new JsonSerializerInternalWriter(this).Serialize(traceJsonWriter ?? jsonWriter, value, objectType);
			if (traceJsonWriter != null)
			{
				TraceWriter.Trace(TraceLevel.Verbose, traceJsonWriter.GetSerializedJsonMessage(), null);
			}
			if (formatting.HasValue)
			{
				jsonWriter.Formatting = formatting.GetValueOrDefault();
			}
			if (dateFormatHandling.HasValue)
			{
				jsonWriter.DateFormatHandling = dateFormatHandling.GetValueOrDefault();
			}
			if (dateTimeZoneHandling.HasValue)
			{
				jsonWriter.DateTimeZoneHandling = dateTimeZoneHandling.GetValueOrDefault();
			}
			if (floatFormatHandling.HasValue)
			{
				jsonWriter.FloatFormatHandling = floatFormatHandling.GetValueOrDefault();
			}
			if (stringEscapeHandling.HasValue)
			{
				jsonWriter.StringEscapeHandling = stringEscapeHandling.GetValueOrDefault();
			}
			if (_dateFormatStringSet)
			{
				jsonWriter.DateFormatString = dateFormatString;
			}
			if (cultureInfo != null)
			{
				jsonWriter.Culture = cultureInfo;
			}
		}

		internal IReferenceResolver GetReferenceResolver()
		{
			if (_referenceResolver == null)
			{
				_referenceResolver = new DefaultReferenceResolver();
			}
			return _referenceResolver;
		}

		internal JsonConverter GetMatchingConverter(Type type)
		{
			return GetMatchingConverter(_converters, type);
		}

		internal static JsonConverter GetMatchingConverter(IList<JsonConverter> converters, Type objectType)
		{
			if (converters != null)
			{
				for (int i = 0; i < converters.Count; i++)
				{
					JsonConverter jsonConverter = converters[i];
					if (jsonConverter.CanConvert(objectType))
					{
						return jsonConverter;
					}
				}
			}
			return null;
		}

		internal void OnError(Newtonsoft.Json.Serialization.ErrorEventArgs e)
		{
			this.Error?.Invoke(this, e);
		}
	}
	[Preserve]
	public enum MissingMemberHandling
	{
		Ignore,
		Error
	}
	[Preserve]
	public enum NullValueHandling
	{
		Include,
		Ignore
	}
	[Preserve]
	public enum ReferenceLoopHandling
	{
		Error,
		Ignore,
		Serialize
	}
	[Flags]
	[Preserve]
	public enum TypeNameHandling
	{
		None = 0,
		Objects = 1,
		Arrays = 2,
		All = 3,
		Auto = 4
	}
	[Preserve]
	public enum JsonToken
	{
		None,
		StartObject,
		StartArray,
		StartConstructor,
		PropertyName,
		Comment,
		Raw,
		Integer,
		Float,
		String,
		Boolean,
		Null,
		Undefined,
		EndObject,
		EndArray,
		EndConstructor,
		Date,
		Bytes
	}
	[Preserve]
	public abstract class JsonWriter : IDisposable
	{
		internal enum State
		{
			Start,
			Property,
			ObjectStart,
			Object,
			ArrayStart,
			Array,
			ConstructorStart,
			Constructor,
			Closed,
			Error
		}

		private static readonly State[][] StateArray;

		internal static readonly State[][] StateArrayTempate;

		private List<JsonPosition> _stack;

		private JsonPosition _currentPosition;

		private State _currentState;

		private Formatting _formatting;

		private DateFormatHandling _dateFormatHandling;

		private DateTimeZoneHandling _dateTimeZoneHandling;

		private StringEscapeHandling _stringEscapeHandling;

		private FloatFormatHandling _floatFormatHandling;

		private string _dateFormatString;

		private CultureInfo _culture;

		public bool CloseOutput { get; set; }

		protected internal int Top
		{
			get
			{
				int num = ((_stack != null) ? _stack.Count : 0);
				if (Peek() != JsonContainerType.None)
				{
					num++;
				}
				return num;
			}
		}

		public WriteState WriteState
		{
			get
			{
				switch (_currentState)
				{
				case State.Error:
					return WriteState.Error;
				case State.Closed:
					return WriteState.Closed;
				case State.ObjectStart:
				case State.Object:
					return WriteState.Object;
				case State.ArrayStart:
				case State.Array:
					return WriteState.Array;
				case State.ConstructorStart:
				case State.Constructor:
					return WriteState.Constructor;
				case State.Property:
					return WriteState.Property;
				case State.Start:
					return WriteState.Start;
				default:
					throw JsonWriterException.Create(this, "Invalid state: " + _currentState, null);
				}
			}
		}

		internal string ContainerPath
		{
			get
			{
				if (_currentPosition.Type == JsonContainerType.None || _stack == null)
				{
					return string.Empty;
				}
				return JsonPosition.BuildPath(_stack, null);
			}
		}

		public string Path
		{
			get
			{
				if (_currentPosition.Type == JsonContainerType.None)
				{
					return string.Empty;
				}
				JsonPosition? currentPosition = ((_currentState != State.ArrayStart && _currentState != State.ConstructorStart && _currentState != State.ObjectStart) ? new JsonPosition?(_currentPosition) : ((JsonPosition?)null));
				return JsonPosition.BuildPath(_stack, currentPosition);
			}
		}

		public Formatting Formatting
		{
			get
			{
				return _formatting;
			}
			set
			{
				if (value < Formatting.None || value > Formatting.Indented)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_formatting = value;
			}
		}

		public DateFormatHandling DateFormatHandling
		{
			get
			{
				return _dateFormatHandling;
			}
			set
			{
				if (value < DateFormatHandling.IsoDateFormat || value > DateFormatHandling.MicrosoftDateFormat)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_dateFormatHandling = value;
			}
		}

		public DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				return _dateTimeZoneHandling;
			}
			set
			{
				if (value < DateTimeZoneHandling.Local || value > DateTimeZoneHandling.RoundtripKind)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_dateTimeZoneHandling = value;
			}
		}

		public StringEscapeHandling StringEscapeHandling
		{
			get
			{
				return _stringEscapeHandling;
			}
			set
			{
				if (value < StringEscapeHandling.Default || value > StringEscapeHandling.EscapeHtml)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_stringEscapeHandling = value;
				OnStringEscapeHandlingChanged();
			}
		}

		public FloatFormatHandling FloatFormatHandling
		{
			get
			{
				return _floatFormatHandling;
			}
			set
			{
				if (value < FloatFormatHandling.String || value > FloatFormatHandling.DefaultValue)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_floatFormatHandling = value;
			}
		}

		public string DateFormatString
		{
			get
			{
				return _dateFormatString;
			}
			set
			{
				_dateFormatString = value;
			}
		}

		public CultureInfo Culture
		{
			get
			{
				return _culture ?? CultureInfo.InvariantCulture;
			}
			set
			{
				_culture = value;
			}
		}

		internal static State[][] BuildStateArray()
		{
			List<State[]> list = StateArrayTempate.ToList();
			State[] item = StateArrayTempate[0];
			State[] item2 = StateArrayTempate[7];
			foreach (JsonToken value in EnumUtils.GetValues(typeof(JsonToken)))
			{
				if (list.Count <= (int)value)
				{
					switch (value)
					{
					case JsonToken.Integer:
					case JsonToken.Float:
					case JsonToken.String:
					case JsonToken.Boolean:
					case JsonToken.Null:
					case JsonToken.Undefined:
					case JsonToken.Date:
					case JsonToken.Bytes:
						list.Add(item2);
						break;
					default:
						list.Add(item);
						break;
					}
				}
			}
			return list.ToArray();
		}

		static JsonWriter()
		{
			StateArrayTempate = new State[8][]
			{
				new State[10]
				{
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.ObjectStart,
					State.ObjectStart,
					State.Error,
					State.Error,
					State.ObjectStart,
					State.ObjectStart,
					State.ObjectStart,
					State.ObjectStart,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.ArrayStart,
					State.ArrayStart,
					State.Error,
					State.Error,
					State.ArrayStart,
					State.ArrayStart,
					State.ArrayStart,
					State.ArrayStart,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.ConstructorStart,
					State.ConstructorStart,
					State.Error,
					State.Error,
					State.ConstructorStart,
					State.ConstructorStart,
					State.ConstructorStart,
					State.ConstructorStart,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.Property,
					State.Error,
					State.Property,
					State.Property,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.Start,
					State.Property,
					State.ObjectStart,
					State.Object,
					State.ArrayStart,
					State.Array,
					State.Constructor,
					State.Constructor,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.Start,
					State.Property,
					State.ObjectStart,
					State.Object,
					State.ArrayStart,
					State.Array,
					State.Constructor,
					State.Constructor,
					State.Error,
					State.Error
				},
				new State[10]
				{
					State.Start,
					State.Object,
					State.Error,
					State.Error,
					State.Array,
					State.Array,
					State.Constructor,
					State.Constructor,
					State.Error,
					State.Error
				}
			};
			StateArray = BuildStateArray();
		}

		internal virtual void OnStringEscapeHandlingChanged()
		{
		}

		protected JsonWriter()
		{
			_currentState = State.Start;
			_formatting = Formatting.None;
			_dateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;
			CloseOutput = true;
		}

		internal void UpdateScopeWithFinishedValue()
		{
			if (_currentPosition.HasIndex)
			{
				_currentPosition.Position++;
			}
		}

		private void Push(JsonContainerType value)
		{
			if (_currentPosition.Type != JsonContainerType.None)
			{
				if (_stack == null)
				{
					_stack = new List<JsonPosition>();
				}
				_stack.Add(_currentPosition);
			}
			_currentPosition = new JsonPosition(value);
		}

		private JsonContainerType Pop()
		{
			JsonPosition currentPosition = _currentPosition;
			if (_stack != null && _stack.Count > 0)
			{
				_currentPosition = _stack[_stack.Count - 1];
				_stack.RemoveAt(_stack.Count - 1);
			}
			else
			{
				_currentPosition = default(JsonPosition);
			}
			return currentPosition.Type;
		}

		private JsonContainerType Peek()
		{
			return _currentPosition.Type;
		}

		public abstract void Flush();

		public virtual void Close()
		{
			AutoCompleteAll();
		}

		public virtual void WriteStartObject()
		{
			InternalWriteStart(JsonToken.StartObject, JsonContainerType.Object);
		}

		public virtual void WriteEndObject()
		{
			InternalWriteEnd(JsonContainerType.Object);
		}

		public virtual void WriteStartArray()
		{
			InternalWriteStart(JsonToken.StartArray, JsonContainerType.Array);
		}

		public virtual void WriteEndArray()
		{
			InternalWriteEnd(JsonContainerType.Array);
		}

		public virtual void WriteStartConstructor(string name)
		{
			InternalWriteStart(JsonToken.StartConstructor, JsonContainerType.Constructor);
		}

		public virtual void WriteEndConstructor()
		{
			InternalWriteEnd(JsonContainerType.Constructor);
		}

		public virtual void WritePropertyName(string name)
		{
			InternalWritePropertyName(name);
		}

		public virtual void WritePropertyName(string name, bool escape)
		{
			WritePropertyName(name);
		}

		public virtual void WriteEnd()
		{
			WriteEnd(Peek());
		}

		public void WriteToken(JsonReader reader)
		{
			WriteToken(reader, writeChildren: true);
		}

		public void WriteToken(JsonReader reader, bool writeChildren)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			WriteToken(reader, writeChildren, writeDateConstructorAsDate: true, writeComments: true);
		}

		public void WriteToken(JsonToken token, object value)
		{
			switch (token)
			{
			case JsonToken.StartObject:
				WriteStartObject();
				break;
			case JsonToken.StartArray:
				WriteStartArray();
				break;
			case JsonToken.StartConstructor:
				ValidationUtils.ArgumentNotNull(value, "value");
				WriteStartConstructor(value.ToString());
				break;
			case JsonToken.PropertyName:
				ValidationUtils.ArgumentNotNull(value, "value");
				WritePropertyName(value.ToString());
				break;
			case JsonToken.Comment:
				WriteComment(value?.ToString());
				break;
			case JsonToken.Integer:
				ValidationUtils.ArgumentNotNull(value, "value");
				WriteValue(Convert.ToInt64(value, CultureInfo.InvariantCulture));
				break;
			case JsonToken.Float:
				ValidationUtils.ArgumentNotNull(value, "value");
				if (value is decimal)
				{
					WriteValue((decimal)value);
				}
				else if (value is double)
				{
					WriteValue((double)value);
				}
				else if (value is float)
				{
					WriteValue((float)value);
				}
				else
				{
					WriteValue(Convert.ToDouble(value, CultureInfo.InvariantCulture));
				}
				break;
			case JsonToken.String:
				ValidationUtils.ArgumentNotNull(value, "value");
				WriteValue(value.ToString());
				break;
			case JsonToken.Boolean:
				ValidationUtils.ArgumentNotNull(value, "value");
				WriteValue(Convert.ToBoolean(value, CultureInfo.InvariantCulture));
				break;
			case JsonToken.Null:
				WriteNull();
				break;
			case JsonToken.Undefined:
				WriteUndefined();
				break;
			case JsonToken.EndObject:
				WriteEndObject();
				break;
			case JsonToken.EndArray:
				WriteEndArray();
				break;
			case JsonToken.EndConstructor:
				WriteEndConstructor();
				break;
			case JsonToken.Date:
				ValidationUtils.ArgumentNotNull(value, "value");
				if (value is DateTimeOffset)
				{
					WriteValue((DateTimeOffset)value);
				}
				else
				{
					WriteValue(Convert.ToDateTime(value, CultureInfo.InvariantCulture));
				}
				break;
			case JsonToken.Raw:
				WriteRawValue(value?.ToString());
				break;
			case JsonToken.Bytes:
				ValidationUtils.ArgumentNotNull(value, "value");
				if (value is Guid)
				{
					WriteValue((Guid)value);
				}
				else
				{
					WriteValue((byte[])value);
				}
				break;
			default:
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException("token", token, "Unexpected token type.");
			case JsonToken.None:
				break;
			}
		}

		public void WriteToken(JsonToken token)
		{
			WriteToken(token, null);
		}

		internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments)
		{
			int num = ((reader.TokenType == JsonToken.None) ? (-1) : (JsonTokenUtils.IsStartToken(reader.TokenType) ? reader.Depth : (reader.Depth + 1)));
			do
			{
				if (writeDateConstructorAsDate && reader.TokenType == JsonToken.StartConstructor && string.Equals(reader.Value.ToString(), "Date", StringComparison.Ordinal))
				{
					WriteConstructorDate(reader);
				}
				else if (writeComments || reader.TokenType != JsonToken.Comment)
				{
					WriteToken(reader.TokenType, reader.Value);
				}
			}
			while (num - 1 < reader.Depth - (JsonTokenUtils.IsEndToken(reader.TokenType) ? 1 : 0) && writeChildren && reader.Read());
		}

		private void WriteConstructorDate(JsonReader reader)
		{
			if (!reader.Read())
			{
				throw JsonWriterException.Create(this, "Unexpected end when reading date constructor.", null);
			}
			if (reader.TokenType != JsonToken.Integer)
			{
				throw JsonWriterException.Create(this, "Unexpected token when reading date constructor. Expected Integer, got " + reader.TokenType, null);
			}
			DateTime value = DateTimeUtils.ConvertJavaScriptTicksToDateTime((long)reader.Value);
			if (!reader.Read())
			{
				throw JsonWriterException.Create(this, "Unexpected end when reading date constructor.", null);
			}
			if (reader.TokenType != JsonToken.EndConstructor)
			{
				throw JsonWriterException.Create(this, "Unexpected token when reading date constructor. Expected EndConstructor, got " + reader.TokenType, null);
			}
			WriteValue(value);
		}

		private void WriteEnd(JsonContainerType type)
		{
			switch (type)
			{
			case JsonContainerType.Object:
				WriteEndObject();
				break;
			case JsonContainerType.Array:
				WriteEndArray();
				break;
			case JsonContainerType.Constructor:
				WriteEndConstructor();
				break;
			default:
				throw JsonWriterException.Create(this, "Unexpected type when writing end: " + type, null);
			}
		}

		private void AutoCompleteAll()
		{
			while (Top > 0)
			{
				WriteEnd();
			}
		}

		private JsonToken GetCloseTokenForType(JsonContainerType type)
		{
			return type switch
			{
				JsonContainerType.Object => JsonToken.EndObject, 
				JsonContainerType.Array => JsonToken.EndArray, 
				JsonContainerType.Constructor => JsonToken.EndConstructor, 
				_ => throw JsonWriterException.Create(this, "No close token for type: " + type, null), 
			};
		}

		private void AutoCompleteClose(JsonContainerType type)
		{
			int num = 0;
			if (_currentPosition.Type == type)
			{
				num = 1;
			}
			else
			{
				int num2 = Top - 2;
				for (int num3 = num2; num3 >= 0; num3--)
				{
					int index = num2 - num3;
					if (_stack[index].Type == type)
					{
						num = num3 + 2;
						break;
					}
				}
			}
			if (num == 0)
			{
				throw JsonWriterException.Create(this, "No token to close.", null);
			}
			for (int i = 0; i < num; i++)
			{
				JsonToken closeTokenForType = GetCloseTokenForType(Pop());
				if (_currentState == State.Property)
				{
					WriteNull();
				}
				if (_formatting == Formatting.Indented && _currentState != State.ObjectStart && _currentState != State.ArrayStart)
				{
					WriteIndent();
				}
				WriteEnd(closeTokenForType);
				JsonContainerType jsonContainerType = Peek();
				switch (jsonContainerType)
				{
				case JsonContainerType.Object:
					_currentState = State.Object;
					break;
				case JsonContainerType.Array:
					_currentState = State.Array;
					break;
				case JsonContainerType.Constructor:
					_currentState = State.Array;
					break;
				case JsonContainerType.None:
					_currentState = State.Start;
					break;
				default:
					throw JsonWriterException.Create(this, "Unknown JsonType: " + jsonContainerType, null);
				}
			}
		}

		protected virtual void WriteEnd(JsonToken token)
		{
		}

		protected virtual void WriteIndent()
		{
		}

		protected virtual void WriteValueDelimiter()
		{
		}

		protected virtual void WriteIndentSpace()
		{
		}

		internal void AutoComplete(JsonToken tokenBeingWritten)
		{
			State state = StateArray[(int)tokenBeingWritten][(int)_currentState];
			if (state == State.Error)
			{
				throw JsonWriterException.Create(this, "Token {0} in state {1} would result in an invalid JSON object.".FormatWith(CultureInfo.InvariantCulture, tokenBeingWritten.ToString(), _currentState.ToString()), null);
			}
			if ((_currentState == State.Object || _currentState == State.Array || _currentState == State.Constructor) && tokenBeingWritten != JsonToken.Comment)
			{
				WriteValueDelimiter();
			}
			if (_formatting == Formatting.Indented)
			{
				if (_currentState == State.Property)
				{
					WriteIndentSpace();
				}
				if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.Constructor || _currentState == State.ConstructorStart || (tokenBeingWritten == JsonToken.PropertyName && _currentState != State.Start))
				{
					WriteIndent();
				}
			}
			_currentState = state;
		}

		public virtual void WriteNull()
		{
			InternalWriteValue(JsonToken.Null);
		}

		public virtual void WriteUndefined()
		{
			InternalWriteValue(JsonToken.Undefined);
		}

		public virtual void WriteRaw(string json)
		{
			InternalWriteRaw();
		}

		public virtual void WriteRawValue(string json)
		{
			UpdateScopeWithFinishedValue();
			AutoComplete(JsonToken.Undefined);
			WriteRaw(json);
		}

		public virtual void WriteValue(string value)
		{
			InternalWriteValue(JsonToken.String);
		}

		public virtual void WriteValue(int value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(uint value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(long value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(ulong value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(float value)
		{
			InternalWriteValue(JsonToken.Float);
		}

		public virtual void WriteValue(double value)
		{
			InternalWriteValue(JsonToken.Float);
		}

		public virtual void WriteValue(bool value)
		{
			InternalWriteValue(JsonToken.Boolean);
		}

		public virtual void WriteValue(short value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(ushort value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(char value)
		{
			InternalWriteValue(JsonToken.String);
		}

		public virtual void WriteValue(byte value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(sbyte value)
		{
			InternalWriteValue(JsonToken.Integer);
		}

		public virtual void WriteValue(decimal value)
		{
			InternalWriteValue(JsonToken.Float);
		}

		public virtual void WriteValue(DateTime value)
		{
			InternalWriteValue(JsonToken.Date);
		}

		public virtual void WriteValue(DateTimeOffset value)
		{
			InternalWriteValue(JsonToken.Date);
		}

		public virtual void WriteValue(Guid value)
		{
			InternalWriteValue(JsonToken.String);
		}

		public virtual void WriteValue(TimeSpan value)
		{
			InternalWriteValue(JsonToken.String);
		}

		public virtual void WriteValue(int? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(uint? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(long? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(ulong? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(float? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(double? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(bool? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value == true);
			}
		}

		public virtual void WriteValue(short? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(ushort? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(char? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(byte? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		[CLSCompliant(false)]
		public virtual void WriteValue(sbyte? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(decimal? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(DateTime? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(DateTimeOffset? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(Guid? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(TimeSpan? value)
		{
			if (!value.HasValue)
			{
				WriteNull();
			}
			else
			{
				WriteValue(value.GetValueOrDefault());
			}
		}

		public virtual void WriteValue(byte[] value)
		{
			if (value == null)
			{
				WriteNull();
			}
			else
			{
				InternalWriteValue(JsonToken.Bytes);
			}
		}

		public virtual void WriteValue(Uri value)
		{
			if (value == null)
			{
				WriteNull();
			}
			else
			{
				InternalWriteValue(JsonToken.String);
			}
		}

		public virtual void WriteValue(object value)
		{
			if (value == null)
			{
				WriteNull();
			}
			else
			{
				WriteValue(this, ConvertUtils.GetTypeCode(value.GetType()), value);
			}
		}

		public virtual void WriteComment(string text)
		{
			InternalWriteComment();
		}

		public virtual void WriteWhitespace(string ws)
		{
			InternalWriteWhitespace(ws);
		}

		void IDisposable.Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (_currentState != State.Closed && disposing)
			{
				Close();
			}
		}

		internal static void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value)
		{
			switch (typeCode)
			{
			case PrimitiveTypeCode.Char:
				writer.WriteValue((char)value);
				return;
			case PrimitiveTypeCode.CharNullable:
				writer.WriteValue((value == null) ? ((char?)null) : new char?((char)value));
				return;
			case PrimitiveTypeCode.Boolean:
				writer.WriteValue((bool)value);
				return;
			case PrimitiveTypeCode.BooleanNullable:
				writer.WriteValue((value == null) ? ((bool?)null) : new bool?((bool)value));
				return;
			case PrimitiveTypeCode.SByte:
				writer.WriteValue((sbyte)value);
				return;
			case PrimitiveTypeCode.SByteNullable:
				writer.WriteValue((value == null) ? ((sbyte?)null) : new sbyte?((sbyte)value));
				return;
			case PrimitiveTypeCode.Int16:
				writer.WriteValue((short)value);
				return;
			case PrimitiveTypeCode.Int16Nullable:
				writer.WriteValue((value == null) ? ((short?)null) : new short?((short)value));
				return;
			case PrimitiveTypeCode.UInt16:
				writer.WriteValue((ushort)value);
				return;
			case PrimitiveTypeCode.UInt16Nullable:
				writer.WriteValue((value == null) ? ((ushort?)null) : new ushort?((ushort)value));
				return;
			case PrimitiveTypeCode.Int32:
				writer.WriteValue((int)value);
				return;
			case PrimitiveTypeCode.Int32Nullable:
				writer.WriteValue((value == null) ? ((int?)null) : new int?((int)value));
				return;
			case PrimitiveTypeCode.Byte:
				writer.WriteValue((byte)value);
				return;
			case PrimitiveTypeCode.ByteNullable:
				writer.WriteValue((value == null) ? ((byte?)null) : new byte?((byte)value));
				return;
			case PrimitiveTypeCode.UInt32:
				writer.WriteValue((uint)value);
				return;
			case PrimitiveTypeCode.UInt32Nullable:
				writer.WriteValue((value == null) ? ((uint?)null) : new uint?((uint)value));
				return;
			case PrimitiveTypeCode.Int64:
				writer.WriteValue((long)value);
				return;
			case PrimitiveTypeCode.Int64Nullable:
				writer.WriteValue((value == null) ? ((long?)null) : new long?((long)value));
				return;
			case PrimitiveTypeCode.UInt64:
				writer.WriteValue((ulong)value);
				return;
			case PrimitiveTypeCode.UInt64Nullable:
				writer.WriteValue((value == null) ? ((ulong?)null) : new ulong?((ulong)value));
				return;
			case PrimitiveTypeCode.Single:
				writer.WriteValue((float)value);
				return;
			case PrimitiveTypeCode.SingleNullable:
				writer.WriteValue((value == null) ? ((float?)null) : new float?((float)value));
				return;
			case PrimitiveTypeCode.Double:
				writer.WriteValue((double)value);
				return;
			case PrimitiveTypeCode.DoubleNullable:
				writer.WriteValue((value == null) ? ((double?)null) : new double?((double)value));
				return;
			case PrimitiveTypeCode.DateTime:
				writer.WriteValue((DateTime)value);
				return;
			case PrimitiveTypeCode.DateTimeNullable:
				writer.WriteValue((value == null) ? ((DateTime?)null) : new DateTime?((DateTime)value));
				return;
			case PrimitiveTypeCode.DateTimeOffset:
				writer.WriteValue((DateTimeOffset)value);
				return;
			case PrimitiveTypeCode.DateTimeOffsetNullable:
				writer.WriteValue((value == null) ? ((DateTimeOffset?)null) : new DateTimeOffset?((DateTimeOffset)value));
				return;
			case PrimitiveTypeCode.Decimal:
				writer.WriteValue((decimal)value);
				return;
			case PrimitiveTypeCode.DecimalNullable:
				writer.WriteValue((value == null) ? ((decimal?)null) : new decimal?((decimal)value));
				return;
			case PrimitiveTypeCode.Guid:
				writer.WriteValue((Guid)value);
				return;
			case PrimitiveTypeCode.GuidNullable:
				writer.WriteValue((value == null) ? ((Guid?)null) : new Guid?((Guid)value));
				return;
			case PrimitiveTypeCode.TimeSpan:
				writer.WriteValue((TimeSpan)value);
				return;
			case PrimitiveTypeCode.TimeSpanNullable:
				writer.WriteValue((value == null) ? ((TimeSpan?)null) : new TimeSpan?((TimeSpan)value));
				return;
			case PrimitiveTypeCode.Uri:
				writer.WriteValue((Uri)value);
				return;
			case PrimitiveTypeCode.String:
				writer.WriteValue((string)value);
				return;
			case PrimitiveTypeCode.Bytes:
				writer.WriteValue((byte[])value);
				return;
			case PrimitiveTypeCode.DBNull:
				writer.WriteNull();
				return;
			}
			if (value is IConvertible)
			{
				IConvertible obj = (IConvertible)value;
				TypeInformation typeInformation = ConvertUtils.GetTypeInformation(obj);
				PrimitiveTypeCode typeCode2 = ((typeInformation.TypeCode == PrimitiveTypeCode.Object) ? PrimitiveTypeCode.String : typeInformation.TypeCode);
				Type conversionType = ((typeInformation.TypeCode == PrimitiveTypeCode.Object) ? typeof(string) : typeInformation.Type);
				object value2 = obj.ToType(conversionType, CultureInfo.InvariantCulture);
				WriteValue(writer, typeCode2, value2);
				return;
			}
			throw CreateUnsupportedTypeException(writer, value);
		}

		private static JsonWriterException CreateUnsupportedTypeException(JsonWriter writer, object value)
		{
			return JsonWriterException.Create(writer, "Unsupported type: {0}. Use the JsonSerializer class to get the object's JSON representation.".FormatWith(CultureInfo.InvariantCulture, value.GetType()), null);
		}

		protected void SetWriteState(JsonToken token, object value)
		{
			switch (token)
			{
			case JsonToken.StartObject:
				InternalWriteStart(token, JsonContainerType.Object);
				break;
			case JsonToken.StartArray:
				InternalWriteStart(token, JsonContainerType.Array);
				break;
			case JsonToken.StartConstructor:
				InternalWriteStart(token, JsonContainerType.Constructor);
				break;
			case JsonToken.PropertyName:
				if (!(value is string))
				{
					throw new ArgumentException("A name is required when setting property name state.", "value");
				}
				InternalWritePropertyName((string)value);
				break;
			case JsonToken.Comment:
				InternalWriteComment();
				break;
			case JsonToken.Raw:
				InternalWriteRaw();
				break;
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Null:
			case JsonToken.Undefined:
			case JsonToken.Date:
			case JsonToken.Bytes:
				InternalWriteValue(token);
				break;
			case JsonToken.EndObject:
				InternalWriteEnd(JsonContainerType.Object);
				break;
			case JsonToken.EndArray:
				InternalWriteEnd(JsonContainerType.Array);
				break;
			case JsonToken.EndConstructor:
				InternalWriteEnd(JsonContainerType.Constructor);
				break;
			default:
				throw new ArgumentOutOfRangeException("token");
			}
		}

		internal void InternalWriteEnd(JsonContainerType container)
		{
			AutoCompleteClose(container);
		}

		internal void InternalWritePropertyName(string name)
		{
			_currentPosition.PropertyName = name;
			AutoComplete(JsonToken.PropertyName);
		}

		internal void InternalWriteRaw()
		{
		}

		internal void InternalWriteStart(JsonToken token, JsonContainerType container)
		{
			UpdateScopeWithFinishedValue();
			AutoComplete(token);
			Push(container);
		}

		internal void InternalWriteValue(JsonToken token)
		{
			UpdateScopeWithFinishedValue();
			AutoComplete(token);
		}

		internal void InternalWriteWhitespace(string ws)
		{
			if (ws != null && !StringUtils.IsWhiteSpace(ws))
			{
				throw JsonWriterException.Create(this, "Only white space characters should be used.", null);
			}
		}

		internal void InternalWriteComment()
		{
			AutoComplete(JsonToken.Comment);
		}
	}
	[Preserve]
	public enum WriteState
	{
		Error,
		Closed,
		Object,
		Array,
		Constructor,
		Property,
		Start
	}
}
namespace Newtonsoft.Json.Utilities
{
	[Preserve]
	internal enum ParserTimeZone
	{
		Unspecified,
		Utc,
		LocalWestOfUtc,
		LocalEastOfUtc
	}
	[Preserve]
	internal struct DateTimeParser
	{
		public int Year;

		public int Month;

		public int Day;

		public int Hour;

		public int Minute;

		public int Second;

		public int Fraction;

		public int ZoneHour;

		public int ZoneMinute;

		public ParserTimeZone Zone;

		private char[] _text;

		private int _end;

		private static readonly int[] Power10;

		private static readonly int Lzyyyy;

		private static readonly int Lzyyyy_;

		private static readonly int Lzyyyy_MM;

		private static readonly int Lzyyyy_MM_;

		private static readonly int Lzyyyy_MM_dd;

		private static readonly int Lzyyyy_MM_ddT;

		private static readonly int LzHH;

		private static readonly int LzHH_;

		private static readonly int LzHH_mm;

		private static readonly int LzHH_mm_;

		private static readonly int LzHH_mm_ss;

		private static readonly int Lz_;

		private static readonly int Lz_zz;

		private const short MaxFractionDigits = 7;

		static DateTimeParser()
		{
			Power10 = new int[7] { -1, 10, 100, 1000, 10000, 100000, 1000000 };
			Lzyyyy = "yyyy".Length;
			Lzyyyy_ = "yyyy-".Length;
			Lzyyyy_MM = "yyyy-MM".Length;
			Lzyyyy_MM_ = "yyyy-MM-".Length;
			Lzyyyy_MM_dd = "yyyy-MM-dd".Length;
			Lzyyyy_MM_ddT = "yyyy-MM-ddT".Length;
			LzHH = "HH".Length;
			LzHH_ = "HH:".Length;
			LzHH_mm = "HH:mm".Length;
			LzHH_mm_ = "HH:mm:".Length;
			LzHH_mm_ss = "HH:mm:ss".Length;
			Lz_ = "-".Length;
			Lz_zz = "-zz".Length;
		}

		public bool Parse(char[] text, int startIndex, int length)
		{
			_text = text;
			_end = startIndex + length;
			if (ParseDate(startIndex) && ParseChar(Lzyyyy_MM_dd + startIndex, 'T') && ParseTimeAndZoneAndWhitespace(Lzyyyy_MM_ddT + startIndex))
			{
				return true;
			}
			return false;
		}

		private bool ParseDate(int start)
		{
			if (Parse4Digit(start, out Year) && 1 <= Year && ParseChar(start + Lzyyyy, '-') && Parse2Digit(start + Lzyyyy_, out Month) && 1 <= Month && Month <= 12 && ParseChar(start + Lzyyyy_MM, '-') && Parse2Digit(start + Lzyyyy_MM_, out Day) && 1 <= Day)
			{
				return Day <= DateTime.DaysInMonth(Year, Month);
			}
			return false;
		}

		private bool ParseTimeAndZoneAndWhitespace(int start)
		{
			if (ParseTime(ref start))
			{
				return ParseZone(start);
			}
			return false;
		}

		private bool ParseTime(ref int start)
		{
			if (!Parse2Digit(start, out Hour) || Hour > 24 || !ParseChar(start + LzHH, ':') || !Parse2Digit(start + LzHH_, out Minute) || Minute >= 60 || !ParseChar(start + LzHH_mm, ':') || !Parse2Digit(start + LzHH_mm_, out Second) || Second >= 60 || (Hour == 24 && (Minute != 0 || Second != 0)))
			{
				return false;
			}
			start += LzHH_mm_ss;
			if (ParseChar(start, '.'))
			{
				Fraction = 0;
				int num = 0;
				while (++start < _end && num < 7)
				{
					int num2 = _text[start] - 48;
					if (num2 < 0 || num2 > 9)
					{
						break;
					}
					Fraction = Fraction * 10 + num2;
					num++;
				}
				if (num < 7)
				{
					if (num == 0)
					{
						return false;
					}
					Fraction *= Power10[7 - num];
				}
				if (Hour == 24 && Fraction != 0)
				{
					return false;
				}
			}
			return true;
		}

		private bool ParseZone(int start)
		{
			if (start < _end)
			{
				char c = _text[start];
				if (c == 'Z' || c == 'z')
				{
					Zone = ParserTimeZone.Utc;
					start++;
				}
				else
				{
					if (start + 2 < _end && Parse2Digit(start + Lz_, out ZoneHour) && ZoneHour <= 99)
					{
						switch (c)
						{
						case '-':
							Zone = ParserTimeZone.LocalWestOfUtc;
							start += Lz_zz;
							break;
						case '+':
							Zone = ParserTimeZone.LocalEastOfUtc;
							start += Lz_zz;
							break;
						}
					}
					if (start < _end)
					{
						if (ParseChar(start, ':'))
						{
							start++;
							if (start + 1 < _end && Parse2Digit(start, out ZoneMinute) && ZoneMinute <= 99)
							{
								start += 2;
							}
						}
						else if (start + 1 < _end && Parse2Digit(start, out ZoneMinute) && ZoneMinute <= 99)
						{
							start += 2;
						}
					}
				}
			}
			return start == _end;
		}

		private bool Parse4Digit(int start, out int num)
		{
			if (start + 3 < _end)
			{
				int num2 = _text[start] - 48;
				int num3 = _text[start + 1] - 48;
				int num4 = _text[start + 2] - 48;
				int num5 = _text[start + 3] - 48;
				if (0 <= num2 && num2 < 10 && 0 <= num3 && num3 < 10 && 0 <= num4 && num4 < 10 && 0 <= num5 && num5 < 10)
				{
					num = ((num2 * 10 + num3) * 10 + num4) * 10 + num5;
					return true;
				}
			}
			num = 0;
			return false;
		}

		private bool Parse2Digit(int start, out int num)
		{
			if (start + 1 < _end)
			{
				int num2 = _text[start] - 48;
				int num3 = _text[start + 1] - 48;
				if (0 <= num2 && num2 < 10 && 0 <= num3 && num3 < 10)
				{
					num = num2 * 10 + num3;
					return true;
				}
			}
			num = 0;
			return false;
		}

		private bool ParseChar(int start, char ch)
		{
			if (start < _end)
			{
				return _text[start] == ch;
			}
			return false;
		}
	}
	[Preserve]
	internal class Base64Encoder
	{
		private const int Base64LineSize = 76;

		private const int LineSizeInBytes = 57;

		private readonly char[] _charsLine = new char[76];

		private readonly TextWriter _writer;

		private byte[] _leftOverBytes;

		private int _leftOverBytesCount;

		public Base64Encoder(TextWriter writer)
		{
			ValidationUtils.ArgumentNotNull(writer, "writer");
			_writer = writer;
		}

		public void Encode(byte[] buffer, int index, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (count > buffer.Length - index)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (_leftOverBytesCount > 0)
			{
				int leftOverBytesCount = _leftOverBytesCount;
				while (leftOverBytesCount < 3 && count > 0)
				{
					_leftOverBytes[leftOverBytesCount++] = buffer[index++];
					count--;
				}
				if (count == 0 && leftOverBytesCount < 3)
				{
					_leftOverBytesCount = leftOverBytesCount;
					return;
				}
				int count2 = Convert.ToBase64CharArray(_leftOverBytes, 0, 3, _charsLine, 0);
				WriteChars(_charsLine, 0, count2);
			}
			_leftOverBytesCount = count % 3;
			if (_leftOverBytesCount > 0)
			{
				count -= _leftOverBytesCount;
				if (_leftOverBytes == null)
				{
					_leftOverBytes = new byte[3];
				}
				for (int i = 0; i < _leftOverBytesCount; i++)
				{
					_leftOverBytes[i] = buffer[index + count + i];
				}
			}
			int num = index + count;
			int num2 = 57;
			while (index < num)
			{
				if (index + num2 > num)
				{
					num2 = num - index;
				}
				int count3 = Convert.ToBase64CharArray(buffer, index, num2, _charsLine, 0);
				WriteChars(_charsLine, 0, count3);
				index += num2;
			}
		}

		public void Flush()
		{
			if (_leftOverBytesCount > 0)
			{
				int count = Convert.ToBase64CharArray(_leftOverBytes, 0, _leftOverBytesCount, _charsLine, 0);
				WriteChars(_charsLine, 0, count);
				_leftOverBytesCount = 0;
			}
		}

		private void WriteChars(char[] chars, int index, int count)
		{
			_writer.Write(chars, index, count);
		}
	}
	[Preserve]
	internal static class JsonTokenUtils
	{
		internal static bool IsEndToken(JsonToken token)
		{
			switch (token)
			{
			case JsonToken.EndObject:
			case JsonToken.EndArray:
			case JsonToken.EndConstructor:
				return true;
			default:
				return false;
			}
		}

		internal static bool IsStartToken(JsonToken token)
		{
			switch (token)
			{
			case JsonToken.StartObject:
			case JsonToken.StartArray:
			case JsonToken.StartConstructor:
				return true;
			default:
				return false;
			}
		}

		internal static bool IsPrimitiveToken(JsonToken token)
		{
			switch (token)
			{
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Null:
			case JsonToken.Undefined:
			case JsonToken.Date:
			case JsonToken.Bytes:
				return true;
			default:
				return false;
			}
		}
	}
	[Preserve]
	internal class PropertyNameTable
	{
		private class Entry
		{
			internal readonly string Value;

			internal readonly int HashCode;

			internal Entry Next;

			internal Entry(string value, int hashCode, Entry next)
			{
				Value = value;
				HashCode = hashCode;
				Next = next;
			}
		}

		private static readonly int HashCodeRandomizer;

		private int _count;

		private Entry[] _entries;

		private int _mask = 31;

		static PropertyNameTable()
		{
			HashCodeRandomizer = Environment.TickCount;
		}

		public PropertyNameTable()
		{
			_entries = new Entry[_mask + 1];
		}

		public string Get(char[] key, int start, int length)
		{
			if (length == 0)
			{
				return string.Empty;
			}
			int num = length + HashCodeRandomizer;
			num += (num << 7) ^ key[start];
			int num2 = start + length;
			for (int i = start + 1; i < num2; i++)
			{
				num += (num << 7) ^ key[i];
			}
			num -= num >> 17;
			num -= num >> 11;
			num -= num >> 5;
			for (Entry entry = _entries[num & _mask]; entry != null; entry = entry.Next)
			{
				if (entry.HashCode == num && TextEquals(entry.Value, key, start, length))
				{
					return entry.Value;
				}
			}
			return null;
		}

		public string Add(string key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			int length = key.Length;
			if (length == 0)
			{
				return string.Empty;
			}
			int num = length + HashCodeRandomizer;
			for (int i = 0; i < key.Length; i++)
			{
				num += (num << 7) ^ key[i];
			}
			num -= num >> 17;
			num -= num >> 11;
			num -= num >> 5;
			for (Entry entry = _entries[num & _mask]; entry != null; entry = entry.Next)
			{
				if (entry.HashCode == num && entry.Value.Equals(key))
				{
					return entry.Value;
				}
			}
			return AddEntry(key, num);
		}

		private string AddEntry(string str, int hashCode)
		{
			int num = hashCode & _mask;
			Entry entry = new Entry(str, hashCode, _entries[num]);
			_entries[num] = entry;
			if (_count++ == _mask)
			{
				Grow();
			}
			return entry.Value;
		}

		private void Grow()
		{
			Entry[] entries = _entries;
			int num = _mask * 2 + 1;
			Entry[] array = new Entry[num + 1];
			for (int i = 0; i < entries.Length; i++)
			{
				Entry entry = entries[i];
				while (entry != null)
				{
					int num2 = entry.HashCode & num;
					Entry next = entry.Next;
					entry.Next = array[num2];
					array[num2] = entry;
					entry = next;
				}
			}
			_entries = array;
			_mask = num;
		}

		private static bool TextEquals(string str1, char[] str2, int str2Start, int str2Length)
		{
			if (str1.Length != str2Length)
			{
				return false;
			}
			for (int i = 0; i < str1.Length; i++)
			{
				if (str1[i] != str2[str2Start + i])
				{
					return false;
				}
			}
			return true;
		}
	}
	[Preserve]
	internal abstract class ReflectionDelegateFactory
	{
		public Func<T, object> CreateGet<T>(MemberInfo memberInfo)
		{
			if (memberInfo is PropertyInfo propertyInfo)
			{
				return CreateGet<T>(propertyInfo);
			}
			if (memberInfo is FieldInfo fieldInfo)
			{
				return CreateGet<T>(fieldInfo);
			}
			throw new Exception("Could not create getter for {0}.".FormatWith(CultureInfo.InvariantCulture, memberInfo));
		}

		public Action<T, object> CreateSet<T>(MemberInfo memberInfo)
		{
			if (memberInfo is PropertyInfo propertyInfo)
			{
				return CreateSet<T>(propertyInfo);
			}
			if (memberInfo is FieldInfo fieldInfo)
			{
				return CreateSet<T>(fieldInfo);
			}
			throw new Exception("Could not create setter for {0}.".FormatWith(CultureInfo.InvariantCulture, memberInfo));
		}

		public abstract MethodCall<T, object> CreateMethodCall<T>(MethodBase method);

		public abstract ObjectConstructor<object> CreateParameterizedConstructor(MethodBase method);

		public abstract Func<T> CreateDefaultConstructor<T>(Type type);

		public abstract Func<T, object> CreateGet<T>(PropertyInfo propertyInfo);

		public abstract Func<T, object> CreateGet<T>(FieldInfo fieldInfo);

		public abstract Action<T, object> CreateSet<T>(FieldInfo fieldInfo);

		public abstract Action<T, object> CreateSet<T>(PropertyInfo propertyInfo);
	}
	[Preserve]
	internal class LateBoundReflectionDelegateFactory : ReflectionDelegateFactory
	{
		private static readonly LateBoundReflectionDelegateFactory _instance = new LateBoundReflectionDelegateFactory();

		internal static ReflectionDelegateFactory Instance => _instance;

		public override ObjectConstructor<object> CreateParameterizedConstructor(MethodBase method)
		{
			ValidationUtils.ArgumentNotNull(method, "method");
			ConstructorInfo c = method as ConstructorInfo;
			if ((object)c != null)
			{
				return (object[] a) => c.Invoke(a);
			}
			return (object[] a) => method.Invoke(null, a);
		}

		public override MethodCall<T, object> CreateMethodCall<T>(MethodBase method)
		{
			ValidationUtils.ArgumentNotNull(method, "method");
			ConstructorInfo c = method as ConstructorInfo;
			if ((object)c != null)
			{
				return (T o, object[] a) => c.Invoke(a);
			}
			return (T o, object[] a) => method.Invoke(o, a);
		}

		public override Func<T> CreateDefaultConstructor<T>(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (type.IsValueType())
			{
				return () => (T)Activator.CreateInstance(type);
			}
			ConstructorInfo constructorInfo = ReflectionUtils.GetDefaultConstructor(type, nonPublic: true);
			return () => (T)constructorInfo.Invoke(null);
		}

		public override Func<T, object> CreateGet<T>(PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			return (T o) => propertyInfo.GetValue(o, null);
		}

		public override Func<T, object> CreateGet<T>(FieldInfo fieldInfo)
		{
			ValidationUtils.ArgumentNotNull(fieldInfo, "fieldInfo");
			return (T o) => fieldInfo.GetValue(o);
		}

		public override Action<T, object> CreateSet<T>(FieldInfo fieldInfo)
		{
			ValidationUtils.ArgumentNotNull(fieldInfo, "fieldInfo");
			return delegate(T o, object v)
			{
				fieldInfo.SetValue(o, v);
			};
		}

		public override Action<T, object> CreateSet<T>(PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			return delegate(T o, object v)
			{
				propertyInfo.SetValue(o, v, null);
			};
		}
	}
	[Preserve]
	internal delegate TResult MethodCall<T, TResult>(T target, params object[] args);
	[Preserve]
	internal class ReflectionMember
	{
		public Type MemberType { get; set; }

		public Func<object, object> Getter { get; set; }

		public Action<object, object> Setter { get; set; }
	}
	[Preserve]
	internal class ReflectionObject
	{
		public ObjectConstructor<object> Creator { get; private set; }

		public IDictionary<string, ReflectionMember> Members { get; private set; }

		public ReflectionObject()
		{
			Members = new Dictionary<string, ReflectionMember>();
		}

		public object GetValue(object target, string member)
		{
			return Members[member].Getter(target);
		}

		public void SetValue(object target, string member, object value)
		{
			Members[member].Setter(target, value);
		}

		public Type GetType(string member)
		{
			return Members[member].MemberType;
		}

		public static ReflectionObject Create(Type t, params string[] memberNames)
		{
			return Create(t, null, memberNames);
		}

		public static ReflectionObject Create(Type t, MethodBase creator, params string[] memberNames)
		{
			ReflectionObject reflectionObject = new ReflectionObject();
			ReflectionDelegateFactory reflectionDelegateFactory = JsonTypeReflector.ReflectionDelegateFactory;
			if ((object)creator != null)
			{
				reflectionObject.Creator = reflectionDelegateFactory.CreateParameterizedConstructor(creator);
			}
			else if (ReflectionUtils.HasDefaultConstructor(t, nonPublic: false))
			{
				Func<object> ctor = reflectionDelegateFactory.CreateDefaultConstructor<object>(t);
				reflectionObject.Creator = (object[] args) => ctor();
			}
			foreach (string text in memberNames)
			{
				MemberInfo[] member = t.GetMember(text, BindingFlags.Instance | BindingFlags.Public);
				if (member.Length != 1)
				{
					throw new ArgumentException("Expected a single member with the name '{0}'.".FormatWith(CultureInfo.InvariantCulture, text));
				}
				MemberInfo memberInfo = member.Single();
				ReflectionMember reflectionMember = new ReflectionMember();
				switch (memberInfo.MemberType())
				{
				case MemberTypes.Field:
				case MemberTypes.Property:
					if (ReflectionUtils.CanReadMemberValue(memberInfo, nonPublic: false))
					{
						reflectionMember.Getter = reflectionDelegateFactory.CreateGet<object>(memberInfo);
					}
					if (ReflectionUtils.CanSetMemberValue(memberInfo, nonPublic: false, canSetReadOnly: false))
					{
						reflectionMember.Setter = reflectionDelegateFactory.CreateSet<object>(memberInfo);
					}
					break;
				case MemberTypes.Method:
				{
					MethodInfo methodInfo = (MethodInfo)memberInfo;
					if (!methodInfo.IsPublic)
					{
						break;
					}
					ParameterInfo[] parameters = methodInfo.GetParameters();
					if (parameters.Length == 0 && (object)methodInfo.ReturnType != typeof(void))
					{
						MethodCall<object, object> call = reflectionDelegateFactory.CreateMethodCall<object>(methodInfo);
						reflectionMember.Getter = (object target) => call(target);
					}
					else if (parameters.Length == 1 && (object)methodInfo.ReturnType == typeof(void))
					{
						MethodCall<object, object> call2 = reflectionDelegateFactory.CreateMethodCall<object>(methodInfo);
						reflectionMember.Setter = delegate(object target, object arg)
						{
							call2(target, arg);
						};
					}
					break;
				}
				default:
					throw new ArgumentException("Unexpected member type '{0}' for member '{1}'.".FormatWith(CultureInfo.InvariantCulture, memberInfo.MemberType(), memberInfo.Name));
				}
				if (ReflectionUtils.CanReadMemberValue(memberInfo, nonPublic: false))
				{
					reflectionMember.Getter = reflectionDelegateFactory.CreateGet<object>(memberInfo);
				}
				if (ReflectionUtils.CanSetMemberValue(memberInfo, nonPublic: false, canSetReadOnly: false))
				{
					reflectionMember.Setter = reflectionDelegateFactory.CreateSet<object>(memberInfo);
				}
				reflectionMember.MemberType = ReflectionUtils.GetMemberUnderlyingType(memberInfo);
				reflectionObject.Members[text] = reflectionMember;
			}
			return reflectionObject;
		}
	}
	[Preserve]
	internal struct StringReference
	{
		private readonly char[] _chars;

		private readonly int _startIndex;

		private readonly int _length;

		public char this[int i] => _chars[i];

		public char[] Chars => _chars;

		public int StartIndex => _startIndex;

		public int Length => _length;

		public StringReference(char[] chars, int startIndex, int length)
		{
			_chars = chars;
			_startIndex = startIndex;
			_length = length;
		}

		public override string ToString()
		{
			return new string(_chars, _startIndex, _length);
		}
	}
	[Preserve]
	internal static class StringReferenceExtensions
	{
		public static int IndexOf(this StringReference s, char c, int startIndex, int length)
		{
			int num = Array.IndexOf(s.Chars, c, s.StartIndex + startIndex, length);
			if (num == -1)
			{
				return -1;
			}
			return num - s.StartIndex;
		}

		public static bool StartsWith(this StringReference s, string text)
		{
			if (text.Length > s.Length)
			{
				return false;
			}
			char[] chars = s.Chars;
			for (int i = 0; i < text.Length; i++)
			{
				if (text[i] != chars[i + s.StartIndex])
				{
					return false;
				}
			}
			return true;
		}

		public static bool EndsWith(this StringReference s, string text)
		{
			if (text.Length > s.Length)
			{
				return false;
			}
			char[] chars = s.Chars;
			int num = s.StartIndex + s.Length - text.Length;
			for (int i = 0; i < text.Length; i++)
			{
				if (text[i] != chars[i + num])
				{
					return false;
				}
			}
			return true;
		}
	}
	[Preserve]
	internal class ThreadSafeStore<TKey, TValue>
	{
		private readonly object _lock = new object();

		private Dictionary<TKey, TValue> _store;

		private readonly Func<TKey, TValue> _creator;

		[Preserve]
		public ThreadSafeStore(Func<TKey, TValue> creator)
		{
			if (creator == null)
			{
				throw new ArgumentNullException("creator");
			}
			_creator = creator;
			_store = new Dictionary<TKey, TValue>();
		}

		[Preserve]
		public TValue Get(TKey key)
		{
			if (!_store.TryGetValue(key, out var value))
			{
				return AddValue(key);
			}
			return value;
		}

		[Preserve]
		private TValue AddValue(TKey key)
		{
			TValue val = _creator(key);
			lock (_lock)
			{
				if (_store == null)
				{
					_store = new Dictionary<TKey, TValue>();
					_store[key] = val;
				}
				else
				{
					if (_store.TryGetValue(key, out var value))
					{
						return value;
					}
					Dictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>(_store);
					dictionary[key] = val;
					_store = dictionary;
				}
				return val;
			}
		}
	}
	[Preserve]
	internal class BidirectionalDictionary<TFirst, TSecond>
	{
		private readonly IDictionary<TFirst, TSecond> _firstToSecond;

		private readonly IDictionary<TSecond, TFirst> _secondToFirst;

		private readonly string _duplicateFirstErrorMessage;

		private readonly string _duplicateSecondErrorMessage;

		public BidirectionalDictionary()
			: this((IEqualityComparer<TFirst>)EqualityComparer<TFirst>.Default, (IEqualityComparer<TSecond>)EqualityComparer<TSecond>.Default)
		{
		}

		public BidirectionalDictionary(IEqualityComparer<TFirst> firstEqualityComparer, IEqualityComparer<TSecond> secondEqualityComparer)
			: this(firstEqualityComparer, secondEqualityComparer, "Duplicate item already exists for '{0}'.", "Duplicate item already exists for '{0}'.")
		{
		}

		public BidirectionalDictionary(IEqualityComparer<TFirst> firstEqualityComparer, IEqualityComparer<TSecond> secondEqualityComparer, string duplicateFirstErrorMessage, string duplicateSecondErrorMessage)
		{
			_firstToSecond = new Dictionary<TFirst, TSecond>(firstEqualityComparer);
			_secondToFirst = new Dictionary<TSecond, TFirst>(secondEqualityComparer);
			_duplicateFirstErrorMessage = duplicateFirstErrorMessage;
			_duplicateSecondErrorMessage = duplicateSecondErrorMessage;
		}

		public void Set(TFirst first, TSecond second)
		{
			if (_firstToSecond.TryGetValue(first, out var value))
			{
				object obj = second;
				if (!value.Equals(obj))
				{
					throw new ArgumentException(_duplicateFirstErrorMessage.FormatWith(CultureInfo.InvariantCulture, first));
				}
			}
			if (_secondToFirst.TryGetValue(second, out var value2))
			{
				object obj2 = first;
				if (!value2.Equals(obj2))
				{
					throw new ArgumentException(_duplicateSecondErrorMessage.FormatWith(CultureInfo.InvariantCulture, second));
				}
			}
			_firstToSecond.Add(first, second);
			_secondToFirst.Add(second, first);
		}

		public bool TryGetByFirst(TFirst first, out TSecond second)
		{
			return _firstToSecond.TryGetValue(first, out second);
		}

		public bool TryGetBySecond(TSecond second, out TFirst first)
		{
			return _secondToFirst.TryGetValue(second, out first);
		}
	}
	[Preserve]
	internal enum PrimitiveTypeCode
	{
		Empty,
		Object,
		Char,
		CharNullable,
		Boolean,
		BooleanNullable,
		SByte,
		SByteNullable,
		Int16,
		Int16Nullable,
		UInt16,
		UInt16Nullable,
		Int32,
		Int32Nullable,
		Byte,
		ByteNullable,
		UInt32,
		UInt32Nullable,
		Int64,
		Int64Nullable,
		UInt64,
		UInt64Nullable,
		Single,
		SingleNullable,
		Double,
		DoubleNullable,
		DateTime,
		DateTimeNullable,
		DateTimeOffset,
		DateTimeOffsetNullable,
		Decimal,
		DecimalNullable,
		Guid,
		GuidNullable,
		TimeSpan,
		TimeSpanNullable,
		BigInteger,
		BigIntegerNullable,
		Uri,
		String,
		Bytes,
		DBNull
	}
	[Preserve]
	internal class TypeInformation
	{
		public Type Type { get; set; }

		public PrimitiveTypeCode TypeCode { get; set; }
	}
	[Preserve]
	internal enum ParseResult
	{
		None,
		Success,
		Overflow,
		Invalid
	}
	[Preserve]
	internal static class ConvertUtils
	{
		internal struct TypeConvertKey
		{
			private readonly Type _initialType;

			private readonly Type _targetType;

			public Type InitialType => _initialType;

			public Type TargetType => _targetType;

			public TypeConvertKey(Type initialType, Type targetType)
			{
				_initialType = initialType;
				_targetType = targetType;
			}

			public override int GetHashCode()
			{
				return _initialType.GetHashCode() ^ _targetType.GetHashCode();
			}

			public override bool Equals(object obj)
			{
				if (!(obj is TypeConvertKey))
				{
					return false;
				}
				return Equals((TypeConvertKey)obj);
			}

			public bool Equals(TypeConvertKey other)
			{
				if ((object)_initialType == other._initialType)
				{
					return (object)_targetType == other._targetType;
				}
				return false;
			}
		}

		internal enum ConvertResult
		{
			Success,
			CannotConvertNull,
			NotInstantiableType,
			NoValidConversion
		}

		private static readonly Dictionary<Type, PrimitiveTypeCode> TypeCodeMap = new Dictionary<Type, PrimitiveTypeCode>
		{
			{
				typeof(char),
				PrimitiveTypeCode.Char
			},
			{
				typeof(char?),
				PrimitiveTypeCode.CharNullable
			},
			{
				typeof(bool),
				PrimitiveTypeCode.Boolean
			},
			{
				typeof(bool?),
				PrimitiveTypeCode.BooleanNullable
			},
			{
				typeof(sbyte),
				PrimitiveTypeCode.SByte
			},
			{
				typeof(sbyte?),
				PrimitiveTypeCode.SByteNullable
			},
			{
				typeof(short),
				PrimitiveTypeCode.Int16
			},
			{
				typeof(short?),
				PrimitiveTypeCode.Int16Nullable
			},
			{
				typeof(ushort),
				PrimitiveTypeCode.UInt16
			},
			{
				typeof(ushort?),
				PrimitiveTypeCode.UInt16Nullable
			},
			{
				typeof(int),
				PrimitiveTypeCode.Int32
			},
			{
				typeof(int?),
				PrimitiveTypeCode.Int32Nullable
			},
			{
				typeof(byte),
				PrimitiveTypeCode.Byte
			},
			{
				typeof(byte?),
				PrimitiveTypeCode.ByteNullable
			},
			{
				typeof(uint),
				PrimitiveTypeCode.UInt32
			},
			{
				typeof(uint?),
				PrimitiveTypeCode.UInt32Nullable
			},
			{
				typeof(long),
				PrimitiveTypeCode.Int64
			},
			{
				typeof(long?),
				PrimitiveTypeCode.Int64Nullable
			},
			{
				typeof(ulong),
				PrimitiveTypeCode.UInt64
			},
			{
				typeof(ulong?),
				PrimitiveTypeCode.UInt64Nullable
			},
			{
				typeof(float),
				PrimitiveTypeCode.Single
			},
			{
				typeof(float?),
				PrimitiveTypeCode.SingleNullable
			},
			{
				typeof(double),
				PrimitiveTypeCode.Double
			},
			{
				typeof(double?),
				PrimitiveTypeCode.DoubleNullable
			},
			{
				typeof(DateTime),
				PrimitiveTypeCode.DateTime
			},
			{
				typeof(DateTime?),
				PrimitiveTypeCode.DateTimeNullable
			},
			{
				typeof(DateTimeOffset),
				PrimitiveTypeCode.DateTimeOffset
			},
			{
				typeof(DateTimeOffset?),
				PrimitiveTypeCode.DateTimeOffsetNullable
			},
			{
				typeof(decimal),
				PrimitiveTypeCode.Decimal
			},
			{
				typeof(decimal?),
				PrimitiveTypeCode.DecimalNullable
			},
			{
				typeof(Guid),
				PrimitiveTypeCode.Guid
			},
			{
				typeof(Guid?),
				PrimitiveTypeCode.GuidNullable
			},
			{
				typeof(TimeSpan),
				PrimitiveTypeCode.TimeSpan
			},
			{
				typeof(TimeSpan?),
				PrimitiveTypeCode.TimeSpanNullable
			},
			{
				typeof(Uri),
				PrimitiveTypeCode.Uri
			},
			{
				typeof(string),
				PrimitiveTypeCode.String
			},
			{
				typeof(byte[]),
				PrimitiveTypeCode.Bytes
			},
			{
				typeof(DBNull),
				PrimitiveTypeCode.DBNull
			}
		};

		private static readonly TypeInformation[] PrimitiveTypeCodes = new TypeInformation[19]
		{
			new TypeInformation
			{
				Type = typeof(object),
				TypeCode = PrimitiveTypeCode.Empty
			},
			new TypeInformation
			{
				Type = typeof(object),
				TypeCode = PrimitiveTypeCode.Object
			},
			new TypeInformation
			{
				Type = typeof(object),
				TypeCode = PrimitiveTypeCode.DBNull
			},
			new TypeInformation
			{
				Type = typeof(bool),
				TypeCode = PrimitiveTypeCode.Boolean
			},
			new TypeInformation
			{
				Type = typeof(char),
				TypeCode = PrimitiveTypeCode.Char
			},
			new TypeInformation
			{
				Type = typeof(sbyte),
				TypeCode = PrimitiveTypeCode.SByte
			},
			new TypeInformation
			{
				Type = typeof(byte),
				TypeCode = PrimitiveTypeCode.Byte
			},
			new TypeInformation
			{
				Type = typeof(short),
				TypeCode = PrimitiveTypeCode.Int16
			},
			new TypeInformation
			{
				Type = typeof(ushort),
				TypeCode = PrimitiveTypeCode.UInt16
			},
			new TypeInformation
			{
				Type = typeof(int),
				TypeCode = PrimitiveTypeCode.Int32
			},
			new TypeInformation
			{
				Type = typeof(uint),
				TypeCode = PrimitiveTypeCode.UInt32
			},
			new TypeInformation
			{
				Type = typeof(long),
				TypeCode = PrimitiveTypeCode.Int64
			},
			new TypeInformation
			{
				Type = typeof(ulong),
				TypeCode = PrimitiveTypeCode.UInt64
			},
			new TypeInformation
			{
				Type = typeof(float),
				TypeCode = PrimitiveTypeCode.Single
			},
			new TypeInformation
			{
				Type = typeof(double),
				TypeCode = PrimitiveTypeCode.Double
			},
			new TypeInformation
			{
				Type = typeof(decimal),
				TypeCode = PrimitiveTypeCode.Decimal
			},
			new TypeInformation
			{
				Type = typeof(DateTime),
				TypeCode = PrimitiveTypeCode.DateTime
			},
			new TypeInformation
			{
				Type = typeof(object),
				TypeCode = PrimitiveTypeCode.Empty
			},
			new TypeInformation
			{
				Type = typeof(string),
				TypeCode = PrimitiveTypeCode.String
			}
		};

		private static readonly ThreadSafeStore<TypeConvertKey, Func<object, object>> CastConverters = new ThreadSafeStore<TypeConvertKey, Func<object, object>>(CreateCastConverter);

		public static PrimitiveTypeCode GetTypeCode(Type t)
		{
			bool isEnum;
			return GetTypeCode(t, out isEnum);
		}

		public static PrimitiveTypeCode GetTypeCode(Type t, out bool isEnum)
		{
			if (TypeCodeMap.TryGetValue(t, out var value))
			{
				isEnum = false;
				return value;
			}
			if (t.IsEnum())
			{
				isEnum = true;
				return GetTypeCode(Enum.GetUnderlyingType(t));
			}
			if (ReflectionUtils.IsNullableType(t))
			{
				Type underlyingType = Nullable.GetUnderlyingType(t);
				if (underlyingType.IsEnum())
				{
					Type t2 = typeof(Nullable<>).MakeGenericType(Enum.GetUnderlyingType(underlyingType));
					isEnum = true;
					return GetTypeCode(t2);
				}
			}
			isEnum = false;
			return PrimitiveTypeCode.Object;
		}

		public static TypeInformation GetTypeInformation(IConvertible convertable)
		{
			return PrimitiveTypeCodes[(int)convertable.GetTypeCode()];
		}

		public static bool IsConvertible(Type t)
		{
			return typeof(IConvertible).IsAssignableFrom(t);
		}

		public static TimeSpan ParseTimeSpan(string input)
		{
			return TimeSpan.Parse(input);
		}

		private static Func<object, object> CreateCastConverter(TypeConvertKey t)
		{
			MethodInfo method = t.TargetType.GetMethod("op_Implicit", new Type[1] { t.InitialType });
			if ((object)method == null)
			{
				method = t.TargetType.GetMethod("op_Explicit", new Type[1] { t.InitialType });
			}
			if ((object)method == null)
			{
				return null;
			}
			MethodCall<object, object> call = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method);
			return (object o) => call(null, o);
		}

		public static object Convert(object initialValue, CultureInfo culture, Type targetType)
		{
			object value;
			return TryConvertInternal(initialValue, culture, targetType, out value) switch
			{
				ConvertResult.Success => value, 
				ConvertResult.CannotConvertNull => throw new Exception("Can not convert null {0} into non-nullable {1}.".FormatWith(CultureInfo.InvariantCulture, initialValue.GetType(), targetType)), 
				ConvertResult.NotInstantiableType => throw new ArgumentException("Target type {0} is not a value type or a non-abstract class.".FormatWith(CultureInfo.InvariantCulture, targetType), "targetType"), 
				ConvertResult.NoValidConversion => throw new InvalidOperationException("Can not convert from {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, initialValue.GetType(), targetType)), 
				_ => throw new InvalidOperationException("Unexpected conversion result."), 
			};
		}

		private static bool TryConvert(object initialValue, CultureInfo culture, Type targetType, out object value)
		{
			try
			{
				if (TryConvertInternal(initialValue, culture, targetType, out value) == ConvertResult.Success)
				{
					return true;
				}
				value = null;
				return false;
			}
			catch
			{
				value = null;
				return false;
			}
		}

		private static ConvertResult TryConvertInternal(object initialValue, CultureInfo culture, Type targetType, out object value)
		{
			if (initialValue == null)
			{
				throw new ArgumentNullException("initialValue");
			}
			if (ReflectionUtils.IsNullableType(targetType))
			{
				targetType = Nullable.GetUnderlyingType(targetType);
			}
			Type type = initialValue.GetType();
			if ((object)targetType == type)
			{
				value = initialValue;
				return ConvertResult.Success;
			}
			if (IsConvertible(initialValue.GetType()) && IsConvertible(targetType))
			{
				if (targetType.IsEnum())
				{
					if (initialValue is string)
					{
						value = Enum.Parse(targetType, initialValue.ToString(), ignoreCase: true);
						return ConvertResult.Success;
					}
					if (IsInteger(initialValue))
					{
						value = Enum.ToObject(targetType, initialValue);
						return ConvertResult.Success;
					}
				}
				value = System.Convert.ChangeType(initialValue, targetType, culture);
				return ConvertResult.Success;
			}
			if (initialValue is DateTime && (object)targetType == typeof(DateTimeOffset))
			{
				value = new DateTimeOffset((DateTime)initialValue);
				return ConvertResult.Success;
			}
			if (initialValue is byte[] && (object)targetType == typeof(Guid))
			{
				value = new Guid((byte[])initialValue);
				return ConvertResult.Success;
			}
			if (initialValue is Guid && (object)targetType == typeof(byte[]))
			{
				value = ((Guid)initialValue).ToByteArray();
				return ConvertResult.Success;
			}
			if (initialValue is string text)
			{
				if ((object)targetType == typeof(Guid))
				{
					value = new Guid(text);
					return ConvertResult.Success;
				}
				if ((object)targetType == typeof(Uri))
				{
					value = new Uri(text, UriKind.RelativeOrAbsolute);
					return ConvertResult.Success;
				}
				if ((object)targetType == typeof(TimeSpan))
				{
					value = ParseTimeSpan(text);
					return ConvertResult.Success;
				}
				if ((object)targetType == typeof(byte[]))
				{
					value = System.Convert.FromBase64String(text);
					return ConvertResult.Success;
				}
				if ((object)targetType == typeof(Version))
				{
					if (VersionTryParse(text, out var result))
					{
						value = result;
						return ConvertResult.Success;
					}
					value = null;
					return ConvertResult.NoValidConversion;
				}
				if (typeof(Type).IsAssignableFrom(targetType))
				{
					value = Type.GetType(text, throwOnError: true);
					return ConvertResult.Success;
				}
			}
			TypeConverter converter = GetConverter(type);
			if (converter != null && converter.CanConvertTo(targetType))
			{
				value = converter.ConvertTo(null, culture, initialValue, targetType);
				return ConvertResult.Success;
			}
			TypeConverter converter2 = GetConverter(targetType);
			if (converter2 != null && converter2.CanConvertFrom(type))
			{
				value = converter2.ConvertFrom(null, culture, initialValue);
				return ConvertResult.Success;
			}
			if (initialValue == DBNull.Value)
			{
				if (ReflectionUtils.IsNullable(targetType))
				{
					value = EnsureTypeAssignable(null, type, targetType);
					return ConvertResult.Success;
				}
				value = null;
				return ConvertResult.CannotConvertNull;
			}
			if (targetType.IsInterface() || targetType.IsGenericTypeDefinition() || targetType.IsAbstract())
			{
				value = null;
				return ConvertResult.NotInstantiableType;
			}
			value = null;
			return ConvertResult.NoValidConversion;
		}

		public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType)
		{
			if ((object)targetType == typeof(object))
			{
				return initialValue;
			}
			if (initialValue == null && ReflectionUtils.IsNullable(targetType))
			{
				return null;
			}
			if (TryConvert(initialValue, culture, targetType, out var value))
			{
				return value;
			}
			return EnsureTypeAssignable(initialValue, ReflectionUtils.GetObjectType(initialValue), targetType);
		}

		private static object EnsureTypeAssignable(object value, Type initialType, Type targetType)
		{
			Type type = value?.GetType();
			if (value != null)
			{
				if (targetType.IsAssignableFrom(type))
				{
					return value;
				}
				Func<object, object> func = CastConverters.Get(new TypeConvertKey(type, targetType));
				if (func != null)
				{
					return func(value);
				}
			}
			else if (ReflectionUtils.IsNullable(targetType))
			{
				return null;
			}
			throw new ArgumentException("Could not cast or convert from {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, ((object)initialType != null) ? initialType.ToString() : "{null}", targetType));
		}

		internal static TypeConverter GetConverter(Type t)
		{
			return JsonTypeReflector.GetTypeConverter(t);
		}

		public static bool VersionTryParse(string input, out Version result)
		{
			try
			{
				result = new Version(input);
				return true;
			}
			catch
			{
				result = null;
				return false;
			}
		}

		public static bool IsInteger(object value)
		{
			switch (GetTypeCode(value.GetType()))
			{
			case PrimitiveTypeCode.SByte:
			case PrimitiveTypeCode.Int16:
			case PrimitiveTypeCode.UInt16:
			case PrimitiveTypeCode.Int32:
			case PrimitiveTypeCode.Byte:
			case PrimitiveTypeCode.UInt32:
			case PrimitiveTypeCode.Int64:
			case PrimitiveTypeCode.UInt64:
				return true;
			default:
				return false;
			}
		}

		public static ParseResult Int32TryParse(char[] chars, int start, int length, out int value)
		{
			value = 0;
			if (length == 0)
			{
				return ParseResult.Invalid;
			}
			bool flag = chars[start] == '-';
			if (flag)
			{
				if (length == 1)
				{
					return ParseResult.Invalid;
				}
				start++;
				length--;
			}
			int num = start + length;
			if (length > 10 || (length == 10 && chars[start] - 48 > 2))
			{
				for (int i = start; i < num; i++)
				{
					int num2 = chars[i] - 48;
					if (num2 < 0 || num2 > 9)
					{
						return ParseResult.Invalid;
					}
				}
				return ParseResult.Overflow;
			}
			for (int j = start; j < num; j++)
			{
				int num3 = chars[j] - 48;
				if (num3 < 0 || num3 > 9)
				{
					return ParseResult.Invalid;
				}
				int num4 = 10 * value - num3;
				if (num4 > value)
				{
					for (j++; j < num; j++)
					{
						num3 = chars[j] - 48;
						if (num3 < 0 || num3 > 9)
						{
							return ParseResult.Invalid;
						}
					}
					return ParseResult.Overflow;
				}
				value = num4;
			}
			if (!flag)
			{
				if (value == int.MinValue)
				{
					return ParseResult.Overflow;
				}
				value = -value;
			}
			return ParseResult.Success;
		}

		public static ParseResult Int64TryParse(char[] chars, int start, int length, out long value)
		{
			value = 0L;
			if (length == 0)
			{
				return ParseResult.Invalid;
			}
			bool flag = chars[start] == '-';
			if (flag)
			{
				if (length == 1)
				{
					return ParseResult.Invalid;
				}
				start++;
				length--;
			}
			int num = start + length;
			if (length > 19)
			{
				for (int i = start; i < num; i++)
				{
					int num2 = chars[i] - 48;
					if (num2 < 0 || num2 > 9)
					{
						return ParseResult.Invalid;
					}
				}
				return ParseResult.Overflow;
			}
			for (int j = start; j < num; j++)
			{
				int num3 = chars[j] - 48;
				if (num3 < 0 || num3 > 9)
				{
					return ParseResult.Invalid;
				}
				long num4 = 10 * value - num3;
				if (num4 > value)
				{
					for (j++; j < num; j++)
					{
						num3 = chars[j] - 48;
						if (num3 < 0 || num3 > 9)
						{
							return ParseResult.Invalid;
						}
					}
					return ParseResult.Overflow;
				}
				value = num4;
			}
			if (!flag)
			{
				if (value == long.MinValue)
				{
					return ParseResult.Overflow;
				}
				value = -value;
			}
			return ParseResult.Success;
		}

		public static bool TryConvertGuid(string s, out Guid g)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (new Regex("^[A-Fa-f0-9]{8}-([A-Fa-f0-9]{4}-){3}[A-Fa-f0-9]{12}$").Match(s).Success)
			{
				g = new Guid(s);
				return true;
			}
			g = Guid.Empty;
			return false;
		}

		public static int HexTextToInt(char[] text, int start, int end)
		{
			int num = 0;
			for (int i = start; i < end; i++)
			{
				num += HexCharToInt(text[i]) << (end - 1 - i) * 4;
			}
			return num;
		}

		private static int HexCharToInt(char ch)
		{
			if (ch <= '9' && ch >= '0')
			{
				return ch - 48;
			}
			if (ch <= 'F' && ch >= 'A')
			{
				return ch - 55;
			}
			if (ch <= 'f' && ch >= 'a')
			{
				return ch - 87;
			}
			throw new FormatException("Invalid hex character: " + ch);
		}
	}
	[Preserve]
	internal interface IWrappedCollection : IList, ICollection, IEnumerable
	{
		object UnderlyingCollection { get; }
	}
	[Preserve]
	internal class CollectionWrapper<T> : ICollection<T>, IEnumerable<T>, IEnumerable, IWrappedCollection, IList, ICollection
	{
		private readonly IList _list;

		private readonly ICollection<T> _genericCollection;

		private object _syncRoot;

		public virtual int Count
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection.Count;
				}
				return _list.Count;
			}
		}

		public virtual bool IsReadOnly
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection.IsReadOnly;
				}
				return _list.IsReadOnly;
			}
		}

		bool IList.IsFixedSize
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection.IsReadOnly;
				}
				return _list.IsFixedSize;
			}
		}

		object IList.this[int index]
		{
			get
			{
				if (_genericCollection != null)
				{
					throw new InvalidOperationException("Wrapped ICollection<T> does not support indexer.");
				}
				return _list[index];
			}
			set
			{
				if (_genericCollection != null)
				{
					throw new InvalidOperationException("Wrapped ICollection<T> does not support indexer.");
				}
				VerifyValueType(value);
				_list[index] = (T)value;
			}
		}

		bool ICollection.IsSynchronized => false;

		object ICollection.SyncRoot
		{
			get
			{
				if (_syncRoot == null)
				{
					Interlocked.CompareExchange(ref _syncRoot, new object(), null);
				}
				return _syncRoot;
			}
		}

		public object UnderlyingCollection
		{
			get
			{
				if (_genericCollection != null)
				{
					return _genericCollection;
				}
				return _list;
			}
		}

		public CollectionWrapper(IList list)
		{
			ValidationUtils.ArgumentNotNull(list, "list");
			if (list is ICollection<T>)
			{
				_genericCollection = (ICollection<T>)list;
			}
			else
			{
				_list = list;
			}
		}

		public CollectionWrapper(ICollection<T> list)
		{
			ValidationUtils.ArgumentNotNull(list, "list");
			_genericCollection = list;
		}

		public virtual void Add(T item)
		{
			if (_genericCollection != null)
			{
				_genericCollection.Add(item);
			}
			else
			{
				_list.Add(item);
			}
		}

		public virtual void Clear()
		{
			if (_genericCollection != null)
			{
				_genericCollection.Clear();
			}
			else
			{
				_list.Clear();
			}
		}

		public virtual bool Contains(T item)
		{
			if (_genericCollection != null)
			{
				return _genericCollection.Contains(item);
			}
			return _list.Contains(item);
		}

		public virtual void CopyTo(T[] array, int arrayIndex)
		{
			if (_genericCollection != null)
			{
				_genericCollection.CopyTo(array, arrayIndex);
			}
			else
			{
				_list.CopyTo(array, arrayIndex);
			}
		}

		public virtual bool Remove(T item)
		{
			if (_genericCollection != null)
			{
				return _genericCollection.Remove(item);
			}
			bool num = _list.Contains(item);
			if (num)
			{
				_list.Remove(item);
			}
			return num;
		}

		public virtual IEnumerator<T> GetEnumerator()
		{
			if (_genericCollection != null)
			{
				return _genericCollection.GetEnumerator();
			}
			return _list.Cast<T>().GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			if (_genericCollection != null)
			{
				return _genericCollection.GetEnumerator();
			}
			return _list.GetEnumerator();
		}

		int IList.Add(object value)
		{
			VerifyValueType(value);
			Add((T)value);
			return Count - 1;
		}

		bool IList.Contains(object value)
		{
			if (IsCompatibleObject(value))
			{
				return Contains((T)value);
			}
			return false;
		}

		int IList.IndexOf(object value)
		{
			if (_genericCollection != null)
			{
				throw new InvalidOperationException("Wrapped ICollection<T> does not support IndexOf.");
			}
			if (IsCompatibleObject(value))
			{
				return _list.IndexOf((T)value);
			}
			return -1;
		}

		void IList.RemoveAt(int index)
		{
			if (_genericCollection != null)
			{
				throw new InvalidOperationException("Wrapped ICollection<T> does not support RemoveAt.");
			}
			_list.RemoveAt(index);
		}

		void IList.Insert(int index, object value)
		{
			if (_genericCollection != null)
			{
				throw new InvalidOperationException("Wrapped ICollection<T> does not support Insert.");
			}
			VerifyValueType(value);
			_list.Insert(index, (T)value);
		}

		void IList.Remove(object value)
		{
			if (IsCompatibleObject(value))
			{
				Remove((T)value);
			}
		}

		void ICollection.CopyTo(Array array, int arrayIndex)
		{
			CopyTo((T[])array, arrayIndex);
		}

		private static void VerifyValueType(object value)
		{
			if (!IsCompatibleObject(value))
			{
				throw new ArgumentException("The value '{0}' is not of type '{1}' and cannot be used in this generic collection.".FormatWith(CultureInfo.InvariantCulture, value, typeof(T)), "value");
			}
		}

		private static bool IsCompatibleObject(object value)
		{
			if (!(value is T) && (value != null || (typeof(T).IsValueType() && !ReflectionUtils.IsNullableType(typeof(T)))))
			{
				return false;
			}
			return true;
		}
	}
	[Preserve]
	internal static class DateTimeUtils
	{
		internal static readonly long InitialJavaScriptDateTicks;

		private const string IsoDateFormat = "yyyy-MM-ddTHH:mm:ss.FFFFFFFK";

		private const int DaysPer100Years = 36524;

		private const int DaysPer400Years = 146097;

		private const int DaysPer4Years = 1461;

		private const int DaysPerYear = 365;

		private const long TicksPerDay = 864000000000L;

		private static readonly int[] DaysToMonth365;

		private static readonly int[] DaysToMonth366;

		static DateTimeUtils()
		{
			InitialJavaScriptDateTicks = 621355968000000000L;
			DaysToMonth365 = new int[13]
			{
				0, 31, 59, 90, 120, 151, 181, 212, 243, 273,
				304, 334, 365
			};
			DaysToMonth366 = new int[13]
			{
				0, 31, 60, 91, 121, 152, 182, 213, 244, 274,
				305, 335, 366
			};
		}

		public static TimeSpan GetUtcOffset(this DateTime d)
		{
			return TimeZone.CurrentTimeZone.GetUtcOffset(d);
		}

		public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind)
		{
			return kind switch
			{
				DateTimeKind.Local => XmlDateTimeSerializationMode.Local, 
				DateTimeKind.Unspecified => XmlDateTimeSerializationMode.Unspecified, 
				DateTimeKind.Utc => XmlDateTimeSerializationMode.Utc, 
				_ => throw MiscellaneousUtils.CreateArgumentOutOfRangeException("kind", kind, "Unexpected DateTimeKind value."), 
			};
		}

		internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone)
		{
			switch (timeZone)
			{
			case DateTimeZoneHandling.Local:
				value = SwitchToLocalTime(value);
				break;
			case DateTimeZoneHandling.Utc:
				value = SwitchToUtcTime(value);
				break;
			case DateTimeZoneHandling.Unspecified:
				value = new DateTime(value.Ticks, DateTimeKind.Unspecified);
				break;
			default:
				throw new ArgumentException("Invalid date time handling value.");
			case DateTimeZoneHandling.RoundtripKind:
				break;
			}
			return value;
		}

		private static DateTime SwitchToLocalTime(DateTime value)
		{
			return value.Kind switch
			{
				DateTimeKind.Unspecified => new DateTime(value.Ticks, DateTimeKind.Local), 
				DateTimeKind.Utc => value.ToLocalTime(), 
				DateTimeKind.Local => value, 
				_ => value, 
			};
		}

		private static DateTime SwitchToUtcTime(DateTime value)
		{
			return value.Kind switch
			{
				DateTimeKind.Unspecified => new DateTime(value.Ticks, DateTimeKind.Utc), 
				DateTimeKind.Utc => value, 
				DateTimeKind.Local => value.ToUniversalTime(), 
				_ => value, 
			};
		}

		private static long ToUniversalTicks(DateTime dateTime)
		{
			if (dateTime.Kind == DateTimeKind.Utc)
			{
				return dateTime.Ticks;
			}
			return ToUniversalTicks(dateTime, dateTime.GetUtcOffset());
		}

		private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset)
		{
			if (dateTime.Kind == DateTimeKind.Utc || dateTime == DateTime.MaxValue || dateTime == DateTime.MinValue)
			{
				return dateTime.Ticks;
			}
			long num = dateTime.Ticks - offset.Ticks;
			if (num > 3155378975999999999L)
			{
				return 3155378975999999999L;
			}
			if (num < 0)
			{
				return 0L;
			}
			return num;
		}

		internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset)
		{
			return UniversialTicksToJavaScriptTicks(ToUniversalTicks(dateTime, offset));
		}

		internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime)
		{
			return ConvertDateTimeToJavaScriptTicks(dateTime, convertToUtc: true);
		}

		internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc)
		{
			return UniversialTicksToJavaScriptTicks(convertToUtc ? ToUniversalTicks(dateTime) : dateTime.Ticks);
		}

		private static long UniversialTicksToJavaScriptTicks(long universialTicks)
		{
			return (universialTicks - InitialJavaScriptDateTicks) / 10000;
		}

		internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks)
		{
			return new DateTime(javaScriptTicks * 10000 + InitialJavaScriptDateTicks, DateTimeKind.Utc);
		}

		internal static bool TryParseDateTimeIso(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, out DateTime dt)
		{
			DateTimeParser dateTimeParser = default(DateTimeParser);
			if (!dateTimeParser.Parse(text.Chars, text.StartIndex, text.Length))
			{
				dt = default(DateTime);
				return false;
			}
			DateTime dateTime = CreateDateTime(dateTimeParser);
			switch (dateTimeParser.Zone)
			{
			case ParserTimeZone.Utc:
				dateTime = new DateTime(dateTime.Ticks, DateTimeKind.Utc);
				break;
			case ParserTimeZone.LocalWestOfUtc:
			{
				TimeSpan timeSpan2 = new TimeSpan(dateTimeParser.ZoneHour, dateTimeParser.ZoneMinute, 0);
				long num = dateTime.Ticks + timeSpan2.Ticks;
				long num4 = num;
				DateTime minValue = DateTime.MaxValue;
				if (num4 <= minValue.Ticks)
				{
					dateTime = new DateTime(num, DateTimeKind.Utc).ToLocalTime();
					break;
				}
				num += dateTime.GetUtcOffset().Ticks;
				long num5 = num;
				minValue = DateTime.MaxValue;
				if (num5 > minValue.Ticks)
				{
					minValue = DateTime.MaxValue;
					num = minValue.Ticks;
				}
				dateTime = new DateTime(num, DateTimeKind.Local);
				break;
			}
			case ParserTimeZone.LocalEastOfUtc:
			{
				TimeSpan timeSpan = new TimeSpan(dateTimeParser.ZoneHour, dateTimeParser.ZoneMinute, 0);
				long num = dateTime.Ticks - timeSpan.Ticks;
				long num2 = num;
				DateTime minValue = DateTime.MinValue;
				if (num2 >= minValue.Ticks)
				{
					dateTime = new DateTime(num, DateTimeKind.Utc).ToLocalTime();
					break;
				}
				num += dateTime.GetUtcOffset().Ticks;
				long num3 = num;
				minValue = DateTime.MinValue;
				if (num3 < minValue.Ticks)
				{
					minValue = DateTime.MinValue;
					num = minValue.Ticks;
				}
				dateTime = new DateTime(num, DateTimeKind.Local);
				break;
			}
			}
			dt = EnsureDateTime(dateTime, dateTimeZoneHandling);
			return true;
		}

		internal static bool TryParseDateTimeOffsetIso(StringReference text, out DateTimeOffset dt)
		{
			DateTimeParser dateTimeParser = default(DateTimeParser);
			if (!dateTimeParser.Parse(text.Chars, text.StartIndex, text.Length))
			{
				dt = default(DateTimeOffset);
				return false;
			}
			DateTime dateTime = CreateDateTime(dateTimeParser);
			TimeSpan offset = dateTimeParser.Zone switch
			{
				ParserTimeZone.Utc => new TimeSpan(0L), 
				ParserTimeZone.LocalWestOfUtc => new TimeSpan(-dateTimeParser.ZoneHour, -dateTimeParser.ZoneMinute, 0), 
				ParserTimeZone.LocalEastOfUtc => new TimeSpan(dateTimeParser.ZoneHour, dateTimeParser.ZoneMinute, 0), 
				_ => TimeZoneInfo.Local.GetUtcOffset(dateTime), 
			};
			long num = dateTime.Ticks - offset.Ticks;
			if (num < 0 || num > 3155378975999999999L)
			{
				dt = default(DateTimeOffset);
				return false;
			}
			dt = new DateTimeOffset(dateTime, offset);
			return true;
		}

		private static DateTime CreateDateTime(DateTimeParser dateTimeParser)
		{
			bool flag;
			if (dateTimeParser.Hour == 24)
			{
				flag = true;
				dateTimeParser.Hour = 0;
			}
			else
			{
				flag = false;
			}
			DateTime result = new DateTime(dateTimeParser.Year, dateTimeParser.Month, dateTimeParser.Day, dateTimeParser.Hour, dateTimeParser.Minute, dateTimeParser.Second).AddTicks(dateTimeParser.Fraction);
			if (flag)
			{
				result = result.AddDays(1.0);
			}
			return result;
		}

		internal static bool TryParseDateTime(StringReference s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, out DateTime dt)
		{
			if (s.Length > 0)
			{
				int startIndex = s.StartIndex;
				if (s[startIndex] == '/')
				{
					if (s.Length >= 9 && s.StartsWith("/Date(") && s.EndsWith(")/") && TryParseDateTimeMicrosoft(s, dateTimeZoneHandling, out dt))
					{
						return true;
					}
				}
				else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[startIndex]) && s[startIndex + 10] == 'T' && TryParseDateTimeIso(s, dateTimeZoneHandling, out dt))
				{
					return true;
				}
				if (!string.IsNullOrEmpty(dateFormatString) && TryParseDateTimeExact(s.ToString(), dateTimeZoneHandling, dateFormatString, culture, out dt))
				{
					return true;
				}
			}
			dt = default(DateTime);
			return false;
		}

		internal static bool TryParseDateTime(string s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, out DateTime dt)
		{
			if (s.Length > 0)
			{
				if (s[0] == '/')
				{
					if (s.Length >= 9 && s.StartsWith("/Date(", StringComparison.Ordinal) && s.EndsWith(")/", StringComparison.Ordinal) && TryParseDateTimeMicrosoft(new StringReference(s.ToCharArray(), 0, s.Length), dateTimeZoneHandling, out dt))
					{
						return true;
					}
				}
				else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[0]) && s[10] == 'T' && DateTime.TryParseExact(s, "yyyy-MM-ddTHH:mm:ss.FFFFFFFK", CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind, out dt))
				{
					dt = EnsureDateTime(dt, dateTimeZoneHandling);
					return true;
				}
				if (!string.IsNullOrEmpty(dateFormatString) && TryParseDateTimeExact(s, dateTimeZoneHandling, dateFormatString, culture, out dt))
				{
					return true;
				}
			}
			dt = default(DateTime);
			return false;
		}

		internal static bool TryParseDateTimeOffset(StringReference s, string dateFormatString, CultureInfo culture, out DateTimeOffset dt)
		{
			if (s.Length > 0)
			{
				int startIndex = s.StartIndex;
				if (s[startIndex] == '/')
				{
					if (s.Length >= 9 && s.StartsWith("/Date(") && s.EndsWith(")/") && TryParseDateTimeOffsetMicrosoft(s, out dt))
					{
						return true;
					}
				}
				else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[startIndex]) && s[startIndex + 10] == 'T' && TryParseDateTimeOffsetIso(s, out dt))
				{
					return true;
				}
				if (!string.IsNullOrEmpty(dateFormatString) && TryParseDateTimeOffsetExact(s.ToString(), dateFormatString, culture, out dt))
				{
					return true;
				}
			}
			dt = default(DateTimeOffset);
			return false;
		}

		internal static bool TryParseDateTimeOffset(string s, string dateFormatString, CultureInfo culture, out DateTimeOffset dt)
		{
			if (s.Length > 0)
			{
				if (s[0] == '/')
				{
					if (s.Length >= 9 && s.StartsWith("/Date(", StringComparison.Ordinal) && s.EndsWith(")/", StringComparison.Ordinal) && TryParseDateTimeOffsetMicrosoft(new StringReference(s.ToCharArray(), 0, s.Length), out dt))
					{
						return true;
					}
				}
				else if (s.Length >= 19 && s.Length <= 40 && char.IsDigit(s[0]) && s[10] == 'T' && DateTimeOffset.TryParseExact(s, "yyyy-MM-ddTHH:mm:ss.FFFFFFFK", CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind, out dt) && TryParseDateTimeOffsetIso(new StringReference(s.ToCharArray(), 0, s.Length), out dt))
				{
					return true;
				}
				if (!string.IsNullOrEmpty(dateFormatString) && TryParseDateTimeOffsetExact(s, dateFormatString, culture, out dt))
				{
					return true;
				}
			}
			dt = default(DateTimeOffset);
			return false;
		}

		private static bool TryParseMicrosoftDate(StringReference text, out long ticks, out TimeSpan offset, out DateTimeKind kind)
		{
			kind = DateTimeKind.Utc;
			int num = text.IndexOf('+', 7, text.Length - 8);
			if (num == -1)
			{
				num = text.IndexOf('-', 7, text.Length - 8);
			}
			if (num != -1)
			{
				kind = DateTimeKind.Local;
				if (!TryReadOffset(text, num + text.StartIndex, out offset))
				{
					ticks = 0L;
					return false;
				}
			}
			else
			{
				offset = TimeSpan.Zero;
				num = text.Length - 2;
			}
			return ConvertUtils.Int64TryParse(text.Chars, 6 + text.StartIndex, num - 6, out ticks) == ParseResult.Success;
		}

		private static bool TryParseDateTimeMicrosoft(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, out DateTime dt)
		{
			if (!TryParseMicrosoftDate(text, out var ticks, out var _, out var kind))
			{
				dt = default(DateTime);
				return false;
			}
			DateTime dateTime = ConvertJavaScriptTicksToDateTime(ticks);
			switch (kind)
			{
			case DateTimeKind.Unspecified:
				dt = DateTime.SpecifyKind(dateTime.ToLocalTime(), DateTimeKind.Unspecified);
				break;
			case DateTimeKind.Local:
				dt = dateTime.ToLocalTime();
				break;
			default:
				dt = dateTime;
				break;
			}
			dt = EnsureDateTime(dt, dateTimeZoneHandling);
			return true;
		}

		private static bool TryParseDateTimeExact(string text, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, out DateTime dt)
		{
			if (DateTime.TryParseExact(text, dateFormatString, culture, DateTimeStyles.RoundtripKind, out var result))
			{
				result = EnsureDateTime(result, dateTimeZoneHandling);
				dt = result;
				return true;
			}
			dt = default(DateTime);
			return false;
		}

		private static bool TryParseDateTimeOffsetMicrosoft(StringReference text, out DateTimeOffset dt)
		{
			if (!TryParseMicrosoftDate(text, out var ticks, out var offset, out var _))
			{
				dt = default(DateTime);
				return false;
			}
			dt = new DateTimeOffset(ConvertJavaScriptTicksToDateTime(ticks).Add(offset).Ticks, offset);
			return true;
		}

		private static bool TryParseDateTimeOffsetExact(string text, string dateFormatString, CultureInfo culture, out DateTimeOffset dt)
		{
			if (DateTimeOffset.TryParseExact(text, dateFormatString, culture, DateTimeStyles.RoundtripKind, out var result))
			{
				dt = result;
				return true;
			}
			dt = default(DateTimeOffset);
			return false;
		}

		private static bool TryReadOffset(StringReference offsetText, int startIndex, out TimeSpan offset)
		{
			bool flag = offsetText[startIndex] == '-';
			if (ConvertUtils.Int32TryParse(offsetText.Chars, startIndex + 1, 2, out var value) != ParseResult.Success)
			{
				offset = default(TimeSpan);
				return false;
			}
			int value2 = 0;
			if (offsetText.Length - startIndex > 5 && ConvertUtils.Int32TryParse(offsetText.Chars, startIndex + 3, 2, out value2) != ParseResult.Success)
			{
				offset = default(TimeSpan);
				return false;
			}
			offset = TimeSpan.FromHours(value) + TimeSpan.FromMinutes(value2);
			if (flag)
			{
				offset = offset.Negate();
			}
			return true;
		}

		internal static void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string formatString, CultureInfo culture)
		{
			if (string.IsNullOrEmpty(formatString))
			{
				char[] array = new char[64];
				int count = WriteDateTimeString(array, 0, value, null, value.Kind, format);
				writer.Write(array, 0, count);
			}
			else
			{
				writer.Write(value.ToString(formatString, culture));
			}
		}

		internal static int WriteDateTimeString(char[] chars, int start, DateTime value, TimeSpan? offset, DateTimeKind kind, DateFormatHandling format)
		{
			int num = start;
			if (format == DateFormatHandling.MicrosoftDateFormat)
			{
				TimeSpan offset2 = offset ?? value.GetUtcOffset();
				long num2 = ConvertDateTimeToJavaScriptTicks(value, offset2);
				"\\/Date(".CopyTo(0, chars, num, 7);
				num += 7;
				string text = num2.ToString(CultureInfo.InvariantCulture);
				text.CopyTo(0, chars, num, text.Length);
				num += text.Length;
				switch (kind)
				{
				case DateTimeKind.Unspecified:
					if (value != DateTime.MaxValue && value != DateTime.MinValue)
					{
						num = WriteDateTimeOffset(chars, num, offset2, format);
					}
					break;
				case DateTimeKind.Local:
					num = WriteDateTimeOffset(chars, num, offset2, format);
					break;
				}
				")\\/".CopyTo(0, chars, num, 3);
				num += 3;
			}
			else
			{
				num = WriteDefaultIsoDate(chars, num, value);
				switch (kind)
				{
				case DateTimeKind.Local:
					num = WriteDateTimeOffset(chars, num, offset ?? value.GetUtcOffset(), format);
					break;
				case DateTimeKind.Utc:
					chars[num++] = 'Z';
					break;
				}
			}
			return num;
		}

		internal static int WriteDefaultIsoDate(char[] chars, int start, DateTime dt)
		{
			int num = 19;
			GetDateValues(dt, out var year, out var month, out var day);
			CopyIntToCharArray(chars, start, year, 4);
			chars[start + 4] = '-';
			CopyIntToCharArray(chars, start + 5, month, 2);
			chars[start + 7] = '-';
			CopyIntToCharArray(chars, start + 8, day, 2);
			chars[start + 10] = 'T';
			CopyIntToCharArray(chars, start + 11, dt.Hour, 2);
			chars[start + 13] = ':';
			CopyIntToCharArray(chars, start + 14, dt.Minute, 2);
			chars[start + 16] = ':';
			CopyIntToCharArray(chars, start + 17, dt.Second, 2);
			int num2 = (int)(dt.Ticks % 10000000);
			if (num2 != 0)
			{
				int num3 = 7;
				while (num2 % 10 == 0)
				{
					num3--;
					num2 /= 10;
				}
				chars[start + 19] = '.';
				CopyIntToCharArray(chars, start + 20, num2, num3);
				num += num3 + 1;
			}
			return start + num;
		}

		private static void CopyIntToCharArray(char[] chars, int start, int value, int digits)
		{
			while (digits-- != 0)
			{
				chars[start + digits] = (char)(value % 10 + 48);
				value /= 10;
			}
		}

		internal static int WriteDateTimeOffset(char[] chars, int start, TimeSpan offset, DateFormatHandling format)
		{
			chars[start++] = ((offset.Ticks >= 0) ? '+' : '-');
			int value = Math.Abs(offset.Hours);
			CopyIntToCharArray(chars, start, value, 2);
			start += 2;
			if (format == DateFormatHandling.IsoDateFormat)
			{
				chars[start++] = ':';
			}
			int value2 = Math.Abs(offset.Minutes);
			CopyIntToCharArray(chars, start, value2, 2);
			start += 2;
			return start;
		}

		internal static void WriteDateTimeOffsetString(TextWriter writer, DateTimeOffset value, DateFormatHandling format, string formatString, CultureInfo culture)
		{
			if (string.IsNullOrEmpty(formatString))
			{
				char[] array = new char[64];
				int count = WriteDateTimeString(array, 0, (format == DateFormatHandling.IsoDateFormat) ? value.DateTime : value.UtcDateTime, value.Offset, DateTimeKind.Local, format);
				writer.Write(array, 0, count);
			}
			else
			{
				writer.Write(value.ToString(formatString, culture));
			}
		}

		private static void GetDateValues(DateTime td, out int year, out int month, out int day)
		{
			int num = (int)(td.Ticks / 864000000000L);
			int num2 = num / 146097;
			num -= num2 * 146097;
			int num3 = num / 36524;
			if (num3 == 4)
			{
				num3 = 3;
			}
			num -= num3 * 36524;
			int num4 = num / 1461;
			num -= num4 * 1461;
			int num5 = num / 365;
			if (num5 == 4)
			{
				num5 = 3;
			}
			year = num2 * 400 + num3 * 100 + num4 * 4 + num5 + 1;
			num -= num5 * 365;
			int[] array = ((num5 == 3 && (num4 != 24 || num3 == 3)) ? DaysToMonth366 : DaysToMonth365);
			int i;
			for (i = num >> 6; num >= array[i]; i++)
			{
			}
			month = i;
			day = num - array[i - 1] + 1;
		}
	}
	[Preserve]
	internal interface IWrappedDictionary : IDictionary, ICollection, IEnumerable
	{
		object UnderlyingDictionary { get; }
	}
	[Preserve]
	internal class DictionaryWrapper<TKey, TValue> : IDictionary<TKey, TValue>, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable, IWrappedDictionary, IDictionary, ICollection
	{
		private struct DictionaryEnumerator<TEnumeratorKey, TEnumeratorValue> : IDictionaryEnumerator, IEnumerator
		{
			private readonly IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> _e;

			public DictionaryEntry Entry => (DictionaryEntry)Current;

			public object Key => Entry.Key;

			public object Value => Entry.Value;

			public object Current => new DictionaryEntry(_e.Current.Key, _e.Current.Value);

			public DictionaryEnumerator(IEnumerator<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> e)
			{
				ValidationUtils.ArgumentNotNull(e, "e");
				_e = e;
			}

			public bool MoveNext()
			{
				return _e.MoveNext();
			}

			public void Reset()
			{
				_e.Reset();
			}
		}

		private readonly IDictionary _dictionary;

		private readonly IDictionary<TKey, TValue> _genericDictionary;

		private object _syncRoot;

		public ICollection<TKey> Keys
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary.Keys.Cast<TKey>().ToList();
				}
				return _genericDictionary.Keys;
			}
		}

		public ICollection<TValue> Values
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary.Values.Cast<TValue>().ToList();
				}
				return _genericDictionary.Values;
			}
		}

		public TValue this[TKey key]
		{
			get
			{
				if (_dictionary != null)
				{
					return (TValue)_dictionary[key];
				}
				return _genericDictionary[key];
			}
			set
			{
				if (_dictionary != null)
				{
					_dictionary[key] = value;
				}
				else
				{
					_genericDictionary[key] = value;
				}
			}
		}

		public int Count
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary.Count;
				}
				return _genericDictionary.Count;
			}
		}

		public bool IsReadOnly
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary.IsReadOnly;
				}
				return _genericDictionary.IsReadOnly;
			}
		}

		object IDictionary.this[object key]
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary[key];
				}
				return _genericDictionary[(TKey)key];
			}
			set
			{
				if (_dictionary != null)
				{
					_dictionary[key] = value;
				}
				else
				{
					_genericDictionary[(TKey)key] = (TValue)value;
				}
			}
		}

		bool IDictionary.IsFixedSize
		{
			get
			{
				if (_genericDictionary != null)
				{
					return false;
				}
				return _dictionary.IsFixedSize;
			}
		}

		ICollection IDictionary.Keys
		{
			get
			{
				if (_genericDictionary != null)
				{
					return _genericDictionary.Keys.ToList();
				}
				return _dictionary.Keys;
			}
		}

		ICollection IDictionary.Values
		{
			get
			{
				if (_genericDictionary != null)
				{
					return _genericDictionary.Values.ToList();
				}
				return _dictionary.Values;
			}
		}

		bool ICollection.IsSynchronized
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary.IsSynchronized;
				}
				return false;
			}
		}

		object ICollection.SyncRoot
		{
			get
			{
				if (_syncRoot == null)
				{
					Interlocked.CompareExchange(ref _syncRoot, new object(), null);
				}
				return _syncRoot;
			}
		}

		public object UnderlyingDictionary
		{
			get
			{
				if (_dictionary != null)
				{
					return _dictionary;
				}
				return _genericDictionary;
			}
		}

		public DictionaryWrapper(IDictionary dictionary)
		{
			ValidationUtils.ArgumentNotNull(dictionary, "dictionary");
			_dictionary = dictionary;
		}

		public DictionaryWrapper(IDictionary<TKey, TValue> dictionary)
		{
			ValidationUtils.ArgumentNotNull(dictionary, "dictionary");
			_genericDictionary = dictionary;
		}

		public void Add(TKey key, TValue value)
		{
			if (_dictionary != null)
			{
				_dictionary.Add(key, value);
				return;
			}
			if (_genericDictionary != null)
			{
				_genericDictionary.Add(key, value);
				return;
			}
			throw new NotSupportedException();
		}

		public bool ContainsKey(TKey key)
		{
			if (_dictionary != null)
			{
				return _dictionary.Contains(key);
			}
			return _genericDictionary.ContainsKey(key);
		}

		public bool Remove(TKey key)
		{
			if (_dictionary != null)
			{
				if (_dictionary.Contains(key))
				{
					_dictionary.Remove(key);
					return true;
				}
				return false;
			}
			return _genericDictionary.Remove(key);
		}

		public bool TryGetValue(TKey key, out TValue value)
		{
			if (_dictionary != null)
			{
				if (!_dictionary.Contains(key))
				{
					value = default(TValue);
					return false;
				}
				value = (TValue)_dictionary[key];
				return true;
			}
			return _genericDictionary.TryGetValue(key, out value);
		}

		public void Add(KeyValuePair<TKey, TValue> item)
		{
			if (_dictionary != null)
			{
				((IList)_dictionary).Add(item);
			}
			else if (_genericDictionary != null)
			{
				_genericDictionary.Add(item);
			}
		}

		public void Clear()
		{
			if (_dictionary != null)
			{
				_dictionary.Clear();
			}
			else
			{
				_genericDictionary.Clear();
			}
		}

		public bool Contains(KeyValuePair<TKey, TValue> item)
		{
			if (_dictionary != null)
			{
				return ((IList)_dictionary).Contains(item);
			}
			return _genericDictionary.Contains(item);
		}

		public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
		{
			if (_dictionary != null)
			{
				foreach (DictionaryEntry item in _dictionary)
				{
					array[arrayIndex++] = new KeyValuePair<TKey, TValue>((TKey)item.Key, (TValue)item.Value);
				}
				return;
			}
			_genericDictionary.CopyTo(array, arrayIndex);
		}

		public bool Remove(KeyValuePair<TKey, TValue> item)
		{
			if (_dictionary != null)
			{
				if (_dictionary.Contains(item.Key))
				{
					if (object.Equals(_dictionary[item.Key], item.Value))
					{
						_dictionary.Remove(item.Key);
						return true;
					}
					return false;
				}
				return true;
			}
			return _genericDictionary.Remove(item);
		}

		public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
		{
			if (_dictionary != null)
			{
				return (from DictionaryEntry de in _dictionary
					select new KeyValuePair<TKey, TValue>((TKey)de.Key, (TValue)de.Value)).GetEnumerator();
			}
			return _genericDictionary.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		void IDictionary.Add(object key, object value)
		{
			if (_dictionary != null)
			{
				_dictionary.Add(key, value);
			}
			else
			{
				_genericDictionary.Add((TKey)key, (TValue)value);
			}
		}

		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			if (_dictionary != null)
			{
				return _dictionary.GetEnumerator();
			}
			return new DictionaryEnumerator<TKey, TValue>(_genericDictionary.GetEnumerator());
		}

		bool IDictionary.Contains(object key)
		{
			if (_genericDictionary != null)
			{
				return _genericDictionary.ContainsKey((TKey)key);
			}
			return _dictionary.Contains(key);
		}

		public void Remove(object key)
		{
			if (_dictionary != null)
			{
				_dictionary.Remove(key);
			}
			else
			{
				_genericDictionary.Remove((TKey)key);
			}
		}

		void ICollection.CopyTo(Array array, int index)
		{
			if (_dictionary != null)
			{
				_dictionary.CopyTo(array, index);
			}
			else
			{
				_genericDictionary.CopyTo((KeyValuePair<TKey, TValue>[])array, index);
			}
		}
	}
	[Preserve]
	internal static class EnumUtils
	{
		private static readonly ThreadSafeStore<Type, BidirectionalDictionary<string, string>> EnumMemberNamesPerType = new ThreadSafeStore<Type, BidirectionalDictionary<string, string>>(InitializeEnumType);

		private static BidirectionalDictionary<string, string> InitializeEnumType(Type type)
		{
			BidirectionalDictionary<string, string> bidirectionalDictionary = new BidirectionalDictionary<string, string>(StringComparer.OrdinalIgnoreCase, StringComparer.OrdinalIgnoreCase);
			FieldInfo[] fields = type.GetFields();
			foreach (FieldInfo fieldInfo in fields)
			{
				string name = fieldInfo.Name;
				string text = (from EnumMemberAttribute a in fieldInfo.GetCustomAttributes(typeof(EnumMemberAttribute), inherit: true)
					select a.Value).SingleOrDefault() ?? fieldInfo.Name;
				if (bidirectionalDictionary.TryGetBySecond(text, out var _))
				{
					throw new InvalidOperationException("Enum name '{0}' already exists on enum '{1}'.".FormatWith(CultureInfo.InvariantCulture, text, type.Name));
				}
				bidirectionalDictionary.Set(name, text);
			}
			return bidirectionalDictionary;
		}

		public static IList<T> GetFlagsValues<T>(T value) where T : struct
		{
			Type typeFromHandle = typeof(T);
			if (!typeFromHandle.IsDefined(typeof(FlagsAttribute), inherit: false))
			{
				throw new ArgumentException("Enum type {0} is not a set of flags.".FormatWith(CultureInfo.InvariantCulture, typeFromHandle));
			}
			Type underlyingType = Enum.GetUnderlyingType(value.GetType());
			ulong num = Convert.ToUInt64(value, CultureInfo.InvariantCulture);
			IList<EnumValue<ulong>> namesAndValues = GetNamesAndValues<T>();
			IList<T> list = new List<T>();
			foreach (EnumValue<ulong> item in namesAndValues)
			{
				if ((num & item.Value) == item.Value && item.Value != 0L)
				{
					list.Add((T)Convert.ChangeType(item.Value, underlyingType, CultureInfo.CurrentCulture));
				}
			}
			if (list.Count == 0 && namesAndValues.SingleOrDefault((EnumValue<ulong> v) => v.Value == 0) != null)
			{
				list.Add(default(T));
			}
			return list;
		}

		public static IList<EnumValue<ulong>> GetNamesAndValues<T>() where T : struct
		{
			return GetNamesAndValues<ulong>(typeof(T));
		}

		public static IList<EnumValue<TUnderlyingType>> GetNamesAndValues<TUnderlyingType>(Type enumType) where TUnderlyingType : struct
		{
			if ((object)enumType == null)
			{
				throw new ArgumentNullException("enumType");
			}
			if (!enumType.IsEnum())
			{
				throw new ArgumentException("Type {0} is not an Enum.".FormatWith(CultureInfo.InvariantCulture, enumType), "enumType");
			}
			IList<object> values = GetValues(enumType);
			IList<string> names = GetNames(enumType);
			IList<EnumValue<TUnderlyingType>> list = new List<EnumValue<TUnderlyingType>>();
			for (int i = 0; i < values.Count; i++)
			{
				try
				{
					list.Add(new EnumValue<TUnderlyingType>(names[i], (TUnderlyingType)Convert.ChangeType(values[i], typeof(TUnderlyingType), CultureInfo.CurrentCulture)));
				}
				catch (OverflowException innerException)
				{
					throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture, "Value from enum with the underlying type of {0} cannot be added to dictionary with a value type of {1}. Value was too large: {2}", new object[3]
					{
						Enum.GetUnderlyingType(enumType),
						typeof(TUnderlyingType),
						Convert.ToUInt64(values[i], CultureInfo.InvariantCulture)
					}), innerException);
				}
			}
			return list;
		}

		public static IList<object> GetValues(Type enumType)
		{
			if (!enumType.IsEnum())
			{
				throw new ArgumentException("Type '" + enumType.Name + "' is not an enum.");
			}
			List<object> list = new List<object>();
			foreach (FieldInfo item in from f in enumType.GetFields()
				where f.IsLiteral
				select f)
			{
				object value = item.GetValue(enumType);
				list.Add(value);
			}
			return list;
		}

		public static IList<string> GetNames(Type enumType)
		{
			if (!enumType.IsEnum())
			{
				throw new ArgumentException("Type '" + enumType.Name + "' is not an enum.");
			}
			List<string> list = new List<string>();
			foreach (FieldInfo item in from f in enumType.GetFields()
				where f.IsLiteral
				select f)
			{
				list.Add(item.Name);
			}
			return list;
		}

		public static object ParseEnumName(string enumText, bool isNullable, Type t)
		{
			if (enumText == string.Empty && isNullable)
			{
				return null;
			}
			BidirectionalDictionary<string, string> map = EnumMemberNamesPerType.Get(t);
			string value;
			if (enumText.IndexOf(',') != -1)
			{
				string[] array = enumText.Split(new char[1] { ',' });
				for (int i = 0; i < array.Length; i++)
				{
					string enumText2 = array[i].Trim();
					array[i] = ResolvedEnumName(map, enumText2);
				}
				value = string.Join(", ", array);
			}
			else
			{
				value = ResolvedEnumName(map, enumText);
			}
			return Enum.Parse(t, value, ignoreCase: true);
		}

		public static string ToEnumName(Type enumType, string enumText, bool camelCaseText)
		{
			BidirectionalDictionary<string, string> bidirectionalDictionary = EnumMemberNamesPerType.Get(enumType);
			string[] array = enumText.Split(new char[1] { ',' });
			for (int i = 0; i < array.Length; i++)
			{
				string text = array[i].Trim();
				bidirectionalDictionary.TryGetByFirst(text, out var second);
				second = second ?? text;
				if (camelCaseText)
				{
					second = StringUtils.ToCamelCase(second);
				}
				array[i] = second;
			}
			return string.Join(", ", array);
		}

		private static string ResolvedEnumName(BidirectionalDictionary<string, string> map, string enumText)
		{
			map.TryGetBySecond(enumText, out var first);
			return first ?? enumText;
		}
	}
	[Preserve]
	internal class EnumValue<T> where T : struct
	{
		private readonly string _name;

		private readonly T _value;

		public string Name => _name;

		public T Value => _value;

		public EnumValue(string name, T value)
		{
			_name = name;
			_value = value;
		}
	}
	[Preserve]
	internal static class BufferUtils
	{
		public static char[] RentBuffer(IArrayPool<char> bufferPool, int minSize)
		{
			if (bufferPool == null)
			{
				return new char[minSize];
			}
			return bufferPool.Rent(minSize);
		}

		public static void ReturnBuffer(IArrayPool<char> bufferPool, char[] buffer)
		{
			bufferPool?.Return(buffer);
		}

		public static char[] EnsureBufferSize(IArrayPool<char> bufferPool, int size, char[] buffer)
		{
			if (bufferPool == null)
			{
				return new char[size];
			}
			if (buffer != null)
			{
				bufferPool.Return(buffer);
			}
			return bufferPool.Rent(size);
		}
	}
	[Preserve]
	internal static class JavaScriptUtils
	{
		internal static readonly bool[] SingleQuoteCharEscapeFlags;

		internal static readonly bool[] DoubleQuoteCharEscapeFlags;

		internal static readonly bool[] HtmlCharEscapeFlags;

		private const int UnicodeTextLength = 6;

		private const string EscapedUnicodeText = "!";

		static JavaScriptUtils()
		{
			SingleQuoteCharEscapeFlags = new bool[128];
			DoubleQuoteCharEscapeFlags = new bool[128];
			HtmlCharEscapeFlags = new bool[128];
			IList<char> list = new List<char> { '\n', '\r', '\t', '\\', '\f', '\b' };
			for (int i = 0; i < 32; i++)
			{
				list.Add((char)i);
			}
			foreach (char item in list.Union(new char[1] { '\'' }))
			{
				SingleQuoteCharEscapeFlags[(uint)item] = true;
			}
			foreach (char item2 in list.Union(new char[1] { '"' }))
			{
				DoubleQuoteCharEscapeFlags[(uint)item2] = true;
			}
			foreach (char item3 in list.Union(new char[5] { '"', '\'', '<', '>', '&' }))
			{
				HtmlCharEscapeFlags[(uint)item3] = true;
			}
		}

		public static bool[] GetCharEscapeFlags(StringEscapeHandling stringEscapeHandling, char quoteChar)
		{
			if (stringEscapeHandling == StringEscapeHandling.EscapeHtml)
			{
				return HtmlCharEscapeFlags;
			}
			if (quoteChar == '"')
			{
				return DoubleQuoteCharEscapeFlags;
			}
			return SingleQuoteCharEscapeFlags;
		}

		public static bool ShouldEscapeJavaScriptString(string s, bool[] charEscapeFlags)
		{
			if (s == null)
			{
				return false;
			}
			foreach (char c in s)
			{
				if (c >= charEscapeFlags.Length || charEscapeFlags[(uint)c])
				{
					return true;
				}
			}
			return false;
		}

		public static void WriteEscapedJavaScriptString(TextWriter writer, string s, char delimiter, bool appendDelimiters, bool[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, IArrayPool<char> bufferPool, ref char[] writeBuffer)
		{
			if (appendDelimiters)
			{
				writer.Write(delimiter);
			}
			if (s != null)
			{
				int num = 0;
				for (int i = 0; i < s.Length; i++)
				{
					char c = s[i];
					if (c < charEscapeFlags.Length && !charEscapeFlags[(uint)c])
					{
						continue;
					}
					string text;
					switch (c)
					{
					case '\t':
						text = "\\t";
						break;
					case '\n':
						text = "\\n";
						break;
					case '\r':
						text = "\\r";
						break;
					case '\f':
						text = "\\f";
						break;
					case '\b':
						text = "\\b";
						break;
					case '\\':
						text = "\\\\";
						break;
					case '\u0085':
						text = "\\u0085";
						break;
					case '\u2028':
						text = "\\u2028";
						break;
					case '\u2029':
						text = "\\u2029";
						break;
					default:
						if (c < charEscapeFlags.Length || stringEscapeHandling == StringEscapeHandling.EscapeNonAscii)
						{
							if (c == '\'' && stringEscapeHandling != StringEscapeHandling.EscapeHtml)
							{
								text = "\\'";
								break;
							}
							if (c == '"' && stringEscapeHandling != StringEscapeHandling.EscapeHtml)
							{
								text = "\\\"";
								break;
							}
							if (writeBuffer == null || writeBuffer.Length < 6)
							{
								writeBuffer = BufferUtils.EnsureBufferSize(bufferPool, 6, writeBuffer);
							}
							StringUtils.ToCharAsUnicode(c, writeBuffer);
							text = "!";
						}
						else
						{
							text = null;
						}
						break;
					}
					if (text == null)
					{
						continue;
					}
					bool flag = string.Equals(text, "!");
					if (i > num)
					{
						int num2 = i - num + (flag ? 6 : 0);
						int num3 = (flag ? 6 : 0);
						if (writeBuffer == null || writeBuffer.Length < num2)
						{
							char[] array = BufferUtils.RentBuffer(bufferPool, num2);
							if (flag)
							{
								Array.Copy(writeBuffer, array, 6);
							}
							BufferUtils.ReturnBuffer(bufferPool, writeBuffer);
							writeBuffer = array;
						}
						s.CopyTo(num, writeBuffer, num3, num2 - num3);
						writer.Write(writeBuffer, num3, num2 - num3);
					}
					num = i + 1;
					if (!flag)
					{
						writer.Write(text);
					}
					else
					{
						writer.Write(writeBuffer, 0, 6);
					}
				}
				if (num == 0)
				{
					writer.Write(s);
				}
				else
				{
					int num4 = s.Length - num;
					if (writeBuffer == null || writeBuffer.Length < num4)
					{
						writeBuffer = BufferUtils.EnsureBufferSize(bufferPool, num4, writeBuffer);
					}
					s.CopyTo(num, writeBuffer, 0, num4);
					writer.Write(writeBuffer, 0, num4);
				}
			}
			if (appendDelimiters)
			{
				writer.Write(delimiter);
			}
		}

		public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters, StringEscapeHandling stringEscapeHandling)
		{
			bool[] charEscapeFlags = GetCharEscapeFlags(stringEscapeHandling, delimiter);
			using StringWriter stringWriter = StringUtils.CreateStringWriter(StringUtils.GetLength(value) ?? 16);
			char[] writeBuffer = null;
			WriteEscapedJavaScriptString(stringWriter, value, delimiter, appendDelimiters, charEscapeFlags, stringEscapeHandling, null, ref writeBuffer);
			return stringWriter.ToString();
		}
	}
	[Preserve]
	internal struct StringBuffer
	{
		private char[] _buffer;

		private int _position;

		public int Position
		{
			get
			{
				return _position;
			}
			set
			{
				_position = value;
			}
		}

		public bool IsEmpty => _buffer == null;

		public char[] InternalBuffer => _buffer;

		public StringBuffer(IArrayPool<char> bufferPool, int initalSize)
			: this(BufferUtils.RentBuffer(bufferPool, initalSize))
		{
		}

		private StringBuffer(char[] buffer)
		{
			_buffer = buffer;
			_position = 0;
		}

		public void Append(IArrayPool<char> bufferPool, char value)
		{
			if (_position == _buffer.Length)
			{
				EnsureSize(bufferPool, 1);
			}
			_buffer[_position++] = value;
		}

		public void Append(IArrayPool<char> bufferPool, char[] buffer, int startIndex, int count)
		{
			if (_position + count >= _buffer.Length)
			{
				EnsureSize(bufferPool, count);
			}
			Array.Copy(buffer, startIndex, _buffer, _position, count);
			_position += count;
		}

		public void Clear(IArrayPool<char> bufferPool)
		{
			if (_buffer != null)
			{
				BufferUtils.ReturnBuffer(bufferPool, _buffer);
				_buffer = null;
			}
			_position = 0;
		}

		private void EnsureSize(IArrayPool<char> bufferPool, int appendLength)
		{
			char[] array = BufferUtils.RentBuffer(bufferPool, (_position + appendLength) * 2);
			if (_buffer != null)
			{
				Array.Copy(_buffer, array, _position);
				BufferUtils.ReturnBuffer(bufferPool, _buffer);
			}
			_buffer = array;
		}

		public override string ToString()
		{
			return ToString(0, _position);
		}

		public string ToString(int start, int length)
		{
			return new string(_buffer, start, length);
		}
	}
	[Preserve]
	internal static class CollectionUtils
	{
		public static bool IsNullOrEmpty<T>(ICollection<T> collection)
		{
			if (collection != null)
			{
				return collection.Count == 0;
			}
			return true;
		}

		public static void AddRange<T>(this IList<T> initial, IEnumerable<T> collection)
		{
			if (initial == null)
			{
				throw new ArgumentNullException("initial");
			}
			if (collection == null)
			{
				return;
			}
			foreach (T item in collection)
			{
				initial.Add(item);
			}
		}

		public static void AddRange<T>(this IList<T> initial, IEnumerable collection)
		{
			ValidationUtils.ArgumentNotNull(initial, "initial");
			initial.AddRange(collection.Cast<T>());
		}

		public static bool IsDictionaryType(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (typeof(IDictionary).IsAssignableFrom(type))
			{
				return true;
			}
			if (ReflectionUtils.ImplementsGenericDefinition(type, typeof(IDictionary<, >)))
			{
				return true;
			}
			return false;
		}

		public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType)
		{
			Type constructorArgumentType = typeof(IList<>).MakeGenericType(collectionItemType);
			return ResolveEnumerableCollectionConstructor(collectionType, collectionItemType, constructorArgumentType);
		}

		public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType, Type constructorArgumentType)
		{
			Type type = typeof(IEnumerable<>).MakeGenericType(collectionItemType);
			ConstructorInfo constructorInfo = null;
			ConstructorInfo[] constructors = collectionType.GetConstructors(BindingFlags.Instance | BindingFlags.Public);
			foreach (ConstructorInfo constructorInfo2 in constructors)
			{
				IList<ParameterInfo> parameters = constructorInfo2.GetParameters();
				if (parameters.Count == 1)
				{
					Type parameterType = parameters[0].ParameterType;
					if ((object)type == parameterType)
					{
						constructorInfo = constructorInfo2;
						break;
					}
					if ((object)constructorInfo == null && parameterType.IsAssignableFrom(constructorArgumentType))
					{
						constructorInfo = constructorInfo2;
					}
				}
			}
			return constructorInfo;
		}

		public static bool AddDistinct<T>(this IList<T> list, T value)
		{
			return list.AddDistinct(value, EqualityComparer<T>.Default);
		}

		public static bool AddDistinct<T>(this IList<T> list, T value, IEqualityComparer<T> comparer)
		{
			if (list.ContainsValue(value, comparer))
			{
				return false;
			}
			list.Add(value);
			return true;
		}

		public static bool ContainsValue<TSource>(this IEnumerable<TSource> source, TSource value, IEqualityComparer<TSource> comparer)
		{
			if (comparer == null)
			{
				comparer = EqualityComparer<TSource>.Default;
			}
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			foreach (TSource item in source)
			{
				if (comparer.Equals(item, value))
				{
					return true;
				}
			}
			return false;
		}

		public static bool AddRangeDistinct<T>(this IList<T> list, IEnumerable<T> values, IEqualityComparer<T> comparer)
		{
			bool result = true;
			foreach (T value in values)
			{
				if (!list.AddDistinct(value, comparer))
				{
					result = false;
				}
			}
			return result;
		}

		public static int IndexOf<T>(this IEnumerable<T> collection, Func<T, bool> predicate)
		{
			int num = 0;
			foreach (T item in collection)
			{
				if (predicate(item))
				{
					return num;
				}
				num++;
			}
			return -1;
		}

		public static bool Contains<T>(this List<T> list, T value, IEqualityComparer comparer)
		{
			for (int i = 0; i < list.Count; i++)
			{
				if (comparer.Equals(value, list[i]))
				{
					return true;
				}
			}
			return false;
		}

		public static int IndexOfReference<T>(this List<T> list, T item)
		{
			for (int i = 0; i < list.Count; i++)
			{
				if ((object)item == (object)list[i])
				{
					return i;
				}
			}
			return -1;
		}

		private static IList<int> GetDimensions(IList values, int dimensionsCount)
		{
			IList<int> list = new List<int>();
			IList list2 = values;
			while (true)
			{
				list.Add(list2.Count);
				if (list.Count == dimensionsCount || list2.Count == 0)
				{
					break;
				}
				object obj = list2[0];
				if (!(obj is IList))
				{
					break;
				}
				list2 = (IList)obj;
			}
			return list;
		}

		private static void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, int[] indices)
		{
			int num = indices.Length;
			if (num == multidimensionalArray.Rank)
			{
				multidimensionalArray.SetValue(JaggedArrayGetValue(values, indices), indices);
				return;
			}
			int length = multidimensionalArray.GetLength(num);
			if (((IList)JaggedArrayGetValue(values, indices)).Count != length)
			{
				throw new Exception("Cannot deserialize non-cubical array as multidimensional array.");
			}
			int[] array = new int[num + 1];
			for (int i = 0; i < num; i++)
			{
				array[i] = indices[i];
			}
			for (int j = 0; j < multidimensionalArray.GetLength(num); j++)
			{
				array[num] = j;
				CopyFromJaggedToMultidimensionalArray(values, multidimensionalArray, array);
			}
		}

		private static object JaggedArrayGetValue(IList values, int[] indices)
		{
			IList list = values;
			for (int i = 0; i < indices.Length; i++)
			{
				int index = indices[i];
				if (i == indices.Length - 1)
				{
					return list[index];
				}
				list = (IList)list[index];
			}
			return list;
		}

		public static Array ToMultidimensionalArray(IList values, Type type, int rank)
		{
			IList<int> dimensions = GetDimensions(values, rank);
			while (dimensions.Count < rank)
			{
				dimensions.Add(0);
			}
			Array array = Array.CreateInstance(type, dimensions.ToArray());
			CopyFromJaggedToMultidimensionalArray(values, array, new int[0]);
			return array;
		}
	}
	[Preserve]
	internal static class MathUtils
	{
		public static int IntLength(ulong i)
		{
			if (i < 10000000000L)
			{
				if (i < 10)
				{
					return 1;
				}
				if (i < 100)
				{
					return 2;
				}
				if (i < 1000)
				{
					return 3;
				}
				if (i < 10000)
				{
					return 4;
				}
				if (i < 100000)
				{
					return 5;
				}
				if (i < 1000000)
				{
					return 6;
				}
				if (i < 10000000)
				{
					return 7;
				}
				if (i < 100000000)
				{
					return 8;
				}
				if (i < 1000000000)
				{
					return 9;
				}
				return 10;
			}
			if (i < 100000000000L)
			{
				return 11;
			}
			if (i < 1000000000000L)
			{
				return 12;
			}
			if (i < 10000000000000L)
			{
				return 13;
			}
			if (i < 100000000000000L)
			{
				return 14;
			}
			if (i < 1000000000000000L)
			{
				return 15;
			}
			if (i < 10000000000000000L)
			{
				return 16;
			}
			if (i < 100000000000000000L)
			{
				return 17;
			}
			if (i < 1000000000000000000L)
			{
				return 18;
			}
			if (i < 10000000000000000000uL)
			{
				return 19;
			}
			return 20;
		}

		public static char IntToHex(int n)
		{
			if (n <= 9)
			{
				return (char)(n + 48);
			}
			return (char)(n - 10 + 97);
		}

		public static int? Min(int? val1, int? val2)
		{
			if (!val1.HasValue)
			{
				return val2;
			}
			if (!val2.HasValue)
			{
				return val1;
			}
			return Math.Min(val1.GetValueOrDefault(), val2.GetValueOrDefault());
		}

		public static int? Max(int? val1, int? val2)
		{
			if (!val1.HasValue)
			{
				return val2;
			}
			if (!val2.HasValue)
			{
				return val1;
			}
			return Math.Max(val1.GetValueOrDefault(), val2.GetValueOrDefault());
		}

		public static double? Max(double? val1, double? val2)
		{
			if (!val1.HasValue)
			{
				return val2;
			}
			if (!val2.HasValue)
			{
				return val1;
			}
			return Math.Max(val1.GetValueOrDefault(), val2.GetValueOrDefault());
		}

		public static bool ApproxEquals(double d1, double d2)
		{
			if (d1 == d2)
			{
				return true;
			}
			double num = (Math.Abs(d1) + Math.Abs(d2) + 10.0) * 2.220446049250313E-16;
			double num2 = d1 - d2;
			if (0.0 - num < num2)
			{
				return num > num2;
			}
			return false;
		}
	}
	[Preserve]
	internal delegate T Creator<T>();
	[Preserve]
	internal static class MiscellaneousUtils
	{
		public static bool ValueEquals(object objA, object objB)
		{
			if (objA == null && objB == null)
			{
				return true;
			}
			if (objA != null && objB == null)
			{
				return false;
			}
			if (objA == null && objB != null)
			{
				return false;
			}
			if ((object)objA.GetType() != objB.GetType())
			{
				if (ConvertUtils.IsInteger(objA) && ConvertUtils.IsInteger(objB))
				{
					return Convert.ToDecimal(objA, CultureInfo.CurrentCulture).Equals(Convert.ToDecimal(objB, CultureInfo.CurrentCulture));
				}
				if ((objA is double || objA is float || objA is decimal) && (objB is double || objB is float || objB is decimal))
				{
					return MathUtils.ApproxEquals(Convert.ToDouble(objA, CultureInfo.CurrentCulture), Convert.ToDouble(objB, CultureInfo.CurrentCulture));
				}
				return false;
			}
			return objA.Equals(objB);
		}

		public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message)
		{
			string message2 = message + Environment.NewLine + "Actual value was {0}.".FormatWith(CultureInfo.InvariantCulture, actualValue);
			return new ArgumentOutOfRangeException(paramName, message2);
		}

		public static string ToString(object value)
		{
			if (value == null)
			{
				return "{null}";
			}
			if (!(value is string))
			{
				return value.ToString();
			}
			return "\"" + value.ToString() + "\"";
		}

		public static int ByteArrayCompare(byte[] a1, byte[] a2)
		{
			int num = a1.Length.CompareTo(a2.Length);
			if (num != 0)
			{
				return num;
			}
			for (int i = 0; i < a1.Length; i++)
			{
				int num2 = a1[i].CompareTo(a2[i]);
				if (num2 != 0)
				{
					return num2;
				}
			}
			return 0;
		}

		public static string GetPrefix(string qualifiedName)
		{
			GetQualifiedNameParts(qualifiedName, out var prefix, out var _);
			return prefix;
		}

		public static string GetLocalName(string qualifiedName)
		{
			GetQualifiedNameParts(qualifiedName, out var _, out var localName);
			return localName;
		}

		public static void GetQualifiedNameParts(string qualifiedName, out string prefix, out string localName)
		{
			int num = qualifiedName.IndexOf(':');
			if (num == -1 || num == 0 || qualifiedName.Length - 1 == num)
			{
				prefix = null;
				localName = qualifiedName;
			}
			else
			{
				prefix = qualifiedName.Substring(0, num);
				localName = qualifiedName.Substring(num + 1);
			}
		}

		internal static string FormatValueForPrint(object value)
		{
			if (value == null)
			{
				return "{null}";
			}
			if (value is string)
			{
				return string.Concat("\"", value, "\"");
			}
			return value.ToString();
		}
	}
	[Preserve]
	internal static class ReflectionUtils
	{
		public static readonly Type[] EmptyTypes;

		static ReflectionUtils()
		{
			EmptyTypes = Type.EmptyTypes;
		}

		public static bool IsVirtual(this PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			MethodInfo getMethod = propertyInfo.GetGetMethod();
			if ((object)getMethod != null && getMethod.IsVirtual)
			{
				return true;
			}
			getMethod = propertyInfo.GetSetMethod();
			if ((object)getMethod != null && getMethod.IsVirtual)
			{
				return true;
			}
			return false;
		}

		public static MethodInfo GetBaseDefinition(this PropertyInfo propertyInfo)
		{
			ValidationUtils.ArgumentNotNull(propertyInfo, "propertyInfo");
			MethodInfo getMethod = propertyInfo.GetGetMethod();
			if ((object)getMethod != null)
			{
				return getMethod.GetBaseDefinition();
			}
			return propertyInfo.GetSetMethod()?.GetBaseDefinition();
		}

		public static bool IsPublic(PropertyInfo property)
		{
			if ((object)property.GetGetMethod() != null && property.GetGetMethod().IsPublic)
			{
				return true;
			}
			if ((object)property.GetSetMethod() != null && property.GetSetMethod().IsPublic)
			{
				return true;
			}
			return false;
		}

		public static Type GetObjectType(object v)
		{
			return v?.GetType();
		}

		public static string GetTypeName(Type t, FormatterAssemblyStyle assemblyFormat, SerializationBinder binder)
		{
			string assemblyQualifiedName = t.AssemblyQualifiedName;
			return assemblyFormat switch
			{
				FormatterAssemblyStyle.Simple => RemoveAssemblyDetails(assemblyQualifiedName), 
				FormatterAssemblyStyle.Full => assemblyQualifiedName, 
				_ => throw new ArgumentOutOfRangeException(), 
			};
		}

		private static string RemoveAssemblyDetails(string fullyQualifiedTypeName)
		{
			StringBuilder stringBuilder = new StringBuilder();
			bool flag = false;
			bool flag2 = false;
			foreach (char c in fullyQualifiedTypeName)
			{
				switch (c)
				{
				case '[':
					flag = false;
					flag2 = false;
					stringBuilder.Append(c);
					break;
				case ']':
					flag = false;
					flag2 = false;
					stringBuilder.Append(c);
					break;
				case ',':
					if (!flag)
					{
						flag = true;
						stringBuilder.Append(c);
					}
					else
					{
						flag2 = true;
					}
					break;
				default:
					if (!flag2)
					{
						stringBuilder.Append(c);
					}
					break;
				}
			}
			return stringBuilder.ToString();
		}

		public static bool HasDefaultConstructor(Type t, bool nonPublic)
		{
			ValidationUtils.ArgumentNotNull(t, "t");
			if (t.IsValueType())
			{
				return true;
			}
			return (object)GetDefaultConstructor(t, nonPublic) != null;
		}

		public static ConstructorInfo GetDefaultConstructor(Type t)
		{
			return GetDefaultConstructor(t, nonPublic: false);
		}

		public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic)
		{
			BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public;
			if (nonPublic)
			{
				bindingFlags |= BindingFlags.NonPublic;
			}
			return t.GetConstructors(bindingFlags).SingleOrDefault((ConstructorInfo c) => !c.GetParameters().Any());
		}

		public static bool IsNullable(Type t)
		{
			ValidationUtils.ArgumentNotNull(t, "t");
			if (t.IsValueType())
			{
				return IsNullableType(t);
			}
			return true;
		}

		public static bool IsNullableType(Type t)
		{
			ValidationUtils.ArgumentNotNull(t, "t");
			if (t.IsGenericType())
			{
				return (object)t.GetGenericTypeDefinition() == typeof(Nullable<>);
			}
			return false;
		}

		public static Type EnsureNotNullableType(Type t)
		{
			if (!IsNullableType(t))
			{
				return t;
			}
			return Nullable.GetUnderlyingType(t);
		}

		public static bool IsGenericDefinition(Type type, Type genericInterfaceDefinition)
		{
			if (!type.IsGenericType())
			{
				return false;
			}
			return (object)type.GetGenericTypeDefinition() == genericInterfaceDefinition;
		}

		public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition)
		{
			Type implementingType;
			return ImplementsGenericDefinition(type, genericInterfaceDefinition, out implementingType);
		}

		public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, out Type implementingType)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			ValidationUtils.ArgumentNotNull(genericInterfaceDefinition, "genericInterfaceDefinition");
			if (!genericInterfaceDefinition.IsInterface() || !genericInterfaceDefinition.IsGenericTypeDefinition())
			{
				throw new ArgumentNullException("'{0}' is not a generic interface definition.".FormatWith(CultureInfo.InvariantCulture, genericInterfaceDefinition));
			}
			if (type.IsInterface() && type.IsGenericType())
			{
				Type genericTypeDefinition = type.GetGenericTypeDefinition();
				if ((object)genericInterfaceDefinition == genericTypeDefinition)
				{
					implementingType = type;
					return true;
				}
			}
			Type[] interfaces = type.GetInterfaces();
			foreach (Type type2 in interfaces)
			{
				if (type2.IsGenericType())
				{
					Type genericTypeDefinition2 = type2.GetGenericTypeDefinition();
					if ((object)genericInterfaceDefinition == genericTypeDefinition2)
					{
						implementingType = type2;
						return true;
					}
				}
			}
			implementingType = null;
			return false;
		}

		public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition)
		{
			Type implementingType;
			return InheritsGenericDefinition(type, genericClassDefinition, out implementingType);
		}

		public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, out Type implementingType)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			ValidationUtils.ArgumentNotNull(genericClassDefinition, "genericClassDefinition");
			if (!genericClassDefinition.IsClass() || !genericClassDefinition.IsGenericTypeDefinition())
			{
				throw new ArgumentNullException("'{0}' is not a generic class definition.".FormatWith(CultureInfo.InvariantCulture, genericClassDefinition));
			}
			return InheritsGenericDefinitionInternal(type, genericClassDefinition, out implementingType);
		}

		private static bool InheritsGenericDefinitionInternal(Type currentType, Type genericClassDefinition, out Type implementingType)
		{
			if (currentType.IsGenericType())
			{
				Type genericTypeDefinition = currentType.GetGenericTypeDefinition();
				if ((object)genericClassDefinition == genericTypeDefinition)
				{
					implementingType = currentType;
					return true;
				}
			}
			if ((object)currentType.BaseType() == null)
			{
				implementingType = null;
				return false;
			}
			return InheritsGenericDefinitionInternal(currentType.BaseType(), genericClassDefinition, out implementingType);
		}

		public static Type GetCollectionItemType(Type type)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			if (type.IsArray)
			{
				return type.GetElementType();
			}
			if (ImplementsGenericDefinition(type, typeof(IEnumerable<>), out var implementingType))
			{
				if (implementingType.IsGenericTypeDefinition())
				{
					throw new Exception("Type {0} is not a collection.".FormatWith(CultureInfo.InvariantCulture, type));
				}
				return implementingType.GetGenericArguments()[0];
			}
			if (typeof(IEnumerable).IsAssignableFrom(type))
			{
				return null;
			}
			throw new Exception("Type {0} is not a collection.".FormatWith(CultureInfo.InvariantCulture, type));
		}

		public static void GetDictionaryKeyValueTypes(Type dictionaryType, out Type keyType, out Type valueType)
		{
			ValidationUtils.ArgumentNotNull(dictionaryType, "dictionaryType");
			if (ImplementsGenericDefinition(dictionaryType, typeof(IDictionary<, >), out var implementingType))
			{
				if (implementingType.IsGenericTypeDefinition())
				{
					throw new Exception("Type {0} is not a dictionary.".FormatWith(CultureInfo.InvariantCulture, dictionaryType));
				}
				Type[] genericArguments = implementingType.GetGenericArguments();
				keyType = genericArguments[0];
				valueType = genericArguments[1];
			}
			else
			{
				if (!typeof(IDictionary).IsAssignableFrom(dictionaryType))
				{
					throw new Exception("Type {0} is not a dictionary.".FormatWith(CultureInfo.InvariantCulture, dictionaryType));
				}
				keyType = null;
				valueType = null;
			}
		}

		public static Type GetMemberUnderlyingType(MemberInfo member)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			return member.MemberType() switch
			{
				MemberTypes.Field => ((FieldInfo)member).FieldType, 
				MemberTypes.Property => ((PropertyInfo)member).PropertyType, 
				MemberTypes.Event => ((EventInfo)member).EventHandlerType, 
				MemberTypes.Method => ((MethodInfo)member).ReturnType, 
				_ => throw new ArgumentException("MemberInfo must be of type FieldInfo, PropertyInfo, EventInfo or MethodInfo", "member"), 
			};
		}

		public static bool IsIndexedProperty(MemberInfo member)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			if (member is PropertyInfo property)
			{
				return IsIndexedProperty(property);
			}
			return false;
		}

		public static bool IsIndexedProperty(PropertyInfo property)
		{
			ValidationUtils.ArgumentNotNull(property, "property");
			return property.GetIndexParameters().Length != 0;
		}

		public static object GetMemberValue(MemberInfo member, object target)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			ValidationUtils.ArgumentNotNull(target, "target");
			switch (member.MemberType())
			{
			case MemberTypes.Field:
				return ((FieldInfo)member).GetValue(target);
			case MemberTypes.Property:
				try
				{
					return ((PropertyInfo)member).GetValue(target, null);
				}
				catch (TargetParameterCountException innerException)
				{
					throw new ArgumentException("MemberInfo '{0}' has index parameters".FormatWith(CultureInfo.InvariantCulture, member.Name), innerException);
				}
			default:
				throw new ArgumentException("MemberInfo '{0}' is not of type FieldInfo or PropertyInfo".FormatWith(CultureInfo.InvariantCulture, CultureInfo.InvariantCulture, member.Name), "member");
			}
		}

		public static void SetMemberValue(MemberInfo member, object target, object value)
		{
			ValidationUtils.ArgumentNotNull(member, "member");
			ValidationUtils.ArgumentNotNull(target, "target");
			switch (member.MemberType())
			{
			case MemberTypes.Field:
				((FieldInfo)member).SetValue(target, value);
				break;
			case MemberTypes.Property:
				((PropertyInfo)member).SetValue(target, value, null);
				break;
			default:
				throw new ArgumentException("MemberInfo '{0}' must be of type FieldInfo or PropertyInfo".FormatWith(CultureInfo.InvariantCulture, member.Name), "member");
			}
		}

		public static bool CanReadMemberValue(MemberInfo member, bool nonPublic)
		{
			switch (member.MemberType())
			{
			case MemberTypes.Field:
			{
				FieldInfo fieldInfo = (FieldInfo)member;
				if (nonPublic)
				{
					return true;
				}
				if (fieldInfo.IsPublic)
				{
					return true;
				}
				return false;
			}
			case MemberTypes.Property:
			{
				PropertyInfo propertyInfo = (PropertyInfo)member;
				if (!propertyInfo.CanRead)
				{
					return false;
				}
				if (nonPublic)
				{
					return true;
				}
				return (object)propertyInfo.GetGetMethod(nonPublic) != null;
			}
			default:
				return false;
			}
		}

		public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly)
		{
			switch (member.MemberType())
			{
			case MemberTypes.Field:
			{
				FieldInfo fieldInfo = (FieldInfo)member;
				if (fieldInfo.IsLiteral)
				{
					return false;
				}
				if (fieldInfo.IsInitOnly && !canSetReadOnly)
				{
					return false;
				}
				if (nonPublic)
				{
					return true;
				}
				if (fieldInfo.IsPublic)
				{
					return true;
				}
				return false;
			}
			case MemberTypes.Property:
			{
				PropertyInfo propertyInfo = (PropertyInfo)member;
				if (!propertyInfo.CanWrite)
				{
					return false;
				}
				if (nonPublic)
				{
					return true;
				}
				return (object)propertyInfo.GetSetMethod(nonPublic) != null;
			}
			default:
				return false;
			}
		}

		public static List<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr)
		{
			List<MemberInfo> list = new List<MemberInfo>();
			((IList<MemberInfo>)list).AddRange((IEnumerable)GetFields(type, bindingAttr));
			((IList<MemberInfo>)list).AddRange((IEnumerable)GetProperties(type, bindingAttr));
			List<MemberInfo> list2 = new List<MemberInfo>(list.Count);
			foreach (IGrouping<string, MemberInfo> item in from m in list
				group m by m.Name)
			{
				int num = item.Count();
				IList<MemberInfo> list3 = item.ToList();
				if (num == 1)
				{
					list2.Add(list3.First());
					continue;
				}
				IList<MemberInfo> list4 = new List<MemberInfo>();
				foreach (MemberInfo item2 in list3)
				{
					if (list4.Count == 0)
					{
						list4.Add(item2);
					}
					else if (!IsOverridenGenericMember(item2, bindingAttr) || item2.Name == "Item")
					{
						list4.Add(item2);
					}
				}
				list2.AddRange(list4);
			}
			return list2;
		}

		private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr)
		{
			if (memberInfo.MemberType() != MemberTypes.Property)
			{
				return false;
			}
			PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
			if (!propertyInfo.IsVirtual())
			{
				return false;
			}
			Type declaringType = propertyInfo.DeclaringType;
			if (!declaringType.IsGenericType())
			{
				return false;
			}
			Type genericTypeDefinition = declaringType.GetGenericTypeDefinition();
			if ((object)genericTypeDefinition == null)
			{
				return false;
			}
			MemberInfo[] member = genericTypeDefinition.GetMember(propertyInfo.Name, bindingAttr);
			if (member.Length == 0)
			{
				return false;
			}
			if (!GetMemberUnderlyingType(member[0]).IsGenericParameter)
			{
				return false;
			}
			return true;
		}

		public static T GetAttribute<T>(object attributeProvider) where T : Attribute
		{
			return GetAttribute<T>(attributeProvider, inherit: true);
		}

		public static T GetAttribute<T>(object attributeProvider, bool inherit) where T : Attribute
		{
			T[] attributes = GetAttributes<T>(attributeProvider, inherit);
			if (attributes == null)
			{
				return null;
			}
			return attributes.FirstOrDefault();
		}

		public static T[] GetAttributes<T>(object attributeProvider, bool inherit) where T : Attribute
		{
			Attribute[] attributes = GetAttributes(attributeProvider, typeof(T), inherit);
			if (attributes is T[] result)
			{
				return result;
			}
			return attributes.Cast<T>().ToArray();
		}

		public static Attribute[] GetAttributes(object attributeProvider, Type attributeType, bool inherit)
		{
			ValidationUtils.ArgumentNotNull(attributeProvider, "attributeProvider");
			if (attributeProvider is Type)
			{
				Type type = (Type)attributeProvider;
				Attribute[] array = (((object)attributeType != null) ? type.GetCustomAttributes(attributeType, inherit) : type.GetCustomAttributes(inherit)).Cast<Attribute>().ToArray();
				if (inherit && (object)type.BaseType != null)
				{
					array = array.Union(GetAttributes(type.BaseType, attributeType, inherit)).ToArray();
				}
				return array;
			}
			if (attributeProvider is Assembly)
			{
				Assembly element = (Assembly)attributeProvider;
				if ((object)attributeType == null)
				{
					return Attribute.GetCustomAttributes(element);
				}
				return Attribute.GetCustomAttributes(element, attributeType);
			}
			if (attributeProvider is MemberInfo)
			{
				MemberInfo element2 = (MemberInfo)attributeProvider;
				if ((object)attributeType == null)
				{
					return Attribute.GetCustomAttributes(element2, inherit);
				}
				return Attribute.GetCustomAttributes(element2, attributeType, inherit);
			}
			if (attributeProvider is Module)
			{
				Module element3 = (Module)attributeProvider;
				if ((object)attributeType == null)
				{
					return Attribute.GetCustomAttributes(element3, inherit);
				}
				return Attribute.GetCustomAttributes(element3, attributeType, inherit);
			}
			if (attributeProvider is ParameterInfo)
			{
				ParameterInfo element4 = (ParameterInfo)attributeProvider;
				if ((object)attributeType == null)
				{
					return Attribute.GetCustomAttributes(element4, inherit);
				}
				return Attribute.GetCustomAttributes(element4, attributeType, inherit);
			}
			System.Reflection.ICustomAttributeProvider customAttributeProvider = (System.Reflection.ICustomAttributeProvider)attributeProvider;
			return (Attribute[])(((object)attributeType != null) ? customAttributeProvider.GetCustomAttributes(attributeType, inherit) : customAttributeProvider.GetCustomAttributes(inherit));
		}

		public static void SplitFullyQualifiedTypeName(string fullyQualifiedTypeName, out string typeName, out string assemblyName)
		{
			int? assemblyDelimiterIndex = GetAssemblyDelimiterIndex(fullyQualifiedTypeName);
			if (assemblyDelimiterIndex.HasValue)
			{
				typeName = fullyQualifiedTypeName.Substring(0, assemblyDelimiterIndex.GetValueOrDefault()).Trim();
				assemblyName = fullyQualifiedTypeName.Substring(assemblyDelimiterIndex.GetValueOrDefault() + 1, fullyQualifiedTypeName.Length - assemblyDelimiterIndex.GetValueOrDefault() - 1).Trim();
			}
			else
			{
				typeName = fullyQualifiedTypeName;
				assemblyName = null;
			}
		}

		private static int? GetAssemblyDelimiterIndex(string fullyQualifiedTypeName)
		{
			int num = 0;
			for (int i = 0; i < fullyQualifiedTypeName.Length; i++)
			{
				switch (fullyQualifiedTypeName[i])
				{
				case '[':
					num++;
					break;
				case ']':
					num--;
					break;
				case ',':
					if (num == 0)
					{
						return i;
					}
					break;
				}
			}
			return null;
		}

		public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo)
		{
			MemberTypes memberTypes = memberInfo.MemberType();
			if (memberTypes == MemberTypes.Property)
			{
				PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
				Type[] types = (from p in propertyInfo.GetIndexParameters()
					select p.ParameterType).ToArray();
				return targetType.GetProperty(propertyInfo.Name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, propertyInfo.PropertyType, types, null);
			}
			return targetType.GetMember(memberInfo.Name, memberInfo.MemberType(), BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic).SingleOrDefault();
		}

		public static IEnumerable<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr)
		{
			ValidationUtils.ArgumentNotNull(targetType, "targetType");
			List<MemberInfo> list = new List<MemberInfo>(targetType.GetFields(bindingAttr));
			GetChildPrivateFields(list, targetType, bindingAttr);
			return list.Cast<FieldInfo>();
		}

		private static void GetChildPrivateFields(IList<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr)
		{
			if ((bindingAttr & BindingFlags.NonPublic) == 0)
			{
				return;
			}
			BindingFlags bindingAttr2 = bindingAttr.RemoveFlag(BindingFlags.Public);
			while ((object)(targetType = targetType.BaseType()) != null)
			{
				IEnumerable<MemberInfo> collection = (from f in targetType.GetFields(bindingAttr2)
					where f.IsPrivate
					select f).Cast<MemberInfo>();
				initialFields.AddRange(collection);
			}
		}

		public static IEnumerable<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr)
		{
			ValidationUtils.ArgumentNotNull(targetType, "targetType");
			List<PropertyInfo> list = new List<PropertyInfo>(targetType.GetProperties(bindingAttr));
			if (targetType.IsInterface())
			{
				Type[] interfaces = targetType.GetInterfaces();
				foreach (Type type in interfaces)
				{
					list.AddRange(type.GetProperties(bindingAttr));
				}
			}
			GetChildPrivateProperties(list, targetType, bindingAttr);
			for (int j = 0; j < list.Count; j++)
			{
				PropertyInfo propertyInfo = list[j];
				if ((object)propertyInfo.DeclaringType != targetType)
				{
					PropertyInfo value = (PropertyInfo)GetMemberInfoFromType(propertyInfo.DeclaringType, propertyInfo);
					list[j] = value;
				}
			}
			return list;
		}

		public static BindingFlags RemoveFlag(this BindingFlags bindingAttr, BindingFlags flag)
		{
			if ((bindingAttr & flag) != flag)
			{
				return bindingAttr;
			}
			return bindingAttr ^ flag;
		}

		private static void GetChildPrivateProperties(IList<PropertyInfo> initialProperties, Type targetType, BindingFlags bindingAttr)
		{
			while ((object)(targetType = targetType.BaseType()) != null)
			{
				PropertyInfo[] properties = targetType.GetProperties(bindingAttr);
				foreach (PropertyInfo propertyInfo in properties)
				{
					PropertyInfo subTypeProperty = propertyInfo;
					if (!IsPublic(subTypeProperty))
					{
						int num = initialProperties.IndexOf((PropertyInfo p) => p.Name == subTypeProperty.Name);
						if (num == -1)
						{
							initialProperties.Add(subTypeProperty);
						}
						else if (!IsPublic(initialProperties[num]))
						{
							initialProperties[num] = subTypeProperty;
						}
					}
					else if (!subTypeProperty.IsVirtual())
					{
						if (initialProperties.IndexOf((PropertyInfo p) => p.Name == subTypeProperty.Name && (object)p.DeclaringType == subTypeProperty.DeclaringType) == -1)
						{
							initialProperties.Add(subTypeProperty);
						}
					}
					else if (initialProperties.IndexOf((PropertyInfo p) => p.Name == subTypeProperty.Name && p.IsVirtual() && (object)p.GetBaseDefinition() != null && p.GetBaseDefinition().DeclaringType.IsAssignableFrom(subTypeProperty.GetBaseDefinition().DeclaringType)) == -1)
					{
						initialProperties.Add(subTypeProperty);
					}
				}
			}
		}

		public static bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method)
		{
			return currentType.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).Any((MethodInfo info) => info.Name == method && (object)info.DeclaringType != methodDeclaringType && (object)info.GetBaseDefinition().DeclaringType == methodDeclaringType);
		}

		public static object GetDefaultValue(Type type)
		{
			if (!type.IsValueType())
			{
				return null;
			}
			switch (ConvertUtils.GetTypeCode(type))
			{
			case PrimitiveTypeCode.Boolean:
				return false;
			case PrimitiveTypeCode.Char:
			case PrimitiveTypeCode.SByte:
			case PrimitiveTypeCode.Int16:
			case PrimitiveTypeCode.UInt16:
			case PrimitiveTypeCode.Int32:
			case PrimitiveTypeCode.Byte:
			case PrimitiveTypeCode.UInt32:
				return 0;
			case PrimitiveTypeCode.Int64:
			case PrimitiveTypeCode.UInt64:
				return 0L;
			case PrimitiveTypeCode.Single:
				return 0f;
			case PrimitiveTypeCode.Double:
				return 0.0;
			case PrimitiveTypeCode.Decimal:
				return 0m;
			case PrimitiveTypeCode.DateTime:
				return default(DateTime);
			case PrimitiveTypeCode.Guid:
				return default(Guid);
			case PrimitiveTypeCode.DateTimeOffset:
				return default(DateTimeOffset);
			default:
				if (IsNullable(type))
				{
					return null;
				}
				return Activator.CreateInstance(type);
			}
		}
	}
	[Preserve]
	internal static class StringUtils
	{
		public const string CarriageReturnLineFeed = "\r\n";

		public const string Empty = "";

		public const char CarriageReturn = '\r';

		public const char LineFeed = '\n';

		public const char Tab = '\t';

		public static string FormatWith(this string format, IFormatProvider provider, object arg0)
		{
			return format.FormatWith(provider, new object[1] { arg0 });
		}

		public static string FormatWith(this string format, IFormatProvider provider, object arg0, object arg1)
		{
			return format.FormatWith(provider, new object[2] { arg0, arg1 });
		}

		public static string FormatWith(this string format, IFormatProvider provider, object arg0, object arg1, object arg2)
		{
			return format.FormatWith(provider, new object[3] { arg0, arg1, arg2 });
		}

		public static string FormatWith(this string format, IFormatProvider provider, object arg0, object arg1, object arg2, object arg3)
		{
			return format.FormatWith(provider, new object[4] { arg0, arg1, arg2, arg3 });
		}

		private static string FormatWith(this string format, IFormatProvider provider, params object[] args)
		{
			ValidationUtils.ArgumentNotNull(format, "format");
			return string.Format(provider, format, args);
		}

		public static bool IsWhiteSpace(string s)
		{
			if (s == null)
			{
				throw new ArgumentNullException("s");
			}
			if (s.Length == 0)
			{
				return false;
			}
			for (int i = 0; i < s.Length; i++)
			{
				if (!char.IsWhiteSpace(s[i]))
				{
					return false;
				}
			}
			return true;
		}

		public static string NullEmptyString(string s)
		{
			if (!string.IsNullOrEmpty(s))
			{
				return s;
			}
			return null;
		}

		public static StringWriter CreateStringWriter(int capacity)
		{
			return new StringWriter(new StringBuilder(capacity), CultureInfo.InvariantCulture);
		}

		public static int? GetLength(string value)
		{
			return value?.Length;
		}

		public static void ToCharAsUnicode(char c, char[] buffer)
		{
			buffer[0] = '\\';
			buffer[1] = 'u';
			buffer[2] = MathUtils.IntToHex(((int)c >> 12) & 0xF);
			buffer[3] = MathUtils.IntToHex(((int)c >> 8) & 0xF);
			buffer[4] = MathUtils.IntToHex(((int)c >> 4) & 0xF);
			buffer[5] = MathUtils.IntToHex(c & 0xF);
		}

		public static TSource ForgivingCaseSensitiveFind<TSource>(this IEnumerable<TSource> source, Func<TSource, string> valueSelector, string testValue)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (valueSelector == null)
			{
				throw new ArgumentNullException("valueSelector");
			}
			IEnumerable<TSource> source2 = source.Where((TSource s) => string.Equals(valueSelector(s), testValue, StringComparison.OrdinalIgnoreCase));
			if (source2.Count() <= 1)
			{
				return source2.SingleOrDefault();
			}
			return source.Where((TSource s) => string.Equals(valueSelector(s), testValue, StringComparison.Ordinal)).SingleOrDefault();
		}

		public static string ToCamelCase(string s)
		{
			if (string.IsNullOrEmpty(s) || !char.IsUpper(s[0]))
			{
				return s;
			}
			char[] array = s.ToCharArray();
			for (int i = 0; i < array.Length && (i != 1 || char.IsUpper(array[i])); i++)
			{
				bool flag = i + 1 < array.Length;
				if (i > 0 && flag && !char.IsUpper(array[i + 1]))
				{
					break;
				}
				array[i] = char.ToLower(array[i], CultureInfo.InvariantCulture);
			}
			return new string(array);
		}

		public static bool IsHighSurrogate(char c)
		{
			return char.IsHighSurrogate(c);
		}

		public static bool IsLowSurrogate(char c)
		{
			return char.IsLowSurrogate(c);
		}

		public static bool StartsWith(this string source, char value)
		{
			if (source.Length > 0)
			{
				return source[0] == value;
			}
			return false;
		}

		public static bool EndsWith(this string source, char value)
		{
			if (source.Length > 0)
			{
				return source[source.Length - 1] == value;
			}
			return false;
		}
	}
	[Preserve]
	internal static class TypeExtensions
	{
		public static MethodInfo Method(this Delegate d)
		{
			return d.Method;
		}

		public static MemberTypes MemberType(this MemberInfo memberInfo)
		{
			return memberInfo.MemberType;
		}

		public static bool ContainsGenericParameters(this Type type)
		{
			return type.ContainsGenericParameters;
		}

		public static bool IsInterface(this Type type)
		{
			return type.IsInterface;
		}

		public static bool IsGenericType(this Type type)
		{
			return type.IsGenericType;
		}

		public static bool IsGenericTypeDefinition(this Type type)
		{
			return type.IsGenericTypeDefinition;
		}

		public static Type BaseType(this Type type)
		{
			return type.BaseType;
		}

		public static Assembly Assembly(this Type type)
		{
			return type.Assembly;
		}

		public static bool IsEnum(this Type type)
		{
			return type.IsEnum;
		}

		public static bool IsClass(this Type type)
		{
			return type.IsClass;
		}

		public static bool IsSealed(this Type type)
		{
			return type.IsSealed;
		}

		public static bool IsAbstract(this Type type)
		{
			return type.IsAbstract;
		}

		public static bool IsVisible(this Type type)
		{
			return type.IsVisible;
		}

		public static bool IsValueType(this Type type)
		{
			return type.IsValueType;
		}

		public static bool AssignableToTypeName(this Type type, string fullTypeName, out Type match)
		{
			Type type2 = type;
			while ((object)type2 != null)
			{
				if (string.Equals(type2.FullName, fullTypeName, StringComparison.Ordinal))
				{
					match = type2;
					return true;
				}
				type2 = type2.BaseType();
			}
			Type[] interfaces = type.GetInterfaces();
			for (int i = 0; i < interfaces.Length; i++)
			{
				if (string.Equals(interfaces[i].Name, fullTypeName, StringComparison.Ordinal))
				{
					match = type;
					return true;
				}
			}
			match = null;
			return false;
		}

		public static bool AssignableToTypeName(this Type type, string fullTypeName)
		{
			Type match;
			return type.AssignableToTypeName(fullTypeName, out match);
		}

		public static bool ImplementInterface(this Type type, Type interfaceType)
		{
			Type type2 = type;
			while ((object)type2 != null)
			{
				foreach (Type item in (IEnumerable<Type>)type2.GetInterfaces())
				{
					if ((object)item == interfaceType || ((object)item != null && item.ImplementInterface(interfaceType)))
					{
						return true;
					}
				}
				type2 = type2.BaseType();
			}
			return false;
		}
	}
	[Preserve]
	internal static class ValidationUtils
	{
		public static void ArgumentNotNull(object value, string parameterName)
		{
			if (value == null)
			{
				throw new ArgumentNullException(parameterName);
			}
		}
	}
}
namespace Newtonsoft.Json.Shims
{
	[Preserve]
	public class PreserveAttribute : Attribute
	{
	}
}
namespace Newtonsoft.Json.Serialization
{
	[Preserve]
	public class DiagnosticsTraceWriter : ITraceWriter
	{
		public TraceLevel LevelFilter { get; set; }

		private TraceEventType GetTraceEventType(TraceLevel level)
		{
			return level switch
			{
				TraceLevel.Error => TraceEventType.Error, 
				TraceLevel.Warning => TraceEventType.Warning, 
				TraceLevel.Info => TraceEventType.Information, 
				TraceLevel.Verbose => TraceEventType.Verbose, 
				_ => throw new ArgumentOutOfRangeException("level"), 
			};
		}

		public void Trace(TraceLevel level, string message, Exception ex)
		{
			if (level == TraceLevel.Off)
			{
				return;
			}
			TraceEventCache eventCache = new TraceEventCache();
			TraceEventType traceEventType = GetTraceEventType(level);
			foreach (TraceListener listener in System.Diagnostics.Trace.Listeners)
			{
				if (!listener.IsThreadSafe)
				{
					lock (listener)
					{
						listener.TraceEvent(eventCache, "Newtonsoft.Json", traceEventType, 0, message);
					}
				}
				else
				{
					listener.TraceEvent(eventCache, "Newtonsoft.Json", traceEventType, 0, message);
				}
				if (System.Diagnostics.Trace.AutoFlush)
				{
					listener.Flush();
				}
			}
		}
	}
	[Preserve]
	public interface IAttributeProvider
	{
		IList<Attribute> GetAttributes(bool inherit);

		IList<Attribute> GetAttributes(Type attributeType, bool inherit);
	}
	[Preserve]
	public interface ITraceWriter
	{
		TraceLevel LevelFilter { get; }

		void Trace(TraceLevel level, string message, Exception ex);
	}
	[Preserve]
	public class JsonContainerContract : JsonContract
	{
		private JsonContract _itemContract;

		private JsonContract _finalItemContract;

		internal JsonContract ItemContract
		{
			get
			{
				return _itemContract;
			}
			set
			{
				_itemContract = value;
				if (_itemContract != null)
				{
					_finalItemContract = (_itemContract.UnderlyingType.IsSealed() ? _itemContract : null);
				}
				else
				{
					_finalItemContract = null;
				}
			}
		}

		internal JsonContract FinalItemContract => _finalItemContract;

		public JsonConverter ItemConverter { get; set; }

		public bool? ItemIsReference { get; set; }

		public ReferenceLoopHandling? ItemReferenceLoopHandling { get; set; }

		public TypeNameHandling? ItemTypeNameHandling { get; set; }

		internal JsonContainerContract(Type underlyingType)
			: base(underlyingType)
		{
			JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(underlyingType);
			if (cachedAttribute != null)
			{
				if ((object)cachedAttribute.ItemConverterType != null)
				{
					ItemConverter = JsonTypeReflector.CreateJsonConverterInstance(cachedAttribute.ItemConverterType, cachedAttribute.ItemConverterParameters);
				}
				ItemIsReference = cachedAttribute._itemIsReference;
				ItemReferenceLoopHandling = cachedAttribute._itemReferenceLoopHandling;
				ItemTypeNameHandling = cachedAttribute._itemTypeNameHandling;
			}
		}
	}
	[Preserve]
	public class MemoryTraceWriter : ITraceWriter
	{
		private readonly Queue<string> _traceMessages;

		public TraceLevel LevelFilter { get; set; }

		public MemoryTraceWriter()
		{
			LevelFilter = TraceLevel.Verbose;
			_traceMessages = new Queue<string>();
		}

		public void Trace(TraceLevel level, string message, Exception ex)
		{
			if (_traceMessages.Count >= 1000)
			{
				_traceMessages.Dequeue();
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append(DateTime.Now.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fff", CultureInfo.InvariantCulture));
			stringBuilder.Append(" ");
			stringBuilder.Append(level.ToString("g"));
			stringBuilder.Append(" ");
			stringBuilder.Append(message);
			_traceMessages.Enqueue(stringBuilder.ToString());
		}

		public IEnumerable<string> GetTraceMessages()
		{
			return _traceMessages;
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			foreach (string traceMessage in _traceMessages)
			{
				if (stringBuilder.Length > 0)
				{
					stringBuilder.AppendLine();
				}
				stringBuilder.Append(traceMessage);
			}
			return stringBuilder.ToString();
		}
	}
	[Preserve]
	public class ReflectionAttributeProvider : IAttributeProvider
	{
		private readonly object _attributeProvider;

		public ReflectionAttributeProvider(object attributeProvider)
		{
			ValidationUtils.ArgumentNotNull(attributeProvider, "attributeProvider");
			_attributeProvider = attributeProvider;
		}

		public IList<Attribute> GetAttributes(bool inherit)
		{
			return ReflectionUtils.GetAttributes(_attributeProvider, null, inherit);
		}

		public IList<Attribute> GetAttributes(Type attributeType, bool inherit)
		{
			return ReflectionUtils.GetAttributes(_attributeProvider, attributeType, inherit);
		}
	}
	[Preserve]
	internal class TraceJsonReader : JsonReader, IJsonLineInfo
	{
		private readonly JsonReader _innerReader;

		private readonly JsonTextWriter _textWriter;

		private readonly StringWriter _sw;

		public override int Depth => _innerReader.Depth;

		public override string Path => _innerReader.Path;

		public override char QuoteChar
		{
			get
			{
				return _innerReader.QuoteChar;
			}
			protected internal set
			{
				_innerReader.QuoteChar = value;
			}
		}

		public override JsonToken TokenType => _innerReader.TokenType;

		public override object Value => _innerReader.Value;

		public override Type ValueType => _innerReader.ValueType;

		int IJsonLineInfo.LineNumber
		{
			get
			{
				if (!(_innerReader is IJsonLineInfo jsonLineInfo))
				{
					return 0;
				}
				return jsonLineInfo.LineNumber;
			}
		}

		int IJsonLineInfo.LinePosition
		{
			get
			{
				if (!(_innerReader is IJsonLineInfo jsonLineInfo))
				{
					return 0;
				}
				return jsonLineInfo.LinePosition;
			}
		}

		public TraceJsonReader(JsonReader innerReader)
		{
			_innerReader = innerReader;
			_sw = new StringWriter(CultureInfo.InvariantCulture);
			_sw.Write("Deserialized JSON: " + Environment.NewLine);
			_textWriter = new JsonTextWriter(_sw);
			_textWriter.Formatting = Formatting.Indented;
		}

		public string GetDeserializedJsonMessage()
		{
			return _sw.ToString();
		}

		public override bool Read()
		{
			bool result = _innerReader.Read();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
			return result;
		}

		public override int? ReadAsInt32()
		{
			int? result = _innerReader.ReadAsInt32();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
			return result;
		}

		public override string ReadAsString()
		{
			string result = _innerReader.ReadAsString();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
			return result;
		}

		public override byte[] ReadAsBytes()
		{
			byte[] result = _innerReader.ReadAsBytes();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
			return result;
		}

		public override decimal? ReadAsDecimal()
		{
			decimal? result = _innerReader.ReadAsDecimal();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
			return result;
		}

		public override double? ReadAsDouble()
		{
			double? result = _innerReader.ReadAsDouble();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
			return result;
		}

		public override bool? ReadAsBoolean()
		{
			bool? result = _innerReader.ReadAsBoolean();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
			return result;
		}

		public override DateTime? ReadAsDateTime()
		{
			DateTime? result = _innerReader.ReadAsDateTime();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
			return result;
		}

		public override DateTimeOffset? ReadAsDateTimeOffset()
		{
			DateTimeOffset? result = _innerReader.ReadAsDateTimeOffset();
			_textWriter.WriteToken(_innerReader, writeChildren: false, writeDateConstructorAsDate: false, writeComments: true);
			return result;
		}

		public override void Close()
		{
			_innerReader.Close();
		}

		bool IJsonLineInfo.HasLineInfo()
		{
			if (_innerReader is IJsonLineInfo jsonLineInfo)
			{
				return jsonLineInfo.HasLineInfo();
			}
			return false;
		}
	}
	[Preserve]
	internal class TraceJsonWriter : JsonWriter
	{
		private readonly JsonWriter _innerWriter;

		private readonly JsonTextWriter _textWriter;

		private readonly StringWriter _sw;

		public TraceJsonWriter(JsonWriter innerWriter)
		{
			_innerWriter = innerWriter;
			_sw = new StringWriter(CultureInfo.InvariantCulture);
			_sw.Write("Serialized JSON: " + Environment.NewLine);
			_textWriter = new JsonTextWriter(_sw);
			_textWriter.Formatting = Formatting.Indented;
			_textWriter.Culture = innerWriter.Culture;
			_textWriter.DateFormatHandling = innerWriter.DateFormatHandling;
			_textWriter.DateFormatString = innerWriter.DateFormatString;
			_textWriter.DateTimeZoneHandling = innerWriter.DateTimeZoneHandling;
			_textWriter.FloatFormatHandling = innerWriter.FloatFormatHandling;
		}

		public string GetSerializedJsonMessage()
		{
			return _sw.ToString();
		}

		public override void WriteValue(decimal value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(bool value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(byte value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(byte? value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(char value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(byte[] value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(DateTime value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(DateTimeOffset value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(double value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteUndefined()
		{
			_textWriter.WriteUndefined();
			_innerWriter.WriteUndefined();
			base.WriteUndefined();
		}

		public override void WriteNull()
		{
			_textWriter.WriteNull();
			_innerWriter.WriteNull();
			base.WriteUndefined();
		}

		public override void WriteValue(float value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(Guid value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(int value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(long value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(object value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(sbyte value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(short value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(string value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(TimeSpan value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(uint value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(ulong value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(Uri value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteValue(ushort value)
		{
			_textWriter.WriteValue(value);
			_innerWriter.WriteValue(value);
			base.WriteValue(value);
		}

		public override void WriteWhitespace(string ws)
		{
			_textWriter.WriteWhitespace(ws);
			_innerWriter.WriteWhitespace(ws);
			base.WriteWhitespace(ws);
		}

		public override void WriteComment(string text)
		{
			_textWriter.WriteComment(text);
			_innerWriter.WriteComment(text);
			base.WriteComment(text);
		}

		public override void WriteStartArray()
		{
			_textWriter.WriteStartArray();
			_innerWriter.WriteStartArray();
			base.WriteStartArray();
		}

		public override void WriteEndArray()
		{
			_textWriter.WriteEndArray();
			_innerWriter.WriteEndArray();
			base.WriteEndArray();
		}

		public override void WriteStartConstructor(string name)
		{
			_textWriter.WriteStartConstructor(name);
			_innerWriter.WriteStartConstructor(name);
			base.WriteStartConstructor(name);
		}

		public override void WriteEndConstructor()
		{
			_textWriter.WriteEndConstructor();
			_innerWriter.WriteEndConstructor();
			base.WriteEndConstructor();
		}

		public override void WritePropertyName(string name)
		{
			_textWriter.WritePropertyName(name);
			_innerWriter.WritePropertyName(name);
			base.WritePropertyName(name);
		}

		public override void WritePropertyName(string name, bool escape)
		{
			_textWriter.WritePropertyName(name, escape);
			_innerWriter.WritePropertyName(name, escape);
			base.WritePropertyName(name);
		}

		public override void WriteStartObject()
		{
			_textWriter.WriteStartObject();
			_innerWriter.WriteStartObject();
			base.WriteStartObject();
		}

		public override void WriteEndObject()
		{
			_textWriter.WriteEndObject();
			_innerWriter.WriteEndObject();
			base.WriteEndObject();
		}

		public override void WriteRawValue(string json)
		{
			_textWriter.WriteRawValue(json);
			_innerWriter.WriteRawValue(json);
			InternalWriteValue(JsonToken.Undefined);
		}

		public override void WriteRaw(string json)
		{
			_textWriter.WriteRaw(json);
			_innerWriter.WriteRaw(json);
			base.WriteRaw(json);
		}

		public override void Close()
		{
			_textWriter.Close();
			_innerWriter.Close();
			base.Close();
		}

		public override void Flush()
		{
			_textWriter.Flush();
			_innerWriter.Flush();
		}
	}
	[Preserve]
	internal class JsonFormatterConverter : IFormatterConverter
	{
		private readonly JsonSerializerInternalReader _reader;

		private readonly JsonISerializableContract _contract;

		private readonly JsonProperty _member;

		public JsonFormatterConverter(JsonSerializerInternalReader reader, JsonISerializableContract contract, JsonProperty member)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			ValidationUtils.ArgumentNotNull(contract, "contract");
			_reader = reader;
			_contract = contract;
			_member = member;
		}

		private T GetTokenValue<T>(object value)
		{
			ValidationUtils.ArgumentNotNull(value, "value");
			return (T)System.Convert.ChangeType(((JValue)value).Value, typeof(T), CultureInfo.InvariantCulture);
		}

		public object Convert(object value, Type type)
		{
			ValidationUtils.ArgumentNotNull(value, "value");
			if (!(value is JToken token))
			{
				throw new ArgumentException("Value is not a JToken.", "value");
			}
			return _reader.CreateISerializableItem(token, type, _contract, _member);
		}

		public object Convert(object value, TypeCode typeCode)
		{
			ValidationUtils.ArgumentNotNull(value, "value");
			if (value is JValue)
			{
				value = ((JValue)value).Value;
			}
			return System.Convert.ChangeType(value, typeCode, CultureInfo.InvariantCulture);
		}

		public bool ToBoolean(object value)
		{
			return GetTokenValue<bool>(value);
		}

		public byte ToByte(object value)
		{
			return GetTokenValue<byte>(value);
		}

		public char ToChar(object value)
		{
			return GetTokenValue<char>(value);
		}

		public DateTime ToDateTime(object value)
		{
			return GetTokenValue<DateTime>(value);
		}

		public decimal ToDecimal(object value)
		{
			return GetTokenValue<decimal>(value);
		}

		public double ToDouble(object value)
		{
			return GetTokenValue<double>(value);
		}

		public short ToInt16(object value)
		{
			return GetTokenValue<short>(value);
		}

		public int ToInt32(object value)
		{
			return GetTokenValue<int>(value);
		}

		public long ToInt64(object value)
		{
			return GetTokenValue<long>(value);
		}

		public sbyte ToSByte(object value)
		{
			return GetTokenValue<sbyte>(value);
		}

		public float ToSingle(object value)
		{
			return GetTokenValue<float>(value);
		}

		public string ToString(object value)
		{
			return GetTokenValue<string>(value);
		}

		public ushort ToUInt16(object value)
		{
			return GetTokenValue<ushort>(value);
		}

		public uint ToUInt32(object value)
		{
			return GetTokenValue<uint>(value);
		}

		public ulong ToUInt64(object value)
		{
			return GetTokenValue<ulong>(value);
		}
	}
	[Preserve]
	public class JsonISerializableContract : JsonContainerContract
	{
		public ObjectConstructor<object> ISerializableCreator { get; set; }

		public JsonISerializableContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Serializable;
		}
	}
	[Preserve]
	public class JsonLinqContract : JsonContract
	{
		public JsonLinqContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Linq;
		}
	}
	[Preserve]
	public class JsonPrimitiveContract : JsonContract
	{
		private static readonly Dictionary<Type, ReadType> ReadTypeMap = new Dictionary<Type, ReadType>
		{
			[typeof(byte[])] = ReadType.ReadAsBytes,
			[typeof(byte)] = ReadType.ReadAsInt32,
			[typeof(short)] = ReadType.ReadAsInt32,
			[typeof(int)] = ReadType.ReadAsInt32,
			[typeof(decimal)] = ReadType.ReadAsDecimal,
			[typeof(bool)] = ReadType.ReadAsBoolean,
			[typeof(string)] = ReadType.ReadAsString,
			[typeof(DateTime)] = ReadType.ReadAsDateTime,
			[typeof(DateTimeOffset)] = ReadType.ReadAsDateTimeOffset,
			[typeof(float)] = ReadType.ReadAsDouble,
			[typeof(double)] = ReadType.ReadAsDouble
		};

		internal PrimitiveTypeCode TypeCode { get; set; }

		public JsonPrimitiveContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Primitive;
			TypeCode = ConvertUtils.GetTypeCode(underlyingType);
			IsReadOnlyOrFixedSize = true;
			if (ReadTypeMap.TryGetValue(NonNullableUnderlyingType, out var value))
			{
				InternalReadType = value;
			}
		}
	}
	[Preserve]
	public class ErrorEventArgs : EventArgs
	{
		public object CurrentObject { get; private set; }

		public ErrorContext ErrorContext { get; private set; }

		public ErrorEventArgs(object currentObject, ErrorContext errorContext)
		{
			CurrentObject = currentObject;
			ErrorContext = errorContext;
		}
	}
	[Preserve]
	internal class DefaultReferenceResolver : IReferenceResolver
	{
		private int _referenceCount;

		private BidirectionalDictionary<string, object> GetMappings(object context)
		{
			JsonSerializerInternalBase jsonSerializerInternalBase;
			if (context is JsonSerializerInternalBase)
			{
				jsonSerializerInternalBase = (JsonSerializerInternalBase)context;
			}
			else
			{
				if (!(context is JsonSerializerProxy))
				{
					throw new JsonException("The DefaultReferenceResolver can only be used internally.");
				}
				jsonSerializerInternalBase = ((JsonSerializerProxy)context).GetInternalSerializer();
			}
			return jsonSerializerInternalBase.DefaultReferenceMappings;
		}

		public object ResolveReference(object context, string reference)
		{
			GetMappings(context).TryGetByFirst(reference, out var second);
			return second;
		}

		public string GetReference(object context, object value)
		{
			BidirectionalDictionary<string, object> mappings = GetMappings(context);
			if (!mappings.TryGetBySecond(value, out var first))
			{
				_referenceCount++;
				first = _referenceCount.ToString(CultureInfo.InvariantCulture);
				mappings.Set(first, value);
			}
			return first;
		}

		public void AddReference(object context, string reference, object value)
		{
			GetMappings(context).Set(reference, value);
		}

		public bool IsReferenced(object context, object value)
		{
			string first;
			return GetMappings(context).TryGetBySecond(value, out first);
		}
	}
	[Preserve]
	public class CamelCasePropertyNamesContractResolver : DefaultContractResolver
	{
		public CamelCasePropertyNamesContractResolver()
			: base(shareCache: true)
		{
		}

		protected override string ResolvePropertyName(string propertyName)
		{
			return StringUtils.ToCamelCase(propertyName);
		}
	}
	[Preserve]
	internal struct ResolverContractKey
	{
		private readonly Type _resolverType;

		private readonly Type _contractType;

		public ResolverContractKey(Type resolverType, Type contractType)
		{
			_resolverType = resolverType;
			_contractType = contractType;
		}

		public override int GetHashCode()
		{
			return _resolverType.GetHashCode() ^ _contractType.GetHashCode();
		}

		public override bool Equals(object obj)
		{
			if (!(obj is ResolverContractKey))
			{
				return false;
			}
			return Equals((ResolverContractKey)obj);
		}

		public bool Equals(ResolverContractKey other)
		{
			if ((object)_resolverType == other._resolverType)
			{
				return (object)_contractType == other._contractType;
			}
			return false;
		}
	}
	[Preserve]
	internal class DefaultContractResolverState
	{
		public Dictionary<ResolverContractKey, JsonContract> ContractCache;

		public PropertyNameTable NameTable = new PropertyNameTable();
	}
	[Preserve]
	public class DefaultContractResolver : IContractResolver
	{
		internal class EnumerableDictionaryWrapper<TEnumeratorKey, TEnumeratorValue> : IEnumerable<KeyValuePair<object, object>>, IEnumerable
		{
			private readonly IEnumerable<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> _e;

			public EnumerableDictionaryWrapper(IEnumerable<KeyValuePair<TEnumeratorKey, TEnumeratorValue>> e)
			{
				ValidationUtils.ArgumentNotNull(e, "e");
				_e = e;
			}

			public IEnumerator<KeyValuePair<object, object>> GetEnumerator()
			{
				foreach (KeyValuePair<TEnumeratorKey, TEnumeratorValue> item in _e)
				{
					yield return new KeyValuePair<object, object>(item.Key, item.Value);
				}
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		private static readonly IContractResolver _instance = new DefaultContractResolver(shareCache: true);

		private static readonly JsonConverter[] BuiltInConverters = new JsonConverter[4]
		{
			new XmlNodeConverter(),
			new KeyValuePairConverter(),
			new BsonObjectIdConverter(),
			new RegexConverter()
		};

		private static readonly object TypeContractCacheLock = new object();

		private static readonly DefaultContractResolverState _sharedState = new DefaultContractResolverState();

		private readonly DefaultContractResolverState _instanceState = new DefaultContractResolverState();

		private readonly bool _sharedCache;

		internal static IContractResolver Instance => _instance;

		public bool DynamicCodeGeneration => JsonTypeReflector.DynamicCodeGeneration;

		[Obsolete("DefaultMembersSearchFlags is obsolete. To modify the members serialized inherit from DefaultContractResolver and override the GetSerializableMembers method instead.")]
		public BindingFlags DefaultMembersSearchFlags { get; set; }

		public bool SerializeCompilerGeneratedMembers { get; set; }

		public bool IgnoreSerializableInterface { get; set; }

		public bool IgnoreSerializableAttribute { get; set; }

		public DefaultContractResolver()
		{
			IgnoreSerializableAttribute = true;
			DefaultMembersSearchFlags = BindingFlags.Instance | BindingFlags.Public;
		}

		[Obsolete("DefaultContractResolver(bool) is obsolete. Use the parameterless constructor and cache instances of the contract resolver within your application for optimal performance.")]
		public DefaultContractResolver(bool shareCache)
			: this()
		{
			_sharedCache = shareCache;
		}

		internal DefaultContractResolverState GetState()
		{
			if (_sharedCache)
			{
				return _sharedState;
			}
			return _instanceState;
		}

		public virtual JsonContract ResolveContract(Type type)
		{
			if ((object)type == null)
			{
				throw new ArgumentNullException("type");
			}
			DefaultContractResolverState state = GetState();
			ResolverContractKey key = new ResolverContractKey(GetType(), type);
			Dictionary<ResolverContractKey, JsonContract> contractCache = state.ContractCache;
			if (contractCache == null || !contractCache.TryGetValue(key, out var value))
			{
				value = CreateContract(type);
				lock (TypeContractCacheLock)
				{
					contractCache = state.ContractCache;
					Dictionary<ResolverContractKey, JsonContract> dictionary = ((contractCache != null) ? new Dictionary<ResolverContractKey, JsonContract>(contractCache) : new Dictionary<ResolverContractKey, JsonContract>());
					dictionary[key] = value;
					state.ContractCache = dictionary;
				}
			}
			return value;
		}

		protected virtual List<MemberInfo> GetSerializableMembers(Type objectType)
		{
			bool ignoreSerializableAttribute = IgnoreSerializableAttribute;
			MemberSerialization objectMemberSerialization = JsonTypeReflector.GetObjectMemberSerialization(objectType, ignoreSerializableAttribute);
			List<MemberInfo> list = (from m in ReflectionUtils.GetFieldsAndProperties(objectType, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic)
				where !ReflectionUtils.IsIndexedProperty(m)
				select m).ToList();
			List<MemberInfo> list2 = new List<MemberInfo>();
			if (objectMemberSerialization != MemberSerialization.Fields)
			{
				DataContractAttribute dataContractAttribute = JsonTypeReflector.GetDataContractAttribute(objectType);
				List<MemberInfo> list3 = (from m in ReflectionUtils.GetFieldsAndProperties(objectType, DefaultMembersSearchFlags)
					where !ReflectionUtils.IsIndexedProperty(m)
					select m).ToList();
				foreach (MemberInfo item in list)
				{
					if (SerializeCompilerGeneratedMembers || !item.IsDefined(typeof(CompilerGeneratedAttribute), inherit: true))
					{
						if (list3.Contains(item))
						{
							list2.Add(item);
						}
						else if (JsonTypeReflector.GetAttribute<JsonPropertyAttribute>(item) != null)
						{
							list2.Add(item);
						}
						else if (JsonTypeReflector.GetAttribute<JsonRequiredAttribute>(item) != null)
						{
							list2.Add(item);
						}
						else if (dataContractAttribute != null && JsonTypeReflector.GetAttribute<DataMemberAttribute>(item) != null)
						{
							list2.Add(item);
						}
						else if (objectMemberSerialization == MemberSerialization.Fields && item.MemberType() == MemberTypes.Field)
						{
							list2.Add(item);
						}
					}
				}
				if (objectType.AssignableToTypeName("System.Data.Objects.DataClasses.EntityObject", out var _))
				{
					list2 = list2.Where(ShouldSerializeEntityMember).ToList();
				}
			}
			else
			{
				foreach (MemberInfo item2 in list)
				{
					if (item2 is FieldInfo { IsStatic: false })
					{
						list2.Add(item2);
					}
				}
			}
			return list2;
		}

		private bool ShouldSerializeEntityMember(MemberInfo memberInfo)
		{
			if (memberInfo is PropertyInfo propertyInfo && propertyInfo.PropertyType.IsGenericType() && propertyInfo.PropertyType.GetGenericTypeDefinition().FullName == "System.Data.Objects.DataClasses.EntityReference`1")
			{
				return false;
			}
			return true;
		}

		protected virtual JsonObjectContract CreateObjectContract(Type objectType)
		{
			JsonObjectContract jsonObjectContract = new JsonObjectContract(objectType);
			InitializeContract(jsonObjectContract);
			bool ignoreSerializableAttribute = IgnoreSerializableAttribute;
			jsonObjectContract.MemberSerialization = JsonTypeReflector.GetObjectMemberSerialization(jsonObjectContract.NonNullableUnderlyingType, ignoreSerializableAttribute);
			jsonObjectContract.Properties.AddRange(CreateProperties(jsonObjectContract.NonNullableUnderlyingType, jsonObjectContract.MemberSerialization));
			JsonObjectAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonObjectAttribute>(jsonObjectContract.NonNullableUnderlyingType);
			if (cachedAttribute != null)
			{
				jsonObjectContract.ItemRequired = cachedAttribute._itemRequired;
			}
			if (jsonObjectContract.IsInstantiable)
			{
				ConstructorInfo attributeConstructor = GetAttributeConstructor(jsonObjectContract.NonNullableUnderlyingType);
				if ((object)attributeConstructor != null)
				{
					jsonObjectContract.OverrideConstructor = attributeConstructor;
					jsonObjectContract.CreatorParameters.AddRange(CreateConstructorParameters(attributeConstructor, jsonObjectContract.Properties));
				}
				else if (jsonObjectContract.MemberSerialization == MemberSerialization.Fields)
				{
					if (JsonTypeReflector.FullyTrusted)
					{
						jsonObjectContract.DefaultCreator = jsonObjectContract.GetUninitializedObject;
					}
				}
				else if (jsonObjectContract.DefaultCreator == null || jsonObjectContract.DefaultCreatorNonPublic)
				{
					ConstructorInfo parameterizedConstructor = GetParameterizedConstructor(jsonObjectContract.NonNullableUnderlyingType);
					if ((object)parameterizedConstructor != null)
					{
						jsonObjectContract.ParametrizedConstructor = parameterizedConstructor;
						jsonObjectContract.CreatorParameters.AddRange(CreateConstructorParameters(parameterizedConstructor, jsonObjectContract.Properties));
					}
				}
			}
			MemberInfo extensionDataMemberForType = GetExtensionDataMemberForType(jsonObjectContract.NonNullableUnderlyingType);
			if ((object)extensionDataMemberForType != null)
			{
				SetExtensionDataDelegates(jsonObjectContract, extensionDataMemberForType);
			}
			return jsonObjectContract;
		}

		private MemberInfo GetExtensionDataMemberForType(Type type)
		{
			return GetClassHierarchyForType(type).SelectMany(delegate(Type baseType)
			{
				List<MemberInfo> list = new List<MemberInfo>();
				CollectionUtils.AddRange(list, baseType.GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
				CollectionUtils.AddRange(list, baseType.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
				return list;
			}).LastOrDefault(delegate(MemberInfo m)
			{
				MemberTypes memberTypes = m.MemberType();
				if (memberTypes != MemberTypes.Property && memberTypes != MemberTypes.Field)
				{
					return false;
				}
				if (!m.IsDefined(typeof(JsonExtensionDataAttribute), inherit: false))
				{
					return false;
				}
				if (!ReflectionUtils.CanReadMemberValue(m, nonPublic: true))
				{
					throw new JsonException("Invalid extension data attribute on '{0}'. Member '{1}' must have a getter.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(m.DeclaringType), m.Name));
				}
				if (ReflectionUtils.ImplementsGenericDefinition(ReflectionUtils.GetMemberUnderlyingType(m), typeof(IDictionary<, >), out var implementingType))
				{
					Type obj = implementingType.GetGenericArguments()[0];
					Type type2 = implementingType.GetGenericArguments()[1];
					if (obj.IsAssignableFrom(typeof(string)) && type2.IsAssignableFrom(typeof(JToken)))
					{
						return true;
					}
				}
				throw new JsonException("Invalid extension data attribute on '{0}'. Member '{1}' type must implement IDictionary<string, JToken>.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(m.DeclaringType), m.Name));
			});
		}

		private static void SetExtensionDataDelegates(JsonObjectContract contract, MemberInfo member)
		{
			JsonExtensionDataAttribute attribute = ReflectionUtils.GetAttribute<JsonExtensionDataAttribute>(member);
			if (attribute == null)
			{
				return;
			}
			Type memberUnderlyingType = ReflectionUtils.GetMemberUnderlyingType(member);
			ReflectionUtils.ImplementsGenericDefinition(memberUnderlyingType, typeof(IDictionary<, >), out var implementingType);
			Type type = implementingType.GetGenericArguments()[0];
			Type type2 = implementingType.GetGenericArguments()[1];
			Type type3 = ((!ReflectionUtils.IsGenericDefinition(memberUnderlyingType, typeof(IDictionary<, >))) ? memberUnderlyingType : typeof(Dictionary<, >).MakeGenericType(type, type2));
			Func<object, object> getExtensionDataDictionary = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(member);
			if (attribute.ReadData)
			{
				Action<object, object> setExtensionDataDictionary = (ReflectionUtils.CanSetMemberValue(member, nonPublic: true, canSetReadOnly: false) ? JsonTypeReflector.ReflectionDelegateFactory.CreateSet<object>(member) : null);
				Func<object> createExtensionDataDictionary = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(type3);
				MethodInfo method = memberUnderlyingType.GetMethod("Add", new Type[2] { type, type2 });
				MethodCall<object, object> setExtensionDataDictionaryValue = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method);
				ExtensionDataSetter extensionDataSetter = delegate(object o, string key, object value)
				{
					object obj = getExtensionDataDictionary(o);
					if (obj == null)
					{
						if (setExtensionDataDictionary == null)
						{
							throw new JsonSerializationException("Cannot set value onto extension data member '{0}'. The extension data collection is null and it cannot be set.".FormatWith(CultureInfo.InvariantCulture, member.Name));
						}
						obj = createExtensionDataDictionary();
						setExtensionDataDictionary(o, obj);
					}
					setExtensionDataDictionaryValue(obj, key, value);
				};
				contract.ExtensionDataSetter = extensionDataSetter;
			}
			if (attribute.WriteData)
			{
				ConstructorInfo method2 = typeof(EnumerableDictionaryWrapper<, >).MakeGenericType(type, type2).GetConstructors().First();
				ObjectConstructor<object> createEnumerableWrapper = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(method2);
				ExtensionDataGetter extensionDataGetter = delegate(object o)
				{
					object obj = getExtensionDataDictionary(o);
					return (obj == null) ? null : ((IEnumerable<KeyValuePair<object, object>>)createEnumerableWrapper(obj));
				};
				contract.ExtensionDataGetter = extensionDataGetter;
			}
			contract.ExtensionDataValueType = type2;
		}

		private ConstructorInfo GetAttributeConstructor(Type objectType)
		{
			IList<ConstructorInfo> list = (from c in objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)
				where c.IsDefined(typeof(JsonConstructorAttribute), inherit: true)
				select c).ToList();
			if (list.Count > 1)
			{
				throw new JsonException("Multiple constructors with the JsonConstructorAttribute.");
			}
			if (list.Count == 1)
			{
				return list[0];
			}
			if ((object)objectType == typeof(Version))
			{
				return objectType.GetConstructor(new Type[4]
				{
					typeof(int),
					typeof(int),
					typeof(int),
					typeof(int)
				});
			}
			return null;
		}

		private ConstructorInfo GetParameterizedConstructor(Type objectType)
		{
			IList<ConstructorInfo> list = objectType.GetConstructors(BindingFlags.Instance | BindingFlags.Public).ToList();
			if (list.Count == 1)
			{
				return list[0];
			}
			return null;
		}

		protected virtual IList<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties)
		{
			ParameterInfo[] parameters = constructor.GetParameters();
			JsonPropertyCollection jsonPropertyCollection = new JsonPropertyCollection(constructor.DeclaringType);
			ParameterInfo[] array = parameters;
			foreach (ParameterInfo parameterInfo in array)
			{
				JsonProperty jsonProperty = ((parameterInfo.Name != null) ? memberProperties.GetClosestMatchProperty(parameterInfo.Name) : null);
				if (jsonProperty != null && (object)jsonProperty.PropertyType != parameterInfo.ParameterType)
				{
					jsonProperty = null;
				}
				if (jsonProperty != null || parameterInfo.Name != null)
				{
					JsonProperty jsonProperty2 = CreatePropertyFromConstructorParameter(jsonProperty, parameterInfo);
					if (jsonProperty2 != null)
					{
						jsonPropertyCollection.AddProperty(jsonProperty2);
					}
				}
			}
			return jsonPropertyCollection;
		}

		protected virtual JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo)
		{
			JsonProperty jsonProperty = new JsonProperty();
			jsonProperty.PropertyType = parameterInfo.ParameterType;
			jsonProperty.AttributeProvider = new ReflectionAttributeProvider(parameterInfo);
			SetPropertySettingsFromAttributes(jsonProperty, parameterInfo, parameterInfo.Name, parameterInfo.Member.DeclaringType, MemberSerialization.OptOut, out var _);
			jsonProperty.Readable = false;
			jsonProperty.Writable = true;
			if (matchingMemberProperty != null)
			{
				jsonProperty.PropertyName = ((jsonProperty.PropertyName != parameterInfo.Name) ? jsonProperty.PropertyName : matchingMemberProperty.PropertyName);
				jsonProperty.Converter = jsonProperty.Converter ?? matchingMemberProperty.Converter;
				jsonProperty.MemberConverter = jsonProperty.MemberConverter ?? matchingMemberProperty.MemberConverter;
				if (!jsonProperty._hasExplicitDefaultValue && matchingMemberProperty._hasExplicitDefaultValue)
				{
					jsonProperty.DefaultValue = matchingMemberProperty.DefaultValue;
				}
				jsonProperty._required = jsonProperty._required ?? matchingMemberProperty._required;
				jsonProperty.IsReference = jsonProperty.IsReference ?? matchingMemberProperty.IsReference;
				jsonProperty.NullValueHandling = jsonProperty.NullValueHandling ?? matchingMemberProperty.NullValueHandling;
				jsonProperty.DefaultValueHandling = jsonProperty.DefaultValueHandling ?? matchingMemberProperty.DefaultValueHandling;
				jsonProperty.ReferenceLoopHandling = jsonProperty.ReferenceLoopHandling ?? matchingMemberProperty.ReferenceLoopHandling;
				jsonProperty.ObjectCreationHandling = jsonProperty.ObjectCreationHandling ?? matchingMemberProperty.ObjectCreationHandling;
				jsonProperty.TypeNameHandling = jsonProperty.TypeNameHandling ?? matchingMemberProperty.TypeNameHandling;
			}
			return jsonProperty;
		}

		protected virtual JsonConverter ResolveContractConverter(Type objectType)
		{
			return JsonTypeReflector.GetJsonConverter(objectType);
		}

		private Func<object> GetDefaultCreator(Type createdType)
		{
			return JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(createdType);
		}

		private void InitializeContract(JsonContract contract)
		{
			JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(contract.NonNullableUnderlyingType);
			if (cachedAttribute != null)
			{
				contract.IsReference = cachedAttribute._isReference;
			}
			else
			{
				DataContractAttribute dataContractAttribute = JsonTypeReflector.GetDataContractAttribute(contract.NonNullableUnderlyingType);
				if (dataContractAttribute != null && dataContractAttribute.IsReference)
				{
					contract.IsReference = true;
				}
			}
			contract.Converter = ResolveContractConverter(contract.NonNullableUnderlyingType);
			contract.InternalConverter = JsonSerializer.GetMatchingConverter(BuiltInConverters, contract.NonNullableUnderlyingType);
			if (contract.IsInstantiable && (ReflectionUtils.HasDefaultConstructor(contract.CreatedType, nonPublic: true) || contract.CreatedType.IsValueType()))
			{
				contract.DefaultCreator = GetDefaultCreator(contract.CreatedType);
				contract.DefaultCreatorNonPublic = !contract.CreatedType.IsValueType() && (object)ReflectionUtils.GetDefaultConstructor(contract.CreatedType) == null;
			}
			ResolveCallbackMethods(contract, contract.NonNullableUnderlyingType);
		}

		private void ResolveCallbackMethods(JsonContract contract, Type t)
		{
			GetCallbackMethodsForType(t, out var onSerializing, out var onSerialized, out var onDeserializing, out var onDeserialized, out var onError);
			if (onSerializing != null)
			{
				contract.OnSerializingCallbacks.AddRange(onSerializing);
			}
			if (onSerialized != null)
			{
				contract.OnSerializedCallbacks.AddRange(onSerialized);
			}
			if (onDeserializing != null)
			{
				contract.OnDeserializingCallbacks.AddRange(onDeserializing);
			}
			if (onDeserialized != null)
			{
				contract.OnDeserializedCallbacks.AddRange(onDeserialized);
			}
			if (onError != null)
			{
				contract.OnErrorCallbacks.AddRange(onError);
			}
		}

		private void GetCallbackMethodsForType(Type type, out List<SerializationCallback> onSerializing, out List<SerializationCallback> onSerialized, out List<SerializationCallback> onDeserializing, out List<SerializationCallback> onDeserialized, out List<SerializationErrorCallback> onError)
		{
			onSerializing = null;
			onSerialized = null;
			onDeserializing = null;
			onDeserialized = null;
			onError = null;
			foreach (Type item in GetClassHierarchyForType(type))
			{
				MethodInfo currentCallback = null;
				MethodInfo currentCallback2 = null;
				MethodInfo currentCallback3 = null;
				MethodInfo currentCallback4 = null;
				MethodInfo currentCallback5 = null;
				bool flag = ShouldSkipSerializing(item);
				bool flag2 = ShouldSkipDeserialized(item);
				MethodInfo[] methods = item.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
				foreach (MethodInfo methodInfo in methods)
				{
					if (!methodInfo.ContainsGenericParameters)
					{
						Type prevAttributeType = null;
						ParameterInfo[] parameters = methodInfo.GetParameters();
						if (!flag && IsValidCallback(methodInfo, parameters, typeof(OnSerializingAttribute), currentCallback, ref prevAttributeType))
						{
							onSerializing = onSerializing ?? new List<SerializationCallback>();
							onSerializing.Add(JsonContract.CreateSerializationCallback(methodInfo));
							currentCallback = methodInfo;
						}
						if (IsValidCallback(methodInfo, parameters, typeof(OnSerializedAttribute), currentCallback2, ref prevAttributeType))
						{
							onSerialized = onSerialized ?? new List<SerializationCallback>();
							onSerialized.Add(JsonContract.CreateSerializationCallback(methodInfo));
							currentCallback2 = methodInfo;
						}
						if (IsValidCallback(methodInfo, parameters, typeof(OnDeserializingAttribute), currentCallback3, ref prevAttributeType))
						{
							onDeserializing = onDeserializing ?? new List<SerializationCallback>();
							onDeserializing.Add(JsonContract.CreateSerializationCallback(methodInfo));
							currentCallback3 = methodInfo;
						}
						if (!flag2 && IsValidCallback(methodInfo, parameters, typeof(OnDeserializedAttribute), currentCallback4, ref prevAttributeType))
						{
							onDeserialized = onDeserialized ?? new List<SerializationCallback>();
							onDeserialized.Add(JsonContract.CreateSerializationCallback(methodInfo));
							currentCallback4 = methodInfo;
						}
						if (IsValidCallback(methodInfo, parameters, typeof(OnErrorAttribute), currentCallback5, ref prevAttributeType))
						{
							onError = onError ?? new List<SerializationErrorCallback>();
							onError.Add(JsonContract.CreateSerializationErrorCallback(methodInfo));
							currentCallback5 = methodInfo;
						}
					}
				}
			}
		}

		private static bool ShouldSkipDeserialized(Type t)
		{
			return false;
		}

		private static bool ShouldSkipSerializing(Type t)
		{
			return false;
		}

		private List<Type> GetClassHierarchyForType(Type type)
		{
			List<Type> list = new List<Type>();
			Type type2 = type;
			while ((object)type2 != null && (object)type2 != typeof(object))
			{
				list.Add(type2);
				type2 = type2.BaseType();
			}
			list.Reverse();
			return list;
		}

		protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType)
		{
			JsonDictionaryContract jsonDictionaryContract = new JsonDictionaryContract(objectType);
			InitializeContract(jsonDictionaryContract);
			jsonDictionaryContract.DictionaryKeyResolver = ResolveDictionaryKey;
			ConstructorInfo attributeConstructor = GetAttributeConstructor(jsonDictionaryContract.NonNullableUnderlyingType);
			if ((object)attributeConstructor != null)
			{
				ParameterInfo[] parameters = attributeConstructor.GetParameters();
				Type type = (((object)jsonDictionaryContract.DictionaryKeyType != null && (object)jsonDictionaryContract.DictionaryValueType != null) ? typeof(IEnumerable<>).MakeGenericType(typeof(KeyValuePair<, >).MakeGenericType(jsonDictionaryContract.DictionaryKeyType, jsonDictionaryContract.DictionaryValueType)) : typeof(IDictionary));
				if (parameters.Length == 0)
				{
					jsonDictionaryContract.HasParameterizedCreator = false;
				}
				else
				{
					if (parameters.Length != 1 || !type.IsAssignableFrom(parameters[0].ParameterType))
					{
						throw new JsonException("Constructor for '{0}' must have no parameters or a single parameter that implements '{1}'.".FormatWith(CultureInfo.InvariantCulture, jsonDictionaryContract.UnderlyingType, type));
					}
					jsonDictionaryContract.HasParameterizedCreator = true;
				}
				jsonDictionaryContract.OverrideCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(attributeConstructor);
			}
			return jsonDictionaryContract;
		}

		protected virtual JsonArrayContract CreateArrayContract(Type objectType)
		{
			JsonArrayContract jsonArrayContract = new JsonArrayContract(objectType);
			InitializeContract(jsonArrayContract);
			ConstructorInfo attributeConstructor = GetAttributeConstructor(jsonArrayContract.NonNullableUnderlyingType);
			if ((object)attributeConstructor != null)
			{
				ParameterInfo[] parameters = attributeConstructor.GetParameters();
				Type type = (((object)jsonArrayContract.CollectionItemType != null) ? typeof(IEnumerable<>).MakeGenericType(jsonArrayContract.CollectionItemType) : typeof(IEnumerable));
				if (parameters.Length == 0)
				{
					jsonArrayContract.HasParameterizedCreator = false;
				}
				else
				{
					if (parameters.Length != 1 || !type.IsAssignableFrom(parameters[0].ParameterType))
					{
						throw new JsonException("Constructor for '{0}' must have no parameters or a single parameter that implements '{1}'.".FormatWith(CultureInfo.InvariantCulture, jsonArrayContract.UnderlyingType, type));
					}
					jsonArrayContract.HasParameterizedCreator = true;
				}
				jsonArrayContract.OverrideCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(attributeConstructor);
			}
			return jsonArrayContract;
		}

		protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType)
		{
			JsonPrimitiveContract jsonPrimitiveContract = new JsonPrimitiveContract(objectType);
			InitializeContract(jsonPrimitiveContract);
			return jsonPrimitiveContract;
		}

		protected virtual JsonLinqContract CreateLinqContract(Type objectType)
		{
			JsonLinqContract jsonLinqContract = new JsonLinqContract(objectType);
			InitializeContract(jsonLinqContract);
			return jsonLinqContract;
		}

		protected virtual JsonISerializableContract CreateISerializableContract(Type objectType)
		{
			JsonISerializableContract jsonISerializableContract = new JsonISerializableContract(objectType);
			InitializeContract(jsonISerializableContract);
			ConstructorInfo constructor = jsonISerializableContract.NonNullableUnderlyingType.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, new Type[2]
			{
				typeof(SerializationInfo),
				typeof(StreamingContext)
			}, null);
			if ((object)constructor != null)
			{
				ObjectConstructor<object> iSerializableCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(constructor);
				jsonISerializableContract.ISerializableCreator = iSerializableCreator;
			}
			return jsonISerializableContract;
		}

		protected virtual JsonStringContract CreateStringContract(Type objectType)
		{
			JsonStringContract jsonStringContract = new JsonStringContract(objectType);
			InitializeContract(jsonStringContract);
			return jsonStringContract;
		}

		protected virtual JsonContract CreateContract(Type objectType)
		{
			if (IsJsonPrimitiveType(objectType))
			{
				return CreatePrimitiveContract(objectType);
			}
			Type type = ReflectionUtils.EnsureNotNullableType(objectType);
			JsonContainerAttribute cachedAttribute = JsonTypeReflector.GetCachedAttribute<JsonContainerAttribute>(type);
			if (cachedAttribute is JsonObjectAttribute)
			{
				return CreateObjectContract(objectType);
			}
			if (cachedAttribute is JsonArrayAttribute)
			{
				return CreateArrayContract(objectType);
			}
			if (cachedAttribute is JsonDictionaryAttribute)
			{
				return CreateDictionaryContract(objectType);
			}
			if ((object)type == typeof(JToken) || type.IsSubclassOf(typeof(JToken)))
			{
				return CreateLinqContract(objectType);
			}
			if (CollectionUtils.IsDictionaryType(type))
			{
				return CreateDictionaryContract(objectType);
			}
			if (typeof(IEnumerable).IsAssignableFrom(type))
			{
				return CreateArrayContract(objectType);
			}
			if (CanConvertToString(type))
			{
				return CreateStringContract(objectType);
			}
			if (!IgnoreSerializableInterface && typeof(ISerializable).IsAssignableFrom(type))
			{
				return CreateISerializableContract(objectType);
			}
			if (IsIConvertible(type))
			{
				return CreatePrimitiveContract(type);
			}
			return CreateObjectContract(objectType);
		}

		internal static bool IsJsonPrimitiveType(Type t)
		{
			PrimitiveTypeCode typeCode = ConvertUtils.GetTypeCode(t);
			if (typeCode != PrimitiveTypeCode.Empty)
			{
				return typeCode != PrimitiveTypeCode.Object;
			}
			return false;
		}

		internal static bool IsIConvertible(Type t)
		{
			if (typeof(IConvertible).IsAssignableFrom(t) || (ReflectionUtils.IsNullableType(t) && typeof(IConvertible).IsAssignableFrom(Nullable.GetUnderlyingType(t))))
			{
				return !typeof(JToken).IsAssignableFrom(t);
			}
			return false;
		}

		internal static bool CanConvertToString(Type type)
		{
			TypeConverter converter = ConvertUtils.GetConverter(type);
			if (converter != null && !(converter is ComponentConverter) && !(converter is ReferenceConverter) && (object)converter.GetType() != typeof(TypeConverter) && converter.CanConvertTo(typeof(string)))
			{
				return true;
			}
			if ((object)type == typeof(Type) || type.IsSubclassOf(typeof(Type)))
			{
				return true;
			}
			return false;
		}

		private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, ref Type prevAttributeType)
		{
			if (!method.IsDefined(attributeType, inherit: false))
			{
				return false;
			}
			if ((object)currentCallback != null)
			{
				throw new JsonException("Invalid attribute. Both '{0}' and '{1}' in type '{2}' have '{3}'.".FormatWith(CultureInfo.InvariantCulture, method, currentCallback, GetClrTypeFullName(method.DeclaringType), attributeType));
			}
			if ((object)prevAttributeType != null)
			{
				throw new JsonException("Invalid Callback. Method '{3}' in type '{2}' has both '{0}' and '{1}'.".FormatWith(CultureInfo.InvariantCulture, prevAttributeType, attributeType, GetClrTypeFullName(method.DeclaringType), method));
			}
			if (method.IsVirtual)
			{
				throw new JsonException("Virtual Method '{0}' of type '{1}' cannot be marked with '{2}' attribute.".FormatWith(CultureInfo.InvariantCulture, method, GetClrTypeFullName(method.DeclaringType), attributeType));
			}
			if ((object)method.ReturnType != typeof(void))
			{
				throw new JsonException("Serialization Callback '{1}' in type '{0}' must return void.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method));
			}
			if ((object)attributeType == typeof(OnErrorAttribute))
			{
				if (parameters == null || parameters.Length != 2 || (object)parameters[0].ParameterType != typeof(StreamingContext) || (object)parameters[1].ParameterType != typeof(ErrorContext))
				{
					throw new JsonException("Serialization Error Callback '{1}' in type '{0}' must have two parameters of type '{2}' and '{3}'.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method, typeof(StreamingContext), typeof(ErrorContext)));
				}
			}
			else if (parameters == null || parameters.Length != 1 || (object)parameters[0].ParameterType != typeof(StreamingContext))
			{
				throw new JsonException("Serialization Callback '{1}' in type '{0}' must have a single parameter of type '{2}'.".FormatWith(CultureInfo.InvariantCulture, GetClrTypeFullName(method.DeclaringType), method, typeof(StreamingContext)));
			}
			prevAttributeType = attributeType;
			return true;
		}

		internal static string GetClrTypeFullName(Type type)
		{
			if (type.IsGenericTypeDefinition() || !type.ContainsGenericParameters())
			{
				return type.FullName;
			}
			return string.Format(CultureInfo.InvariantCulture, "{0}.{1}", new object[2] { type.Namespace, type.Name });
		}

		protected virtual IList<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization)
		{
			List<MemberInfo> obj = GetSerializableMembers(type) ?? throw new JsonSerializationException("Null collection of seralizable members returned.");
			JsonPropertyCollection jsonPropertyCollection = new JsonPropertyCollection(type);
			foreach (MemberInfo item in obj)
			{
				JsonProperty jsonProperty = CreateProperty(item, memberSerialization);
				if (jsonProperty != null)
				{
					DefaultContractResolverState state = GetState();
					lock (state.NameTable)
					{
						jsonProperty.PropertyName = state.NameTable.Add(jsonProperty.PropertyName);
					}
					jsonPropertyCollection.AddProperty(jsonProperty);
				}
			}
			return jsonPropertyCollection.OrderBy((JsonProperty p) => p.Order ?? (-1)).ToList();
		}

		protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member)
		{
			return new ReflectionValueProvider(member);
		}

		protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization)
		{
			JsonProperty jsonProperty = new JsonProperty();
			jsonProperty.PropertyType = ReflectionUtils.GetMemberUnderlyingType(member);
			jsonProperty.DeclaringType = member.DeclaringType;
			jsonProperty.ValueProvider = CreateMemberValueProvider(member);
			jsonProperty.AttributeProvider = new ReflectionAttributeProvider(member);
			SetPropertySettingsFromAttributes(jsonProperty, member, member.Name, member.DeclaringType, memberSerialization, out var allowNonPublicAccess);
			if (memberSerialization != MemberSerialization.Fields)
			{
				jsonProperty.Readable = ReflectionUtils.CanReadMemberValue(member, allowNonPublicAccess);
				jsonProperty.Writable = ReflectionUtils.CanSetMemberValue(member, allowNonPublicAccess, jsonProperty.HasMemberAttribute);
			}
			else
			{
				jsonProperty.Readable = true;
				jsonProperty.Writable = true;
			}
			jsonProperty.ShouldSerialize = CreateShouldSerializeTest(member);
			SetIsSpecifiedActions(jsonProperty, member, allowNonPublicAccess);
			return jsonProperty;
		}

		private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, out bool allowNonPublicAccess)
		{
			DataContractAttribute dataContractAttribute = JsonTypeReflector.GetDataContractAttribute(declaringType);
			MemberInfo memberInfo = attributeProvider as MemberInfo;
			DataMemberAttribute dataMemberAttribute = ((dataContractAttribute == null || (object)memberInfo == null) ? null : JsonTypeReflector.GetDataMemberAttribute(memberInfo));
			JsonPropertyAttribute attribute = JsonTypeReflector.GetAttribute<JsonPropertyAttribute>(attributeProvider);
			JsonRequiredAttribute attribute2 = JsonTypeReflector.GetAttribute<JsonRequiredAttribute>(attributeProvider);
			string propertyName = ((attribute != null && attribute.PropertyName != null) ? attribute.PropertyName : ((dataMemberAttribute == null || dataMemberAttribute.Name == null) ? name : dataMemberAttribute.Name));
			property.PropertyName = ResolvePropertyName(propertyName);
			property.UnderlyingName = name;
			bool flag = false;
			if (attribute != null)
			{
				property._required = attribute._required;
				property.Order = attribute._order;
				property.DefaultValueHandling = attribute._defaultValueHandling;
				flag = true;
			}
			else if (dataMemberAttribute != null)
			{
				property._required = (dataMemberAttribute.IsRequired ? Required.AllowNull : Required.Default);
				property.Order = ((dataMemberAttribute.Order != -1) ? new int?(dataMemberAttribute.Order) : ((int?)null));
				property.DefaultValueHandling = ((!dataMemberAttribute.EmitDefaultValue) ? new DefaultValueHandling?(DefaultValueHandling.Ignore) : ((DefaultValueHandling?)null));
				flag = true;
			}
			if (attribute2 != null)
			{
				property._required = Required.Always;
				flag = true;
			}
			property.HasMemberAttribute = flag;
			bool flag2 = JsonTypeReflector.GetAttribute<JsonIgnoreAttribute>(attributeProvider) != null || JsonTypeReflector.GetAttribute<JsonExtensionDataAttribute>(attributeProvider) != null || JsonTypeReflector.GetAttribute<NonSerializedAttribute>(attributeProvider) != null;
			if (memberSerialization != MemberSerialization.OptIn)
			{
				bool flag3 = false;
				property.Ignored = flag2 || flag3;
			}
			else
			{
				property.Ignored = flag2 || !flag;
			}
			property.Converter = JsonTypeReflector.GetJsonConverter(attributeProvider);
			property.MemberConverter = JsonTypeReflector.GetJsonConverter(attributeProvider);
			DefaultValueAttribute attribute3 = JsonTypeReflector.GetAttribute<DefaultValueAttribute>(attributeProvider);
			if (attribute3 != null)
			{
				property.DefaultValue = attribute3.Value;
			}
			property.NullValueHandling = attribute?._nullValueHandling;
			property.ReferenceLoopHandling = attribute?._referenceLoopHandling;
			property.ObjectCreationHandling = attribute?._objectCreationHandling;
			property.TypeNameHandling = attribute?._typeNameHandling;
			property.IsReference = attribute?._isReference;
			property.ItemIsReference = attribute?._itemIsReference;
			property.ItemConverter = ((attribute != null && (object)attribute.ItemConverterType != null) ? JsonTypeReflector.CreateJsonConverterInstance(attribute.ItemConverterType, attribute.ItemConverterParameters) : null);
			property.ItemReferenceLoopHandling = attribute?._itemReferenceLoopHandling;
			property.ItemTypeNameHandling = attribute?._itemTypeNameHandling;
			allowNonPublicAccess = false;
			if ((DefaultMembersSearchFlags & BindingFlags.NonPublic) == BindingFlags.NonPublic)
			{
				allowNonPublicAccess = true;
			}
			if (flag)
			{
				allowNonPublicAccess = true;
			}
			if (memberSerialization == MemberSerialization.Fields)
			{
				allowNonPublicAccess = true;
			}
		}

		private Predicate<object> CreateShouldSerializeTest(MemberInfo member)
		{
			MethodInfo method = member.DeclaringType.GetMethod("ShouldSerialize" + member.Name, ReflectionUtils.EmptyTypes);
			if ((object)method == null || (object)method.ReturnType != typeof(bool))
			{
				return null;
			}
			MethodCall<object, object> shouldSerializeCall = JsonTypeReflector.ReflectionDelegateFactory.CreateMethodCall<object>(method);
			return (object o) => (bool)shouldSerializeCall(o);
		}

		private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess)
		{
			MemberInfo memberInfo = member.DeclaringType.GetProperty(member.Name + "Specified");
			if ((object)memberInfo == null)
			{
				memberInfo = member.DeclaringType.GetField(member.Name + "Specified");
			}
			if ((object)memberInfo != null && (object)ReflectionUtils.GetMemberUnderlyingType(memberInfo) == typeof(bool))
			{
				Func<object, object> specifiedPropertyGet = JsonTypeReflector.ReflectionDelegateFactory.CreateGet<object>(memberInfo);
				property.GetIsSpecified = (object o) => (bool)specifiedPropertyGet(o);
				if (ReflectionUtils.CanSetMemberValue(memberInfo, allowNonPublicAccess, canSetReadOnly: false))
				{
					property.SetIsSpecified = JsonTypeReflector.ReflectionDelegateFactory.CreateSet<object>(memberInfo);
				}
			}
		}

		protected virtual string ResolvePropertyName(string propertyName)
		{
			return propertyName;
		}

		protected virtual string ResolveDictionaryKey(string dictionaryKey)
		{
			return ResolvePropertyName(dictionaryKey);
		}

		public string GetResolvedPropertyName(string propertyName)
		{
			return ResolvePropertyName(propertyName);
		}
	}
	[Preserve]
	public class DefaultSerializationBinder : SerializationBinder
	{
		internal struct TypeNameKey
		{
			internal readonly string AssemblyName;

			internal readonly string TypeName;

			public TypeNameKey(string assemblyName, string typeName)
			{
				AssemblyName = assemblyName;
				TypeName = typeName;
			}

			public override int GetHashCode()
			{
				return ((AssemblyName != null) ? AssemblyName.GetHashCode() : 0) ^ ((TypeName != null) ? TypeName.GetHashCode() : 0);
			}

			public override bool Equals(object obj)
			{
				if (!(obj is TypeNameKey))
				{
					return false;
				}
				return Equals((TypeNameKey)obj);
			}

			public bool Equals(TypeNameKey other)
			{
				if (AssemblyName == other.AssemblyName)
				{
					return TypeName == other.TypeName;
				}
				return false;
			}
		}

		internal static readonly DefaultSerializationBinder Instance = new DefaultSerializationBinder();

		private readonly ThreadSafeStore<TypeNameKey, Type> _typeCache = new ThreadSafeStore<TypeNameKey, Type>(GetTypeFromTypeNameKey);

		private static Type GetTypeFromTypeNameKey(TypeNameKey typeNameKey)
		{
			string assemblyName = typeNameKey.AssemblyName;
			string typeName = typeNameKey.TypeName;
			if (assemblyName != null)
			{
				Assembly assembly = Assembly.Load(assemblyName);
				if ((object)assembly == null)
				{
					Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
					foreach (Assembly assembly2 in assemblies)
					{
						if (assembly2.FullName == assemblyName)
						{
							assembly = assembly2;
							break;
						}
					}
				}
				if ((object)assembly == null)
				{
					throw new JsonSerializationException("Could not load assembly '{0}'.".FormatWith(CultureInfo.InvariantCulture, assemblyName));
				}
				return assembly.GetType(typeName) ?? throw new JsonSerializationException("Could not find type '{0}' in assembly '{1}'.".FormatWith(CultureInfo.InvariantCulture, typeName, assembly.FullName));
			}
			return Type.GetType(typeName);
		}

		public override Type BindToType(string assemblyName, string typeName)
		{
			return _typeCache.Get(new TypeNameKey(assemblyName, typeName));
		}
	}
	[Preserve]
	public class ErrorContext
	{
		internal bool Traced { get; set; }

		public Exception Error { get; private set; }

		public object OriginalObject { get; private set; }

		public object Member { get; private set; }

		public string Path { get; private set; }

		public bool Handled { get; set; }

		internal ErrorContext(object originalObject, object member, string path, Exception error)
		{
			OriginalObject = originalObject;
			Member = member;
			Error = error;
			Path = path;
		}
	}
	[Preserve]
	public interface IContractResolver
	{
		JsonContract ResolveContract(Type type);
	}
	[Preserve]
	public interface IValueProvider
	{
		void SetValue(object target, object value);

		object GetValue(object target);
	}
	[Preserve]
	public class JsonArrayContract : JsonContainerContract
	{
		private readonly Type _genericCollectionDefinitionType;

		private Type _genericWrapperType;

		private ObjectConstructor<object> _genericWrapperCreator;

		private Func<object> _genericTemporaryCollectionCreator;

		private readonly ConstructorInfo _parameterizedConstructor;

		private ObjectConstructor<object> _parameterizedCreator;

		private ObjectConstructor<object> _overrideCreator;

		public Type CollectionItemType { get; private set; }

		public bool IsMultidimensionalArray { get; private set; }

		internal bool IsArray { get; private set; }

		internal bool ShouldCreateWrapper { get; private set; }

		internal bool CanDeserialize { get; private set; }

		internal ObjectConstructor<object> ParameterizedCreator
		{
			get
			{
				if (_parameterizedCreator == null)
				{
					_parameterizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(_parameterizedConstructor);
				}
				return _parameterizedCreator;
			}
		}

		public ObjectConstructor<object> OverrideCreator
		{
			get
			{
				return _overrideCreator;
			}
			set
			{
				_overrideCreator = value;
				CanDeserialize = true;
			}
		}

		public bool HasParameterizedCreator { get; set; }

		internal bool HasParameterizedCreatorInternal
		{
			get
			{
				if (!HasParameterizedCreator && _parameterizedCreator == null)
				{
					return (object)_parameterizedConstructor != null;
				}
				return true;
			}
		}

		public JsonArrayContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Array;
			IsArray = base.CreatedType.IsArray;
			bool canDeserialize;
			Type implementingType;
			if (IsArray)
			{
				CollectionItemType = ReflectionUtils.GetCollectionItemType(base.UnderlyingType);
				IsReadOnlyOrFixedSize = true;
				_genericCollectionDefinitionType = typeof(List<>).MakeGenericType(CollectionItemType);
				canDeserialize = true;
				IsMultidimensionalArray = IsArray && base.UnderlyingType.GetArrayRank() > 1;
			}
			else if (typeof(IList).IsAssignableFrom(underlyingType))
			{
				if (ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(ICollection<>), out _genericCollectionDefinitionType))
				{
					CollectionItemType = _genericCollectionDefinitionType.GetGenericArguments()[0];
				}
				else
				{
					CollectionItemType = ReflectionUtils.GetCollectionItemType(underlyingType);
				}
				if ((object)underlyingType == typeof(IList))
				{
					base.CreatedType = typeof(List<object>);
				}
				if ((object)CollectionItemType != null)
				{
					_parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(underlyingType, CollectionItemType);
				}
				IsReadOnlyOrFixedSize = ReflectionUtils.InheritsGenericDefinition(underlyingType, typeof(System.Collections.ObjectModel.ReadOnlyCollection<>));
				canDeserialize = true;
			}
			else if (ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(ICollection<>), out _genericCollectionDefinitionType))
			{
				CollectionItemType = _genericCollectionDefinitionType.GetGenericArguments()[0];
				if (ReflectionUtils.IsGenericDefinition(underlyingType, typeof(ICollection<>)) || ReflectionUtils.IsGenericDefinition(underlyingType, typeof(IList<>)))
				{
					base.CreatedType = typeof(List<>).MakeGenericType(CollectionItemType);
				}
				_parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(underlyingType, CollectionItemType);
				canDeserialize = true;
				ShouldCreateWrapper = true;
			}
			else if (ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(IEnumerable<>), out implementingType))
			{
				CollectionItemType = implementingType.GetGenericArguments()[0];
				if (ReflectionUtils.IsGenericDefinition(base.UnderlyingType, typeof(IEnumerable<>)))
				{
					base.CreatedType = typeof(List<>).MakeGenericType(CollectionItemType);
				}
				_parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(underlyingType, CollectionItemType);
				if (underlyingType.IsGenericType() && (object)underlyingType.GetGenericTypeDefinition() == typeof(IEnumerable<>))
				{
					_genericCollectionDefinitionType = implementingType;
					IsReadOnlyOrFixedSize = false;
					ShouldCreateWrapper = false;
					canDeserialize = true;
				}
				else
				{
					_genericCollectionDefinitionType = typeof(List<>).MakeGenericType(CollectionItemType);
					IsReadOnlyOrFixedSize = true;
					ShouldCreateWrapper = true;
					canDeserialize = HasParameterizedCreatorInternal;
				}
			}
			else
			{
				canDeserialize = false;
				ShouldCreateWrapper = true;
			}
			CanDeserialize = canDeserialize;
			if ((object)CollectionItemType != null && ReflectionUtils.IsNullableType(CollectionItemType) && (ReflectionUtils.InheritsGenericDefinition(base.CreatedType, typeof(List<>), out implementingType) || (IsArray && !IsMultidimensionalArray)))
			{
				ShouldCreateWrapper = true;
			}
		}

		internal IWrappedCollection CreateWrapper(object list)
		{
			if (_genericWrapperCreator == null)
			{
				_genericWrapperType = typeof(CollectionWrapper<>).MakeGenericType(CollectionItemType);
				Type type = ((!ReflectionUtils.InheritsGenericDefinition(_genericCollectionDefinitionType, typeof(List<>)) && (object)_genericCollectionDefinitionType.GetGenericTypeDefinition() != typeof(IEnumerable<>)) ? _genericCollectionDefinitionType : typeof(ICollection<>).MakeGenericType(CollectionItemType));
				ConstructorInfo constructor = _genericWrapperType.GetConstructor(new Type[1] { type });
				_genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(constructor);
			}
			return (IWrappedCollection)_genericWrapperCreator(list);
		}

		internal IList CreateTemporaryCollection()
		{
			if (_genericTemporaryCollectionCreator == null)
			{
				Type type = ((IsMultidimensionalArray || (object)CollectionItemType == null) ? typeof(object) : CollectionItemType);
				Type type2 = typeof(List<>).MakeGenericType(type);
				_genericTemporaryCollectionCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(type2);
			}
			return (IList)_genericTemporaryCollectionCreator();
		}
	}
	[Preserve]
	internal enum JsonContractType
	{
		None,
		Object,
		Array,
		Primitive,
		String,
		Dictionary,
		Dynamic,
		Serializable,
		Linq
	}
	[Preserve]
	public delegate void SerializationCallback(object o, StreamingContext context);
	[Preserve]
	public delegate void SerializationErrorCallback(object o, StreamingContext context, ErrorContext errorContext);
	[Preserve]
	public delegate void ExtensionDataSetter(object o, string key, object value);
	[Preserve]
	public delegate IEnumerable<KeyValuePair<object, object>> ExtensionDataGetter(object o);
	[Preserve]
	public abstract class JsonContract
	{
		internal bool IsNullable;

		internal bool IsConvertable;

		internal bool IsEnum;

		internal Type NonNullableUnderlyingType;

		internal ReadType InternalReadType;

		internal JsonContractType ContractType;

		internal bool IsReadOnlyOrFixedSize;

		internal bool IsSealed;

		internal bool IsInstantiable;

		private List<SerializationCallback> _onDeserializedCallbacks;

		private IList<SerializationCallback> _onDeserializingCallbacks;

		private IList<SerializationCallback> _onSerializedCallbacks;

		private IList<SerializationCallback> _onSerializingCallbacks;

		private IList<SerializationErrorCallback> _onErrorCallbacks;

		private Type _createdType;

		public Type UnderlyingType { get; private set; }

		public Type CreatedType
		{
			get
			{
				return _createdType;
			}
			set
			{
				_createdType = value;
				IsSealed = _createdType.IsSealed();
				IsInstantiable = !_createdType.IsInterface() && !_createdType.IsAbstract();
			}
		}

		public bool? IsReference { get; set; }

		public JsonConverter Converter { get; set; }

		internal JsonConverter InternalConverter { get; set; }

		public IList<SerializationCallback> OnDeserializedCallbacks
		{
			get
			{
				if (_onDeserializedCallbacks == null)
				{
					_onDeserializedCallbacks = new List<SerializationCallback>();
				}
				return _onDeserializedCallbacks;
			}
		}

		public IList<SerializationCallback> OnDeserializingCallbacks
		{
			get
			{
				if (_onDeserializingCallbacks == null)
				{
					_onDeserializingCallbacks = new List<SerializationCallback>();
				}
				return _onDeserializingCallbacks;
			}
		}

		public IList<SerializationCallback> OnSerializedCallbacks
		{
			get
			{
				if (_onSerializedCallbacks == null)
				{
					_onSerializedCallbacks = new List<SerializationCallback>();
				}
				return _onSerializedCallbacks;
			}
		}

		public IList<SerializationCallback> OnSerializingCallbacks
		{
			get
			{
				if (_onSerializingCallbacks == null)
				{
					_onSerializingCallbacks = new List<SerializationCallback>();
				}
				return _onSerializingCallbacks;
			}
		}

		public IList<SerializationErrorCallback> OnErrorCallbacks
		{
			get
			{
				if (_onErrorCallbacks == null)
				{
					_onErrorCallbacks = new List<SerializationErrorCallback>();
				}
				return _onErrorCallbacks;
			}
		}

		[Obsolete("This property is obsolete and has been replaced by the OnDeserializedCallbacks collection.")]
		public MethodInfo OnDeserialized
		{
			get
			{
				if (OnDeserializedCallbacks.Count <= 0)
				{
					return null;
				}
				return OnDeserializedCallbacks[0].Method();
			}
			set
			{
				OnDeserializedCallbacks.Clear();
				OnDeserializedCallbacks.Add(CreateSerializationCallback(value));
			}
		}

		[Obsolete("This property is obsolete and has been replaced by the OnDeserializingCallbacks collection.")]
		public MethodInfo OnDeserializing
		{
			get
			{
				if (OnDeserializingCallbacks.Count <= 0)
				{
					return null;
				}
				return OnDeserializingCallbacks[0].Method();
			}
			set
			{
				OnDeserializingCallbacks.Clear();
				OnDeserializingCallbacks.Add(CreateSerializationCallback(value));
			}
		}

		[Obsolete("This property is obsolete and has been replaced by the OnSerializedCallbacks collection.")]
		public MethodInfo OnSerialized
		{
			get
			{
				if (OnSerializedCallbacks.Count <= 0)
				{
					return null;
				}
				return OnSerializedCallbacks[0].Method();
			}
			set
			{
				OnSerializedCallbacks.Clear();
				OnSerializedCallbacks.Add(CreateSerializationCallback(value));
			}
		}

		[Obsolete("This property is obsolete and has been replaced by the OnSerializingCallbacks collection.")]
		public MethodInfo OnSerializing
		{
			get
			{
				if (OnSerializingCallbacks.Count <= 0)
				{
					return null;
				}
				return OnSerializingCallbacks[0].Method();
			}
			set
			{
				OnSerializingCallbacks.Clear();
				OnSerializingCallbacks.Add(CreateSerializationCallback(value));
			}
		}

		[Obsolete("This property is obsolete and has been replaced by the OnErrorCallbacks collection.")]
		public MethodInfo OnError
		{
			get
			{
				if (OnErrorCallbacks.Count <= 0)
				{
					return null;
				}
				return OnErrorCallbacks[0].Method();
			}
			set
			{
				OnErrorCallbacks.Clear();
				OnErrorCallbacks.Add(CreateSerializationErrorCallback(value));
			}
		}

		public Func<object> DefaultCreator { get; set; }

		public bool DefaultCreatorNonPublic { get; set; }

		internal JsonContract(Type underlyingType)
		{
			ValidationUtils.ArgumentNotNull(underlyingType, "underlyingType");
			UnderlyingType = underlyingType;
			IsNullable = ReflectionUtils.IsNullable(underlyingType);
			NonNullableUnderlyingType = ((IsNullable && ReflectionUtils.IsNullableType(underlyingType)) ? Nullable.GetUnderlyingType(underlyingType) : underlyingType);
			CreatedType = NonNullableUnderlyingType;
			IsConvertable = ConvertUtils.IsConvertible(NonNullableUnderlyingType);
			IsEnum = NonNullableUnderlyingType.IsEnum();
			InternalReadType = ReadType.Read;
		}

		internal void InvokeOnSerializing(object o, StreamingContext context)
		{
			if (_onSerializingCallbacks == null)
			{
				return;
			}
			foreach (SerializationCallback onSerializingCallback in _onSerializingCallbacks)
			{
				onSerializingCallback(o, context);
			}
		}

		internal void InvokeOnSerialized(object o, StreamingContext context)
		{
			if (_onSerializedCallbacks == null)
			{
				return;
			}
			foreach (SerializationCallback onSerializedCallback in _onSerializedCallbacks)
			{
				onSerializedCallback(o, context);
			}
		}

		internal void InvokeOnDeserializing(object o, StreamingContext context)
		{
			if (_onDeserializingCallbacks == null)
			{
				return;
			}
			foreach (SerializationCallback onDeserializingCallback in _onDeserializingCallbacks)
			{
				onDeserializingCallback(o, context);
			}
		}

		internal void InvokeOnDeserialized(object o, StreamingContext context)
		{
			if (_onDeserializedCallbacks == null)
			{
				return;
			}
			foreach (SerializationCallback onDeserializedCallback in _onDeserializedCallbacks)
			{
				onDeserializedCallback(o, context);
			}
		}

		internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext)
		{
			if (_onErrorCallbacks == null)
			{
				return;
			}
			foreach (SerializationErrorCallback onErrorCallback in _onErrorCallbacks)
			{
				onErrorCallback(o, context, errorContext);
			}
		}

		internal static SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo)
		{
			return delegate(object o, StreamingContext context)
			{
				callbackMethodInfo.Invoke(o, new object[1] { context });
			};
		}

		internal static SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo)
		{
			return delegate(object o, StreamingContext context, ErrorContext econtext)
			{
				callbackMethodInfo.Invoke(o, new object[2] { context, econtext });
			};
		}
	}
	[Preserve]
	public class JsonDictionaryContract : JsonContainerContract
	{
		private readonly Type _genericCollectionDefinitionType;

		private Type _genericWrapperType;

		private ObjectConstructor<object> _genericWrapperCreator;

		private Func<object> _genericTemporaryDictionaryCreator;

		private readonly ConstructorInfo _parameterizedConstructor;

		private ObjectConstructor<object> _overrideCreator;

		private ObjectConstructor<object> _parameterizedCreator;

		[Obsolete("PropertyNameResolver is obsolete. Use DictionaryKeyResolver instead.")]
		public Func<string, string> PropertyNameResolver
		{
			get
			{
				return DictionaryKeyResolver;
			}
			set
			{
				DictionaryKeyResolver = value;
			}
		}

		public Func<string, string> DictionaryKeyResolver { get; set; }

		public Type DictionaryKeyType { get; private set; }

		public Type DictionaryValueType { get; private set; }

		internal JsonContract KeyContract { get; set; }

		internal bool ShouldCreateWrapper { get; private set; }

		internal ObjectConstructor<object> ParameterizedCreator
		{
			get
			{
				if (_parameterizedCreator == null)
				{
					_parameterizedCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(_parameterizedConstructor);
				}
				return _parameterizedCreator;
			}
		}

		public ObjectConstructor<object> OverrideCreator
		{
			get
			{
				return _overrideCreator;
			}
			set
			{
				_overrideCreator = value;
			}
		}

		public bool HasParameterizedCreator { get; set; }

		internal bool HasParameterizedCreatorInternal
		{
			get
			{
				if (!HasParameterizedCreator && _parameterizedCreator == null)
				{
					return (object)_parameterizedConstructor != null;
				}
				return true;
			}
		}

		public JsonDictionaryContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Dictionary;
			Type keyType;
			Type valueType;
			if (ReflectionUtils.ImplementsGenericDefinition(underlyingType, typeof(IDictionary<, >), out _genericCollectionDefinitionType))
			{
				keyType = _genericCollectionDefinitionType.GetGenericArguments()[0];
				valueType = _genericCollectionDefinitionType.GetGenericArguments()[1];
				if (ReflectionUtils.IsGenericDefinition(base.UnderlyingType, typeof(IDictionary<, >)))
				{
					base.CreatedType = typeof(Dictionary<, >).MakeGenericType(keyType, valueType);
				}
			}
			else
			{
				ReflectionUtils.GetDictionaryKeyValueTypes(base.UnderlyingType, out keyType, out valueType);
				if ((object)base.UnderlyingType == typeof(IDictionary))
				{
					base.CreatedType = typeof(Dictionary<object, object>);
				}
			}
			if ((object)keyType != null && (object)valueType != null)
			{
				_parameterizedConstructor = CollectionUtils.ResolveEnumerableCollectionConstructor(base.CreatedType, typeof(KeyValuePair<, >).MakeGenericType(keyType, valueType), typeof(IDictionary<, >).MakeGenericType(keyType, valueType));
			}
			ShouldCreateWrapper = !typeof(IDictionary).IsAssignableFrom(base.CreatedType);
			DictionaryKeyType = keyType;
			DictionaryValueType = valueType;
			if ((object)DictionaryValueType != null && ReflectionUtils.IsNullableType(DictionaryValueType) && ReflectionUtils.InheritsGenericDefinition(base.CreatedType, typeof(Dictionary<, >), out var _))
			{
				ShouldCreateWrapper = true;
			}
		}

		internal IWrappedDictionary CreateWrapper(object dictionary)
		{
			if (_genericWrapperCreator == null)
			{
				_genericWrapperType = typeof(DictionaryWrapper<, >).MakeGenericType(DictionaryKeyType, DictionaryValueType);
				ConstructorInfo constructor = _genericWrapperType.GetConstructor(new Type[1] { _genericCollectionDefinitionType });
				_genericWrapperCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(constructor);
			}
			return (IWrappedDictionary)_genericWrapperCreator(dictionary);
		}

		internal IDictionary CreateTemporaryDictionary()
		{
			if (_genericTemporaryDictionaryCreator == null)
			{
				Type type = typeof(Dictionary<, >).MakeGenericType(DictionaryKeyType ?? typeof(object), DictionaryValueType ?? typeof(object));
				_genericTemporaryDictionaryCreator = JsonTypeReflector.ReflectionDelegateFactory.CreateDefaultConstructor<object>(type);
			}
			return (IDictionary)_genericTemporaryDictionaryCreator();
		}
	}
	[Preserve]
	public class JsonProperty
	{
		internal Required? _required;

		internal bool _hasExplicitDefaultValue;

		private object _defaultValue;

		private bool _hasGeneratedDefaultValue;

		private string _propertyName;

		internal bool _skipPropertyNameEscape;

		private Type _propertyType;

		internal JsonContract PropertyContract { get; set; }

		public string PropertyName
		{
			get
			{
				return _propertyName;
			}
			set
			{
				_propertyName = value;
				_skipPropertyNameEscape = !JavaScriptUtils.ShouldEscapeJavaScriptString(_propertyName, JavaScriptUtils.HtmlCharEscapeFlags);
			}
		}

		public Type DeclaringType { get; set; }

		public int? Order { get; set; }

		public string UnderlyingName { get; set; }

		public IValueProvider ValueProvider { get; set; }

		public IAttributeProvider AttributeProvider { get; set; }

		public Type PropertyType
		{
			get
			{
				return _propertyType;
			}
			set
			{
				if ((object)_propertyType != value)
				{
					_propertyType = value;
					_hasGeneratedDefaultValue = false;
				}
			}
		}

		public JsonConverter Converter { get; set; }

		public JsonConverter MemberConverter { get; set; }

		public bool Ignored { get; set; }

		public bool Readable { get; set; }

		public bool Writable { get; set; }

		public bool HasMemberAttribute { get; set; }

		public object DefaultValue
		{
			get
			{
				if (!_hasExplicitDefaultValue)
				{
					return null;
				}
				return _defaultValue;
			}
			set
			{
				_hasExplicitDefaultValue = true;
				_defaultValue = value;
			}
		}

		public Required Required
		{
			get
			{
				return _required ?? Required.Default;
			}
			set
			{
				_required = value;
			}
		}

		public bool? IsReference { get; set; }

		public NullValueHandling? NullValueHandling { get; set; }

		public DefaultValueHandling? DefaultValueHandling { get; set; }

		public ReferenceLoopHandling? ReferenceLoopHandling { get; set; }

		public ObjectCreationHandling? ObjectCreationHandling { get; set; }

		public TypeNameHandling? TypeNameHandling { get; set; }

		public Predicate<object> ShouldSerialize { get; set; }

		public Predicate<object> ShouldDeserialize { get; set; }

		public Predicate<object> GetIsSpecified { get; set; }

		public Action<object, object> SetIsSpecified { get; set; }

		public JsonConverter ItemConverter { get; set; }

		public bool? ItemIsReference { get; set; }

		public TypeNameHandling? ItemTypeNameHandling { get; set; }

		public ReferenceLoopHandling? ItemReferenceLoopHandling { get; set; }

		internal object GetResolvedDefaultValue()
		{
			if ((object)_propertyType == null)
			{
				return null;
			}
			if (!_hasExplicitDefaultValue && !_hasGeneratedDefaultValue)
			{
				_defaultValue = ReflectionUtils.GetDefaultValue(PropertyType);
				_hasGeneratedDefaultValue = true;
			}
			return _defaultValue;
		}

		public override string ToString()
		{
			return PropertyName;
		}

		internal void WritePropertyName(JsonWriter writer)
		{
			if (_skipPropertyNameEscape)
			{
				writer.WritePropertyName(PropertyName, escape: false);
			}
			else
			{
				writer.WritePropertyName(PropertyName);
			}
		}
	}
	[Preserve]
	public class JsonPropertyCollection : KeyedCollection<string, JsonProperty>
	{
		private readonly Type _type;

		private readonly List<JsonProperty> _list;

		public JsonPropertyCollection(Type type)
			: base((IEqualityComparer<string>)StringComparer.Ordinal)
		{
			ValidationUtils.ArgumentNotNull(type, "type");
			_type = type;
			_list = (List<JsonProperty>)base.Items;
		}

		protected override string GetKeyForItem(JsonProperty item)
		{
			return item.PropertyName;
		}

		public void AddProperty(JsonProperty property)
		{
			if (Contains(property.PropertyName))
			{
				if (property.Ignored)
				{
					return;
				}
				JsonProperty jsonProperty = base[property.PropertyName];
				bool flag = true;
				if (jsonProperty.Ignored)
				{
					Remove(jsonProperty);
					flag = false;
				}
				else if ((object)property.DeclaringType != null && (object)jsonProperty.DeclaringType != null)
				{
					if (property.DeclaringType.IsSubclassOf(jsonProperty.DeclaringType) || (jsonProperty.DeclaringType.IsInterface() && property.DeclaringType.ImplementInterface(jsonProperty.DeclaringType)))
					{
						Remove(jsonProperty);
						flag = false;
					}
					if (jsonProperty.DeclaringType.IsSubclassOf(property.DeclaringType) || (property.DeclaringType.IsInterface() && jsonProperty.DeclaringType.ImplementInterface(property.DeclaringType)))
					{
						return;
					}
				}
				if (flag)
				{
					throw new JsonSerializationException("A member with the name '{0}' already exists on '{1}'. Use the JsonPropertyAttribute to specify another name.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, _type));
				}
			}
			Add(property);
		}

		public JsonProperty GetClosestMatchProperty(string propertyName)
		{
			JsonProperty property = GetProperty(propertyName, StringComparison.Ordinal);
			if (property == null)
			{
				property = GetProperty(propertyName, StringComparison.OrdinalIgnoreCase);
			}
			return property;
		}

		private new bool TryGetValue(string key, out JsonProperty item)
		{
			if (base.Dictionary == null)
			{
				item = null;
				return false;
			}
			return base.Dictionary.TryGetValue(key, out item);
		}

		public JsonProperty GetProperty(string propertyName, StringComparison comparisonType)
		{
			if (comparisonType == StringComparison.Ordinal)
			{
				if (TryGetValue(propertyName, out var item))
				{
					return item;
				}
				return null;
			}
			for (int i = 0; i < _list.Count; i++)
			{
				JsonProperty jsonProperty = _list[i];
				if (string.Equals(propertyName, jsonProperty.PropertyName, comparisonType))
				{
					return jsonProperty;
				}
			}
			return null;
		}
	}
	[Preserve]
	public interface IReferenceResolver
	{
		object ResolveReference(object context, string reference);

		string GetReference(object context, object value);

		bool IsReferenced(object context, object value);

		void AddReference(object context, string reference, object value);
	}
	[Preserve]
	public class JsonObjectContract : JsonContainerContract
	{
		internal bool ExtensionDataIsJToken;

		private bool? _hasRequiredOrDefaultValueProperties;

		private ConstructorInfo _parametrizedConstructor;

		private ConstructorInfo _overrideConstructor;

		private ObjectConstructor<object> _overrideCreator;

		private ObjectConstructor<object> _parameterizedCreator;

		private JsonPropertyCollection _creatorParameters;

		private Type _extensionDataValueType;

		public MemberSerialization MemberSerialization { get; set; }

		public Required? ItemRequired { get; set; }

		public JsonPropertyCollection Properties { get; private set; }

		[Obsolete("ConstructorParameters is obsolete. Use CreatorParameters instead.")]
		public JsonPropertyCollection ConstructorParameters => CreatorParameters;

		public JsonPropertyCollection CreatorParameters
		{
			get
			{
				if (_creatorParameters == null)
				{
					_creatorParameters = new JsonPropertyCollection(base.UnderlyingType);
				}
				return _creatorParameters;
			}
		}

		[Obsolete("OverrideConstructor is obsolete. Use OverrideCreator instead.")]
		public ConstructorInfo OverrideConstructor
		{
			get
			{
				return _overrideConstructor;
			}
			set
			{
				_overrideConstructor = value;
				_overrideCreator = (((object)value != null) ? JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(value) : null);
			}
		}

		[Obsolete("ParametrizedConstructor is obsolete. Use OverrideCreator instead.")]
		public ConstructorInfo ParametrizedConstructor
		{
			get
			{
				return _parametrizedConstructor;
			}
			set
			{
				_parametrizedConstructor = value;
				_parameterizedCreator = (((object)value != null) ? JsonTypeReflector.ReflectionDelegateFactory.CreateParameterizedConstructor(value) : null);
			}
		}

		public ObjectConstructor<object> OverrideCreator
		{
			get
			{
				return _overrideCreator;
			}
			set
			{
				_overrideCreator = value;
				_overrideConstructor = null;
			}
		}

		internal ObjectConstructor<object> ParameterizedCreator => _parameterizedCreator;

		public ExtensionDataSetter ExtensionDataSetter { get; set; }

		public ExtensionDataGetter ExtensionDataGetter { get; set; }

		public Type ExtensionDataValueType
		{
			get
			{
				return _extensionDataValueType;
			}
			set
			{
				_extensionDataValueType = value;
				ExtensionDataIsJToken = (object)value != null && typeof(JToken).IsAssignableFrom(value);
			}
		}

		internal bool HasRequiredOrDefaultValueProperties
		{
			get
			{
				if (!_hasRequiredOrDefaultValueProperties.HasValue)
				{
					_hasRequiredOrDefaultValueProperties = false;
					if ((ItemRequired ?? Required.Default) != Required.Default)
					{
						_hasRequiredOrDefaultValueProperties = true;
					}
					else
					{
						foreach (JsonProperty property in Properties)
						{
							if (property.Required != Required.Default || ((uint?)property.DefaultValueHandling & 2u) == 2)
							{
								_hasRequiredOrDefaultValueProperties = true;
								break;
							}
						}
					}
				}
				return _hasRequiredOrDefaultValueProperties == true;
			}
		}

		public JsonObjectContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.Object;
			Properties = new JsonPropertyCollection(base.UnderlyingType);
		}

		internal object GetUninitializedObject()
		{
			if (!JsonTypeReflector.FullyTrusted)
			{
				throw new JsonException("Insufficient permissions. Creating an uninitialized '{0}' type requires full trust.".FormatWith(CultureInfo.InvariantCulture, NonNullableUnderlyingType));
			}
			return FormatterServices.GetUninitializedObject(NonNullableUnderlyingType);
		}
	}
	[Preserve]
	internal abstract class JsonSerializerInternalBase
	{
		private class ReferenceEqualsEqualityComparer : IEqualityComparer<object>
		{
			bool IEqualityComparer<object>.Equals(object x, object y)
			{
				return x == y;
			}

			int IEqualityComparer<object>.GetHashCode(object obj)
			{
				return RuntimeHelpers.GetHashCode(obj);
			}
		}

		private ErrorContext _currentErrorContext;

		private BidirectionalDictionary<string, object> _mappings;

		internal readonly JsonSerializer Serializer;

		internal readonly ITraceWriter TraceWriter;

		protected JsonSerializerProxy InternalSerializer;

		internal BidirectionalDictionary<string, object> DefaultReferenceMappings
		{
			get
			{
				if (_mappings == null)
				{
					_mappings = new BidirectionalDictionary<string, object>(EqualityComparer<string>.Default, new ReferenceEqualsEqualityComparer(), "A different value already has the Id '{0}'.", "A different Id has already been assigned for value '{0}'.");
				}
				return _mappings;
			}
		}

		protected JsonSerializerInternalBase(JsonSerializer serializer)
		{
			ValidationUtils.ArgumentNotNull(serializer, "serializer");
			Serializer = serializer;
			TraceWriter = serializer.TraceWriter;
		}

		private ErrorContext GetErrorContext(object currentObject, object member, string path, Exception error)
		{
			if (_currentErrorContext == null)
			{
				_currentErrorContext = new ErrorContext(currentObject, member, path, error);
			}
			if (_currentErrorContext.Error != error)
			{
				throw new InvalidOperationException("Current error context error is different to requested error.");
			}
			return _currentErrorContext;
		}

		protected void ClearErrorContext()
		{
			if (_currentErrorContext == null)
			{
				throw new InvalidOperationException("Could not clear error context. Error context is already null.");
			}
			_currentErrorContext = null;
		}

		protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, IJsonLineInfo lineInfo, string path, Exception ex)
		{
			ErrorContext errorContext = GetErrorContext(currentObject, keyValue, path, ex);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Error && !errorContext.Traced)
			{
				errorContext.Traced = true;
				string text = (((object)GetType() == typeof(JsonSerializerInternalWriter)) ? "Error serializing" : "Error deserializing");
				if (contract != null)
				{
					text = text + " " + contract.UnderlyingType;
				}
				text = text + ". " + ex.Message;
				if (!(ex is JsonException))
				{
					text = JsonPosition.FormatMessage(lineInfo, path, text);
				}
				TraceWriter.Trace(TraceLevel.Error, text, ex);
			}
			if (contract != null && currentObject != null)
			{
				contract.InvokeOnError(currentObject, Serializer.Context, errorContext);
			}
			if (!errorContext.Handled)
			{
				Serializer.OnError(new ErrorEventArgs(currentObject, errorContext));
			}
			return errorContext.Handled;
		}
	}
	[Preserve]
	internal class JsonSerializerInternalReader : JsonSerializerInternalBase
	{
		internal enum PropertyPresence
		{
			None,
			Null,
			Value
		}

		internal class CreatorPropertyContext
		{
			public string Name;

			public JsonProperty Property;

			public JsonProperty ConstructorProperty;

			public PropertyPresence? Presence;

			public object Value;

			public bool Used;
		}

		public JsonSerializerInternalReader(JsonSerializer serializer)
			: base(serializer)
		{
		}

		public void Populate(JsonReader reader, object target)
		{
			ValidationUtils.ArgumentNotNull(target, "target");
			Type type = target.GetType();
			JsonContract jsonContract = Serializer._contractResolver.ResolveContract(type);
			if (!reader.MoveToContent())
			{
				throw JsonSerializationException.Create(reader, "No JSON content found.");
			}
			if (reader.TokenType == JsonToken.StartArray)
			{
				if (jsonContract.ContractType == JsonContractType.Array)
				{
					JsonArrayContract jsonArrayContract = (JsonArrayContract)jsonContract;
					object list;
					if (!jsonArrayContract.ShouldCreateWrapper)
					{
						list = (IList)target;
					}
					else
					{
						IList list2 = jsonArrayContract.CreateWrapper(target);
						list = list2;
					}
					PopulateList((IList)list, reader, jsonArrayContract, null, null);
					return;
				}
				throw JsonSerializationException.Create(reader, "Cannot populate JSON array onto type '{0}'.".FormatWith(CultureInfo.InvariantCulture, type));
			}
			if (reader.TokenType == JsonToken.StartObject)
			{
				reader.ReadAndAssert();
				string id = null;
				if (Serializer.MetadataPropertyHandling != MetadataPropertyHandling.Ignore && reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString(), "$id", StringComparison.Ordinal))
				{
					reader.ReadAndAssert();
					id = ((reader.Value != null) ? reader.Value.ToString() : null);
					reader.ReadAndAssert();
				}
				if (jsonContract.ContractType == JsonContractType.Dictionary)
				{
					JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)jsonContract;
					object dictionary;
					if (!jsonDictionaryContract.ShouldCreateWrapper)
					{
						dictionary = (IDictionary)target;
					}
					else
					{
						IDictionary dictionary2 = jsonDictionaryContract.CreateWrapper(target);
						dictionary = dictionary2;
					}
					PopulateDictionary((IDictionary)dictionary, reader, jsonDictionaryContract, null, id);
				}
				else
				{
					if (jsonContract.ContractType != JsonContractType.Object)
					{
						throw JsonSerializationException.Create(reader, "Cannot populate JSON object onto type '{0}'.".FormatWith(CultureInfo.InvariantCulture, type));
					}
					PopulateObject(target, reader, (JsonObjectContract)jsonContract, null, id);
				}
				return;
			}
			throw JsonSerializationException.Create(reader, "Unexpected initial token '{0}' when populating object. Expected JSON object or array.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}

		private JsonContract GetContractSafe(Type type)
		{
			if ((object)type == null)
			{
				return null;
			}
			return Serializer._contractResolver.ResolveContract(type);
		}

		public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			JsonContract contractSafe = GetContractSafe(objectType);
			try
			{
				JsonConverter converter = GetConverter(contractSafe, null, null, null);
				if (reader.TokenType == JsonToken.None && !ReadForType(reader, contractSafe, converter != null))
				{
					if (contractSafe != null && !contractSafe.IsNullable)
					{
						throw JsonSerializationException.Create(reader, "No JSON content found and type '{0}' is not nullable.".FormatWith(CultureInfo.InvariantCulture, contractSafe.UnderlyingType));
					}
					return null;
				}
				object result = ((converter == null || !converter.CanRead) ? CreateValueInternal(reader, objectType, contractSafe, null, null, null, null) : DeserializeConvertable(converter, reader, objectType, null));
				if (checkAdditionalContent && reader.Read() && reader.TokenType != JsonToken.Comment)
				{
					throw new JsonSerializationException("Additional text found in JSON string after finishing deserializing object.");
				}
				return result;
			}
			catch (Exception ex)
			{
				if (IsErrorHandled(null, contractSafe, null, reader as IJsonLineInfo, reader.Path, ex))
				{
					HandleError(reader, readPastError: false, 0);
					return null;
				}
				ClearErrorContext();
				throw;
			}
		}

		private JsonSerializerProxy GetInternalSerializer()
		{
			if (InternalSerializer == null)
			{
				InternalSerializer = new JsonSerializerProxy(this);
			}
			return InternalSerializer;
		}

		private JToken CreateJToken(JsonReader reader, JsonContract contract)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			if (contract != null)
			{
				if ((object)contract.UnderlyingType == typeof(JRaw))
				{
					return JRaw.Create(reader);
				}
				if (reader.TokenType == JsonToken.Null && (object)contract.UnderlyingType != typeof(JValue) && (object)contract.UnderlyingType != typeof(JToken))
				{
					return null;
				}
			}
			using JTokenWriter jTokenWriter = new JTokenWriter();
			jTokenWriter.WriteToken(reader);
			return jTokenWriter.Token;
		}

		private JToken CreateJObject(JsonReader reader)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			using JTokenWriter jTokenWriter = new JTokenWriter();
			jTokenWriter.WriteStartObject();
			do
			{
				if (reader.TokenType == JsonToken.PropertyName)
				{
					string text = (string)reader.Value;
					if (!reader.ReadAndMoveToContent())
					{
						break;
					}
					if (!CheckPropertyName(reader, text))
					{
						jTokenWriter.WritePropertyName(text);
						jTokenWriter.WriteToken(reader, writeChildren: true, writeDateConstructorAsDate: true, writeComments: false);
					}
				}
				else if (reader.TokenType != JsonToken.Comment)
				{
					jTokenWriter.WriteEndObject();
					return jTokenWriter.Token;
				}
			}
			while (reader.Read());
			throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
		}

		private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue)
		{
			if (contract != null && contract.ContractType == JsonContractType.Linq)
			{
				return CreateJToken(reader, contract);
			}
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.StartObject:
					return CreateObject(reader, objectType, contract, member, containerContract, containerMember, existingValue);
				case JsonToken.StartArray:
					return CreateList(reader, objectType, contract, member, existingValue, null);
				case JsonToken.Integer:
				case JsonToken.Float:
				case JsonToken.Boolean:
				case JsonToken.Date:
				case JsonToken.Bytes:
					return EnsureType(reader, reader.Value, CultureInfo.InvariantCulture, contract, objectType);
				case JsonToken.String:
				{
					string text = (string)reader.Value;
					if (CoerceEmptyStringToNull(objectType, contract, text))
					{
						return null;
					}
					if ((object)objectType == typeof(byte[]))
					{
						return Convert.FromBase64String(text);
					}
					return EnsureType(reader, text, CultureInfo.InvariantCulture, contract, objectType);
				}
				case JsonToken.StartConstructor:
				{
					string value = reader.Value.ToString();
					return EnsureType(reader, value, CultureInfo.InvariantCulture, contract, objectType);
				}
				case JsonToken.Null:
				case JsonToken.Undefined:
					if ((object)objectType == typeof(DBNull))
					{
						return DBNull.Value;
					}
					return EnsureType(reader, reader.Value, CultureInfo.InvariantCulture, contract, objectType);
				case JsonToken.Raw:
					return new JRaw((string)reader.Value);
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token while deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (reader.Read());
			throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
		}

		private static bool CoerceEmptyStringToNull(Type objectType, JsonContract contract, string s)
		{
			if (string.IsNullOrEmpty(s) && (object)objectType != null && (object)objectType != typeof(string) && (object)objectType != typeof(object) && contract != null)
			{
				return contract.IsNullable;
			}
			return false;
		}

		internal string GetExpectedDescription(JsonContract contract)
		{
			switch (contract.ContractType)
			{
			case JsonContractType.Object:
			case JsonContractType.Dictionary:
			case JsonContractType.Serializable:
				return "JSON object (e.g. {\"name\":\"value\"})";
			case JsonContractType.Array:
				return "JSON array (e.g. [1,2,3])";
			case JsonContractType.Primitive:
				return "JSON primitive value (e.g. string, number, boolean, null)";
			case JsonContractType.String:
				return "JSON string value";
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter, JsonContainerContract containerContract, JsonProperty containerProperty)
		{
			JsonConverter result = null;
			if (memberConverter != null)
			{
				result = memberConverter;
			}
			else if (containerProperty != null && containerProperty.ItemConverter != null)
			{
				result = containerProperty.ItemConverter;
			}
			else if (containerContract != null && containerContract.ItemConverter != null)
			{
				result = containerContract.ItemConverter;
			}
			else if (contract != null)
			{
				JsonConverter matchingConverter;
				if (contract.Converter != null)
				{
					result = contract.Converter;
				}
				else if ((matchingConverter = Serializer.GetMatchingConverter(contract.UnderlyingType)) != null)
				{
					result = matchingConverter;
				}
				else if (contract.InternalConverter != null)
				{
					result = contract.InternalConverter;
				}
			}
			return result;
		}

		private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue)
		{
			Type objectType2 = objectType;
			string id;
			if (Serializer.MetadataPropertyHandling == MetadataPropertyHandling.Ignore)
			{
				reader.ReadAndAssert();
				id = null;
			}
			else if (Serializer.MetadataPropertyHandling == MetadataPropertyHandling.ReadAhead)
			{
				JTokenReader jTokenReader = reader as JTokenReader;
				if (jTokenReader == null)
				{
					jTokenReader = (JTokenReader)JToken.ReadFrom(reader).CreateReader();
					jTokenReader.Culture = reader.Culture;
					jTokenReader.DateFormatString = reader.DateFormatString;
					jTokenReader.DateParseHandling = reader.DateParseHandling;
					jTokenReader.DateTimeZoneHandling = reader.DateTimeZoneHandling;
					jTokenReader.FloatParseHandling = reader.FloatParseHandling;
					jTokenReader.SupportMultipleContent = reader.SupportMultipleContent;
					jTokenReader.ReadAndAssert();
					reader = jTokenReader;
				}
				if (ReadMetadataPropertiesToken(jTokenReader, ref objectType2, ref contract, member, containerContract, containerMember, existingValue, out var newValue, out id))
				{
					return newValue;
				}
			}
			else
			{
				reader.ReadAndAssert();
				if (ReadMetadataProperties(reader, ref objectType2, ref contract, member, containerContract, containerMember, existingValue, out var newValue2, out id))
				{
					return newValue2;
				}
			}
			if (HasNoDefinedType(contract))
			{
				return CreateJObject(reader);
			}
			switch (contract.ContractType)
			{
			case JsonContractType.Object:
			{
				bool createdFromNonDefaultCreator2 = false;
				JsonObjectContract jsonObjectContract = (JsonObjectContract)contract;
				object obj = ((existingValue == null || ((object)objectType2 != objectType && !objectType2.IsAssignableFrom(existingValue.GetType()))) ? CreateNewObject(reader, jsonObjectContract, member, containerMember, id, out createdFromNonDefaultCreator2) : existingValue);
				if (createdFromNonDefaultCreator2)
				{
					return obj;
				}
				return PopulateObject(obj, reader, jsonObjectContract, member, id);
			}
			case JsonContractType.Primitive:
			{
				JsonPrimitiveContract contract3 = (JsonPrimitiveContract)contract;
				if (Serializer.MetadataPropertyHandling != MetadataPropertyHandling.Ignore && reader.TokenType == JsonToken.PropertyName && string.Equals(reader.Value.ToString(), "$value", StringComparison.Ordinal))
				{
					reader.ReadAndAssert();
					if (reader.TokenType == JsonToken.StartObject)
					{
						throw JsonSerializationException.Create(reader, "Unexpected token when deserializing primitive value: " + reader.TokenType);
					}
					object result = CreateValueInternal(reader, objectType2, contract3, member, null, null, existingValue);
					reader.ReadAndAssert();
					return result;
				}
				break;
			}
			case JsonContractType.Dictionary:
			{
				JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)contract;
				if (existingValue == null)
				{
					bool createdFromNonDefaultCreator;
					IDictionary dictionary = CreateNewDictionary(reader, jsonDictionaryContract, out createdFromNonDefaultCreator);
					if (createdFromNonDefaultCreator)
					{
						if (id != null)
						{
							throw JsonSerializationException.Create(reader, "Cannot preserve reference to readonly dictionary, or dictionary created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
						}
						if (contract.OnSerializingCallbacks.Count > 0)
						{
							throw JsonSerializationException.Create(reader, "Cannot call OnSerializing on readonly dictionary, or dictionary created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
						}
						if (contract.OnErrorCallbacks.Count > 0)
						{
							throw JsonSerializationException.Create(reader, "Cannot call OnError on readonly list, or dictionary created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
						}
						if (!jsonDictionaryContract.HasParameterizedCreatorInternal)
						{
							throw JsonSerializationException.Create(reader, "Cannot deserialize readonly or fixed size dictionary: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
						}
					}
					PopulateDictionary(dictionary, reader, jsonDictionaryContract, member, id);
					if (createdFromNonDefaultCreator)
					{
						return (jsonDictionaryContract.OverrideCreator ?? jsonDictionaryContract.ParameterizedCreator)(dictionary);
					}
					if (dictionary is IWrappedDictionary)
					{
						return ((IWrappedDictionary)dictionary).UnderlyingDictionary;
					}
					return dictionary;
				}
				object dictionary2;
				if (!jsonDictionaryContract.ShouldCreateWrapper)
				{
					dictionary2 = (IDictionary)existingValue;
				}
				else
				{
					IDictionary dictionary3 = jsonDictionaryContract.CreateWrapper(existingValue);
					dictionary2 = dictionary3;
				}
				return PopulateDictionary((IDictionary)dictionary2, reader, jsonDictionaryContract, member, id);
			}
			case JsonContractType.Serializable:
			{
				JsonISerializableContract contract2 = (JsonISerializableContract)contract;
				return CreateISerializable(reader, contract2, member, id);
			}
			}
			string format = "Cannot deserialize the current JSON object (e.g. {{\"name\":\"value\"}}) into type '{0}' because the type requires a {1} to deserialize correctly." + Environment.NewLine + "To fix this error either change the JSON to a {1} or change the deserialized type so that it is a normal .NET type (e.g. not a primitive type like integer, not a collection type like an array or List<T>) that can be deserialized from a JSON object. JsonObjectAttribute can also be added to the type to force it to deserialize from a JSON object." + Environment.NewLine;
			format = format.FormatWith(CultureInfo.InvariantCulture, objectType2, GetExpectedDescription(contract));
			throw JsonSerializationException.Create(reader, format);
		}

		private bool ReadMetadataPropertiesToken(JTokenReader reader, ref Type objectType, ref JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, out object newValue, out string id)
		{
			id = null;
			newValue = null;
			if (reader.TokenType == JsonToken.StartObject)
			{
				JObject jObject = (JObject)reader.CurrentToken;
				JToken jToken = jObject["$ref"];
				if (jToken != null)
				{
					if (jToken.Type != JTokenType.String && jToken.Type != JTokenType.Null)
					{
						throw JsonSerializationException.Create(jToken, jToken.Path, "JSON reference {0} property must have a string or null value.".FormatWith(CultureInfo.InvariantCulture, "$ref"), null);
					}
					JToken parent = jToken.Parent;
					JToken jToken2 = null;
					if (parent.Next != null)
					{
						jToken2 = parent.Next;
					}
					else if (parent.Previous != null)
					{
						jToken2 = parent.Previous;
					}
					string text = (string)jToken;
					if (text != null)
					{
						if (jToken2 != null)
						{
							throw JsonSerializationException.Create(jToken2, jToken2.Path, "Additional content found in JSON reference object. A JSON reference object should only have a {0} property.".FormatWith(CultureInfo.InvariantCulture, "$ref"), null);
						}
						newValue = Serializer.GetReferenceResolver().ResolveReference(this, text);
						if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
						{
							TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader, reader.Path, "Resolved object reference '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, text, newValue.GetType())), null);
						}
						reader.Skip();
						return true;
					}
				}
				JToken jToken3 = jObject["$type"];
				if (jToken3 != null)
				{
					string qualifiedTypeName = (string)jToken3;
					JsonReader jsonReader = jToken3.CreateReader();
					jsonReader.ReadAndAssert();
					ResolveTypeName(jsonReader, ref objectType, ref contract, member, containerContract, containerMember, qualifiedTypeName);
					if (jObject["$value"] != null)
					{
						while (true)
						{
							reader.ReadAndAssert();
							if (reader.TokenType == JsonToken.PropertyName && (string)reader.Value == "$value")
							{
								break;
							}
							reader.ReadAndAssert();
							reader.Skip();
						}
						return false;
					}
				}
				JToken jToken4 = jObject["$id"];
				if (jToken4 != null)
				{
					id = (string)jToken4;
				}
				JToken jToken5 = jObject["$values"];
				if (jToken5 != null)
				{
					JsonReader jsonReader2 = jToken5.CreateReader();
					jsonReader2.ReadAndAssert();
					newValue = CreateList(jsonReader2, objectType, contract, member, existingValue, id);
					reader.Skip();
					return true;
				}
			}
			reader.ReadAndAssert();
			return false;
		}

		private bool ReadMetadataProperties(JsonReader reader, ref Type objectType, ref JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, out object newValue, out string id)
		{
			id = null;
			newValue = null;
			if (reader.TokenType == JsonToken.PropertyName)
			{
				string text = reader.Value.ToString();
				if (text.Length > 0 && text[0] == '$')
				{
					bool flag;
					do
					{
						text = reader.Value.ToString();
						if (string.Equals(text, "$ref", StringComparison.Ordinal))
						{
							reader.ReadAndAssert();
							if (reader.TokenType != JsonToken.String && reader.TokenType != JsonToken.Null)
							{
								throw JsonSerializationException.Create(reader, "JSON reference {0} property must have a string or null value.".FormatWith(CultureInfo.InvariantCulture, "$ref"));
							}
							string text2 = ((reader.Value != null) ? reader.Value.ToString() : null);
							reader.ReadAndAssert();
							if (text2 != null)
							{
								if (reader.TokenType == JsonToken.PropertyName)
								{
									throw JsonSerializationException.Create(reader, "Additional content found in JSON reference object. A JSON reference object should only have a {0} property.".FormatWith(CultureInfo.InvariantCulture, "$ref"));
								}
								newValue = Serializer.GetReferenceResolver().ResolveReference(this, text2);
								if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
								{
									TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Resolved object reference '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, text2, newValue.GetType())), null);
								}
								return true;
							}
							flag = true;
						}
						else if (string.Equals(text, "$type", StringComparison.Ordinal))
						{
							reader.ReadAndAssert();
							string qualifiedTypeName = reader.Value.ToString();
							ResolveTypeName(reader, ref objectType, ref contract, member, containerContract, containerMember, qualifiedTypeName);
							reader.ReadAndAssert();
							flag = true;
						}
						else if (string.Equals(text, "$id", StringComparison.Ordinal))
						{
							reader.ReadAndAssert();
							id = ((reader.Value != null) ? reader.Value.ToString() : null);
							reader.ReadAndAssert();
							flag = true;
						}
						else
						{
							if (string.Equals(text, "$values", StringComparison.Ordinal))
							{
								reader.ReadAndAssert();
								object obj = CreateList(reader, objectType, contract, member, existingValue, id);
								reader.ReadAndAssert();
								newValue = obj;
								return true;
							}
							flag = false;
						}
					}
					while (flag && reader.TokenType == JsonToken.PropertyName);
				}
			}
			return false;
		}

		private void ResolveTypeName(JsonReader reader, ref Type objectType, ref JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, string qualifiedTypeName)
		{
			if ((member?.TypeNameHandling ?? containerContract?.ItemTypeNameHandling ?? containerMember?.ItemTypeNameHandling ?? Serializer._typeNameHandling) != TypeNameHandling.None)
			{
				ReflectionUtils.SplitFullyQualifiedTypeName(qualifiedTypeName, out var typeName, out var assemblyName);
				Type type;
				try
				{
					type = Serializer._binder.BindToType(assemblyName, typeName);
				}
				catch (Exception ex)
				{
					throw JsonSerializationException.Create(reader, "Error resolving type specified in JSON '{0}'.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName), ex);
				}
				if ((object)type == null)
				{
					throw JsonSerializationException.Create(reader, "Type specified in JSON '{0}' was not resolved.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName));
				}
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
				{
					TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Resolved type '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, qualifiedTypeName, type)), null);
				}
				if ((object)objectType != null && !objectType.IsAssignableFrom(type))
				{
					throw JsonSerializationException.Create(reader, "Type specified in JSON '{0}' is not compatible with '{1}'.".FormatWith(CultureInfo.InvariantCulture, type.AssemblyQualifiedName, objectType.AssemblyQualifiedName));
				}
				objectType = type;
				contract = GetContractSafe(type);
			}
		}

		private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract)
		{
			if (contract == null)
			{
				throw JsonSerializationException.Create(reader, "Could not resolve type '{0}' to a JsonContract.".FormatWith(CultureInfo.InvariantCulture, objectType));
			}
			JsonArrayContract obj = contract as JsonArrayContract;
			if (obj == null)
			{
				string format = "Cannot deserialize the current JSON array (e.g. [1,2,3]) into type '{0}' because the type requires a {1} to deserialize correctly." + Environment.NewLine + "To fix this error either change the JSON to a {1} or change the deserialized type to an array or a type that implements a collection interface (e.g. ICollection, IList) like List<T> that can be deserialized from a JSON array. JsonArrayAttribute can also be added to the type to force it to deserialize from a JSON array." + Environment.NewLine;
				format = format.FormatWith(CultureInfo.InvariantCulture, objectType, GetExpectedDescription(contract));
				throw JsonSerializationException.Create(reader, format);
			}
			return obj;
		}

		private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string id)
		{
			if (HasNoDefinedType(contract))
			{
				return CreateJToken(reader, contract);
			}
			JsonArrayContract jsonArrayContract = EnsureArrayContract(reader, objectType, contract);
			if (existingValue == null)
			{
				bool createdFromNonDefaultCreator;
				IList list = CreateNewList(reader, jsonArrayContract, out createdFromNonDefaultCreator);
				if (createdFromNonDefaultCreator)
				{
					if (id != null)
					{
						throw JsonSerializationException.Create(reader, "Cannot preserve reference to array or readonly list, or list created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
					if (contract.OnSerializingCallbacks.Count > 0)
					{
						throw JsonSerializationException.Create(reader, "Cannot call OnSerializing on an array or readonly list, or list created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
					if (contract.OnErrorCallbacks.Count > 0)
					{
						throw JsonSerializationException.Create(reader, "Cannot call OnError on an array or readonly list, or list created from a non-default constructor: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
					if (!jsonArrayContract.HasParameterizedCreatorInternal && !jsonArrayContract.IsArray)
					{
						throw JsonSerializationException.Create(reader, "Cannot deserialize readonly or fixed size list: {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
					}
				}
				if (!jsonArrayContract.IsMultidimensionalArray)
				{
					PopulateList(list, reader, jsonArrayContract, member, id);
				}
				else
				{
					PopulateMultidimensionalArray(list, reader, jsonArrayContract, member, id);
				}
				if (createdFromNonDefaultCreator)
				{
					if (jsonArrayContract.IsMultidimensionalArray)
					{
						list = CollectionUtils.ToMultidimensionalArray(list, jsonArrayContract.CollectionItemType, contract.CreatedType.GetArrayRank());
					}
					else
					{
						if (!jsonArrayContract.IsArray)
						{
							return (jsonArrayContract.OverrideCreator ?? jsonArrayContract.ParameterizedCreator)(list);
						}
						Array array = Array.CreateInstance(jsonArrayContract.CollectionItemType, list.Count);
						list.CopyTo(array, 0);
						list = array;
					}
				}
				else if (list is IWrappedCollection)
				{
					return ((IWrappedCollection)list).UnderlyingCollection;
				}
				return list;
			}
			if (!jsonArrayContract.CanDeserialize)
			{
				throw JsonSerializationException.Create(reader, "Cannot populate list type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.CreatedType));
			}
			object list2;
			if (!jsonArrayContract.ShouldCreateWrapper)
			{
				list2 = (IList)existingValue;
			}
			else
			{
				IList list3 = jsonArrayContract.CreateWrapper(existingValue);
				list2 = list3;
			}
			return PopulateList((IList)list2, reader, jsonArrayContract, member, id);
		}

		private bool HasNoDefinedType(JsonContract contract)
		{
			if (contract != null && (object)contract.UnderlyingType != typeof(object))
			{
				return contract.ContractType == JsonContractType.Linq;
			}
			return true;
		}

		private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType)
		{
			if ((object)targetType == null)
			{
				return value;
			}
			if ((object)ReflectionUtils.GetObjectType(value) != targetType)
			{
				if (value == null && contract.IsNullable)
				{
					return null;
				}
				try
				{
					if (contract.IsConvertable)
					{
						JsonPrimitiveContract jsonPrimitiveContract = (JsonPrimitiveContract)contract;
						if (contract.IsEnum)
						{
							if (value is string)
							{
								return Enum.Parse(contract.NonNullableUnderlyingType, value.ToString(), ignoreCase: true);
							}
							if (ConvertUtils.IsInteger(jsonPrimitiveContract.TypeCode))
							{
								return Enum.ToObject(contract.NonNullableUnderlyingType, value);
							}
						}
						return Convert.ChangeType(value, contract.NonNullableUnderlyingType, culture);
					}
					return ConvertUtils.ConvertOrCast(value, culture, contract.NonNullableUnderlyingType);
				}
				catch (Exception ex)
				{
					throw JsonSerializationException.Create(reader, "Error converting value {0} to type '{1}'.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.FormatValueForPrint(value), targetType), ex);
				}
			}
			return value;
		}

		private bool SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target)
		{
			if (CalculatePropertyDetails(property, ref propertyConverter, containerContract, containerProperty, reader, target, out var useExistingValue, out var currentValue, out var propertyContract, out var gottenCurrentValue))
			{
				return false;
			}
			object obj;
			if (propertyConverter != null && propertyConverter.CanRead)
			{
				if (!gottenCurrentValue && target != null && property.Readable)
				{
					currentValue = property.ValueProvider.GetValue(target);
				}
				obj = DeserializeConvertable(propertyConverter, reader, property.PropertyType, currentValue);
			}
			else
			{
				obj = CreateValueInternal(reader, property.PropertyType, propertyContract, property, containerContract, containerProperty, useExistingValue ? currentValue : null);
			}
			if ((!useExistingValue || obj != currentValue) && ShouldSetPropertyValue(property, obj))
			{
				property.ValueProvider.SetValue(target, obj);
				if (property.SetIsSpecified != null)
				{
					if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
					{
						TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "IsSpecified for property '{0}' on {1} set to true.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType)), null);
					}
					property.SetIsSpecified(target, true);
				}
				return true;
			}
			return useExistingValue;
		}

		private bool CalculatePropertyDetails(JsonProperty property, ref JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target, out bool useExistingValue, out object currentValue, out JsonContract propertyContract, out bool gottenCurrentValue)
		{
			currentValue = null;
			useExistingValue = false;
			propertyContract = null;
			gottenCurrentValue = false;
			if (property.Ignored)
			{
				return true;
			}
			JsonToken tokenType = reader.TokenType;
			if (property.PropertyContract == null)
			{
				property.PropertyContract = GetContractSafe(property.PropertyType);
			}
			if (property.ObjectCreationHandling.GetValueOrDefault(Serializer._objectCreationHandling) != ObjectCreationHandling.Replace && (tokenType == JsonToken.StartArray || tokenType == JsonToken.StartObject) && property.Readable)
			{
				currentValue = property.ValueProvider.GetValue(target);
				gottenCurrentValue = true;
				if (currentValue != null)
				{
					propertyContract = GetContractSafe(currentValue.GetType());
					useExistingValue = !propertyContract.IsReadOnlyOrFixedSize && !propertyContract.UnderlyingType.IsValueType();
				}
			}
			if (!property.Writable && !useExistingValue)
			{
				return true;
			}
			if (property.NullValueHandling.GetValueOrDefault(Serializer._nullValueHandling) == NullValueHandling.Ignore && tokenType == JsonToken.Null)
			{
				return true;
			}
			if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Ignore) && !HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate) && JsonTokenUtils.IsPrimitiveToken(tokenType) && MiscellaneousUtils.ValueEquals(reader.Value, property.GetResolvedDefaultValue()))
			{
				return true;
			}
			if (currentValue == null)
			{
				propertyContract = property.PropertyContract;
			}
			else
			{
				propertyContract = GetContractSafe(currentValue.GetType());
				if (propertyContract != property.PropertyContract)
				{
					propertyConverter = GetConverter(propertyContract, property.MemberConverter, containerContract, containerProperty);
				}
			}
			return false;
		}

		private void AddReference(JsonReader reader, string id, object value)
		{
			try
			{
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
				{
					TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Read object reference Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, id, value.GetType())), null);
				}
				Serializer.GetReferenceResolver().AddReference(this, id, value);
			}
			catch (Exception ex)
			{
				throw JsonSerializationException.Create(reader, "Error reading object reference '{0}'.".FormatWith(CultureInfo.InvariantCulture, id), ex);
			}
		}

		private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
		{
			return (value & flag) == flag;
		}

		private bool ShouldSetPropertyValue(JsonProperty property, object value)
		{
			if (property.NullValueHandling.GetValueOrDefault(Serializer._nullValueHandling) == NullValueHandling.Ignore && value == null)
			{
				return false;
			}
			if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Ignore) && !HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate) && MiscellaneousUtils.ValueEquals(value, property.GetResolvedDefaultValue()))
			{
				return false;
			}
			if (!property.Writable)
			{
				return false;
			}
			return true;
		}

		private IList CreateNewList(JsonReader reader, JsonArrayContract contract, out bool createdFromNonDefaultCreator)
		{
			if (!contract.CanDeserialize)
			{
				throw JsonSerializationException.Create(reader, "Cannot create and populate list type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.CreatedType));
			}
			if (contract.OverrideCreator != null)
			{
				if (contract.HasParameterizedCreator)
				{
					createdFromNonDefaultCreator = true;
					return contract.CreateTemporaryCollection();
				}
				createdFromNonDefaultCreator = false;
				return (IList)contract.OverrideCreator();
			}
			if (contract.IsReadOnlyOrFixedSize)
			{
				createdFromNonDefaultCreator = true;
				IList list = contract.CreateTemporaryCollection();
				if (contract.ShouldCreateWrapper)
				{
					list = contract.CreateWrapper(list);
				}
				return list;
			}
			if (contract.DefaultCreator != null && (!contract.DefaultCreatorNonPublic || Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
			{
				object obj = contract.DefaultCreator();
				if (contract.ShouldCreateWrapper)
				{
					obj = contract.CreateWrapper(obj);
				}
				createdFromNonDefaultCreator = false;
				return (IList)obj;
			}
			if (contract.HasParameterizedCreatorInternal)
			{
				createdFromNonDefaultCreator = true;
				return contract.CreateTemporaryCollection();
			}
			if (!contract.IsInstantiable)
			{
				throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
			}
			throw JsonSerializationException.Create(reader, "Unable to find a constructor to use for type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
		}

		private IDictionary CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract, out bool createdFromNonDefaultCreator)
		{
			if (contract.OverrideCreator != null)
			{
				if (contract.HasParameterizedCreator)
				{
					createdFromNonDefaultCreator = true;
					return contract.CreateTemporaryDictionary();
				}
				createdFromNonDefaultCreator = false;
				return (IDictionary)contract.OverrideCreator();
			}
			if (contract.IsReadOnlyOrFixedSize)
			{
				createdFromNonDefaultCreator = true;
				return contract.CreateTemporaryDictionary();
			}
			if (contract.DefaultCreator != null && (!contract.DefaultCreatorNonPublic || Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor))
			{
				object obj = contract.DefaultCreator();
				if (contract.ShouldCreateWrapper)
				{
					obj = contract.CreateWrapper(obj);
				}
				createdFromNonDefaultCreator = false;
				return (IDictionary)obj;
			}
			if (contract.HasParameterizedCreatorInternal)
			{
				createdFromNonDefaultCreator = true;
				return contract.CreateTemporaryDictionary();
			}
			if (!contract.IsInstantiable)
			{
				throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
			}
			throw JsonSerializationException.Create(reader, "Unable to find a default constructor to use for type {0}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType));
		}

		private void OnDeserializing(JsonReader reader, JsonContract contract, object value)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Started deserializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			contract.InvokeOnDeserializing(value, Serializer._context);
		}

		private void OnDeserialized(JsonReader reader, JsonContract contract, object value)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Finished deserializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			contract.InvokeOnDeserialized(value, Serializer._context);
		}

		private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, string id)
		{
			object obj = ((dictionary is IWrappedDictionary wrappedDictionary) ? wrappedDictionary.UnderlyingDictionary : dictionary);
			if (id != null)
			{
				AddReference(reader, id, obj);
			}
			OnDeserializing(reader, contract, obj);
			int depth = reader.Depth;
			if (contract.KeyContract == null)
			{
				contract.KeyContract = GetContractSafe(contract.DictionaryKeyType);
			}
			if (contract.ItemContract == null)
			{
				contract.ItemContract = GetContractSafe(contract.DictionaryValueType);
			}
			JsonConverter jsonConverter = contract.ItemConverter ?? GetConverter(contract.ItemContract, null, contract, containerProperty);
			PrimitiveTypeCode primitiveTypeCode = ((contract.KeyContract is JsonPrimitiveContract) ? ((JsonPrimitiveContract)contract.KeyContract).TypeCode : PrimitiveTypeCode.Empty);
			bool flag = false;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					object obj2 = reader.Value;
					if (CheckPropertyName(reader, obj2.ToString()))
					{
						break;
					}
					try
					{
						try
						{
							switch (primitiveTypeCode)
							{
							case PrimitiveTypeCode.DateTime:
							case PrimitiveTypeCode.DateTimeNullable:
							{
								obj2 = ((!DateTimeUtils.TryParseDateTime(obj2.ToString(), reader.DateTimeZoneHandling, reader.DateFormatString, reader.Culture, out var dt2)) ? EnsureType(reader, obj2, CultureInfo.InvariantCulture, contract.KeyContract, contract.DictionaryKeyType) : ((object)dt2));
								break;
							}
							case PrimitiveTypeCode.DateTimeOffset:
							case PrimitiveTypeCode.DateTimeOffsetNullable:
							{
								obj2 = ((!DateTimeUtils.TryParseDateTimeOffset(obj2.ToString(), reader.DateFormatString, reader.Culture, out var dt)) ? EnsureType(reader, obj2, CultureInfo.InvariantCulture, contract.KeyContract, contract.DictionaryKeyType) : ((object)dt));
								break;
							}
							default:
								obj2 = EnsureType(reader, obj2, CultureInfo.InvariantCulture, contract.KeyContract, contract.DictionaryKeyType);
								break;
							}
						}
						catch (Exception ex)
						{
							throw JsonSerializationException.Create(reader, "Could not convert string '{0}' to dictionary key type '{1}'. Create a TypeConverter to convert from the string to the key type object.".FormatWith(CultureInfo.InvariantCulture, reader.Value, contract.DictionaryKeyType), ex);
						}
						if (!ReadForType(reader, contract.ItemContract, jsonConverter != null))
						{
							throw JsonSerializationException.Create(reader, "Unexpected end when deserializing object.");
						}
						object value = ((jsonConverter == null || !jsonConverter.CanRead) ? CreateValueInternal(reader, contract.DictionaryValueType, contract.ItemContract, null, contract, containerProperty, null) : DeserializeConvertable(jsonConverter, reader, contract.DictionaryValueType, null));
						dictionary[obj2] = value;
					}
					catch (Exception ex2)
					{
						if (IsErrorHandled(obj, contract, obj2, reader as IJsonLineInfo, reader.Path, ex2))
						{
							HandleError(reader, readPastError: true, depth);
							break;
						}
						throw;
					}
					break;
				}
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag && reader.Read());
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, obj, "Unexpected end when deserializing object.");
			}
			OnDeserialized(reader, contract, obj);
			return obj;
		}

		private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id)
		{
			int arrayRank = contract.UnderlyingType.GetArrayRank();
			if (id != null)
			{
				AddReference(reader, id, list);
			}
			OnDeserializing(reader, contract, list);
			JsonContract contractSafe = GetContractSafe(contract.CollectionItemType);
			JsonConverter converter = GetConverter(contractSafe, null, contract, containerProperty);
			int? num = null;
			Stack<IList> stack = new Stack<IList>();
			stack.Push(list);
			IList list2 = list;
			bool flag = false;
			do
			{
				int depth = reader.Depth;
				if (stack.Count == arrayRank)
				{
					try
					{
						if (ReadForType(reader, contractSafe, converter != null))
						{
							JsonToken tokenType = reader.TokenType;
							if (tokenType == JsonToken.EndArray)
							{
								stack.Pop();
								list2 = stack.Peek();
								num = null;
							}
							else
							{
								object value = ((converter == null || !converter.CanRead) ? CreateValueInternal(reader, contract.CollectionItemType, contractSafe, null, contract, containerProperty, null) : DeserializeConvertable(converter, reader, contract.CollectionItemType, null));
								list2.Add(value);
							}
							continue;
						}
					}
					catch (Exception ex)
					{
						JsonPosition position = reader.GetPosition(depth);
						if (IsErrorHandled(list, contract, position.Position, reader as IJsonLineInfo, reader.Path, ex))
						{
							HandleError(reader, readPastError: true, depth);
							if (num.HasValue && num == position.Position)
							{
								throw JsonSerializationException.Create(reader, "Infinite loop detected from error handling.", ex);
							}
							num = position.Position;
							continue;
						}
						throw;
					}
					break;
				}
				if (!reader.Read())
				{
					break;
				}
				switch (reader.TokenType)
				{
				case JsonToken.StartArray:
				{
					IList list3 = new List<object>();
					list2.Add(list3);
					stack.Push(list3);
					list2 = list3;
					break;
				}
				case JsonToken.EndArray:
					stack.Pop();
					if (stack.Count > 0)
					{
						list2 = stack.Peek();
					}
					else
					{
						flag = true;
					}
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing multidimensional array: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag);
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, list, "Unexpected end when deserializing array.");
			}
			OnDeserialized(reader, contract, list);
			return list;
		}

		private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object currentObject, string message)
		{
			try
			{
				throw JsonSerializationException.Create(reader, message);
			}
			catch (Exception ex)
			{
				if (IsErrorHandled(currentObject, contract, null, reader as IJsonLineInfo, reader.Path, ex))
				{
					HandleError(reader, readPastError: false, 0);
					return;
				}
				throw;
			}
		}

		private object PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id)
		{
			object obj = ((list is IWrappedCollection wrappedCollection) ? wrappedCollection.UnderlyingCollection : list);
			if (id != null)
			{
				AddReference(reader, id, obj);
			}
			if (list.IsFixedSize)
			{
				reader.Skip();
				return obj;
			}
			OnDeserializing(reader, contract, obj);
			int depth = reader.Depth;
			if (contract.ItemContract == null)
			{
				contract.ItemContract = GetContractSafe(contract.CollectionItemType);
			}
			JsonConverter converter = GetConverter(contract.ItemContract, null, contract, containerProperty);
			int? num = null;
			bool flag = false;
			do
			{
				try
				{
					if (ReadForType(reader, contract.ItemContract, converter != null))
					{
						JsonToken tokenType = reader.TokenType;
						if (tokenType == JsonToken.EndArray)
						{
							flag = true;
							continue;
						}
						object value = ((converter == null || !converter.CanRead) ? CreateValueInternal(reader, contract.CollectionItemType, contract.ItemContract, null, contract, containerProperty, null) : DeserializeConvertable(converter, reader, contract.CollectionItemType, null));
						list.Add(value);
						continue;
					}
				}
				catch (Exception ex)
				{
					JsonPosition position = reader.GetPosition(depth);
					if (IsErrorHandled(obj, contract, position.Position, reader as IJsonLineInfo, reader.Path, ex))
					{
						HandleError(reader, readPastError: true, depth);
						if (num.HasValue && num == position.Position)
						{
							throw JsonSerializationException.Create(reader, "Infinite loop detected from error handling.", ex);
						}
						num = position.Position;
						continue;
					}
					throw;
				}
				break;
			}
			while (!flag);
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, obj, "Unexpected end when deserializing array.");
			}
			OnDeserialized(reader, contract, obj);
			return obj;
		}

		private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty member, string id)
		{
			Type underlyingType = contract.UnderlyingType;
			if (!JsonTypeReflector.FullyTrusted)
			{
				string format = "Type '{0}' implements ISerializable but cannot be deserialized using the ISerializable interface because the current application is not fully trusted and ISerializable can expose secure data." + Environment.NewLine + "To fix this error either change the environment to be fully trusted, change the application to not deserialize the type, add JsonObjectAttribute to the type or change the JsonSerializer setting ContractResolver to use a new DefaultContractResolver with IgnoreSerializableInterface set to true." + Environment.NewLine;
				format = format.FormatWith(CultureInfo.InvariantCulture, underlyingType);
				throw JsonSerializationException.Create(reader, format);
			}
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Deserializing {0} using ISerializable constructor.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			SerializationInfo serializationInfo = new SerializationInfo(contract.UnderlyingType, new JsonFormatterConverter(this, contract, member));
			bool flag = false;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string text = reader.Value.ToString();
					if (!reader.Read())
					{
						throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
					}
					serializationInfo.AddValue(text, JToken.ReadFrom(reader));
					break;
				}
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag && reader.Read());
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, serializationInfo, "Unexpected end when deserializing object.");
			}
			if (contract.ISerializableCreator == null)
			{
				throw JsonSerializationException.Create(reader, "ISerializable type '{0}' does not have a valid constructor. To correctly implement ISerializable a constructor that takes SerializationInfo and StreamingContext parameters should be present.".FormatWith(CultureInfo.InvariantCulture, underlyingType));
			}
			object obj = contract.ISerializableCreator(serializationInfo, Serializer._context);
			if (id != null)
			{
				AddReference(reader, id, obj);
			}
			OnDeserializing(reader, contract, obj);
			OnDeserialized(reader, contract, obj);
			return obj;
		}

		internal object CreateISerializableItem(JToken token, Type type, JsonISerializableContract contract, JsonProperty member)
		{
			JsonContract contractSafe = GetContractSafe(type);
			JsonConverter converter = GetConverter(contractSafe, null, contract, member);
			JsonReader jsonReader = token.CreateReader();
			jsonReader.ReadAndAssert();
			if (converter != null && converter.CanRead)
			{
				return DeserializeConvertable(converter, jsonReader, type, null);
			}
			return CreateValueInternal(jsonReader, type, contractSafe, null, contract, member, null);
		}

		private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor<object> creator, string id)
		{
			ValidationUtils.ArgumentNotNull(creator, "creator");
			bool flag = contract.HasRequiredOrDefaultValueProperties || HasFlag(Serializer._defaultValueHandling, DefaultValueHandling.Populate);
			Type underlyingType = contract.UnderlyingType;
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				string arg = string.Join(", ", contract.CreatorParameters.Select((JsonProperty p) => p.PropertyName).ToArray());
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Deserializing {0} using creator with parameters: {1}.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType, arg)), null);
			}
			List<CreatorPropertyContext> list = ResolvePropertyAndCreatorValues(contract, containerProperty, reader, underlyingType);
			if (flag)
			{
				foreach (JsonProperty property in contract.Properties)
				{
					if (list.All((CreatorPropertyContext p) => p.Property != property))
					{
						list.Add(new CreatorPropertyContext
						{
							Property = property,
							Name = property.PropertyName,
							Presence = PropertyPresence.None
						});
					}
				}
			}
			object[] array = new object[contract.CreatorParameters.Count];
			foreach (CreatorPropertyContext item in list)
			{
				if (flag && item.Property != null && !item.Presence.HasValue)
				{
					object value = item.Value;
					PropertyPresence value2 = ((value == null) ? PropertyPresence.Null : ((!(value is string)) ? PropertyPresence.Value : (CoerceEmptyStringToNull(item.Property.PropertyType, item.Property.PropertyContract, (string)value) ? PropertyPresence.Null : PropertyPresence.Value)));
					item.Presence = value2;
				}
				JsonProperty jsonProperty = item.ConstructorProperty;
				if (jsonProperty == null && item.Property != null)
				{
					jsonProperty = contract.CreatorParameters.ForgivingCaseSensitiveFind((JsonProperty p) => p.PropertyName, item.Property.UnderlyingName);
				}
				if (jsonProperty == null || jsonProperty.Ignored)
				{
					continue;
				}
				if (flag && (item.Presence == PropertyPresence.None || item.Presence == PropertyPresence.Null))
				{
					if (jsonProperty.PropertyContract == null)
					{
						jsonProperty.PropertyContract = GetContractSafe(jsonProperty.PropertyType);
					}
					if (HasFlag(jsonProperty.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate))
					{
						item.Value = EnsureType(reader, jsonProperty.GetResolvedDefaultValue(), CultureInfo.InvariantCulture, jsonProperty.PropertyContract, jsonProperty.PropertyType);
					}
				}
				int num = contract.CreatorParameters.IndexOf(jsonProperty);
				array[num] = item.Value;
				item.Used = true;
			}
			object obj = creator(array);
			if (id != null)
			{
				AddReference(reader, id, obj);
			}
			OnDeserializing(reader, contract, obj);
			foreach (CreatorPropertyContext item2 in list)
			{
				if (item2.Used || item2.Property == null || item2.Property.Ignored || item2.Presence == PropertyPresence.None)
				{
					continue;
				}
				JsonProperty property2 = item2.Property;
				object value3 = item2.Value;
				if (ShouldSetPropertyValue(property2, value3))
				{
					property2.ValueProvider.SetValue(obj, value3);
					item2.Used = true;
				}
				else
				{
					if (property2.Writable || value3 == null)
					{
						continue;
					}
					JsonContract jsonContract = Serializer._contractResolver.ResolveContract(property2.PropertyType);
					if (jsonContract.ContractType == JsonContractType.Array)
					{
						JsonArrayContract jsonArrayContract = (JsonArrayContract)jsonContract;
						object value4 = property2.ValueProvider.GetValue(obj);
						if (value4 != null)
						{
							IWrappedCollection wrappedCollection = jsonArrayContract.CreateWrapper(value4);
							foreach (object item3 in jsonArrayContract.CreateWrapper(value3))
							{
								wrappedCollection.Add(item3);
							}
						}
					}
					else if (jsonContract.ContractType == JsonContractType.Dictionary)
					{
						JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)jsonContract;
						object value5 = property2.ValueProvider.GetValue(obj);
						if (value5 != null)
						{
							object obj2;
							if (!jsonDictionaryContract.ShouldCreateWrapper)
							{
								obj2 = (IDictionary)value5;
							}
							else
							{
								IDictionary dictionary = jsonDictionaryContract.CreateWrapper(value5);
								obj2 = dictionary;
							}
							IDictionary dictionary2 = (IDictionary)obj2;
							object obj3;
							if (!jsonDictionaryContract.ShouldCreateWrapper)
							{
								obj3 = (IDictionary)value3;
							}
							else
							{
								IDictionary dictionary = jsonDictionaryContract.CreateWrapper(value3);
								obj3 = dictionary;
							}
							foreach (DictionaryEntry item4 in (IDictionary)obj3)
							{
								dictionary2.Add(item4.Key, item4.Value);
							}
						}
					}
					item2.Used = true;
				}
			}
			if (contract.ExtensionDataSetter != null)
			{
				foreach (CreatorPropertyContext item5 in list)
				{
					if (!item5.Used)
					{
						contract.ExtensionDataSetter(obj, item5.Name, item5.Value);
					}
				}
			}
			if (flag)
			{
				foreach (CreatorPropertyContext item6 in list)
				{
					if (item6.Property != null)
					{
						EndProcessProperty(obj, reader, contract, reader.Depth, item6.Property, item6.Presence.GetValueOrDefault(), !item6.Used);
					}
				}
			}
			OnDeserialized(reader, contract, obj);
			return obj;
		}

		private object DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object existingValue)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Started deserializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, objectType, converter.GetType())), null);
			}
			object result = converter.ReadJson(reader, objectType, existingValue, GetInternalSerializer());
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Finished deserializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, objectType, converter.GetType())), null);
			}
			return result;
		}

		private List<CreatorPropertyContext> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType)
		{
			List<CreatorPropertyContext> list = new List<CreatorPropertyContext>();
			bool flag = false;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string text = reader.Value.ToString();
					CreatorPropertyContext creatorPropertyContext = new CreatorPropertyContext
					{
						Name = reader.Value.ToString(),
						ConstructorProperty = contract.CreatorParameters.GetClosestMatchProperty(text),
						Property = contract.Properties.GetClosestMatchProperty(text)
					};
					list.Add(creatorPropertyContext);
					JsonProperty jsonProperty = creatorPropertyContext.ConstructorProperty ?? creatorPropertyContext.Property;
					if (jsonProperty != null && !jsonProperty.Ignored)
					{
						if (jsonProperty.PropertyContract == null)
						{
							jsonProperty.PropertyContract = GetContractSafe(jsonProperty.PropertyType);
						}
						JsonConverter converter = GetConverter(jsonProperty.PropertyContract, jsonProperty.MemberConverter, contract, containerProperty);
						if (!ReadForType(reader, jsonProperty.PropertyContract, converter != null))
						{
							throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
						}
						if (converter != null && converter.CanRead)
						{
							creatorPropertyContext.Value = DeserializeConvertable(converter, reader, jsonProperty.PropertyType, null);
						}
						else
						{
							creatorPropertyContext.Value = CreateValueInternal(reader, jsonProperty.PropertyType, jsonProperty.PropertyContract, jsonProperty, contract, containerProperty, null);
						}
						break;
					}
					if (!reader.Read())
					{
						throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
					}
					if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
					{
						TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Could not find member '{0}' on {1}.".FormatWith(CultureInfo.InvariantCulture, text, contract.UnderlyingType)), null);
					}
					if (Serializer._missingMemberHandling == MissingMemberHandling.Error)
					{
						throw JsonSerializationException.Create(reader, "Could not find member '{0}' on object of type '{1}'".FormatWith(CultureInfo.InvariantCulture, text, objectType.Name));
					}
					if (contract.ExtensionDataSetter != null)
					{
						creatorPropertyContext.Value = ReadExtensionDataValue(contract, containerProperty, reader);
					}
					else
					{
						reader.Skip();
					}
					break;
				}
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag && reader.Read());
			return list;
		}

		private bool ReadForType(JsonReader reader, JsonContract contract, bool hasConverter)
		{
			if (hasConverter)
			{
				return reader.Read();
			}
			switch (contract?.InternalReadType ?? ReadType.Read)
			{
			case ReadType.Read:
				return reader.ReadAndMoveToContent();
			case ReadType.ReadAsInt32:
				reader.ReadAsInt32();
				break;
			case ReadType.ReadAsDecimal:
				reader.ReadAsDecimal();
				break;
			case ReadType.ReadAsDouble:
				reader.ReadAsDouble();
				break;
			case ReadType.ReadAsBytes:
				reader.ReadAsBytes();
				break;
			case ReadType.ReadAsBoolean:
				reader.ReadAsBoolean();
				break;
			case ReadType.ReadAsString:
				reader.ReadAsString();
				break;
			case ReadType.ReadAsDateTime:
				reader.ReadAsDateTime();
				break;
			case ReadType.ReadAsDateTimeOffset:
				reader.ReadAsDateTimeOffset();
				break;
			default:
				throw new ArgumentOutOfRangeException();
			}
			return reader.TokenType != JsonToken.None;
		}

		public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, string id, out bool createdFromNonDefaultCreator)
		{
			object obj = null;
			if (objectContract.OverrideCreator != null)
			{
				if (objectContract.CreatorParameters.Count > 0)
				{
					createdFromNonDefaultCreator = true;
					return CreateObjectUsingCreatorWithParameters(reader, objectContract, containerMember, objectContract.OverrideCreator, id);
				}
				obj = objectContract.OverrideCreator();
			}
			else if (objectContract.DefaultCreator != null && (!objectContract.DefaultCreatorNonPublic || Serializer._constructorHandling == ConstructorHandling.AllowNonPublicDefaultConstructor || objectContract.ParameterizedCreator == null))
			{
				obj = objectContract.DefaultCreator();
			}
			else if (objectContract.ParameterizedCreator != null)
			{
				createdFromNonDefaultCreator = true;
				return CreateObjectUsingCreatorWithParameters(reader, objectContract, containerMember, objectContract.ParameterizedCreator, id);
			}
			if (obj == null)
			{
				if (!objectContract.IsInstantiable)
				{
					throw JsonSerializationException.Create(reader, "Could not create an instance of type {0}. Type is an interface or abstract class and cannot be instantiated.".FormatWith(CultureInfo.InvariantCulture, objectContract.UnderlyingType));
				}
				throw JsonSerializationException.Create(reader, "Unable to find a constructor to use for type {0}. A class should either have a default constructor, one constructor with arguments or a constructor marked with the JsonConstructor attribute.".FormatWith(CultureInfo.InvariantCulture, objectContract.UnderlyingType));
			}
			createdFromNonDefaultCreator = false;
			return obj;
		}

		private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, string id)
		{
			OnDeserializing(reader, contract, newObject);
			Dictionary<JsonProperty, PropertyPresence> dictionary = ((contract.HasRequiredOrDefaultValueProperties || HasFlag(Serializer._defaultValueHandling, DefaultValueHandling.Populate)) ? contract.Properties.ToDictionary((JsonProperty m) => m, (JsonProperty m) => PropertyPresence.None) : null);
			if (id != null)
			{
				AddReference(reader, id, newObject);
			}
			int depth = reader.Depth;
			bool flag = false;
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string text = reader.Value.ToString();
					if (CheckPropertyName(reader, text))
					{
						break;
					}
					try
					{
						JsonProperty closestMatchProperty = contract.Properties.GetClosestMatchProperty(text);
						if (closestMatchProperty == null)
						{
							if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
							{
								TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(reader as IJsonLineInfo, reader.Path, "Could not find member '{0}' on {1}".FormatWith(CultureInfo.InvariantCulture, text, contract.UnderlyingType)), null);
							}
							if (Serializer._missingMemberHandling == MissingMemberHandling.Error)
							{
								throw JsonSerializationException.Create(reader, "Could not find member '{0}' on object of type '{1}'".FormatWith(CultureInfo.InvariantCulture, text, contract.UnderlyingType.Name));
							}
							if (reader.Read())
							{
								SetExtensionData(contract, member, reader, text, newObject);
							}
							break;
						}
						if (closestMatchProperty.Ignored || !ShouldDeserialize(reader, closestMatchProperty, newObject))
						{
							if (reader.Read())
							{
								SetPropertyPresence(reader, closestMatchProperty, dictionary);
								SetExtensionData(contract, member, reader, text, newObject);
							}
							break;
						}
						if (closestMatchProperty.PropertyContract == null)
						{
							closestMatchProperty.PropertyContract = GetContractSafe(closestMatchProperty.PropertyType);
						}
						JsonConverter converter = GetConverter(closestMatchProperty.PropertyContract, closestMatchProperty.MemberConverter, contract, member);
						if (!ReadForType(reader, closestMatchProperty.PropertyContract, converter != null))
						{
							throw JsonSerializationException.Create(reader, "Unexpected end when setting {0}'s value.".FormatWith(CultureInfo.InvariantCulture, text));
						}
						SetPropertyPresence(reader, closestMatchProperty, dictionary);
						if (!SetPropertyValue(closestMatchProperty, converter, contract, member, reader, newObject))
						{
							SetExtensionData(contract, member, reader, text, newObject);
						}
					}
					catch (Exception ex)
					{
						if (IsErrorHandled(newObject, contract, text, reader as IJsonLineInfo, reader.Path, ex))
						{
							HandleError(reader, readPastError: true, depth);
							break;
						}
						throw;
					}
					break;
				}
				case JsonToken.EndObject:
					flag = true;
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when deserializing object: " + reader.TokenType);
				case JsonToken.Comment:
					break;
				}
			}
			while (!flag && reader.Read());
			if (!flag)
			{
				ThrowUnexpectedEndException(reader, contract, newObject, "Unexpected end when deserializing object.");
			}
			if (dictionary != null)
			{
				foreach (KeyValuePair<JsonProperty, PropertyPresence> item in dictionary)
				{
					JsonProperty key = item.Key;
					PropertyPresence value = item.Value;
					EndProcessProperty(newObject, reader, contract, depth, key, value, setDefaultValue: true);
				}
			}
			OnDeserialized(reader, contract, newObject);
			return newObject;
		}

		private bool ShouldDeserialize(JsonReader reader, JsonProperty property, object target)
		{
			if (property.ShouldDeserialize == null)
			{
				return true;
			}
			bool flag = property.ShouldDeserialize(target);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, reader.Path, "ShouldDeserialize result for property '{0}' on {1}: {2}".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType, flag)), null);
			}
			return flag;
		}

		private bool CheckPropertyName(JsonReader reader, string memberName)
		{
			if (Serializer.MetadataPropertyHandling == MetadataPropertyHandling.ReadAhead)
			{
				switch (memberName)
				{
				case "$id":
				case "$ref":
				case "$type":
				case "$values":
					reader.Skip();
					return true;
				}
			}
			return false;
		}

		private void SetExtensionData(JsonObjectContract contract, JsonProperty member, JsonReader reader, string memberName, object o)
		{
			if (contract.ExtensionDataSetter != null)
			{
				try
				{
					object value = ReadExtensionDataValue(contract, member, reader);
					contract.ExtensionDataSetter(o, memberName, value);
					return;
				}
				catch (Exception ex)
				{
					throw JsonSerializationException.Create(reader, "Error setting value in extension data for type '{0}'.".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType), ex);
				}
			}
			reader.Skip();
		}

		private object ReadExtensionDataValue(JsonObjectContract contract, JsonProperty member, JsonReader reader)
		{
			if (contract.ExtensionDataIsJToken)
			{
				return JToken.ReadFrom(reader);
			}
			return CreateValueInternal(reader, null, null, null, contract, member, null);
		}

		private void EndProcessProperty(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, JsonProperty property, PropertyPresence presence, bool setDefaultValue)
		{
			if (presence != PropertyPresence.None && presence != PropertyPresence.Null)
			{
				return;
			}
			try
			{
				Required required = property._required ?? contract.ItemRequired ?? Required.Default;
				switch (presence)
				{
				case PropertyPresence.None:
					if (required == Required.AllowNull || required == Required.Always)
					{
						throw JsonSerializationException.Create(reader, "Required property '{0}' not found in JSON.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName));
					}
					if (setDefaultValue && !property.Ignored)
					{
						if (property.PropertyContract == null)
						{
							property.PropertyContract = GetContractSafe(property.PropertyType);
						}
						if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Populate) && property.Writable)
						{
							property.ValueProvider.SetValue(newObject, EnsureType(reader, property.GetResolvedDefaultValue(), CultureInfo.InvariantCulture, property.PropertyContract, property.PropertyType));
						}
					}
					break;
				case PropertyPresence.Null:
					switch (required)
					{
					case Required.Always:
						throw JsonSerializationException.Create(reader, "Required property '{0}' expects a value but got null.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName));
					case Required.DisallowNull:
						throw JsonSerializationException.Create(reader, "Required property '{0}' expects a non-null value.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName));
					}
					break;
				}
			}
			catch (Exception ex)
			{
				if (IsErrorHandled(newObject, contract, property.PropertyName, reader as IJsonLineInfo, reader.Path, ex))
				{
					HandleError(reader, readPastError: true, initialDepth);
					return;
				}
				throw;
			}
		}

		private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary<JsonProperty, PropertyPresence> requiredProperties)
		{
			if (property != null && requiredProperties != null)
			{
				PropertyPresence value;
				switch (reader.TokenType)
				{
				case JsonToken.String:
					value = (CoerceEmptyStringToNull(property.PropertyType, property.PropertyContract, (string)reader.Value) ? PropertyPresence.Null : PropertyPresence.Value);
					break;
				case JsonToken.Null:
				case JsonToken.Undefined:
					value = PropertyPresence.Null;
					break;
				default:
					value = PropertyPresence.Value;
					break;
				}
				requiredProperties[property] = value;
			}
		}

		private void HandleError(JsonReader reader, bool readPastError, int initialDepth)
		{
			ClearErrorContext();
			if (readPastError)
			{
				reader.Skip();
				while (reader.Depth > initialDepth + 1 && reader.Read())
				{
				}
			}
		}
	}
	[Preserve]
	internal class JsonSerializerInternalWriter : JsonSerializerInternalBase
	{
		private Type _rootType;

		private int _rootLevel;

		private readonly List<object> _serializeStack = new List<object>();

		public JsonSerializerInternalWriter(JsonSerializer serializer)
			: base(serializer)
		{
		}

		public void Serialize(JsonWriter jsonWriter, object value, Type objectType)
		{
			if (jsonWriter == null)
			{
				throw new ArgumentNullException("jsonWriter");
			}
			_rootType = objectType;
			_rootLevel = _serializeStack.Count + 1;
			JsonContract contractSafe = GetContractSafe(value);
			try
			{
				if (ShouldWriteReference(value, null, contractSafe, null, null))
				{
					WriteReference(jsonWriter, value);
				}
				else
				{
					SerializeValue(jsonWriter, value, contractSafe, null, null, null);
				}
			}
			catch (Exception ex)
			{
				if (IsErrorHandled(null, contractSafe, null, null, jsonWriter.Path, ex))
				{
					HandleError(jsonWriter, 0);
					return;
				}
				ClearErrorContext();
				throw;
			}
			finally
			{
				_rootType = null;
			}
		}

		private JsonSerializerProxy GetInternalSerializer()
		{
			if (InternalSerializer == null)
			{
				InternalSerializer = new JsonSerializerProxy(this);
			}
			return InternalSerializer;
		}

		private JsonContract GetContractSafe(object value)
		{
			if (value == null)
			{
				return null;
			}
			return Serializer._contractResolver.ResolveContract(value.GetType());
		}

		private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
		{
			if (contract.TypeCode == PrimitiveTypeCode.Bytes && ShouldWriteType(TypeNameHandling.Objects, contract, member, containerContract, containerProperty))
			{
				writer.WriteStartObject();
				WriteTypeProperty(writer, contract.CreatedType);
				writer.WritePropertyName("$value", escape: false);
				JsonWriter.WriteValue(writer, contract.TypeCode, value);
				writer.WriteEndObject();
			}
			else
			{
				JsonWriter.WriteValue(writer, contract.TypeCode, value);
			}
		}

		private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			JsonConverter jsonConverter = member?.Converter ?? containerProperty?.ItemConverter ?? containerContract?.ItemConverter ?? valueContract.Converter ?? Serializer.GetMatchingConverter(valueContract.UnderlyingType) ?? valueContract.InternalConverter;
			if (jsonConverter != null && jsonConverter.CanWrite)
			{
				SerializeConvertable(writer, jsonConverter, value, valueContract, containerContract, containerProperty);
				return;
			}
			switch (valueContract.ContractType)
			{
			case JsonContractType.Object:
				SerializeObject(writer, value, (JsonObjectContract)valueContract, member, containerContract, containerProperty);
				break;
			case JsonContractType.Array:
			{
				JsonArrayContract jsonArrayContract = (JsonArrayContract)valueContract;
				if (!jsonArrayContract.IsMultidimensionalArray)
				{
					SerializeList(writer, (IEnumerable)value, jsonArrayContract, member, containerContract, containerProperty);
				}
				else
				{
					SerializeMultidimensionalArray(writer, (Array)value, jsonArrayContract, member, containerContract, containerProperty);
				}
				break;
			}
			case JsonContractType.Primitive:
				SerializePrimitive(writer, value, (JsonPrimitiveContract)valueContract, member, containerContract, containerProperty);
				break;
			case JsonContractType.String:
				SerializeString(writer, value, (JsonStringContract)valueContract);
				break;
			case JsonContractType.Dictionary:
			{
				JsonDictionaryContract jsonDictionaryContract = (JsonDictionaryContract)valueContract;
				object values;
				if (!(value is IDictionary))
				{
					IDictionary dictionary = jsonDictionaryContract.CreateWrapper(value);
					values = dictionary;
				}
				else
				{
					values = (IDictionary)value;
				}
				SerializeDictionary(writer, (IDictionary)values, jsonDictionaryContract, member, containerContract, containerProperty);
				break;
			}
			case JsonContractType.Serializable:
				SerializeISerializable(writer, (ISerializable)value, (JsonISerializableContract)valueContract, member, containerContract, containerProperty);
				break;
			case JsonContractType.Linq:
				((JToken)value).WriteTo(writer, Serializer.Converters.ToArray());
				break;
			case JsonContractType.Dynamic:
				break;
			}
		}

		private bool? ResolveIsReference(JsonContract contract, JsonProperty property, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			bool? result = null;
			if (property != null)
			{
				result = property.IsReference;
			}
			if (!result.HasValue && containerProperty != null)
			{
				result = containerProperty.ItemIsReference;
			}
			if (!result.HasValue && collectionContract != null)
			{
				result = collectionContract.ItemIsReference;
			}
			if (!result.HasValue)
			{
				result = contract.IsReference;
			}
			return result;
		}

		private bool ShouldWriteReference(object value, JsonProperty property, JsonContract valueContract, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			if (value == null)
			{
				return false;
			}
			if (valueContract.ContractType == JsonContractType.Primitive || valueContract.ContractType == JsonContractType.String)
			{
				return false;
			}
			bool? flag = ResolveIsReference(valueContract, property, collectionContract, containerProperty);
			if (!flag.HasValue)
			{
				flag = ((valueContract.ContractType != JsonContractType.Array) ? new bool?(HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Objects)) : new bool?(HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Arrays)));
			}
			if (flag != true)
			{
				return false;
			}
			return Serializer.GetReferenceResolver().IsReferenced(this, value);
		}

		private bool ShouldWriteProperty(object memberValue, JsonProperty property)
		{
			if (property.NullValueHandling.GetValueOrDefault(Serializer._nullValueHandling) == NullValueHandling.Ignore && memberValue == null)
			{
				return false;
			}
			if (HasFlag(property.DefaultValueHandling.GetValueOrDefault(Serializer._defaultValueHandling), DefaultValueHandling.Ignore) && MiscellaneousUtils.ValueEquals(memberValue, property.GetResolvedDefaultValue()))
			{
				return false;
			}
			return true;
		}

		private bool CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty)
		{
			if (value == null || contract.ContractType == JsonContractType.Primitive || contract.ContractType == JsonContractType.String)
			{
				return true;
			}
			ReferenceLoopHandling? referenceLoopHandling = null;
			if (property != null)
			{
				referenceLoopHandling = property.ReferenceLoopHandling;
			}
			if (!referenceLoopHandling.HasValue && containerProperty != null)
			{
				referenceLoopHandling = containerProperty.ItemReferenceLoopHandling;
			}
			if (!referenceLoopHandling.HasValue && containerContract != null)
			{
				referenceLoopHandling = containerContract.ItemReferenceLoopHandling;
			}
			if ((Serializer._equalityComparer != null) ? _serializeStack.Contains(value, Serializer._equalityComparer) : _serializeStack.Contains(value))
			{
				string text = "Self referencing loop detected";
				if (property != null)
				{
					text += " for property '{0}'".FormatWith(CultureInfo.InvariantCulture, property.PropertyName);
				}
				text += " with type '{0}'.".FormatWith(CultureInfo.InvariantCulture, value.GetType());
				switch (referenceLoopHandling.GetValueOrDefault(Serializer._referenceLoopHandling))
				{
				case ReferenceLoopHandling.Error:
					throw JsonSerializationException.Create(null, writer.ContainerPath, text, null);
				case ReferenceLoopHandling.Ignore:
					if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
					{
						TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, text + ". Skipping serializing self referenced value."), null);
					}
					return false;
				case ReferenceLoopHandling.Serialize:
					if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
					{
						TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, text + ". Serializing self referenced value."), null);
					}
					return true;
				}
			}
			return true;
		}

		private void WriteReference(JsonWriter writer, object value)
		{
			string reference = GetReference(writer, value);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Writing object reference to Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, reference, value.GetType())), null);
			}
			writer.WriteStartObject();
			writer.WritePropertyName("$ref", escape: false);
			writer.WriteValue(reference);
			writer.WriteEndObject();
		}

		private string GetReference(JsonWriter writer, object value)
		{
			try
			{
				return Serializer.GetReferenceResolver().GetReference(this, value);
			}
			catch (Exception ex)
			{
				throw JsonSerializationException.Create(null, writer.ContainerPath, "Error writing object reference for '{0}'.".FormatWith(CultureInfo.InvariantCulture, value.GetType()), ex);
			}
		}

		internal static bool TryConvertToString(object value, Type type, out string s)
		{
			TypeConverter converter = ConvertUtils.GetConverter(type);
			if (converter != null && !(converter is ComponentConverter) && (object)converter.GetType() != typeof(TypeConverter) && converter.CanConvertTo(typeof(string)))
			{
				s = converter.ConvertToInvariantString(value);
				return true;
			}
			if (value is Type)
			{
				s = ((Type)value).AssemblyQualifiedName;
				return true;
			}
			s = null;
			return false;
		}

		private void SerializeString(JsonWriter writer, object value, JsonStringContract contract)
		{
			OnSerializing(writer, contract, value);
			TryConvertToString(value, contract.UnderlyingType, out var s);
			writer.WriteValue(s);
			OnSerialized(writer, contract, value);
		}

		private void OnSerializing(JsonWriter writer, JsonContract contract, object value)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Started serializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			contract.InvokeOnSerializing(value, Serializer._context);
		}

		private void OnSerialized(JsonWriter writer, JsonContract contract, object value)
		{
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
			{
				TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Finished serializing {0}".FormatWith(CultureInfo.InvariantCulture, contract.UnderlyingType)), null);
			}
			contract.InvokeOnSerialized(value, Serializer._context);
		}

		private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			OnSerializing(writer, contract, value);
			_serializeStack.Add(value);
			WriteObjectStart(writer, value, contract, member, collectionContract, containerProperty);
			int top = writer.Top;
			for (int i = 0; i < contract.Properties.Count; i++)
			{
				JsonProperty jsonProperty = contract.Properties[i];
				try
				{
					if (CalculatePropertyValues(writer, value, contract, member, jsonProperty, out var memberContract, out var memberValue))
					{
						jsonProperty.WritePropertyName(writer);
						SerializeValue(writer, memberValue, memberContract, jsonProperty, contract, member);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(value, contract, jsonProperty.PropertyName, null, writer.ContainerPath, ex))
					{
						HandleError(writer, top);
						continue;
					}
					throw;
				}
			}
			if (contract.ExtensionDataGetter != null)
			{
				IEnumerable<KeyValuePair<object, object>> enumerable = contract.ExtensionDataGetter(value);
				if (enumerable != null)
				{
					foreach (KeyValuePair<object, object> item in enumerable)
					{
						JsonContract contractSafe = GetContractSafe(item.Key);
						JsonContract contractSafe2 = GetContractSafe(item.Value);
						bool escape;
						string propertyName = GetPropertyName(writer, item.Key, contractSafe, out escape);
						if (ShouldWriteReference(item.Value, null, contractSafe2, contract, member))
						{
							writer.WritePropertyName(propertyName);
							WriteReference(writer, item.Value);
						}
						else if (CheckForCircularReference(writer, item.Value, null, contractSafe2, contract, member))
						{
							writer.WritePropertyName(propertyName);
							SerializeValue(writer, item.Value, contractSafe2, null, contract, member);
						}
					}
				}
			}
			writer.WriteEndObject();
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, value);
		}

		private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty member, JsonProperty property, out JsonContract memberContract, out object memberValue)
		{
			if (!property.Ignored && property.Readable && ShouldSerialize(writer, property, value) && IsSpecified(writer, property, value))
			{
				if (property.PropertyContract == null)
				{
					property.PropertyContract = Serializer._contractResolver.ResolveContract(property.PropertyType);
				}
				memberValue = property.ValueProvider.GetValue(value);
				memberContract = (property.PropertyContract.IsSealed ? property.PropertyContract : GetContractSafe(memberValue));
				if (ShouldWriteProperty(memberValue, property))
				{
					if (ShouldWriteReference(memberValue, property, memberContract, contract, member))
					{
						property.WritePropertyName(writer);
						WriteReference(writer, memberValue);
						return false;
					}
					if (!CheckForCircularReference(writer, memberValue, property, memberContract, contract, member))
					{
						return false;
					}
					if (memberValue == null)
					{
						JsonObjectContract jsonObjectContract = contract as JsonObjectContract;
						switch (property._required ?? jsonObjectContract?.ItemRequired ?? Required.Default)
						{
						case Required.Always:
							throw JsonSerializationException.Create(null, writer.ContainerPath, "Cannot write a null value for property '{0}'. Property requires a value.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName), null);
						case Required.DisallowNull:
							throw JsonSerializationException.Create(null, writer.ContainerPath, "Cannot write a null value for property '{0}'. Property requires a non-null value.".FormatWith(CultureInfo.InvariantCulture, property.PropertyName), null);
						}
					}
					return true;
				}
			}
			memberContract = null;
			memberValue = null;
			return false;
		}

		private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			writer.WriteStartObject();
			if ((ResolveIsReference(contract, member, collectionContract, containerProperty) ?? HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Objects)) && (member == null || member.Writable))
			{
				WriteReferenceIdProperty(writer, contract.UnderlyingType, value);
			}
			if (ShouldWriteType(TypeNameHandling.Objects, contract, member, collectionContract, containerProperty))
			{
				WriteTypeProperty(writer, contract.UnderlyingType);
			}
		}

		private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value)
		{
			string reference = GetReference(writer, value);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "Writing object reference Id '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, reference, type)), null);
			}
			writer.WritePropertyName("$id", escape: false);
			writer.WriteValue(reference);
		}

		private void WriteTypeProperty(JsonWriter writer, Type type)
		{
			string typeName = ReflectionUtils.GetTypeName(type, Serializer._typeNameAssemblyFormat, Serializer._binder);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "Writing type name '{0}' for {1}.".FormatWith(CultureInfo.InvariantCulture, typeName, type)), null);
			}
			writer.WritePropertyName("$type", escape: false);
			writer.WriteValue(typeName);
		}

		private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag)
		{
			return (value & flag) == flag;
		}

		private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag)
		{
			return (value & flag) == flag;
		}

		private bool HasFlag(TypeNameHandling value, TypeNameHandling flag)
		{
			return (value & flag) == flag;
		}

		private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			if (ShouldWriteReference(value, null, contract, collectionContract, containerProperty))
			{
				WriteReference(writer, value);
			}
			else if (CheckForCircularReference(writer, value, null, contract, collectionContract, containerProperty))
			{
				_serializeStack.Add(value);
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
				{
					TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Started serializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, value.GetType(), converter.GetType())), null);
				}
				converter.WriteJson(writer, value, GetInternalSerializer());
				if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Info)
				{
					TraceWriter.Trace(TraceLevel.Info, JsonPosition.FormatMessage(null, writer.Path, "Finished serializing {0} with converter {1}.".FormatWith(CultureInfo.InvariantCulture, value.GetType(), converter.GetType())), null);
				}
				_serializeStack.RemoveAt(_serializeStack.Count - 1);
			}
		}

		private void SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			object obj = ((values is IWrappedCollection wrappedCollection) ? wrappedCollection.UnderlyingCollection : values);
			OnSerializing(writer, contract, obj);
			_serializeStack.Add(obj);
			bool flag = WriteStartArray(writer, obj, contract, member, collectionContract, containerProperty);
			writer.WriteStartArray();
			int top = writer.Top;
			int num = 0;
			foreach (object value in values)
			{
				try
				{
					JsonContract jsonContract = contract.FinalItemContract ?? GetContractSafe(value);
					if (ShouldWriteReference(value, null, jsonContract, contract, member))
					{
						WriteReference(writer, value);
					}
					else if (CheckForCircularReference(writer, value, null, jsonContract, contract, member))
					{
						SerializeValue(writer, value, jsonContract, null, contract, member);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(obj, contract, num, null, writer.ContainerPath, ex))
					{
						HandleError(writer, top);
						continue;
					}
					throw;
				}
				finally
				{
					num++;
				}
			}
			writer.WriteEndArray();
			if (flag)
			{
				writer.WriteEndObject();
			}
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, obj);
		}

		private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			OnSerializing(writer, contract, values);
			_serializeStack.Add(values);
			bool num = WriteStartArray(writer, values, contract, member, collectionContract, containerProperty);
			SerializeMultidimensionalArray(writer, values, contract, member, writer.Top, new int[0]);
			if (num)
			{
				writer.WriteEndObject();
			}
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, values);
		}

		private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, int[] indices)
		{
			int num = indices.Length;
			int[] array = new int[num + 1];
			for (int i = 0; i < num; i++)
			{
				array[i] = indices[i];
			}
			writer.WriteStartArray();
			for (int j = values.GetLowerBound(num); j <= values.GetUpperBound(num); j++)
			{
				array[num] = j;
				if (array.Length == values.Rank)
				{
					object value = values.GetValue(array);
					try
					{
						JsonContract jsonContract = contract.FinalItemContract ?? GetContractSafe(value);
						if (ShouldWriteReference(value, null, jsonContract, contract, member))
						{
							WriteReference(writer, value);
						}
						else if (CheckForCircularReference(writer, value, null, jsonContract, contract, member))
						{
							SerializeValue(writer, value, jsonContract, null, contract, member);
						}
					}
					catch (Exception ex)
					{
						if (IsErrorHandled(values, contract, j, null, writer.ContainerPath, ex))
						{
							HandleError(writer, initialDepth + 1);
							continue;
						}
						throw;
					}
				}
				else
				{
					SerializeMultidimensionalArray(writer, values, contract, member, initialDepth + 1, array);
				}
			}
			writer.WriteEndArray();
		}

		private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
		{
			bool flag = (ResolveIsReference(contract, member, containerContract, containerProperty) ?? HasFlag(Serializer._preserveReferencesHandling, PreserveReferencesHandling.Arrays)) && (member?.Writable ?? true);
			bool flag2 = ShouldWriteType(TypeNameHandling.Arrays, contract, member, containerContract, containerProperty);
			bool num = flag || flag2;
			if (num)
			{
				writer.WriteStartObject();
				if (flag)
				{
					WriteReferenceIdProperty(writer, contract.UnderlyingType, values);
				}
				if (flag2)
				{
					WriteTypeProperty(writer, values.GetType());
				}
				writer.WritePropertyName("$values", escape: false);
			}
			if (contract.ItemContract == null)
			{
				contract.ItemContract = Serializer._contractResolver.ResolveContract(contract.CollectionItemType ?? typeof(object));
			}
			return num;
		}

		private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			if (!JsonTypeReflector.FullyTrusted)
			{
				string format = "Type '{0}' implements ISerializable but cannot be serialized using the ISerializable interface because the current application is not fully trusted and ISerializable can expose secure data." + Environment.NewLine + "To fix this error either change the environment to be fully trusted, change the application to not deserialize the type, add JsonObjectAttribute to the type or change the JsonSerializer setting ContractResolver to use a new DefaultContractResolver with IgnoreSerializableInterface set to true." + Environment.NewLine;
				format = format.FormatWith(CultureInfo.InvariantCulture, value.GetType());
				throw JsonSerializationException.Create(null, writer.ContainerPath, format, null);
			}
			OnSerializing(writer, contract, value);
			_serializeStack.Add(value);
			WriteObjectStart(writer, value, contract, member, collectionContract, containerProperty);
			SerializationInfo serializationInfo = new SerializationInfo(contract.UnderlyingType, new FormatterConverter());
			value.GetObjectData(serializationInfo, Serializer._context);
			SerializationInfoEnumerator enumerator = serializationInfo.GetEnumerator();
			while (enumerator.MoveNext())
			{
				SerializationEntry current = enumerator.Current;
				JsonContract contractSafe = GetContractSafe(current.Value);
				if (ShouldWriteReference(current.Value, null, contractSafe, contract, member))
				{
					writer.WritePropertyName(current.Name);
					WriteReference(writer, current.Value);
				}
				else if (CheckForCircularReference(writer, current.Value, null, contractSafe, contract, member))
				{
					writer.WritePropertyName(current.Name);
					SerializeValue(writer, current.Value, contractSafe, null, contract, member);
				}
			}
			writer.WriteEndObject();
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, value);
		}

		private bool ShouldWriteDynamicProperty(object memberValue)
		{
			if (Serializer._nullValueHandling == NullValueHandling.Ignore && memberValue == null)
			{
				return false;
			}
			if (HasFlag(Serializer._defaultValueHandling, DefaultValueHandling.Ignore) && (memberValue == null || MiscellaneousUtils.ValueEquals(memberValue, ReflectionUtils.GetDefaultValue(memberValue.GetType()))))
			{
				return false;
			}
			return true;
		}

		private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty)
		{
			TypeNameHandling value = member?.TypeNameHandling ?? containerProperty?.ItemTypeNameHandling ?? containerContract?.ItemTypeNameHandling ?? Serializer._typeNameHandling;
			if (HasFlag(value, typeNameHandlingFlag))
			{
				return true;
			}
			if (HasFlag(value, TypeNameHandling.Auto))
			{
				if (member != null)
				{
					if ((object)contract.UnderlyingType != member.PropertyContract.CreatedType)
					{
						return true;
					}
				}
				else if (containerContract != null)
				{
					if (containerContract.ItemContract == null || (object)contract.UnderlyingType != containerContract.ItemContract.CreatedType)
					{
						return true;
					}
				}
				else if ((object)_rootType != null && _serializeStack.Count == _rootLevel)
				{
					JsonContract jsonContract = Serializer._contractResolver.ResolveContract(_rootType);
					if ((object)contract.UnderlyingType != jsonContract.CreatedType)
					{
						return true;
					}
				}
			}
			return false;
		}

		private void SerializeDictionary(JsonWriter writer, IDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
		{
			object obj = ((values is IWrappedDictionary wrappedDictionary) ? wrappedDictionary.UnderlyingDictionary : values);
			OnSerializing(writer, contract, obj);
			_serializeStack.Add(obj);
			WriteObjectStart(writer, obj, contract, member, collectionContract, containerProperty);
			if (contract.ItemContract == null)
			{
				contract.ItemContract = Serializer._contractResolver.ResolveContract(contract.DictionaryValueType ?? typeof(object));
			}
			if (contract.KeyContract == null)
			{
				contract.KeyContract = Serializer._contractResolver.ResolveContract(contract.DictionaryKeyType ?? typeof(object));
			}
			int top = writer.Top;
			foreach (DictionaryEntry value2 in values)
			{
				string propertyName = GetPropertyName(writer, value2.Key, contract.KeyContract, out var escape);
				propertyName = ((contract.DictionaryKeyResolver != null) ? contract.DictionaryKeyResolver(propertyName) : propertyName);
				try
				{
					object value = value2.Value;
					JsonContract jsonContract = contract.FinalItemContract ?? GetContractSafe(value);
					if (ShouldWriteReference(value, null, jsonContract, contract, member))
					{
						writer.WritePropertyName(propertyName, escape);
						WriteReference(writer, value);
					}
					else if (CheckForCircularReference(writer, value, null, jsonContract, contract, member))
					{
						writer.WritePropertyName(propertyName, escape);
						SerializeValue(writer, value, jsonContract, null, contract, member);
					}
				}
				catch (Exception ex)
				{
					if (IsErrorHandled(obj, contract, propertyName, null, writer.ContainerPath, ex))
					{
						HandleError(writer, top);
						continue;
					}
					throw;
				}
			}
			writer.WriteEndObject();
			_serializeStack.RemoveAt(_serializeStack.Count - 1);
			OnSerialized(writer, contract, obj);
		}

		private string GetPropertyName(JsonWriter writer, object name, JsonContract contract, out bool escape)
		{
			if (contract.ContractType == JsonContractType.Primitive)
			{
				JsonPrimitiveContract jsonPrimitiveContract = (JsonPrimitiveContract)contract;
				if (jsonPrimitiveContract.TypeCode == PrimitiveTypeCode.DateTime || jsonPrimitiveContract.TypeCode == PrimitiveTypeCode.DateTimeNullable)
				{
					DateTime value = DateTimeUtils.EnsureDateTime((DateTime)name, writer.DateTimeZoneHandling);
					escape = false;
					StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
					DateTimeUtils.WriteDateTimeString(stringWriter, value, writer.DateFormatHandling, writer.DateFormatString, writer.Culture);
					return stringWriter.ToString();
				}
				if (jsonPrimitiveContract.TypeCode == PrimitiveTypeCode.DateTimeOffset || jsonPrimitiveContract.TypeCode == PrimitiveTypeCode.DateTimeOffsetNullable)
				{
					escape = false;
					StringWriter stringWriter2 = new StringWriter(CultureInfo.InvariantCulture);
					DateTimeUtils.WriteDateTimeOffsetString(stringWriter2, (DateTimeOffset)name, writer.DateFormatHandling, writer.DateFormatString, writer.Culture);
					return stringWriter2.ToString();
				}
				escape = true;
				return Convert.ToString(name, CultureInfo.InvariantCulture);
			}
			if (TryConvertToString(name, name.GetType(), out var s))
			{
				escape = true;
				return s;
			}
			escape = true;
			return name.ToString();
		}

		private void HandleError(JsonWriter writer, int initialDepth)
		{
			ClearErrorContext();
			if (writer.WriteState == WriteState.Property)
			{
				writer.WriteNull();
			}
			while (writer.Top > initialDepth)
			{
				writer.WriteEnd();
			}
		}

		private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target)
		{
			if (property.ShouldSerialize == null)
			{
				return true;
			}
			bool flag = property.ShouldSerialize(target);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "ShouldSerialize result for property '{0}' on {1}: {2}".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType, flag)), null);
			}
			return flag;
		}

		private bool IsSpecified(JsonWriter writer, JsonProperty property, object target)
		{
			if (property.GetIsSpecified == null)
			{
				return true;
			}
			bool flag = property.GetIsSpecified(target);
			if (TraceWriter != null && TraceWriter.LevelFilter >= TraceLevel.Verbose)
			{
				TraceWriter.Trace(TraceLevel.Verbose, JsonPosition.FormatMessage(null, writer.Path, "IsSpecified result for property '{0}' on {1}: {2}".FormatWith(CultureInfo.InvariantCulture, property.PropertyName, property.DeclaringType, flag)), null);
			}
			return flag;
		}
	}
	[Preserve]
	internal class JsonSerializerProxy : JsonSerializer
	{
		private readonly JsonSerializerInternalReader _serializerReader;

		private readonly JsonSerializerInternalWriter _serializerWriter;

		private readonly JsonSerializer _serializer;

		public override IReferenceResolver ReferenceResolver
		{
			get
			{
				return _serializer.ReferenceResolver;
			}
			set
			{
				_serializer.ReferenceResolver = value;
			}
		}

		public override ITraceWriter TraceWriter
		{
			get
			{
				return _serializer.TraceWriter;
			}
			set
			{
				_serializer.TraceWriter = value;
			}
		}

		public override IEqualityComparer EqualityComparer
		{
			get
			{
				return _serializer.EqualityComparer;
			}
			set
			{
				_serializer.EqualityComparer = value;
			}
		}

		public override JsonConverterCollection Converters => _serializer.Converters;

		public override DefaultValueHandling DefaultValueHandling
		{
			get
			{
				return _serializer.DefaultValueHandling;
			}
			set
			{
				_serializer.DefaultValueHandling = value;
			}
		}

		public override IContractResolver ContractResolver
		{
			get
			{
				return _serializer.ContractResolver;
			}
			set
			{
				_serializer.ContractResolver = value;
			}
		}

		public override MissingMemberHandling MissingMemberHandling
		{
			get
			{
				return _serializer.MissingMemberHandling;
			}
			set
			{
				_serializer.MissingMemberHandling = value;
			}
		}

		public override NullValueHandling NullValueHandling
		{
			get
			{
				return _serializer.NullValueHandling;
			}
			set
			{
				_serializer.NullValueHandling = value;
			}
		}

		public override ObjectCreationHandling ObjectCreationHandling
		{
			get
			{
				return _serializer.ObjectCreationHandling;
			}
			set
			{
				_serializer.ObjectCreationHandling = value;
			}
		}

		public override ReferenceLoopHandling ReferenceLoopHandling
		{
			get
			{
				return _serializer.ReferenceLoopHandling;
			}
			set
			{
				_serializer.ReferenceLoopHandling = value;
			}
		}

		public override PreserveReferencesHandling PreserveReferencesHandling
		{
			get
			{
				return _serializer.PreserveReferencesHandling;
			}
			set
			{
				_serializer.PreserveReferencesHandling = value;
			}
		}

		public override TypeNameHandling TypeNameHandling
		{
			get
			{
				return _serializer.TypeNameHandling;
			}
			set
			{
				_serializer.TypeNameHandling = value;
			}
		}

		public override MetadataPropertyHandling MetadataPropertyHandling
		{
			get
			{
				return _serializer.MetadataPropertyHandling;
			}
			set
			{
				_serializer.MetadataPropertyHandling = value;
			}
		}

		public override FormatterAssemblyStyle TypeNameAssemblyFormat
		{
			get
			{
				return _serializer.TypeNameAssemblyFormat;
			}
			set
			{
				_serializer.TypeNameAssemblyFormat = value;
			}
		}

		public override ConstructorHandling ConstructorHandling
		{
			get
			{
				return _serializer.ConstructorHandling;
			}
			set
			{
				_serializer.ConstructorHandling = value;
			}
		}

		public override SerializationBinder Binder
		{
			get
			{
				return _serializer.Binder;
			}
			set
			{
				_serializer.Binder = value;
			}
		}

		public override StreamingContext Context
		{
			get
			{
				return _serializer.Context;
			}
			set
			{
				_serializer.Context = value;
			}
		}

		public override Formatting Formatting
		{
			get
			{
				return _serializer.Formatting;
			}
			set
			{
				_serializer.Formatting = value;
			}
		}

		public override DateFormatHandling DateFormatHandling
		{
			get
			{
				return _serializer.DateFormatHandling;
			}
			set
			{
				_serializer.DateFormatHandling = value;
			}
		}

		public override DateTimeZoneHandling DateTimeZoneHandling
		{
			get
			{
				return _serializer.DateTimeZoneHandling;
			}
			set
			{
				_serializer.DateTimeZoneHandling = value;
			}
		}

		public override DateParseHandling DateParseHandling
		{
			get
			{
				return _serializer.DateParseHandling;
			}
			set
			{
				_serializer.DateParseHandling = value;
			}
		}

		public override FloatFormatHandling FloatFormatHandling
		{
			get
			{
				return _serializer.FloatFormatHandling;
			}
			set
			{
				_serializer.FloatFormatHandling = value;
			}
		}

		public override FloatParseHandling FloatParseHandling
		{
			get
			{
				return _serializer.FloatParseHandling;
			}
			set
			{
				_serializer.FloatParseHandling = value;
			}
		}

		public override StringEscapeHandling StringEscapeHandling
		{
			get
			{
				return _serializer.StringEscapeHandling;
			}
			set
			{
				_serializer.StringEscapeHandling = value;
			}
		}

		public override string DateFormatString
		{
			get
			{
				return _serializer.DateFormatString;
			}
			set
			{
				_serializer.DateFormatString = value;
			}
		}

		public override CultureInfo Culture
		{
			get
			{
				return _serializer.Culture;
			}
			set
			{
				_serializer.Culture = value;
			}
		}

		public override int? MaxDepth
		{
			get
			{
				return _serializer.MaxDepth;
			}
			set
			{
				_serializer.MaxDepth = value;
			}
		}

		public override bool CheckAdditionalContent
		{
			get
			{
				return _serializer.CheckAdditionalContent;
			}
			set
			{
				_serializer.CheckAdditionalContent = value;
			}
		}

		public override event EventHandler<ErrorEventArgs> Error
		{
			add
			{
				_serializer.Error += value;
			}
			remove
			{
				_serializer.Error -= value;
			}
		}

		internal JsonSerializerInternalBase GetInternalSerializer()
		{
			if (_serializerReader != null)
			{
				return _serializerReader;
			}
			return _serializerWriter;
		}

		public JsonSerializerProxy(JsonSerializerInternalReader serializerReader)
		{
			ValidationUtils.ArgumentNotNull(serializerReader, "serializerReader");
			_serializerReader = serializerReader;
			_serializer = serializerReader.Serializer;
		}

		public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter)
		{
			ValidationUtils.ArgumentNotNull(serializerWriter, "serializerWriter");
			_serializerWriter = serializerWriter;
			_serializer = serializerWriter.Serializer;
		}

		internal override object DeserializeInternal(JsonReader reader, Type objectType)
		{
			if (_serializerReader != null)
			{
				return _serializerReader.Deserialize(reader, objectType, checkAdditionalContent: false);
			}
			return _serializer.Deserialize(reader, objectType);
		}

		internal override void PopulateInternal(JsonReader reader, object target)
		{
			if (_serializerReader != null)
			{
				_serializerReader.Populate(reader, target);
			}
			else
			{
				_serializer.Populate(reader, target);
			}
		}

		internal override void SerializeInternal(JsonWriter jsonWriter, object value, Type rootType)
		{
			if (_serializerWriter != null)
			{
				_serializerWriter.Serialize(jsonWriter, value, rootType);
			}
			else
			{
				_serializer.Serialize(jsonWriter, value);
			}
		}
	}
	[Preserve]
	public class JsonStringContract : JsonPrimitiveContract
	{
		public JsonStringContract(Type underlyingType)
			: base(underlyingType)
		{
			ContractType = JsonContractType.String;
		}
	}
	[Preserve]
	internal static class JsonTypeReflector
	{
		private static bool? _dynamicCodeGeneration;

		private static bool? _fullyTrusted;

		public const string IdPropertyName = "$id";

		public const string RefPropertyName = "$ref";

		public const string TypePropertyName = "$type";

		public const string ValuePropertyName = "$value";

		public const string ArrayValuesPropertyName = "$values";

		public const string ShouldSerializePrefix = "ShouldSerialize";

		public const string SpecifiedPostfix = "Specified";

		private static readonly ThreadSafeStore<Type, Func<object[], JsonConverter>> JsonConverterCreatorCache = new ThreadSafeStore<Type, Func<object[], JsonConverter>>(GetJsonConverterCreator);

		private static readonly ThreadSafeStore<Type, Type> AssociatedMetadataTypesCache = new ThreadSafeStore<Type, Type>(GetAssociateMetadataTypeFromAttribute);

		private static ReflectionObject _metadataTypeAttributeReflectionObject;

		public static bool DynamicCodeGeneration
		{
			get
			{
				if (!_dynamicCodeGeneration.HasValue)
				{
					try
					{
						new ReflectionPermission(ReflectionPermissionFlag.MemberAccess).Demand();
						new ReflectionPermission(ReflectionPermissionFlag.RestrictedMemberAccess).Demand();
						new SecurityPermission(SecurityPermissionFlag.SkipVerification).Demand();
						new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
						new SecurityPermission(PermissionState.Unrestricted).Demand();
						_dynamicCodeGeneration = true;
					}
					catch (Exception)
					{
						_dynamicCodeGeneration = false;
					}
				}
				return _dynamicCodeGeneration == true;
			}
		}

		public static bool FullyTrusted
		{
			get
			{
				if (!_fullyTrusted.HasValue)
				{
					try
					{
						new SecurityPermission(PermissionState.Unrestricted).Demand();
						_fullyTrusted = true;
					}
					catch (Exception)
					{
						_fullyTrusted = false;
					}
				}
				return _fullyTrusted == true;
			}
		}

		public static ReflectionDelegateFactory ReflectionDelegateFactory => LateBoundReflectionDelegateFactory.Instance;

		public static T GetCachedAttribute<T>(object attributeProvider) where T : Attribute
		{
			return CachedAttributeGetter<T>.GetAttribute(attributeProvider);
		}

		public static DataContractAttribute GetDataContractAttribute(Type type)
		{
			Type type2 = type;
			while ((object)type2 != null)
			{
				DataContractAttribute attribute = CachedAttributeGetter<DataContractAttribute>.GetAttribute(type2);
				if (attribute != null)
				{
					return attribute;
				}
				type2 = type2.BaseType();
			}
			return null;
		}

		public static DataMemberAttribute GetDataMemberAttribute(MemberInfo memberInfo)
		{
			if (memberInfo.MemberType() == MemberTypes.Field)
			{
				return CachedAttributeGetter<DataMemberAttribute>.GetAttribute(memberInfo);
			}
			PropertyInfo propertyInfo = (PropertyInfo)memberInfo;
			DataMemberAttribute attribute = CachedAttributeGetter<DataMemberAttribute>.GetAttribute(propertyInfo);
			if (attribute == null && propertyInfo.IsVirtual())
			{
				Type type = propertyInfo.DeclaringType;
				while (attribute == null && (object)type != null)
				{
					PropertyInfo propertyInfo2 = (PropertyInfo)ReflectionUtils.GetMemberInfoFromType(type, propertyInfo);
					if ((object)propertyInfo2 != null && propertyInfo2.IsVirtual())
					{
						attribute = CachedAttributeGetter<DataMemberAttribute>.GetAttribute(propertyInfo2);
					}
					type = type.BaseType();
				}
			}
			return attribute;
		}

		public static MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute)
		{
			JsonObjectAttribute cachedAttribute = GetCachedAttribute<JsonObjectAttribute>(objectType);
			if (cachedAttribute != null)
			{
				return cachedAttribute.MemberSerialization;
			}
			if (GetDataContractAttribute(objectType) != null)
			{
				return MemberSerialization.OptIn;
			}
			if (!ignoreSerializableAttribute && GetCachedAttribute<SerializableAttribute>(objectType) != null)
			{
				return MemberSerialization.Fields;
			}
			return MemberSerialization.OptOut;
		}

		public static JsonConverter GetJsonConverter(object attributeProvider)
		{
			JsonConverterAttribute cachedAttribute = GetCachedAttribute<JsonConverterAttribute>(attributeProvider);
			if (cachedAttribute != null)
			{
				Func<object[], JsonConverter> func = JsonConverterCreatorCache.Get(cachedAttribute.ConverterType);
				if (func != null)
				{
					return func(cachedAttribute.ConverterParameters);
				}
			}
			return null;
		}

		public static JsonConverter CreateJsonConverterInstance(Type converterType, object[] converterArgs)
		{
			return JsonConverterCreatorCache.Get(converterType)(converterArgs);
		}

		private static Func<object[], JsonConverter> GetJsonConverterCreator(Type converterType)
		{
			Func<object> defaultConstructor = (ReflectionUtils.HasDefaultConstructor(converterType, nonPublic: false) ? ReflectionDelegateFactory.CreateDefaultConstructor<object>(converterType) : null);
			return delegate(object[] parameters)
			{
				try
				{
					if (parameters != null)
					{
						Type[] types = parameters.Select((object param) => param.GetType()).ToArray();
						ConstructorInfo constructor = converterType.GetConstructor(types);
						if ((object)constructor == null)
						{
							throw new JsonException("No matching parameterized constructor found for '{0}'.".FormatWith(CultureInfo.InvariantCulture, converterType));
						}
						return (JsonConverter)ReflectionDelegateFactory.CreateParameterizedConstructor(constructor)(parameters);
					}
					if (defaultConstructor == null)
					{
						throw new JsonException("No parameterless constructor defined for '{0}'.".FormatWith(CultureInfo.InvariantCulture, converterType));
					}
					return (JsonConverter)defaultConstructor();
				}
				catch (Exception innerException)
				{
					throw new JsonException("Error creating '{0}'.".FormatWith(CultureInfo.InvariantCulture, converterType), innerException);
				}
			};
		}

		public static TypeConverter GetTypeConverter(Type type)
		{
			return TypeDescriptor.GetConverter(type);
		}

		private static Type GetAssociatedMetadataType(Type type)
		{
			return AssociatedMetadataTypesCache.Get(type);
		}

		private static Type GetAssociateMetadataTypeFromAttribute(Type type)
		{
			Attribute[] attributes = ReflectionUtils.GetAttributes(type, null, inherit: true);
			foreach (Attribute attribute in attributes)
			{
				Type type2 = attribute.GetType();
				if (string.Equals(type2.FullName, "System.ComponentModel.DataAnnotations.MetadataTypeAttribute", StringComparison.Ordinal))
				{
					if (_metadataTypeAttributeReflectionObject == null)
					{
						_metadataTypeAttributeReflectionObject = ReflectionObject.Create(type2, "MetadataClassType");
					}
					return (Type)_metadataTypeAttributeReflectionObject.GetValue(attribute, "MetadataClassType");
				}
			}
			return null;
		}

		private static T GetAttribute<T>(Type type) where T : Attribute
		{
			Type associatedMetadataType = GetAssociatedMetadataType(type);
			T attribute;
			if ((object)associatedMetadataType != null)
			{
				attribute = ReflectionUtils.GetAttribute<T>(associatedMetadataType, inherit: true);
				if (attribute != null)
				{
					return attribute;
				}
			}
			attribute = ReflectionUtils.GetAttribute<T>(type, inherit: true);
			if (attribute != null)
			{
				return attribute;
			}
			Type[] interfaces = type.GetInterfaces();
			for (int i = 0; i < interfaces.Length; i++)
			{
				attribute = ReflectionUtils.GetAttribute<T>(interfaces[i], inherit: true);
				if (attribute != null)
				{
					return attribute;
				}
			}
			return null;
		}

		private static T GetAttribute<T>(MemberInfo memberInfo) where T : Attribute
		{
			Type associatedMetadataType = GetAssociatedMetadataType(memberInfo.DeclaringType);
			T attribute;
			if ((object)associatedMetadataType != null)
			{
				MemberInfo memberInfoFromType = ReflectionUtils.GetMemberInfoFromType(associatedMetadataType, memberInfo);
				if ((object)memberInfoFromType != null)
				{
					attribute = ReflectionUtils.GetAttribute<T>(memberInfoFromType, inherit: true);
					if (attribute != null)
					{
						return attribute;
					}
				}
			}
			attribute = ReflectionUtils.GetAttribute<T>(memberInfo, inherit: true);
			if (attribute != null)
			{
				return attribute;
			}
			if ((object)memberInfo.DeclaringType != null)
			{
				Type[] interfaces = memberInfo.DeclaringType.GetInterfaces();
				for (int i = 0; i < interfaces.Length; i++)
				{
					MemberInfo memberInfoFromType2 = ReflectionUtils.GetMemberInfoFromType(interfaces[i], memberInfo);
					if ((object)memberInfoFromType2 != null)
					{
						attribute = ReflectionUtils.GetAttribute<T>(memberInfoFromType2, inherit: true);
						if (attribute != null)
						{
							return attribute;
						}
					}
				}
			}
			return null;
		}

		public static T GetAttribute<T>(object provider) where T : Attribute
		{
			if (provider is Type type)
			{
				return GetAttribute<T>(type);
			}
			if (provider is MemberInfo memberInfo)
			{
				return GetAttribute<T>(memberInfo);
			}
			return ReflectionUtils.GetAttribute<T>(provider, inherit: true);
		}
	}
	[Preserve]
	internal static class CachedAttributeGetter<T> where T : Attribute
	{
		private static readonly ThreadSafeStore<object, T> TypeAttributeCache = new ThreadSafeStore<object, T>(JsonTypeReflector.GetAttribute<T>);

		public static T GetAttribute(object type)
		{
			return TypeAttributeCache.Get(type);
		}
	}
	[Preserve]
	public class ReflectionValueProvider : IValueProvider
	{
		private readonly MemberInfo _memberInfo;

		public ReflectionValueProvider(MemberInfo memberInfo)
		{
			ValidationUtils.ArgumentNotNull(memberInfo, "memberInfo");
			_memberInfo = memberInfo;
		}

		public void SetValue(object target, object value)
		{
			try
			{
				ReflectionUtils.SetMemberValue(_memberInfo, target, value);
			}
			catch (Exception innerException)
			{
				throw new JsonSerializationException("Error setting value to '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture, _memberInfo.Name, target.GetType()), innerException);
			}
		}

		public object GetValue(object target)
		{
			try
			{
				return ReflectionUtils.GetMemberValue(_memberInfo, target);
			}
			catch (Exception innerException)
			{
				throw new JsonSerializationException("Error getting value from '{0}' on '{1}'.".FormatWith(CultureInfo.InvariantCulture, _memberInfo.Name, target.GetType()), innerException);
			}
		}
	}
	[Preserve]
	[AttributeUsage(AttributeTargets.Method, Inherited = false)]
	public sealed class OnErrorAttribute : Attribute
	{
	}
	[Preserve]
	public delegate object ObjectConstructor<T>(params object[] args);
}
namespace Newtonsoft.Json.Linq
{
	[Preserve]
	public enum CommentHandling
	{
		Ignore,
		Load
	}
	[Preserve]
	public enum LineInfoHandling
	{
		Ignore,
		Load
	}
	[Preserve]
	public class JPropertyDescriptor : PropertyDescriptor
	{
		public override Type ComponentType => typeof(JObject);

		public override bool IsReadOnly => false;

		public override Type PropertyType => typeof(object);

		protected override int NameHashCode => base.NameHashCode;

		public JPropertyDescriptor(string name)
			: base(name, null)
		{
		}

		private static JObject CastInstance(object instance)
		{
			return (JObject)instance;
		}

		public override bool CanResetValue(object component)
		{
			return false;
		}

		public override object GetValue(object component)
		{
			return CastInstance(component)[Name];
		}

		public override void ResetValue(object component)
		{
		}

		public override void SetValue(object component, object value)
		{
			JToken value2 = ((value is JToken) ? ((JToken)value) : new JValue(value));
			CastInstance(component)[Name] = value2;
		}

		public override bool ShouldSerializeValue(object component)
		{
			return false;
		}
	}
	[Preserve]
	internal class JPropertyKeyedCollection : System.Collections.ObjectModel.Collection<JToken>
	{
		private static readonly IEqualityComparer<string> Comparer = StringComparer.Ordinal;

		private Dictionary<string, JToken> _dictionary;

		public JToken this[string key]
		{
			get
			{
				if (key == null)
				{
					throw new ArgumentNullException("key");
				}
				if (_dictionary != null)
				{
					return _dictionary[key];
				}
				throw new KeyNotFoundException();
			}
		}

		public ICollection<string> Keys
		{
			get
			{
				EnsureDictionary();
				return _dictionary.Keys;
			}
		}

		public ICollection<JToken> Values
		{
			get
			{
				EnsureDictionary();
				return _dictionary.Values;
			}
		}

		public JPropertyKeyedCollection()
			: base((IList<JToken>)new List<JToken>())
		{
		}

		private void AddKey(string key, JToken item)
		{
			EnsureDictionary();
			_dictionary[key] = item;
		}

		protected void ChangeItemKey(JToken item, string newKey)
		{
			if (!ContainsItem(item))
			{
				throw new ArgumentException("The specified item does not exist in this KeyedCollection.");
			}
			string keyForItem = GetKeyForItem(item);
			if (!Comparer.Equals(keyForItem, newKey))
			{
				if (newKey != null)
				{
					AddKey(newKey, item);
				}
				if (keyForItem != null)
				{
					RemoveKey(keyForItem);
				}
			}
		}

		protected override void ClearItems()
		{
			base.ClearItems();
			if (_dictionary != null)
			{
				_dictionary.Clear();
			}
		}

		public bool Contains(string key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (_dictionary != null)
			{
				return _dictionary.ContainsKey(key);
			}
			return false;
		}

		private bool ContainsItem(JToken item)
		{
			if (_dictionary == null)
			{
				return false;
			}
			string keyForItem = GetKeyForItem(item);
			JToken value;
			return _dictionary.TryGetValue(keyForItem, out value);
		}

		private void EnsureDictionary()
		{
			if (_dictionary == null)
			{
				_dictionary = new Dictionary<string, JToken>(Comparer);
			}
		}

		private string GetKeyForItem(JToken item)
		{
			return ((JProperty)item).Name;
		}

		protected override void InsertItem(int index, JToken item)
		{
			AddKey(GetKeyForItem(item), item);
			base.InsertItem(index, item);
		}

		public bool Remove(string key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (_dictionary != null)
			{
				if (_dictionary.ContainsKey(key))
				{
					return Remove(_dictionary[key]);
				}
				return false;
			}
			return false;
		}

		protected override void RemoveItem(int index)
		{
			string keyForItem = GetKeyForItem(base.Items[index]);
			RemoveKey(keyForItem);
			base.RemoveItem(index);
		}

		private void RemoveKey(string key)
		{
			if (_dictionary != null)
			{
				_dictionary.Remove(key);
			}
		}

		protected override void SetItem(int index, JToken item)
		{
			string keyForItem = GetKeyForItem(item);
			string keyForItem2 = GetKeyForItem(base.Items[index]);
			if (Comparer.Equals(keyForItem2, keyForItem))
			{
				if (_dictionary != null)
				{
					_dictionary[keyForItem] = item;
				}
			}
			else
			{
				AddKey(keyForItem, item);
				if (keyForItem2 != null)
				{
					RemoveKey(keyForItem2);
				}
			}
			base.SetItem(index, item);
		}

		public bool TryGetValue(string key, out JToken value)
		{
			if (_dictionary == null)
			{
				value = null;
				return false;
			}
			return _dictionary.TryGetValue(key, out value);
		}

		public int IndexOfReference(JToken t)
		{
			return ((List<JToken>)base.Items).IndexOfReference(t);
		}

		public bool Compare(JPropertyKeyedCollection other)
		{
			if (this == other)
			{
				return true;
			}
			Dictionary<string, JToken> dictionary = _dictionary;
			Dictionary<string, JToken> dictionary2 = other._dictionary;
			if (dictionary == null && dictionary2 == null)
			{
				return true;
			}
			if (dictionary == null)
			{
				return dictionary2.Count == 0;
			}
			if (dictionary2 == null)
			{
				return dictionary.Count == 0;
			}
			if (dictionary.Count != dictionary2.Count)
			{
				return false;
			}
			foreach (KeyValuePair<string, JToken> item in dictionary)
			{
				if (!dictionary2.TryGetValue(item.Key, out var value))
				{
					return false;
				}
				JProperty jProperty = (JProperty)item.Value;
				JProperty jProperty2 = (JProperty)value;
				if (jProperty.Value == null)
				{
					return jProperty2.Value == null;
				}
				if (!jProperty.Value.DeepEquals(jProperty2.Value))
				{
					return false;
				}
			}
			return true;
		}
	}
	[Preserve]
	public class JsonLoadSettings
	{
		private CommentHandling _commentHandling;

		private LineInfoHandling _lineInfoHandling;

		public CommentHandling CommentHandling
		{
			get
			{
				return _commentHandling;
			}
			set
			{
				if (value < CommentHandling.Ignore || value > CommentHandling.Load)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_commentHandling = value;
			}
		}

		public LineInfoHandling LineInfoHandling
		{
			get
			{
				return _lineInfoHandling;
			}
			set
			{
				if (value < LineInfoHandling.Ignore || value > LineInfoHandling.Load)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_lineInfoHandling = value;
			}
		}
	}
	[Preserve]
	public class JsonMergeSettings
	{
		private MergeArrayHandling _mergeArrayHandling;

		private MergeNullValueHandling _mergeNullValueHandling;

		public MergeArrayHandling MergeArrayHandling
		{
			get
			{
				return _mergeArrayHandling;
			}
			set
			{
				if (value < MergeArrayHandling.Concat || value > MergeArrayHandling.Merge)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_mergeArrayHandling = value;
			}
		}

		public MergeNullValueHandling MergeNullValueHandling
		{
			get
			{
				return _mergeNullValueHandling;
			}
			set
			{
				if (value < MergeNullValueHandling.Ignore || value > MergeNullValueHandling.Merge)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				_mergeNullValueHandling = value;
			}
		}
	}
	[Preserve]
	public enum MergeArrayHandling
	{
		Concat,
		Union,
		Replace,
		Merge
	}
	[Flags]
	[Preserve]
	public enum MergeNullValueHandling
	{
		Ignore = 0,
		Merge = 1
	}
	[Preserve]
	public class JRaw : JValue
	{
		public JRaw(JRaw other)
			: base(other)
		{
		}

		public JRaw(object rawJson)
			: base(rawJson, JTokenType.Raw)
		{
		}

		public static JRaw Create(JsonReader reader)
		{
			using StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			using JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter);
			jsonTextWriter.WriteToken(reader);
			return new JRaw(stringWriter.ToString());
		}

		internal override JToken CloneToken()
		{
			return new JRaw(this);
		}
	}
	[Preserve]
	public interface IJEnumerable<T> : IEnumerable<T>, IEnumerable where T : JToken
	{
		IJEnumerable<JToken> this[object key] { get; }
	}
	[Preserve]
	public class JTokenEqualityComparer : IEqualityComparer<JToken>
	{
		public bool Equals(JToken x, JToken y)
		{
			return JToken.DeepEquals(x, y);
		}

		public int GetHashCode(JToken obj)
		{
			return obj?.GetDeepHashCode() ?? 0;
		}
	}
	[Preserve]
	public static class Extensions
	{
		public static IJEnumerable<JToken> Ancestors<T>(this IEnumerable<T> source) where T : JToken
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			return source.SelectMany((T j) => j.Ancestors()).AsJEnumerable();
		}

		public static IJEnumerable<JToken> AncestorsAndSelf<T>(this IEnumerable<T> source) where T : JToken
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			return source.SelectMany((T j) => j.AncestorsAndSelf()).AsJEnumerable();
		}

		public static IJEnumerable<JToken> Descendants<T>(this IEnumerable<T> source) where T : JContainer
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			return source.SelectMany((T j) => j.Descendants()).AsJEnumerable();
		}

		public static IJEnumerable<JToken> DescendantsAndSelf<T>(this IEnumerable<T> source) where T : JContainer
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			return source.SelectMany((T j) => j.DescendantsAndSelf()).AsJEnumerable();
		}

		public static IJEnumerable<JProperty> Properties(this IEnumerable<JObject> source)
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			return source.SelectMany((JObject d) => d.Properties()).AsJEnumerable();
		}

		public static IJEnumerable<JToken> Values(this IEnumerable<JToken> source, object key)
		{
			return source.Values<JToken, JToken>(key).AsJEnumerable();
		}

		public static IJEnumerable<JToken> Values(this IEnumerable<JToken> source)
		{
			return source.Values(null);
		}

		public static IEnumerable<U> Values<U>(this IEnumerable<JToken> source, object key)
		{
			return source.Values<JToken, U>(key);
		}

		public static IEnumerable<U> Values<U>(this IEnumerable<JToken> source)
		{
			return source.Values<JToken, U>(null);
		}

		public static U Value<U>(this IEnumerable<JToken> value)
		{
			return value.Value<JToken, U>();
		}

		public static U Value<T, U>(this IEnumerable<T> value) where T : JToken
		{
			ValidationUtils.ArgumentNotNull(value, "value");
			return ((value as JToken) ?? throw new ArgumentException("Source value must be a JToken.")).Convert<JToken, U>();
		}

		internal static IEnumerable<U> Values<T, U>(this IEnumerable<T> source, object key) where T : JToken
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			foreach (T token in source)
			{
				if (key == null)
				{
					if (token is JValue)
					{
						yield return ((JValue)(object)token).Convert<JValue, U>();
						continue;
					}
					foreach (JToken item in token.Children())
					{
						yield return item.Convert<JToken, U>();
					}
				}
				else
				{
					JToken jToken = token[key];
					if (jToken != null)
					{
						yield return jToken.Convert<JToken, U>();
					}
				}
			}
		}

		public static IJEnumerable<JToken> Children<T>(this IEnumerable<T> source) where T : JToken
		{
			return source.Children<T, JToken>().AsJEnumerable();
		}

		public static IEnumerable<U> Children<T, U>(this IEnumerable<T> source) where T : JToken
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			return source.SelectMany((T c) => c.Children()).Convert<JToken, U>();
		}

		internal static IEnumerable<U> Convert<T, U>(this IEnumerable<T> source) where T : JToken
		{
			ValidationUtils.ArgumentNotNull(source, "source");
			foreach (T item in source)
			{
				yield return item.Convert<JToken, U>();
			}
		}

		internal static U Convert<T, U>(this T token) where T : JToken
		{
			if (token == null)
			{
				return default(U);
			}
			if (token is U && (object)typeof(U) != typeof(IComparable) && (object)typeof(U) != typeof(IFormattable))
			{
				return (U)(object)token;
			}
			if (!(token is JValue jValue))
			{
				throw new InvalidCastException("Cannot cast {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, token.GetType(), typeof(T)));
			}
			if (jValue.Value is U)
			{
				return (U)jValue.Value;
			}
			Type type = typeof(U);
			if (ReflectionUtils.IsNullableType(type))
			{
				if (jValue.Value == null)
				{
					return default(U);
				}
				type = Nullable.GetUnderlyingType(type);
			}
			return (U)System.Convert.ChangeType(jValue.Value, type, CultureInfo.InvariantCulture);
		}

		public static IJEnumerable<JToken> AsJEnumerable(this IEnumerable<JToken> source)
		{
			return source.AsJEnumerable<JToken>();
		}

		public static IJEnumerable<T> AsJEnumerable<T>(this IEnumerable<T> source) where T : JToken
		{
			if (source == null)
			{
				return null;
			}
			if (source is IJEnumerable<T>)
			{
				return (IJEnumerable<T>)source;
			}
			return new JEnumerable<T>(source);
		}
	}
	[Preserve]
	public class JConstructor : JContainer
	{
		private string _name;

		private readonly List<JToken> _values = new List<JToken>();

		protected override IList<JToken> ChildrenTokens => _values;

		public string Name
		{
			get
			{
				return _name;
			}
			set
			{
				_name = value;
			}
		}

		public override JTokenType Type => JTokenType.Constructor;

		public override JToken this[object key]
		{
			get
			{
				ValidationUtils.ArgumentNotNull(key, "key");
				if (!(key is int))
				{
					throw new ArgumentException("Accessed JConstructor values with invalid key value: {0}. Argument position index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
				}
				return GetItem((int)key);
			}
			set
			{
				ValidationUtils.ArgumentNotNull(key, "key");
				if (!(key is int))
				{
					throw new ArgumentException("Set JConstructor values with invalid key value: {0}. Argument position index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
				}
				SetItem((int)key, value);
			}
		}

		internal override int IndexOfItem(JToken item)
		{
			return _values.IndexOfReference(item);
		}

		internal override void MergeItem(object content, JsonMergeSettings settings)
		{
			if (content is JConstructor jConstructor)
			{
				if (jConstructor.Name != null)
				{
					Name = jConstructor.Name;
				}
				JContainer.MergeEnumerableContent(this, jConstructor, settings);
			}
		}

		public JConstructor()
		{
		}

		public JConstructor(JConstructor other)
			: base(other)
		{
			_name = other.Name;
		}

		public JConstructor(string name, params object[] content)
			: this(name, (object)content)
		{
		}

		public JConstructor(string name, object content)
			: this(name)
		{
			Add(content);
		}

		public JConstructor(string name)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			if (name.Length == 0)
			{
				throw new ArgumentException("Constructor name cannot be empty.", "name");
			}
			_name = name;
		}

		internal override bool DeepEquals(JToken node)
		{
			if (node is JConstructor jConstructor && _name == jConstructor.Name)
			{
				return ContentsEqual(jConstructor);
			}
			return false;
		}

		internal override JToken CloneToken()
		{
			return new JConstructor(this);
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WriteStartConstructor(_name);
			foreach (JToken item in Children())
			{
				item.WriteTo(writer, converters);
			}
			writer.WriteEndConstructor();
		}

		internal override int GetDeepHashCode()
		{
			return _name.GetHashCode() ^ ContentsHashCode();
		}

		public new static JConstructor Load(JsonReader reader)
		{
			return Load(reader, null);
		}

		public new static JConstructor Load(JsonReader reader, JsonLoadSettings settings)
		{
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading JConstructor from JsonReader.");
			}
			reader.MoveToContent();
			if (reader.TokenType != JsonToken.StartConstructor)
			{
				throw JsonReaderException.Create(reader, "Error reading JConstructor from JsonReader. Current JsonReader item is not a constructor: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JConstructor jConstructor = new JConstructor((string)reader.Value);
			jConstructor.SetLineInfo(reader as IJsonLineInfo, settings);
			jConstructor.ReadTokenFrom(reader, settings);
			return jConstructor;
		}
	}
	[Preserve]
	public abstract class JContainer : JToken, IList<JToken>, ICollection<JToken>, IEnumerable<JToken>, IEnumerable, ITypedList, IBindingList, IList, ICollection
	{
		internal ListChangedEventHandler _listChanged;

		internal AddingNewEventHandler _addingNew;

		private object _syncRoot;

		private bool _busy;

		protected abstract IList<JToken> ChildrenTokens { get; }

		public override bool HasValues => ChildrenTokens.Count > 0;

		public override JToken First
		{
			get
			{
				IList<JToken> childrenTokens = ChildrenTokens;
				if (childrenTokens.Count <= 0)
				{
					return null;
				}
				return childrenTokens[0];
			}
		}

		public override JToken Last
		{
			get
			{
				IList<JToken> childrenTokens = ChildrenTokens;
				int count = childrenTokens.Count;
				if (count <= 0)
				{
					return null;
				}
				return childrenTokens[count - 1];
			}
		}

		JToken IList<JToken>.this[int index]
		{
			get
			{
				return GetItem(index);
			}
			set
			{
				SetItem(index, value);
			}
		}

		bool ICollection<JToken>.IsReadOnly => false;

		bool IList.IsFixedSize => false;

		bool IList.IsReadOnly => false;

		object IList.this[int index]
		{
			get
			{
				return GetItem(index);
			}
			set
			{
				SetItem(index, EnsureValue(value));
			}
		}

		public int Count => ChildrenTokens.Count;

		bool ICollection.IsSynchronized => false;

		object ICollection.SyncRoot
		{
			get
			{
				if (_syncRoot == null)
				{
					Interlocked.CompareExchange(ref _syncRoot, new object(), null);
				}
				return _syncRoot;
			}
		}

		bool IBindingList.AllowEdit => true;

		bool IBindingList.AllowNew => true;

		bool IBindingList.AllowRemove => true;

		bool IBindingList.IsSorted => false;

		ListSortDirection IBindingList.SortDirection => ListSortDirection.Ascending;

		PropertyDescriptor IBindingList.SortProperty => null;

		bool IBindingList.SupportsChangeNotification => true;

		bool IBindingList.SupportsSearching => false;

		bool IBindingList.SupportsSorting => false;

		public event ListChangedEventHandler ListChanged
		{
			add
			{
				_listChanged = (ListChangedEventHandler)Delegate.Combine(_listChanged, value);
			}
			remove
			{
				_listChanged = (ListChangedEventHandler)Delegate.Remove(_listChanged, value);
			}
		}

		public event AddingNewEventHandler AddingNew
		{
			add
			{
				_addingNew = (AddingNewEventHandler)Delegate.Combine(_addingNew, value);
			}
			remove
			{
				_addingNew = (AddingNewEventHandler)Delegate.Remove(_addingNew, value);
			}
		}

		internal JContainer()
		{
		}

		internal JContainer(JContainer other)
			: this()
		{
			ValidationUtils.ArgumentNotNull(other, "other");
			int num = 0;
			foreach (JToken item in (IEnumerable<JToken>)other)
			{
				AddInternal(num, item, skipParentCheck: false);
				num++;
			}
		}

		internal void CheckReentrancy()
		{
			if (_busy)
			{
				throw new InvalidOperationException("Cannot change {0} during a collection change event.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
		}

		internal virtual IList<JToken> CreateChildrenCollection()
		{
			return new List<JToken>();
		}

		protected virtual void OnAddingNew(AddingNewEventArgs e)
		{
			_addingNew?.Invoke(this, e);
		}

		protected virtual void OnListChanged(ListChangedEventArgs e)
		{
			ListChangedEventHandler listChanged = _listChanged;
			if (listChanged != null)
			{
				_busy = true;
				try
				{
					listChanged(this, e);
				}
				finally
				{
					_busy = false;
				}
			}
		}

		internal bool ContentsEqual(JContainer container)
		{
			if (container == this)
			{
				return true;
			}
			IList<JToken> childrenTokens = ChildrenTokens;
			IList<JToken> childrenTokens2 = container.ChildrenTokens;
			if (childrenTokens.Count != childrenTokens2.Count)
			{
				return false;
			}
			for (int i = 0; i < childrenTokens.Count; i++)
			{
				if (!childrenTokens[i].DeepEquals(childrenTokens2[i]))
				{
					return false;
				}
			}
			return true;
		}

		public override JEnumerable<JToken> Children()
		{
			return new JEnumerable<JToken>(ChildrenTokens);
		}

		public override IEnumerable<T> Values<T>()
		{
			return ChildrenTokens.Convert<JToken, T>();
		}

		public IEnumerable<JToken> Descendants()
		{
			return GetDescendants(self: false);
		}

		public IEnumerable<JToken> DescendantsAndSelf()
		{
			return GetDescendants(self: true);
		}

		internal IEnumerable<JToken> GetDescendants(bool self)
		{
			if (self)
			{
				yield return this;
			}
			foreach (JToken o in ChildrenTokens)
			{
				yield return o;
				if (!(o is JContainer jContainer))
				{
					continue;
				}
				foreach (JToken item in jContainer.Descendants())
				{
					yield return item;
				}
			}
		}

		internal bool IsMultiContent(object content)
		{
			if (content is IEnumerable && !(content is string) && !(content is JToken))
			{
				return !(content is byte[]);
			}
			return false;
		}

		internal JToken EnsureParentToken(JToken item, bool skipParentCheck)
		{
			if (item == null)
			{
				return JValue.CreateNull();
			}
			if (skipParentCheck)
			{
				return item;
			}
			if (item.Parent != null || item == this || (item.HasValues && base.Root == item))
			{
				item = item.CloneToken();
			}
			return item;
		}

		internal abstract int IndexOfItem(JToken item);

		internal virtual void InsertItem(int index, JToken item, bool skipParentCheck)
		{
			IList<JToken> childrenTokens = ChildrenTokens;
			if (index > childrenTokens.Count)
			{
				throw new ArgumentOutOfRangeException("index", "Index must be within the bounds of the List.");
			}
			CheckReentrancy();
			item = EnsureParentToken(item, skipParentCheck);
			JToken jToken = ((index == 0) ? null : childrenTokens[index - 1]);
			JToken jToken2 = ((index == childrenTokens.Count) ? null : childrenTokens[index]);
			ValidateToken(item, null);
			item.Parent = this;
			item.Previous = jToken;
			if (jToken != null)
			{
				jToken.Next = item;
			}
			item.Next = jToken2;
			if (jToken2 != null)
			{
				jToken2.Previous = item;
			}
			childrenTokens.Insert(index, item);
			if (_listChanged != null)
			{
				OnListChanged(new ListChangedEventArgs(ListChangedType.ItemAdded, index));
			}
		}

		internal virtual void RemoveItemAt(int index)
		{
			IList<JToken> childrenTokens = ChildrenTokens;
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index", "Index is less than 0.");
			}
			if (index >= childrenTokens.Count)
			{
				throw new ArgumentOutOfRangeException("index", "Index is equal to or greater than Count.");
			}
			CheckReentrancy();
			JToken jToken = childrenTokens[index];
			JToken jToken2 = ((index == 0) ? null : childrenTokens[index - 1]);
			JToken jToken3 = ((index == childrenTokens.Count - 1) ? null : childrenTokens[index + 1]);
			if (jToken2 != null)
			{
				jToken2.Next = jToken3;
			}
			if (jToken3 != null)
			{
				jToken3.Previous = jToken2;
			}
			jToken.Parent = null;
			jToken.Previous = null;
			jToken.Next = null;
			childrenTokens.RemoveAt(index);
			if (_listChanged != null)
			{
				OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, index));
			}
		}

		internal virtual bool RemoveItem(JToken item)
		{
			int num = IndexOfItem(item);
			if (num >= 0)
			{
				RemoveItemAt(num);
				return true;
			}
			return false;
		}

		internal virtual JToken GetItem(int index)
		{
			return ChildrenTokens[index];
		}

		internal virtual void SetItem(int index, JToken item)
		{
			IList<JToken> childrenTokens = ChildrenTokens;
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index", "Index is less than 0.");
			}
			if (index >= childrenTokens.Count)
			{
				throw new ArgumentOutOfRangeException("index", "Index is equal to or greater than Count.");
			}
			JToken jToken = childrenTokens[index];
			if (!IsTokenUnchanged(jToken, item))
			{
				CheckReentrancy();
				item = EnsureParentToken(item, skipParentCheck: false);
				ValidateToken(item, jToken);
				JToken jToken2 = ((index == 0) ? null : childrenTokens[index - 1]);
				JToken jToken3 = ((index == childrenTokens.Count - 1) ? null : childrenTokens[index + 1]);
				item.Parent = this;
				item.Previous = jToken2;
				if (jToken2 != null)
				{
					jToken2.Next = item;
				}
				item.Next = jToken3;
				if (jToken3 != null)
				{
					jToken3.Previous = item;
				}
				childrenTokens[index] = item;
				jToken.Parent = null;
				jToken.Previous = null;
				jToken.Next = null;
				if (_listChanged != null)
				{
					OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, index));
				}
			}
		}

		internal virtual void ClearItems()
		{
			CheckReentrancy();
			IList<JToken> childrenTokens = ChildrenTokens;
			foreach (JToken item in childrenTokens)
			{
				item.Parent = null;
				item.Previous = null;
				item.Next = null;
			}
			childrenTokens.Clear();
			if (_listChanged != null)
			{
				OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));
			}
		}

		internal virtual void ReplaceItem(JToken existing, JToken replacement)
		{
			if (existing != null && existing.Parent == this)
			{
				int index = IndexOfItem(existing);
				SetItem(index, replacement);
			}
		}

		internal virtual bool ContainsItem(JToken item)
		{
			return IndexOfItem(item) != -1;
		}

		internal virtual void CopyItemsTo(Array array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (arrayIndex < 0)
			{
				throw new ArgumentOutOfRangeException("arrayIndex", "arrayIndex is less than 0.");
			}
			if (arrayIndex >= array.Length && arrayIndex != 0)
			{
				throw new ArgumentException("arrayIndex is equal to or greater than the length of array.");
			}
			if (Count > array.Length - arrayIndex)
			{
				throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array.");
			}
			int num = 0;
			foreach (JToken childrenToken in ChildrenTokens)
			{
				array.SetValue(childrenToken, arrayIndex + num);
				num++;
			}
		}

		internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue)
		{
			if (currentValue is JValue jValue)
			{
				if (jValue.Type == JTokenType.Null && newValue == null)
				{
					return true;
				}
				return jValue.Equals(newValue);
			}
			return false;
		}

		internal virtual void ValidateToken(JToken o, JToken existing)
		{
			ValidationUtils.ArgumentNotNull(o, "o");
			if (o.Type == JTokenType.Property)
			{
				throw new ArgumentException("Can not add {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, o.GetType(), GetType()));
			}
		}

		public virtual void Add(object content)
		{
			AddInternal(ChildrenTokens.Count, content, skipParentCheck: false);
		}

		internal void AddAndSkipParentCheck(JToken token)
		{
			AddInternal(ChildrenTokens.Count, token, skipParentCheck: true);
		}

		public void AddFirst(object content)
		{
			AddInternal(0, content, skipParentCheck: false);
		}

		internal void AddInternal(int index, object content, bool skipParentCheck)
		{
			if (IsMultiContent(content))
			{
				IEnumerable obj = (IEnumerable)content;
				int num = index;
				{
					foreach (object item2 in obj)
					{
						AddInternal(num, item2, skipParentCheck);
						num++;
					}
					return;
				}
			}
			JToken item = CreateFromContent(content);
			InsertItem(index, item, skipParentCheck);
		}

		internal static JToken CreateFromContent(object content)
		{
			if (content is JToken result)
			{
				return result;
			}
			return new JValue(content);
		}

		public JsonWriter CreateWriter()
		{
			return new JTokenWriter(this);
		}

		public void ReplaceAll(object content)
		{
			ClearItems();
			Add(content);
		}

		public void RemoveAll()
		{
			ClearItems();
		}

		internal abstract void MergeItem(object content, JsonMergeSettings settings);

		public void Merge(object content)
		{
			MergeItem(content, new JsonMergeSettings());
		}

		public void Merge(object content, JsonMergeSettings settings)
		{
			MergeItem(content, settings);
		}

		internal void ReadTokenFrom(JsonReader reader, JsonLoadSettings options)
		{
			int depth = reader.Depth;
			if (!reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading {0} from JsonReader.".FormatWith(CultureInfo.InvariantCulture, GetType().Name));
			}
			ReadContentFrom(reader, options);
			if (reader.Depth > depth)
			{
				throw JsonReaderException.Create(reader, "Unexpected end of content while loading {0}.".FormatWith(CultureInfo.InvariantCulture, GetType().Name));
			}
		}

		internal void ReadContentFrom(JsonReader r, JsonLoadSettings settings)
		{
			ValidationUtils.ArgumentNotNull(r, "r");
			IJsonLineInfo lineInfo = r as IJsonLineInfo;
			JContainer jContainer = this;
			do
			{
				if ((jContainer as JProperty)?.Value != null)
				{
					if (jContainer == this)
					{
						break;
					}
					jContainer = jContainer.Parent;
				}
				switch (r.TokenType)
				{
				case JsonToken.StartArray:
				{
					JArray jArray = new JArray();
					jArray.SetLineInfo(lineInfo, settings);
					jContainer.Add(jArray);
					jContainer = jArray;
					break;
				}
				case JsonToken.EndArray:
					if (jContainer == this)
					{
						return;
					}
					jContainer = jContainer.Parent;
					break;
				case JsonToken.StartObject:
				{
					JObject jObject = new JObject();
					jObject.SetLineInfo(lineInfo, settings);
					jContainer.Add(jObject);
					jContainer = jObject;
					break;
				}
				case JsonToken.EndObject:
					if (jContainer == this)
					{
						return;
					}
					jContainer = jContainer.Parent;
					break;
				case JsonToken.StartConstructor:
				{
					JConstructor jConstructor = new JConstructor(r.Value.ToString());
					jConstructor.SetLineInfo(lineInfo, settings);
					jContainer.Add(jConstructor);
					jContainer = jConstructor;
					break;
				}
				case JsonToken.EndConstructor:
					if (jContainer == this)
					{
						return;
					}
					jContainer = jContainer.Parent;
					break;
				case JsonToken.Integer:
				case JsonToken.Float:
				case JsonToken.String:
				case JsonToken.Boolean:
				case JsonToken.Date:
				case JsonToken.Bytes:
				{
					JValue jValue = new JValue(r.Value);
					jValue.SetLineInfo(lineInfo, settings);
					jContainer.Add(jValue);
					break;
				}
				case JsonToken.Comment:
					if (settings != null && settings.CommentHandling == CommentHandling.Load)
					{
						JValue jValue = JValue.CreateComment(r.Value.ToString());
						jValue.SetLineInfo(lineInfo, settings);
						jContainer.Add(jValue);
					}
					break;
				case JsonToken.Null:
				{
					JValue jValue = JValue.CreateNull();
					jValue.SetLineInfo(lineInfo, settings);
					jContainer.Add(jValue);
					break;
				}
				case JsonToken.Undefined:
				{
					JValue jValue = JValue.CreateUndefined();
					jValue.SetLineInfo(lineInfo, settings);
					jContainer.Add(jValue);
					break;
				}
				case JsonToken.PropertyName:
				{
					string name = r.Value.ToString();
					JProperty jProperty = new JProperty(name);
					jProperty.SetLineInfo(lineInfo, settings);
					JProperty jProperty2 = ((JObject)jContainer).Property(name);
					if (jProperty2 == null)
					{
						jContainer.Add(jProperty);
					}
					else
					{
						jProperty2.Replace(jProperty);
					}
					jContainer = jProperty;
					break;
				}
				default:
					throw new InvalidOperationException("The JsonReader should not be on a token of type {0}.".FormatWith(CultureInfo.InvariantCulture, r.TokenType));
				case JsonToken.None:
					break;
				}
			}
			while (r.Read());
		}

		internal int ContentsHashCode()
		{
			int num = 0;
			foreach (JToken childrenToken in ChildrenTokens)
			{
				num ^= childrenToken.GetDeepHashCode();
			}
			return num;
		}

		string ITypedList.GetListName(PropertyDescriptor[] listAccessors)
		{
			return string.Empty;
		}

		PropertyDescriptorCollection ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors)
		{
			return (First as ICustomTypeDescriptor)?.GetProperties();
		}

		int IList<JToken>.IndexOf(JToken item)
		{
			return IndexOfItem(item);
		}

		void IList<JToken>.Insert(int index, JToken item)
		{
			InsertItem(index, item, skipParentCheck: false);
		}

		void IList<JToken>.RemoveAt(int index)
		{
			RemoveItemAt(index);
		}

		void ICollection<JToken>.Add(JToken item)
		{
			Add(item);
		}

		void ICollection<JToken>.Clear()
		{
			ClearItems();
		}

		bool ICollection<JToken>.Contains(JToken item)
		{
			return ContainsItem(item);
		}

		void ICollection<JToken>.CopyTo(JToken[] array, int arrayIndex)
		{
			CopyItemsTo(array, arrayIndex);
		}

		bool ICollection<JToken>.Remove(JToken item)
		{
			return RemoveItem(item);
		}

		private JToken EnsureValue(object value)
		{
			if (value == null)
			{
				return null;
			}
			if (value is JToken result)
			{
				return result;
			}
			throw new ArgumentException("Argument is not a JToken.");
		}

		int IList.Add(object value)
		{
			Add(EnsureValue(value));
			return Count - 1;
		}

		void IList.Clear()
		{
			ClearItems();
		}

		bool IList.Contains(object value)
		{
			return ContainsItem(EnsureValue(value));
		}

		int IList.IndexOf(object value)
		{
			return IndexOfItem(EnsureValue(value));
		}

		void IList.Insert(int index, object value)
		{
			InsertItem(index, EnsureValue(value), skipParentCheck: false);
		}

		void IList.Remove(object value)
		{
			RemoveItem(EnsureValue(value));
		}

		void IList.RemoveAt(int index)
		{
			RemoveItemAt(index);
		}

		void ICollection.CopyTo(Array array, int index)
		{
			CopyItemsTo(array, index);
		}

		void IBindingList.AddIndex(PropertyDescriptor property)
		{
		}

		object IBindingList.AddNew()
		{
			AddingNewEventArgs e = new AddingNewEventArgs();
			OnAddingNew(e);
			if (e.NewObject == null)
			{
				throw new JsonException("Could not determine new value to add to '{0}'.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
			if (!(e.NewObject is JToken))
			{
				throw new JsonException("New item to be added to collection must be compatible with {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JToken)));
			}
			JToken jToken = (JToken)e.NewObject;
			Add(jToken);
			return jToken;
		}

		void IBindingList.ApplySort(PropertyDescriptor property, ListSortDirection direction)
		{
			throw new NotSupportedException();
		}

		int IBindingList.Find(PropertyDescriptor property, object key)
		{
			throw new NotSupportedException();
		}

		void IBindingList.RemoveIndex(PropertyDescriptor property)
		{
		}

		void IBindingList.RemoveSort()
		{
			throw new NotSupportedException();
		}

		internal static void MergeEnumerableContent(JContainer target, IEnumerable content, JsonMergeSettings settings)
		{
			switch (settings.MergeArrayHandling)
			{
			case MergeArrayHandling.Concat:
			{
				foreach (JToken item in content)
				{
					target.Add(item);
				}
				break;
			}
			case MergeArrayHandling.Union:
			{
				HashSet<JToken> hashSet = new HashSet<JToken>(target, JToken.EqualityComparer);
				{
					foreach (JToken item2 in content)
					{
						if (hashSet.Add(item2))
						{
							target.Add(item2);
						}
					}
					break;
				}
			}
			case MergeArrayHandling.Replace:
				target.ClearItems();
				{
					foreach (JToken item3 in content)
					{
						target.Add(item3);
					}
					break;
				}
			case MergeArrayHandling.Merge:
			{
				int num = 0;
				{
					foreach (object item4 in content)
					{
						if (num < target.Count)
						{
							if (target[num] is JContainer jContainer)
							{
								jContainer.Merge(item4, settings);
							}
							else if (item4 != null)
							{
								JToken jToken = CreateFromContent(item4);
								if (jToken.Type != JTokenType.Null)
								{
									target[num] = jToken;
								}
							}
						}
						else
						{
							target.Add(item4);
						}
						num++;
					}
					break;
				}
			}
			default:
				throw new ArgumentOutOfRangeException("settings", "Unexpected merge array handling when merging JSON.");
			}
		}
	}
	[Preserve]
	public struct JEnumerable<T> : IJEnumerable<T>, IEnumerable<T>, IEnumerable where T : JToken
	{
		public static readonly JEnumerable<T> Empty = new JEnumerable<T>(Enumerable.Empty<T>());

		private readonly IEnumerable<T> _enumerable;

		public IJEnumerable<JToken> this[object key]
		{
			get
			{
				if (_enumerable == null)
				{
					return JEnumerable<JToken>.Empty;
				}
				return new JEnumerable<JToken>(_enumerable.Values<T, JToken>(key));
			}
		}

		public JEnumerable(IEnumerable<T> enumerable)
		{
			ValidationUtils.ArgumentNotNull(enumerable, "enumerable");
			_enumerable = enumerable;
		}

		public IEnumerator<T> GetEnumerator()
		{
			if (_enumerable == null)
			{
				return Empty.GetEnumerator();
			}
			return _enumerable.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public bool Equals(JEnumerable<T> other)
		{
			return object.Equals(_enumerable, other._enumerable);
		}

		public override bool Equals(object obj)
		{
			if (obj is JEnumerable<T>)
			{
				return Equals((JEnumerable<T>)obj);
			}
			return false;
		}

		public override int GetHashCode()
		{
			if (_enumerable == null)
			{
				return 0;
			}
			return _enumerable.GetHashCode();
		}
	}
	[Preserve]
	public class JObject : JContainer, IDictionary<string, JToken>, ICollection<KeyValuePair<string, JToken>>, IEnumerable<KeyValuePair<string, JToken>>, IEnumerable, INotifyPropertyChanged, ICustomTypeDescriptor, INotifyPropertyChanging
	{
		private readonly JPropertyKeyedCollection _properties = new JPropertyKeyedCollection();

		protected override IList<JToken> ChildrenTokens => _properties;

		public override JTokenType Type => JTokenType.Object;

		public override JToken this[object key]
		{
			get
			{
				ValidationUtils.ArgumentNotNull(key, "key");
				if (!(key is string propertyName))
				{
					throw new ArgumentException("Accessed JObject values with invalid key value: {0}. Object property name expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
				}
				return this[propertyName];
			}
			set
			{
				ValidationUtils.ArgumentNotNull(key, "key");
				if (!(key is string propertyName))
				{
					throw new ArgumentException("Set JObject values with invalid key value: {0}. Object property name expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
				}
				this[propertyName] = value;
			}
		}

		public JToken this[string propertyName]
		{
			get
			{
				ValidationUtils.ArgumentNotNull(propertyName, "propertyName");
				return Property(propertyName)?.Value;
			}
			set
			{
				JProperty jProperty = Property(propertyName);
				if (jProperty != null)
				{
					jProperty.Value = value;
					return;
				}
				OnPropertyChanging(propertyName);
				Add(new JProperty(propertyName, value));
				OnPropertyChanged(propertyName);
			}
		}

		ICollection<string> IDictionary<string, JToken>.Keys => _properties.Keys;

		ICollection<JToken> IDictionary<string, JToken>.Values
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		bool ICollection<KeyValuePair<string, JToken>>.IsReadOnly => false;

		public event PropertyChangedEventHandler PropertyChanged;

		public event PropertyChangingEventHandler PropertyChanging;

		public JObject()
		{
		}

		public JObject(JObject other)
			: base(other)
		{
		}

		public JObject(params object[] content)
			: this((object)content)
		{
		}

		public JObject(object content)
		{
			Add(content);
		}

		internal override bool DeepEquals(JToken node)
		{
			if (!(node is JObject jObject))
			{
				return false;
			}
			return _properties.Compare(jObject._properties);
		}

		internal override int IndexOfItem(JToken item)
		{
			return _properties.IndexOfReference(item);
		}

		internal override void InsertItem(int index, JToken item, bool skipParentCheck)
		{
			if (item == null || item.Type != JTokenType.Comment)
			{
				base.InsertItem(index, item, skipParentCheck);
			}
		}

		internal override void ValidateToken(JToken o, JToken existing)
		{
			ValidationUtils.ArgumentNotNull(o, "o");
			if (o.Type != JTokenType.Property)
			{
				throw new ArgumentException("Can not add {0} to {1}.".FormatWith(CultureInfo.InvariantCulture, o.GetType(), GetType()));
			}
			JProperty jProperty = (JProperty)o;
			if (existing != null)
			{
				JProperty jProperty2 = (JProperty)existing;
				if (jProperty.Name == jProperty2.Name)
				{
					return;
				}
			}
			if (_properties.TryGetValue(jProperty.Name, out existing))
			{
				throw new ArgumentException("Can not add property {0} to {1}. Property with the same name already exists on object.".FormatWith(CultureInfo.InvariantCulture, jProperty.Name, GetType()));
			}
		}

		internal override void MergeItem(object content, JsonMergeSettings settings)
		{
			if (!(content is JObject jObject))
			{
				return;
			}
			foreach (KeyValuePair<string, JToken> item in jObject)
			{
				JProperty jProperty = Property(item.Key);
				if (jProperty == null)
				{
					Add(item.Key, item.Value);
				}
				else
				{
					if (item.Value == null)
					{
						continue;
					}
					if (!(jProperty.Value is JContainer jContainer))
					{
						if (item.Value.Type != JTokenType.Null || (settings != null && settings.MergeNullValueHandling == MergeNullValueHandling.Merge))
						{
							jProperty.Value = item.Value;
						}
					}
					else if (jContainer.Type != item.Value.Type)
					{
						jProperty.Value = item.Value;
					}
					else
					{
						jContainer.Merge(item.Value, settings);
					}
				}
			}
		}

		internal void InternalPropertyChanged(JProperty childProperty)
		{
			OnPropertyChanged(childProperty.Name);
			if (_listChanged != null)
			{
				OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, IndexOfItem(childProperty)));
			}
		}

		internal void InternalPropertyChanging(JProperty childProperty)
		{
			OnPropertyChanging(childProperty.Name);
		}

		internal override JToken CloneToken()
		{
			return new JObject(this);
		}

		public IEnumerable<JProperty> Properties()
		{
			return _properties.Cast<JProperty>();
		}

		public JProperty Property(string name)
		{
			if (name == null)
			{
				return null;
			}
			_properties.TryGetValue(name, out var value);
			return (JProperty)value;
		}

		public JEnumerable<JToken> PropertyValues()
		{
			return new JEnumerable<JToken>(from p in Properties()
				select p.Value);
		}

		public new static JObject Load(JsonReader reader)
		{
			return Load(reader, null);
		}

		public new static JObject Load(JsonReader reader, JsonLoadSettings settings)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading JObject from JsonReader.");
			}
			reader.MoveToContent();
			if (reader.TokenType != JsonToken.StartObject)
			{
				throw JsonReaderException.Create(reader, "Error reading JObject from JsonReader. Current JsonReader item is not an object: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JObject jObject = new JObject();
			jObject.SetLineInfo(reader as IJsonLineInfo, settings);
			jObject.ReadTokenFrom(reader, settings);
			return jObject;
		}

		public new static JObject Parse(string json)
		{
			return Parse(json, null);
		}

		public new static JObject Parse(string json, JsonLoadSettings settings)
		{
			using JsonReader jsonReader = new JsonTextReader(new StringReader(json));
			JObject result = Load(jsonReader, settings);
			if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
			{
				throw JsonReaderException.Create(jsonReader, "Additional text found in JSON string after parsing content.");
			}
			return result;
		}

		public new static JObject FromObject(object o)
		{
			return FromObject(o, JsonSerializer.CreateDefault());
		}

		public new static JObject FromObject(object o, JsonSerializer jsonSerializer)
		{
			JToken jToken = JToken.FromObjectInternal(o, jsonSerializer);
			if (jToken != null && jToken.Type != JTokenType.Object)
			{
				throw new ArgumentException("Object serialized to {0}. JObject instance expected.".FormatWith(CultureInfo.InvariantCulture, jToken.Type));
			}
			return (JObject)jToken;
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WriteStartObject();
			for (int i = 0; i < _properties.Count; i++)
			{
				_properties[i].WriteTo(writer, converters);
			}
			writer.WriteEndObject();
		}

		public JToken GetValue(string propertyName)
		{
			return GetValue(propertyName, StringComparison.Ordinal);
		}

		public JToken GetValue(string propertyName, StringComparison comparison)
		{
			if (propertyName == null)
			{
				return null;
			}
			JProperty jProperty = Property(propertyName);
			if (jProperty != null)
			{
				return jProperty.Value;
			}
			if (comparison != StringComparison.Ordinal)
			{
				foreach (JProperty property in _properties)
				{
					if (string.Equals(property.Name, propertyName, comparison))
					{
						return property.Value;
					}
				}
			}
			return null;
		}

		public bool TryGetValue(string propertyName, StringComparison comparison, out JToken value)
		{
			value = GetValue(propertyName, comparison);
			return value != null;
		}

		public void Add(string propertyName, JToken value)
		{
			Add(new JProperty(propertyName, value));
		}

		bool IDictionary<string, JToken>.ContainsKey(string key)
		{
			return _properties.Contains(key);
		}

		public bool Remove(string propertyName)
		{
			JProperty jProperty = Property(propertyName);
			if (jProperty == null)
			{
				return false;
			}
			jProperty.Remove();
			return true;
		}

		public bool TryGetValue(string propertyName, out JToken value)
		{
			JProperty jProperty = Property(propertyName);
			if (jProperty == null)
			{
				value = null;
				return false;
			}
			value = jProperty.Value;
			return true;
		}

		void ICollection<KeyValuePair<string, JToken>>.Add(KeyValuePair<string, JToken> item)
		{
			Add(new JProperty(item.Key, item.Value));
		}

		void ICollection<KeyValuePair<string, JToken>>.Clear()
		{
			RemoveAll();
		}

		bool ICollection<KeyValuePair<string, JToken>>.Contains(KeyValuePair<string, JToken> item)
		{
			JProperty jProperty = Property(item.Key);
			if (jProperty == null)
			{
				return false;
			}
			return jProperty.Value == item.Value;
		}

		void ICollection<KeyValuePair<string, JToken>>.CopyTo(KeyValuePair<string, JToken>[] array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (arrayIndex < 0)
			{
				throw new ArgumentOutOfRangeException("arrayIndex", "arrayIndex is less than 0.");
			}
			if (arrayIndex >= array.Length && arrayIndex != 0)
			{
				throw new ArgumentException("arrayIndex is equal to or greater than the length of array.");
			}
			if (base.Count > array.Length - arrayIndex)
			{
				throw new ArgumentException("The number of elements in the source JObject is greater than the available space from arrayIndex to the end of the destination array.");
			}
			int num = 0;
			foreach (JProperty property in _properties)
			{
				array[arrayIndex + num] = new KeyValuePair<string, JToken>(property.Name, property.Value);
				num++;
			}
		}

		bool ICollection<KeyValuePair<string, JToken>>.Remove(KeyValuePair<string, JToken> item)
		{
			if (!((ICollection<KeyValuePair<string, JToken>>)this).Contains(item))
			{
				return false;
			}
			((IDictionary<string, JToken>)this).Remove(item.Key);
			return true;
		}

		internal override int GetDeepHashCode()
		{
			return ContentsHashCode();
		}

		public IEnumerator<KeyValuePair<string, JToken>> GetEnumerator()
		{
			foreach (JProperty property in _properties)
			{
				yield return new KeyValuePair<string, JToken>(property.Name, property.Value);
			}
		}

		protected virtual void OnPropertyChanged(string propertyName)
		{
			if (this.PropertyChanged != null)
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}

		protected virtual void OnPropertyChanging(string propertyName)
		{
			if (this.PropertyChanging != null)
			{
				this.PropertyChanging(this, new PropertyChangingEventArgs(propertyName));
			}
		}

		PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties()
		{
			return ((ICustomTypeDescriptor)this).GetProperties((Attribute[])null);
		}

		PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes)
		{
			PropertyDescriptorCollection propertyDescriptorCollection = new PropertyDescriptorCollection(null);
			using IEnumerator<KeyValuePair<string, JToken>> enumerator = GetEnumerator();
			while (enumerator.MoveNext())
			{
				propertyDescriptorCollection.Add(new JPropertyDescriptor(enumerator.Current.Key));
			}
			return propertyDescriptorCollection;
		}

		AttributeCollection ICustomTypeDescriptor.GetAttributes()
		{
			return AttributeCollection.Empty;
		}

		string ICustomTypeDescriptor.GetClassName()
		{
			return null;
		}

		string ICustomTypeDescriptor.GetComponentName()
		{
			return null;
		}

		TypeConverter ICustomTypeDescriptor.GetConverter()
		{
			return new TypeConverter();
		}

		EventDescriptor ICustomTypeDescriptor.GetDefaultEvent()
		{
			return null;
		}

		PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty()
		{
			return null;
		}

		object ICustomTypeDescriptor.GetEditor(Type editorBaseType)
		{
			return null;
		}

		EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes)
		{
			return EventDescriptorCollection.Empty;
		}

		EventDescriptorCollection ICustomTypeDescriptor.GetEvents()
		{
			return EventDescriptorCollection.Empty;
		}

		object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd)
		{
			return null;
		}
	}
	[Preserve]
	public class JArray : JContainer, IList<JToken>, ICollection<JToken>, IEnumerable<JToken>, IEnumerable
	{
		private readonly List<JToken> _values = new List<JToken>();

		protected override IList<JToken> ChildrenTokens => _values;

		public override JTokenType Type => JTokenType.Array;

		public override JToken this[object key]
		{
			get
			{
				ValidationUtils.ArgumentNotNull(key, "key");
				if (!(key is int))
				{
					throw new ArgumentException("Accessed JArray values with invalid key value: {0}. Int32 array index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
				}
				return GetItem((int)key);
			}
			set
			{
				ValidationUtils.ArgumentNotNull(key, "key");
				if (!(key is int))
				{
					throw new ArgumentException("Set JArray values with invalid key value: {0}. Int32 array index expected.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.ToString(key)));
				}
				SetItem((int)key, value);
			}
		}

		public JToken this[int index]
		{
			get
			{
				return GetItem(index);
			}
			set
			{
				SetItem(index, value);
			}
		}

		public bool IsReadOnly => false;

		public JArray()
		{
		}

		public JArray(JArray other)
			: base(other)
		{
		}

		public JArray(params object[] content)
			: this((object)content)
		{
		}

		public JArray(object content)
		{
			Add(content);
		}

		internal override bool DeepEquals(JToken node)
		{
			if (node is JArray container)
			{
				return ContentsEqual(container);
			}
			return false;
		}

		internal override JToken CloneToken()
		{
			return new JArray(this);
		}

		public new static JArray Load(JsonReader reader)
		{
			return Load(reader, null);
		}

		public new static JArray Load(JsonReader reader, JsonLoadSettings settings)
		{
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading JArray from JsonReader.");
			}
			reader.MoveToContent();
			if (reader.TokenType != JsonToken.StartArray)
			{
				throw JsonReaderException.Create(reader, "Error reading JArray from JsonReader. Current JsonReader item is not an array: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JArray jArray = new JArray();
			jArray.SetLineInfo(reader as IJsonLineInfo, settings);
			jArray.ReadTokenFrom(reader, settings);
			return jArray;
		}

		public new static JArray Parse(string json)
		{
			return Parse(json, null);
		}

		public new static JArray Parse(string json, JsonLoadSettings settings)
		{
			using JsonReader jsonReader = new JsonTextReader(new StringReader(json));
			JArray result = Load(jsonReader, settings);
			if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
			{
				throw JsonReaderException.Create(jsonReader, "Additional text found in JSON string after parsing content.");
			}
			return result;
		}

		public new static JArray FromObject(object o)
		{
			return FromObject(o, JsonSerializer.CreateDefault());
		}

		public new static JArray FromObject(object o, JsonSerializer jsonSerializer)
		{
			JToken jToken = JToken.FromObjectInternal(o, jsonSerializer);
			if (jToken.Type != JTokenType.Array)
			{
				throw new ArgumentException("Object serialized to {0}. JArray instance expected.".FormatWith(CultureInfo.InvariantCulture, jToken.Type));
			}
			return (JArray)jToken;
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WriteStartArray();
			for (int i = 0; i < _values.Count; i++)
			{
				_values[i].WriteTo(writer, converters);
			}
			writer.WriteEndArray();
		}

		internal override int IndexOfItem(JToken item)
		{
			return _values.IndexOfReference(item);
		}

		internal override void MergeItem(object content, JsonMergeSettings settings)
		{
			IEnumerable enumerable = ((IsMultiContent(content) || content is JArray) ? ((IEnumerable)content) : null);
			if (enumerable != null)
			{
				JContainer.MergeEnumerableContent(this, enumerable, settings);
			}
		}

		public int IndexOf(JToken item)
		{
			return IndexOfItem(item);
		}

		public void Insert(int index, JToken item)
		{
			InsertItem(index, item, skipParentCheck: false);
		}

		public void RemoveAt(int index)
		{
			RemoveItemAt(index);
		}

		public IEnumerator<JToken> GetEnumerator()
		{
			return Children().GetEnumerator();
		}

		public void Add(JToken item)
		{
			Add((object)item);
		}

		public void Clear()
		{
			ClearItems();
		}

		public bool Contains(JToken item)
		{
			return ContainsItem(item);
		}

		public void CopyTo(JToken[] array, int arrayIndex)
		{
			CopyItemsTo(array, arrayIndex);
		}

		public bool Remove(JToken item)
		{
			return RemoveItem(item);
		}

		internal override int GetDeepHashCode()
		{
			return ContentsHashCode();
		}
	}
	[Preserve]
	public class JTokenReader : JsonReader, IJsonLineInfo
	{
		private readonly JToken _root;

		private string _initialPath;

		private JToken _parent;

		private JToken _current;

		public JToken CurrentToken => _current;

		int IJsonLineInfo.LineNumber
		{
			get
			{
				if (base.CurrentState == State.Start)
				{
					return 0;
				}
				return ((IJsonLineInfo)_current)?.LineNumber ?? 0;
			}
		}

		int IJsonLineInfo.LinePosition
		{
			get
			{
				if (base.CurrentState == State.Start)
				{
					return 0;
				}
				return ((IJsonLineInfo)_current)?.LinePosition ?? 0;
			}
		}

		public override string Path
		{
			get
			{
				string text = base.Path;
				if (_initialPath == null)
				{
					_initialPath = _root.Path;
				}
				if (!string.IsNullOrEmpty(_initialPath))
				{
					if (string.IsNullOrEmpty(text))
					{
						return _initialPath;
					}
					text = ((!StringUtils.StartsWith(text, '[')) ? (_initialPath + "." + text) : (_initialPath + text));
				}
				return text;
			}
		}

		public JTokenReader(JToken token)
		{
			ValidationUtils.ArgumentNotNull(token, "token");
			_root = token;
		}

		internal JTokenReader(JToken token, string initialPath)
			: this(token)
		{
			_initialPath = initialPath;
		}

		public override bool Read()
		{
			if (base.CurrentState != State.Start)
			{
				if (_current == null)
				{
					return false;
				}
				if (_current is JContainer jContainer && _parent != jContainer)
				{
					return ReadInto(jContainer);
				}
				return ReadOver(_current);
			}
			_current = _root;
			SetToken(_current);
			return true;
		}

		private bool ReadOver(JToken t)
		{
			if (t == _root)
			{
				return ReadToEnd();
			}
			JToken next = t.Next;
			if (next == null || next == t || t == t.Parent.Last)
			{
				if (t.Parent == null)
				{
					return ReadToEnd();
				}
				return SetEnd(t.Parent);
			}
			_current = next;
			SetToken(_current);
			return true;
		}

		private bool ReadToEnd()
		{
			_current = null;
			SetToken(JsonToken.None);
			return false;
		}

		private JsonToken? GetEndToken(JContainer c)
		{
			return c.Type switch
			{
				JTokenType.Object => JsonToken.EndObject, 
				JTokenType.Array => JsonToken.EndArray, 
				JTokenType.Constructor => JsonToken.EndConstructor, 
				JTokenType.Property => null, 
				_ => throw MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", c.Type, "Unexpected JContainer type."), 
			};
		}

		private bool ReadInto(JContainer c)
		{
			JToken first = c.First;
			if (first == null)
			{
				return SetEnd(c);
			}
			SetToken(first);
			_current = first;
			_parent = c;
			return true;
		}

		private bool SetEnd(JContainer c)
		{
			JsonToken? endToken = GetEndToken(c);
			if (endToken.HasValue)
			{
				SetToken(endToken.GetValueOrDefault());
				_current = c;
				_parent = c;
				return true;
			}
			return ReadOver(c);
		}

		private void SetToken(JToken token)
		{
			switch (token.Type)
			{
			case JTokenType.Object:
				SetToken(JsonToken.StartObject);
				break;
			case JTokenType.Array:
				SetToken(JsonToken.StartArray);
				break;
			case JTokenType.Constructor:
				SetToken(JsonToken.StartConstructor, ((JConstructor)token).Name);
				break;
			case JTokenType.Property:
				SetToken(JsonToken.PropertyName, ((JProperty)token).Name);
				break;
			case JTokenType.Comment:
				SetToken(JsonToken.Comment, ((JValue)token).Value);
				break;
			case JTokenType.Integer:
				SetToken(JsonToken.Integer, ((JValue)token).Value);
				break;
			case JTokenType.Float:
				SetToken(JsonToken.Float, ((JValue)token).Value);
				break;
			case JTokenType.String:
				SetToken(JsonToken.String, ((JValue)token).Value);
				break;
			case JTokenType.Boolean:
				SetToken(JsonToken.Boolean, ((JValue)token).Value);
				break;
			case JTokenType.Null:
				SetToken(JsonToken.Null, ((JValue)token).Value);
				break;
			case JTokenType.Undefined:
				SetToken(JsonToken.Undefined, ((JValue)token).Value);
				break;
			case JTokenType.Date:
				SetToken(JsonToken.Date, ((JValue)token).Value);
				break;
			case JTokenType.Raw:
				SetToken(JsonToken.Raw, ((JValue)token).Value);
				break;
			case JTokenType.Bytes:
				SetToken(JsonToken.Bytes, ((JValue)token).Value);
				break;
			case JTokenType.Guid:
				SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
				break;
			case JTokenType.Uri:
			{
				object value = ((JValue)token).Value;
				if (value is Uri)
				{
					SetToken(JsonToken.String, ((Uri)value).OriginalString);
				}
				else
				{
					SetToken(JsonToken.String, SafeToString(value));
				}
				break;
			}
			case JTokenType.TimeSpan:
				SetToken(JsonToken.String, SafeToString(((JValue)token).Value));
				break;
			default:
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException("Type", token.Type, "Unexpected JTokenType.");
			}
		}

		private string SafeToString(object value)
		{
			return value?.ToString();
		}

		bool IJsonLineInfo.HasLineInfo()
		{
			if (base.CurrentState == State.Start)
			{
				return false;
			}
			return ((IJsonLineInfo)_current)?.HasLineInfo() ?? false;
		}
	}
	[Preserve]
	public class JTokenWriter : JsonWriter
	{
		private JContainer _token;

		private JContainer _parent;

		private JValue _value;

		private JToken _current;

		public JToken CurrentToken => _current;

		public JToken Token
		{
			get
			{
				if (_token != null)
				{
					return _token;
				}
				return _value;
			}
		}

		public JTokenWriter(JContainer container)
		{
			ValidationUtils.ArgumentNotNull(container, "container");
			_token = container;
			_parent = container;
		}

		public JTokenWriter()
		{
		}

		public override void Flush()
		{
		}

		public override void Close()
		{
			base.Close();
		}

		public override void WriteStartObject()
		{
			base.WriteStartObject();
			AddParent(new JObject());
		}

		private void AddParent(JContainer container)
		{
			if (_parent == null)
			{
				_token = container;
			}
			else
			{
				_parent.AddAndSkipParentCheck(container);
			}
			_parent = container;
			_current = container;
		}

		private void RemoveParent()
		{
			_current = _parent;
			_parent = _parent.Parent;
			if (_parent != null && _parent.Type == JTokenType.Property)
			{
				_parent = _parent.Parent;
			}
		}

		public override void WriteStartArray()
		{
			base.WriteStartArray();
			AddParent(new JArray());
		}

		public override void WriteStartConstructor(string name)
		{
			base.WriteStartConstructor(name);
			AddParent(new JConstructor(name));
		}

		protected override void WriteEnd(JsonToken token)
		{
			RemoveParent();
		}

		public override void WritePropertyName(string name)
		{
			if (_parent is JObject jObject)
			{
				jObject.Remove(name);
			}
			AddParent(new JProperty(name));
			base.WritePropertyName(name);
		}

		private void AddValue(object value, JsonToken token)
		{
			AddValue(new JValue(value), token);
		}

		internal void AddValue(JValue value, JsonToken token)
		{
			if (_parent != null)
			{
				_parent.Add(value);
				_current = _parent.Last;
				if (_parent.Type == JTokenType.Property)
				{
					_parent = _parent.Parent;
				}
			}
			else
			{
				_value = value ?? JValue.CreateNull();
				_current = _value;
			}
		}

		public override void WriteValue(object value)
		{
			base.WriteValue(value);
		}

		public override void WriteNull()
		{
			base.WriteNull();
			AddValue(null, JsonToken.Null);
		}

		public override void WriteUndefined()
		{
			base.WriteUndefined();
			AddValue(null, JsonToken.Undefined);
		}

		public override void WriteRaw(string json)
		{
			base.WriteRaw(json);
			AddValue(new JRaw(json), JsonToken.Raw);
		}

		public override void WriteComment(string text)
		{
			base.WriteComment(text);
			AddValue(JValue.CreateComment(text), JsonToken.Comment);
		}

		public override void WriteValue(string value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}

		public override void WriteValue(int value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public override void WriteValue(uint value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(long value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public override void WriteValue(ulong value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(float value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Float);
		}

		public override void WriteValue(double value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Float);
		}

		public override void WriteValue(bool value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Boolean);
		}

		public override void WriteValue(short value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public override void WriteValue(ushort value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(char value)
		{
			base.WriteValue(value);
			string text = null;
			text = value.ToString(CultureInfo.InvariantCulture);
			AddValue(text, JsonToken.String);
		}

		public override void WriteValue(byte value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		[CLSCompliant(false)]
		public override void WriteValue(sbyte value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Integer);
		}

		public override void WriteValue(decimal value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Float);
		}

		public override void WriteValue(DateTime value)
		{
			base.WriteValue(value);
			value = DateTimeUtils.EnsureDateTime(value, base.DateTimeZoneHandling);
			AddValue(value, JsonToken.Date);
		}

		public override void WriteValue(DateTimeOffset value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Date);
		}

		public override void WriteValue(byte[] value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.Bytes);
		}

		public override void WriteValue(TimeSpan value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}

		public override void WriteValue(Guid value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}

		public override void WriteValue(Uri value)
		{
			base.WriteValue(value);
			AddValue(value, JsonToken.String);
		}

		internal override void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments)
		{
			JTokenReader jTokenReader = reader as JTokenReader;
			if (jTokenReader != null && writeChildren && writeDateConstructorAsDate && writeComments)
			{
				if (jTokenReader.TokenType == JsonToken.None && !jTokenReader.Read())
				{
					return;
				}
				JToken jToken = jTokenReader.CurrentToken.CloneToken();
				if (_parent != null)
				{
					_parent.Add(jToken);
					_current = _parent.Last;
					if (_parent.Type == JTokenType.Property)
					{
						_parent = _parent.Parent;
						InternalWriteValue(JsonToken.Null);
					}
				}
				else
				{
					_current = jToken;
					if (_token == null && _value == null)
					{
						_token = jToken as JContainer;
						_value = jToken as JValue;
					}
				}
				jTokenReader.Skip();
			}
			else
			{
				base.WriteToken(reader, writeChildren, writeDateConstructorAsDate, writeComments);
			}
		}
	}
	[Preserve]
	public abstract class JToken : IJEnumerable<JToken>, IEnumerable<JToken>, IEnumerable, IJsonLineInfo, ICloneable
	{
		private class LineInfoAnnotation
		{
			internal readonly int LineNumber;

			internal readonly int LinePosition;

			public LineInfoAnnotation(int lineNumber, int linePosition)
			{
				LineNumber = lineNumber;
				LinePosition = linePosition;
			}
		}

		private static JTokenEqualityComparer _equalityComparer;

		private JContainer _parent;

		private JToken _previous;

		private JToken _next;

		private object _annotations;

		private static readonly JTokenType[] BooleanTypes = new JTokenType[6]
		{
			JTokenType.Integer,
			JTokenType.Float,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Boolean
		};

		private static readonly JTokenType[] NumberTypes = new JTokenType[6]
		{
			JTokenType.Integer,
			JTokenType.Float,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Boolean
		};

		private static readonly JTokenType[] StringTypes = new JTokenType[11]
		{
			JTokenType.Date,
			JTokenType.Integer,
			JTokenType.Float,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Boolean,
			JTokenType.Bytes,
			JTokenType.Guid,
			JTokenType.TimeSpan,
			JTokenType.Uri
		};

		private static readonly JTokenType[] GuidTypes = new JTokenType[5]
		{
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Guid,
			JTokenType.Bytes
		};

		private static readonly JTokenType[] TimeSpanTypes = new JTokenType[4]
		{
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.TimeSpan
		};

		private static readonly JTokenType[] UriTypes = new JTokenType[4]
		{
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Uri
		};

		private static readonly JTokenType[] CharTypes = new JTokenType[5]
		{
			JTokenType.Integer,
			JTokenType.Float,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw
		};

		private static readonly JTokenType[] DateTimeTypes = new JTokenType[4]
		{
			JTokenType.Date,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw
		};

		private static readonly JTokenType[] BytesTypes = new JTokenType[5]
		{
			JTokenType.Bytes,
			JTokenType.String,
			JTokenType.Comment,
			JTokenType.Raw,
			JTokenType.Integer
		};

		public static JTokenEqualityComparer EqualityComparer
		{
			get
			{
				if (_equalityComparer == null)
				{
					_equalityComparer = new JTokenEqualityComparer();
				}
				return _equalityComparer;
			}
		}

		public JContainer Parent
		{
			[DebuggerStepThrough]
			get
			{
				return _parent;
			}
			internal set
			{
				_parent = value;
			}
		}

		public JToken Root
		{
			get
			{
				JContainer parent = Parent;
				if (parent == null)
				{
					return this;
				}
				while (parent.Parent != null)
				{
					parent = parent.Parent;
				}
				return parent;
			}
		}

		public abstract JTokenType Type { get; }

		public abstract bool HasValues { get; }

		public JToken Next
		{
			get
			{
				return _next;
			}
			internal set
			{
				_next = value;
			}
		}

		public JToken Previous
		{
			get
			{
				return _previous;
			}
			internal set
			{
				_previous = value;
			}
		}

		public string Path
		{
			get
			{
				if (Parent == null)
				{
					return string.Empty;
				}
				List<JsonPosition> list = new List<JsonPosition>();
				JToken jToken = null;
				for (JToken jToken2 = this; jToken2 != null; jToken2 = jToken2.Parent)
				{
					switch (jToken2.Type)
					{
					case JTokenType.Property:
					{
						JProperty jProperty = (JProperty)jToken2;
						list.Add(new JsonPosition(JsonContainerType.Object)
						{
							PropertyName = jProperty.Name
						});
						break;
					}
					case JTokenType.Array:
					case JTokenType.Constructor:
						if (jToken != null)
						{
							int position = ((IList<JToken>)jToken2).IndexOf(jToken);
							list.Add(new JsonPosition(JsonContainerType.Array)
							{
								Position = position
							});
						}
						break;
					}
					jToken = jToken2;
				}
				list.Reverse();
				return JsonPosition.BuildPath(list, null);
			}
		}

		public virtual JToken this[object key]
		{
			get
			{
				throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
			set
			{
				throw new InvalidOperationException("Cannot set child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
		}

		public virtual JToken First
		{
			get
			{
				throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
		}

		public virtual JToken Last
		{
			get
			{
				throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
			}
		}

		IJEnumerable<JToken> IJEnumerable<JToken>.this[object key] => this[key];

		int IJsonLineInfo.LineNumber => Annotation<LineInfoAnnotation>()?.LineNumber ?? 0;

		int IJsonLineInfo.LinePosition => Annotation<LineInfoAnnotation>()?.LinePosition ?? 0;

		internal abstract JToken CloneToken();

		internal abstract bool DeepEquals(JToken node);

		public static bool DeepEquals(JToken t1, JToken t2)
		{
			if (t1 != t2)
			{
				if (t1 != null && t2 != null)
				{
					return t1.DeepEquals(t2);
				}
				return false;
			}
			return true;
		}

		internal JToken()
		{
		}

		public void AddAfterSelf(object content)
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			int num = _parent.IndexOfItem(this);
			_parent.AddInternal(num + 1, content, skipParentCheck: false);
		}

		public void AddBeforeSelf(object content)
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			int index = _parent.IndexOfItem(this);
			_parent.AddInternal(index, content, skipParentCheck: false);
		}

		public IEnumerable<JToken> Ancestors()
		{
			return GetAncestors(self: false);
		}

		public IEnumerable<JToken> AncestorsAndSelf()
		{
			return GetAncestors(self: true);
		}

		internal IEnumerable<JToken> GetAncestors(bool self)
		{
			for (JToken current = (self ? this : Parent); current != null; current = current.Parent)
			{
				yield return current;
			}
		}

		public IEnumerable<JToken> AfterSelf()
		{
			if (Parent != null)
			{
				for (JToken o = Next; o != null; o = o.Next)
				{
					yield return o;
				}
			}
		}

		public IEnumerable<JToken> BeforeSelf()
		{
			for (JToken o = Parent.First; o != this; o = o.Next)
			{
				yield return o;
			}
		}

		public virtual T Value<T>(object key)
		{
			JToken jToken = this[key];
			if (jToken != null)
			{
				return jToken.Convert<JToken, T>();
			}
			return default(T);
		}

		public virtual JEnumerable<JToken> Children()
		{
			return JEnumerable<JToken>.Empty;
		}

		public JEnumerable<T> Children<T>() where T : JToken
		{
			return new JEnumerable<T>(Children().OfType<T>());
		}

		public virtual IEnumerable<T> Values<T>()
		{
			throw new InvalidOperationException("Cannot access child value on {0}.".FormatWith(CultureInfo.InvariantCulture, GetType()));
		}

		public void Remove()
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			_parent.RemoveItem(this);
		}

		public void Replace(JToken value)
		{
			if (_parent == null)
			{
				throw new InvalidOperationException("The parent is missing.");
			}
			_parent.ReplaceItem(this, value);
		}

		public abstract void WriteTo(JsonWriter writer, params JsonConverter[] converters);

		public override string ToString()
		{
			return ToString(Formatting.Indented);
		}

		public string ToString(Formatting formatting, params JsonConverter[] converters)
		{
			using StringWriter stringWriter = new StringWriter(CultureInfo.InvariantCulture);
			JsonTextWriter jsonTextWriter = new JsonTextWriter(stringWriter);
			jsonTextWriter.Formatting = formatting;
			WriteTo(jsonTextWriter, converters);
			return stringWriter.ToString();
		}

		private static JValue EnsureValue(JToken value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (value is JProperty)
			{
				value = ((JProperty)value).Value;
			}
			return value as JValue;
		}

		private static string GetType(JToken token)
		{
			ValidationUtils.ArgumentNotNull(token, "token");
			if (token is JProperty)
			{
				token = ((JProperty)token).Value;
			}
			return token.Type.ToString();
		}

		private static bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable)
		{
			if (Array.IndexOf(validTypes, o.Type) == -1)
			{
				if (nullable)
				{
					if (o.Type != JTokenType.Null)
					{
						return o.Type == JTokenType.Undefined;
					}
					return true;
				}
				return false;
			}
			return true;
		}

		public static explicit operator bool(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, BooleanTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Boolean.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToBoolean(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator DateTimeOffset(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, DateTimeTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to DateTimeOffset.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is DateTimeOffset)
			{
				return (DateTimeOffset)jValue.Value;
			}
			if (jValue.Value is string)
			{
				return DateTimeOffset.Parse((string)jValue.Value, CultureInfo.InvariantCulture);
			}
			return new DateTimeOffset(Convert.ToDateTime(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator bool?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, BooleanTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Boolean.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToBoolean(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator long(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Int64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToInt64(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator DateTime?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, DateTimeTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to DateTime.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is DateTimeOffset)
			{
				return ((DateTimeOffset)jValue.Value).DateTime;
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToDateTime(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator DateTimeOffset?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, DateTimeTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to DateTimeOffset.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			if (jValue.Value is DateTimeOffset)
			{
				return (DateTimeOffset?)jValue.Value;
			}
			if (jValue.Value is string)
			{
				return DateTimeOffset.Parse((string)jValue.Value, CultureInfo.InvariantCulture);
			}
			return new DateTimeOffset(Convert.ToDateTime(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator decimal?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Decimal.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToDecimal(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator double?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Double.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToDouble(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator char?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, CharTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Char.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToChar(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator int(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Int32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToInt32(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator short(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Int16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToInt16(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator ushort(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to UInt16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToUInt16(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator char(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, CharTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Char.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToChar(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator byte(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Byte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToByte(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator sbyte(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to SByte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToSByte(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator int?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Int32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToInt32(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator short?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Int16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToInt16(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator ushort?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to UInt16.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToUInt16(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator byte?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Byte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToByte(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator sbyte?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to SByte.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToSByte(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator DateTime(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, DateTimeTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to DateTime.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is DateTimeOffset)
			{
				return ((DateTimeOffset)jValue.Value).DateTime;
			}
			return Convert.ToDateTime(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator long?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Int64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToInt64(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator float?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Single.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToSingle(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator decimal(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Decimal.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToDecimal(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator uint?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to UInt32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToUInt32(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator ulong?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to UInt64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return Convert.ToUInt64(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator double(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Double.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToDouble(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator float(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Single.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToSingle(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator string(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, StringTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to String.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			if (jValue.Value is byte[])
			{
				return Convert.ToBase64String((byte[])jValue.Value);
			}
			return Convert.ToString(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator uint(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to UInt32.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToUInt32(jValue.Value, CultureInfo.InvariantCulture);
		}

		[CLSCompliant(false)]
		public static explicit operator ulong(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, NumberTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to UInt64.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			return Convert.ToUInt64(jValue.Value, CultureInfo.InvariantCulture);
		}

		public static explicit operator byte[](JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, BytesTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to byte array.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is string)
			{
				return Convert.FromBase64String(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
			}
			if (jValue.Value is byte[])
			{
				return (byte[])jValue.Value;
			}
			throw new ArgumentException("Can not convert {0} to byte array.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
		}

		public static explicit operator Guid(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, GuidTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to Guid.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value is byte[])
			{
				return new Guid((byte[])jValue.Value);
			}
			if (!(jValue.Value is Guid))
			{
				return new Guid(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
			}
			return (Guid)jValue.Value;
		}

		public static explicit operator Guid?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, GuidTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Guid.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			if (jValue.Value is byte[])
			{
				return new Guid((byte[])jValue.Value);
			}
			return (jValue.Value is Guid) ? ((Guid)jValue.Value) : new Guid(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator TimeSpan(JToken value)
		{
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, TimeSpanTypes, nullable: false))
			{
				throw new ArgumentException("Can not convert {0} to TimeSpan.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (!(jValue.Value is TimeSpan))
			{
				return ConvertUtils.ParseTimeSpan(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
			}
			return (TimeSpan)jValue.Value;
		}

		public static explicit operator TimeSpan?(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, TimeSpanTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to TimeSpan.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			return (jValue.Value is TimeSpan) ? ((TimeSpan)jValue.Value) : ConvertUtils.ParseTimeSpan(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
		}

		public static explicit operator Uri(JToken value)
		{
			if (value == null)
			{
				return null;
			}
			JValue jValue = EnsureValue(value);
			if (jValue == null || !ValidateToken(jValue, UriTypes, nullable: true))
			{
				throw new ArgumentException("Can not convert {0} to Uri.".FormatWith(CultureInfo.InvariantCulture, GetType(value)));
			}
			if (jValue.Value == null)
			{
				return null;
			}
			if (!(jValue.Value is Uri))
			{
				return new Uri(Convert.ToString(jValue.Value, CultureInfo.InvariantCulture));
			}
			return (Uri)jValue.Value;
		}

		public static implicit operator JToken(bool value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(DateTimeOffset value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(byte value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(byte? value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(sbyte value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(sbyte? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(bool? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(long value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(DateTime? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(DateTimeOffset? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(decimal? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(double? value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(short value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(ushort value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(int value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(int? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(DateTime value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(long? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(float? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(decimal value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(short? value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(ushort? value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(uint? value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(ulong? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(double value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(float value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(string value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(uint value)
		{
			return new JValue(value);
		}

		[CLSCompliant(false)]
		public static implicit operator JToken(ulong value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(byte[] value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(Uri value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(TimeSpan value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(TimeSpan? value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(Guid value)
		{
			return new JValue(value);
		}

		public static implicit operator JToken(Guid? value)
		{
			return new JValue(value);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<JToken>)this).GetEnumerator();
		}

		IEnumerator<JToken> IEnumerable<JToken>.GetEnumerator()
		{
			return Children().GetEnumerator();
		}

		internal abstract int GetDeepHashCode();

		public JsonReader CreateReader()
		{
			return new JTokenReader(this);
		}

		internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer)
		{
			ValidationUtils.ArgumentNotNull(o, "o");
			ValidationUtils.ArgumentNotNull(jsonSerializer, "jsonSerializer");
			using JTokenWriter jTokenWriter = new JTokenWriter();
			jsonSerializer.Serialize(jTokenWriter, o);
			return jTokenWriter.Token;
		}

		public static JToken FromObject(object o)
		{
			return FromObjectInternal(o, JsonSerializer.CreateDefault());
		}

		public static JToken FromObject(object o, JsonSerializer jsonSerializer)
		{
			return FromObjectInternal(o, jsonSerializer);
		}

		public T ToObject<T>()
		{
			return (T)ToObject(typeof(T));
		}

		public object ToObject(Type objectType)
		{
			if (JsonConvert.DefaultSettings == null)
			{
				bool isEnum;
				PrimitiveTypeCode typeCode = ConvertUtils.GetTypeCode(objectType, out isEnum);
				if (isEnum)
				{
					if (Type == JTokenType.String)
					{
						try
						{
							return ToObject(objectType, JsonSerializer.CreateDefault());
						}
						catch (Exception innerException)
						{
							Type type = (objectType.IsEnum() ? objectType : Nullable.GetUnderlyingType(objectType));
							throw new ArgumentException("Could not convert '{0}' to {1}.".FormatWith(CultureInfo.InvariantCulture, (string)this, type.Name), innerException);
						}
					}
					if (Type == JTokenType.Integer)
					{
						return Enum.ToObject(objectType.IsEnum() ? objectType : Nullable.GetUnderlyingType(objectType), ((JValue)this).Value);
					}
				}
				switch (typeCode)
				{
				case PrimitiveTypeCode.BooleanNullable:
					return (bool?)this;
				case PrimitiveTypeCode.Boolean:
					return (bool)this;
				case PrimitiveTypeCode.CharNullable:
					return (char?)this;
				case PrimitiveTypeCode.Char:
					return (char)this;
				case PrimitiveTypeCode.SByte:
					return (sbyte?)this;
				case PrimitiveTypeCode.SByteNullable:
					return (sbyte)this;
				case PrimitiveTypeCode.ByteNullable:
					return (byte?)this;
				case PrimitiveTypeCode.Byte:
					return (byte)this;
				case PrimitiveTypeCode.Int16Nullable:
					return (short?)this;
				case PrimitiveTypeCode.Int16:
					return (short)this;
				case PrimitiveTypeCode.UInt16Nullable:
					return (ushort?)this;
				case PrimitiveTypeCode.UInt16:
					return (ushort)this;
				case PrimitiveTypeCode.Int32Nullable:
					return (int?)this;
				case PrimitiveTypeCode.Int32:
					return (int)this;
				case PrimitiveTypeCode.UInt32Nullable:
					return (uint?)this;
				case PrimitiveTypeCode.UInt32:
					return (uint)this;
				case PrimitiveTypeCode.Int64Nullable:
					return (long?)this;
				case PrimitiveTypeCode.Int64:
					return (long)this;
				case PrimitiveTypeCode.UInt64Nullable:
					return (ulong?)this;
				case PrimitiveTypeCode.UInt64:
					return (ulong)this;
				case PrimitiveTypeCode.SingleNullable:
					return (float?)this;
				case PrimitiveTypeCode.Single:
					return (float)this;
				case PrimitiveTypeCode.DoubleNullable:
					return (double?)this;
				case PrimitiveTypeCode.Double:
					return (double)this;
				case PrimitiveTypeCode.DecimalNullable:
					return (decimal?)this;
				case PrimitiveTypeCode.Decimal:
					return (decimal)this;
				case PrimitiveTypeCode.DateTimeNullable:
					return (DateTime?)this;
				case PrimitiveTypeCode.DateTime:
					return (DateTime)this;
				case PrimitiveTypeCode.DateTimeOffsetNullable:
					return (DateTimeOffset?)this;
				case PrimitiveTypeCode.DateTimeOffset:
					return (DateTimeOffset)this;
				case PrimitiveTypeCode.String:
					return (string)this;
				case PrimitiveTypeCode.GuidNullable:
					return (Guid?)this;
				case PrimitiveTypeCode.Guid:
					return (Guid)this;
				case PrimitiveTypeCode.Uri:
					return (Uri)this;
				case PrimitiveTypeCode.TimeSpanNullable:
					return (TimeSpan?)this;
				case PrimitiveTypeCode.TimeSpan:
					return (TimeSpan)this;
				}
			}
			return ToObject(objectType, JsonSerializer.CreateDefault());
		}

		public T ToObject<T>(JsonSerializer jsonSerializer)
		{
			return (T)ToObject(typeof(T), jsonSerializer);
		}

		public object ToObject(Type objectType, JsonSerializer jsonSerializer)
		{
			ValidationUtils.ArgumentNotNull(jsonSerializer, "jsonSerializer");
			using JTokenReader reader = new JTokenReader(this);
			return jsonSerializer.Deserialize(reader, objectType);
		}

		public static JToken ReadFrom(JsonReader reader)
		{
			return ReadFrom(reader, null);
		}

		public static JToken ReadFrom(JsonReader reader, JsonLoadSettings settings)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			if (reader.TokenType == JsonToken.None && !((settings != null && settings.CommentHandling == CommentHandling.Ignore) ? reader.ReadAndMoveToContent() : reader.Read()))
			{
				throw JsonReaderException.Create(reader, "Error reading JToken from JsonReader.");
			}
			IJsonLineInfo lineInfo = reader as IJsonLineInfo;
			switch (reader.TokenType)
			{
			case JsonToken.StartObject:
				return JObject.Load(reader, settings);
			case JsonToken.StartArray:
				return JArray.Load(reader, settings);
			case JsonToken.StartConstructor:
				return JConstructor.Load(reader, settings);
			case JsonToken.PropertyName:
				return JProperty.Load(reader, settings);
			case JsonToken.Integer:
			case JsonToken.Float:
			case JsonToken.String:
			case JsonToken.Boolean:
			case JsonToken.Date:
			case JsonToken.Bytes:
			{
				JValue jValue4 = new JValue(reader.Value);
				jValue4.SetLineInfo(lineInfo, settings);
				return jValue4;
			}
			case JsonToken.Comment:
			{
				JValue jValue3 = JValue.CreateComment(reader.Value.ToString());
				jValue3.SetLineInfo(lineInfo, settings);
				return jValue3;
			}
			case JsonToken.Null:
			{
				JValue jValue2 = JValue.CreateNull();
				jValue2.SetLineInfo(lineInfo, settings);
				return jValue2;
			}
			case JsonToken.Undefined:
			{
				JValue jValue = JValue.CreateUndefined();
				jValue.SetLineInfo(lineInfo, settings);
				return jValue;
			}
			default:
				throw JsonReaderException.Create(reader, "Error reading JToken from JsonReader. Unexpected token: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
		}

		public static JToken Parse(string json)
		{
			return Parse(json, null);
		}

		public static JToken Parse(string json, JsonLoadSettings settings)
		{
			using JsonReader jsonReader = new JsonTextReader(new StringReader(json));
			JToken result = Load(jsonReader, settings);
			if (jsonReader.Read() && jsonReader.TokenType != JsonToken.Comment)
			{
				throw JsonReaderException.Create(jsonReader, "Additional text found in JSON string after parsing content.");
			}
			return result;
		}

		public static JToken Load(JsonReader reader, JsonLoadSettings settings)
		{
			return ReadFrom(reader, settings);
		}

		public static JToken Load(JsonReader reader)
		{
			return Load(reader, null);
		}

		internal void SetLineInfo(IJsonLineInfo lineInfo, JsonLoadSettings settings)
		{
			if ((settings == null || settings.LineInfoHandling != LineInfoHandling.Load) && lineInfo != null && lineInfo.HasLineInfo())
			{
				SetLineInfo(lineInfo.LineNumber, lineInfo.LinePosition);
			}
		}

		internal void SetLineInfo(int lineNumber, int linePosition)
		{
			AddAnnotation(new LineInfoAnnotation(lineNumber, linePosition));
		}

		bool IJsonLineInfo.HasLineInfo()
		{
			return Annotation<LineInfoAnnotation>() != null;
		}

		public JToken SelectToken(string path)
		{
			return SelectToken(path, errorWhenNoMatch: false);
		}

		public JToken SelectToken(string path, bool errorWhenNoMatch)
		{
			JPath jPath = new JPath(path);
			JToken jToken = null;
			foreach (JToken item in jPath.Evaluate(this, errorWhenNoMatch))
			{
				if (jToken != null)
				{
					throw new JsonException("Path returned multiple tokens.");
				}
				jToken = item;
			}
			return jToken;
		}

		public IEnumerable<JToken> SelectTokens(string path)
		{
			return SelectTokens(path, errorWhenNoMatch: false);
		}

		public IEnumerable<JToken> SelectTokens(string path, bool errorWhenNoMatch)
		{
			return new JPath(path).Evaluate(this, errorWhenNoMatch);
		}

		object ICloneable.Clone()
		{
			return DeepClone();
		}

		public JToken DeepClone()
		{
			return CloneToken();
		}

		public void AddAnnotation(object annotation)
		{
			if (annotation == null)
			{
				throw new ArgumentNullException("annotation");
			}
			if (_annotations == null)
			{
				_annotations = ((!(annotation is object[])) ? annotation : new object[1] { annotation });
				return;
			}
			object[] array = _annotations as object[];
			if (array == null)
			{
				_annotations = new object[2] { _annotations, annotation };
				return;
			}
			int i;
			for (i = 0; i < array.Length && array[i] != null; i++)
			{
			}
			if (i == array.Length)
			{
				Array.Resize(ref array, i * 2);
				_annotations = array;
			}
			array[i] = annotation;
		}

		public T Annotation<T>() where T : class
		{
			if (_annotations != null)
			{
				if (!(_annotations is object[] array))
				{
					return _annotations as T;
				}
				foreach (object obj in array)
				{
					if (obj == null)
					{
						break;
					}
					if (obj is T result)
					{
						return result;
					}
				}
			}
			return null;
		}

		public object Annotation(Type type)
		{
			if ((object)type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (_annotations != null)
			{
				if (!(_annotations is object[] array))
				{
					if (type.IsInstanceOfType(_annotations))
					{
						return _annotations;
					}
				}
				else
				{
					foreach (object obj in array)
					{
						if (obj == null)
						{
							break;
						}
						if (type.IsInstanceOfType(obj))
						{
							return obj;
						}
					}
				}
			}
			return null;
		}

		public IEnumerable<T> Annotations<T>() where T : class
		{
			if (_annotations == null)
			{
				yield break;
			}
			if (_annotations is object[] annotations)
			{
				foreach (object obj in annotations)
				{
					if (obj != null)
					{
						if (obj is T val)
						{
							yield return val;
						}
						continue;
					}
					break;
				}
			}
			else if (_annotations is T val2)
			{
				yield return val2;
			}
		}

		public IEnumerable<object> Annotations(Type type)
		{
			if ((object)type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (_annotations == null)
			{
				yield break;
			}
			if (_annotations is object[] annotations)
			{
				foreach (object obj in annotations)
				{
					if (obj != null)
					{
						if (type.IsInstanceOfType(obj))
						{
							yield return obj;
						}
						continue;
					}
					break;
				}
			}
			else if (type.IsInstanceOfType(_annotations))
			{
				yield return _annotations;
			}
		}

		public void RemoveAnnotations<T>() where T : class
		{
			if (_annotations == null)
			{
				return;
			}
			if (!(_annotations is object[] array))
			{
				if (_annotations is T)
				{
					_annotations = null;
				}
				return;
			}
			int i = 0;
			int num = 0;
			for (; i < array.Length; i++)
			{
				object obj = array[i];
				if (obj == null)
				{
					break;
				}
				if (!(obj is T))
				{
					array[num++] = obj;
				}
			}
			if (num != 0)
			{
				while (num < i)
				{
					array[num++] = null;
				}
			}
			else
			{
				_annotations = null;
			}
		}

		public void RemoveAnnotations(Type type)
		{
			if ((object)type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (_annotations == null)
			{
				return;
			}
			if (!(_annotations is object[] array))
			{
				if (type.IsInstanceOfType(_annotations))
				{
					_annotations = null;
				}
				return;
			}
			int i = 0;
			int num = 0;
			for (; i < array.Length; i++)
			{
				object obj = array[i];
				if (obj == null)
				{
					break;
				}
				if (!type.IsInstanceOfType(obj))
				{
					array[num++] = obj;
				}
			}
			if (num != 0)
			{
				while (num < i)
				{
					array[num++] = null;
				}
			}
			else
			{
				_annotations = null;
			}
		}
	}
	[Preserve]
	public class JProperty : JContainer
	{
		private class JPropertyList : IList<JToken>, ICollection<JToken>, IEnumerable<JToken>, IEnumerable
		{
			internal JToken _token;

			public int Count
			{
				get
				{
					if (_token == null)
					{
						return 0;
					}
					return 1;
				}
			}

			public bool IsReadOnly => false;

			public JToken this[int index]
			{
				get
				{
					if (index != 0)
					{
						return null;
					}
					return _token;
				}
				set
				{
					if (index == 0)
					{
						_token = value;
					}
				}
			}

			public IEnumerator<JToken> GetEnumerator()
			{
				if (_token != null)
				{
					yield return _token;
				}
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			public void Add(JToken item)
			{
				_token = item;
			}

			public void Clear()
			{
				_token = null;
			}

			public bool Contains(JToken item)
			{
				return _token == item;
			}

			public void CopyTo(JToken[] array, int arrayIndex)
			{
				if (_token != null)
				{
					array[arrayIndex] = _token;
				}
			}

			public bool Remove(JToken item)
			{
				if (_token == item)
				{
					_token = null;
					return true;
				}
				return false;
			}

			public int IndexOf(JToken item)
			{
				if (_token != item)
				{
					return -1;
				}
				return 0;
			}

			public void Insert(int index, JToken item)
			{
				if (index == 0)
				{
					_token = item;
				}
			}

			public void RemoveAt(int index)
			{
				if (index == 0)
				{
					_token = null;
				}
			}
		}

		private readonly JPropertyList _content = new JPropertyList();

		private readonly string _name;

		protected override IList<JToken> ChildrenTokens => _content;

		public string Name
		{
			[DebuggerStepThrough]
			get
			{
				return _name;
			}
		}

		public new JToken Value
		{
			[DebuggerStepThrough]
			get
			{
				return _content._token;
			}
			set
			{
				CheckReentrancy();
				JToken item = value ?? JValue.CreateNull();
				if (_content._token == null)
				{
					InsertItem(0, item, skipParentCheck: false);
				}
				else
				{
					SetItem(0, item);
				}
			}
		}

		public override JTokenType Type
		{
			[DebuggerStepThrough]
			get
			{
				return JTokenType.Property;
			}
		}

		public JProperty(JProperty other)
			: base(other)
		{
			_name = other.Name;
		}

		internal override JToken GetItem(int index)
		{
			if (index != 0)
			{
				throw new ArgumentOutOfRangeException();
			}
			return Value;
		}

		internal override void SetItem(int index, JToken item)
		{
			if (index != 0)
			{
				throw new ArgumentOutOfRangeException();
			}
			if (!JContainer.IsTokenUnchanged(Value, item))
			{
				if (base.Parent != null)
				{
					((JObject)base.Parent).InternalPropertyChanging(this);
				}
				base.SetItem(0, item);
				if (base.Parent != null)
				{
					((JObject)base.Parent).InternalPropertyChanged(this);
				}
			}
		}

		internal override bool RemoveItem(JToken item)
		{
			throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
		}

		internal override void RemoveItemAt(int index)
		{
			throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
		}

		internal override int IndexOfItem(JToken item)
		{
			return _content.IndexOf(item);
		}

		internal override void InsertItem(int index, JToken item, bool skipParentCheck)
		{
			if (item == null || item.Type != JTokenType.Comment)
			{
				if (Value != null)
				{
					throw new JsonException("{0} cannot have multiple values.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
				}
				base.InsertItem(0, item, skipParentCheck: false);
			}
		}

		internal override bool ContainsItem(JToken item)
		{
			return Value == item;
		}

		internal override void MergeItem(object content, JsonMergeSettings settings)
		{
			if (content is JProperty { Value: not null } jProperty && jProperty.Value.Type != JTokenType.Null)
			{
				Value = jProperty.Value;
			}
		}

		internal override void ClearItems()
		{
			throw new JsonException("Cannot add or remove items from {0}.".FormatWith(CultureInfo.InvariantCulture, typeof(JProperty)));
		}

		internal override bool DeepEquals(JToken node)
		{
			if (node is JProperty jProperty && _name == jProperty.Name)
			{
				return ContentsEqual(jProperty);
			}
			return false;
		}

		internal override JToken CloneToken()
		{
			return new JProperty(this);
		}

		internal JProperty(string name)
		{
			ValidationUtils.ArgumentNotNull(name, "name");
			_name = name;
		}

		public JProperty(string name, params object[] content)
			: this(name, (object)content)
		{
		}

		public JProperty(string name, object content)
		{
			ValidationUtils.ArgumentNotNull(name, "name");
			_name = name;
			Value = (IsMultiContent(content) ? new JArray(content) : JContainer.CreateFromContent(content));
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			writer.WritePropertyName(_name);
			JToken value = Value;
			if (value != null)
			{
				value.WriteTo(writer, converters);
			}
			else
			{
				writer.WriteNull();
			}
		}

		internal override int GetDeepHashCode()
		{
			return _name.GetHashCode() ^ ((Value != null) ? Value.GetDeepHashCode() : 0);
		}

		public new static JProperty Load(JsonReader reader)
		{
			return Load(reader, null);
		}

		public new static JProperty Load(JsonReader reader, JsonLoadSettings settings)
		{
			if (reader.TokenType == JsonToken.None && !reader.Read())
			{
				throw JsonReaderException.Create(reader, "Error reading JProperty from JsonReader.");
			}
			reader.MoveToContent();
			if (reader.TokenType != JsonToken.PropertyName)
			{
				throw JsonReaderException.Create(reader, "Error reading JProperty from JsonReader. Current JsonReader item is not a property: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			JProperty jProperty = new JProperty((string)reader.Value);
			jProperty.SetLineInfo(reader as IJsonLineInfo, settings);
			jProperty.ReadTokenFrom(reader, settings);
			return jProperty;
		}
	}
	[Preserve]
	public enum JTokenType
	{
		None,
		Object,
		Array,
		Constructor,
		Property,
		Comment,
		Integer,
		Float,
		String,
		Boolean,
		Null,
		Undefined,
		Date,
		Raw,
		Bytes,
		Guid,
		Uri,
		TimeSpan
	}
	[Preserve]
	public class JValue : JToken, IFormattable, IComparable, IConvertible
	{
		private JTokenType _valueType;

		private object _value;

		public override bool HasValues => false;

		public override JTokenType Type => _valueType;

		public new object Value
		{
			get
			{
				return _value;
			}
			set
			{
				Type obj = ((_value != null) ? _value.GetType() : null);
				Type type = value?.GetType();
				if ((object)obj != type)
				{
					_valueType = GetValueType(_valueType, value);
				}
				_value = value;
			}
		}

		internal JValue(object value, JTokenType type)
		{
			_value = value;
			_valueType = type;
		}

		public JValue(JValue other)
			: this(other.Value, other.Type)
		{
		}

		public JValue(long value)
			: this(value, JTokenType.Integer)
		{
		}

		public JValue(decimal value)
			: this(value, JTokenType.Float)
		{
		}

		public JValue(char value)
			: this(value, JTokenType.String)
		{
		}

		[CLSCompliant(false)]
		public JValue(ulong value)
			: this(value, JTokenType.Integer)
		{
		}

		public JValue(double value)
			: this(value, JTokenType.Float)
		{
		}

		public JValue(float value)
			: this(value, JTokenType.Float)
		{
		}

		public JValue(DateTime value)
			: this(value, JTokenType.Date)
		{
		}

		public JValue(DateTimeOffset value)
			: this(value, JTokenType.Date)
		{
		}

		public JValue(bool value)
			: this(value, JTokenType.Boolean)
		{
		}

		public JValue(string value)
			: this(value, JTokenType.String)
		{
		}

		public JValue(Guid value)
			: this(value, JTokenType.Guid)
		{
		}

		public JValue(Uri value)
			: this(value, (value != null) ? JTokenType.Uri : JTokenType.Null)
		{
		}

		public JValue(TimeSpan value)
			: this(value, JTokenType.TimeSpan)
		{
		}

		public JValue(object value)
			: this(value, GetValueType(null, value))
		{
		}

		internal override bool DeepEquals(JToken node)
		{
			if (!(node is JValue jValue))
			{
				return false;
			}
			if (jValue == this)
			{
				return true;
			}
			return ValuesEquals(this, jValue);
		}

		internal static int Compare(JTokenType valueType, object objA, object objB)
		{
			if (objA == null && objB == null)
			{
				return 0;
			}
			if (objA != null && objB == null)
			{
				return 1;
			}
			if (objA == null && objB != null)
			{
				return -1;
			}
			switch (valueType)
			{
			case JTokenType.Integer:
				if (objA is ulong || objB is ulong || objA is decimal || objB is decimal)
				{
					return Convert.ToDecimal(objA, CultureInfo.InvariantCulture).CompareTo(Convert.ToDecimal(objB, CultureInfo.InvariantCulture));
				}
				if (objA is float || objB is float || objA is double || objB is double)
				{
					return CompareFloat(objA, objB);
				}
				return Convert.ToInt64(objA, CultureInfo.InvariantCulture).CompareTo(Convert.ToInt64(objB, CultureInfo.InvariantCulture));
			case JTokenType.Float:
				return CompareFloat(objA, objB);
			case JTokenType.Comment:
			case JTokenType.String:
			case JTokenType.Raw:
			{
				string strA = Convert.ToString(objA, CultureInfo.InvariantCulture);
				string strB = Convert.ToString(objB, CultureInfo.InvariantCulture);
				return string.CompareOrdinal(strA, strB);
			}
			case JTokenType.Boolean:
			{
				bool flag = Convert.ToBoolean(objA, CultureInfo.InvariantCulture);
				bool value3 = Convert.ToBoolean(objB, CultureInfo.InvariantCulture);
				return flag.CompareTo(value3);
			}
			case JTokenType.Date:
			{
				if (objA is DateTime dateTime)
				{
					DateTime value2 = ((!(objB is DateTimeOffset dateTimeOffset)) ? Convert.ToDateTime(objB, CultureInfo.InvariantCulture) : dateTimeOffset.DateTime);
					return dateTime.CompareTo(value2);
				}
				DateTimeOffset dateTimeOffset2 = (DateTimeOffset)objA;
				DateTimeOffset other = ((!(objB is DateTimeOffset)) ? new DateTimeOffset(Convert.ToDateTime(objB, CultureInfo.InvariantCulture)) : ((DateTimeOffset)objB));
				return dateTimeOffset2.CompareTo(other);
			}
			case JTokenType.Bytes:
			{
				if (!(objB is byte[]))
				{
					throw new ArgumentException("Object must be of type byte[].");
				}
				byte[] array = objA as byte[];
				byte[] array2 = objB as byte[];
				if (array == null)
				{
					return -1;
				}
				if (array2 == null)
				{
					return 1;
				}
				return MiscellaneousUtils.ByteArrayCompare(array, array2);
			}
			case JTokenType.Guid:
			{
				if (!(objB is Guid))
				{
					throw new ArgumentException("Object must be of type Guid.");
				}
				Guid guid = (Guid)objA;
				Guid value4 = (Guid)objB;
				return guid.CompareTo(value4);
			}
			case JTokenType.Uri:
			{
				if (!(objB is Uri))
				{
					throw new ArgumentException("Object must be of type Uri.");
				}
				Uri uri = (Uri)objA;
				Uri uri2 = (Uri)objB;
				return Comparer<string>.Default.Compare(uri.ToString(), uri2.ToString());
			}
			case JTokenType.TimeSpan:
			{
				if (!(objB is TimeSpan))
				{
					throw new ArgumentException("Object must be of type TimeSpan.");
				}
				TimeSpan timeSpan = (TimeSpan)objA;
				TimeSpan value = (TimeSpan)objB;
				return timeSpan.CompareTo(value);
			}
			default:
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException("valueType", valueType, "Unexpected value type: {0}".FormatWith(CultureInfo.InvariantCulture, valueType));
			}
		}

		private static int CompareFloat(object objA, object objB)
		{
			double d = Convert.ToDouble(objA, CultureInfo.InvariantCulture);
			double num = Convert.ToDouble(objB, CultureInfo.InvariantCulture);
			if (MathUtils.ApproxEquals(d, num))
			{
				return 0;
			}
			return d.CompareTo(num);
		}

		internal override JToken CloneToken()
		{
			return new JValue(this);
		}

		public static JValue CreateComment(string value)
		{
			return new JValue(value, JTokenType.Comment);
		}

		public static JValue CreateString(string value)
		{
			return new JValue(value, JTokenType.String);
		}

		public static JValue CreateNull()
		{
			return new JValue(null, JTokenType.Null);
		}

		public static JValue CreateUndefined()
		{
			return new JValue(null, JTokenType.Undefined);
		}

		private static JTokenType GetValueType(JTokenType? current, object value)
		{
			if (value == null)
			{
				return JTokenType.Null;
			}
			if (value == DBNull.Value)
			{
				return JTokenType.Null;
			}
			if (value is string)
			{
				return GetStringValueType(current);
			}
			if (value is long || value is int || value is short || value is sbyte || value is ulong || value is uint || value is ushort || value is byte)
			{
				return JTokenType.Integer;
			}
			if (value is Enum)
			{
				return JTokenType.Integer;
			}
			if (value is double || value is float || value is decimal)
			{
				return JTokenType.Float;
			}
			if (value is DateTime)
			{
				return JTokenType.Date;
			}
			if (value is DateTimeOffset)
			{
				return JTokenType.Date;
			}
			if (value is byte[])
			{
				return JTokenType.Bytes;
			}
			if (value is bool)
			{
				return JTokenType.Boolean;
			}
			if (value is Guid)
			{
				return JTokenType.Guid;
			}
			if (value is Uri)
			{
				return JTokenType.Uri;
			}
			if (value is TimeSpan)
			{
				return JTokenType.TimeSpan;
			}
			throw new ArgumentException("Could not determine JSON object type for type {0}.".FormatWith(CultureInfo.InvariantCulture, value.GetType()));
		}

		private static JTokenType GetStringValueType(JTokenType? current)
		{
			if (!current.HasValue)
			{
				return JTokenType.String;
			}
			JTokenType valueOrDefault = current.GetValueOrDefault();
			if (valueOrDefault == JTokenType.Comment || valueOrDefault == JTokenType.String || valueOrDefault == JTokenType.Raw)
			{
				return current.GetValueOrDefault();
			}
			return JTokenType.String;
		}

		public override void WriteTo(JsonWriter writer, params JsonConverter[] converters)
		{
			if (converters != null && converters.Length != 0 && _value != null)
			{
				JsonConverter matchingConverter = JsonSerializer.GetMatchingConverter(converters, _value.GetType());
				if (matchingConverter != null && matchingConverter.CanWrite)
				{
					matchingConverter.WriteJson(writer, _value, JsonSerializer.CreateDefault());
					return;
				}
			}
			switch (_valueType)
			{
			case JTokenType.Comment:
				writer.WriteComment((_value != null) ? _value.ToString() : null);
				break;
			case JTokenType.Raw:
				writer.WriteRawValue((_value != null) ? _value.ToString() : null);
				break;
			case JTokenType.Null:
				writer.WriteNull();
				break;
			case JTokenType.Undefined:
				writer.WriteUndefined();
				break;
			case JTokenType.Integer:
				if (_value is int)
				{
					writer.WriteValue((int)_value);
				}
				else if (_value is long)
				{
					writer.WriteValue((long)_value);
				}
				else if (_value is ulong)
				{
					writer.WriteValue((ulong)_value);
				}
				else
				{
					writer.WriteValue(Convert.ToInt64(_value, CultureInfo.InvariantCulture));
				}
				break;
			case JTokenType.Float:
				if (_value is decimal)
				{
					writer.WriteValue((decimal)_value);
				}
				else if (_value is double)
				{
					writer.WriteValue((double)_value);
				}
				else if (_value is float)
				{
					writer.WriteValue((float)_value);
				}
				else
				{
					writer.WriteValue(Convert.ToDouble(_value, CultureInfo.InvariantCulture));
				}
				break;
			case JTokenType.String:
				writer.WriteValue((_value != null) ? _value.ToString() : null);
				break;
			case JTokenType.Boolean:
				writer.WriteValue(Convert.ToBoolean(_value, CultureInfo.InvariantCulture));
				break;
			case JTokenType.Date:
				if (_value is DateTimeOffset)
				{
					writer.WriteValue((DateTimeOffset)_value);
				}
				else
				{
					writer.WriteValue(Convert.ToDateTime(_value, CultureInfo.InvariantCulture));
				}
				break;
			case JTokenType.Bytes:
				writer.WriteValue((byte[])_value);
				break;
			case JTokenType.Guid:
				writer.WriteValue((_value != null) ? ((Guid?)_value) : ((Guid?)null));
				break;
			case JTokenType.TimeSpan:
				writer.WriteValue((_value != null) ? ((TimeSpan?)_value) : ((TimeSpan?)null));
				break;
			case JTokenType.Uri:
				writer.WriteValue((Uri)_value);
				break;
			default:
				throw MiscellaneousUtils.CreateArgumentOutOfRangeException("TokenType", _valueType, "Unexpected token type.");
			}
		}

		internal override int GetDeepHashCode()
		{
			int num = ((_value != null) ? _value.GetHashCode() : 0);
			int valueType = (int)_valueType;
			return valueType.GetHashCode() ^ num;
		}

		private static bool ValuesEquals(JValue v1, JValue v2)
		{
			if (v1 != v2)
			{
				if (v1._valueType == v2._valueType)
				{
					return Compare(v1._valueType, v1._value, v2._value) == 0;
				}
				return false;
			}
			return true;
		}

		public bool Equals(JValue other)
		{
			if (other == null)
			{
				return false;
			}
			return ValuesEquals(this, other);
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj is JValue other)
			{
				return Equals(other);
			}
			return base.Equals(obj);
		}

		public override int GetHashCode()
		{
			if (_value == null)
			{
				return 0;
			}
			return _value.GetHashCode();
		}

		public override string ToString()
		{
			if (_value == null)
			{
				return string.Empty;
			}
			return _value.ToString();
		}

		public string ToString(string format)
		{
			return ToString(format, CultureInfo.CurrentCulture);
		}

		public string ToString(IFormatProvider formatProvider)
		{
			return ToString(null, formatProvider);
		}

		public string ToString(string format, IFormatProvider formatProvider)
		{
			if (_value == null)
			{
				return string.Empty;
			}
			if (_value is IFormattable formattable)
			{
				return formattable.ToString(format, formatProvider);
			}
			return _value.ToString();
		}

		int IComparable.CompareTo(object obj)
		{
			if (obj == null)
			{
				return 1;
			}
			object objB = ((obj is JValue) ? ((JValue)obj).Value : obj);
			return Compare(_valueType, _value, objB);
		}

		public int CompareTo(JValue obj)
		{
			if (obj == null)
			{
				return 1;
			}
			return Compare(_valueType, _value, obj._value);
		}

		TypeCode IConvertible.GetTypeCode()
		{
			if (_value == null)
			{
				return TypeCode.Empty;
			}
			if (!(_value is IConvertible convertible))
			{
				return TypeCode.Object;
			}
			return convertible.GetTypeCode();
		}

		bool IConvertible.ToBoolean(IFormatProvider provider)
		{
			return (bool)(JToken)this;
		}

		char IConvertible.ToChar(IFormatProvider provider)
		{
			return (char)(JToken)this;
		}

		sbyte IConvertible.ToSByte(IFormatProvider provider)
		{
			return (sbyte)(JToken)this;
		}

		byte IConvertible.ToByte(IFormatProvider provider)
		{
			return (byte)(JToken)this;
		}

		short IConvertible.ToInt16(IFormatProvider provider)
		{
			return (short)(JToken)this;
		}

		ushort IConvertible.ToUInt16(IFormatProvider provider)
		{
			return (ushort)(JToken)this;
		}

		int IConvertible.ToInt32(IFormatProvider provider)
		{
			return (int)(JToken)this;
		}

		uint IConvertible.ToUInt32(IFormatProvider provider)
		{
			return (uint)(JToken)this;
		}

		long IConvertible.ToInt64(IFormatProvider provider)
		{
			return (long)(JToken)this;
		}

		ulong IConvertible.ToUInt64(IFormatProvider provider)
		{
			return (ulong)(JToken)this;
		}

		float IConvertible.ToSingle(IFormatProvider provider)
		{
			return (float)(JToken)this;
		}

		double IConvertible.ToDouble(IFormatProvider provider)
		{
			return (double)(JToken)this;
		}

		decimal IConvertible.ToDecimal(IFormatProvider provider)
		{
			return (decimal)(JToken)this;
		}

		DateTime IConvertible.ToDateTime(IFormatProvider provider)
		{
			return (DateTime)(JToken)this;
		}

		object IConvertible.ToType(Type conversionType, IFormatProvider provider)
		{
			return ToObject(conversionType);
		}
	}
}
namespace Newtonsoft.Json.Linq.JsonPath
{
	[Preserve]
	internal class ArrayIndexFilter : PathFilter
	{
		public int? Index { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
		{
			foreach (JToken t in current)
			{
				if (Index.HasValue)
				{
					JToken tokenIndex = PathFilter.GetTokenIndex(t, errorWhenNoMatch, Index.GetValueOrDefault());
					if (tokenIndex != null)
					{
						yield return tokenIndex;
					}
				}
				else if (t is JArray || t is JConstructor)
				{
					foreach (JToken item in (IEnumerable<JToken>)t)
					{
						yield return item;
					}
				}
				else if (errorWhenNoMatch)
				{
					throw new JsonException("Index * not valid on {0}.".FormatWith(CultureInfo.InvariantCulture, t.GetType().Name));
				}
			}
		}
	}
	[Preserve]
	internal class ArrayMultipleIndexFilter : PathFilter
	{
		public List<int> Indexes { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
		{
			foreach (JToken t in current)
			{
				foreach (int index in Indexes)
				{
					JToken tokenIndex = PathFilter.GetTokenIndex(t, errorWhenNoMatch, index);
					if (tokenIndex != null)
					{
						yield return tokenIndex;
					}
				}
			}
		}
	}
	[Preserve]
	internal class ArraySliceFilter : PathFilter
	{
		public int? Start { get; set; }

		public int? End { get; set; }

		public int? Step { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
		{
			if (Step == 0)
			{
				throw new JsonException("Step cannot be zero.");
			}
			foreach (JToken t in current)
			{
				if (t is JArray a)
				{
					int stepCount = Step ?? 1;
					int num = Start ?? ((stepCount <= 0) ? (a.Count - 1) : 0);
					int stopIndex = End ?? ((stepCount > 0) ? a.Count : (-1));
					if (Start < 0)
					{
						num = a.Count + num;
					}
					if (End < 0)
					{
						stopIndex = a.Count + stopIndex;
					}
					num = Math.Max(num, (stepCount <= 0) ? int.MinValue : 0);
					num = Math.Min(num, (stepCount > 0) ? a.Count : (a.Count - 1));
					stopIndex = Math.Max(stopIndex, -1);
					stopIndex = Math.Min(stopIndex, a.Count);
					bool positiveStep = stepCount > 0;
					if (IsValid(num, stopIndex, positiveStep))
					{
						for (int i = num; IsValid(i, stopIndex, positiveStep); i += stepCount)
						{
							yield return a[i];
						}
					}
					else if (errorWhenNoMatch)
					{
						throw new JsonException("Array slice of {0} to {1} returned no results.".FormatWith(CultureInfo.InvariantCulture, Start.HasValue ? Start.GetValueOrDefault().ToString(CultureInfo.InvariantCulture) : "*", End.HasValue ? End.GetValueOrDefault().ToString(CultureInfo.InvariantCulture) : "*"));
					}
				}
				else if (errorWhenNoMatch)
				{
					throw new JsonException("Array slice is not valid on {0}.".FormatWith(CultureInfo.InvariantCulture, t.GetType().Name));
				}
			}
		}

		private bool IsValid(int index, int stopIndex, bool positiveStep)
		{
			if (positiveStep)
			{
				return index < stopIndex;
			}
			return index > stopIndex;
		}
	}
	[Preserve]
	internal class FieldFilter : PathFilter
	{
		public string Name { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
		{
			foreach (JToken t in current)
			{
				if (t is JObject o)
				{
					if (Name != null)
					{
						JToken jToken = o[Name];
						if (jToken != null)
						{
							yield return jToken;
						}
						else if (errorWhenNoMatch)
						{
							throw new JsonException("Property '{0}' does not exist on JObject.".FormatWith(CultureInfo.InvariantCulture, Name));
						}
						continue;
					}
					foreach (KeyValuePair<string, JToken> item in o)
					{
						yield return item.Value;
					}
				}
				else if (errorWhenNoMatch)
				{
					throw new JsonException("Property '{0}' not valid on {1}.".FormatWith(CultureInfo.InvariantCulture, Name ?? "*", t.GetType().Name));
				}
			}
		}
	}
	[Preserve]
	internal class FieldMultipleFilter : PathFilter
	{
		public List<string> Names { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
		{
			foreach (JToken t in current)
			{
				if (t is JObject o)
				{
					foreach (string name in Names)
					{
						JToken jToken = o[name];
						if (jToken != null)
						{
							yield return jToken;
						}
						if (errorWhenNoMatch)
						{
							throw new JsonException("Property '{0}' does not exist on JObject.".FormatWith(CultureInfo.InvariantCulture, name));
						}
					}
				}
				else if (errorWhenNoMatch)
				{
					throw new JsonException("Properties {0} not valid on {1}.".FormatWith(CultureInfo.InvariantCulture, string.Join(", ", Names.Select((string n) => "'" + n + "'").ToArray()), t.GetType().Name));
				}
			}
		}
	}
	[Preserve]
	internal class JPath
	{
		private readonly string _expression;

		private int _currentIndex;

		public List<PathFilter> Filters { get; private set; }

		public JPath(string expression)
		{
			ValidationUtils.ArgumentNotNull(expression, "expression");
			_expression = expression;
			Filters = new List<PathFilter>();
			ParseMain();
		}

		private void ParseMain()
		{
			int currentIndex = _currentIndex;
			EatWhitespace();
			if (_expression.Length == _currentIndex)
			{
				return;
			}
			if (_expression[_currentIndex] == '$')
			{
				if (_expression.Length == 1)
				{
					return;
				}
				char c = _expression[_currentIndex + 1];
				if (c == '.' || c == '[')
				{
					_currentIndex++;
					currentIndex = _currentIndex;
				}
			}
			if (!ParsePath(Filters, currentIndex, query: false))
			{
				int currentIndex2 = _currentIndex;
				EatWhitespace();
				if (_currentIndex < _expression.Length)
				{
					throw new JsonException("Unexpected character while parsing path: " + _expression[currentIndex2]);
				}
			}
		}

		private bool ParsePath(List<PathFilter> filters, int currentPartStartIndex, bool query)
		{
			bool flag = false;
			bool flag2 = false;
			bool flag3 = false;
			bool flag4 = false;
			while (_currentIndex < _expression.Length && !flag4)
			{
				char c = _expression[_currentIndex];
				switch (c)
				{
				case '(':
				case '[':
					if (_currentIndex > currentPartStartIndex)
					{
						string text2 = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex);
						if (text2 == "*")
						{
							text2 = null;
						}
						PathFilter item2 = (flag ? ((PathFilter)new ScanFilter
						{
							Name = text2
						}) : ((PathFilter)new FieldFilter
						{
							Name = text2
						}));
						filters.Add(item2);
						flag = false;
					}
					filters.Add(ParseIndexer(c));
					_currentIndex++;
					currentPartStartIndex = _currentIndex;
					flag2 = true;
					flag3 = false;
					break;
				case ')':
				case ']':
					flag4 = true;
					break;
				case ' ':
					if (_currentIndex < _expression.Length)
					{
						flag4 = true;
					}
					break;
				case '.':
					if (_currentIndex > currentPartStartIndex)
					{
						string text = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex);
						if (text == "*")
						{
							text = null;
						}
						PathFilter item = (flag ? ((PathFilter)new ScanFilter
						{
							Name = text
						}) : ((PathFilter)new FieldFilter
						{
							Name = text
						}));
						filters.Add(item);
						flag = false;
					}
					if (_currentIndex + 1 < _expression.Length && _expression[_currentIndex + 1] == '.')
					{
						flag = true;
						_currentIndex++;
					}
					_currentIndex++;
					currentPartStartIndex = _currentIndex;
					flag2 = false;
					flag3 = true;
					break;
				default:
					if (query && (c == '=' || c == '<' || c == '!' || c == '>' || c == '|' || c == '&'))
					{
						flag4 = true;
						break;
					}
					if (flag2)
					{
						throw new JsonException("Unexpected character following indexer: " + c);
					}
					_currentIndex++;
					break;
				}
			}
			bool flag5 = _currentIndex == _expression.Length;
			if (_currentIndex > currentPartStartIndex)
			{
				string text3 = _expression.Substring(currentPartStartIndex, _currentIndex - currentPartStartIndex).TrimEnd(new char[0]);
				if (text3 == "*")
				{
					text3 = null;
				}
				PathFilter item3 = (flag ? ((PathFilter)new ScanFilter
				{
					Name = text3
				}) : ((PathFilter)new FieldFilter
				{
					Name = text3
				}));
				filters.Add(item3);
			}
			else if (flag3 && (flag5 || query))
			{
				throw new JsonException("Unexpected end while parsing path.");
			}
			return flag5;
		}

		private PathFilter ParseIndexer(char indexerOpenChar)
		{
			_currentIndex++;
			char indexerCloseChar = ((indexerOpenChar == '[') ? ']' : ')');
			EnsureLength("Path ended with open indexer.");
			EatWhitespace();
			if (_expression[_currentIndex] == '\'')
			{
				return ParseQuotedField(indexerCloseChar);
			}
			if (_expression[_currentIndex] == '?')
			{
				return ParseQuery(indexerCloseChar);
			}
			return ParseArrayIndexer(indexerCloseChar);
		}

		private PathFilter ParseArrayIndexer(char indexerCloseChar)
		{
			int currentIndex = _currentIndex;
			int? num = null;
			List<int> list = null;
			int num2 = 0;
			int? start = null;
			int? end = null;
			int? step = null;
			while (_currentIndex < _expression.Length)
			{
				char c = _expression[_currentIndex];
				if (c == ' ')
				{
					num = _currentIndex;
					EatWhitespace();
					continue;
				}
				if (c == indexerCloseChar)
				{
					int num3 = (num ?? _currentIndex) - currentIndex;
					if (list != null)
					{
						if (num3 == 0)
						{
							throw new JsonException("Array index expected.");
						}
						int item = Convert.ToInt32(_expression.Substring(currentIndex, num3), CultureInfo.InvariantCulture);
						list.Add(item);
						return new ArrayMultipleIndexFilter
						{
							Indexes = list
						};
					}
					if (num2 > 0)
					{
						if (num3 > 0)
						{
							int value = Convert.ToInt32(_expression.Substring(currentIndex, num3), CultureInfo.InvariantCulture);
							if (num2 == 1)
							{
								end = value;
							}
							else
							{
								step = value;
							}
						}
						return new ArraySliceFilter
						{
							Start = start,
							End = end,
							Step = step
						};
					}
					if (num3 == 0)
					{
						throw new JsonException("Array index expected.");
					}
					int value2 = Convert.ToInt32(_expression.Substring(currentIndex, num3), CultureInfo.InvariantCulture);
					return new ArrayIndexFilter
					{
						Index = value2
					};
				}
				switch (c)
				{
				case ',':
				{
					int num5 = (num ?? _currentIndex) - currentIndex;
					if (num5 == 0)
					{
						throw new JsonException("Array index expected.");
					}
					if (list == null)
					{
						list = new List<int>();
					}
					string value4 = _expression.Substring(currentIndex, num5);
					list.Add(Convert.ToInt32(value4, CultureInfo.InvariantCulture));
					_currentIndex++;
					EatWhitespace();
					currentIndex = _currentIndex;
					num = null;
					break;
				}
				case '*':
					_currentIndex++;
					EnsureLength("Path ended with open indexer.");
					EatWhitespace();
					if (_expression[_currentIndex] != indexerCloseChar)
					{
						throw new JsonException("Unexpected character while parsing path indexer: " + c);
					}
					return new ArrayIndexFilter();
				case ':':
				{
					int num4 = (num ?? _currentIndex) - currentIndex;
					if (num4 > 0)
					{
						int value3 = Convert.ToInt32(_expression.Substring(currentIndex, num4), CultureInfo.InvariantCulture);
						switch (num2)
						{
						case 0:
							start = value3;
							break;
						case 1:
							end = value3;
							break;
						default:
							step = value3;
							break;
						}
					}
					num2++;
					_currentIndex++;
					EatWhitespace();
					currentIndex = _currentIndex;
					num = null;
					break;
				}
				default:
					if (!char.IsDigit(c) && c != '-')
					{
						throw new JsonException("Unexpected character while parsing path indexer: " + c);
					}
					if (num.HasValue)
					{
						throw new JsonException("Unexpected character while parsing path indexer: " + c);
					}
					_currentIndex++;
					break;
				}
			}
			throw new JsonException("Path ended with open indexer.");
		}

		private void EatWhitespace()
		{
			while (_currentIndex < _expression.Length && _expression[_currentIndex] == ' ')
			{
				_currentIndex++;
			}
		}

		private PathFilter ParseQuery(char indexerCloseChar)
		{
			_currentIndex++;
			EnsureLength("Path ended with open indexer.");
			if (_expression[_currentIndex] != '(')
			{
				throw new JsonException("Unexpected character while parsing path indexer: " + _expression[_currentIndex]);
			}
			_currentIndex++;
			QueryExpression expression = ParseExpression();
			_currentIndex++;
			EnsureLength("Path ended with open indexer.");
			EatWhitespace();
			if (_expression[_currentIndex] != indexerCloseChar)
			{
				throw new JsonException("Unexpected character while parsing path indexer: " + _expression[_currentIndex]);
			}
			return new QueryFilter
			{
				Expression = expression
			};
		}

		private QueryExpression ParseExpression()
		{
			QueryExpression queryExpression = null;
			CompositeExpression compositeExpression = null;
			while (_currentIndex < _expression.Length)
			{
				EatWhitespace();
				if (_expression[_currentIndex] != '@')
				{
					throw new JsonException("Unexpected character while parsing path query: " + _expression[_currentIndex]);
				}
				_currentIndex++;
				List<PathFilter> list = new List<PathFilter>();
				if (ParsePath(list, _currentIndex, query: true))
				{
					throw new JsonException("Path ended with open query.");
				}
				EatWhitespace();
				EnsureLength("Path ended with open query.");
				object value = null;
				QueryOperator queryOperator;
				if (_expression[_currentIndex] == ')' || _expression[_currentIndex] == '|' || _expression[_currentIndex] == '&')
				{
					queryOperator = QueryOperator.Exists;
				}
				else
				{
					queryOperator = ParseOperator();
					EatWhitespace();
					EnsureLength("Path ended with open query.");
					value = ParseValue();
					EatWhitespace();
					EnsureLength("Path ended with open query.");
				}
				BooleanQueryExpression booleanQueryExpression = new BooleanQueryExpression
				{
					Path = list,
					Operator = queryOperator,
					Value = ((queryOperator != QueryOperator.Exists) ? new JValue(value) : null)
				};
				if (_expression[_currentIndex] == ')')
				{
					if (compositeExpression != null)
					{
						compositeExpression.Expressions.Add(booleanQueryExpression);
						return queryExpression;
					}
					return booleanQueryExpression;
				}
				if (_expression[_currentIndex] == '&' && Match("&&"))
				{
					if (compositeExpression == null || compositeExpression.Operator != QueryOperator.And)
					{
						CompositeExpression compositeExpression2 = new CompositeExpression
						{
							Operator = QueryOperator.And
						};
						compositeExpression?.Expressions.Add(compositeExpression2);
						compositeExpression = compositeExpression2;
						if (queryExpression == null)
						{
							queryExpression = compositeExpression;
						}
					}
					compositeExpression.Expressions.Add(booleanQueryExpression);
				}
				if (_expression[_currentIndex] != '|' || !Match("||"))
				{
					continue;
				}
				if (compositeExpression == null || compositeExpression.Operator != QueryOperator.Or)
				{
					CompositeExpression compositeExpression3 = new CompositeExpression
					{
						Operator = QueryOperator.Or
					};
					compositeExpression?.Expressions.Add(compositeExpression3);
					compositeExpression = compositeExpression3;
					if (queryExpression == null)
					{
						queryExpression = compositeExpression;
					}
				}
				compositeExpression.Expressions.Add(booleanQueryExpression);
			}
			throw new JsonException("Path ended with open query.");
		}

		private object ParseValue()
		{
			char c = _expression[_currentIndex];
			if (c == '\'')
			{
				return ReadQuotedString();
			}
			if (char.IsDigit(c) || c == '-')
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(c);
				_currentIndex++;
				while (_currentIndex < _expression.Length)
				{
					c = _expression[_currentIndex];
					if (c == ' ' || c == ')')
					{
						string text = stringBuilder.ToString();
						if (text.IndexOfAny(new char[3] { '.', 'E', 'e' }) != -1)
						{
							if (double.TryParse(text, NumberStyles.Float | NumberStyles.AllowThousands, CultureInfo.InvariantCulture, out var result))
							{
								return result;
							}
							throw new JsonException("Could not read query value.");
						}
						if (long.TryParse(text, NumberStyles.Integer, CultureInfo.InvariantCulture, out var result2))
						{
							return result2;
						}
						throw new JsonException("Could not read query value.");
					}
					stringBuilder.Append(c);
					_currentIndex++;
				}
			}
			else
			{
				switch (c)
				{
				case 't':
					if (Match("true"))
					{
						return true;
					}
					break;
				case 'f':
					if (Match("false"))
					{
						return false;
					}
					break;
				case 'n':
					if (Match("null"))
					{
						return null;
					}
					break;
				}
			}
			throw new JsonException("Could not read query value.");
		}

		private string ReadQuotedString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			_currentIndex++;
			while (_currentIndex < _expression.Length)
			{
				char c = _expression[_currentIndex];
				if (c == '\\' && _currentIndex + 1 < _expression.Length)
				{
					_currentIndex++;
					if (_expression[_currentIndex] == '\'')
					{
						stringBuilder.Append('\'');
					}
					else
					{
						if (_expression[_currentIndex] != '\\')
						{
							throw new JsonException("Unknown escape chracter: \\" + _expression[_currentIndex]);
						}
						stringBuilder.Append('\\');
					}
					_currentIndex++;
				}
				else
				{
					if (c == '\'')
					{
						_currentIndex++;
						return stringBuilder.ToString();
					}
					_currentIndex++;
					stringBuilder.Append(c);
				}
			}
			throw new JsonException("Path ended with an open string.");
		}

		private bool Match(string s)
		{
			int num = _currentIndex;
			foreach (char c in s)
			{
				if (num < _expression.Length && _expression[num] == c)
				{
					num++;
					continue;
				}
				return false;
			}
			_currentIndex = num;
			return true;
		}

		private QueryOperator ParseOperator()
		{
			if (_currentIndex + 1 >= _expression.Length)
			{
				throw new JsonException("Path ended with open query.");
			}
			if (Match("=="))
			{
				return QueryOperator.Equals;
			}
			if (Match("!=") || Match("<>"))
			{
				return QueryOperator.NotEquals;
			}
			if (Match("<="))
			{
				return QueryOperator.LessThanOrEquals;
			}
			if (Match("<"))
			{
				return QueryOperator.LessThan;
			}
			if (Match(">="))
			{
				return QueryOperator.GreaterThanOrEquals;
			}
			if (Match(">"))
			{
				return QueryOperator.GreaterThan;
			}
			throw new JsonException("Could not read query operator.");
		}

		private PathFilter ParseQuotedField(char indexerCloseChar)
		{
			List<string> list = null;
			while (_currentIndex < _expression.Length)
			{
				string text = ReadQuotedString();
				EatWhitespace();
				EnsureLength("Path ended with open indexer.");
				if (_expression[_currentIndex] == indexerCloseChar)
				{
					if (list != null)
					{
						list.Add(text);
						return new FieldMultipleFilter
						{
							Names = list
						};
					}
					return new FieldFilter
					{
						Name = text
					};
				}
				if (_expression[_currentIndex] == ',')
				{
					_currentIndex++;
					EatWhitespace();
					if (list == null)
					{
						list = new List<string>();
					}
					list.Add(text);
					continue;
				}
				throw new JsonException("Unexpected character while parsing path indexer: " + _expression[_currentIndex]);
			}
			throw new JsonException("Path ended with open indexer.");
		}

		private void EnsureLength(string message)
		{
			if (_currentIndex >= _expression.Length)
			{
				throw new JsonException(message);
			}
		}

		internal IEnumerable<JToken> Evaluate(JToken t, bool errorWhenNoMatch)
		{
			return Evaluate(Filters, t, errorWhenNoMatch);
		}

		internal static IEnumerable<JToken> Evaluate(List<PathFilter> filters, JToken t, bool errorWhenNoMatch)
		{
			IEnumerable<JToken> enumerable = new JToken[1] { t };
			foreach (PathFilter filter in filters)
			{
				enumerable = filter.ExecuteFilter(enumerable, errorWhenNoMatch);
			}
			return enumerable;
		}
	}
	[Preserve]
	internal abstract class PathFilter
	{
		public abstract IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch);

		protected static JToken GetTokenIndex(JToken t, bool errorWhenNoMatch, int index)
		{
			JArray jArray = t as JArray;
			JConstructor jConstructor = t as JConstructor;
			if (jArray != null)
			{
				if (jArray.Count <= index)
				{
					if (errorWhenNoMatch)
					{
						throw new JsonException("Index {0} outside the bounds of JArray.".FormatWith(CultureInfo.InvariantCulture, index));
					}
					return null;
				}
				return jArray[index];
			}
			if (jConstructor != null)
			{
				if (jConstructor.Count <= index)
				{
					if (errorWhenNoMatch)
					{
						throw new JsonException("Index {0} outside the bounds of JConstructor.".FormatWith(CultureInfo.InvariantCulture, index));
					}
					return null;
				}
				return jConstructor[index];
			}
			if (errorWhenNoMatch)
			{
				throw new JsonException("Index {0} not valid on {1}.".FormatWith(CultureInfo.InvariantCulture, index, t.GetType().Name));
			}
			return null;
		}
	}
	[Preserve]
	internal enum QueryOperator
	{
		None,
		Equals,
		NotEquals,
		Exists,
		LessThan,
		LessThanOrEquals,
		GreaterThan,
		GreaterThanOrEquals,
		And,
		Or
	}
	[Preserve]
	internal abstract class QueryExpression
	{
		public QueryOperator Operator { get; set; }

		public abstract bool IsMatch(JToken t);
	}
	[Preserve]
	internal class CompositeExpression : QueryExpression
	{
		public List<QueryExpression> Expressions { get; set; }

		public CompositeExpression()
		{
			Expressions = new List<QueryExpression>();
		}

		public override bool IsMatch(JToken t)
		{
			switch (base.Operator)
			{
			case QueryOperator.And:
				foreach (QueryExpression expression in Expressions)
				{
					if (!expression.IsMatch(t))
					{
						return false;
					}
				}
				return true;
			case QueryOperator.Or:
				foreach (QueryExpression expression2 in Expressions)
				{
					if (expression2.IsMatch(t))
					{
						return true;
					}
				}
				return false;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}
	}
	[Preserve]
	internal class BooleanQueryExpression : QueryExpression
	{
		public List<PathFilter> Path { get; set; }

		public JValue Value { get; set; }

		public override bool IsMatch(JToken t)
		{
			foreach (JToken item in JPath.Evaluate(Path, t, errorWhenNoMatch: false))
			{
				if (item is JValue jValue)
				{
					switch (base.Operator)
					{
					case QueryOperator.Equals:
						if (EqualsWithStringCoercion(jValue, Value))
						{
							return true;
						}
						break;
					case QueryOperator.NotEquals:
						if (!EqualsWithStringCoercion(jValue, Value))
						{
							return true;
						}
						break;
					case QueryOperator.GreaterThan:
						if (jValue.CompareTo(Value) > 0)
						{
							return true;
						}
						break;
					case QueryOperator.GreaterThanOrEquals:
						if (jValue.CompareTo(Value) >= 0)
						{
							return true;
						}
						break;
					case QueryOperator.LessThan:
						if (jValue.CompareTo(Value) < 0)
						{
							return true;
						}
						break;
					case QueryOperator.LessThanOrEquals:
						if (jValue.CompareTo(Value) <= 0)
						{
							return true;
						}
						break;
					case QueryOperator.Exists:
						return true;
					}
				}
				else
				{
					QueryOperator queryOperator = base.Operator;
					if (queryOperator == QueryOperator.NotEquals || queryOperator == QueryOperator.Exists)
					{
						return true;
					}
				}
			}
			return false;
		}

		private bool EqualsWithStringCoercion(JValue value, JValue queryValue)
		{
			if (value.Equals(queryValue))
			{
				return true;
			}
			if (queryValue.Type != JTokenType.String)
			{
				return false;
			}
			string b = (string)queryValue.Value;
			string a;
			switch (value.Type)
			{
			case JTokenType.Date:
			{
				using (StringWriter stringWriter = StringUtils.CreateStringWriter(64))
				{
					if (value.Value is DateTimeOffset)
					{
						DateTimeUtils.WriteDateTimeOffsetString(stringWriter, (DateTimeOffset)value.Value, DateFormatHandling.IsoDateFormat, null, CultureInfo.InvariantCulture);
					}
					else
					{
						DateTimeUtils.WriteDateTimeString(stringWriter, (DateTime)value.Value, DateFormatHandling.IsoDateFormat, null, CultureInfo.InvariantCulture);
					}
					a = stringWriter.ToString();
				}
				break;
			}
			case JTokenType.Bytes:
				a = Convert.ToBase64String((byte[])value.Value);
				break;
			case JTokenType.Guid:
			case JTokenType.TimeSpan:
				a = value.Value.ToString();
				break;
			case JTokenType.Uri:
				a = ((Uri)value.Value).OriginalString;
				break;
			default:
				return false;
			}
			return string.Equals(a, b, StringComparison.Ordinal);
		}
	}
	[Preserve]
	internal class QueryFilter : PathFilter
	{
		public QueryExpression Expression { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
		{
			foreach (JToken item in current)
			{
				foreach (JToken item2 in (IEnumerable<JToken>)item)
				{
					if (Expression.IsMatch(item2))
					{
						yield return item2;
					}
				}
			}
		}
	}
	[Preserve]
	internal class ScanFilter : PathFilter
	{
		public string Name { get; set; }

		public override IEnumerable<JToken> ExecuteFilter(IEnumerable<JToken> current, bool errorWhenNoMatch)
		{
			foreach (JToken root in current)
			{
				if (Name == null)
				{
					yield return root;
				}
				JToken value = root;
				JToken jToken = root;
				while (true)
				{
					if (jToken != null && jToken.HasValues)
					{
						value = jToken.First;
					}
					else
					{
						while (value != null && value != root && value == value.Parent.Last)
						{
							value = value.Parent;
						}
						if (value == null || value == root)
						{
							break;
						}
						value = value.Next;
					}
					if (value is JProperty jProperty)
					{
						if (jProperty.Name == Name)
						{
							yield return jProperty.Value;
						}
					}
					else if (Name == null)
					{
						yield return value;
					}
					jToken = value as JContainer;
				}
			}
		}
	}
}
namespace Newtonsoft.Json.Converters
{
	[Preserve]
	public class BinaryConverter : JsonConverter
	{
		private const string BinaryTypeName = "System.Data.Linq.Binary";

		private const string BinaryToArrayName = "ToArray";

		private ReflectionObject _reflectionObject;

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			byte[] byteArray = GetByteArray(value);
			writer.WriteValue(byteArray);
		}

		private byte[] GetByteArray(object value)
		{
			if (value.GetType().AssignableToTypeName("System.Data.Linq.Binary"))
			{
				EnsureReflectionObject(value.GetType());
				return (byte[])_reflectionObject.GetValue(value, "ToArray");
			}
			throw new JsonSerializationException("Unexpected value type when writing binary: {0}".FormatWith(CultureInfo.InvariantCulture, value.GetType()));
		}

		private void EnsureReflectionObject(Type t)
		{
			if (_reflectionObject == null)
			{
				_reflectionObject = ReflectionObject.Create(t, t.GetConstructor(new Type[1] { typeof(byte[]) }), "ToArray");
			}
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				if (!ReflectionUtils.IsNullable(objectType))
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			byte[] array;
			if (reader.TokenType == JsonToken.StartArray)
			{
				array = ReadByteArray(reader);
			}
			else
			{
				if (reader.TokenType != JsonToken.String)
				{
					throw JsonSerializationException.Create(reader, "Unexpected token parsing binary. Expected String or StartArray, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
				}
				array = Convert.FromBase64String(reader.Value.ToString());
			}
			Type type = (ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType);
			if (type.AssignableToTypeName("System.Data.Linq.Binary"))
			{
				EnsureReflectionObject(type);
				return _reflectionObject.Creator(array);
			}
			throw JsonSerializationException.Create(reader, "Unexpected object type when writing binary: {0}".FormatWith(CultureInfo.InvariantCulture, objectType));
		}

		private byte[] ReadByteArray(JsonReader reader)
		{
			List<byte> list = new List<byte>();
			while (reader.Read())
			{
				switch (reader.TokenType)
				{
				case JsonToken.Integer:
					list.Add(Convert.ToByte(reader.Value, CultureInfo.InvariantCulture));
					break;
				case JsonToken.EndArray:
					return list.ToArray();
				default:
					throw JsonSerializationException.Create(reader, "Unexpected token when reading bytes: {0}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
				case JsonToken.Comment:
					break;
				}
			}
			throw JsonSerializationException.Create(reader, "Unexpected end when reading bytes.");
		}

		public override bool CanConvert(Type objectType)
		{
			if (objectType.AssignableToTypeName("System.Data.Linq.Binary"))
			{
				return true;
			}
			return false;
		}
	}
	public class ColorConverter : JsonConverter
	{
		public override bool CanRead => true;

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			Color color = (Color)value;
			writer.WriteStartObject();
			writer.WritePropertyName("a");
			writer.WriteValue(color.a);
			writer.WritePropertyName("r");
			writer.WriteValue(color.r);
			writer.WritePropertyName("g");
			writer.WriteValue(color.g);
			writer.WritePropertyName("b");
			writer.WriteValue(color.b);
			writer.WriteEndObject();
		}

		public override bool CanConvert(Type objectType)
		{
			if ((object)objectType != typeof(Color))
			{
				return (object)objectType == typeof(Color32);
			}
			return true;
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				return default(Color);
			}
			JObject jObject = JObject.Load(reader);
			if ((object)objectType == typeof(Color32))
			{
				return new Color32((byte)jObject["r"], (byte)jObject["g"], (byte)jObject["b"], (byte)jObject["a"]);
			}
			return new Color((float)jObject["r"], (float)jObject["g"], (float)jObject["b"], (float)jObject["a"]);
		}
	}
	[Preserve]
	public abstract class CustomCreationConverter<T> : JsonConverter
	{
		public override bool CanWrite => false;

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			throw new NotSupportedException("CustomCreationConverter should only be used while deserializing.");
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				return null;
			}
			T val = Create(objectType);
			if (val == null)
			{
				throw new JsonSerializationException("No object created.");
			}
			serializer.Populate(reader, val);
			return val;
		}

		public abstract T Create(Type objectType);

		public override bool CanConvert(Type objectType)
		{
			return typeof(T).IsAssignableFrom(objectType);
		}
	}
	[Preserve]
	public abstract class DateTimeConverterBase : JsonConverter
	{
		public override bool CanConvert(Type objectType)
		{
			if ((object)objectType == typeof(DateTime) || (object)objectType == typeof(DateTime?))
			{
				return true;
			}
			if ((object)objectType == typeof(DateTimeOffset) || (object)objectType == typeof(DateTimeOffset?))
			{
				return true;
			}
			return false;
		}
	}
	public class EnumerableVectorConverter<T> : JsonConverter
	{
		private static readonly VectorConverter VectorConverter = new VectorConverter();

		public override bool CanRead => true;

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
			}
			T[] array = (value as IEnumerable<T>)?.ToArray();
			if (array == null)
			{
				writer.WriteNull();
				return;
			}
			writer.WriteStartArray();
			for (int i = 0; i < array.Length; i++)
			{
				VectorConverter.WriteJson(writer, array[i], serializer);
			}
			writer.WriteEndArray();
		}

		public override bool CanConvert(Type objectType)
		{
			if (!typeof(IEnumerable<Vector2>).IsAssignableFrom(objectType) && !typeof(IEnumerable<Vector3>).IsAssignableFrom(objectType))
			{
				return typeof(IEnumerable<Vector4>).IsAssignableFrom(objectType);
			}
			return true;
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				return null;
			}
			List<T> list = new List<T>();
			JObject jObject = JObject.Load(reader);
			for (int i = 0; i < jObject.Count; i++)
			{
				list.Add(JsonConvert.DeserializeObject<T>(jObject[i].ToString()));
			}
			return list;
		}
	}
	public class HashSetConverter : JsonConverter
	{
		public override bool CanWrite => false;

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			bool flag = serializer.ObjectCreationHandling == ObjectCreationHandling.Replace;
			if (reader.TokenType == JsonToken.Null)
			{
				if (!flag)
				{
					return existingValue;
				}
				return null;
			}
			object obj = ((!flag && existingValue != null) ? existingValue : Activator.CreateInstance(objectType));
			Type objectType2 = objectType.GetGenericArguments()[0];
			MethodInfo method = objectType.GetMethod("Add");
			JArray jArray = JArray.Load(reader);
			for (int i = 0; i < jArray.Count; i++)
			{
				object obj2 = serializer.Deserialize(jArray[i].CreateReader(), objectType2);
				method.Invoke(obj, new object[1] { obj2 });
			}
			return obj;
		}

		public override bool CanConvert(Type objectType)
		{
			if (objectType.IsGenericType())
			{
				return (object)objectType.GetGenericTypeDefinition() == typeof(HashSet<>);
			}
			return false;
		}
	}
	[Preserve]
	public class KeyValuePairConverter : JsonConverter
	{
		private const string KeyName = "Key";

		private const string ValueName = "Value";

		private static readonly ThreadSafeStore<Type, ReflectionObject> ReflectionObjectPerType = new ThreadSafeStore<Type, ReflectionObject>(InitializeReflectionObject);

		private static ReflectionObject InitializeReflectionObject(Type t)
		{
			Type[] genericArguments = t.GetGenericArguments();
			Type type = ((IList<Type>)genericArguments)[0];
			Type type2 = ((IList<Type>)genericArguments)[1];
			return ReflectionObject.Create(t, t.GetConstructor(new Type[2] { type, type2 }), "Key", "Value");
		}

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			ReflectionObject reflectionObject = ReflectionObjectPerType.Get(value.GetType());
			DefaultContractResolver defaultContractResolver = serializer.ContractResolver as DefaultContractResolver;
			writer.WriteStartObject();
			writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Key") : "Key");
			serializer.Serialize(writer, reflectionObject.GetValue(value, "Key"), reflectionObject.GetType("Key"));
			writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Value") : "Value");
			serializer.Serialize(writer, reflectionObject.GetValue(value, "Value"), reflectionObject.GetType("Value"));
			writer.WriteEndObject();
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				if (!ReflectionUtils.IsNullableType(objectType))
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to KeyValuePair.");
				}
				return null;
			}
			object obj = null;
			object obj2 = null;
			reader.ReadAndAssert();
			Type key = (ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType);
			ReflectionObject reflectionObject = ReflectionObjectPerType.Get(key);
			while (reader.TokenType == JsonToken.PropertyName)
			{
				string a = reader.Value.ToString();
				if (string.Equals(a, "Key", StringComparison.OrdinalIgnoreCase))
				{
					reader.ReadAndAssert();
					obj = serializer.Deserialize(reader, reflectionObject.GetType("Key"));
				}
				else if (string.Equals(a, "Value", StringComparison.OrdinalIgnoreCase))
				{
					reader.ReadAndAssert();
					obj2 = serializer.Deserialize(reader, reflectionObject.GetType("Value"));
				}
				else
				{
					reader.Skip();
				}
				reader.ReadAndAssert();
			}
			return reflectionObject.Creator(obj, obj2);
		}

		public override bool CanConvert(Type objectType)
		{
			Type type = (ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType);
			if (type.IsValueType() && type.IsGenericType())
			{
				return (object)type.GetGenericTypeDefinition() == typeof(KeyValuePair<, >);
			}
			return false;
		}
	}
	[Preserve]
	public class BsonObjectIdConverter : JsonConverter
	{
		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			BsonObjectId bsonObjectId = (BsonObjectId)value;
			if (writer is BsonWriter bsonWriter)
			{
				bsonWriter.WriteObjectId(bsonObjectId.Value);
			}
			else
			{
				writer.WriteValue(bsonObjectId.Value);
			}
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType != JsonToken.Bytes)
			{
				throw new JsonSerializationException("Expected Bytes but got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			return new BsonObjectId((byte[])reader.Value);
		}

		public override bool CanConvert(Type objectType)
		{
			return (object)objectType == typeof(BsonObjectId);
		}
	}
	public class Matrix4x4Converter : JsonConverter
	{
		public override bool CanRead => true;

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			Matrix4x4 matrix4x = (Matrix4x4)value;
			writer.WriteStartObject();
			writer.WritePropertyName("m00");
			writer.WriteValue(matrix4x.m00);
			writer.WritePropertyName("m01");
			writer.WriteValue(matrix4x.m01);
			writer.WritePropertyName("m02");
			writer.WriteValue(matrix4x.m02);
			writer.WritePropertyName("m03");
			writer.WriteValue(matrix4x.m03);
			writer.WritePropertyName("m10");
			writer.WriteValue(matrix4x.m10);
			writer.WritePropertyName("m11");
			writer.WriteValue(matrix4x.m11);
			writer.WritePropertyName("m12");
			writer.WriteValue(matrix4x.m12);
			writer.WritePropertyName("m13");
			writer.WriteValue(matrix4x.m13);
			writer.WritePropertyName("m20");
			writer.WriteValue(matrix4x.m20);
			writer.WritePropertyName("m21");
			writer.WriteValue(matrix4x.m21);
			writer.WritePropertyName("m22");
			writer.WriteValue(matrix4x.m22);
			writer.WritePropertyName("m23");
			writer.WriteValue(matrix4x.m23);
			writer.WritePropertyName("m30");
			writer.WriteValue(matrix4x.m30);
			writer.WritePropertyName("m31");
			writer.WriteValue(matrix4x.m31);
			writer.WritePropertyName("m32");
			writer.WriteValue(matrix4x.m32);
			writer.WritePropertyName("m33");
			writer.WriteValue(matrix4x.m33);
			writer.WriteEnd();
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				return default(Matrix4x4);
			}
			JObject jObject = JObject.Load(reader);
			return new Matrix4x4
			{
				m00 = (float)jObject["m00"],
				m01 = (float)jObject["m01"],
				m02 = (float)jObject["m02"],
				m03 = (float)jObject["m03"],
				m20 = (float)jObject["m20"],
				m21 = (float)jObject["m21"],
				m22 = (float)jObject["m22"],
				m23 = (float)jObject["m23"],
				m30 = (float)jObject["m30"],
				m31 = (float)jObject["m31"],
				m32 = (float)jObject["m32"],
				m33 = (float)jObject["m33"]
			};
		}

		public override bool CanConvert(Type objectType)
		{
			return (object)objectType == typeof(Matrix4x4);
		}
	}
	public class QuaternionConverter : JsonConverter
	{
		public override bool CanRead => true;

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			Quaternion quaternion = (Quaternion)value;
			writer.WriteStartObject();
			writer.WritePropertyName("w");
			writer.WriteValue(quaternion.w);
			writer.WritePropertyName("x");
			writer.WriteValue(quaternion.x);
			writer.WritePropertyName("y");
			writer.WriteValue(quaternion.y);
			writer.WritePropertyName("z");
			writer.WriteValue(quaternion.z);
			writer.WritePropertyName("eulerAngles");
			writer.WriteStartObject();
			writer.WritePropertyName("x");
			writer.WriteValue(quaternion.eulerAngles.x);
			writer.WritePropertyName("y");
			writer.WriteValue(quaternion.eulerAngles.y);
			writer.WritePropertyName("z");
			writer.WriteValue(quaternion.eulerAngles.z);
			writer.WriteEndObject();
			writer.WriteEndObject();
		}

		public override bool CanConvert(Type objectType)
		{
			return (object)objectType == typeof(Quaternion);
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			JObject jObject = JObject.Load(reader);
			List<JProperty> source = jObject.Properties().ToList();
			Quaternion quaternion = default(Quaternion);
			if (source.Any((JProperty p) => p.Name == "w"))
			{
				quaternion.w = (float)jObject["w"];
			}
			if (source.Any((JProperty p) => p.Name == "x"))
			{
				quaternion.x = (float)jObject["x"];
			}
			if (source.Any((JProperty p) => p.Name == "y"))
			{
				quaternion.y = (float)jObject["y"];
			}
			if (source.Any((JProperty p) => p.Name == "z"))
			{
				quaternion.z = (float)jObject["z"];
			}
			if (source.Any((JProperty p) => p.Name == "eulerAngles"))
			{
				JToken jToken = jObject["eulerAngles"];
				quaternion.eulerAngles = new Vector3
				{
					x = (float)jToken["x"],
					y = (float)jToken["y"],
					z = (float)jToken["z"]
				};
			}
			return quaternion;
		}
	}
	[Preserve]
	public class RegexConverter : JsonConverter
	{
		private const string PatternName = "Pattern";

		private const string OptionsName = "Options";

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			Regex regex = (Regex)value;
			if (writer is BsonWriter writer2)
			{
				WriteBson(writer2, regex);
			}
			else
			{
				WriteJson(writer, regex, serializer);
			}
		}

		private bool HasFlag(RegexOptions options, RegexOptions flag)
		{
			return (options & flag) == flag;
		}

		private void WriteBson(BsonWriter writer, Regex regex)
		{
			string text = null;
			if (HasFlag(regex.Options, RegexOptions.IgnoreCase))
			{
				text += "i";
			}
			if (HasFlag(regex.Options, RegexOptions.Multiline))
			{
				text += "m";
			}
			if (HasFlag(regex.Options, RegexOptions.Singleline))
			{
				text += "s";
			}
			text += "u";
			if (HasFlag(regex.Options, RegexOptions.ExplicitCapture))
			{
				text += "x";
			}
			writer.WriteRegex(regex.ToString(), text);
		}

		private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer)
		{
			DefaultContractResolver defaultContractResolver = serializer.ContractResolver as DefaultContractResolver;
			writer.WriteStartObject();
			writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Pattern") : "Pattern");
			writer.WriteValue(regex.ToString());
			writer.WritePropertyName((defaultContractResolver != null) ? defaultContractResolver.GetResolvedPropertyName("Options") : "Options");
			serializer.Serialize(writer, regex.Options);
			writer.WriteEndObject();
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.StartObject)
			{
				return ReadRegexObject(reader, serializer);
			}
			if (reader.TokenType == JsonToken.String)
			{
				return ReadRegexString(reader);
			}
			throw JsonSerializationException.Create(reader, "Unexpected token when reading Regex.");
		}

		private object ReadRegexString(JsonReader reader)
		{
			string obj = (string)reader.Value;
			int num = obj.LastIndexOf('/');
			string pattern = obj.Substring(1, num - 1);
			string text = obj.Substring(num + 1);
			RegexOptions regexOptions = RegexOptions.None;
			string text2 = text;
			for (int i = 0; i < text2.Length; i++)
			{
				switch (text2[i])
				{
				case 'i':
					regexOptions |= RegexOptions.IgnoreCase;
					break;
				case 'm':
					regexOptions |= RegexOptions.Multiline;
					break;
				case 's':
					regexOptions |= RegexOptions.Singleline;
					break;
				case 'x':
					regexOptions |= RegexOptions.ExplicitCapture;
					break;
				}
			}
			return new Regex(pattern, regexOptions);
		}

		private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer)
		{
			string text = null;
			RegexOptions? regexOptions = null;
			while (reader.Read())
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					string a = reader.Value.ToString();
					if (!reader.Read())
					{
						throw JsonSerializationException.Create(reader, "Unexpected end when reading Regex.");
					}
					if (string.Equals(a, "Pattern", StringComparison.OrdinalIgnoreCase))
					{
						text = (string)reader.Value;
					}
					else if (string.Equals(a, "Options", StringComparison.OrdinalIgnoreCase))
					{
						regexOptions = serializer.Deserialize<RegexOptions>(reader);
					}
					else
					{
						reader.Skip();
					}
					break;
				}
				case JsonToken.EndObject:
					if (text == null)
					{
						throw JsonSerializationException.Create(reader, "Error deserializing Regex. No pattern found.");
					}
					return new Regex(text, regexOptions ?? RegexOptions.None);
				}
			}
			throw JsonSerializationException.Create(reader, "Unexpected end when reading Regex.");
		}

		public override bool CanConvert(Type objectType)
		{
			return (object)objectType == typeof(Regex);
		}
	}
	public class ResolutionConverter : JsonConverter
	{
		public override bool CanRead => true;

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			Resolution resolution = (Resolution)value;
			writer.WriteStartObject();
			writer.WritePropertyName("height");
			writer.WriteValue(resolution.height);
			writer.WritePropertyName("width");
			writer.WriteValue(resolution.width);
			writer.WritePropertyName("refreshRate");
			writer.WriteValue(resolution.refreshRate);
			writer.WriteEndObject();
		}

		public override bool CanConvert(Type objectType)
		{
			return (object)objectType == typeof(Resolution);
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			JObject jObject = JObject.Load(reader);
			return new Resolution
			{
				height = (int)jObject["height"],
				width = (int)jObject["width"],
				refreshRate = (int)jObject["refreshRate"]
			};
		}
	}
	[Preserve]
	public class StringEnumConverter : JsonConverter
	{
		public bool CamelCaseText { get; set; }

		public bool AllowIntegerValues { get; set; }

		public StringEnumConverter()
		{
			AllowIntegerValues = true;
		}

		public StringEnumConverter(bool camelCaseText)
			: this()
		{
			CamelCaseText = camelCaseText;
		}

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			Enum obj = (Enum)value;
			string text = obj.ToString("G");
			if (char.IsNumber(text[0]) || text[0] == '-')
			{
				writer.WriteValue(value);
				return;
			}
			string value2 = EnumUtils.ToEnumName(obj.GetType(), text, CamelCaseText);
			writer.WriteValue(value2);
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				if (!ReflectionUtils.IsNullableType(objectType))
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			bool flag = ReflectionUtils.IsNullableType(objectType);
			Type type = (flag ? Nullable.GetUnderlyingType(objectType) : objectType);
			try
			{
				if (reader.TokenType == JsonToken.String)
				{
					return EnumUtils.ParseEnumName(reader.Value.ToString(), flag, type);
				}
				if (reader.TokenType == JsonToken.Integer)
				{
					if (!AllowIntegerValues)
					{
						throw JsonSerializationException.Create(reader, "Integer value {0} is not allowed.".FormatWith(CultureInfo.InvariantCulture, reader.Value));
					}
					return ConvertUtils.ConvertOrCast(reader.Value, CultureInfo.InvariantCulture, type);
				}
			}
			catch (Exception ex)
			{
				throw JsonSerializationException.Create(reader, "Error converting value {0} to type '{1}'.".FormatWith(CultureInfo.InvariantCulture, MiscellaneousUtils.FormatValueForPrint(reader.Value), objectType), ex);
			}
			throw JsonSerializationException.Create(reader, "Unexpected token {0} when parsing enum.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}

		public override bool CanConvert(Type objectType)
		{
			return (ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType).IsEnum();
		}
	}
	public class UriConverter : JsonConverter
	{
		public override bool CanConvert(Type objectType)
		{
			return (object)objectType == typeof(Uri);
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			return reader.TokenType switch
			{
				JsonToken.String => new Uri((string)reader.Value), 
				JsonToken.Null => null, 
				_ => throw new InvalidOperationException("Unhandled case for UriConverter. Check to see if this converter has been applied to the wrong serialization type."), 
			};
		}

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			Uri uri = value as Uri;
			if (uri == null)
			{
				throw new InvalidOperationException("Unhandled case for UriConverter. Check to see if this converter has been applied to the wrong serialization type.");
			}
			writer.WriteValue(uri.OriginalString);
		}
	}
	[Preserve]
	public class VectorConverter : JsonConverter
	{
		private static readonly Type V2 = typeof(Vector2);

		private static readonly Type V3 = typeof(Vector3);

		private static readonly Type V4 = typeof(Vector4);

		public bool EnableVector2 { get; set; }

		public bool EnableVector3 { get; set; }

		public bool EnableVector4 { get; set; }

		public VectorConverter()
		{
			EnableVector2 = true;
			EnableVector3 = true;
			EnableVector4 = true;
		}

		public VectorConverter(bool enableVector2, bool enableVector3, bool enableVector4)
			: this()
		{
			EnableVector2 = enableVector2;
			EnableVector3 = enableVector3;
			EnableVector4 = enableVector4;
		}

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			Type type = value.GetType();
			if ((object)type == V2)
			{
				Vector2 vector = (Vector2)value;
				WriteVector(writer, vector.x, vector.y, null, null);
			}
			else if ((object)type == V3)
			{
				Vector3 vector2 = (Vector3)value;
				WriteVector(writer, vector2.x, vector2.y, vector2.z, null);
			}
			else if ((object)type == V4)
			{
				Vector4 vector3 = (Vector4)value;
				WriteVector(writer, vector3.x, vector3.y, vector3.z, vector3.w);
			}
			else
			{
				writer.WriteNull();
			}
		}

		private static void WriteVector(JsonWriter writer, float x, float y, float? z, float? w)
		{
			writer.WriteStartObject();
			writer.WritePropertyName("x");
			writer.WriteValue(x);
			writer.WritePropertyName("y");
			writer.WriteValue(y);
			if (z.HasValue)
			{
				writer.WritePropertyName("z");
				writer.WriteValue(z.Value);
				if (w.HasValue)
				{
					writer.WritePropertyName("w");
					writer.WriteValue(w.Value);
				}
			}
			writer.WriteEndObject();
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if ((object)objectType == V2)
			{
				return PopulateVector2(reader);
			}
			if ((object)objectType == V3)
			{
				return PopulateVector3(reader);
			}
			return PopulateVector4(reader);
		}

		public override bool CanConvert(Type objectType)
		{
			if ((!EnableVector2 || (object)objectType != V2) && (!EnableVector3 || (object)objectType != V3))
			{
				if (EnableVector4)
				{
					return (object)objectType == V4;
				}
				return false;
			}
			return true;
		}

		private static Vector2 PopulateVector2(JsonReader reader)
		{
			Vector2 result = default(Vector2);
			if (reader.TokenType != JsonToken.Null)
			{
				JObject jObject = JObject.Load(reader);
				result.x = jObject["x"].Value<float>();
				result.y = jObject["y"].Value<float>();
			}
			return result;
		}

		private static Vector3 PopulateVector3(JsonReader reader)
		{
			Vector3 result = default(Vector3);
			if (reader.TokenType != JsonToken.Null)
			{
				JObject jObject = JObject.Load(reader);
				result.x = jObject["x"].Value<float>();
				result.y = jObject["y"].Value<float>();
				result.z = jObject["z"].Value<float>();
			}
			return result;
		}

		private static Vector4 PopulateVector4(JsonReader reader)
		{
			Vector4 result = default(Vector4);
			if (reader.TokenType != JsonToken.Null)
			{
				JObject jObject = JObject.Load(reader);
				result.x = jObject["x"].Value<float>();
				result.y = jObject["y"].Value<float>();
				result.z = jObject["z"].Value<float>();
				result.w = jObject["w"].Value<float>();
			}
			return result;
		}
	}
	[Preserve]
	public class VersionConverter : JsonConverter
	{
		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			if (value == null)
			{
				writer.WriteNull();
				return;
			}
			if (value is Version)
			{
				writer.WriteValue(value.ToString());
				return;
			}
			throw new JsonSerializationException("Expected Version object value");
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				return null;
			}
			if (reader.TokenType == JsonToken.String)
			{
				try
				{
					return new Version((string)reader.Value);
				}
				catch (Exception ex)
				{
					throw JsonSerializationException.Create(reader, "Error parsing version string: {0}".FormatWith(CultureInfo.InvariantCulture, reader.Value), ex);
				}
			}
			throw JsonSerializationException.Create(reader, "Unexpected token or value when parsing version. Token: {0}, Value: {1}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType, reader.Value));
		}

		public override bool CanConvert(Type objectType)
		{
			return (object)objectType == typeof(Version);
		}
	}
	[Preserve]
	public class IsoDateTimeConverter : DateTimeConverterBase
	{
		private const string DefaultDateTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK";

		private DateTimeStyles _dateTimeStyles = DateTimeStyles.RoundtripKind;

		private string _dateTimeFormat;

		private CultureInfo _culture;

		public DateTimeStyles DateTimeStyles
		{
			get
			{
				return _dateTimeStyles;
			}
			set
			{
				_dateTimeStyles = value;
			}
		}

		public string DateTimeFormat
		{
			get
			{
				return _dateTimeFormat ?? string.Empty;
			}
			set
			{
				_dateTimeFormat = StringUtils.NullEmptyString(value);
			}
		}

		public CultureInfo Culture
		{
			get
			{
				return _culture ?? CultureInfo.CurrentCulture;
			}
			set
			{
				_culture = value;
			}
		}

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			string value2;
			if (value is DateTime dateTime)
			{
				if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
				{
					dateTime = dateTime.ToUniversalTime();
				}
				value2 = dateTime.ToString(_dateTimeFormat ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK", Culture);
			}
			else
			{
				if (!(value is DateTimeOffset dateTimeOffset))
				{
					throw new JsonSerializationException("Unexpected value when converting date. Expected DateTime or DateTimeOffset, got {0}.".FormatWith(CultureInfo.InvariantCulture, ReflectionUtils.GetObjectType(value)));
				}
				if ((_dateTimeStyles & DateTimeStyles.AdjustToUniversal) == DateTimeStyles.AdjustToUniversal || (_dateTimeStyles & DateTimeStyles.AssumeUniversal) == DateTimeStyles.AssumeUniversal)
				{
					dateTimeOffset = dateTimeOffset.ToUniversalTime();
				}
				value2 = dateTimeOffset.ToString(_dateTimeFormat ?? "yyyy'-'MM'-'dd'T'HH':'mm':'ss.FFFFFFFK", Culture);
			}
			writer.WriteValue(value2);
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			bool flag = ReflectionUtils.IsNullableType(objectType);
			Type type = (flag ? Nullable.GetUnderlyingType(objectType) : objectType);
			if (reader.TokenType == JsonToken.Null)
			{
				if (!ReflectionUtils.IsNullableType(objectType))
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			if (reader.TokenType == JsonToken.Date)
			{
				if ((object)type == typeof(DateTimeOffset))
				{
					if (!(reader.Value is DateTimeOffset))
					{
						return new DateTimeOffset((DateTime)reader.Value);
					}
					return reader.Value;
				}
				if (reader.Value is DateTimeOffset)
				{
					return ((DateTimeOffset)reader.Value).DateTime;
				}
				return reader.Value;
			}
			if (reader.TokenType != JsonToken.String)
			{
				throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected String, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			string text = reader.Value.ToString();
			if (string.IsNullOrEmpty(text) && flag)
			{
				return null;
			}
			if ((object)type == typeof(DateTimeOffset))
			{
				if (!string.IsNullOrEmpty(_dateTimeFormat))
				{
					return DateTimeOffset.ParseExact(text, _dateTimeFormat, Culture, _dateTimeStyles);
				}
				return DateTimeOffset.Parse(text, Culture, _dateTimeStyles);
			}
			if (!string.IsNullOrEmpty(_dateTimeFormat))
			{
				return DateTime.ParseExact(text, _dateTimeFormat, Culture, _dateTimeStyles);
			}
			return DateTime.Parse(text, Culture, _dateTimeStyles);
		}
	}
	[Preserve]
	public class JavaScriptDateTimeConverter : DateTimeConverterBase
	{
		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			long value2;
			if (value is DateTime dateTime)
			{
				value2 = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTime.ToUniversalTime());
			}
			else
			{
				if (!(value is DateTimeOffset dateTimeOffset))
				{
					throw new JsonSerializationException("Expected date object value.");
				}
				value2 = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTimeOffset.ToUniversalTime().UtcDateTime);
			}
			writer.WriteStartConstructor("Date");
			writer.WriteValue(value2);
			writer.WriteEndConstructor();
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				if (!ReflectionUtils.IsNullable(objectType))
				{
					throw JsonSerializationException.Create(reader, "Cannot convert null value to {0}.".FormatWith(CultureInfo.InvariantCulture, objectType));
				}
				return null;
			}
			if (reader.TokenType != JsonToken.StartConstructor || !string.Equals(reader.Value.ToString(), "Date", StringComparison.Ordinal))
			{
				throw JsonSerializationException.Create(reader, "Unexpected token or value when parsing date. Token: {0}, Value: {1}".FormatWith(CultureInfo.InvariantCulture, reader.TokenType, reader.Value));
			}
			reader.Read();
			if (reader.TokenType != JsonToken.Integer)
			{
				throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected Integer, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			DateTime dateTime = DateTimeUtils.ConvertJavaScriptTicksToDateTime((long)reader.Value);
			reader.Read();
			if (reader.TokenType != JsonToken.EndConstructor)
			{
				throw JsonSerializationException.Create(reader, "Unexpected token parsing date. Expected EndConstructor, got {0}.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
			}
			if ((object)(ReflectionUtils.IsNullableType(objectType) ? Nullable.GetUnderlyingType(objectType) : objectType) == typeof(DateTimeOffset))
			{
				return new DateTimeOffset(dateTime);
			}
			return dateTime;
		}
	}
	internal class XmlDocumentWrapper : XmlNodeWrapper, IXmlDocument, IXmlNode
	{
		private readonly XmlDocument _document;

		public IXmlElement DocumentElement
		{
			get
			{
				if (_document.DocumentElement == null)
				{
					return null;
				}
				return new XmlElementWrapper(_document.DocumentElement);
			}
		}

		public XmlDocumentWrapper(XmlDocument document)
			: base(document)
		{
			_document = document;
		}

		public IXmlNode CreateComment(string data)
		{
			return new XmlNodeWrapper(_document.CreateComment(data));
		}

		public IXmlNode CreateTextNode(string text)
		{
			return new XmlNodeWrapper(_document.CreateTextNode(text));
		}

		public IXmlNode CreateCDataSection(string data)
		{
			return new XmlNodeWrapper(_document.CreateCDataSection(data));
		}

		public IXmlNode CreateWhitespace(string text)
		{
			return new XmlNodeWrapper(_document.CreateWhitespace(text));
		}

		public IXmlNode CreateSignificantWhitespace(string text)
		{
			return new XmlNodeWrapper(_document.CreateSignificantWhitespace(text));
		}

		public IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone)
		{
			return new XmlDeclarationWrapper(_document.CreateXmlDeclaration(version, encoding, standalone));
		}

		public IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset)
		{
			return new XmlDocumentTypeWrapper(_document.CreateDocumentType(name, publicId, systemId, null));
		}

		public IXmlNode CreateProcessingInstruction(string target, string data)
		{
			return new XmlNodeWrapper(_document.CreateProcessingInstruction(target, data));
		}

		public IXmlElement CreateElement(string elementName)
		{
			return new XmlElementWrapper(_document.CreateElement(elementName));
		}

		public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
		{
			return new XmlElementWrapper(_document.CreateElement(qualifiedName, namespaceUri));
		}

		public IXmlNode CreateAttribute(string name, string value)
		{
			return new XmlNodeWrapper(_document.CreateAttribute(name))
			{
				Value = value
			};
		}

		public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value)
		{
			return new XmlNodeWrapper(_document.CreateAttribute(qualifiedName, namespaceUri))
			{
				Value = value
			};
		}
	}
	internal class XmlElementWrapper : XmlNodeWrapper, IXmlElement, IXmlNode
	{
		private readonly XmlElement _element;

		public bool IsEmpty => _element.IsEmpty;

		public XmlElementWrapper(XmlElement element)
			: base(element)
		{
			_element = element;
		}

		public void SetAttributeNode(IXmlNode attribute)
		{
			XmlNodeWrapper xmlNodeWrapper = (XmlNodeWrapper)attribute;
			_element.SetAttributeNode((XmlAttribute)xmlNodeWrapper.WrappedNode);
		}

		public string GetPrefixOfNamespace(string namespaceUri)
		{
			return _element.GetPrefixOfNamespace(namespaceUri);
		}
	}
	internal class XmlDeclarationWrapper : XmlNodeWrapper, IXmlDeclaration, IXmlNode
	{
		private readonly XmlDeclaration _declaration;

		public string Version => _declaration.Version;

		public string Encoding
		{
			get
			{
				return _declaration.Encoding;
			}
			set
			{
				_declaration.Encoding = value;
			}
		}

		public string Standalone
		{
			get
			{
				return _declaration.Standalone;
			}
			set
			{
				_declaration.Standalone = value;
			}
		}

		public XmlDeclarationWrapper(XmlDeclaration declaration)
			: base(declaration)
		{
			_declaration = declaration;
		}
	}
	internal class XmlDocumentTypeWrapper : XmlNodeWrapper, IXmlDocumentType, IXmlNode
	{
		private readonly XmlDocumentType _documentType;

		public string Name => _documentType.Name;

		public string System => _documentType.SystemId;

		public string Public => _documentType.PublicId;

		public string InternalSubset => _documentType.InternalSubset;

		public override string LocalName => "DOCTYPE";

		public XmlDocumentTypeWrapper(XmlDocumentType documentType)
			: base(documentType)
		{
			_documentType = documentType;
		}
	}
	internal class XmlNodeWrapper : IXmlNode
	{
		private readonly XmlNode _node;

		private List<IXmlNode> _childNodes;

		private List<IXmlNode> _attributes;

		public object WrappedNode => _node;

		public XmlNodeType NodeType => _node.NodeType;

		public virtual string LocalName => _node.LocalName;

		public List<IXmlNode> ChildNodes
		{
			get
			{
				if (_childNodes == null)
				{
					_childNodes = new List<IXmlNode>(_node.ChildNodes.Count);
					foreach (XmlNode childNode in _node.ChildNodes)
					{
						_childNodes.Add(WrapNode(childNode));
					}
				}
				return _childNodes;
			}
		}

		public List<IXmlNode> Attributes
		{
			get
			{
				if (_node.Attributes == null)
				{
					return null;
				}
				if (_attributes == null)
				{
					_attributes = new List<IXmlNode>(_node.Attributes.Count);
					foreach (XmlAttribute attribute in _node.Attributes)
					{
						_attributes.Add(WrapNode(attribute));
					}
				}
				return _attributes;
			}
		}

		public IXmlNode ParentNode
		{
			get
			{
				XmlNode xmlNode = ((_node is XmlAttribute) ? ((XmlAttribute)_node).OwnerElement : _node.ParentNode);
				if (xmlNode == null)
				{
					return null;
				}
				return WrapNode(xmlNode);
			}
		}

		public string Value
		{
			get
			{
				return _node.Value;
			}
			set
			{
				_node.Value = value;
			}
		}

		public string NamespaceUri => _node.NamespaceURI;

		public XmlNodeWrapper(XmlNode node)
		{
			_node = node;
		}

		internal static IXmlNode WrapNode(XmlNode node)
		{
			return node.NodeType switch
			{
				XmlNodeType.Element => new XmlElementWrapper((XmlElement)node), 
				XmlNodeType.XmlDeclaration => new XmlDeclarationWrapper((XmlDeclaration)node), 
				XmlNodeType.DocumentType => new XmlDocumentTypeWrapper((XmlDocumentType)node), 
				_ => new XmlNodeWrapper(node), 
			};
		}

		public IXmlNode AppendChild(IXmlNode newChild)
		{
			XmlNodeWrapper xmlNodeWrapper = (XmlNodeWrapper)newChild;
			_node.AppendChild(xmlNodeWrapper._node);
			_childNodes = null;
			_attributes = null;
			return newChild;
		}
	}
	internal interface IXmlDocument : IXmlNode
	{
		IXmlElement DocumentElement { get; }

		IXmlNode CreateComment(string text);

		IXmlNode CreateTextNode(string text);

		IXmlNode CreateCDataSection(string data);

		IXmlNode CreateWhitespace(string text);

		IXmlNode CreateSignificantWhitespace(string text);

		IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);

		IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);

		IXmlNode CreateProcessingInstruction(string target, string data);

		IXmlElement CreateElement(string elementName);

		IXmlElement CreateElement(string qualifiedName, string namespaceUri);

		IXmlNode CreateAttribute(string name, string value);

		IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
	}
	internal interface IXmlDeclaration : IXmlNode
	{
		string Version { get; }

		string Encoding { get; set; }

		string Standalone { get; set; }
	}
	internal interface IXmlDocumentType : IXmlNode
	{
		string Name { get; }

		string System { get; }

		string Public { get; }

		string InternalSubset { get; }
	}
	internal interface IXmlElement : IXmlNode
	{
		bool IsEmpty { get; }

		void SetAttributeNode(IXmlNode attribute);

		string GetPrefixOfNamespace(string namespaceUri);
	}
	internal interface IXmlNode
	{
		XmlNodeType NodeType { get; }

		string LocalName { get; }

		List<IXmlNode> ChildNodes { get; }

		List<IXmlNode> Attributes { get; }

		IXmlNode ParentNode { get; }

		string Value { get; set; }

		string NamespaceUri { get; }

		object WrappedNode { get; }

		IXmlNode AppendChild(IXmlNode newChild);
	}
	internal class XDeclarationWrapper : XObjectWrapper, IXmlDeclaration, IXmlNode
	{
		internal XDeclaration Declaration { get; private set; }

		public override XmlNodeType NodeType => XmlNodeType.XmlDeclaration;

		public string Version => Declaration.Version;

		public string Encoding
		{
			get
			{
				return Declaration.Encoding;
			}
			set
			{
				Declaration.Encoding = value;
			}
		}

		public string Standalone
		{
			get
			{
				return Declaration.Standalone;
			}
			set
			{
				Declaration.Standalone = value;
			}
		}

		public XDeclarationWrapper(XDeclaration declaration)
			: base(null)
		{
			Declaration = declaration;
		}
	}
	internal class XDocumentTypeWrapper : XObjectWrapper, IXmlDocumentType, IXmlNode
	{
		private readonly XDocumentType _documentType;

		public string Name => _documentType.Name;

		public string System => _documentType.SystemId;

		public string Public => _documentType.PublicId;

		public string InternalSubset => _documentType.InternalSubset;

		public override string LocalName => "DOCTYPE";

		public XDocumentTypeWrapper(XDocumentType documentType)
			: base(documentType)
		{
			_documentType = documentType;
		}
	}
	internal class XDocumentWrapper : XContainerWrapper, IXmlDocument, IXmlNode
	{
		private XDocument Document => (XDocument)base.WrappedNode;

		public override List<IXmlNode> ChildNodes
		{
			get
			{
				List<IXmlNode> childNodes = base.ChildNodes;
				if (Document.Declaration != null && childNodes[0].NodeType != XmlNodeType.XmlDeclaration)
				{
					childNodes.Insert(0, new XDeclarationWrapper(Document.Declaration));
				}
				return childNodes;
			}
		}

		public IXmlElement DocumentElement
		{
			get
			{
				if (Document.Root == null)
				{
					return null;
				}
				return new XElementWrapper(Document.Root);
			}
		}

		public XDocumentWrapper(XDocument document)
			: base(document)
		{
		}

		public IXmlNode CreateComment(string text)
		{
			return new XObjectWrapper(new XComment(text));
		}

		public IXmlNode CreateTextNode(string text)
		{
			return new XObjectWrapper(new XText(text));
		}

		public IXmlNode CreateCDataSection(string data)
		{
			return new XObjectWrapper(new XCData(data));
		}

		public IXmlNode CreateWhitespace(string text)
		{
			return new XObjectWrapper(new XText(text));
		}

		public IXmlNode CreateSignificantWhitespace(string text)
		{
			return new XObjectWrapper(new XText(text));
		}

		public IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone)
		{
			return new XDeclarationWrapper(new XDeclaration(version, encoding, standalone));
		}

		public IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset)
		{
			return new XDocumentTypeWrapper(new XDocumentType(name, publicId, systemId, internalSubset));
		}

		public IXmlNode CreateProcessingInstruction(string target, string data)
		{
			return new XProcessingInstructionWrapper(new XProcessingInstruction(target, data));
		}

		public IXmlElement CreateElement(string elementName)
		{
			return new XElementWrapper(new XElement(elementName));
		}

		public IXmlElement CreateElement(string qualifiedName, string namespaceUri)
		{
			return new XElementWrapper(new XElement(XName.Get(MiscellaneousUtils.GetLocalName(qualifiedName), namespaceUri)));
		}

		public IXmlNode CreateAttribute(string name, string value)
		{
			return new XAttributeWrapper(new XAttribute(name, value));
		}

		public IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value)
		{
			return new XAttributeWrapper(new XAttribute(XName.Get(MiscellaneousUtils.GetLocalName(qualifiedName), namespaceUri), value));
		}

		public override IXmlNode AppendChild(IXmlNode newChild)
		{
			if (newChild is XDeclarationWrapper xDeclarationWrapper)
			{
				Document.Declaration = xDeclarationWrapper.Declaration;
				return xDeclarationWrapper;
			}
			return base.AppendChild(newChild);
		}
	}
	internal class XTextWrapper : XObjectWrapper
	{
		private XText Text => (XText)base.WrappedNode;

		public override string Value
		{
			get
			{
				return Text.Value;
			}
			set
			{
				Text.Value = value;
			}
		}

		public override IXmlNode ParentNode
		{
			get
			{
				if (Text.Parent == null)
				{
					return null;
				}
				return XContainerWrapper.WrapNode(Text.Parent);
			}
		}

		public XTextWrapper(XText text)
			: base(text)
		{
		}
	}
	internal class XCommentWrapper : XObjectWrapper
	{
		private XComment Text => (XComment)base.WrappedNode;

		public override string Value
		{
			get
			{
				return Text.Value;
			}
			set
			{
				Text.Value = value;
			}
		}

		public override IXmlNode ParentNode
		{
			get
			{
				if (Text.Parent == null)
				{
					return null;
				}
				return XContainerWrapper.WrapNode(Text.Parent);
			}
		}

		public XCommentWrapper(XComment text)
			: base(text)
		{
		}
	}
	internal class XProcessingInstructionWrapper : XObjectWrapper
	{
		private XProcessingInstruction ProcessingInstruction => (XProcessingInstruction)base.WrappedNode;

		public override string LocalName => ProcessingInstruction.Target;

		public override string Value
		{
			get
			{
				return ProcessingInstruction.Data;
			}
			set
			{
				ProcessingInstruction.Data = value;
			}
		}

		public XProcessingInstructionWrapper(XProcessingInstruction processingInstruction)
			: base(processingInstruction)
		{
		}
	}
	internal class XContainerWrapper : XObjectWrapper
	{
		private List<IXmlNode> _childNodes;

		private XContainer Container => (XContainer)base.WrappedNode;

		public override List<IXmlNode> ChildNodes
		{
			get
			{
				if (_childNodes == null)
				{
					_childNodes = new List<IXmlNode>();
					foreach (XNode item in Container.Nodes())
					{
						_childNodes.Add(WrapNode(item));
					}
				}
				return _childNodes;
			}
		}

		public override IXmlNode ParentNode
		{
			get
			{
				if (Container.Parent == null)
				{
					return null;
				}
				return WrapNode(Container.Parent);
			}
		}

		public XContainerWrapper(XContainer container)
			: base(container)
		{
		}

		internal static IXmlNode WrapNode(XObject node)
		{
			if (node is XDocument)
			{
				return new XDocumentWrapper((XDocument)node);
			}
			if (node is XElement)
			{
				return new XElementWrapper((XElement)node);
			}
			if (node is XContainer)
			{
				return new XContainerWrapper((XContainer)node);
			}
			if (node is XProcessingInstruction)
			{
				return new XProcessingInstructionWrapper((XProcessingInstruction)node);
			}
			if (node is XText)
			{
				return new XTextWrapper((XText)node);
			}
			if (node is XComment)
			{
				return new XCommentWrapper((XComment)node);
			}
			if (node is XAttribute)
			{
				return new XAttributeWrapper((XAttribute)node);
			}
			if (node is XDocumentType)
			{
				return new XDocumentTypeWrapper((XDocumentType)node);
			}
			return new XObjectWrapper(node);
		}

		public override IXmlNode AppendChild(IXmlNode newChild)
		{
			Container.Add(newChild.WrappedNode);
			_childNodes = null;
			return newChild;
		}
	}
	internal class XObjectWrapper : IXmlNode
	{
		private static readonly List<IXmlNode> EmptyChildNodes = new List<IXmlNode>();

		private readonly XObject _xmlObject;

		public object WrappedNode => _xmlObject;

		public virtual XmlNodeType NodeType => _xmlObject.NodeType;

		public virtual string LocalName => null;

		public virtual List<IXmlNode> ChildNodes => EmptyChildNodes;

		public virtual List<IXmlNode> Attributes => null;

		public virtual IXmlNode ParentNode => null;

		public virtual string Value
		{
			get
			{
				return null;
			}
			set
			{
				throw new InvalidOperationException();
			}
		}

		public virtual string NamespaceUri => null;

		public XObjectWrapper(XObject xmlObject)
		{
			_xmlObject = xmlObject;
		}

		public virtual IXmlNode AppendChild(IXmlNode newChild)
		{
			throw new InvalidOperationException();
		}
	}
	internal class XAttributeWrapper : XObjectWrapper
	{
		private XAttribute Attribute => (XAttribute)base.WrappedNode;

		public override string Value
		{
			get
			{
				return Attribute.Value;
			}
			set
			{
				Attribute.Value = value;
			}
		}

		public override string LocalName => Attribute.Name.LocalName;

		public override string NamespaceUri => Attribute.Name.NamespaceName;

		public override IXmlNode ParentNode
		{
			get
			{
				if (Attribute.Parent == null)
				{
					return null;
				}
				return XContainerWrapper.WrapNode(Attribute.Parent);
			}
		}

		public XAttributeWrapper(XAttribute attribute)
			: base(attribute)
		{
		}
	}
	internal class XElementWrapper : XContainerWrapper, IXmlElement, IXmlNode
	{
		private List<IXmlNode> _attributes;

		private XElement Element => (XElement)base.WrappedNode;

		public override List<IXmlNode> Attributes
		{
			get
			{
				if (_attributes == null)
				{
					_attributes = new List<IXmlNode>();
					foreach (XAttribute item in Element.Attributes())
					{
						_attributes.Add(new XAttributeWrapper(item));
					}
					string namespaceUri = NamespaceUri;
					if (!string.IsNullOrEmpty(namespaceUri) && namespaceUri != ParentNode?.NamespaceUri && string.IsNullOrEmpty(GetPrefixOfNamespace(namespaceUri)))
					{
						bool flag = false;
						foreach (IXmlNode attribute in _attributes)
						{
							if (attribute.LocalName == "xmlns" && string.IsNullOrEmpty(attribute.NamespaceUri) && attribute.Value == namespaceUri)
							{
								flag = true;
							}
						}
						if (!flag)
						{
							_attributes.Insert(0, new XAttributeWrapper(new XAttribute("xmlns", namespaceUri)));
						}
					}
				}
				return _attributes;
			}
		}

		public override string Value
		{
			get
			{
				return Element.Value;
			}
			set
			{
				Element.Value = value;
			}
		}

		public override string LocalName => Element.Name.LocalName;

		public override string NamespaceUri => Element.Name.NamespaceName;

		public bool IsEmpty => Element.IsEmpty;

		public XElementWrapper(XElement element)
			: base(element)
		{
		}

		public void SetAttributeNode(IXmlNode attribute)
		{
			XObjectWrapper xObjectWrapper = (XObjectWrapper)attribute;
			Element.Add(xObjectWrapper.WrappedNode);
			_attributes = null;
		}

		public override IXmlNode AppendChild(IXmlNode newChild)
		{
			IXmlNode result = base.AppendChild(newChild);
			_attributes = null;
			return result;
		}

		public string GetPrefixOfNamespace(string namespaceUri)
		{
			return Element.GetPrefixOfNamespace(namespaceUri);
		}
	}
	[Preserve]
	public class XmlNodeConverter : JsonConverter
	{
		private const string TextName = "#text";

		private const string CommentName = "#comment";

		private const string CDataName = "#cdata-section";

		private const string WhitespaceName = "#whitespace";

		private const string SignificantWhitespaceName = "#significant-whitespace";

		private const string DeclarationName = "?xml";

		private const string JsonNamespaceUri = "http://james.newtonking.com/projects/json";

		public string DeserializeRootElementName { get; set; }

		public bool WriteArrayAttribute { get; set; }

		public bool OmitRootObject { get; set; }

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			IXmlNode node = WrapXml(value);
			XmlNamespaceManager manager = new XmlNamespaceManager(new NameTable());
			PushParentNamespaces(node, manager);
			if (!OmitRootObject)
			{
				writer.WriteStartObject();
			}
			SerializeNode(writer, node, manager, !OmitRootObject);
			if (!OmitRootObject)
			{
				writer.WriteEndObject();
			}
		}

		private IXmlNode WrapXml(object value)
		{
			if (value is XObject)
			{
				return XContainerWrapper.WrapNode((XObject)value);
			}
			if (value is XmlNode)
			{
				return XmlNodeWrapper.WrapNode((XmlNode)value);
			}
			throw new ArgumentException("Value must be an XML object.", "value");
		}

		private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager)
		{
			List<IXmlNode> list = null;
			IXmlNode xmlNode = node;
			while ((xmlNode = xmlNode.ParentNode) != null)
			{
				if (xmlNode.NodeType == XmlNodeType.Element)
				{
					if (list == null)
					{
						list = new List<IXmlNode>();
					}
					list.Add(xmlNode);
				}
			}
			if (list == null)
			{
				return;
			}
			list.Reverse();
			foreach (IXmlNode item in list)
			{
				manager.PushScope();
				foreach (IXmlNode attribute in item.Attributes)
				{
					if (attribute.NamespaceUri == "http://www.w3.org/2000/xmlns/" && attribute.LocalName != "xmlns")
					{
						manager.AddNamespace(attribute.LocalName, attribute.Value);
					}
				}
			}
		}

		private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager)
		{
			string text = ((node.NamespaceUri == null || (node.LocalName == "xmlns" && node.NamespaceUri == "http://www.w3.org/2000/xmlns/")) ? null : manager.LookupPrefix(node.NamespaceUri));
			if (!string.IsNullOrEmpty(text))
			{
				return text + ":" + XmlConvert.DecodeName(node.LocalName);
			}
			return XmlConvert.DecodeName(node.LocalName);
		}

		private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager)
		{
			switch (node.NodeType)
			{
			case XmlNodeType.Attribute:
				if (node.NamespaceUri == "http://james.newtonking.com/projects/json")
				{
					return "$" + node.LocalName;
				}
				return "@" + ResolveFullName(node, manager);
			case XmlNodeType.CDATA:
				return "#cdata-section";
			case XmlNodeType.Comment:
				return "#comment";
			case XmlNodeType.Element:
				if (node.NamespaceUri == "http://james.newtonking.com/projects/json")
				{
					return "$" + node.LocalName;
				}
				return ResolveFullName(node, manager);
			case XmlNodeType.ProcessingInstruction:
				return "?" + ResolveFullName(node, manager);
			case XmlNodeType.DocumentType:
				return "!" + ResolveFullName(node, manager);
			case XmlNodeType.XmlDeclaration:
				return "?xml";
			case XmlNodeType.SignificantWhitespace:
				return "#significant-whitespace";
			case XmlNodeType.Text:
				return "#text";
			case XmlNodeType.Whitespace:
				return "#whitespace";
			default:
				throw new JsonSerializationException("Unexpected XmlNodeType when getting node name: " + node.NodeType);
			}
		}

		private bool IsArray(IXmlNode node)
		{
			if (node.Attributes != null)
			{
				foreach (IXmlNode attribute in node.Attributes)
				{
					if (attribute.LocalName == "Array" && attribute.NamespaceUri == "http://james.newtonking.com/projects/json")
					{
						return XmlConvert.ToBoolean(attribute.Value);
					}
				}
			}
			return false;
		}

		private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName)
		{
			Dictionary<string, List<IXmlNode>> dictionary = new Dictionary<string, List<IXmlNode>>();
			for (int i = 0; i < node.ChildNodes.Count; i++)
			{
				IXmlNode xmlNode = node.ChildNodes[i];
				string propertyName = GetPropertyName(xmlNode, manager);
				if (!dictionary.TryGetValue(propertyName, out var value))
				{
					value = new List<IXmlNode>();
					dictionary.Add(propertyName, value);
				}
				value.Add(xmlNode);
			}
			foreach (KeyValuePair<string, List<IXmlNode>> item in dictionary)
			{
				List<IXmlNode> value2 = item.Value;
				if (value2.Count == 1 && !IsArray(value2[0]))
				{
					SerializeNode(writer, value2[0], manager, writePropertyName);
					continue;
				}
				string key = item.Key;
				if (writePropertyName)
				{
					writer.WritePropertyName(key);
				}
				writer.WriteStartArray();
				for (int j = 0; j < value2.Count; j++)
				{
					SerializeNode(writer, value2[j], manager, writePropertyName: false);
				}
				writer.WriteEndArray();
			}
		}

		private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName)
		{
			switch (node.NodeType)
			{
			case XmlNodeType.Document:
			case XmlNodeType.DocumentFragment:
				SerializeGroupedNodes(writer, node, manager, writePropertyName);
				break;
			case XmlNodeType.Element:
				if (IsArray(node) && AllSameName(node) && node.ChildNodes.Count > 0)
				{
					SerializeGroupedNodes(writer, node, manager, writePropertyName: false);
					break;
				}
				manager.PushScope();
				foreach (IXmlNode attribute in node.Attributes)
				{
					if (attribute.NamespaceUri == "http://www.w3.org/2000/xmlns/")
					{
						string prefix = ((attribute.LocalName != "xmlns") ? XmlConvert.DecodeName(attribute.LocalName) : string.Empty);
						string value = attribute.Value;
						manager.AddNamespace(prefix, value);
					}
				}
				if (writePropertyName)
				{
					writer.WritePropertyName(GetPropertyName(node, manager));
				}
				if (!ValueAttributes(node.Attributes) && node.ChildNodes.Count == 1 && node.ChildNodes[0].NodeType == XmlNodeType.Text)
				{
					writer.WriteValue(node.ChildNodes[0].Value);
				}
				else if (node.ChildNodes.Count == 0 && CollectionUtils.IsNullOrEmpty(node.Attributes))
				{
					if (((IXmlElement)node).IsEmpty)
					{
						writer.WriteNull();
					}
					else
					{
						writer.WriteValue(string.Empty);
					}
				}
				else
				{
					writer.WriteStartObject();
					for (int i = 0; i < node.Attributes.Count; i++)
					{
						SerializeNode(writer, node.Attributes[i], manager, writePropertyName: true);
					}
					SerializeGroupedNodes(writer, node, manager, writePropertyName: true);
					writer.WriteEndObject();
				}
				manager.PopScope();
				break;
			case XmlNodeType.Comment:
				if (writePropertyName)
				{
					writer.WriteComment(node.Value);
				}
				break;
			case XmlNodeType.Attribute:
			case XmlNodeType.Text:
			case XmlNodeType.CDATA:
			case XmlNodeType.ProcessingInstruction:
			case XmlNodeType.Whitespace:
			case XmlNodeType.SignificantWhitespace:
				if ((!(node.NamespaceUri == "http://www.w3.org/2000/xmlns/") || !(node.Value == "http://james.newtonking.com/projects/json")) && (!(node.NamespaceUri == "http://james.newtonking.com/projects/json") || !(node.LocalName == "Array")))
				{
					if (writePropertyName)
					{
						writer.WritePropertyName(GetPropertyName(node, manager));
					}
					writer.WriteValue(node.Value);
				}
				break;
			case XmlNodeType.XmlDeclaration:
			{
				IXmlDeclaration xmlDeclaration = (IXmlDeclaration)node;
				writer.WritePropertyName(GetPropertyName(node, manager));
				writer.WriteStartObject();
				if (!string.IsNullOrEmpty(xmlDeclaration.Version))
				{
					writer.WritePropertyName("@version");
					writer.WriteValue(xmlDeclaration.Version);
				}
				if (!string.IsNullOrEmpty(xmlDeclaration.Encoding))
				{
					writer.WritePropertyName("@encoding");
					writer.WriteValue(xmlDeclaration.Encoding);
				}
				if (!string.IsNullOrEmpty(xmlDeclaration.Standalone))
				{
					writer.WritePropertyName("@standalone");
					writer.WriteValue(xmlDeclaration.Standalone);
				}
				writer.WriteEndObject();
				break;
			}
			case XmlNodeType.DocumentType:
			{
				IXmlDocumentType xmlDocumentType = (IXmlDocumentType)node;
				writer.WritePropertyName(GetPropertyName(node, manager));
				writer.WriteStartObject();
				if (!string.IsNullOrEmpty(xmlDocumentType.Name))
				{
					writer.WritePropertyName("@name");
					writer.WriteValue(xmlDocumentType.Name);
				}
				if (!string.IsNullOrEmpty(xmlDocumentType.Public))
				{
					writer.WritePropertyName("@public");
					writer.WriteValue(xmlDocumentType.Public);
				}
				if (!string.IsNullOrEmpty(xmlDocumentType.System))
				{
					writer.WritePropertyName("@system");
					writer.WriteValue(xmlDocumentType.System);
				}
				if (!string.IsNullOrEmpty(xmlDocumentType.InternalSubset))
				{
					writer.WritePropertyName("@internalSubset");
					writer.WriteValue(xmlDocumentType.InternalSubset);
				}
				writer.WriteEndObject();
				break;
			}
			default:
				throw new JsonSerializationException("Unexpected XmlNodeType when serializing nodes: " + node.NodeType);
			}
		}

		private static bool AllSameName(IXmlNode node)
		{
			foreach (IXmlNode childNode in node.ChildNodes)
			{
				if (childNode.LocalName != node.LocalName)
				{
					return false;
				}
			}
			return true;
		}

		public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
		{
			if (reader.TokenType == JsonToken.Null)
			{
				return null;
			}
			XmlNamespaceManager manager = new XmlNamespaceManager(new NameTable());
			IXmlDocument xmlDocument = null;
			IXmlNode xmlNode = null;
			if (typeof(XObject).IsAssignableFrom(objectType))
			{
				if ((object)objectType != typeof(XDocument) && (object)objectType != typeof(XElement))
				{
					throw new JsonSerializationException("XmlNodeConverter only supports deserializing XDocument or XElement.");
				}
				xmlDocument = new XDocumentWrapper(new XDocument());
				xmlNode = xmlDocument;
			}
			if (typeof(XmlNode).IsAssignableFrom(objectType))
			{
				if ((object)objectType != typeof(XmlDocument))
				{
					throw new JsonSerializationException("XmlNodeConverter only supports deserializing XmlDocuments");
				}
				xmlDocument = new XmlDocumentWrapper(new XmlDocument
				{
					XmlResolver = null
				});
				xmlNode = xmlDocument;
			}
			if (xmlDocument == null || xmlNode == null)
			{
				throw new JsonSerializationException("Unexpected type when converting XML: " + objectType);
			}
			if (reader.TokenType != JsonToken.StartObject)
			{
				throw new JsonSerializationException("XmlNodeConverter can only convert JSON that begins with an object.");
			}
			if (!string.IsNullOrEmpty(DeserializeRootElementName))
			{
				ReadElement(reader, xmlDocument, xmlNode, DeserializeRootElementName, manager);
			}
			else
			{
				reader.Read();
				DeserializeNode(reader, xmlDocument, manager, xmlNode);
			}
			if ((object)objectType == typeof(XElement))
			{
				XElement obj = (XElement)xmlDocument.DocumentElement.WrappedNode;
				obj.Remove();
				return obj;
			}
			return xmlDocument.WrappedNode;
		}

		private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode)
		{
			switch (propertyName)
			{
			case "#text":
				currentNode.AppendChild(document.CreateTextNode(reader.Value.ToString()));
				return;
			case "#cdata-section":
				currentNode.AppendChild(document.CreateCDataSection(reader.Value.ToString()));
				return;
			case "#whitespace":
				currentNode.AppendChild(document.CreateWhitespace(reader.Value.ToString()));
				return;
			case "#significant-whitespace":
				currentNode.AppendChild(document.CreateSignificantWhitespace(reader.Value.ToString()));
				return;
			}
			if (!string.IsNullOrEmpty(propertyName) && propertyName[0] == '?')
			{
				CreateInstruction(reader, document, currentNode, propertyName);
			}
			else if (string.Equals(propertyName, "!DOCTYPE", StringComparison.OrdinalIgnoreCase))
			{
				CreateDocumentType(reader, document, currentNode);
			}
			else if (reader.TokenType == JsonToken.StartArray)
			{
				ReadArrayElements(reader, document, propertyName, currentNode, manager);
			}
			else
			{
				ReadElement(reader, document, currentNode, propertyName, manager);
			}
		}

		private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager)
		{
			if (string.IsNullOrEmpty(propertyName))
			{
				throw JsonSerializationException.Create(reader, "XmlNodeConverter cannot convert JSON with an empty property name to XML.");
			}
			Dictionary<string, string> attributeNameValues = ReadAttributeElements(reader, manager);
			string prefix = MiscellaneousUtils.GetPrefix(propertyName);
			if (StringUtils.StartsWith(propertyName, '@'))
			{
				string text = propertyName.Substring(1);
				string prefix2 = MiscellaneousUtils.GetPrefix(text);
				AddAttribute(reader, document, currentNode, text, manager, prefix2);
				return;
			}
			if (StringUtils.StartsWith(propertyName, '$'))
			{
				switch (propertyName)
				{
				case "$values":
					propertyName = propertyName.Substring(1);
					prefix = manager.LookupPrefix("http://james.newtonking.com/projects/json");
					CreateElement(reader, document, currentNode, propertyName, manager, prefix, attributeNameValues);
					return;
				case "$id":
				case "$ref":
				case "$type":
				case "$value":
				{
					string attributeName = propertyName.Substring(1);
					string attributePrefix = manager.LookupPrefix("http://james.newtonking.com/projects/json");
					AddAttribute(reader, document, currentNode, attributeName, manager, attributePrefix);
					return;
				}
				}
			}
			CreateElement(reader, document, currentNode, propertyName, manager, prefix, attributeNameValues);
		}

		private void CreateElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string elementName, XmlNamespaceManager manager, string elementPrefix, Dictionary<string, string> attributeNameValues)
		{
			IXmlElement xmlElement = CreateElement(elementName, document, elementPrefix, manager);
			currentNode.AppendChild(xmlElement);
			foreach (KeyValuePair<string, string> attributeNameValue in attributeNameValues)
			{
				string text = XmlConvert.EncodeName(attributeNameValue.Key);
				string prefix = MiscellaneousUtils.GetPrefix(attributeNameValue.Key);
				IXmlNode attributeNode = ((!string.IsNullOrEmpty(prefix)) ? document.CreateAttribute(text, manager.LookupNamespace(prefix) ?? string.Empty, attributeNameValue.Value) : document.CreateAttribute(text, attributeNameValue.Value));
				xmlElement.SetAttributeNode(attributeNode);
			}
			if (reader.TokenType == JsonToken.String || reader.TokenType == JsonToken.Integer || reader.TokenType == JsonToken.Float || reader.TokenType == JsonToken.Boolean || reader.TokenType == JsonToken.Date)
			{
				string text2 = ConvertTokenToXmlValue(reader);
				if (text2 != null)
				{
					xmlElement.AppendChild(document.CreateTextNode(text2));
				}
			}
			else if (reader.TokenType != JsonToken.Null)
			{
				if (reader.TokenType != JsonToken.EndObject)
				{
					manager.PushScope();
					DeserializeNode(reader, document, manager, xmlElement);
					manager.PopScope();
				}
				manager.RemoveNamespace(string.Empty, manager.DefaultNamespace);
			}
		}

		private static void AddAttribute(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string attributeName, XmlNamespaceManager manager, string attributePrefix)
		{
			string text = XmlConvert.EncodeName(attributeName);
			string value = reader.Value.ToString();
			IXmlNode attributeNode = ((!string.IsNullOrEmpty(attributePrefix)) ? document.CreateAttribute(text, manager.LookupNamespace(attributePrefix), value) : document.CreateAttribute(text, value));
			((IXmlElement)currentNode).SetAttributeNode(attributeNode);
		}

		private string ConvertTokenToXmlValue(JsonReader reader)
		{
			if (reader.TokenType == JsonToken.String)
			{
				if (reader.Value == null)
				{
					return null;
				}
				return reader.Value.ToString();
			}
			if (reader.TokenType == JsonToken.Integer)
			{
				return XmlConvert.ToString(Convert.ToInt64(reader.Value, CultureInfo.InvariantCulture));
			}
			if (reader.TokenType == JsonToken.Float)
			{
				if (reader.Value is decimal)
				{
					return XmlConvert.ToString((decimal)reader.Value);
				}
				if (reader.Value is float)
				{
					return XmlConvert.ToString((float)reader.Value);
				}
				return XmlConvert.ToString(Convert.ToDouble(reader.Value, CultureInfo.InvariantCulture));
			}
			if (reader.TokenType == JsonToken.Boolean)
			{
				return XmlConvert.ToString(Convert.ToBoolean(reader.Value, CultureInfo.InvariantCulture));
			}
			if (reader.TokenType == JsonToken.Date)
			{
				if (reader.Value is DateTimeOffset)
				{
					return XmlConvert.ToString((DateTimeOffset)reader.Value);
				}
				DateTime dateTime = Convert.ToDateTime(reader.Value, CultureInfo.InvariantCulture);
				return XmlConvert.ToString(dateTime, DateTimeUtils.ToSerializationMode(dateTime.Kind));
			}
			if (reader.TokenType == JsonToken.Null)
			{
				return null;
			}
			throw JsonSerializationException.Create(reader, "Cannot get an XML string value from token type '{0}'.".FormatWith(CultureInfo.InvariantCulture, reader.TokenType));
		}

		private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager)
		{
			string prefix = MiscellaneousUtils.GetPrefix(propertyName);
			IXmlElement xmlElement = CreateElement(propertyName, document, prefix, manager);
			currentNode.AppendChild(xmlElement);
			int num = 0;
			while (reader.Read() && reader.TokenType != JsonToken.EndArray)
			{
				DeserializeValue(reader, document, manager, propertyName, xmlElement);
				num++;
			}
			if (WriteArrayAttribute)
			{
				AddJsonArrayAttribute(xmlElement, document);
			}
			if (num != 1 || !WriteArrayAttribute)
			{
				return;
			}
			foreach (IXmlNode childNode in xmlElement.ChildNodes)
			{
				if (childNode is IXmlElement xmlElement2 && xmlElement2.LocalName == propertyName)
				{
					AddJsonArrayAttribute(xmlElement2, document);
					break;
				}
			}
		}

		private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document)
		{
			element.SetAttributeNode(document.CreateAttribute("json:Array", "http://james.newtonking.com/projects/json", "true"));
			if (element is XElementWrapper && element.GetPrefixOfNamespace("http://james.newtonking.com/projects/json") == null)
			{
				element.SetAttributeNode(document.CreateAttribute("xmlns:json", "http://www.w3.org/2000/xmlns/", "http://james.newtonking.com/projects/json"));
			}
		}

		private Dictionary<string, string> ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			bool flag = false;
			bool flag2 = false;
			if (reader.TokenType != JsonToken.String && reader.TokenType != JsonToken.Null && reader.TokenType != JsonToken.Boolean && reader.TokenType != JsonToken.Integer && reader.TokenType != JsonToken.Float && reader.TokenType != JsonToken.Date && reader.TokenType != JsonToken.StartConstructor)
			{
				while (!flag && !flag2 && reader.Read())
				{
					switch (reader.TokenType)
					{
					case JsonToken.PropertyName:
					{
						string text = reader.Value.ToString();
						if (!string.IsNullOrEmpty(text))
						{
							switch (text[0])
							{
							case '@':
							{
								text = text.Substring(1);
								reader.Read();
								string value = ConvertTokenToXmlValue(reader);
								dictionary.Add(text, value);
								if (IsNamespaceAttribute(text, out var prefix))
								{
									manager.AddNamespace(prefix, value);
								}
								break;
							}
							case '$':
								switch (text)
								{
								case "$values":
								case "$id":
								case "$ref":
								case "$type":
								case "$value":
								{
									string text2 = manager.LookupPrefix("http://james.newtonking.com/projects/json");
									if (text2 == null)
									{
										int? num = null;
										while (manager.LookupNamespace("json" + num) != null)
										{
											num = num.GetValueOrDefault() + 1;
										}
										text2 = "json" + num;
										dictionary.Add("xmlns:" + text2, "http://james.newtonking.com/projects/json");
										manager.AddNamespace(text2, "http://james.newtonking.com/projects/json");
									}
									if (text == "$values")
									{
										flag = true;
										break;
									}
									text = text.Substring(1);
									reader.Read();
									if (!JsonTokenUtils.IsPrimitiveToken(reader.TokenType))
									{
										throw JsonSerializationException.Create(reader, "Unexpected JsonToken: " + reader.TokenType);
									}
									string value = ((reader.Value != null) ? reader.Value.ToString() : null);
									dictionary.Add(text2 + ":" + text, value);
									break;
								}
								default:
									flag = true;
									break;
								}
								break;
							default:
								flag = true;
								break;
							}
						}
						else
						{
							flag = true;
						}
						break;
					}
					case JsonToken.EndObject:
						flag2 = true;
						break;
					case JsonToken.Comment:
						flag2 = true;
						break;
					default:
						throw JsonSerializationException.Create(reader, "Unexpected JsonToken: " + reader.TokenType);
					}
				}
			}
			return dictionary;
		}

		private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName)
		{
			if (propertyName == "?xml")
			{
				string version = null;
				string encoding = null;
				string standalone = null;
				while (reader.Read() && reader.TokenType != JsonToken.EndObject)
				{
					switch (reader.Value.ToString())
					{
					case "@version":
						reader.Read();
						version = reader.Value.ToString();
						break;
					case "@encoding":
						reader.Read();
						encoding = reader.Value.ToString();
						break;
					case "@standalone":
						reader.Read();
						standalone = reader.Value.ToString();
						break;
					default:
						throw JsonSerializationException.Create(reader, "Unexpected property name encountered while deserializing XmlDeclaration: " + reader.Value);
					}
				}
				IXmlNode newChild = document.CreateXmlDeclaration(version, encoding, standalone);
				currentNode.AppendChild(newChild);
			}
			else
			{
				IXmlNode newChild2 = document.CreateProcessingInstruction(propertyName.Substring(1), reader.Value.ToString());
				currentNode.AppendChild(newChild2);
			}
		}

		private void CreateDocumentType(JsonReader reader, IXmlDocument document, IXmlNode currentNode)
		{
			string name = null;
			string publicId = null;
			string systemId = null;
			string internalSubset = null;
			while (reader.Read() && reader.TokenType != JsonToken.EndObject)
			{
				switch (reader.Value.ToString())
				{
				case "@name":
					reader.Read();
					name = reader.Value.ToString();
					break;
				case "@public":
					reader.Read();
					publicId = reader.Value.ToString();
					break;
				case "@system":
					reader.Read();
					systemId = reader.Value.ToString();
					break;
				case "@internalSubset":
					reader.Read();
					internalSubset = reader.Value.ToString();
					break;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected property name encountered while deserializing XmlDeclaration: " + reader.Value);
				}
			}
			IXmlNode newChild = document.CreateXmlDocumentType(name, publicId, systemId, internalSubset);
			currentNode.AppendChild(newChild);
		}

		private IXmlElement CreateElement(string elementName, IXmlDocument document, string elementPrefix, XmlNamespaceManager manager)
		{
			string text = XmlConvert.EncodeName(elementName);
			string text2 = (string.IsNullOrEmpty(elementPrefix) ? manager.DefaultNamespace : manager.LookupNamespace(elementPrefix));
			if (string.IsNullOrEmpty(text2))
			{
				return document.CreateElement(text);
			}
			return document.CreateElement(text, text2);
		}

		private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode)
		{
			do
			{
				switch (reader.TokenType)
				{
				case JsonToken.PropertyName:
				{
					if (currentNode.NodeType == XmlNodeType.Document && document.DocumentElement != null)
					{
						throw JsonSerializationException.Create(reader, "JSON root object has multiple properties. The root object must have a single property in order to create a valid XML document. Consider specifing a DeserializeRootElementName.");
					}
					string text = reader.Value.ToString();
					reader.Read();
					if (reader.TokenType == JsonToken.StartArray)
					{
						int num = 0;
						while (reader.Read() && reader.TokenType != JsonToken.EndArray)
						{
							DeserializeValue(reader, document, manager, text, currentNode);
							num++;
						}
						if (num != 1 || !WriteArrayAttribute)
						{
							break;
						}
						foreach (IXmlNode childNode in currentNode.ChildNodes)
						{
							if (childNode is IXmlElement xmlElement && xmlElement.LocalName == text)
							{
								AddJsonArrayAttribute(xmlElement, document);
								break;
							}
						}
					}
					else
					{
						DeserializeValue(reader, document, manager, text, currentNode);
					}
					break;
				}
				case JsonToken.StartConstructor:
				{
					string propertyName = reader.Value.ToString();
					while (reader.Read() && reader.TokenType != JsonToken.EndConstructor)
					{
						DeserializeValue(reader, document, manager, propertyName, currentNode);
					}
					break;
				}
				case JsonToken.Comment:
					currentNode.AppendChild(document.CreateComment((string)reader.Value));
					break;
				case JsonToken.EndObject:
				case JsonToken.EndArray:
					return;
				default:
					throw JsonSerializationException.Create(reader, "Unexpected JsonToken when deserializing node: " + reader.TokenType);
				}
			}
			while (reader.TokenType == JsonToken.PropertyName || reader.Read());
		}

		private bool IsNamespaceAttribute(string attributeName, out string prefix)
		{
			if (attributeName.StartsWith("xmlns", StringComparison.Ordinal))
			{
				if (attributeName.Length == 5)
				{
					prefix = string.Empty;
					return true;
				}
				if (attributeName[5] == ':')
				{
					prefix = attributeName.Substring(6, attributeName.Length - 6);
					return true;
				}
			}
			prefix = null;
			return false;
		}

		private bool ValueAttributes(List<IXmlNode> c)
		{
			foreach (IXmlNode item in c)
			{
				if (item.NamespaceUri != "http://james.newtonking.com/projects/json")
				{
					return true;
				}
			}
			return false;
		}

		public override bool CanConvert(Type valueType)
		{
			if (typeof(XObject).IsAssignableFrom(valueType))
			{
				return true;
			}
			if (typeof(XmlNode).IsAssignableFrom(valueType))
			{
				return true;
			}
			return false;
		}
	}
}
namespace Newtonsoft.Json.Bson
{
	[Preserve]
	internal enum BsonBinaryType : byte
	{
		Binary = 0,
		Function = 1,
		[Obsolete("This type has been deprecated in the BSON specification. Use Binary instead.")]
		BinaryOld = 2,
		[Obsolete("This type has been deprecated in the BSON specification. Use Uuid instead.")]
		UuidOld = 3,
		Uuid = 4,
		Md5 = 5,
		UserDefined = 128
	}
	[Preserve]
	internal class BsonBinaryWriter
	{
		private static readonly Encoding Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false);

		private readonly BinaryWriter _writer;

		private byte[] _largeByteBuffer;

		public DateTimeKind DateTimeKindHandling { get; set; }

		public BsonBinaryWriter(BinaryWriter writer)
		{
			DateTimeKindHandling = DateTimeKind.Utc;
			_writer = writer;
		}

		public void Flush()
		{
			_writer.Flush();
		}

		public void Close()
		{
			_writer.Close();
		}

		public void WriteToken(BsonToken t)
		{
			CalculateSize(t);
			WriteTokenInternal(t);
		}

		private void WriteTokenInternal(BsonToken t)
		{
			switch (t.Type)
			{
			case BsonType.Object:
			{
				BsonObject bsonObject = (BsonObject)t;
				_writer.Write(bsonObject.CalculatedSize);
				foreach (BsonProperty item in bsonObject)
				{
					_writer.Write((sbyte)item.Value.Type);
					WriteString((string)item.Name.Value, item.Name.ByteCount, null);
					WriteTokenInternal(item.Value);
				}
				_writer.Write((byte)0);
				break;
			}
			case BsonType.Array:
			{
				BsonArray bsonArray = (BsonArray)t;
				_writer.Write(bsonArray.CalculatedSize);
				ulong num2 = 0uL;
				foreach (BsonToken item2 in bsonArray)
				{
					_writer.Write((sbyte)item2.Type);
					WriteString(num2.ToString(CultureInfo.InvariantCulture), MathUtils.IntLength(num2), null);
					WriteTokenInternal(item2);
					num2++;
				}
				_writer.Write((byte)0);
				break;
			}
			case BsonType.Integer:
			{
				BsonValue bsonValue2 = (BsonValue)t;
				_writer.Write(Convert.ToInt32(bsonValue2.Value, CultureInfo.InvariantCulture));
				break;
			}
			case BsonType.Long:
			{
				BsonValue bsonValue3 = (BsonValue)t;
				_writer.Write(Convert.ToInt64(bsonValue3.Value, CultureInfo.InvariantCulture));
				break;
			}
			case BsonType.Number:
			{
				BsonValue bsonValue4 = (BsonValue)t;
				_writer.Write(Convert.ToDouble(bsonValue4.Value, CultureInfo.InvariantCulture));
				break;
			}
			case BsonType.String:
			{
				BsonString bsonString = (BsonString)t;
				WriteString((string)bsonString.Value, bsonString.ByteCount, bsonString.CalculatedSize - 4);
				break;
			}
			case BsonType.Boolean:
			{
				BsonValue bsonValue5 = (BsonValue)t;
				_writer.Write((bool)bsonValue5.Value);
				break;
			}
			case BsonType.Date:
			{
				BsonValue bsonValue = (BsonValue)t;
				long num = 0L;
				if (bsonValue.Value is DateTime)
				{
					DateTime dateTime = (DateTime)bsonValue.Value;
					if (DateTimeKindHandling == DateTimeKind.Utc)
					{
						dateTime = dateTime.ToUniversalTime();
					}
					else if (DateTimeKindHandling == DateTimeKind.Local)
					{
						dateTime = dateTime.ToLocalTime();
					}
					num = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTime, convertToUtc: false);
				}
				else
				{
					DateTimeOffset dateTimeOffset = (DateTimeOffset)bsonValue.Value;
					num = DateTimeUtils.ConvertDateTimeToJavaScriptTicks(dateTimeOffset.UtcDateTime, dateTimeOffset.Offset);
				}
				_writer.Write(num);
				break;
			}
			case BsonType.Binary:
			{
				BsonBinary bsonBinary = (BsonBinary)t;
				byte[] array = (byte[])bsonBinary.Value;
				_writer.Write(array.Length);
				_writer.Write((byte)bsonBinary.BinaryType);
				_writer.Write(array);
				break;
			}
			case BsonType.Oid:
			{
				byte[] buffer = (byte[])((BsonValue)t).Value;
				_writer.Write(buffer);
				break;
			}
			case BsonType.Regex:
			{
				BsonRegex bsonRegex = (BsonRegex)t;
				WriteString((string)bsonRegex.Pattern.Value, bsonRegex.Pattern.ByteCount, null);
				WriteString((string)bsonRegex.Options.Value, bsonRegex.Options.ByteCount, null);
				break;
			}
			default:
				throw new ArgumentOutOfRangeException("t", "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture, t.Type));
			case BsonType.Undefined:
			case BsonType.Null:
				break;
			}
		}

		private void WriteString(string s, int byteCount, int? calculatedlengthPrefix)
		{
			if (calculatedlengthPrefix.HasValue)
			{
				_writer.Write(calculatedlengthPrefix.GetValueOrDefault());
			}
			WriteUtf8Bytes(s, byteCount);
			_writer.Write((byte)0);
		}

		public void WriteUtf8Bytes(string s, int byteCount)
		{
			if (s != null)
			{
				if (_largeByteBuffer == null)
				{
					_largeByteBuffer = new byte[256];
				}
				if (byteCount <= 256)
				{
					Encoding.GetBytes(s, 0, s.Length, _largeByteBuffer, 0);
					_writer.Write(_largeByteBuffer, 0, byteCount);
				}
				else
				{
					byte[] bytes = Encoding.GetBytes(s);
					_writer.Write(bytes);
				}
			}
		}

		private int CalculateSize(int stringByteCount)
		{
			return stringByteCount + 1;
		}

		private int CalculateSizeWithLength(int stringByteCount, bool includeSize)
		{
			return ((!includeSize) ? 1 : 5) + stringByteCount;
		}

		private int CalculateSize(BsonToken t)
		{
			switch (t.Type)
			{
			case BsonType.Object:
			{
				BsonObject bsonObject = (BsonObject)t;
				int num4 = 4;
				foreach (BsonProperty item in bsonObject)
				{
					int num5 = 1;
					num5 += CalculateSize(item.Name);
					num5 += CalculateSize(item.Value);
					num4 += num5;
				}
				return bsonObject.CalculatedSize = num4 + 1;
			}
			case BsonType.Array:
			{
				BsonArray bsonArray = (BsonArray)t;
				int num2 = 4;
				ulong num3 = 0uL;
				foreach (BsonToken item2 in bsonArray)
				{
					num2++;
					num2 += CalculateSize(MathUtils.IntLength(num3));
					num2 += CalculateSize(item2);
					num3++;
				}
				num2++;
				bsonArray.CalculatedSize = num2;
				return bsonArray.CalculatedSize;
			}
			case BsonType.Integer:
				return 4;
			case BsonType.Long:
				return 8;
			case BsonType.Number:
				return 8;
			case BsonType.String:
			{
				BsonString bsonString = (BsonString)t;
				string text = (string)bsonString.Value;
				bsonString.ByteCount = ((text != null) ? Encoding.GetByteCount(text) : 0);
				bsonString.CalculatedSize = CalculateSizeWithLength(bsonString.ByteCount, bsonString.IncludeLength);
				return bsonString.CalculatedSize;
			}
			case BsonType.Boolean:
				return 1;
			case BsonType.Undefined:
			case BsonType.Null:
				return 0;
			case BsonType.Date:
				return 8;
			case BsonType.Binary:
			{
				BsonBinary obj = (BsonBinary)t;
				byte[] array = (byte[])obj.Value;
				obj.CalculatedSize = 5 + array.Length;
				return obj.CalculatedSize;
			}
			case BsonType.Oid:
				return 12;
			case BsonType.Regex:
			{
				BsonRegex bsonRegex = (BsonRegex)t;
				int num = 0;
				num += CalculateSize(bsonRegex.Pattern);
				num += CalculateSize(bsonRegex.Options);
				bsonRegex.CalculatedSize = num;
				return bsonRegex.CalculatedSize;
			}
			default:
				throw new ArgumentOutOfRangeException("t", "Unexpected token when writing BSON: {0}".FormatWith(CultureInfo.InvariantCulture, t.Type));
			}
		}
	}
	[Preserve]
	public class BsonReader : JsonReader
	{
		private enum BsonReaderState
		{
			Normal,
			ReferenceStart,
			ReferenceRef,
			ReferenceId,
			CodeWScopeStart,
			CodeWScopeCode,
			CodeWScopeScope,
			CodeWScopeScopeObject,
			CodeWScopeScopeEnd
		}

		private class ContainerContext
		{
			public readonly BsonType Type;

			public int Length;

			public int Position;

			public ContainerContext(BsonType type)
			{
				Type = type;
			}
		}

		private const int MaxCharBytesSize = 128;

		private static readonly byte[] SeqRange1 = new byte[2] { 0, 127 };

		private static readonly byte[] SeqRange2 = new byte[2] { 194, 223 };

		private static readonly byte[] SeqRange3 = new byte[2] { 224, 239 };

		private static readonly byte[] SeqRange4 = new byte[2] { 240, 244 };

		private readonly BinaryReader _reader;

		private readonly List<ContainerContext> _stack;

		private byte[] _byteBuffer;

		private char[] _charBuffer;

		private BsonType _currentElementType;

		private BsonReaderState _bsonReaderState;

		private ContainerContext _currentContext;

		private bool _readRootValueAsArray;

		private bool _jsonNet35BinaryCompatibility;

		private DateTimeKind _dateTimeKindHandling;

		[Obsolete("JsonNet35BinaryCompatibility will be removed in a future version of Json.NET.")]
		public bool JsonNet35BinaryCompatibility
		{
			get
			{
				return _jsonNet35BinaryCompatibility;
			}
			set
			{
				_jsonNet35BinaryCompatibility = value;
			}
		}

		public bool ReadRootValueAsArray
		{
			get
			{
				return _readRootValueAsArray;
			}
			set
			{
				_readRootValueAsArray = value;
			}
		}

		public DateTimeKind DateTimeKindHandling
		{
			get
			{
				return _dateTimeKindHandling;
			}
			set
			{
				_dateTimeKindHandling = value;
			}
		}

		public BsonReader(Stream stream)
			: this(stream, readRootValueAsArray: false, DateTimeKind.Local)
		{
		}

		public BsonReader(BinaryReader reader)
			: this(reader, readRootValueAsArray: false, DateTimeKind.Local)
		{
		}

		public BsonReader(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling)
		{
			ValidationUtils.ArgumentNotNull(stream, "stream");
			_reader = new BinaryReader(stream);
			_stack = new List<ContainerContext>();
			_readRootValueAsArray = readRootValueAsArray;
			_dateTimeKindHandling = dateTimeKindHandling;
		}

		public BsonReader(BinaryReader reader, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling)
		{
			ValidationUtils.ArgumentNotNull(reader, "reader");
			_reader = reader;
			_stack = new List<ContainerContext>();
			_readRootValueAsArray = readRootValueAsArray;
			_dateTimeKindHandling = dateTimeKindHandling;
		}

		private string ReadElement()
		{
			_currentElementType = ReadType();
			return ReadString();
		}

		public override bool Read()
		{
			try
			{
				bool flag;
				switch (_bsonReaderState)
				{
				case BsonReaderState.Normal:
					flag = ReadNormal();
					break;
				case BsonReaderState.ReferenceStart:
				case BsonReaderState.ReferenceRef:
				case BsonReaderState.ReferenceId:
					flag = ReadReference();
					break;
				case BsonReaderState.CodeWScopeStart:
				case BsonReaderState.CodeWScopeCode:
				case BsonReaderState.CodeWScopeScope:
				case BsonReaderState.CodeWScopeScopeObject:
				case BsonReaderState.CodeWScopeScopeEnd:
					flag = ReadCodeWScope();
					break;
				default:
					throw JsonReaderException.Create(this, "Unexpected state: {0}".FormatWith(CultureInfo.InvariantCulture, _bsonReaderState));
				}
				if (!flag)
				{
					SetToken(JsonToken.None);
					return false;
				}
				return true;
			}
			catch (EndOfStreamException)
			{
				SetToken(JsonToken.None);
				return false;
			}
		}

		public override void Close()
		{
			base.Close();
			if (base.CloseInput && _reader != null)
			{
				_reader.Close();
			}
		}

		private bool ReadCodeWScope()
		{
			switch (_bsonReaderState)
			{
			case BsonReaderState.CodeWScopeStart:
				SetToken(JsonToken.PropertyName, "$code");
				_bsonReaderState = BsonReaderState.CodeWScopeCode;
				return true;
			case BsonReaderState.CodeWScopeCode:
				ReadInt32();
				SetToken(JsonToken.String, ReadLengthString());
				_bsonReaderState = BsonReaderState.CodeWScopeScope;
				return true;
			case BsonReaderState.CodeWScopeScope:
			{
				if (base.CurrentState == State.PostValue)
				{
					SetToken(JsonToken.PropertyName, "$scope");
					return true;
				}
				SetToken(JsonToken.StartObject);
				_bsonReaderState = BsonReaderState.CodeWScopeScopeObject;
				ContainerContext containerContext = new ContainerContext(BsonType.Object);
				PushContext(containerContext);
				containerContext.Length = ReadInt32();
				return true;
			}
			case BsonReaderState.CodeWScopeScopeObject:
			{
				bool num = ReadNormal();
				if (num && TokenType == JsonToken.EndObject)
				{
					_bsonReaderState = BsonReaderState.CodeWScopeScopeEnd;
				}
				return num;
			}
			case BsonReaderState.CodeWScopeScopeEnd:
				SetToken(JsonToken.EndObject);
				_bsonReaderState = BsonReaderState.Normal;
				return true;
			default:
				throw new ArgumentOutOfRangeException();
			}
		}

		private bool ReadReference()
		{
			switch (base.CurrentState)
			{
			case State.ObjectStart:
				SetToken(JsonToken.PropertyName, "$ref");
				_bsonReaderState = BsonReaderState.ReferenceRef;
				return true;
			case State.Property:
				if (_bsonReaderState == BsonReaderState.ReferenceRef)
				{
					SetToken(JsonToken.String, ReadLengthString());
					return true;
				}
				if (_bsonReaderState == BsonReaderState.ReferenceId)
				{
					SetToken(JsonToken.Bytes, ReadBytes(12));
					return true;
				}
				throw JsonReaderException.Create(this, "Unexpected state when reading BSON reference: " + _bsonReaderState);
			case State.PostValue:
				if (_bsonReaderState == BsonReaderState.ReferenceRef)
				{
					SetToken(JsonToken.PropertyName, "$id");
					_bsonReaderState = BsonReaderState.ReferenceId;
					return true;
				}
				if (_bsonReaderState == BsonReaderState.ReferenceId)
				{
					SetToken(JsonToken.EndObject);
					_bsonReaderState = BsonReaderState.Normal;
					return true;
				}
				throw JsonReaderException.Create(this, "Unexpected state when reading BSON reference: " + _bsonReaderState);
			default:
				throw JsonReaderException.Create(this, "Unexpected state when reading BSON reference: " + base.CurrentState);
			}
		}

		private bool ReadNormal()
		{
			switch (base.CurrentState)
			{
			case State.Start:
			{
				JsonToken token2 = ((!_readRootValueAsArray) ? JsonToken.StartObject : JsonToken.StartArray);
				int type = ((!_readRootValueAsArray) ? 3 : 4);
				SetToken(token2);
				ContainerContext containerContext = new ContainerContext((BsonType)type);
				PushContext(containerContext);
				containerContext.Length = ReadInt32();
				return true;
			}
			case State.Complete:
			case State.Closed:
				return false;
			case State.Property:
				ReadType(_currentElementType);
				return true;
			case State.ObjectStart:
			case State.ArrayStart:
			case State.PostValue:
			{
				ContainerContext currentContext = _currentContext;
				if (currentContext == null)
				{
					return false;
				}
				int num = currentContext.Length - 1;
				if (currentContext.Position < num)
				{
					if (currentContext.Type == BsonType.Array)
					{
						ReadElement();
						ReadType(_currentElementType);
						return true;
					}
					SetToken(JsonToken.PropertyName, ReadElement());
					return true;
				}
				if (currentContext.Position == num)
				{
					if (ReadByte() != 0)
					{
						throw JsonReaderException.Create(this, "Unexpected end of object byte value.");
					}
					PopContext();
					if (_currentContext != null)
					{
						MovePosition(currentContext.Length);
					}
					JsonToken token = ((currentContext.Type == BsonType.Object) ? JsonToken.EndObject : JsonToken.EndArray);
					SetToken(token);
					return true;
				}
				throw JsonReaderException.Create(this, "Read past end of current container context.");
			}
			default:
				throw new ArgumentOutOfRangeException();
			case State.ConstructorStart:
			case State.Constructor:
			case State.Error:
			case State.Finished:
				return false;
			}
		}

		private void PopContext()
		{
			_stack.RemoveAt(_stack.Count - 1);
			if (_stack.Count == 0)
			{
				_currentContext = null;
			}
			else
			{
				_currentContext = _stack[_stack.Count - 1];
			}
		}

		private void PushContext(ContainerContext newContext)
		{
			_stack.Add(newContext);
			_currentContext = newContext;
		}

		private byte ReadByte()
		{
			MovePosition(1);
			return _reader.ReadByte();
		}

		private void ReadType(BsonType type)
		{
			switch (type)
			{
			case BsonType.Number:
			{
				double num = ReadDouble();
				if (_floatParseHandling == FloatParseHandling.Decimal)
				{
					SetToken(JsonToken.Float, Convert.ToDecimal(num, CultureInfo.InvariantCulture));
				}
				else
				{
					SetToken(JsonToken.Float, num);
				}
				break;
			}
			case BsonType.String:
			case BsonType.Symbol:
				SetToken(JsonToken.String, ReadLengthString());
				break;
			case BsonType.Object:
			{
				SetToken(JsonToken.StartObject);
				ContainerContext containerContext2 = new ContainerContext(BsonType.Object);
				PushContext(containerContext2);
				containerContext2.Length = ReadInt32();
				break;
			}
			case BsonType.Array:
			{
				SetToken(JsonToken.StartArray);
				ContainerContext containerContext = new ContainerContext(BsonType.Array);
				PushContext(containerContext);
				containerContext.Length = ReadInt32();
				break;
			}
			case BsonType.Binary:
			{
				BsonBinaryType binaryType;
				byte[] array = ReadBinary(out binaryType);
				object value3 = ((binaryType != BsonBinaryType.Uuid) ? array : ((object)new Guid(array)));
				SetToken(JsonToken.Bytes, value3);
				break;
			}
			case BsonType.Undefined:
				SetToken(JsonToken.Undefined);
				break;
			case BsonType.Oid:
			{
				byte[] value2 = ReadBytes(12);
				SetToken(JsonToken.Bytes, value2);
				break;
			}
			case BsonType.Boolean:
			{
				bool flag = Convert.ToBoolean(ReadByte());
				SetToken(JsonToken.Boolean, flag);
				break;
			}
			case BsonType.Date:
			{
				DateTime dateTime = DateTimeUtils.ConvertJavaScriptTicksToDateTime(ReadInt64());
				SetToken(JsonToken.Date, DateTimeKindHandling switch
				{
					DateTimeKind.Unspecified => DateTime.SpecifyKind(dateTime, DateTimeKind.Unspecified), 
					DateTimeKind.Local => dateTime.ToLocalTime(), 
					_ => dateTime, 
				});
				break;
			}
			case BsonType.Null:
				SetToken(JsonToken.Null);
				break;
			case BsonType.Regex:
			{
				string text = ReadString();
				string text2 = ReadString();
				string value = "/" + text + "/" + text2;
				SetToken(JsonToken.String, value);
				break;
			}
			case BsonType.Reference:
				SetToken(JsonToken.StartObject);
				_bsonReaderState = BsonReaderState.ReferenceStart;
				break;
			case BsonType.Code:
				SetToken(JsonToken.String, ReadLengthString());
				break;
			case BsonType.CodeWScope:
				SetToken(JsonToken.StartObject);
				_bsonReaderState = BsonReaderState.CodeWScopeStart;
				break;
			case BsonType.Integer:
				SetToken(JsonToken.Integer, (long)ReadInt32());
				break;
			case BsonType.TimeStamp:
			case BsonType.Long:
				SetToken(JsonToken.Integer, ReadInt64());
				break;
			default:
				throw new ArgumentOutOfRangeException("type", "Unexpected BsonType value: " + type);
			}
		}

		private byte[] ReadBinary(out BsonBinaryType binaryType)
		{
			int count = ReadInt32();
			binaryType = (BsonBinaryType)ReadByte();
			if (binaryType == BsonBinaryType.BinaryOld && !_jsonNet35BinaryCompatibility)
			{
				count = ReadInt32();
			}
			return ReadBytes(count);
		}

		private string ReadString()
		{
			EnsureBuffers();
			StringBuilder stringBuilder = null;
			int num = 0;
			int num2 = 0;
			while (true)
			{
				int num3 = num2;
				byte b;
				while (num3 < 128 && (b = _reader.ReadByte()) > 0)
				{
					_byteBuffer[num3++] = b;
				}
				int num4 = num3 - num2;
				num += num4;
				if (num3 < 128 && stringBuilder == null)
				{
					int chars = Encoding.UTF8.GetChars(_byteBuffer, 0, num4, _charBuffer, 0);
					MovePosition(num + 1);
					return new string(_charBuffer, 0, chars);
				}
				int lastFullCharStop = GetLastFullCharStop(num3 - 1);
				int chars2 = Encoding.UTF8.GetChars(_byteBuffer, 0, lastFullCharStop + 1, _charBuffer, 0);
				if (stringBuilder == null)
				{
					stringBuilder = new StringBuilder(256);
				}
				stringBuilder.Append(_charBuffer, 0, chars2);
				if (lastFullCharStop < num4 - 1)
				{
					num2 = num4 - lastFullCharStop - 1;
					Array.Copy(_byteBuffer, lastFullCharStop + 1, _byteBuffer, 0, num2);
					continue;
				}
				if (num3 < 128)
				{
					break;
				}
				num2 = 0;
			}
			MovePosition(num + 1);
			return stringBuilder.ToString();
		}

		private string ReadLengthString()
		{
			int num = ReadInt32();
			MovePosition(num);
			string result = GetString(num - 1);
			_reader.ReadByte();
			return result;
		}

		private string GetString(int length)
		{
			if (length == 0)
			{
				return string.Empty;
			}
			EnsureBuffers();
			StringBuilder stringBuilder = null;
			int num = 0;
			int num2 = 0;
			do
			{
				int count = ((length - num > 128 - num2) ? (128 - num2) : (length - num));
				int num3 = _reader.Read(_byteBuffer, num2, count);
				if (num3 == 0)
				{
					throw new EndOfStreamException("Unable to read beyond the end of the stream.");
				}
				num += num3;
				num3 += num2;
				if (num3 == length)
				{
					int chars = Encoding.UTF8.GetChars(_byteBuffer, 0, num3, _charBuffer, 0);
					return new string(_charBuffer, 0, chars);
				}
				int lastFullCharStop = GetLastFullCharStop(num3 - 1);
				if (stringBuilder == null)
				{
					stringBuilder = new StringBuilder(length);
				}
				int chars2 = Encoding.UTF8.GetChars(_byteBuffer, 0, lastFullCharStop + 1, _charBuffer, 0);
				stringBuilder.Append(_charBuffer, 0, chars2);
				if (lastFullCharStop < num3 - 1)
				{
					num2 = num3 - lastFullCharStop - 1;
					Array.Copy(_byteBuffer, lastFullCharStop + 1, _byteBuffer, 0, num2);
				}
				else
				{
					num2 = 0;
				}
			}
			while (num < length);
			return stringBuilder.ToString();
		}

		private int GetLastFullCharStop(int start)
		{
			int num = start;
			int num2 = 0;
			for (; num >= 0; num--)
			{
				num2 = BytesInSequence(_byteBuffer[num]);
				switch (num2)
				{
				case 0:
					continue;
				default:
					num--;
					break;
				case 1:
					break;
				}
				break;
			}
			if (num2 == start - num)
			{
				return start;
			}
			return num;
		}

		private int BytesInSequence(byte b)
		{
			if (b <= SeqRange1[1])
			{
				return 1;
			}
			if (b >= SeqRange2[0] && b <= SeqRange2[1])
			{
				return 2;
			}
			if (b >= SeqRange3[0] && b <= SeqRange3[1])
			{
				return 3;
			}
			if (b >= SeqRange4[0] && b <= SeqRange4[1])
			{
				return 4;
			}
			return 0;
		}

		private void EnsureBuffers()
		{
			if (_byteBuffer == null)
			{
				_byteBuffer = new byte[128];
			}
			if (_charBuffer == null)
			{
				int maxCharCount = Encoding.UTF8.GetMaxCharCount(128);
				_charBuffer = new char[maxCharCount];
			}
		}

		private double ReadDouble()
		{
			MovePosition(8);
			return _reader.ReadDouble();
		}

		private int ReadInt32()
		{
			MovePosition(4);
			return _reader.ReadInt32();
		}

		private long ReadInt64()
		{
			MovePosition(8);
			return _reader.ReadInt64();
		}

		private BsonType ReadType()
		{
			MovePosition(1);
			return (BsonType)_reader.ReadSByte();
		}

		private void MovePosition(int count)
		{
			_currentContext.Position += count;
		}

		private byte[] ReadBytes(int count)
		{
			MovePosition(count);
			return _reader.ReadBytes(count);
		}
	}
	[Preserve]
	internal abstract class BsonToken
	{
		public abstract BsonType Type { get; }

		public BsonToken Parent { get; set; }

		public int CalculatedSize { get; set; }
	}
	[Preserve]
	internal class BsonObject : BsonToken, IEnumerable<BsonProperty>, IEnumerable
	{
		private readonly List<BsonProperty> _children = new List<BsonProperty>();

		public override BsonType Type => BsonType.Object;

		public void Add(string name, BsonToken token)
		{
			_children.Add(new BsonProperty
			{
				Name = new BsonString(name, includeLength: false),
				Value = token
			});
			token.Parent = this;
		}

		public IEnumerator<BsonProperty> GetEnumerator()
		{
			return _children.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	[Preserve]
	internal class BsonArray : BsonToken, IEnumerable<BsonToken>, IEnumerable
	{
		private readonly List<BsonToken> _children = new List<BsonToken>();

		public override BsonType Type => BsonType.Array;

		public void Add(BsonToken token)
		{
			_children.Add(token);
			token.Parent = this;
		}

		public IEnumerator<BsonToken> GetEnumerator()
		{
			return _children.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	[Preserve]
	internal class BsonValue : BsonToken
	{
		private readonly object _value;

		private readonly BsonType _type;

		public object Value => _value;

		public override BsonType Type => _type;

		public BsonValue(object value, BsonType type)
		{
			_value = value;
			_type = type;
		}
	}
	[Preserve]
	internal class BsonString : BsonValue
	{
		public int ByteCount { get; set; }

		public bool IncludeLength { get; set; }

		public BsonString(object value, bool includeLength)
			: base(value, BsonType.String)
		{
			IncludeLength = includeLength;
		}
	}
	[Preserve]
	internal class BsonBinary : BsonValue
	{
		public BsonBinaryType BinaryType { get; set; }

		public BsonBinary(byte[] value, BsonBinaryType binaryType)
			: base(value, BsonType.Binary)
		{
			BinaryType = binaryType;
		}
	}
	[Preserve]
	internal class BsonRegex : BsonToken
	{
		public BsonString Pattern { get; set; }

		public BsonString Options { get; set; }

		public override BsonType Type => BsonType.Regex;

		public BsonRegex(string pattern, string options)
		{
			Pattern = new BsonString(pattern, includeLength: false);
			Options = new BsonString(options, includeLength: false);
		}
	}
	[Preserve]
	internal class BsonProperty
	{
		public BsonString Name { get; set; }

		public BsonToken Value { get; set; }
	}
	[Preserve]
	internal enum BsonType : sbyte
	{
		Number = 1,
		String = 2,
		Object = 3,
		Array = 4,
		Binary = 5,
		Undefined = 6,
		Oid = 7,
		Boolean = 8,
		Date = 9,
		Null = 10,
		Regex = 11,
		Reference = 12,
		Code = 13,
		Symbol = 14,
		CodeWScope = 15,
		Integer = 16,
		TimeStamp = 17,
		Long = 18,
		MinKey = -1,
		MaxKey = sbyte.MaxValue
	}
	[Preserve]
	public class BsonWriter : JsonWriter
	{
		private readonly BsonBinaryWriter _writer;

		private BsonToken _root;

		private BsonToken _parent;

		private string _propertyName;

		public DateTimeKind DateTimeKindHandling
		{
			get
			{
				return _writer.DateTimeKindHandling;
			}
			set
			{
				_writer.DateTimeKindHandling = value;
			}
		}

		public BsonWriter(Stream stream)
		{
			ValidationUtils.ArgumentNotNull(stream, "stream");
			_writer = new BsonBinaryWriter(new BinaryWriter(stream));
		}

		public BsonWriter(BinaryWriter writer)
		{
			ValidationUtils.ArgumentNotNull(writer, "writer");
			_writer = new BsonBinaryWriter(writer);
		}

		public override void Flush()
		{
			_writer.Flush();
		}

		protected override void WriteEnd(JsonToken token)
		{
			base.WriteEnd(token);
			RemoveParent();
			if (base.Top == 0)
			{
				_writer.WriteToken(_root);
			}
		}

		public override void WriteComment(string text)
		{
			throw JsonWriterException.Create(this, "Cannot write JSON comment as BSON.", null);
		}

		public override void WriteStartConstructor(string name)
		{
			throw JsonWriterException.Create(this, "Cannot write JSON constructor as BSON.", null);
		}

		public override void WriteRaw(string json)
		{
			throw JsonWriterException.Create(this, "Cannot write raw JSON as BSON.", null);
		}

		public override void WriteRawValue(string json)
		{
			throw JsonWriterException.Create(this, "Cannot write raw JSON as BSON.", null);
		}

		public override void WriteStartArray()
		{
			base.WriteStartArray();
			AddParent(new BsonArray());
		}

		public override void WriteStartObject()
		{
			base.WriteStartObject();
			AddParent(new BsonObject());
		}

		public override void WritePropertyName(string name)
		{
			base.WritePropertyName(name);
			_propertyName = name;
		}

		public override void Close()
		{
			base.Close();
			if (base.CloseOutput && _writer != null)
			{
				_writer.Close();
			}
		}

		private void AddParent(BsonToken container)
		{
			AddToken(container);
			_parent = container;
		}

		private void RemoveParent()
		{
			_parent = _parent.Parent;
		}

		private void AddValue(object value, BsonType type)
		{
			AddToken(new BsonValue(value, type));
		}

		internal void AddToken(BsonToken token)
		{
			if (_parent != null)
			{
				if (_parent is BsonObject)
				{
					((BsonObject)_parent).Add(_propertyName, token);
					_propertyName = null;
				}
				else
				{
					((BsonArray)_parent).Add(token);
				}
				return;
			}
			if (token.Type != BsonType.Object && token.Type != BsonType.Array)
			{
				throw JsonWriterException.Create(this, "Error writing {0} value. BSON must start with an Object or Array.".FormatWith(CultureInfo.InvariantCulture, token.Type), null);
			}
			_parent = token;
			_root = token;
		}

		public override void WriteValue(object value)
		{
			base.WriteValue(value);
		}

		public override void WriteNull()
		{
			base.WriteNull();
			AddValue(null, BsonType.Null);
		}

		public override void WriteUndefined()
		{
			base.WriteUndefined();
			AddValue(null, BsonType.Undefined);
		}

		public override void WriteValue(string value)
		{
			base.WriteValue(value);
			if (value == null)
			{
				AddValue(null, BsonType.Null);
			}
			else
			{
				AddToken(new BsonString(value, includeLength: true));
			}
		}

		public override void WriteValue(int value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Integer);
		}

		[CLSCompliant(false)]
		public override void WriteValue(uint value)
		{
			if (value > int.MaxValue)
			{
				throw JsonWriterException.Create(this, "Value is too large to fit in a signed 32 bit integer. BSON does not support unsigned values.", null);
			}
			base.WriteValue(value);
			AddValue(value, BsonType.Integer);
		}

		public override void WriteValue(long value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Long);
		}

		[CLSCompliant(false)]
		public override void WriteValue(ulong value)
		{
			if (value > long.MaxValue)
			{
				throw JsonWriterException.Create(this, "Value is too large to fit in a signed 64 bit integer. BSON does not support unsigned values.", null);
			}
			base.WriteValue(value);
			AddValue(value, BsonType.Long);
		}

		public override void WriteValue(float value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Number);
		}

		public override void WriteValue(double value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Number);
		}

		public override void WriteValue(bool value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Boolean);
		}

		public override void WriteValue(short value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Integer);
		}

		[CLSCompliant(false)]
		public override void WriteValue(ushort value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Integer);
		}

		public override void WriteValue(char value)
		{
			base.WriteValue(value);
			string text = null;
			text = value.ToString(CultureInfo.InvariantCulture);
			AddToken(new BsonString(text, includeLength: true));
		}

		public override void WriteValue(byte value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Integer);
		}

		[CLSCompliant(false)]
		public override void WriteValue(sbyte value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Integer);
		}

		public override void WriteValue(decimal value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Number);
		}

		public override void WriteValue(DateTime value)
		{
			base.WriteValue(value);
			value = DateTimeUtils.EnsureDateTime(value, base.DateTimeZoneHandling);
			AddValue(value, BsonType.Date);
		}

		public override void WriteValue(DateTimeOffset value)
		{
			base.WriteValue(value);
			AddValue(value, BsonType.Date);
		}

		public override void WriteValue(byte[] value)
		{
			base.WriteValue(value);
			AddToken(new BsonBinary(value, BsonBinaryType.Binary));
		}

		public override void WriteValue(Guid value)
		{
			base.WriteValue(value);
			AddToken(new BsonBinary(value.ToByteArray(), BsonBinaryType.Uuid));
		}

		public override void WriteValue(TimeSpan value)
		{
			base.WriteValue(value);
			AddToken(new BsonString(value.ToString(), includeLength: true));
		}

		public override void WriteValue(Uri value)
		{
			base.WriteValue(value);
			AddToken(new BsonString(value.ToString(), includeLength: true));
		}

		public void WriteObjectId(byte[] value)
		{
			ValidationUtils.ArgumentNotNull(value, "value");
			if (value.Length != 12)
			{
				throw JsonWriterException.Create(this, "An object id must be 12 bytes", null);
			}
			UpdateScopeWithFinishedValue();
			AutoComplete(JsonToken.Undefined);
			AddValue(value, BsonType.Oid);
		}

		public void WriteRegex(string pattern, string options)
		{
			ValidationUtils.ArgumentNotNull(pattern, "pattern");
			UpdateScopeWithFinishedValue();
			AutoComplete(JsonToken.Undefined);
			AddToken(new BsonRegex(pattern, options));
		}
	}
	[Preserve]
	public class BsonObjectId
	{
		public byte[] Value { get; private set; }

		public BsonObjectId(byte[] value)
		{
			ValidationUtils.ArgumentNotNull(value, "value");
			if (value.Length != 12)
			{
				throw new ArgumentException("An ObjectId must be 12 bytes", "value");
			}
			Value = value;
		}
	}
}
namespace ProtoBuf
{
	internal enum TimeSpanScale
	{
		Days = 0,
		Hours = 1,
		Minutes = 2,
		Seconds = 3,
		Milliseconds = 4,
		Ticks = 5,
		MinMax = 15
	}
	public static class BclHelpers
	{
		[Flags]
		public enum NetObjectOptions : byte
		{
			None = 0,
			AsReference = 1,
			DynamicType = 2,
			UseConstructor = 4,
			LateSet = 8
		}

		private const int FieldTimeSpanValue = 1;

		private const int FieldTimeSpanScale = 2;

		private const int FieldDecimalLow = 1;

		private const int FieldDecimalHigh = 2;

		private const int FieldDecimalSignScale = 3;

		private const int FieldGuidLow = 1;

		private const int FieldGuidHigh = 2;

		private const int FieldExistingObjectKey = 1;

		private const int FieldNewObjectKey = 2;

		private const int FieldExistingTypeKey = 3;

		private const int FieldNewTypeKey = 4;

		private const int FieldTypeName = 8;

		private const int FieldObject = 10;

		internal static readonly DateTime EpochOrigin = new DateTime(1970, 1, 1, 0, 0, 0, 0);

		public static object GetUninitializedObject(Type type)
		{
			return FormatterServices.GetUninitializedObject(type);
		}

		public static void WriteTimeSpan(TimeSpan timeSpan, ProtoWriter dest)
		{
			if (dest == null)
			{
				throw new ArgumentNullException("dest");
			}
			switch (dest.WireType)
			{
			case WireType.String:
			case WireType.StartGroup:
			{
				long num = timeSpan.Ticks;
				TimeSpanScale timeSpanScale;
				if (timeSpan == TimeSpan.MaxValue)
				{
					num = 1L;
					timeSpanScale = TimeSpanScale.MinMax;
				}
				else if (timeSpan == TimeSpan.MinValue)
				{
					num = -1L;
					timeSpanScale = TimeSpanScale.MinMax;
				}
				else if (num % 864000000000L == 0)
				{
					timeSpanScale = TimeSpanScale.Days;
					num /= 864000000000L;
				}
				else if (num % 36000000000L == 0)
				{
					timeSpanScale = TimeSpanScale.Hours;
					num /= 36000000000L;
				}
				else if (num % 600000000 == 0)
				{
					timeSpanScale = TimeSpanScale.Minutes;
					num /= 600000000;
				}
				else if (num % 10000000 == 0)
				{
					timeSpanScale = TimeSpanScale.Seconds;
					num /= 10000000;
				}
				else if (num % 10000 == 0)
				{
					timeSpanScale = TimeSpanScale.Milliseconds;
					num /= 10000;
				}
				else
				{
					timeSpanScale = TimeSpanScale.Ticks;
				}
				SubItemToken token = ProtoWriter.StartSubItem(null, dest);
				if (num != 0)
				{
					ProtoWriter.WriteFieldHeader(1, WireType.SignedVariant, dest);
					ProtoWriter.WriteInt64(num, dest);
				}
				if (timeSpanScale != TimeSpanScale.Days)
				{
					ProtoWriter.WriteFieldHeader(2, WireType.Variant, dest);
					ProtoWriter.WriteInt32((int)timeSpanScale, dest);
				}
				ProtoWriter.EndSubItem(token, dest);
				break;
			}
			case WireType.Fixed64:
				ProtoWriter.WriteInt64(timeSpan.Ticks, dest);
				break;
			default:
				throw new ProtoException("Unexpected wire-type: " + dest.WireType);
			}
		}

		public static TimeSpan ReadTimeSpan(ProtoReader source)
		{
			long num = ReadTimeSpanTicks(source);
			return num switch
			{
				long.MinValue => TimeSpan.MinValue, 
				long.MaxValue => TimeSpan.MaxValue, 
				_ => TimeSpan.FromTicks(num), 
			};
		}

		public static DateTime ReadDateTime(ProtoReader source)
		{
			long num = ReadTimeSpanTicks(source);
			switch (num)
			{
			case long.MinValue:
				return DateTime.MinValue;
			case long.MaxValue:
				return DateTime.MaxValue;
			default:
			{
				DateTime epochOrigin = EpochOrigin;
				return epochOrigin.AddTicks(num);
			}
			}
		}

		public static void WriteDateTime(DateTime value, ProtoWriter dest)
		{
			if (dest == null)
			{
				throw new ArgumentNullException("dest");
			}
			TimeSpan timeSpan;
			switch (dest.WireType)
			{
			case WireType.String:
			case WireType.StartGroup:
				timeSpan = ((!(value == DateTime.MaxValue)) ? ((!(value == DateTime.MinValue)) ? (value - EpochOrigin) : TimeSpan.MinValue) : TimeSpan.MaxValue);
				break;
			default:
				timeSpan = value - EpochOrigin;
				break;
			}
			WriteTimeSpan(timeSpan, dest);
		}

		private static long ReadTimeSpanTicks(ProtoReader source)
		{
			switch (source.WireType)
			{
			case WireType.String:
			case WireType.StartGroup:
			{
				SubItemToken token = ProtoReader.StartSubItem(source);
				TimeSpanScale timeSpanScale = TimeSpanScale.Days;
				long num = 0L;
				int num2;
				while ((num2 = source.ReadFieldHeader()) > 0)
				{
					switch (num2)
					{
					case 2:
						timeSpanScale = (TimeSpanScale)source.ReadInt32();
						break;
					case 1:
						source.Assert(WireType.SignedVariant);
						num = source.ReadInt64();
						break;
					default:
						source.SkipField();
						break;
					}
				}
				ProtoReader.EndSubItem(token, source);
				switch (timeSpanScale)
				{
				case TimeSpanScale.Days:
					return num * 864000000000L;
				case TimeSpanScale.Hours:
					return num * 36000000000L;
				case TimeSpanScale.Minutes:
					return num * 600000000;
				case TimeSpanScale.Seconds:
					return num * 10000000;
				case TimeSpanScale.Milliseconds:
					return num * 10000;
				case TimeSpanScale.Ticks:
					return num;
				case TimeSpanScale.MinMax:
				{
					long num3 = num;
					if (num3 <= 1 && num3 >= -1)
					{
						switch (num3 - -1)
						{
						case 2L:
							return long.MaxValue;
						case 0L:
							return long.MinValue;
						}
					}
					throw new ProtoException("Unknown min/max value: " + num);
				}
				default:
					throw new ProtoException("Unknown timescale: " + timeSpanScale);
				}
			}
			case WireType.Fixed64:
				return source.ReadInt64();
			default:
				throw new ProtoException("Unexpected wire-type: " + source.WireType);
			}
		}

		public static decimal ReadDecimal(ProtoReader reader)
		{
			ulong num = 0uL;
			uint num2 = 0u;
			uint num3 = 0u;
			SubItemToken token = ProtoReader.StartSubItem(reader);
			int num4;
			while ((num4 = reader.ReadFieldHeader()) > 0)
			{
				switch (num4)
				{
				case 1:
					num = reader.ReadUInt64();
					break;
				case 2:
					num2 = reader.ReadUInt32();
					break;
				case 3:
					num3 = reader.ReadUInt32();
					break;
				default:
					reader.SkipField();
					break;
				}
			}
			ProtoReader.EndSubItem(token, reader);
			if (num == 0 && num2 == 0)
			{
				return 0m;
			}
			int lo = (int)(num & 0xFFFFFFFFu);
			int mid = (int)((num >> 32) & 0xFFFFFFFFu);
			int hi = (int)num2;
			bool isNegative = (num3 & 1) == 1;
			byte scale = (byte)((num3 & 0x1FE) >> 1);
			return new decimal(lo, mid, hi, isNegative, scale);
		}

		public static void WriteDecimal(decimal value, ProtoWriter writer)
		{
			int[] bits = decimal.GetBits(value);
			ulong num = (ulong)((long)bits[1] << 32);
			ulong num2 = (ulong)(bits[0] & 0xFFFFFFFFu);
			ulong num3 = num | num2;
			uint num4 = (uint)bits[2];
			uint num5 = (uint)(((bits[3] >> 15) & 0x1FE) | ((bits[3] >> 31) & 1));
			SubItemToken token = ProtoWriter.StartSubItem(null, writer);
			if (num3 != 0)
			{
				ProtoWriter.WriteFieldHeader(1, WireType.Variant, writer);
				ProtoWriter.WriteUInt64(num3, writer);
			}
			if (num4 != 0)
			{
				ProtoWriter.WriteFieldHeader(2, WireType.Variant, writer);
				ProtoWriter.WriteUInt32(num4, writer);
			}
			if (num5 != 0)
			{
				ProtoWriter.WriteFieldHeader(3, WireType.Variant, writer);
				ProtoWriter.WriteUInt32(num5, writer);
			}
			ProtoWriter.EndSubItem(token, writer);
		}

		public static void WriteGuid(Guid value, ProtoWriter dest)
		{
			byte[] data = value.ToByteArray();
			SubItemToken token = ProtoWriter.StartSubItem(null, dest);
			if (value != Guid.Empty)
			{
				ProtoWriter.WriteFieldHeader(1, WireType.Fixed64, dest);
				ProtoWriter.WriteBytes(data, 0, 8, dest);
				ProtoWriter.WriteFieldHeader(2, WireType.Fixed64, dest);
				ProtoWriter.WriteBytes(data, 8, 8, dest);
			}
			ProtoWriter.EndSubItem(token, dest);
		}

		public static Guid ReadGuid(ProtoReader source)
		{
			ulong num = 0uL;
			ulong num2 = 0uL;
			SubItemToken token = ProtoReader.StartSubItem(source);
			int num3;
			while ((num3 = source.ReadFieldHeader()) > 0)
			{
				switch (num3)
				{
				case 1:
					num = source.ReadUInt64();
					break;
				case 2:
					num2 = source.ReadUInt64();
					break;
				default:
					source.SkipField();
					break;
				}
			}
			ProtoReader.EndSubItem(token, source);
			if (num == 0 && num2 == 0)
			{
				return Guid.Empty;
			}
			uint num4 = (uint)(num >> 32);
			uint a = (uint)num;
			uint num5 = (uint)(num2 >> 32);
			uint num6 = (uint)num2;
			return new Guid((int)a, (short)num4, (short)(num4 >> 16), (byte)num6, (byte)(num6 >> 8), (byte)(num6 >> 16), (byte)(num6 >> 24), (byte)num5, (byte)(num5 >> 8), (byte)(num5 >> 16), (byte)(num5 >> 24));
		}

		public static object ReadNetObject(object value, ProtoReader source, int key, Type type, NetObjectOptions options)
		{
			SubItemToken token = ProtoReader.StartSubItem(source);
			int num = -1;
			int num2 = -1;
			int num3;
			while ((num3 = source.ReadFieldHeader()) > 0)
			{
				switch (num3)
				{
				case 1:
				{
					int key2 = source.ReadInt32();
					value = source.NetCache.GetKeyedObject(key2);
					break;
				}
				case 2:
					num = source.ReadInt32();
					break;
				case 3:
				{
					int key2 = source.ReadInt32();
					type = (Type)source.NetCache.GetKeyedObject(key2);
					key = source.GetTypeKey(ref type);
					break;
				}
				case 4:
					num2 = source.ReadInt32();
					break;
				case 8:
				{
					string text = source.ReadString();
					type = source.DeserializeType(text);
					if ((object)type == null)
					{
						throw new ProtoException("Unable to resolve type: " + text + " (you can use the TypeModel.DynamicTypeFormatting event to provide a custom mapping)");
					}
					if ((object)type == typeof(string))
					{
						key = -1;
						break;
					}
					key = source.GetTypeKey(ref type);
					if (key >= 0)
					{
						break;
					}
					throw new InvalidOperationException("Dynamic type is not a contract-type: " + type.Name);
				}
				case 10:
				{
					bool flag = (object)type == typeof(string);
					bool flag2 = value == null;
					bool flag3 = flag2 && (flag || (options & NetObjectOptions.LateSet) != 0);
					if (num >= 0 && !flag3)
					{
						if (value == null)
						{
							source.TrapNextObject(num);
						}
						else
						{
							source.NetCache.SetKeyedObject(num, value);
						}
						if (num2 >= 0)
						{
							source.NetCache.SetKeyedObject(num2, type);
						}
					}
					object obj = value;
					value = ((!flag) ? ProtoReader.ReadTypedObject(obj, key, source, type) : source.ReadString());
					if (num >= 0)
					{
						if (flag2 && !flag3)
						{
							obj = source.NetCache.GetKeyedObject(num);
						}
						if (flag3)
						{
							source.NetCache.SetKeyedObject(num, value);
							if (num2 >= 0)
							{
								source.NetCache.SetKeyedObject(num2, type);
							}
						}
					}
					if (num >= 0 && !flag3 && !object.ReferenceEquals(obj, value))
					{
						throw new ProtoException("A reference-tracked object changed reference during deserialization");
					}
					if (num < 0 && num2 >= 0)
					{
						source.NetCache.SetKeyedObject(num2, type);
					}
					break;
				}
				default:
					source.SkipField();
					break;
				}
			}
			if (num >= 0 && (options & NetObjectOptions.AsReference) == 0)
			{
				throw new ProtoException("Object key in input stream, but reference-tracking was not expected");
			}
			ProtoReader.EndSubItem(token, source);
			return value;
		}

		public static void WriteNetObject(object value, ProtoWriter dest, int key, NetObjectOptions options)
		{
			if (dest == null)
			{
				throw new ArgumentNullException("dest");
			}
			bool flag = (options & NetObjectOptions.DynamicType) != 0;
			bool flag2 = (options & NetObjectOptions.AsReference) != 0;
			WireType wireType = dest.WireType;
			SubItemToken token = ProtoWriter.StartSubItem(null, dest);
			bool flag3 = true;
			if (flag2)
			{
				bool existing;
				int value2 = dest.NetCache.AddObjectKey(value, out existing);
				ProtoWriter.WriteFieldHeader(existing ? 1 : 2, WireType.Variant, dest);
				ProtoWriter.WriteInt32(value2, dest);
				if (existing)
				{
					flag3 = false;
				}
			}
			if (flag3)
			{
				if (flag)
				{
					Type type = value.GetType();
					if (!(value is string))
					{
						key = dest.GetTypeKey(ref type);
						if (key < 0)
						{
							throw new InvalidOperationException("Dynamic type is not a contract-type: " + type.Name);
						}
					}
					bool existing2;
					int value3 = dest.NetCache.AddObjectKey(type, out existing2);
					ProtoWriter.WriteFieldHeader(existing2 ? 3 : 4, WireType.Variant, dest);
					ProtoWriter.WriteInt32(value3, dest);
					if (!existing2)
					{
						ProtoWriter.WriteFieldHeader(8, WireType.String, dest);
						ProtoWriter.WriteString(dest.SerializeType(type), dest);
					}
				}
				ProtoWriter.WriteFieldHeader(10, wireType, dest);
				if (value is string)
				{
					ProtoWriter.WriteString((string)value, dest);
				}
				else
				{
					ProtoWriter.WriteObject(value, key, dest);
				}
			}
			ProtoWriter.EndSubItem(token, dest);
		}
	}
	public interface IExtension
	{
		Stream BeginAppend();

		void EndAppend(Stream stream, bool commit);

		Stream BeginQuery();

		void EndQuery(Stream stream);

		int GetLength();
	}
	public sealed class BufferExtension : IExtension
	{
		private byte[] buffer;

		int IExtension.GetLength()
		{
			if (buffer != null)
			{
				return buffer.Length;
			}
			return 0;
		}

		Stream IExtension.BeginAppend()
		{
			return new MemoryStream();
		}

		void IExtension.EndAppend(Stream stream, bool commit)
		{
			using (stream)
			{
				int num;
				if (commit && (num = (int)stream.Length) > 0)
				{
					MemoryStream memoryStream = (MemoryStream)stream;
					if (buffer == null)
					{
						buffer = memoryStream.ToArray();
						return;
					}
					int num2 = buffer.Length;
					byte[] to = new byte[num2 + num];
					Helpers.BlockCopy(buffer, 0, to, 0, num2);
					Helpers.BlockCopy(memoryStream.GetBuffer(), 0, to, num2, num);
					buffer = to;
				}
			}
		}

		Stream IExtension.BeginQuery()
		{
			if (buffer != null)
			{
				return new MemoryStream(buffer);
			}
			return Stream.Null;
		}

		void IExtension.EndQuery(Stream stream)
		{
			using (stream)
			{
			}
		}
	}
	internal sealed class BufferPool
	{
		private const int PoolSize = 20;

		internal const int BufferLength = 1024;

		private static readonly object[] pool = new object[20];

		internal static void Flush()
		{
			lock (pool)
			{
				for (int i = 0; i < pool.Length; i++)
				{
					pool[i] = null;
				}
			}
		}

		private BufferPool()
		{
		}

		internal static byte[] GetBuffer()
		{
			lock (pool)
			{
				for (int i = 0; i < pool.Length; i++)
				{
					object obj;
					if ((obj = pool[i]) != null)
					{
						pool[i] = null;
						return (byte[])obj;
					}
				}
			}
			return new byte[1024];
		}

		internal static void ResizeAndFlushLeft(ref byte[] buffer, int toFitAtLeastBytes, int copyFromIndex, int copyBytes)
		{
			int num = buffer.Length * 2;
			if (num < toFitAtLeastBytes)
			{
				num = toFitAtLeastBytes;
			}
			byte[] array = new byte[num];
			if (copyBytes > 0)
			{
				Helpers.BlockCopy(buffer, copyFromIndex, array, 0, copyBytes);
			}
			if (buffer.Length == 1024)
			{
				ReleaseBufferToPool(ref buffer);
			}
			buffer = array;
		}

		internal static void ReleaseBufferToPool(ref byte[] buffer)
		{
			if (buffer == null)
			{
				return;
			}
			if (buffer.Length == 1024)
			{
				lock (pool)
				{
					for (int i = 0; i < pool.Length; i++)
					{
						if (pool[i] == null)
						{
							pool[i] = buffer;
							break;
						}
					}
				}
			}
			buffer = null;
		}
	}
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
	[ImmutableObject(true)]
	public sealed class ProtoBeforeSerializationAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
	[ImmutableObject(true)]
	public sealed class ProtoAfterSerializationAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
	[ImmutableObject(true)]
	public sealed class ProtoBeforeDeserializationAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)]
	[ImmutableObject(true)]
	public sealed class ProtoAfterDeserializationAttribute : Attribute
	{
	}
}
namespace ProtoBuf.Compiler
{
	internal delegate void ProtoSerializer(object value, ProtoWriter dest);
	internal delegate object ProtoDeserializer(object value, ProtoReader source);
	internal struct CodeLabel
	{
		public readonly Label Value;

		public readonly int Index;

		public CodeLabel(Label value, int index)
		{
			Value = value;
			Index = index;
		}
	}
	internal sealed class CompilerContext
	{
		private sealed class UsingBlock : IDisposable
		{
			private Local local;

			private CompilerContext ctx;

			private CodeLabel label;

			public UsingBlock(CompilerContext ctx, Local local)
			{
				if (ctx == null)
				{
					throw new ArgumentNullException("ctx");
				}
				if (local == null)
				{
					throw new ArgumentNullException("local");
				}
				Type type = local.Type;
				if ((!type.IsValueType && !type.IsSealed) || ctx.MapType(typeof(IDisposable)).IsAssignableFrom(type))
				{
					this.local = local;
					this.ctx = ctx;
					label = ctx.BeginTry();
				}
			}

			public void Dispose()
			{
				if (this.local == null || ctx == null)
				{
					return;
				}
				ctx.EndTry(label, @short: false);
				ctx.BeginFinally();
				Type type = ctx.MapType(typeof(IDisposable));
				MethodInfo method = type.GetMethod("Dispose");
				Type type2 = this.local.Type;
				if (type2.IsValueType)
				{
					ctx.LoadAddress(this.local, type2);
					if (ctx.MetadataVersion == ILVersion.Net1)
					{
						ctx.LoadValue(this.local);
						ctx.CastToObject(type2);
					}
					else
					{
						ctx.Constrain(type2);
					}
					ctx.EmitCall(method);
				}
				else
				{
					CodeLabel codeLabel = ctx.DefineLabel();
					if (type.IsAssignableFrom(type2))
					{
						ctx.LoadValue(this.local);
						ctx.BranchIfFalse(codeLabel, @short: true);
						ctx.LoadAddress(this.local, type2);
					}
					else
					{
						using Local local = new Local(ctx, type);
						ctx.LoadValue(this.local);
						ctx.TryCast(type);
						ctx.CopyValue();
						ctx.StoreValue(local);
						ctx.BranchIfFalse(codeLabel, @short: true);
						ctx.LoadAddress(local, type);
					}
					ctx.EmitCall(method);
					ctx.MarkLabel(codeLabel);
				}
				ctx.EndFinally();
				this.local = null;
				ctx = null;
				label = default(CodeLabel);
			}
		}

		public enum ILVersion
		{
			Net1,
			Net2
		}

		private readonly DynamicMethod method;

		private static int next;

		private readonly bool isStatic;

		private readonly RuntimeTypeModel.SerializerPair[] methodPairs;

		private readonly bool isWriter;

		private readonly bool nonPublic;

		private readonly Local inputValue;

		private readonly string assemblyName;

		private readonly ILGenerator il;

		private MutableList locals = new MutableList();

		private int nextLabel;

		private BasicList knownTrustedAssemblies;

		private BasicList knownUntrustedAssemblies;

		private readonly TypeModel model;

		private readonly ILVersion metadataVersion;

		public TypeModel Model => model;

		internal bool NonPublic => nonPublic;

		public Local InputValue => inputValue;

		public ILVersion MetadataVersion => metadataVersion;

		internal CodeLabel DefineLabel()
		{
			CodeLabel result = new CodeLabel(il.DefineLabel(), nextLabel++);
			return result;
		}

		internal void MarkLabel(CodeLabel label)
		{
			il.MarkLabel(label.Value);
		}

		public static ProtoSerializer BuildSerializer(IProtoSerializer head, TypeModel model)
		{
			Type expectedType = head.ExpectedType;
			try
			{
				CompilerContext compilerContext = new CompilerContext(expectedType, isWriter: true, isStatic: true, model, typeof(object));
				compilerContext.LoadValue(compilerContext.InputValue);
				compilerContext.CastFromObject(expectedType);
				compilerContext.WriteNullCheckedTail(expectedType, head, null);
				compilerContext.Emit(System.Reflection.Emit.OpCodes.Ret);
				return (ProtoSerializer)compilerContext.method.CreateDelegate(typeof(ProtoSerializer));
			}
			catch (Exception innerException)
			{
				string text = expectedType.FullName;
				if (string.IsNullOrEmpty(text))
				{
					text = expectedType.Name;
				}
				throw new InvalidOperationException("It was not possible to prepare a serializer for: " + text, innerException);
			}
		}

		public static ProtoDeserializer BuildDeserializer(IProtoSerializer head, TypeModel model)
		{
			Type expectedType = head.ExpectedType;
			CompilerContext compilerContext = new CompilerContext(expectedType, isWriter: false, isStatic: true, model, typeof(object));
			using (Local local = new Local(compilerContext, expectedType))
			{
				if (!expectedType.IsValueType)
				{
					compilerContext.LoadValue(compilerContext.InputValue);
					compilerContext.CastFromObject(expectedType);
					compilerContext.StoreValue(local);
				}
				else
				{
					compilerContext.LoadValue(compilerContext.InputValue);
					CodeLabel label = compilerContext.DefineLabel();
					CodeLabel label2 = compilerContext.DefineLabel();
					compilerContext.BranchIfTrue(label, @short: true);
					compilerContext.LoadAddress(local, expectedType);
					compilerContext.EmitCtor(expectedType);
					compilerContext.Branch(label2, @short: true);
					compilerContext.MarkLabel(label);
					compilerContext.LoadValue(compilerContext.InputValue);
					compilerContext.CastFromObject(expectedType);
					compilerContext.StoreValue(local);
					compilerContext.MarkLabel(label2);
				}
				head.EmitRead(compilerContext, local);
				if (head.ReturnsValue)
				{
					compilerContext.StoreValue(local);
				}
				compilerContext.LoadValue(local);
				compilerContext.CastToObject(expectedType);
			}
			compilerContext.Emit(System.Reflection.Emit.OpCodes.Ret);
			return (ProtoDeserializer)compilerContext.method.CreateDelegate(typeof(ProtoDeserializer));
		}

		internal void Return()
		{
			Emit(System.Reflection.Emit.OpCodes.Ret);
		}

		private static bool IsObject(Type type)
		{
			return (object)type == typeof(object);
		}

		internal void CastToObject(Type type)
		{
			if (!IsObject(type))
			{
				if (type.IsValueType)
				{
					il.Emit(System.Reflection.Emit.OpCodes.Box, type);
				}
				else
				{
					il.Emit(System.Reflection.Emit.OpCodes.Castclass, MapType(typeof(object)));
				}
			}
		}

		internal void CastFromObject(Type type)
		{
			if (IsObject(type))
			{
				return;
			}
			if (type.IsValueType)
			{
				if (MetadataVersion == ILVersion.Net1)
				{
					il.Emit(System.Reflection.Emit.OpCodes.Unbox, type);
					il.Emit(System.Reflection.Emit.OpCodes.Ldobj, type);
				}
				else
				{
					il.Emit(System.Reflection.Emit.OpCodes.Unbox_Any, type);
				}
			}
			else
			{
				il.Emit(System.Reflection.Emit.OpCodes.Castclass, type);
			}
		}

		internal MethodBuilder GetDedicatedMethod(int metaKey, bool read)
		{
			if (methodPairs == null)
			{
				return null;
			}
			for (int i = 0; i < methodPairs.Length; i++)
			{
				if (methodPairs[i].MetaKey == metaKey)
				{
					if (!read)
					{
						return methodPairs[i].Serialize;
					}
					return methodPairs[i].Deserialize;
				}
			}
			throw new ArgumentException("Meta-key not found", "metaKey");
		}

		internal int MapMetaKeyToCompiledKey(int metaKey)
		{
			if (metaKey < 0 || methodPairs == null)
			{
				return metaKey;
			}
			for (int i = 0; i < methodPairs.Length; i++)
			{
				if (methodPairs[i].MetaKey == metaKey)
				{
					return i;
				}
			}
			throw new ArgumentException("Key could not be mapped: " + metaKey, "metaKey");
		}

		internal CompilerContext(ILGenerator il, bool isStatic, bool isWriter, RuntimeTypeModel.SerializerPair[] methodPairs, TypeModel model, ILVersion metadataVersion, string assemblyName, Type inputType)
		{
			if (il == null)
			{
				throw new ArgumentNullException("il");
			}
			if (methodPairs == null)
			{
				throw new ArgumentNullException("methodPairs");
			}
			if (model == null)
			{
				throw new ArgumentNullException("model");
			}
			if (Helpers.IsNullOrEmpty(assemblyName))
			{
				throw new ArgumentNullException("assemblyName");
			}
			this.assemblyName = assemblyName;
			this.isStatic = isStatic;
			this.methodPairs = methodPairs;
			this.il = il;
			this.isWriter = isWriter;
			this.model = model;
			this.metadataVersion = metadataVersion;
			if ((object)inputType != null)
			{
				inputValue = new Local(null, inputType);
			}
		}

		private CompilerContext(Type associatedType, bool isWriter, bool isStatic, TypeModel model, Type inputType)
		{
			if (model == null)
			{
				throw new ArgumentNullException("model");
			}
			metadataVersion = ILVersion.Net2;
			this.isStatic = isStatic;
			this.isWriter = isWriter;
			this.model = model;
			nonPublic = true;
			Type typeFromHandle;
			Type[] parameterTypes;
			if (isWriter)
			{
				typeFromHandle = typeof(void);
				parameterTypes = new Type[2]
				{
					typeof(object),
					typeof(ProtoWriter)
				};
			}
			else
			{
				typeFromHandle = typeof(object);
				parameterTypes = new Type[2]
				{
					typeof(object),
					typeof(ProtoReader)
				};
			}
			method = new DynamicMethod("proto_" + ++next, typeFromHandle, parameterTypes, associatedType.IsInterface ? typeof(object) : associatedType, skipVisibility: true);
			il = method.GetILGenerator();
			if ((object)inputType != null)
			{
				inputValue = new Local(null, inputType);
			}
		}

		private void Emit(System.Reflection.Emit.OpCode opcode)
		{
			il.Emit(opcode);
		}

		public void LoadValue(string value)
		{
			if (value == null)
			{
				LoadNullRef();
			}
			else
			{
				il.Emit(System.Reflection.Emit.OpCodes.Ldstr, value);
			}
		}

		public void LoadValue(float value)
		{
			il.Emit(System.Reflection.Emit.OpCodes.Ldc_R4, value);
		}

		public void LoadValue(double value)
		{
			il.Emit(System.Reflection.Emit.OpCodes.Ldc_R8, value);
		}

		public void LoadValue(long value)
		{
			il.Emit(System.Reflection.Emit.OpCodes.Ldc_I8, value);
		}

		public void LoadValue(int value)
		{
			switch (value)
			{
			case 0:
				Emit(System.Reflection.Emit.OpCodes.Ldc_I4_0);
				return;
			case 1:
				Emit(System.Reflection.Emit.OpCodes.Ldc_I4_1);
				return;
			case 2:
				Emit(System.Reflection.Emit.OpCodes.Ldc_I4_2);
				return;
			case 3:
				Emit(System.Reflection.Emit.OpCodes.Ldc_I4_3);
				return;
			case 4:
				Emit(System.Reflection.Emit.OpCodes.Ldc_I4_4);
				return;
			case 5:
				Emit(System.Reflection.Emit.OpCodes.Ldc_I4_5);
				return;
			case 6:
				Emit(System.Reflection.Emit.OpCodes.Ldc_I4_6);
				return;
			case 7:
				Emit(System.Reflection.Emit.OpCodes.Ldc_I4_7);
				return;
			case 8:
				Emit(System.Reflection.Emit.OpCodes.Ldc_I4_8);
				return;
			case -1:
				Emit(System.Reflection.Emit.OpCodes.Ldc_I4_M1);
				return;
			}
			if (value >= -128 && value <= 127)
			{
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_S, (sbyte)value);
			}
			else
			{
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, value);
			}
		}

		internal LocalBuilder GetFromPool(Type type)
		{
			int count = locals.Count;
			for (int i = 0; i < count; i++)
			{
				LocalBuilder localBuilder = (LocalBuilder)locals[i];
				if (localBuilder != null && (object)localBuilder.LocalType == type)
				{
					locals[i] = null;
					return localBuilder;
				}
			}
			return il.DeclareLocal(type);
		}

		internal void ReleaseToPool(LocalBuilder value)
		{
			int count = locals.Count;
			for (int i = 0; i < count; i++)
			{
				if (locals[i] == null)
				{
					locals[i] = value;
					return;
				}
			}
			locals.Add(value);
		}

		public void LoadReaderWriter()
		{
			Emit(isStatic ? System.Reflection.Emit.OpCodes.Ldarg_1 : System.Reflection.Emit.OpCodes.Ldarg_2);
		}

		public void StoreValue(Local local)
		{
			if (local == InputValue)
			{
				byte arg = ((!isStatic) ? ((byte)1) : ((byte)0));
				il.Emit(System.Reflection.Emit.OpCodes.Starg_S, arg);
				return;
			}
			switch (local.Value.LocalIndex)
			{
			case 0:
				Emit(System.Reflection.Emit.OpCodes.Stloc_0);
				break;
			case 1:
				Emit(System.Reflection.Emit.OpCodes.Stloc_1);
				break;
			case 2:
				Emit(System.Reflection.Emit.OpCodes.Stloc_2);
				break;
			case 3:
				Emit(System.Reflection.Emit.OpCodes.Stloc_3);
				break;
			default:
			{
				System.Reflection.Emit.OpCode opcode = (UseShortForm(local) ? System.Reflection.Emit.OpCodes.Stloc_S : System.Reflection.Emit.OpCodes.Stloc);
				il.Emit(opcode, local.Value);
				break;
			}
			}
		}

		public void LoadValue(Local local)
		{
			if (local == null)
			{
				return;
			}
			if (local == InputValue)
			{
				Emit(isStatic ? System.Reflection.Emit.OpCodes.Ldarg_0 : System.Reflection.Emit.OpCodes.Ldarg_1);
				return;
			}
			switch (local.Value.LocalIndex)
			{
			case 0:
				Emit(System.Reflection.Emit.OpCodes.Ldloc_0);
				break;
			case 1:
				Emit(System.Reflection.Emit.OpCodes.Ldloc_1);
				break;
			case 2:
				Emit(System.Reflection.Emit.OpCodes.Ldloc_2);
				break;
			case 3:
				Emit(System.Reflection.Emit.OpCodes.Ldloc_3);
				break;
			default:
			{
				System.Reflection.Emit.OpCode opcode = (UseShortForm(local) ? System.Reflection.Emit.OpCodes.Ldloc_S : System.Reflection.Emit.OpCodes.Ldloc);
				il.Emit(opcode, local.Value);
				break;
			}
			}
		}

		public Local GetLocalWithValue(Type type, Local fromValue)
		{
			if (fromValue != null)
			{
				if ((object)fromValue.Type == type)
				{
					return fromValue.AsCopy();
				}
				LoadValue(fromValue);
				if (!type.IsValueType && ((object)fromValue.Type == null || !type.IsAssignableFrom(fromValue.Type)))
				{
					Cast(type);
				}
			}
			Local local = new Local(this, type);
			StoreValue(local);
			return local;
		}

		internal void EmitBasicRead(string methodName, Type expectedType)
		{
			MethodInfo methodInfo = MapType(typeof(ProtoReader)).GetMethod(methodName, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			if ((object)methodInfo == null || (object)methodInfo.ReturnType != expectedType || methodInfo.GetParameters().Length != 0)
			{
				throw new ArgumentException("methodName");
			}
			LoadReaderWriter();
			EmitCall(methodInfo);
		}

		internal void EmitBasicRead(Type helperType, string methodName, Type expectedType)
		{
			MethodInfo methodInfo = helperType.GetMethod(methodName, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			if ((object)methodInfo == null || (object)methodInfo.ReturnType != expectedType || methodInfo.GetParameters().Length != 1)
			{
				throw new ArgumentException("methodName");
			}
			LoadReaderWriter();
			EmitCall(methodInfo);
		}

		internal void EmitBasicWrite(string methodName, Local fromValue)
		{
			if (Helpers.IsNullOrEmpty(methodName))
			{
				throw new ArgumentNullException("methodName");
			}
			LoadValue(fromValue);
			LoadReaderWriter();
			EmitCall(GetWriterMethod(methodName));
		}

		private MethodInfo GetWriterMethod(string methodName)
		{
			Type type = MapType(typeof(ProtoWriter));
			MethodInfo[] methods = type.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			MethodInfo[] array = methods;
			foreach (MethodInfo methodInfo in array)
			{
				if (!(methodInfo.Name != methodName))
				{
					ParameterInfo[] parameters = methodInfo.GetParameters();
					if (parameters.Length == 2 && (object)parameters[1].ParameterType == type)
					{
						return methodInfo;
					}
				}
			}
			throw new ArgumentException("No suitable method found for: " + methodName, "methodName");
		}

		internal void EmitWrite(Type helperType, string methodName, Local valueFrom)
		{
			if (Helpers.IsNullOrEmpty(methodName))
			{
				throw new ArgumentNullException("methodName");
			}
			MethodInfo methodInfo = helperType.GetMethod(methodName, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			if ((object)methodInfo == null || (object)methodInfo.ReturnType != MapType(typeof(void)))
			{
				throw new ArgumentException("methodName");
			}
			LoadValue(valueFrom);
			LoadReaderWriter();
			EmitCall(methodInfo);
		}

		public void EmitCall(MethodInfo method)
		{
			CheckAccessibility(method);
			System.Reflection.Emit.OpCode opcode = ((method.IsStatic || method.DeclaringType.IsValueType) ? System.Reflection.Emit.OpCodes.Call : System.Reflection.Emit.OpCodes.Callvirt);
			il.EmitCall(opcode, method, null);
		}

		public void LoadNullRef()
		{
			Emit(System.Reflection.Emit.OpCodes.Ldnull);
		}

		internal void WriteNullCheckedTail(Type type, IProtoSerializer tail, Local valueFrom)
		{
			if (type.IsValueType)
			{
				Type type2 = null;
				type2 = Helpers.GetUnderlyingType(type);
				if ((object)type2 != null)
				{
					using (Local local = GetLocalWithValue(type, valueFrom))
					{
						LoadAddress(local, type);
						LoadValue(type.GetProperty("HasValue"));
						CodeLabel label = DefineLabel();
						BranchIfFalse(label, @short: false);
						LoadAddress(local, type);
						EmitCall(type.GetMethod("GetValueOrDefault", Helpers.EmptyTypes));
						tail.EmitWrite(this, null);
						MarkLabel(label);
						return;
					}
				}
				tail.EmitWrite(this, valueFrom);
			}
			else
			{
				LoadValue(valueFrom);
				CopyValue();
				CodeLabel label2 = DefineLabel();
				CodeLabel label3 = DefineLabel();
				BranchIfTrue(label2, @short: true);
				DiscardValue();
				Branch(label3, @short: false);
				MarkLabel(label2);
				tail.EmitWrite(this, null);
				MarkLabel(label3);
			}
		}

		internal void ReadNullCheckedTail(Type type, IProtoSerializer tail, Local valueFrom)
		{
			Type underlyingType;
			if (type.IsValueType && (object)(underlyingType = Helpers.GetUnderlyingType(type)) != null)
			{
				if (tail.RequiresOldValue)
				{
					using Local local = GetLocalWithValue(type, valueFrom);
					LoadAddress(local, type);
					EmitCall(type.GetMethod("GetValueOrDefault", Helpers.EmptyTypes));
				}
				tail.EmitRead(this, null);
				if (tail.ReturnsValue)
				{
					EmitCtor(type, underlyingType);
				}
			}
			else
			{
				tail.EmitRead(this, valueFrom);
			}
		}

		public void EmitCtor(Type type)
		{
			EmitCtor(type, Helpers.EmptyTypes);
		}

		public void EmitCtor(ConstructorInfo ctor)
		{
			if ((object)ctor == null)
			{
				throw new ArgumentNullException("ctor");
			}
			CheckAccessibility(ctor);
			il.Emit(System.Reflection.Emit.OpCodes.Newobj, ctor);
		}

		public void EmitCtor(Type type, params Type[] parameterTypes)
		{
			if (type.IsValueType && parameterTypes.Length == 0)
			{
				il.Emit(System.Reflection.Emit.OpCodes.Initobj, type);
				return;
			}
			ConstructorInfo constructor = Helpers.GetConstructor(type, parameterTypes, nonPublic: true);
			if ((object)constructor == null)
			{
				throw new InvalidOperationException("No suitable constructor found for " + type.FullName);
			}
			EmitCtor(constructor);
		}

		private bool InternalsVisible(Assembly assembly)
		{
			if (Helpers.IsNullOrEmpty(assemblyName))
			{
				return false;
			}
			if (knownTrustedAssemblies != null && knownTrustedAssemblies.IndexOfReference(assembly) >= 0)
			{
				return true;
			}
			if (knownUntrustedAssemblies != null && knownUntrustedAssemblies.IndexOfReference(assembly) >= 0)
			{
				return false;
			}
			bool flag = false;
			Type type = MapType(typeof(InternalsVisibleToAttribute));
			if ((object)type == null)
			{
				return false;
			}
			object[] customAttributes = assembly.GetCustomAttributes(type, inherit: false);
			for (int i = 0; i < customAttributes.Length; i++)
			{
				InternalsVisibleToAttribute internalsVisibleToAttribute = (InternalsVisibleToAttribute)customAttributes[i];
				if (internalsVisibleToAttribute.AssemblyName == assemblyName || internalsVisibleToAttribute.AssemblyName.StartsWith(assemblyName + ","))
				{
					flag = true;
					break;
				}
			}
			if (flag)
			{
				if (knownTrustedAssemblies == null)
				{
					knownTrustedAssemblies = new BasicList();
				}
				knownTrustedAssemblies.Add(assembly);
			}
			else
			{
				if (knownUntrustedAssemblies == null)
				{
					knownUntrustedAssemblies = new BasicList();
				}
				knownUntrustedAssemblies.Add(assembly);
			}
			return flag;
		}

		internal void CheckAccessibility(MemberInfo member)
		{
			if ((object)member == null)
			{
				throw new ArgumentNullException("member");
			}
			MemberTypes memberType = member.MemberType;
			if (NonPublic)
			{
				return;
			}
			bool flag;
			switch (memberType)
			{
			case MemberTypes.TypeInfo:
			{
				Type type = (Type)member;
				flag = type.IsPublic || InternalsVisible(type.Assembly);
				break;
			}
			case MemberTypes.NestedType:
			{
				Type type = (Type)member;
				do
				{
					flag = type.IsNestedPublic || type.IsPublic || (((object)type.DeclaringType == null || type.IsNestedAssembly || type.IsNestedFamORAssem) && InternalsVisible(type.Assembly));
				}
				while (flag && (object)(type = type.DeclaringType) != null);
				break;
			}
			case MemberTypes.Field:
			{
				FieldInfo fieldInfo = (FieldInfo)member;
				flag = fieldInfo.IsPublic || ((fieldInfo.IsAssembly || fieldInfo.IsFamilyOrAssembly) && InternalsVisible(fieldInfo.DeclaringType.Assembly));
				break;
			}
			case MemberTypes.Constructor:
			{
				ConstructorInfo constructorInfo = (ConstructorInfo)member;
				flag = constructorInfo.IsPublic || ((constructorInfo.IsAssembly || constructorInfo.IsFamilyOrAssembly) && InternalsVisible(constructorInfo.DeclaringType.Assembly));
				break;
			}
			case MemberTypes.Method:
			{
				MethodInfo methodInfo = (MethodInfo)member;
				flag = methodInfo.IsPublic || ((methodInfo.IsAssembly || methodInfo.IsFamilyOrAssembly) && InternalsVisible(methodInfo.DeclaringType.Assembly));
				if (!flag && (member is MethodBuilder || (object)member.DeclaringType == MapType(typeof(TypeModel))))
				{
					flag = true;
				}
				break;
			}
			case MemberTypes.Property:
				flag = true;
				break;
			default:
				throw new NotSupportedException(memberType.ToString());
			}
			if (!flag)
			{
				MemberTypes memberTypes = memberType;
				if (memberTypes == MemberTypes.TypeInfo || memberTypes == MemberTypes.NestedType)
				{
					throw new InvalidOperationException("Non-public type cannot be used with full dll compilation: " + ((Type)member).FullName);
				}
				throw new InvalidOperationException("Non-public member cannot be used with full dll compilation: " + member.DeclaringType.FullName + "." + member.Name);
			}
		}

		public void LoadValue(FieldInfo field)
		{
			CheckAccessibility(field);
			System.Reflection.Emit.OpCode opcode = (field.IsStatic ? System.Reflection.Emit.OpCodes.Ldsfld : System.Reflection.Emit.OpCodes.Ldfld);
			il.Emit(opcode, field);
		}

		public void StoreValue(FieldInfo field)
		{
			CheckAccessibility(field);
			System.Reflection.Emit.OpCode opcode = (field.IsStatic ? System.Reflection.Emit.OpCodes.Stsfld : System.Reflection.Emit.OpCodes.Stfld);
			il.Emit(opcode, field);
		}

		public void LoadValue(PropertyInfo property)
		{
			CheckAccessibility(property);
			EmitCall(Helpers.GetGetMethod(property, nonPublic: true, allowInternal: true));
		}

		public void StoreValue(PropertyInfo property)
		{
			CheckAccessibility(property);
			EmitCall(Helpers.GetSetMethod(property, nonPublic: true, allowInternal: true));
		}

		internal static void LoadValue(ILGenerator il, int value)
		{
			switch (value)
			{
			case 0:
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_0);
				break;
			case 1:
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_1);
				break;
			case 2:
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_2);
				break;
			case 3:
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_3);
				break;
			case 4:
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_4);
				break;
			case 5:
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_5);
				break;
			case 6:
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_6);
				break;
			case 7:
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_7);
				break;
			case 8:
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_8);
				break;
			case -1:
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_M1);
				break;
			default:
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4, value);
				break;
			}
		}

		private bool UseShortForm(Local local)
		{
			return local.Value.LocalIndex < 256;
		}

		internal void LoadAddress(Local local, Type type)
		{
			if (type.IsValueType)
			{
				if (local == null)
				{
					throw new InvalidOperationException("Cannot load the address of a struct at the head of the stack");
				}
				if (local == InputValue)
				{
					il.Emit(System.Reflection.Emit.OpCodes.Ldarga_S, (!isStatic) ? ((byte)1) : ((byte)0));
					return;
				}
				System.Reflection.Emit.OpCode opcode = (UseShortForm(local) ? System.Reflection.Emit.OpCodes.Ldloca_S : System.Reflection.Emit.OpCodes.Ldloca);
				il.Emit(opcode, local.Value);
			}
			else
			{
				LoadValue(local);
			}
		}

		internal void Branch(CodeLabel label, bool @short)
		{
			System.Reflection.Emit.OpCode opcode = (@short ? System.Reflection.Emit.OpCodes.Br_S : System.Reflection.Emit.OpCodes.Br);
			il.Emit(opcode, label.Value);
		}

		internal void BranchIfFalse(CodeLabel label, bool @short)
		{
			System.Reflection.Emit.OpCode opcode = (@short ? System.Reflection.Emit.OpCodes.Brfalse_S : System.Reflection.Emit.OpCodes.Brfalse);
			il.Emit(opcode, label.Value);
		}

		internal void BranchIfTrue(CodeLabel label, bool @short)
		{
			System.Reflection.Emit.OpCode opcode = (@short ? System.Reflection.Emit.OpCodes.Brtrue_S : System.Reflection.Emit.OpCodes.Brtrue);
			il.Emit(opcode, label.Value);
		}

		internal void BranchIfEqual(CodeLabel label, bool @short)
		{
			System.Reflection.Emit.OpCode opcode = (@short ? System.Reflection.Emit.OpCodes.Beq_S : System.Reflection.Emit.OpCodes.Beq);
			il.Emit(opcode, label.Value);
		}

		internal void CopyValue()
		{
			Emit(System.Reflection.Emit.OpCodes.Dup);
		}

		internal void BranchIfGreater(CodeLabel label, bool @short)
		{
			System.Reflection.Emit.OpCode opcode = (@short ? System.Reflection.Emit.OpCodes.Bgt_S : System.Reflection.Emit.OpCodes.Bgt);
			il.Emit(opcode, label.Value);
		}

		internal void BranchIfLess(CodeLabel label, bool @short)
		{
			System.Reflection.Emit.OpCode opcode = (@short ? System.Reflection.Emit.OpCodes.Blt_S : System.Reflection.Emit.OpCodes.Blt);
			il.Emit(opcode, label.Value);
		}

		internal void DiscardValue()
		{
			Emit(System.Reflection.Emit.OpCodes.Pop);
		}

		public void Subtract()
		{
			Emit(System.Reflection.Emit.OpCodes.Sub);
		}

		public void Switch(CodeLabel[] jumpTable)
		{
			if (jumpTable.Length <= 128)
			{
				Label[] array = new Label[jumpTable.Length];
				for (int i = 0; i < array.Length; i++)
				{
					ref Label reference = ref array[i];
					reference = jumpTable[i].Value;
				}
				il.Emit(System.Reflection.Emit.OpCodes.Switch, array);
				return;
			}
			using Local local = GetLocalWithValue(MapType(typeof(int)), null);
			int num = jumpTable.Length;
			int num2 = 0;
			int num3 = num / 128;
			if (num % 128 != 0)
			{
				num3++;
			}
			Label[] array2 = new Label[num3];
			for (int j = 0; j < num3; j++)
			{
				ref Label reference2 = ref array2[j];
				reference2 = il.DefineLabel();
			}
			CodeLabel label = DefineLabel();
			LoadValue(local);
			LoadValue(128);
			Emit(System.Reflection.Emit.OpCodes.Div);
			il.Emit(System.Reflection.Emit.OpCodes.Switch, array2);
			Branch(label, @short: false);
			Label[] array3 = new Label[128];
			for (int k = 0; k < num3; k++)
			{
				il.MarkLabel(array2[k]);
				int num4 = Math.Min(128, num);
				num -= num4;
				if (array3.Length != num4)
				{
					array3 = new Label[num4];
				}
				int num5 = num2;
				for (int l = 0; l < num4; l++)
				{
					ref Label reference3 = ref array3[l];
					reference3 = jumpTable[num2++].Value;
				}
				LoadValue(local);
				if (num5 != 0)
				{
					LoadValue(num5);
					Emit(System.Reflection.Emit.OpCodes.Sub);
				}
				il.Emit(System.Reflection.Emit.OpCodes.Switch, array3);
				if (num != 0)
				{
					Branch(label, @short: false);
				}
			}
			MarkLabel(label);
		}

		internal void EndFinally()
		{
			il.EndExceptionBlock();
		}

		internal void BeginFinally()
		{
			il.BeginFinallyBlock();
		}

		internal void EndTry(CodeLabel label, bool @short)
		{
			System.Reflection.Emit.OpCode opcode = (@short ? System.Reflection.Emit.OpCodes.Leave_S : System.Reflection.Emit.OpCodes.Leave);
			il.Emit(opcode, label.Value);
		}

		internal CodeLabel BeginTry()
		{
			CodeLabel result = new CodeLabel(il.BeginExceptionBlock(), nextLabel++);
			return result;
		}

		internal void Constrain(Type type)
		{
			il.Emit(System.Reflection.Emit.OpCodes.Constrained, type);
		}

		internal void TryCast(Type type)
		{
			il.Emit(System.Reflection.Emit.OpCodes.Isinst, type);
		}

		internal void Cast(Type type)
		{
			il.Emit(System.Reflection.Emit.OpCodes.Castclass, type);
		}

		public IDisposable Using(Local local)
		{
			return new UsingBlock(this, local);
		}

		internal void Add()
		{
			Emit(System.Reflection.Emit.OpCodes.Add);
		}

		internal void LoadLength(Local arr, bool zeroIfNull)
		{
			if (zeroIfNull)
			{
				CodeLabel label = DefineLabel();
				CodeLabel label2 = DefineLabel();
				LoadValue(arr);
				CopyValue();
				BranchIfTrue(label, @short: true);
				DiscardValue();
				LoadValue(0);
				Branch(label2, @short: true);
				MarkLabel(label);
				Emit(System.Reflection.Emit.OpCodes.Ldlen);
				Emit(System.Reflection.Emit.OpCodes.Conv_I4);
				MarkLabel(label2);
			}
			else
			{
				LoadValue(arr);
				Emit(System.Reflection.Emit.OpCodes.Ldlen);
				Emit(System.Reflection.Emit.OpCodes.Conv_I4);
			}
		}

		internal void CreateArray(Type elementType, Local length)
		{
			LoadValue(length);
			il.Emit(System.Reflection.Emit.OpCodes.Newarr, elementType);
		}

		internal void LoadArrayValue(Local arr, Local i)
		{
			Type type = arr.Type;
			type = type.GetElementType();
			LoadValue(arr);
			LoadValue(i);
			switch (Helpers.GetTypeCode(type))
			{
			case ProtoTypeCode.SByte:
				Emit(System.Reflection.Emit.OpCodes.Ldelem_I1);
				return;
			case ProtoTypeCode.Int16:
				Emit(System.Reflection.Emit.OpCodes.Ldelem_I2);
				return;
			case ProtoTypeCode.Int32:
				Emit(System.Reflection.Emit.OpCodes.Ldelem_I4);
				return;
			case ProtoTypeCode.Int64:
				Emit(System.Reflection.Emit.OpCodes.Ldelem_I8);
				return;
			case ProtoTypeCode.Byte:
				Emit(System.Reflection.Emit.OpCodes.Ldelem_U1);
				return;
			case ProtoTypeCode.UInt16:
				Emit(System.Reflection.Emit.OpCodes.Ldelem_U2);
				return;
			case ProtoTypeCode.UInt32:
				Emit(System.Reflection.Emit.OpCodes.Ldelem_U4);
				return;
			case ProtoTypeCode.UInt64:
				Emit(System.Reflection.Emit.OpCodes.Ldelem_I8);
				return;
			case ProtoTypeCode.Single:
				Emit(System.Reflection.Emit.OpCodes.Ldelem_R4);
				return;
			case ProtoTypeCode.Double:
				Emit(System.Reflection.Emit.OpCodes.Ldelem_R8);
				return;
			}
			if (type.IsValueType)
			{
				il.Emit(System.Reflection.Emit.OpCodes.Ldelema, type);
				il.Emit(System.Reflection.Emit.OpCodes.Ldobj, type);
			}
			else
			{
				Emit(System.Reflection.Emit.OpCodes.Ldelem_Ref);
			}
		}

		internal void LoadValue(Type type)
		{
			il.Emit(System.Reflection.Emit.OpCodes.Ldtoken, type);
			EmitCall(MapType(typeof(Type)).GetMethod("GetTypeFromHandle"));
		}

		internal void ConvertToInt32(ProtoTypeCode typeCode, bool uint32Overflow)
		{
			switch (typeCode)
			{
			case ProtoTypeCode.SByte:
			case ProtoTypeCode.Byte:
			case ProtoTypeCode.Int16:
			case ProtoTypeCode.UInt16:
				Emit(System.Reflection.Emit.OpCodes.Conv_I4);
				break;
			case ProtoTypeCode.Int64:
				Emit(System.Reflection.Emit.OpCodes.Conv_Ovf_I4);
				break;
			case ProtoTypeCode.UInt32:
				Emit(uint32Overflow ? System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un : System.Reflection.Emit.OpCodes.Conv_Ovf_I4);
				break;
			case ProtoTypeCode.UInt64:
				Emit(System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un);
				break;
			default:
				throw new InvalidOperationException("ConvertToInt32 not implemented for: " + typeCode);
			case ProtoTypeCode.Int32:
				break;
			}
		}

		internal void ConvertFromInt32(ProtoTypeCode typeCode, bool uint32Overflow)
		{
			switch (typeCode)
			{
			case ProtoTypeCode.SByte:
				Emit(System.Reflection.Emit.OpCodes.Conv_Ovf_I1);
				break;
			case ProtoTypeCode.Byte:
				Emit(System.Reflection.Emit.OpCodes.Conv_Ovf_U1);
				break;
			case ProtoTypeCode.Int16:
				Emit(System.Reflection.Emit.OpCodes.Conv_Ovf_I2);
				break;
			case ProtoTypeCode.UInt16:
				Emit(System.Reflection.Emit.OpCodes.Conv_Ovf_U2);
				break;
			case ProtoTypeCode.UInt32:
				Emit(uint32Overflow ? System.Reflection.Emit.OpCodes.Conv_Ovf_U4 : System.Reflection.Emit.OpCodes.Conv_U4);
				break;
			case ProtoTypeCode.Int64:
				Emit(System.Reflection.Emit.OpCodes.Conv_I8);
				break;
			case ProtoTypeCode.UInt64:
				Emit(System.Reflection.Emit.OpCodes.Conv_U8);
				break;
			default:
				throw new InvalidOperationException();
			case ProtoTypeCode.Int32:
				break;
			}
		}

		internal void LoadValue(decimal value)
		{
			if (value == 0m)
			{
				LoadValue(typeof(decimal).GetField("Zero"));
				return;
			}
			int[] bits = decimal.GetBits(value);
			LoadValue(bits[0]);
			LoadValue(bits[1]);
			LoadValue(bits[2]);
			LoadValue(bits[3] >>> 31);
			LoadValue((bits[3] >> 16) & 0xFF);
			EmitCtor(MapType(typeof(decimal)), MapType(typeof(int)), MapType(typeof(int)), MapType(typeof(int)), MapType(typeof(bool)), MapType(typeof(byte)));
		}

		internal void LoadValue(Guid value)
		{
			if (value == Guid.Empty)
			{
				LoadValue(typeof(Guid).GetField("Empty"));
				return;
			}
			byte[] array = value.ToByteArray();
			int value2 = array[0] | (array[1] << 8) | (array[2] << 16) | (array[3] << 24);
			LoadValue(value2);
			short value3 = (short)(array[4] | (array[5] << 8));
			LoadValue(value3);
			value3 = (short)(array[6] | (array[7] << 8));
			LoadValue(value3);
			for (value2 = 8; value2 <= 15; value2++)
			{
				LoadValue(array[value2]);
			}
			EmitCtor(MapType(typeof(Guid)), MapType(typeof(int)), MapType(typeof(short)), MapType(typeof(short)), MapType(typeof(byte)), MapType(typeof(byte)), MapType(typeof(byte)), MapType(typeof(byte)), MapType(typeof(byte)), MapType(typeof(byte)), MapType(typeof(byte)), MapType(typeof(byte)));
		}

		internal void LoadSerializationContext()
		{
			LoadReaderWriter();
			LoadValue((isWriter ? typeof(ProtoWriter) : typeof(ProtoReader)).GetProperty("Context"));
		}

		internal Type MapType(Type type)
		{
			return model.MapType(type);
		}

		internal bool AllowInternal(PropertyInfo property)
		{
			if (!NonPublic)
			{
				return InternalsVisible(property.DeclaringType.Assembly);
			}
			return true;
		}
	}
	internal sealed class Local : IDisposable
	{
		private LocalBuilder value;

		private CompilerContext ctx;

		private readonly Type type;

		public Type Type => type;

		internal LocalBuilder Value
		{
			get
			{
				if (value == null)
				{
					throw new ObjectDisposedException(GetType().Name);
				}
				return value;
			}
		}

		public Local AsCopy()
		{
			if (ctx == null)
			{
				return this;
			}
			return new Local(value, type);
		}

		public void Dispose()
		{
			if (ctx != null)
			{
				ctx.ReleaseToPool(value);
				value = null;
				ctx = null;
			}
		}

		private Local(LocalBuilder value, Type type)
		{
			this.value = value;
			this.type = type;
		}

		internal Local(CompilerContext ctx, Type type)
		{
			this.ctx = ctx;
			if (ctx != null)
			{
				value = ctx.GetFromPool(type);
			}
			this.type = type;
		}

		internal bool IsSame(Local other)
		{
			if (this == other)
			{
				return true;
			}
			object obj = value;
			if (other != null)
			{
				return obj == other.value;
			}
			return false;
		}
	}
}
namespace ProtoBuf
{
	public enum DataFormat
	{
		Default,
		ZigZag,
		TwosComplement,
		FixedSize,
		Group
	}
	public interface IExtensible
	{
		IExtension GetExtensionObject(bool createIfMissing);
	}
	public abstract class Extensible : IExtensible
	{
		private IExtension extensionObject;

		IExtension IExtensible.GetExtensionObject(bool createIfMissing)
		{
			return GetExtensionObject(createIfMissing);
		}

		protected virtual IExtension GetExtensionObject(bool createIfMissing)
		{
			return GetExtensionObject(ref extensionObject, createIfMissing);
		}

		public static IExtension GetExtensionObject(ref IExtension extensionObject, bool createIfMissing)
		{
			if (createIfMissing && extensionObject == null)
			{
				extensionObject = new BufferExtension();
			}
			return extensionObject;
		}

		public static void AppendValue<TValue>(IExtensible instance, int tag, TValue value)
		{
			AppendValue(instance, tag, DataFormat.Default, value);
		}

		public static void AppendValue<TValue>(IExtensible instance, int tag, DataFormat format, TValue value)
		{
			ExtensibleUtil.AppendExtendValue(RuntimeTypeModel.Default, instance, tag, format, value);
		}

		public static TValue GetValue<TValue>(IExtensible instance, int tag)
		{
			return GetValue<TValue>(instance, tag, DataFormat.Default);
		}

		public static TValue GetValue<TValue>(IExtensible instance, int tag, DataFormat format)
		{
			TryGetValue<TValue>(instance, tag, format, out var value);
			return value;
		}

		public static bool TryGetValue<TValue>(IExtensible instance, int tag, out TValue value)
		{
			return TryGetValue<TValue>(instance, tag, DataFormat.Default, out value);
		}

		public static bool TryGetValue<TValue>(IExtensible instance, int tag, DataFormat format, out TValue value)
		{
			return TryGetValue<TValue>(instance, tag, format, allowDefinedTag: false, out value);
		}

		public static bool TryGetValue<TValue>(IExtensible instance, int tag, DataFormat format, bool allowDefinedTag, out TValue value)
		{
			value = default(TValue);
			bool result = false;
			foreach (TValue extendedValue in ExtensibleUtil.GetExtendedValues<TValue>(instance, tag, format, singleton: true, allowDefinedTag))
			{
				value = extendedValue;
				result = true;
			}
			return result;
		}

		public static IEnumerable<TValue> GetValues<TValue>(IExtensible instance, int tag)
		{
			return ExtensibleUtil.GetExtendedValues<TValue>(instance, tag, DataFormat.Default, singleton: false, allowDefinedTag: false);
		}

		public static IEnumerable<TValue> GetValues<TValue>(IExtensible instance, int tag, DataFormat format)
		{
			return ExtensibleUtil.GetExtendedValues<TValue>(instance, tag, format, singleton: false, allowDefinedTag: false);
		}

		public static bool TryGetValue(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format, bool allowDefinedTag, out object value)
		{
			value = null;
			bool result = false;
			foreach (object extendedValue in ExtensibleUtil.GetExtendedValues(model, type, instance, tag, format, singleton: true, allowDefinedTag))
			{
				value = extendedValue;
				result = true;
			}
			return result;
		}

		public static IEnumerable GetValues(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format)
		{
			return ExtensibleUtil.GetExtendedValues(model, type, instance, tag, format, singleton: false, allowDefinedTag: false);
		}

		public static void AppendValue(TypeModel model, IExtensible instance, int tag, DataFormat format, object value)
		{
			ExtensibleUtil.AppendExtendValue(model, instance, tag, format, value);
		}
	}
	internal static class ExtensibleUtil
	{
		internal static IEnumerable<TValue> GetExtendedValues<TValue>(IExtensible instance, int tag, DataFormat format, bool singleton, bool allowDefinedTag)
		{
			foreach (TValue extendedValue in GetExtendedValues(RuntimeTypeModel.Default, typeof(TValue), instance, tag, format, singleton, allowDefinedTag))
			{
				yield return extendedValue;
			}
		}

		internal static IEnumerable GetExtendedValues(TypeModel model, Type type, IExtensible instance, int tag, DataFormat format, bool singleton, bool allowDefinedTag)
		{
			if (instance == null)
			{
				throw new ArgumentNullException("instance");
			}
			if (tag <= 0)
			{
				throw new ArgumentOutOfRangeException("tag");
			}
			IExtension extn = instance.GetExtensionObject(createIfMissing: false);
			if (extn == null)
			{
				yield break;
			}
			Stream stream = extn.BeginQuery();
			object value = null;
			ProtoReader reader = null;
			try
			{
				SerializationContext ctx = new SerializationContext();
				reader = ProtoReader.Create(stream, model, ctx, -1);
				while (model.TryDeserializeAuxiliaryType(reader, format, tag, type, ref value, skipOtherFields: true, asListItem: false, autoCreate: false, insideList: false) && value != null)
				{
					if (!singleton)
					{
						yield return value;
						value = null;
					}
				}
				if (singleton && value != null)
				{
					yield return value;
				}
			}
			finally
			{
				ProtoReader.Recycle(reader);
				extn.EndQuery(stream);
			}
		}

		internal static void AppendExtendValue(TypeModel model, IExtensible instance, int tag, DataFormat format, object value)
		{
			if (instance == null)
			{
				throw new ArgumentNullException("instance");
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			IExtension extensionObject = instance.GetExtensionObject(createIfMissing: true);
			if (extensionObject == null)
			{
				throw new InvalidOperationException("No extension object available; appended data would be lost.");
			}
			bool commit = false;
			Stream stream = extensionObject.BeginAppend();
			try
			{
				using (ProtoWriter protoWriter = new ProtoWriter(stream, model, null))
				{
					model.TrySerializeAuxiliaryType(protoWriter, null, format, tag, value, isInsideList: false);
					protoWriter.Close();
				}
				commit = true;
			}
			finally
			{
				extensionObject.EndAppend(stream, commit);
			}
		}
	}
	internal sealed class Helpers
	{
		public static readonly Type[] EmptyTypes = Type.EmptyTypes;

		private Helpers()
		{
		}

		public static StringBuilder AppendLine(StringBuilder builder)
		{
			return builder.AppendLine();
		}

		public static bool IsNullOrEmpty(string value)
		{
			if (value != null)
			{
				return value.Length == 0;
			}
			return true;
		}

		[Conditional("DEBUG")]
		public static void DebugWriteLine(string message, object obj)
		{
		}

		[Conditional("DEBUG")]
		public static void DebugWriteLine(string message)
		{
		}

		[Conditional("TRACE")]
		public static void TraceWriteLine(string message)
		{
			Trace.WriteLine(message);
		}

		[Conditional("DEBUG")]
		public static void DebugAssert(bool condition, string message)
		{
		}

		[Conditional("DEBUG")]
		public static void DebugAssert(bool condition, string message, params object[] args)
		{
		}

		[Conditional("DEBUG")]
		public static void DebugAssert(bool condition)
		{
		}

		public static void Sort(int[] keys, object[] values)
		{
			bool flag;
			do
			{
				flag = false;
				for (int i = 1; i < keys.Length; i++)
				{
					if (keys[i - 1] > keys[i])
					{
						int num = keys[i];
						keys[i] = keys[i - 1];
						keys[i - 1] = num;
						object obj = values[i];
						values[i] = values[i - 1];
						values[i - 1] = obj;
						flag = true;
					}
				}
			}
			while (flag);
		}

		public static void BlockCopy(byte[] from, int fromIndex, byte[] to, int toIndex, int count)
		{
			Buffer.BlockCopy(from, fromIndex, to, toIndex, count);
		}

		public static bool IsInfinity(float value)
		{
			return float.IsInfinity(value);
		}

		internal static MethodInfo GetInstanceMethod(Type declaringType, string name)
		{
			return declaringType.GetMethod(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		}

		internal static MethodInfo GetStaticMethod(Type declaringType, string name)
		{
			return declaringType.GetMethod(name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
		}

		internal static MethodInfo GetInstanceMethod(Type declaringType, string name, Type[] types)
		{
			if (types == null)
			{
				types = EmptyTypes;
			}
			return declaringType.GetMethod(name, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, types, null);
		}

		internal static bool IsSubclassOf(Type type, Type baseClass)
		{
			return type.IsSubclassOf(baseClass);
		}

		public static bool IsInfinity(double value)
		{
			return double.IsInfinity(value);
		}

		public static ProtoTypeCode GetTypeCode(Type type)
		{
			TypeCode typeCode = Type.GetTypeCode(type);
			switch (typeCode)
			{
			case TypeCode.Empty:
			case TypeCode.Boolean:
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
			case TypeCode.Int64:
			case TypeCode.UInt64:
			case TypeCode.Single:
			case TypeCode.Double:
			case TypeCode.Decimal:
			case TypeCode.DateTime:
			case TypeCode.String:
				return (ProtoTypeCode)typeCode;
			default:
				if ((object)type == typeof(TimeSpan))
				{
					return ProtoTypeCode.TimeSpan;
				}
				if ((object)type == typeof(Guid))
				{
					return ProtoTypeCode.Guid;
				}
				if ((object)type == typeof(Uri))
				{
					return ProtoTypeCode.Uri;
				}
				if ((object)type == typeof(byte[]))
				{
					return ProtoTypeCode.ByteArray;
				}
				if ((object)type == typeof(Type))
				{
					return ProtoTypeCode.Type;
				}
				return ProtoTypeCode.Unknown;
			}
		}

		internal static Type GetUnderlyingType(Type type)
		{
			return Nullable.GetUnderlyingType(type);
		}

		internal static bool IsValueType(Type type)
		{
			return type.IsValueType;
		}

		internal static bool IsEnum(Type type)
		{
			return type.IsEnum;
		}

		internal static MethodInfo GetGetMethod(PropertyInfo property, bool nonPublic, bool allowInternal)
		{
			if ((object)property == null)
			{
				return null;
			}
			MethodInfo methodInfo = property.GetGetMethod(nonPublic);
			if ((object)methodInfo == null && !nonPublic && allowInternal)
			{
				methodInfo = property.GetGetMethod(nonPublic: true);
				if ((object)methodInfo == null && !methodInfo.IsAssembly && !methodInfo.IsFamilyOrAssembly)
				{
					methodInfo = null;
				}
			}
			return methodInfo;
		}

		internal static MethodInfo GetSetMethod(PropertyInfo property, bool nonPublic, bool allowInternal)
		{
			if ((object)property == null)
			{
				return null;
			}
			MethodInfo methodInfo = property.GetSetMethod(nonPublic);
			if ((object)methodInfo == null && !nonPublic && allowInternal)
			{
				methodInfo = property.GetGetMethod(nonPublic: true);
				if ((object)methodInfo == null && !methodInfo.IsAssembly && !methodInfo.IsFamilyOrAssembly)
				{
					methodInfo = null;
				}
			}
			return methodInfo;
		}

		internal static ConstructorInfo GetConstructor(Type type, Type[] parameterTypes, bool nonPublic)
		{
			return type.GetConstructor(nonPublic ? (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) : (BindingFlags.Instance | BindingFlags.Public), null, parameterTypes, null);
		}

		internal static ConstructorInfo[] GetConstructors(Type type, bool nonPublic)
		{
			return type.GetConstructors(nonPublic ? (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) : (BindingFlags.Instance | BindingFlags.Public));
		}

		internal static PropertyInfo GetProperty(Type type, string name, bool nonPublic)
		{
			return type.GetProperty(name, nonPublic ? (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic) : (BindingFlags.Instance | BindingFlags.Public));
		}

		internal static object ParseEnum(Type type, string value)
		{
			return Enum.Parse(type, value, ignoreCase: true);
		}

		internal static MemberInfo[] GetInstanceFieldsAndProperties(Type type, bool publicOnly)
		{
			BindingFlags bindingAttr = (publicOnly ? (BindingFlags.Instance | BindingFlags.Public) : (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
			PropertyInfo[] properties = type.GetProperties(bindingAttr);
			FieldInfo[] fields = type.GetFields(bindingAttr);
			MemberInfo[] array = new MemberInfo[fields.Length + properties.Length];
			properties.CopyTo(array, 0);
			fields.CopyTo(array, properties.Length);
			return array;
		}

		internal static Type GetMemberType(MemberInfo member)
		{
			return member.MemberType switch
			{
				MemberTypes.Field => ((FieldInfo)member).FieldType, 
				MemberTypes.Property => ((PropertyInfo)member).PropertyType, 
				_ => null, 
			};
		}

		internal static bool IsAssignableFrom(Type target, Type type)
		{
			return target.IsAssignableFrom(type);
		}
	}
	internal enum ProtoTypeCode
	{
		Empty = 0,
		Unknown = 1,
		Boolean = 3,
		Char = 4,
		SByte = 5,
		Byte = 6,
		Int16 = 7,
		UInt16 = 8,
		Int32 = 9,
		UInt32 = 10,
		Int64 = 11,
		UInt64 = 12,
		Single = 13,
		Double = 14,
		Decimal = 15,
		DateTime = 16,
		String = 18,
		TimeSpan = 100,
		ByteArray = 101,
		Guid = 102,
		Uri = 103,
		Type = 104
	}
	public enum ImplicitFields
	{
		None,
		AllPublic,
		AllFields
	}
}
namespace ProtoBuf.Meta
{
	internal abstract class AttributeMap
	{
		private sealed class ReflectionAttributeMap : AttributeMap
		{
			private readonly Attribute attribute;

			public override object Target => attribute;

			public override Type AttributeType => attribute.GetType();

			public override bool TryGet(string key, bool publicOnly, out object value)
			{
				MemberInfo[] instanceFieldsAndProperties = Helpers.GetInstanceFieldsAndProperties(attribute.GetType(), publicOnly);
				MemberInfo[] array = instanceFieldsAndProperties;
				foreach (MemberInfo memberInfo in array)
				{
					if (string.Equals(memberInfo.Name, key, StringComparison.OrdinalIgnoreCase))
					{
						if (memberInfo is PropertyInfo propertyInfo)
						{
							value = propertyInfo.GetValue(attribute, null);
							return true;
						}
						if (memberInfo is FieldInfo fieldInfo)
						{
							value = fieldInfo.GetValue(attribute);
							return true;
						}
						throw new NotSupportedException(memberInfo.GetType().Name);
					}
				}
				value = null;
				return false;
			}

			public ReflectionAttributeMap(Attribute attribute)
			{
				this.attribute = attribute;
			}
		}

		public abstract Type AttributeType { get; }

		public abstract object Target { get; }

		public abstract bool TryGet(string key, bool publicOnly, out object value);

		public bool TryGet(string key, out object value)
		{
			return TryGet(key, publicOnly: true, out value);
		}

		public static AttributeMap[] Create(TypeModel model, Type type, bool inherit)
		{
			object[] customAttributes = type.GetCustomAttributes(inherit);
			AttributeMap[] array = new AttributeMap[customAttributes.Length];
			for (int i = 0; i < customAttributes.Length; i++)
			{
				array[i] = new ReflectionAttributeMap((Attribute)customAttributes[i]);
			}
			return array;
		}

		public static AttributeMap[] Create(TypeModel model, MemberInfo member, bool inherit)
		{
			object[] customAttributes = member.GetCustomAttributes(inherit);
			AttributeMap[] array = new AttributeMap[customAttributes.Length];
			for (int i = 0; i < customAttributes.Length; i++)
			{
				array[i] = new ReflectionAttributeMap((Attribute)customAttributes[i]);
			}
			return array;
		}

		public static AttributeMap[] Create(TypeModel model, Assembly assembly)
		{
			object[] customAttributes = assembly.GetCustomAttributes(inherit: false);
			AttributeMap[] array = new AttributeMap[customAttributes.Length];
			for (int i = 0; i < customAttributes.Length; i++)
			{
				array[i] = new ReflectionAttributeMap((Attribute)customAttributes[i]);
			}
			return array;
		}
	}
	internal class BasicList : IEnumerable
	{
		public struct NodeEnumerator : IEnumerator
		{
			private int position;

			private readonly Node node;

			public object Current => node[position];

			internal NodeEnumerator(Node node)
			{
				position = -1;
				this.node = node;
			}

			void IEnumerator.Reset()
			{
				position = -1;
			}

			public bool MoveNext()
			{
				int length = node.Length;
				if (position <= length)
				{
					return ++position < length;
				}
				return false;
			}
		}

		internal sealed class Node
		{
			private readonly object[] data;

			private int length;

			public object this[int index]
			{
				get
				{
					if (index >= 0 && index < length)
					{
						return data[index];
					}
					throw new ArgumentOutOfRangeException("index");
				}
				set
				{
					if (index >= 0 && index < length)
					{
						data[index] = value;
						return;
					}
					throw new ArgumentOutOfRangeException("index");
				}
			}

			public int Length => length;

			internal Node(object[] data, int length)
			{
				this.data = data;
				this.length = length;
			}

			public void RemoveLastWithMutate()
			{
				if (length == 0)
				{
					throw new InvalidOperationException();
				}
				length--;
			}

			public Node Append(object value)
			{
				int num = length + 1;
				object[] array;
				if (data == null)
				{
					array = new object[10];
				}
				else if (length == data.Length)
				{
					array = new object[data.Length * 2];
					Array.Copy(data, array, length);
				}
				else
				{
					array = data;
				}
				array[length] = value;
				return new Node(array, num);
			}

			public Node Trim()
			{
				if (length == 0 || length == data.Length)
				{
					return this;
				}
				object[] destinationArray = new object[length];
				Array.Copy(data, destinationArray, length);
				return new Node(destinationArray, length);
			}

			internal int IndexOfString(string value)
			{
				for (int i = 0; i < length; i++)
				{
					if (value == (string)data[i])
					{
						return i;
					}
				}
				return -1;
			}

			internal int IndexOfReference(object instance)
			{
				for (int i = 0; i < length; i++)
				{
					if (instance == data[i])
					{
						return i;
					}
				}
				return -1;
			}

			internal int IndexOf(MatchPredicate predicate, object ctx)
			{
				for (int i = 0; i < length; i++)
				{
					if (predicate(data[i], ctx))
					{
						return i;
					}
				}
				return -1;
			}

			internal void CopyTo(Array array, int offset)
			{
				if (length > 0)
				{
					Array.Copy(data, 0, array, offset, length);
				}
			}

			internal void Clear()
			{
				if (data != null)
				{
					Array.Clear(data, 0, data.Length);
				}
				length = 0;
			}
		}

		internal delegate bool MatchPredicate(object value, object ctx);

		internal sealed class Group
		{
			public readonly int First;

			public readonly BasicList Items;

			public Group(int first)
			{
				First = first;
				Items = new BasicList();
			}
		}

		private static readonly Node nil = new Node(null, 0);

		protected Node head = nil;

		public object this[int index] => head[index];

		public int Count => head.Length;

		public void CopyTo(Array array, int offset)
		{
			head.CopyTo(array, offset);
		}

		public int Add(object value)
		{
			return (head = head.Append(value)).Length - 1;
		}

		public void Trim()
		{
			head = head.Trim();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return new NodeEnumerator(head);
		}

		public NodeEnumerator GetEnumerator()
		{
			return new NodeEnumerator(head);
		}

		internal int IndexOf(MatchPredicate predicate, object ctx)
		{
			return head.IndexOf(predicate, ctx);
		}

		internal int IndexOfString(string value)
		{
			return head.IndexOfString(value);
		}

		internal int IndexOfReference(object instance)
		{
			return head.IndexOfReference(instance);
		}

		internal bool Contains(object value)
		{
			NodeEnumerator enumerator = GetEnumerator();
			while (enumerator.MoveNext())
			{
				object current = enumerator.Current;
				if (object.Equals(current, value))
				{
					return true;
				}
			}
			return false;
		}

		internal static BasicList GetContiguousGroups(int[] keys, object[] values)
		{
			if (keys == null)
			{
				throw new ArgumentNullException("keys");
			}
			if (values == null)
			{
				throw new ArgumentNullException("values");
			}
			if (values.Length < keys.Length)
			{
				throw new ArgumentException("Not all keys are covered by values", "values");
			}
			BasicList basicList = new BasicList();
			Group obj = null;
			for (int i = 0; i < keys.Length; i++)
			{
				if (i == 0 || keys[i] != keys[i - 1])
				{
					obj = null;
				}
				if (obj == null)
				{
					obj = new Group(keys[i]);
					basicList.Add(obj);
				}
				obj.Items.Add(values[i]);
			}
			return basicList;
		}
	}
	internal sealed class MutableList : BasicList
	{
		public new object this[int index]
		{
			get
			{
				return head[index];
			}
			set
			{
				head[index] = value;
			}
		}

		public void RemoveLast()
		{
			head.RemoveLastWithMutate();
		}

		public void Clear()
		{
			head.Clear();
		}
	}
	public class CallbackSet
	{
		private readonly MetaType metaType;

		private MethodInfo beforeSerialize;

		private MethodInfo afterSerialize;

		private MethodInfo beforeDeserialize;

		private MethodInfo afterDeserialize;

		internal MethodInfo this[TypeModel.CallbackType callbackType] => callbackType switch
		{
			TypeModel.CallbackType.BeforeSerialize => beforeSerialize, 
			TypeModel.CallbackType.AfterSerialize => afterSerialize, 
			TypeModel.CallbackType.BeforeDeserialize => beforeDeserialize, 
			TypeModel.CallbackType.AfterDeserialize => afterDeserialize, 
			_ => throw new ArgumentException("Callback type not supported: " + callbackType, "callbackType"), 
		};

		public MethodInfo BeforeSerialize
		{
			get
			{
				return beforeSerialize;
			}
			set
			{
				beforeSerialize = SanityCheckCallback(metaType.Model, value);
			}
		}

		public MethodInfo BeforeDeserialize
		{
			get
			{
				return beforeDeserialize;
			}
			set
			{
				beforeDeserialize = SanityCheckCallback(metaType.Model, value);
			}
		}

		public MethodInfo AfterSerialize
		{
			get
			{
				return afterSerialize;
			}
			set
			{
				afterSerialize = SanityCheckCallback(metaType.Model, value);
			}
		}

		public MethodInfo AfterDeserialize
		{
			get
			{
				return afterDeserialize;
			}
			set
			{
				afterDeserialize = SanityCheckCallback(metaType.Model, value);
			}
		}

		public bool NonTrivial
		{
			get
			{
				if ((object)beforeSerialize == null && (object)beforeDeserialize == null && (object)afterSerialize == null)
				{
					return (object)afterDeserialize != null;
				}
				return true;
			}
		}

		internal CallbackSet(MetaType metaType)
		{
			if (metaType == null)
			{
				throw new ArgumentNullException("metaType");
			}
			this.metaType = metaType;
		}

		internal static bool CheckCallbackParameters(TypeModel model, MethodInfo method)
		{
			ParameterInfo[] parameters = method.GetParameters();
			for (int i = 0; i < parameters.Length; i++)
			{
				Type parameterType = parameters[i].ParameterType;
				if ((object)parameterType != model.MapType(typeof(SerializationContext)) && (object)parameterType != model.MapType(typeof(Type)) && (object)parameterType != model.MapType(typeof(StreamingContext)))
				{
					return false;
				}
			}
			return true;
		}

		private MethodInfo SanityCheckCallback(TypeModel model, MethodInfo callback)
		{
			metaType.ThrowIfFrozen();
			if ((object)callback == null)
			{
				return callback;
			}
			if (callback.IsStatic)
			{
				throw new ArgumentException("Callbacks cannot be static", "callback");
			}
			if ((object)callback.ReturnType != model.MapType(typeof(void)) || !CheckCallbackParameters(model, callback))
			{
				throw CreateInvalidCallbackSignature(callback);
			}
			return callback;
		}

		internal static Exception CreateInvalidCallbackSignature(MethodInfo method)
		{
			return new NotSupportedException("Invalid callback signature in " + method.DeclaringType.FullName + "." + method.Name);
		}
	}
}
namespace ProtoBuf.Serializers
{
	internal interface ISerializerProxy
	{
		IProtoSerializer Serializer { get; }
	}
}
namespace ProtoBuf.Meta
{
	public class MetaType : ISerializerProxy
	{
		internal sealed class Comparer : IComparer, IComparer<MetaType>
		{
			public static readonly Comparer Default = new Comparer();

			public int Compare(object x, object y)
			{
				return Compare(x as MetaType, y as MetaType);
			}

			public int Compare(MetaType x, MetaType y)
			{
				if (object.ReferenceEquals(x, y))
				{
					return 0;
				}
				if (x == null)
				{
					return -1;
				}
				if (y == null)
				{
					return 1;
				}
				return string.Compare(x.GetSchemaTypeName(), y.GetSchemaTypeName(), StringComparison.Ordinal);
			}
		}

		[Flags]
		internal enum AttributeFamily
		{
			None = 0,
			ProtoBuf = 1,
			DataContractSerialier = 2,
			XmlSerializer = 4,
			AutoTuple = 8
		}

		private const byte OPTIONS_Pending = 1;

		private const byte OPTIONS_EnumPassThru = 2;

		private const byte OPTIONS_Frozen = 4;

		private const byte OPTIONS_PrivateOnApi = 8;

		private const byte OPTIONS_SkipConstructor = 16;

		private const byte OPTIONS_AsReferenceDefault = 32;

		private const byte OPTIONS_AutoTuple = 64;

		private const byte OPTIONS_IgnoreListHandling = 128;

		private MetaType baseType;

		private BasicList subTypes;

		internal static readonly Type ienumerable = typeof(IEnumerable);

		private CallbackSet callbacks;

		private string name;

		private MethodInfo factory;

		private readonly RuntimeTypeModel model;

		private readonly Type type;

		private IProtoTypeSerializer serializer;

		private Type constructType;

		private Type surrogate;

		private readonly BasicList fields = new BasicList();

		private volatile byte flags;

		IProtoSerializer ISerializerProxy.Serializer => Serializer;

		public MetaType BaseType => baseType;

		internal TypeModel Model => model;

		public bool IncludeSerializerMethod
		{
			get
			{
				return !HasFlag(8);
			}
			set
			{
				SetFlag(8, !value, throwIfFrozen: true);
			}
		}

		public bool AsReferenceDefault
		{
			get
			{
				return HasFlag(32);
			}
			set
			{
				SetFlag(32, value, throwIfFrozen: true);
			}
		}

		public bool HasCallbacks
		{
			get
			{
				if (callbacks != null)
				{
					return callbacks.NonTrivial;
				}
				return false;
			}
		}

		public bool HasSubtypes
		{
			get
			{
				if (subTypes != null)
				{
					return subTypes.Count != 0;
				}
				return false;
			}
		}

		public CallbackSet Callbacks
		{
			get
			{
				if (callbacks == null)
				{
					callbacks = new CallbackSet(this);
				}
				return callbacks;
			}
		}

		private bool IsValueType => type.IsValueType;

		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				ThrowIfFrozen();
				name = value;
			}
		}

		public Type Type => type;

		internal IProtoTypeSerializer Serializer
		{
			get
			{
				if (serializer == null)
				{
					int opaqueToken = 0;
					try
					{
						model.TakeLock(ref opaqueToken);
						if (serializer == null)
						{
							SetFlag(4, value: true, throwIfFrozen: false);
							serializer = BuildSerializer();
							if (model.AutoCompile)
							{
								CompileInPlace();
							}
						}
					}
					finally
					{
						model.ReleaseLock(opaqueToken);
					}
				}
				return serializer;
			}
		}

		internal bool IsList
		{
			get
			{
				Type type = (IgnoreListHandling ? null : TypeModel.GetListItemType(model, this.type));
				return (object)type != null;
			}
		}

		public bool UseConstructor
		{
			get
			{
				return !HasFlag(16);
			}
			set
			{
				SetFlag(16, !value, throwIfFrozen: true);
			}
		}

		public Type ConstructType
		{
			get
			{
				return constructType;
			}
			set
			{
				ThrowIfFrozen();
				constructType = value;
			}
		}

		public ValueMember this[int fieldNumber]
		{
			get
			{
				BasicList.NodeEnumerator enumerator = fields.GetEnumerator();
				while (enumerator.MoveNext())
				{
					ValueMember valueMember = (ValueMember)enumerator.Current;
					if (valueMember.FieldNumber == fieldNumber)
					{
						return valueMember;
					}
				}
				return null;
			}
		}

		public ValueMember this[MemberInfo member]
		{
			get
			{
				if ((object)member == null)
				{
					return null;
				}
				BasicList.NodeEnumerator enumerator = fields.GetEnumerator();
				while (enumerator.MoveNext())
				{
					ValueMember valueMember = (ValueMember)enumerator.Current;
					if ((object)valueMember.Member == member)
					{
						return valueMember;
					}
				}
				return null;
			}
		}

		public bool EnumPassthru
		{
			get
			{
				return HasFlag(2);
			}
			set
			{
				SetFlag(2, value, throwIfFrozen: true);
			}
		}

		public bool IgnoreListHandling
		{
			get
			{
				return HasFlag(128);
			}
			set
			{
				SetFlag(128, value, throwIfFrozen: true);
			}
		}

		internal bool Pending
		{
			get
			{
				return HasFlag(1);
			}
			set
			{
				SetFlag(1, value, throwIfFrozen: false);
			}
		}

		internal IEnumerable Fields => fields;

		internal bool IsAutoTuple => HasFlag(64);

		public override string ToString()
		{
			return type.ToString();
		}

		private bool IsValidSubType(Type subType)
		{
			return type.IsAssignableFrom(subType);
		}

		public MetaType AddSubType(int fieldNumber, Type derivedType)
		{
			return AddSubType(fieldNumber, derivedType, DataFormat.Default);
		}

		public MetaType AddSubType(int fieldNumber, Type derivedType, DataFormat dataFormat)
		{
			if ((object)derivedType == null)
			{
				throw new ArgumentNullException("derivedType");
			}
			if (fieldNumber < 1)
			{
				throw new ArgumentOutOfRangeException("fieldNumber");
			}
			if ((!type.IsClass && !type.IsInterface) || type.IsSealed)
			{
				throw new InvalidOperationException("Sub-types can only be added to non-sealed classes");
			}
			if (!IsValidSubType(derivedType))
			{
				throw new ArgumentException(derivedType.Name + " is not a valid sub-type of " + type.Name, "derivedType");
			}
			MetaType metaType = model[derivedType];
			ThrowIfFrozen();
			metaType.ThrowIfFrozen();
			SubType value = new SubType(fieldNumber, metaType, dataFormat);
			ThrowIfFrozen();
			metaType.SetBaseType(this);
			if (subTypes == null)
			{
				subTypes = new BasicList();
			}
			subTypes.Add(value);
			return this;
		}

		private void SetBaseType(MetaType baseType)
		{
			if (baseType == null)
			{
				throw new ArgumentNullException("baseType");
			}
			if (this.baseType == baseType)
			{
				return;
			}
			if (this.baseType != null)
			{
				throw new InvalidOperationException("A type can only participate in one inheritance hierarchy");
			}
			for (MetaType metaType = baseType; metaType != null; metaType = metaType.baseType)
			{
				if (object.ReferenceEquals(metaType, this))
				{
					throw new InvalidOperationException("Cyclic inheritance is not allowed");
				}
			}
			this.baseType = baseType;
		}

		public MetaType SetCallbacks(MethodInfo beforeSerialize, MethodInfo afterSerialize, MethodInfo beforeDeserialize, MethodInfo afterDeserialize)
		{
			CallbackSet callbackSet = Callbacks;
			callbackSet.BeforeSerialize = beforeSerialize;
			callbackSet.AfterSerialize = afterSerialize;
			callbackSet.BeforeDeserialize = beforeDeserialize;
			callbackSet.AfterDeserialize = afterDeserialize;
			return this;
		}

		public MetaType SetCallbacks(string beforeSerialize, string afterSerialize, string beforeDeserialize, string afterDeserialize)
		{
			if (IsValueType)
			{
				throw new InvalidOperationException();
			}
			CallbackSet callbackSet = Callbacks;
			callbackSet.BeforeSerialize = ResolveMethod(beforeSerialize, instance: true);
			callbackSet.AfterSerialize = ResolveMethod(afterSerialize, instance: true);
			callbackSet.BeforeDeserialize = ResolveMethod(beforeDeserialize, instance: true);
			callbackSet.AfterDeserialize = ResolveMethod(afterDeserialize, instance: true);
			return this;
		}

		internal string GetSchemaTypeName()
		{
			if ((object)surrogate != null)
			{
				return model[surrogate].GetSchemaTypeName();
			}
			if (!Helpers.IsNullOrEmpty(name))
			{
				return name;
			}
			string text = this.type.Name;
			if (this.type.IsGenericType)
			{
				StringBuilder stringBuilder = new StringBuilder(text);
				int num = text.IndexOf('`');
				if (num >= 0)
				{
					stringBuilder.Length = num;
				}
				Type[] genericArguments = this.type.GetGenericArguments();
				foreach (Type type in genericArguments)
				{
					stringBuilder.Append('_');
					Type type2 = type;
					int key = model.GetKey(ref type2);
					MetaType metaType;
					if (key >= 0 && (metaType = model[type2]) != null && (object)metaType.surrogate == null)
					{
						stringBuilder.Append(metaType.GetSchemaTypeName());
					}
					else
					{
						stringBuilder.Append(type2.Name);
					}
				}
				return stringBuilder.ToString();
			}
			return text;
		}

		public MetaType SetFactory(MethodInfo factory)
		{
			model.VerifyFactory(factory, type);
			ThrowIfFrozen();
			this.factory = factory;
			return this;
		}

		public MetaType SetFactory(string factory)
		{
			return SetFactory(ResolveMethod(factory, instance: false));
		}

		private MethodInfo ResolveMethod(string name, bool instance)
		{
			if (Helpers.IsNullOrEmpty(name))
			{
				return null;
			}
			if (!instance)
			{
				return Helpers.GetStaticMethod(type, name);
			}
			return Helpers.GetInstanceMethod(type, name);
		}

		internal static Exception InbuiltType(Type type)
		{
			return new ArgumentException("Data of this type has inbuilt behaviour, and cannot be added to a model in this way: " + type.FullName);
		}

		internal MetaType(RuntimeTypeModel model, Type type, MethodInfo factory)
		{
			this.factory = factory;
			if (model == null)
			{
				throw new ArgumentNullException("model");
			}
			if ((object)type == null)
			{
				throw new ArgumentNullException("type");
			}
			IProtoSerializer protoSerializer = model.TryGetBasicTypeSerializer(type);
			if (protoSerializer != null)
			{
				throw InbuiltType(type);
			}
			this.type = type;
			this.model = model;
			if (Helpers.IsEnum(type))
			{
				EnumPassthru = type.IsDefined(model.MapType(typeof(FlagsAttribute)), inherit: false);
			}
		}

		protected internal void ThrowIfFrozen()
		{
			if ((flags & 4) != 0)
			{
				throw new InvalidOperationException("The type cannot be changed once a serializer has been generated for " + type.FullName);
			}
		}

		private IProtoTypeSerializer BuildSerializer()
		{
			if (Helpers.IsEnum(type))
			{
				return new TagDecorator(1, WireType.Variant, strict: false, new EnumSerializer(type, GetEnumMap()));
			}
			Type itemType = (IgnoreListHandling ? null : TypeModel.GetListItemType(model, type));
			if ((object)itemType != null)
			{
				if ((object)surrogate != null)
				{
					throw new ArgumentException("Repeated data (a list, collection, etc) has inbuilt behaviour and cannot use a surrogate");
				}
				if (subTypes != null && subTypes.Count != 0)
				{
					throw new ArgumentException("Repeated data (a list, collection, etc) has inbuilt behaviour and cannot be subclassed");
				}
				Type defaultType = null;
				ResolveListTypes(model, type, ref itemType, ref defaultType);
				ValueMember valueMember = new ValueMember(model, 1, type, itemType, defaultType, DataFormat.Default);
				return new TypeSerializer(model, type, new int[1] { 1 }, new IProtoSerializer[1] { valueMember.Serializer }, null, isRootType: true, useConstructor: true, null, constructType, factory);
			}
			if ((object)surrogate != null)
			{
				MetaType metaType = model[surrogate];
				MetaType metaType2;
				while ((metaType2 = metaType.baseType) != null)
				{
					metaType = metaType2;
				}
				return new SurrogateSerializer(type, surrogate, metaType.Serializer);
			}
			if (IsAutoTuple)
			{
				MemberInfo[] mappedMembers;
				ConstructorInfo constructorInfo = ResolveTupleConstructor(type, out mappedMembers);
				if ((object)constructorInfo == null)
				{
					throw new InvalidOperationException();
				}
				return new TupleSerializer(model, constructorInfo, mappedMembers);
			}
			fields.Trim();
			int count = fields.Count;
			int num = ((subTypes != null) ? subTypes.Count : 0);
			int[] array = new int[count + num];
			IProtoSerializer[] array2 = new IProtoSerializer[count + num];
			int num2 = 0;
			if (num != 0)
			{
				BasicList.NodeEnumerator enumerator = subTypes.GetEnumerator();
				while (enumerator.MoveNext())
				{
					SubType subType = (SubType)enumerator.Current;
					if (!subType.DerivedType.IgnoreListHandling && model.MapType(ienumerable).IsAssignableFrom(subType.DerivedType.Type))
					{
						throw new ArgumentException("Repeated data (a list, collection, etc) has inbuilt behaviour and cannot be used as a subclass");
					}
					array[num2] = subType.FieldNumber;
					array2[num2++] = subType.Serializer;
				}
			}
			if (count != 0)
			{
				BasicList.NodeEnumerator enumerator2 = fields.GetEnumerator();
				while (enumerator2.MoveNext())
				{
					ValueMember valueMember2 = (ValueMember)enumerator2.Current;
					array[num2] = valueMember2.FieldNumber;
					array2[num2++] = valueMember2.Serializer;
				}
			}
			BasicList basicList = null;
			for (MetaType metaType3 = BaseType; metaType3 != null; metaType3 = metaType3.BaseType)
			{
				MethodInfo methodInfo = (metaType3.HasCallbacks ? metaType3.Callbacks.BeforeDeserialize : null);
				if ((object)methodInfo != null)
				{
					if (basicList == null)
					{
						basicList = new BasicList();
					}
					basicList.Add(methodInfo);
				}
			}
			MethodInfo[] array3 = null;
			if (basicList != null)
			{
				array3 = new MethodInfo[basicList.Count];
				basicList.CopyTo(array3, 0);
				Array.Reverse((Array)array3);
			}
			return new TypeSerializer(model, type, array, array2, array3, baseType == null, UseConstructor, callbacks, constructType, factory);
		}

		private static Type GetBaseType(MetaType type)
		{
			return type.type.BaseType;
		}

		internal static bool GetAsReferenceDefault(RuntimeTypeModel model, Type type)
		{
			if ((object)type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (Helpers.IsEnum(type))
			{
				return false;
			}
			AttributeMap[] array = AttributeMap.Create(model, type, inherit: false);
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].AttributeType.FullName == "ProtoBuf.ProtoContractAttribute" && array[i].TryGet("AsReferenceDefault", out var value))
				{
					return (bool)value;
				}
			}
			return false;
		}

		internal void ApplyDefaultBehaviour()
		{
			Type type = GetBaseType(this);
			if ((object)type != null && model.FindWithoutAdd(type) == null && GetContractFamily(model, type, null) != AttributeFamily.None)
			{
				model.FindOrAddAuto(type, demand: true, addWithContractOnly: false, addEvenIfAutoDisabled: false);
			}
			AttributeMap[] array = AttributeMap.Create(model, this.type, inherit: false);
			AttributeFamily attributeFamily = GetContractFamily(model, this.type, array);
			if (attributeFamily == AttributeFamily.AutoTuple)
			{
				SetFlag(64, value: true, throwIfFrozen: true);
			}
			bool flag = !EnumPassthru && Helpers.IsEnum(this.type);
			if (attributeFamily == AttributeFamily.None && !flag)
			{
				return;
			}
			BasicList basicList = null;
			BasicList basicList2 = null;
			int dataMemberOffset = 0;
			int num = 1;
			bool flag2 = model.InferTagFromNameDefault;
			ImplicitFields implicitFields = ImplicitFields.None;
			string text = null;
			foreach (AttributeMap attributeMap in array)
			{
				string fullName = attributeMap.AttributeType.FullName;
				object value;
				if (!flag && fullName == "ProtoBuf.ProtoIncludeAttribute")
				{
					int fieldNumber = 0;
					if (attributeMap.TryGet("tag", out value))
					{
						fieldNumber = (int)value;
					}
					DataFormat dataFormat = DataFormat.Default;
					if (attributeMap.TryGet("DataFormat", out value))
					{
						dataFormat = (DataFormat)(int)value;
					}
					Type type2 = null;
					try
					{
						if (attributeMap.TryGet("knownTypeName", out value))
						{
							type2 = model.GetType((string)value, this.type.Assembly);
						}
						else if (attributeMap.TryGet("knownType", out value))
						{
							type2 = (Type)value;
						}
					}
					catch (Exception innerException)
					{
						throw new InvalidOperationException("Unable to resolve sub-type of: " + this.type.FullName, innerException);
					}
					if ((object)type2 == null)
					{
						throw new InvalidOperationException("Unable to resolve sub-type of: " + this.type.FullName);
					}
					if (IsValidSubType(type2))
					{
						AddSubType(fieldNumber, type2, dataFormat);
					}
				}
				if (fullName == "ProtoBuf.ProtoPartialIgnoreAttribute" && attributeMap.TryGet("MemberName", out value) && value != null)
				{
					if (basicList == null)
					{
						basicList = new BasicList();
					}
					basicList.Add((string)value);
				}
				if (!flag && fullName == "ProtoBuf.ProtoPartialMemberAttribute")
				{
					if (basicList2 == null)
					{
						basicList2 = new BasicList();
					}
					basicList2.Add(attributeMap);
				}
				if (fullName == "ProtoBuf.ProtoContractAttribute")
				{
					if (attributeMap.TryGet("Name", out value))
					{
						text = (string)value;
					}
					if (Helpers.IsEnum(this.type))
					{
						if (attributeMap.TryGet("EnumPassthruHasValue", publicOnly: false, out value) && (bool)value && attributeMap.TryGet("EnumPassthru", out value))
						{
							EnumPassthru = (bool)value;
							if (EnumPassthru)
							{
								flag = false;
							}
						}
					}
					else
					{
						if (attributeMap.TryGet("DataMemberOffset", out value))
						{
							dataMemberOffset = (int)value;
						}
						if (attributeMap.TryGet("InferTagFromNameHasValue", publicOnly: false, out value) && (bool)value && attributeMap.TryGet("InferTagFromName", out value))
						{
							flag2 = (bool)value;
						}
						if (attributeMap.TryGet("ImplicitFields", out value) && value != null)
						{
							implicitFields = (ImplicitFields)(int)value;
						}
						if (attributeMap.TryGet("SkipConstructor", out value))
						{
							UseConstructor = !(bool)value;
						}
						if (attributeMap.TryGet("IgnoreListHandling", out value))
						{
							IgnoreListHandling = (bool)value;
						}
						if (attributeMap.TryGet("AsReferenceDefault", out value))
						{
							AsReferenceDefault = (bool)value;
						}
						if (attributeMap.TryGet("ImplicitFirstTag", out value) && (int)value > 0)
						{
							num = (int)value;
						}
					}
				}
				if (fullName == "System.Runtime.Serialization.DataContractAttribute" && text == null && attributeMap.TryGet("Name", out value))
				{
					text = (string)value;
				}
				if (fullName == "System.Xml.Serialization.XmlTypeAttribute" && text == null && attributeMap.TryGet("TypeName", out value))
				{
					text = (string)value;
				}
			}
			if (!Helpers.IsNullOrEmpty(text))
			{
				Name = text;
			}
			if (implicitFields != ImplicitFields.None)
			{
				attributeFamily &= AttributeFamily.ProtoBuf;
			}
			MethodInfo[] array2 = null;
			BasicList basicList3 = new BasicList();
			MemberInfo[] members = this.type.GetMembers(flag ? (BindingFlags.Static | BindingFlags.Public) : (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
			MemberInfo[] array3 = members;
			foreach (MemberInfo memberInfo in array3)
			{
				if ((object)memberInfo.DeclaringType != this.type || memberInfo.IsDefined(model.MapType(typeof(ProtoIgnoreAttribute)), inherit: true) || (basicList != null && basicList.Contains(memberInfo.Name)))
				{
					continue;
				}
				bool forced = false;
				if (memberInfo is PropertyInfo propertyInfo)
				{
					if (!flag)
					{
						Type effectiveType = propertyInfo.PropertyType;
						bool isPublic = (object)Helpers.GetGetMethod(propertyInfo, nonPublic: false, allowInternal: false) != null;
						bool isField = false;
						ApplyDefaultBehaviour_AddMembers(model, attributeFamily, flag, basicList2, dataMemberOffset, flag2, implicitFields, basicList3, memberInfo, ref forced, isPublic, isField, ref effectiveType);
					}
				}
				else if (memberInfo is FieldInfo { FieldType: var effectiveType2, IsPublic: var isPublic2 } fieldInfo)
				{
					bool isField = true;
					if (!flag || fieldInfo.IsStatic)
					{
						ApplyDefaultBehaviour_AddMembers(model, attributeFamily, flag, basicList2, dataMemberOffset, flag2, implicitFields, basicList3, memberInfo, ref forced, isPublic2, isField, ref effectiveType2);
					}
				}
				else if (memberInfo is MethodInfo methodInfo && !flag)
				{
					AttributeMap[] array4 = AttributeMap.Create(model, methodInfo, inherit: false);
					if (array4 != null && array4.Length > 0)
					{
						CheckForCallback(methodInfo, array4, "ProtoBuf.ProtoBeforeSerializationAttribute", ref array2, 0);
						CheckForCallback(methodInfo, array4, "ProtoBuf.ProtoAfterSerializationAttribute", ref array2, 1);
						CheckForCallback(methodInfo, array4, "ProtoBuf.ProtoBeforeDeserializationAttribute", ref array2, 2);
						CheckForCallback(methodInfo, array4, "ProtoBuf.ProtoAfterDeserializationAttribute", ref array2, 3);
						CheckForCallback(methodInfo, array4, "System.Runtime.Serialization.OnSerializingAttribute", ref array2, 4);
						CheckForCallback(methodInfo, array4, "System.Runtime.Serialization.OnSerializedAttribute", ref array2, 5);
						CheckForCallback(methodInfo, array4, "System.Runtime.Serialization.OnDeserializingAttribute", ref array2, 6);
						CheckForCallback(methodInfo, array4, "System.Runtime.Serialization.OnDeserializedAttribute", ref array2, 7);
					}
				}
			}
			ProtoMemberAttribute[] array5 = new ProtoMemberAttribute[basicList3.Count];
			basicList3.CopyTo(array5, 0);
			if (flag2 || implicitFields != ImplicitFields.None)
			{
				Array.Sort(array5);
				int num2 = num;
				ProtoMemberAttribute[] array6 = array5;
				foreach (ProtoMemberAttribute protoMemberAttribute in array6)
				{
					if (!protoMemberAttribute.TagIsPinned)
					{
						protoMemberAttribute.Rebase(num2++);
					}
				}
			}
			ProtoMemberAttribute[] array7 = array5;
			foreach (ProtoMemberAttribute normalizedAttribute in array7)
			{
				ValueMember valueMember = ApplyDefaultBehaviour(flag, normalizedAttribute);
				if (valueMember != null)
				{
					Add(valueMember);
				}
			}
			if (array2 != null)
			{
				SetCallbacks(Coalesce(array2, 0, 4), Coalesce(array2, 1, 5), Coalesce(array2, 2, 6), Coalesce(array2, 3, 7));
			}
		}

		private static void ApplyDefaultBehaviour_AddMembers(TypeModel model, AttributeFamily family, bool isEnum, BasicList partialMembers, int dataMemberOffset, bool inferTagByName, ImplicitFields implicitMode, BasicList members, MemberInfo member, ref bool forced, bool isPublic, bool isField, ref Type effectiveType)
		{
			switch (implicitMode)
			{
			case ImplicitFields.AllFields:
				if (isField)
				{
					forced = true;
				}
				break;
			case ImplicitFields.AllPublic:
				if (isPublic)
				{
					forced = true;
				}
				break;
			}
			if (effectiveType.IsSubclassOf(model.MapType(typeof(Delegate))))
			{
				effectiveType = null;
			}
			if ((object)effectiveType != null)
			{
				ProtoMemberAttribute protoMemberAttribute = NormalizeProtoMember(model, member, family, forced, isEnum, partialMembers, dataMemberOffset, inferTagByName);
				if (protoMemberAttribute != null)
				{
					members.Add(protoMemberAttribute);
				}
			}
		}

		private static MethodInfo Coalesce(MethodInfo[] arr, int x, int y)
		{
			MethodInfo methodInfo = arr[x];
			if ((object)methodInfo == null)
			{
				methodInfo = arr[y];
			}
			return methodInfo;
		}

		internal static AttributeFamily GetContractFamily(RuntimeTypeModel model, Type type, AttributeMap[] attributes)
		{
			AttributeFamily attributeFamily = AttributeFamily.None;
			if (attributes == null)
			{
				attributes = AttributeMap.Create(model, type, inherit: false);
			}
			for (int i = 0; i < attributes.Length; i++)
			{
				switch (attributes[i].AttributeType.FullName)
				{
				case "ProtoBuf.ProtoContractAttribute":
				{
					bool value = false;
					GetFieldBoolean(ref value, attributes[i], "UseProtoMembersOnly");
					if (value)
					{
						return AttributeFamily.ProtoBuf;
					}
					attributeFamily |= AttributeFamily.ProtoBuf;
					break;
				}
				case "System.Xml.Serialization.XmlTypeAttribute":
					if (!model.AutoAddProtoContractTypesOnly)
					{
						attributeFamily |= AttributeFamily.XmlSerializer;
					}
					break;
				case "System.Runtime.Serialization.DataContractAttribute":
					if (!model.AutoAddProtoContractTypesOnly)
					{
						attributeFamily |= AttributeFamily.DataContractSerialier;
					}
					break;
				}
			}
			if (attributeFamily == AttributeFamily.None && (object)ResolveTupleConstructor(type, out var _) != null)
			{
				attributeFamily |= AttributeFamily.AutoTuple;
			}
			return attributeFamily;
		}

		internal static ConstructorInfo ResolveTupleConstructor(Type type, out MemberInfo[] mappedMembers)
		{
			mappedMembers = null;
			if ((object)type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (type.IsAbstract)
			{
				return null;
			}
			ConstructorInfo[] constructors = Helpers.GetConstructors(type, nonPublic: false);
			if (constructors.Length == 0 || (constructors.Length == 1 && constructors[0].GetParameters().Length == 0))
			{
				return null;
			}
			MemberInfo[] instanceFieldsAndProperties = Helpers.GetInstanceFieldsAndProperties(type, publicOnly: true);
			BasicList basicList = new BasicList();
			for (int i = 0; i < instanceFieldsAndProperties.Length; i++)
			{
				if (instanceFieldsAndProperties[i] is PropertyInfo propertyInfo)
				{
					if (!propertyInfo.CanRead)
					{
						return null;
					}
					if (propertyInfo.CanWrite && (object)Helpers.GetSetMethod(propertyInfo, nonPublic: false, allowInternal: false) != null)
					{
						return null;
					}
					basicList.Add(propertyInfo);
				}
				else if (instanceFieldsAndProperties[i] is FieldInfo fieldInfo)
				{
					if (!fieldInfo.IsInitOnly)
					{
						return null;
					}
					basicList.Add(fieldInfo);
				}
			}
			if (basicList.Count == 0)
			{
				return null;
			}
			MemberInfo[] array = new MemberInfo[basicList.Count];
			basicList.CopyTo(array, 0);
			int[] array2 = new int[array.Length];
			int num = 0;
			ConstructorInfo result = null;
			mappedMembers = new MemberInfo[array2.Length];
			for (int j = 0; j < constructors.Length; j++)
			{
				ParameterInfo[] parameters = constructors[j].GetParameters();
				if (parameters.Length != array.Length)
				{
					continue;
				}
				for (int k = 0; k < array2.Length; k++)
				{
					array2[k] = -1;
				}
				for (int l = 0; l < parameters.Length; l++)
				{
					string text = parameters[l].Name.ToLower();
					for (int m = 0; m < array.Length; m++)
					{
						if (!(array[m].Name.ToLower() != text))
						{
							Type memberType = Helpers.GetMemberType(array[m]);
							if ((object)memberType == parameters[l].ParameterType)
							{
								array2[l] = m;
							}
						}
					}
				}
				bool flag = false;
				for (int n = 0; n < array2.Length; n++)
				{
					if (array2[n] < 0)
					{
						flag = true;
						break;
					}
					mappedMembers[n] = array[array2[n]];
				}
				if (!flag)
				{
					num++;
					result = constructors[j];
				}
			}
			if (num != 1)
			{
				return null;
			}
			return result;
		}

		private static void CheckForCallback(MethodInfo method, AttributeMap[] attributes, string callbackTypeName, ref MethodInfo[] callbacks, int index)
		{
			for (int i = 0; i < attributes.Length; i++)
			{
				if (attributes[i].AttributeType.FullName == callbackTypeName)
				{
					if (callbacks == null)
					{
						callbacks = new MethodInfo[8];
					}
					else if ((object)callbacks[index] != null)
					{
						Type reflectedType = method.ReflectedType;
						throw new ProtoException("Duplicate " + callbackTypeName + " callbacks on " + reflectedType.FullName);
					}
					callbacks[index] = method;
				}
			}
		}

		private static bool HasFamily(AttributeFamily value, AttributeFamily required)
		{
			return (value & required) == required;
		}

		private static ProtoMemberAttribute NormalizeProtoMember(TypeModel model, MemberInfo member, AttributeFamily family, bool forced, bool isEnum, BasicList partialMembers, int dataMemberOffset, bool inferByTagName)
		{
			if ((object)member == null || (family == AttributeFamily.None && !isEnum))
			{
				return null;
			}
			int value = int.MinValue;
			int num = ((!inferByTagName) ? 1 : (-1));
			string text = null;
			bool value2 = false;
			bool ignore = false;
			bool flag = false;
			bool value3 = false;
			bool value4 = false;
			bool value5 = false;
			bool value6 = false;
			bool tagIsPinned = false;
			bool value7 = false;
			DataFormat value8 = DataFormat.Default;
			if (isEnum)
			{
				forced = true;
			}
			AttributeMap[] attribs = AttributeMap.Create(model, member, inherit: true);
			if (isEnum)
			{
				AttributeMap attribute = GetAttribute(attribs, "ProtoBuf.ProtoIgnoreAttribute");
				if (attribute != null)
				{
					ignore = true;
				}
				else
				{
					attribute = GetAttribute(attribs, "ProtoBuf.ProtoEnumAttribute");
					value = Convert.ToInt32(((FieldInfo)member).GetRawConstantValue());
					if (attribute != null)
					{
						GetFieldName(ref text, attribute, "Name");
						if ((bool)Helpers.GetInstanceMethod(attribute.AttributeType, "HasValue").Invoke(attribute.Target, null) && attribute.TryGet("Value", out var value9))
						{
							value = (int)value9;
						}
					}
				}
				flag = true;
			}
			if (!ignore && !flag)
			{
				AttributeMap attribute = GetAttribute(attribs, "ProtoBuf.ProtoMemberAttribute");
				GetIgnore(ref ignore, attribute, attribs, "ProtoBuf.ProtoIgnoreAttribute");
				if (!ignore && attribute != null)
				{
					GetFieldNumber(ref value, attribute, "Tag");
					GetFieldName(ref text, attribute, "Name");
					GetFieldBoolean(ref value3, attribute, "IsRequired");
					GetFieldBoolean(ref value2, attribute, "IsPacked");
					GetFieldBoolean(ref value7, attribute, "OverwriteList");
					GetDataFormat(ref value8, attribute, "DataFormat");
					GetFieldBoolean(ref value5, attribute, "AsReferenceHasValue", publicOnly: false);
					if (value5)
					{
						value5 = GetFieldBoolean(ref value4, attribute, "AsReference", publicOnly: true);
					}
					GetFieldBoolean(ref value6, attribute, "DynamicType");
					flag = (tagIsPinned = value > 0);
				}
				if (!flag && partialMembers != null)
				{
					BasicList.NodeEnumerator enumerator = partialMembers.GetEnumerator();
					while (enumerator.MoveNext())
					{
						AttributeMap attributeMap = (AttributeMap)enumerator.Current;
						if (attributeMap.TryGet("MemberName", out var value10) && (string)value10 == member.Name)
						{
							GetFieldNumber(ref value, attributeMap, "Tag");
							GetFieldName(ref text, attributeMap, "Name");
							GetFieldBoolean(ref value3, attributeMap, "IsRequired");
							GetFieldBoolean(ref value2, attributeMap, "IsPacked");
							GetFieldBoolean(ref value7, attribute, "OverwriteList");
							GetDataFormat(ref value8, attributeMap, "DataFormat");
							GetFieldBoolean(ref value5, attribute, "AsReferenceHasValue", publicOnly: false);
							if (value5)
							{
								value5 = GetFieldBoolean(ref value4, attributeMap, "AsReference", publicOnly: true);
							}
							GetFieldBoolean(ref value6, attributeMap, "DynamicType");
							if (flag = (tagIsPinned = value > 0))
							{
								break;
							}
						}
					}
				}
			}
			if (!ignore && !flag && HasFamily(family, AttributeFamily.DataContractSerialier))
			{
				AttributeMap attribute = GetAttribute(attribs, "System.Runtime.Serialization.DataMemberAttribute");
				if (attribute != null)
				{
					GetFieldNumber(ref value, attribute, "Order");
					GetFieldName(ref text, attribute, "Name");
					GetFieldBoolean(ref value3, attribute, "IsRequired");
					flag = value >= num;
					if (flag)
					{
						value += dataMemberOffset;
					}
				}
			}
			if (!ignore && !flag && HasFamily(family, AttributeFamily.XmlSerializer))
			{
				AttributeMap attribute = GetAttribute(attribs, "System.Xml.Serialization.XmlElementAttribute");
				if (attribute == null)
				{
					attribute = GetAttribute(attribs, "System.Xml.Serialization.XmlArrayAttribute");
				}
				GetIgnore(ref ignore, attribute, attribs, "System.Xml.Serialization.XmlIgnoreAttribute");
				if (attribute != null && !ignore)
				{
					GetFieldNumber(ref value, attribute, "Order");
					GetFieldName(ref text, attribute, "ElementName");
					flag = value >= num;
				}
			}
			if (!ignore && !flag && GetAttribute(attribs, "System.NonSerializedAttribute") != null)
			{
				ignore = true;
			}
			if (ignore || (value < num && !forced))
			{
				return null;
			}
			ProtoMemberAttribute protoMemberAttribute = new ProtoMemberAttribute(value, forced || inferByTagName);
			protoMemberAttribute.AsReference = value4;
			protoMemberAttribute.AsReferenceHasValue = value5;
			protoMemberAttribute.DataFormat = value8;
			protoMemberAttribute.DynamicType = value6;
			protoMemberAttribute.IsPacked = value2;
			protoMemberAttribute.OverwriteList = value7;
			protoMemberAttribute.IsRequired = value3;
			protoMemberAttribute.Name = (Helpers.IsNullOrEmpty(text) ? member.Name : text);
			protoMemberAttribute.Member = member;
			protoMemberAttribute.TagIsPinned = tagIsPinned;
			return protoMemberAttribute;
		}

		private ValueMember ApplyDefaultBehaviour(bool isEnum, ProtoMemberAttribute normalizedAttribute)
		{
			MemberInfo member;
			if (normalizedAttribute == null || (object)(member = normalizedAttribute.Member) == null)
			{
				return null;
			}
			Type memberType = Helpers.GetMemberType(member);
			Type itemType = null;
			Type defaultType = null;
			ResolveListTypes(model, memberType, ref itemType, ref defaultType);
			if ((object)itemType != null)
			{
				int num = model.FindOrAddAuto(memberType, demand: false, addWithContractOnly: true, addEvenIfAutoDisabled: false);
				if (num >= 0 && model[memberType].IgnoreListHandling)
				{
					itemType = null;
					defaultType = null;
				}
			}
			AttributeMap[] attribs = AttributeMap.Create(model, member, inherit: true);
			object defaultValue = null;
			if (model.UseImplicitZeroDefaults)
			{
				switch (Helpers.GetTypeCode(memberType))
				{
				case ProtoTypeCode.Boolean:
					defaultValue = false;
					break;
				case ProtoTypeCode.Decimal:
					defaultValue = 0m;
					break;
				case ProtoTypeCode.Single:
					defaultValue = 0f;
					break;
				case ProtoTypeCode.Double:
					defaultValue = 0.0;
					break;
				case ProtoTypeCode.Byte:
					defaultValue = (byte)0;
					break;
				case ProtoTypeCode.Char:
					defaultValue = '\0';
					break;
				case ProtoTypeCode.Int16:
					defaultValue = (short)0;
					break;
				case ProtoTypeCode.Int32:
					defaultValue = 0;
					break;
				case ProtoTypeCode.Int64:
					defaultValue = 0L;
					break;
				case ProtoTypeCode.SByte:
					defaultValue = (sbyte)0;
					break;
				case ProtoTypeCode.UInt16:
					defaultValue = (ushort)0;
					break;
				case ProtoTypeCode.UInt32:
					defaultValue = 0u;
					break;
				case ProtoTypeCode.UInt64:
					defaultValue = 0uL;
					break;
				case ProtoTypeCode.TimeSpan:
					defaultValue = TimeSpan.Zero;
					break;
				case ProtoTypeCode.Guid:
					defaultValue = Guid.Empty;
					break;
				}
			}
			AttributeMap attribute;
			if ((attribute = GetAttribute(attribs, "System.ComponentModel.DefaultValueAttribute")) != null && attribute.TryGet("Value", out var value))
			{
				defaultValue = value;
			}
			ValueMember valueMember = ((isEnum || normalizedAttribute.Tag > 0) ? new ValueMember(model, type, normalizedAttribute.Tag, member, memberType, itemType, defaultType, normalizedAttribute.DataFormat, defaultValue) : null);
			if (valueMember != null)
			{
				Type declaringType = type;
				PropertyInfo propertyInfo = Helpers.GetProperty(declaringType, member.Name + "Specified", nonPublic: true);
				MethodInfo getMethod = Helpers.GetGetMethod(propertyInfo, nonPublic: true, allowInternal: true);
				if ((object)getMethod == null || getMethod.IsStatic)
				{
					propertyInfo = null;
				}
				if ((object)propertyInfo != null)
				{
					valueMember.SetSpecified(getMethod, Helpers.GetSetMethod(propertyInfo, nonPublic: true, allowInternal: true));
				}
				else
				{
					MethodInfo instanceMethod = Helpers.GetInstanceMethod(declaringType, "ShouldSerialize" + member.Name, Helpers.EmptyTypes);
					if ((object)instanceMethod != null && (object)instanceMethod.ReturnType == model.MapType(typeof(bool)))
					{
						valueMember.SetSpecified(instanceMethod, null);
					}
				}
				if (!Helpers.IsNullOrEmpty(normalizedAttribute.Name))
				{
					valueMember.SetName(normalizedAttribute.Name);
				}
				valueMember.IsPacked = normalizedAttribute.IsPacked;
				valueMember.IsRequired = normalizedAttribute.IsRequired;
				valueMember.OverwriteList = normalizedAttribute.OverwriteList;
				if (normalizedAttribute.AsReferenceHasValue)
				{
					valueMember.AsReference = normalizedAttribute.AsReference;
				}
				valueMember.DynamicType = normalizedAttribute.DynamicType;
			}
			return valueMember;
		}

		private static void GetDataFormat(ref DataFormat value, AttributeMap attrib, string memberName)
		{
			if (attrib != null && value == DataFormat.Default && attrib.TryGet(memberName, out var value2) && value2 != null)
			{
				value = (DataFormat)value2;
			}
		}

		private static void GetIgnore(ref bool ignore, AttributeMap attrib, AttributeMap[] attribs, string fullName)
		{
			if (!ignore && attrib != null)
			{
				ignore = GetAttribute(attribs, fullName) != null;
			}
		}

		private static void GetFieldBoolean(ref bool value, AttributeMap attrib, string memberName)
		{
			GetFieldBoolean(ref value, attrib, memberName, publicOnly: true);
		}

		private static bool GetFieldBoolean(ref bool value, AttributeMap attrib, string memberName, bool publicOnly)
		{
			if (attrib == null)
			{
				return false;
			}
			if (value)
			{
				return true;
			}
			if (attrib.TryGet(memberName, publicOnly, out var value2) && value2 != null)
			{
				value = (bool)value2;
				return true;
			}
			return false;
		}

		private static void GetFieldNumber(ref int value, AttributeMap attrib, string memberName)
		{
			if (attrib != null && value <= 0 && attrib.TryGet(memberName, out var value2) && value2 != null)
			{
				value = (int)value2;
			}
		}

		private static void GetFieldName(ref string name, AttributeMap attrib, string memberName)
		{
			if (attrib != null && Helpers.IsNullOrEmpty(name) && attrib.TryGet(memberName, out var value) && value != null)
			{
				name = (string)value;
			}
		}

		private static AttributeMap GetAttribute(AttributeMap[] attribs, string fullName)
		{
			foreach (AttributeMap attributeMap in attribs)
			{
				if (attributeMap != null && attributeMap.AttributeType.FullName == fullName)
				{
					return attributeMap;
				}
			}
			return null;
		}

		public MetaType Add(int fieldNumber, string memberName)
		{
			AddField(fieldNumber, memberName, null, null, null);
			return this;
		}

		public ValueMember AddField(int fieldNumber, string memberName)
		{
			return AddField(fieldNumber, memberName, null, null, null);
		}

		public MetaType Add(string memberName)
		{
			Add(GetNextFieldNumber(), memberName);
			return this;
		}

		public void SetSurrogate(Type surrogateType)
		{
			if ((object)surrogateType == type)
			{
				surrogateType = null;
			}
			if ((object)surrogateType != null && (object)surrogateType != null && Helpers.IsAssignableFrom(model.MapType(typeof(IEnumerable)), surrogateType))
			{
				throw new ArgumentException("Repeated data (a list, collection, etc) has inbuilt behaviour and cannot be used as a surrogate");
			}
			ThrowIfFrozen();
			surrogate = surrogateType;
		}

		internal MetaType GetSurrogateOrSelf()
		{
			if ((object)surrogate != null)
			{
				return model[surrogate];
			}
			return this;
		}

		internal MetaType GetSurrogateOrBaseOrSelf(bool deep)
		{
			if ((object)surrogate != null)
			{
				return model[surrogate];
			}
			MetaType metaType = baseType;
			if (metaType != null)
			{
				if (deep)
				{
					MetaType result;
					do
					{
						result = metaType;
						metaType = metaType.baseType;
					}
					while (metaType != null);
					return result;
				}
				return metaType;
			}
			return this;
		}

		private int GetNextFieldNumber()
		{
			int num = 0;
			BasicList.NodeEnumerator enumerator = fields.GetEnumerator();
			while (enumerator.MoveNext())
			{
				ValueMember valueMember = (ValueMember)enumerator.Current;
				if (valueMember.FieldNumber > num)
				{
					num = valueMember.FieldNumber;
				}
			}
			if (subTypes != null)
			{
				BasicList.NodeEnumerator enumerator2 = subTypes.GetEnumerator();
				while (enumerator2.MoveNext())
				{
					SubType subType = (SubType)enumerator2.Current;
					if (subType.FieldNumber > num)
					{
						num = subType.FieldNumber;
					}
				}
			}
			return num + 1;
		}

		public MetaType Add(params string[] memberNames)
		{
			if (memberNames == null)
			{
				throw new ArgumentNullException("memberNames");
			}
			int nextFieldNumber = GetNextFieldNumber();
			for (int i = 0; i < memberNames.Length; i++)
			{
				Add(nextFieldNumber++, memberNames[i]);
			}
			return this;
		}

		public MetaType Add(int fieldNumber, string memberName, object defaultValue)
		{
			AddField(fieldNumber, memberName, null, null, defaultValue);
			return this;
		}

		public MetaType Add(int fieldNumber, string memberName, Type itemType, Type defaultType)
		{
			AddField(fieldNumber, memberName, itemType, defaultType, null);
			return this;
		}

		public ValueMember AddField(int fieldNumber, string memberName, Type itemType, Type defaultType)
		{
			return AddField(fieldNumber, memberName, itemType, defaultType, null);
		}

		private ValueMember AddField(int fieldNumber, string memberName, Type itemType, Type defaultType, object defaultValue)
		{
			MemberInfo memberInfo = null;
			MemberInfo[] member = type.GetMember(memberName, Helpers.IsEnum(type) ? (BindingFlags.Static | BindingFlags.Public) : (BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic));
			if (member != null && member.Length == 1)
			{
				memberInfo = member[0];
			}
			if ((object)memberInfo == null)
			{
				throw new ArgumentException("Unable to determine member: " + memberName, "memberName");
			}
			Type memberType = memberInfo.MemberType switch
			{
				MemberTypes.Field => ((FieldInfo)memberInfo).FieldType, 
				MemberTypes.Property => ((PropertyInfo)memberInfo).PropertyType, 
				_ => throw new NotSupportedException(memberInfo.MemberType.ToString()), 
			};
			ResolveListTypes(model, memberType, ref itemType, ref defaultType);
			ValueMember valueMember = new ValueMember(model, type, fieldNumber, memberInfo, memberType, itemType, defaultType, DataFormat.Default, defaultValue);
			Add(valueMember);
			return valueMember;
		}

		internal static void ResolveListTypes(TypeModel model, Type type, ref Type itemType, ref Type defaultType)
		{
			if ((object)type == null)
			{
				return;
			}
			if (type.IsArray)
			{
				if (type.GetArrayRank() != 1)
				{
					throw new NotSupportedException("Multi-dimension arrays are supported");
				}
				itemType = type.GetElementType();
				if ((object)itemType == model.MapType(typeof(byte)))
				{
					defaultType = (itemType = null);
				}
				else
				{
					defaultType = type;
				}
			}
			if ((object)itemType == null)
			{
				itemType = TypeModel.GetListItemType(model, type);
			}
			if ((object)itemType != null)
			{
				Type itemType2 = null;
				Type defaultType2 = null;
				ResolveListTypes(model, itemType, ref itemType2, ref defaultType2);
				if ((object)itemType2 != null)
				{
					throw TypeModel.CreateNestedListsNotSupported();
				}
			}
			if ((object)itemType == null || (object)defaultType != null)
			{
				return;
			}
			if (type.IsClass && !type.IsAbstract && (object)Helpers.GetConstructor(type, Helpers.EmptyTypes, nonPublic: true) != null)
			{
				defaultType = type;
			}
			if ((object)defaultType == null && type.IsInterface)
			{
				Type[] genericArguments;
				if (type.IsGenericType && (object)type.GetGenericTypeDefinition() == model.MapType(typeof(IDictionary<, >)) && (object)itemType == model.MapType(typeof(KeyValuePair<, >)).MakeGenericType(genericArguments = type.GetGenericArguments()))
				{
					defaultType = model.MapType(typeof(Dictionary<, >)).MakeGenericType(genericArguments);
				}
				else
				{
					defaultType = model.MapType(typeof(List<>)).MakeGenericType(itemType);
				}
			}
			if ((object)defaultType != null && !Helpers.IsAssignableFrom(type, defaultType))
			{
				defaultType = null;
			}
		}

		private void Add(ValueMember member)
		{
			int opaqueToken = 0;
			try
			{
				model.TakeLock(ref opaqueToken);
				ThrowIfFrozen();
				fields.Add(member);
			}
			finally
			{
				model.ReleaseLock(opaqueToken);
			}
		}

		public ValueMember[] GetFields()
		{
			ValueMember[] array = new ValueMember[fields.Count];
			fields.CopyTo(array, 0);
			Array.Sort(array, ValueMember.Comparer.Default);
			return array;
		}

		public SubType[] GetSubtypes()
		{
			if (subTypes == null || subTypes.Count == 0)
			{
				return new SubType[0];
			}
			SubType[] array = new SubType[subTypes.Count];
			subTypes.CopyTo(array, 0);
			Array.Sort(array, SubType.Comparer.Default);
			return array;
		}

		public void CompileInPlace()
		{
			serializer = CompiledSerializer.Wrap(Serializer, model);
		}

		internal bool IsDefined(int fieldNumber)
		{
			BasicList.NodeEnumerator enumerator = fields.GetEnumerator();
			while (enumerator.MoveNext())
			{
				ValueMember valueMember = (ValueMember)enumerator.Current;
				if (valueMember.FieldNumber == fieldNumber)
				{
					return true;
				}
			}
			return false;
		}

		internal int GetKey(bool demand, bool getBaseKey)
		{
			return model.GetKey(type, demand, getBaseKey);
		}

		internal EnumSerializer.EnumPair[] GetEnumMap()
		{
			if (HasFlag(2))
			{
				return null;
			}
			EnumSerializer.EnumPair[] array = new EnumSerializer.EnumPair[fields.Count];
			for (int i = 0; i < array.Length; i++)
			{
				ValueMember valueMember = (ValueMember)fields[i];
				int fieldNumber = valueMember.FieldNumber;
				object rawEnumValue = valueMember.GetRawEnumValue();
				ref EnumSerializer.EnumPair reference = ref array[i];
				reference = new EnumSerializer.EnumPair(fieldNumber, rawEnumValue, valueMember.MemberType);
			}
			return array;
		}

		private bool HasFlag(byte flag)
		{
			return (flags & flag) == flag;
		}

		private void SetFlag(byte flag, bool value, bool throwIfFrozen)
		{
			if (throwIfFrozen && HasFlag(flag) != value)
			{
				ThrowIfFrozen();
			}
			if (value)
			{
				flags |= flag;
			}
			else
			{
				flags = (byte)(flags & ~flag);
			}
		}

		internal static MetaType GetRootType(MetaType source)
		{
			while (source.serializer != null)
			{
				MetaType metaType = source.baseType;
				if (metaType == null)
				{
					return source;
				}
				source = metaType;
			}
			RuntimeTypeModel runtimeTypeModel = source.model;
			int opaqueToken = 0;
			try
			{
				runtimeTypeModel.TakeLock(ref opaqueToken);
				MetaType metaType2;
				while ((metaType2 = source.baseType) != null)
				{
					source = metaType2;
				}
				return source;
			}
			finally
			{
				runtimeTypeModel.ReleaseLock(opaqueToken);
			}
		}

		internal bool IsPrepared()
		{
			return serializer is CompiledSerializer;
		}

		internal static StringBuilder NewLine(StringBuilder builder, int indent)
		{
			return Helpers.AppendLine(builder).Append(' ', indent * 3);
		}

		internal void WriteSchema(StringBuilder builder, int indent, ref bool requiresBclImport)
		{
			if ((object)surrogate != null)
			{
				return;
			}
			ValueMember[] array = new ValueMember[fields.Count];
			fields.CopyTo(array, 0);
			Array.Sort(array, ValueMember.Comparer.Default);
			if (IsList)
			{
				string schemaTypeName = model.GetSchemaTypeName(TypeModel.GetListItemType(model, type), DataFormat.Default, asReference: false, dynamicType: false, ref requiresBclImport);
				NewLine(builder, indent).Append("message ").Append(GetSchemaTypeName()).Append(" {");
				NewLine(builder, indent + 1).Append("repeated ").Append(schemaTypeName).Append(" items = 1;");
				NewLine(builder, indent).Append('}');
				return;
			}
			if (IsAutoTuple)
			{
				if ((object)ResolveTupleConstructor(type, out var mappedMembers) == null)
				{
					return;
				}
				NewLine(builder, indent).Append("message ").Append(GetSchemaTypeName()).Append(" {");
				for (int i = 0; i < mappedMembers.Length; i++)
				{
					Type effectiveType;
					if (mappedMembers[i] is PropertyInfo)
					{
						effectiveType = ((PropertyInfo)mappedMembers[i]).PropertyType;
					}
					else
					{
						if (!(mappedMembers[i] is FieldInfo))
						{
							throw new NotSupportedException("Unknown member type: " + mappedMembers[i].GetType().Name);
						}
						effectiveType = ((FieldInfo)mappedMembers[i]).FieldType;
					}
					NewLine(builder, indent + 1).Append("optional ").Append(model.GetSchemaTypeName(effectiveType, DataFormat.Default, asReference: false, dynamicType: false, ref requiresBclImport).Replace('.', '_')).Append(' ')
						.Append(mappedMembers[i].Name)
						.Append(" = ")
						.Append(i + 1)
						.Append(';');
				}
				NewLine(builder, indent).Append('}');
				return;
			}
			if (Helpers.IsEnum(type))
			{
				NewLine(builder, indent).Append("enum ").Append(GetSchemaTypeName()).Append(" {");
				if (array.Length == 0 && EnumPassthru)
				{
					if (type.IsDefined(model.MapType(typeof(FlagsAttribute)), inherit: false))
					{
						NewLine(builder, indent + 1).Append("// this is a composite/flags enumeration");
					}
					else
					{
						NewLine(builder, indent + 1).Append("// this enumeration will be passed as a raw value");
					}
					FieldInfo[] array2 = type.GetFields();
					foreach (FieldInfo fieldInfo in array2)
					{
						if (fieldInfo.IsStatic && fieldInfo.IsLiteral)
						{
							object rawConstantValue = fieldInfo.GetRawConstantValue();
							NewLine(builder, indent + 1).Append(fieldInfo.Name).Append(" = ").Append(rawConstantValue)
								.Append(";");
						}
					}
				}
				else
				{
					ValueMember[] array3 = array;
					foreach (ValueMember valueMember in array3)
					{
						NewLine(builder, indent + 1).Append(valueMember.Name).Append(" = ").Append(valueMember.FieldNumber)
							.Append(';');
					}
				}
				NewLine(builder, indent).Append('}');
				return;
			}
			NewLine(builder, indent).Append("message ").Append(GetSchemaTypeName()).Append(" {");
			ValueMember[] array4 = array;
			foreach (ValueMember valueMember2 in array4)
			{
				string value = (((object)valueMember2.ItemType != null) ? "repeated" : (valueMember2.IsRequired ? "required" : "optional"));
				NewLine(builder, indent + 1).Append(value).Append(' ');
				if (valueMember2.DataFormat == DataFormat.Group)
				{
					builder.Append("group ");
				}
				string schemaTypeName2 = valueMember2.GetSchemaTypeName(applyNetObjectProxy: true, ref requiresBclImport);
				builder.Append(schemaTypeName2).Append(" ").Append(valueMember2.Name)
					.Append(" = ")
					.Append(valueMember2.FieldNumber);
				if (valueMember2.DefaultValue != null)
				{
					if (valueMember2.DefaultValue is string)
					{
						builder.Append(" [default = \"").Append(valueMember2.DefaultValue).Append("\"]");
					}
					else if (valueMember2.DefaultValue is bool)
					{
						builder.Append(((bool)valueMember2.DefaultValue) ? " [default = true]" : " [default = false]");
					}
					else
					{
						builder.Append(" [default = ").Append(valueMember2.DefaultValue).Append(']');
					}
				}
				if ((object)valueMember2.ItemType != null && valueMember2.IsPacked)
				{
					builder.Append(" [packed=true]");
				}
				builder.Append(';');
				if (schemaTypeName2 == "bcl.NetObjectProxy" && valueMember2.AsReference && !valueMember2.DynamicType)
				{
					builder.Append(" // reference-tracked ").Append(valueMember2.GetSchemaTypeName(applyNetObjectProxy: false, ref requiresBclImport));
				}
			}
			if (subTypes != null && subTypes.Count != 0)
			{
				NewLine(builder, indent + 1).Append("// the following represent sub-types; at most 1 should have a value");
				SubType[] array5 = new SubType[subTypes.Count];
				subTypes.CopyTo(array5, 0);
				Array.Sort(array5, SubType.Comparer.Default);
				SubType[] array6 = array5;
				foreach (SubType subType in array6)
				{
					string schemaTypeName3 = subType.DerivedType.GetSchemaTypeName();
					NewLine(builder, indent + 1).Append("optional ").Append(schemaTypeName3).Append(" ")
						.Append(schemaTypeName3)
						.Append(" = ")
						.Append(subType.FieldNumber)
						.Append(';');
				}
			}
			NewLine(builder, indent).Append('}');
		}
	}
	public abstract class TypeModel
	{
		private class DeserializeItemsIterator : IEnumerator, IEnumerable
		{
			private bool haveObject;

			private object current;

			private readonly Stream source;

			private readonly Type type;

			private readonly PrefixStyle style;

			private readonly int expectedField;

			private readonly Serializer.TypeResolver resolver;

			private readonly TypeModel model;

			private readonly SerializationContext context;

			public object Current => current;

			IEnumerator IEnumerable.GetEnumerator()
			{
				return this;
			}

			public bool MoveNext()
			{
				if (haveObject)
				{
					current = model.DeserializeWithLengthPrefix(source, null, type, style, expectedField, resolver, out var _, out haveObject, context);
				}
				return haveObject;
			}

			void IEnumerator.Reset()
			{
				throw new NotSupportedException();
			}

			public DeserializeItemsIterator(TypeModel model, Stream source, Type type, PrefixStyle style, int expectedField, Serializer.TypeResolver resolver, SerializationContext context)
			{
				haveObject = true;
				this.source = source;
				this.type = type;
				this.style = style;
				this.expectedField = expectedField;
				this.resolver = resolver;
				this.model = model;
				this.context = context;
			}
		}

		private sealed class DeserializeItemsIterator<T> : DeserializeItemsIterator, IEnumerator<T>, IDisposable, IEnumerator, IEnumerable<T>, IEnumerable
		{
			public new T Current => (T)base.Current;

			IEnumerator<T> IEnumerable<T>.GetEnumerator()
			{
				return this;
			}

			void IDisposable.Dispose()
			{
			}

			public DeserializeItemsIterator(TypeModel model, Stream source, PrefixStyle style, int expectedField, SerializationContext context)
				: base(model, source, model.MapType(typeof(T)), style, expectedField, null, context)
			{
			}
		}

		protected internal enum CallbackType
		{
			BeforeSerialize,
			AfterSerialize,
			BeforeDeserialize,
			AfterDeserialize
		}

		internal sealed class Formatter : IFormatter
		{
			private readonly TypeModel model;

			private readonly Type type;

			private SerializationBinder binder;

			private StreamingContext context;

			private ISurrogateSelector surrogateSelector;

			public SerializationBinder Binder
			{
				get
				{
					return binder;
				}
				set
				{
					binder = value;
				}
			}

			public StreamingContext Context
			{
				get
				{
					return context;
				}
				set
				{
					context = value;
				}
			}

			public ISurrogateSelector SurrogateSelector
			{
				get
				{
					return surrogateSelector;
				}
				set
				{
					surrogateSelector = value;
				}
			}

			internal Formatter(TypeModel model, Type type)
			{
				if (model == null)
				{
					throw new ArgumentNullException("model");
				}
				if ((object)type == null)
				{
					throw new ArgumentNullException("type");
				}
				this.model = model;
				this.type = type;
			}

			public object Deserialize(Stream source)
			{
				return model.Deserialize(source, null, type, -1, Context);
			}

			public void Serialize(Stream destination, object graph)
			{
				model.Serialize(destination, graph, Context);
			}
		}

		private static readonly Type ilist = typeof(IList);

		public event TypeFormatEventHandler DynamicTypeFormatting;

		protected internal Type MapType(Type type)
		{
			return MapType(type, demand: true);
		}

		protected internal virtual Type MapType(Type type, bool demand)
		{
			return type;
		}

		private WireType GetWireType(ProtoTypeCode code, DataFormat format, ref Type type, out int modelKey)
		{
			modelKey = -1;
			if (Helpers.IsEnum(type))
			{
				modelKey = GetKey(ref type);
				return WireType.Variant;
			}
			switch (code)
			{
			case ProtoTypeCode.Int64:
			case ProtoTypeCode.UInt64:
				if (format != DataFormat.FixedSize)
				{
					return WireType.Variant;
				}
				return WireType.Fixed64;
			case ProtoTypeCode.Boolean:
			case ProtoTypeCode.Char:
			case ProtoTypeCode.SByte:
			case ProtoTypeCode.Byte:
			case ProtoTypeCode.Int16:
			case ProtoTypeCode.UInt16:
			case ProtoTypeCode.Int32:
			case ProtoTypeCode.UInt32:
				if (format != DataFormat.FixedSize)
				{
					return WireType.Variant;
				}
				return WireType.Fixed32;
			case ProtoTypeCode.Double:
				return WireType.Fixed64;
			case ProtoTypeCode.Single:
				return WireType.Fixed32;
			case ProtoTypeCode.Decimal:
			case ProtoTypeCode.DateTime:
			case ProtoTypeCode.String:
			case ProtoTypeCode.TimeSpan:
			case ProtoTypeCode.ByteArray:
			case ProtoTypeCode.Guid:
			case ProtoTypeCode.Uri:
				return WireType.String;
			default:
				if ((modelKey = GetKey(ref type)) >= 0)
				{
					return WireType.String;
				}
				return WireType.None;
			}
		}

		internal bool TrySerializeAuxiliaryType(ProtoWriter writer, Type type, DataFormat format, int tag, object value, bool isInsideList)
		{
			if ((object)type == null)
			{
				type = value.GetType();
			}
			ProtoTypeCode typeCode = Helpers.GetTypeCode(type);
			int modelKey;
			WireType wireType = GetWireType(typeCode, format, ref type, out modelKey);
			if (modelKey >= 0)
			{
				if (Helpers.IsEnum(type))
				{
					Serialize(modelKey, value, writer);
					return true;
				}
				ProtoWriter.WriteFieldHeader(tag, wireType, writer);
				switch (wireType)
				{
				case WireType.None:
					throw ProtoWriter.CreateException(writer);
				case WireType.String:
				case WireType.StartGroup:
				{
					SubItemToken token = ProtoWriter.StartSubItem(value, writer);
					Serialize(modelKey, value, writer);
					ProtoWriter.EndSubItem(token, writer);
					return true;
				}
				default:
					Serialize(modelKey, value, writer);
					return true;
				}
			}
			if (wireType != WireType.None)
			{
				ProtoWriter.WriteFieldHeader(tag, wireType, writer);
			}
			switch (typeCode)
			{
			case ProtoTypeCode.Int16:
				ProtoWriter.WriteInt16((short)value, writer);
				return true;
			case ProtoTypeCode.Int32:
				ProtoWriter.WriteInt32((int)value, writer);
				return true;
			case ProtoTypeCode.Int64:
				ProtoWriter.WriteInt64((long)value, writer);
				return true;
			case ProtoTypeCode.UInt16:
				ProtoWriter.WriteUInt16((ushort)value, writer);
				return true;
			case ProtoTypeCode.UInt32:
				ProtoWriter.WriteUInt32((uint)value, writer);
				return true;
			case ProtoTypeCode.UInt64:
				ProtoWriter.WriteUInt64((ulong)value, writer);
				return true;
			case ProtoTypeCode.Boolean:
				ProtoWriter.WriteBoolean((bool)value, writer);
				return true;
			case ProtoTypeCode.SByte:
				ProtoWriter.WriteSByte((sbyte)value, writer);
				return true;
			case ProtoTypeCode.Byte:
				ProtoWriter.WriteByte((byte)value, writer);
				return true;
			case ProtoTypeCode.Char:
				ProtoWriter.WriteUInt16((char)value, writer);
				return true;
			case ProtoTypeCode.Double:
				ProtoWriter.WriteDouble((double)value, writer);
				return true;
			case ProtoTypeCode.Single:
				ProtoWriter.WriteSingle((float)value, writer);
				return true;
			case ProtoTypeCode.DateTime:
				BclHelpers.WriteDateTime((DateTime)value, writer);
				return true;
			case ProtoTypeCode.Decimal:
				BclHelpers.WriteDecimal((decimal)value, writer);
				return true;
			case ProtoTypeCode.String:
				ProtoWriter.WriteString((string)value, writer);
				return true;
			case ProtoTypeCode.ByteArray:
				ProtoWriter.WriteBytes((byte[])value, writer);
				return true;
			case ProtoTypeCode.TimeSpan:
				BclHelpers.WriteTimeSpan((TimeSpan)value, writer);
				return true;
			case ProtoTypeCode.Guid:
				BclHelpers.WriteGuid((Guid)value, writer);
				return true;
			case ProtoTypeCode.Uri:
				ProtoWriter.WriteString(((Uri)value).AbsoluteUri, writer);
				return true;
			default:
				if (value is IEnumerable enumerable)
				{
					if (isInsideList)
					{
						throw CreateNestedListsNotSupported();
					}
					foreach (object item in enumerable)
					{
						if (item == null)
						{
							throw new NullReferenceException();
						}
						if (!TrySerializeAuxiliaryType(writer, null, format, tag, item, isInsideList: true))
						{
							ThrowUnexpectedType(item.GetType());
						}
					}
					return true;
				}
				return false;
			}
		}

		private void SerializeCore(ProtoWriter writer, object value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			Type type = value.GetType();
			int key = GetKey(ref type);
			if (key >= 0)
			{
				Serialize(key, value, writer);
			}
			else if (!TrySerializeAuxiliaryType(writer, type, DataFormat.Default, 1, value, isInsideList: false))
			{
				ThrowUnexpectedType(type);
			}
		}

		public void Serialize(Stream dest, object value)
		{
			Serialize(dest, value, null);
		}

		public void Serialize(Stream dest, object value, SerializationContext context)
		{
			using ProtoWriter protoWriter = new ProtoWriter(dest, this, context);
			protoWriter.SetRootObject(value);
			SerializeCore(protoWriter, value);
			protoWriter.Close();
		}

		public void Serialize(ProtoWriter dest, object value)
		{
			if (dest == null)
			{
				throw new ArgumentNullException("dest");
			}
			dest.CheckDepthFlushlock();
			dest.SetRootObject(value);
			SerializeCore(dest, value);
			dest.CheckDepthFlushlock();
			ProtoWriter.Flush(dest);
		}

		public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int fieldNumber)
		{
			int bytesRead;
			return DeserializeWithLengthPrefix(source, value, type, style, fieldNumber, null, out bytesRead);
		}

		public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, Serializer.TypeResolver resolver)
		{
			int bytesRead;
			return DeserializeWithLengthPrefix(source, value, type, style, expectedField, resolver, out bytesRead);
		}

		public object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, Serializer.TypeResolver resolver, out int bytesRead)
		{
			bool haveObject;
			return DeserializeWithLengthPrefix(source, value, type, style, expectedField, resolver, out bytesRead, out haveObject, null);
		}

		private object DeserializeWithLengthPrefix(Stream source, object value, Type type, PrefixStyle style, int expectedField, Serializer.TypeResolver resolver, out int bytesRead, out bool haveObject, SerializationContext context)
		{
			haveObject = false;
			bytesRead = 0;
			if ((object)type == null && (style != PrefixStyle.Base128 || resolver == null))
			{
				throw new InvalidOperationException("A type must be provided unless base-128 prefixing is being used in combination with a resolver");
			}
			int num;
			bool flag2;
			do
			{
				bool flag = expectedField > 0 || resolver != null;
				num = ProtoReader.ReadLengthPrefix(source, flag, style, out var fieldNumber, out var bytesRead2);
				if (bytesRead2 == 0)
				{
					return value;
				}
				bytesRead += bytesRead2;
				if (num < 0)
				{
					return value;
				}
				if (style == PrefixStyle.Base128)
				{
					if (flag && expectedField == 0 && (object)type == null && resolver != null)
					{
						type = resolver(fieldNumber);
						flag2 = (object)type == null;
					}
					else
					{
						flag2 = expectedField != fieldNumber;
					}
				}
				else
				{
					flag2 = false;
				}
				if (flag2)
				{
					if (num == int.MaxValue)
					{
						throw new InvalidOperationException();
					}
					ProtoReader.Seek(source, num, null);
					bytesRead += num;
				}
			}
			while (flag2);
			ProtoReader protoReader = null;
			try
			{
				protoReader = ProtoReader.Create(source, this, context, num);
				int key = GetKey(ref type);
				if (key >= 0 && !Helpers.IsEnum(type))
				{
					value = Deserialize(key, value, protoReader);
				}
				else if (!TryDeserializeAuxiliaryType(protoReader, DataFormat.Default, 1, type, ref value, skipOtherFields: true, asListItem: false, autoCreate: true, insideList: false) && num != 0)
				{
					ThrowUnexpectedType(type);
				}
				bytesRead += protoReader.Position;
				haveObject = true;
				return value;
			}
			finally
			{
				ProtoReader.Recycle(protoReader);
			}
		}

		public IEnumerable DeserializeItems(Stream source, Type type, PrefixStyle style, int expectedField, Serializer.TypeResolver resolver)
		{
			return DeserializeItems(source, type, style, expectedField, resolver, null);
		}

		public IEnumerable DeserializeItems(Stream source, Type type, PrefixStyle style, int expectedField, Serializer.TypeResolver resolver, SerializationContext context)
		{
			return new DeserializeItemsIterator(this, source, type, style, expectedField, resolver, context);
		}

		public IEnumerable<T> DeserializeItems<T>(Stream source, PrefixStyle style, int expectedField)
		{
			return DeserializeItems<T>(source, style, expectedField, null);
		}

		public IEnumerable<T> DeserializeItems<T>(Stream source, PrefixStyle style, int expectedField, SerializationContext context)
		{
			return new DeserializeItemsIterator<T>(this, source, style, expectedField, context);
		}

		public void SerializeWithLengthPrefix(Stream dest, object value, Type type, PrefixStyle style, int fieldNumber)
		{
			SerializeWithLengthPrefix(dest, value, type, style, fieldNumber, null);
		}

		public void SerializeWithLengthPrefix(Stream dest, object value, Type type, PrefixStyle style, int fieldNumber, SerializationContext context)
		{
			if ((object)type == null)
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				type = MapType(value.GetType());
			}
			int key = GetKey(ref type);
			using ProtoWriter protoWriter = new ProtoWriter(dest, this, context);
			switch (style)
			{
			case PrefixStyle.None:
				Serialize(key, value, protoWriter);
				break;
			case PrefixStyle.Base128:
			case PrefixStyle.Fixed32:
			case PrefixStyle.Fixed32BigEndian:
				ProtoWriter.WriteObject(value, key, protoWriter, style, fieldNumber);
				break;
			default:
				throw new ArgumentOutOfRangeException("style");
			}
			protoWriter.Close();
		}

		public object Deserialize(Stream source, object value, Type type)
		{
			return Deserialize(source, value, type, null);
		}

		public object Deserialize(Stream source, object value, Type type, SerializationContext context)
		{
			bool noAutoCreate = PrepareDeserialize(value, ref type);
			ProtoReader protoReader = null;
			try
			{
				protoReader = ProtoReader.Create(source, this, context, -1);
				if (value != null)
				{
					protoReader.SetRootObject(value);
				}
				object result = DeserializeCore(protoReader, type, value, noAutoCreate);
				protoReader.CheckFullyConsumed();
				return result;
			}
			finally
			{
				ProtoReader.Recycle(protoReader);
			}
		}

		private bool PrepareDeserialize(object value, ref Type type)
		{
			if ((object)type == null)
			{
				if (value == null)
				{
					throw new ArgumentNullException("type");
				}
				type = MapType(value.GetType());
			}
			bool result = true;
			Type underlyingType = Helpers.GetUnderlyingType(type);
			if ((object)underlyingType != null)
			{
				type = underlyingType;
				result = false;
			}
			return result;
		}

		public object Deserialize(Stream source, object value, Type type, int length)
		{
			return Deserialize(source, value, type, length, null);
		}

		public object Deserialize(Stream source, object value, Type type, int length, SerializationContext context)
		{
			bool noAutoCreate = PrepareDeserialize(value, ref type);
			ProtoReader protoReader = null;
			try
			{
				protoReader = ProtoReader.Create(source, this, context, length);
				if (value != null)
				{
					protoReader.SetRootObject(value);
				}
				object result = DeserializeCore(protoReader, type, value, noAutoCreate);
				protoReader.CheckFullyConsumed();
				return result;
			}
			finally
			{
				ProtoReader.Recycle(protoReader);
			}
		}

		public object Deserialize(ProtoReader source, object value, Type type)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			bool noAutoCreate = PrepareDeserialize(value, ref type);
			if (value != null)
			{
				source.SetRootObject(value);
			}
			object result = DeserializeCore(source, type, value, noAutoCreate);
			source.CheckFullyConsumed();
			return result;
		}

		private object DeserializeCore(ProtoReader reader, Type type, object value, bool noAutoCreate)
		{
			int key = GetKey(ref type);
			if (key >= 0 && !Helpers.IsEnum(type))
			{
				return Deserialize(key, value, reader);
			}
			TryDeserializeAuxiliaryType(reader, DataFormat.Default, 1, type, ref value, skipOtherFields: true, asListItem: false, noAutoCreate, insideList: false);
			return value;
		}

		internal static MethodInfo ResolveListAdd(TypeModel model, Type listType, Type itemType, out bool isList)
		{
			isList = model.MapType(ilist).IsAssignableFrom(listType);
			Type[] array = new Type[1] { itemType };
			MethodInfo instanceMethod = Helpers.GetInstanceMethod(listType, "Add", array);
			if ((object)instanceMethod == null)
			{
				bool flag = listType.IsInterface && (object)listType == model.MapType(typeof(IEnumerable<>)).MakeGenericType(array);
				Type type = model.MapType(typeof(ICollection<>)).MakeGenericType(array);
				if (flag || type.IsAssignableFrom(listType))
				{
					instanceMethod = Helpers.GetInstanceMethod(type, "Add", array);
				}
			}
			if ((object)instanceMethod == null)
			{
				Type[] interfaces = listType.GetInterfaces();
				foreach (Type type2 in interfaces)
				{
					if (type2.Name == "IProducerConsumerCollection`1" && type2.IsGenericType && type2.GetGenericTypeDefinition().FullName == "System.Collections.Concurrent.IProducerConsumerCollection`1")
					{
						instanceMethod = Helpers.GetInstanceMethod(type2, "TryAdd", array);
						if ((object)instanceMethod != null)
						{
							break;
						}
					}
				}
			}
			if ((object)instanceMethod == null)
			{
				array[0] = model.MapType(typeof(object));
				instanceMethod = Helpers.GetInstanceMethod(listType, "Add", array);
			}
			if ((object)instanceMethod == null && isList)
			{
				instanceMethod = Helpers.GetInstanceMethod(model.MapType(ilist), "Add", array);
			}
			return instanceMethod;
		}

		internal static Type GetListItemType(TypeModel model, Type listType)
		{
			if ((object)listType == model.MapType(typeof(string)) || listType.IsArray || !model.MapType(typeof(IEnumerable)).IsAssignableFrom(listType))
			{
				return null;
			}
			BasicList basicList = new BasicList();
			MethodInfo[] methods = listType.GetMethods();
			foreach (MethodInfo methodInfo in methods)
			{
				if (!methodInfo.IsStatic && !(methodInfo.Name != "Add"))
				{
					ParameterInfo[] parameters = methodInfo.GetParameters();
					Type parameterType;
					if (parameters.Length == 1 && !basicList.Contains(parameterType = parameters[0].ParameterType))
					{
						basicList.Add(parameterType);
					}
				}
			}
			string name = listType.Name;
			if (name == null || (name.IndexOf("Queue") < 0 && name.IndexOf("Stack") < 0))
			{
				TestEnumerableListPatterns(model, basicList, listType);
				Type[] interfaces = listType.GetInterfaces();
				foreach (Type iType in interfaces)
				{
					TestEnumerableListPatterns(model, basicList, iType);
				}
			}
			PropertyInfo[] properties = listType.GetProperties(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (PropertyInfo propertyInfo in properties)
			{
				if (!(propertyInfo.Name != "Item") && !basicList.Contains(propertyInfo.PropertyType))
				{
					ParameterInfo[] indexParameters = propertyInfo.GetIndexParameters();
					if (indexParameters.Length == 1 && (object)indexParameters[0].ParameterType == model.MapType(typeof(int)))
					{
						basicList.Add(propertyInfo.PropertyType);
					}
				}
			}
			switch (basicList.Count)
			{
			case 0:
				return null;
			case 1:
				return (Type)basicList[0];
			case 2:
				if (CheckDictionaryAccessors(model, (Type)basicList[0], (Type)basicList[1]))
				{
					return (Type)basicList[0];
				}
				if (CheckDictionaryAccessors(model, (Type)basicList[1], (Type)basicList[0]))
				{
					return (Type)basicList[1];
				}
				break;
			}
			return null;
		}

		private static void TestEnumerableListPatterns(TypeModel model, BasicList candidates, Type iType)
		{
			if (!iType.IsGenericType)
			{
				return;
			}
			Type genericTypeDefinition = iType.GetGenericTypeDefinition();
			if ((object)genericTypeDefinition == model.MapType(typeof(IEnumerable<>)) || (object)genericTypeDefinition == model.MapType(typeof(ICollection<>)) || genericTypeDefinition.FullName == "System.Collections.Concurrent.IProducerConsumerCollection`1")
			{
				Type[] genericArguments = iType.GetGenericArguments();
				if (!candidates.Contains(genericArguments[0]))
				{
					candidates.Add(genericArguments[0]);
				}
			}
		}

		private static bool CheckDictionaryAccessors(TypeModel model, Type pair, Type value)
		{
			if (pair.IsGenericType && (object)pair.GetGenericTypeDefinition() == model.MapType(typeof(KeyValuePair<, >)))
			{
				return (object)pair.GetGenericArguments()[1] == value;
			}
			return false;
		}

		private bool TryDeserializeList(TypeModel model, ProtoReader reader, DataFormat format, int tag, Type listType, Type itemType, ref object value)
		{
			bool isList;
			MethodInfo methodInfo = ResolveListAdd(model, listType, itemType, out isList);
			if ((object)methodInfo == null)
			{
				throw new NotSupportedException("Unknown list variant: " + listType.FullName);
			}
			bool result = false;
			object value2 = null;
			IList list = value as IList;
			object[] array = (isList ? null : new object[1]);
			BasicList basicList = (listType.IsArray ? new BasicList() : null);
			while (TryDeserializeAuxiliaryType(reader, format, tag, itemType, ref value2, skipOtherFields: true, asListItem: true, autoCreate: true, insideList: true))
			{
				result = true;
				if (value == null && basicList == null)
				{
					value = CreateListInstance(listType, itemType);
					list = value as IList;
				}
				if (list != null)
				{
					list.Add(value2);
				}
				else if (basicList != null)
				{
					basicList.Add(value2);
				}
				else
				{
					array[0] = value2;
					methodInfo.Invoke(value, array);
				}
				value2 = null;
			}
			if (basicList != null)
			{
				if (value != null)
				{
					if (basicList.Count != 0)
					{
						Array array2 = (Array)value;
						Array array3 = Array.CreateInstance(itemType, array2.Length + basicList.Count);
						Array.Copy(array2, array3, array2.Length);
						basicList.CopyTo(array3, array2.Length);
						value = array3;
					}
				}
				else
				{
					Array array3 = Array.CreateInstance(itemType, basicList.Count);
					basicList.CopyTo(array3, 0);
					value = array3;
				}
			}
			return result;
		}

		private static object CreateListInstance(Type listType, Type itemType)
		{
			Type type = listType;
			if (listType.IsArray)
			{
				return Array.CreateInstance(itemType, 0);
			}
			if (!listType.IsClass || listType.IsAbstract || (object)Helpers.GetConstructor(listType, Helpers.EmptyTypes, nonPublic: true) == null)
			{
				bool flag = false;
				string fullName;
				if (listType.IsInterface && (fullName = listType.FullName) != null && fullName.IndexOf("Dictionary") >= 0)
				{
					if (listType.IsGenericType && (object)listType.GetGenericTypeDefinition() == typeof(IDictionary<, >))
					{
						Type[] genericArguments = listType.GetGenericArguments();
						type = typeof(Dictionary<, >).MakeGenericType(genericArguments);
						flag = true;
					}
					if (!flag && (object)listType == typeof(IDictionary))
					{
						type = typeof(Hashtable);
						flag = true;
					}
				}
				if (!flag)
				{
					type = typeof(List<>).MakeGenericType(itemType);
					flag = true;
				}
				if (!flag)
				{
					type = typeof(ArrayList);
					flag = true;
				}
			}
			return Activator.CreateInstance(type);
		}

		internal bool TryDeserializeAuxiliaryType(ProtoReader reader, DataFormat format, int tag, Type type, ref object value, bool skipOtherFields, bool asListItem, bool autoCreate, bool insideList)
		{
			if ((object)type == null)
			{
				throw new ArgumentNullException("type");
			}
			Type type2 = null;
			ProtoTypeCode typeCode = Helpers.GetTypeCode(type);
			int modelKey;
			WireType wireType = GetWireType(typeCode, format, ref type, out modelKey);
			bool flag = false;
			if (wireType == WireType.None)
			{
				type2 = GetListItemType(this, type);
				if ((object)type2 == null && type.IsArray && type.GetArrayRank() == 1 && (object)type != typeof(byte[]))
				{
					type2 = type.GetElementType();
				}
				if ((object)type2 != null)
				{
					if (insideList)
					{
						throw CreateNestedListsNotSupported();
					}
					flag = TryDeserializeList(this, reader, format, tag, type, type2, ref value);
					if (!flag && autoCreate)
					{
						value = CreateListInstance(type, type2);
					}
					return flag;
				}
				ThrowUnexpectedType(type);
			}
			while (!flag || !asListItem)
			{
				int num = reader.ReadFieldHeader();
				if (num <= 0)
				{
					break;
				}
				if (num != tag)
				{
					if (skipOtherFields)
					{
						reader.SkipField();
						continue;
					}
					throw ProtoReader.AddErrorData(new InvalidOperationException("Expected field " + tag + ", but found " + num), reader);
				}
				flag = true;
				reader.Hint(wireType);
				if (modelKey >= 0)
				{
					switch (wireType)
					{
					case WireType.String:
					case WireType.StartGroup:
					{
						SubItemToken token = ProtoReader.StartSubItem(reader);
						value = Deserialize(modelKey, value, reader);
						ProtoReader.EndSubItem(token, reader);
						break;
					}
					default:
						value = Deserialize(modelKey, value, reader);
						break;
					}
					continue;
				}
				switch (typeCode)
				{
				case ProtoTypeCode.Int16:
					value = reader.ReadInt16();
					break;
				case ProtoTypeCode.Int32:
					value = reader.ReadInt32();
					break;
				case ProtoTypeCode.Int64:
					value = reader.ReadInt64();
					break;
				case ProtoTypeCode.UInt16:
					value = reader.ReadUInt16();
					break;
				case ProtoTypeCode.UInt32:
					value = reader.ReadUInt32();
					break;
				case ProtoTypeCode.UInt64:
					value = reader.ReadUInt64();
					break;
				case ProtoTypeCode.Boolean:
					value = reader.ReadBoolean();
					break;
				case ProtoTypeCode.SByte:
					value = reader.ReadSByte();
					break;
				case ProtoTypeCode.Byte:
					value = reader.ReadByte();
					break;
				case ProtoTypeCode.Char:
					value = (char)reader.ReadUInt16();
					break;
				case ProtoTypeCode.Double:
					value = reader.ReadDouble();
					break;
				case ProtoTypeCode.Single:
					value = reader.ReadSingle();
					break;
				case ProtoTypeCode.DateTime:
					value = BclHelpers.ReadDateTime(reader);
					break;
				case ProtoTypeCode.Decimal:
					value = BclHelpers.ReadDecimal(reader);
					break;
				case ProtoTypeCode.String:
					value = reader.ReadString();
					break;
				case ProtoTypeCode.ByteArray:
					value = ProtoReader.AppendBytes((byte[])value, reader);
					break;
				case ProtoTypeCode.TimeSpan:
					value = BclHelpers.ReadTimeSpan(reader);
					break;
				case ProtoTypeCode.Guid:
					value = BclHelpers.ReadGuid(reader);
					break;
				case ProtoTypeCode.Uri:
					value = new Uri(reader.ReadString());
					break;
				}
			}
			if (!flag && !asListItem && autoCreate && (object)type != typeof(string))
			{
				value = Activator.CreateInstance(type);
			}
			return flag;
		}

		public static RuntimeTypeModel Create()
		{
			return new RuntimeTypeModel(isDefault: false);
		}

		protected internal static Type ResolveProxies(Type type)
		{
			if ((object)type == null)
			{
				return null;
			}
			if (type.IsGenericParameter)
			{
				return null;
			}
			Type underlyingType = Helpers.GetUnderlyingType(type);
			if ((object)underlyingType != null)
			{
				return underlyingType;
			}
			string fullName = type.FullName;
			if (fullName != null && fullName.StartsWith("System.Data.Entity.DynamicProxies."))
			{
				return type.BaseType;
			}
			Type[] interfaces = type.GetInterfaces();
			for (int i = 0; i < interfaces.Length; i++)
			{
				switch (interfaces[i].FullName)
				{
				case "NHibernate.Proxy.INHibernateProxy":
				case "NHibernate.Proxy.DynamicProxy.IProxy":
				case "NHibernate.Intercept.IFieldInterceptorAccessor":
					return type.BaseType;
				}
			}
			return null;
		}

		public bool IsDefined(Type type)
		{
			return GetKey(ref type) >= 0;
		}

		protected internal int GetKey(ref Type type)
		{
			if ((object)type == null)
			{
				return -1;
			}
			int keyImpl = GetKeyImpl(type);
			if (keyImpl < 0)
			{
				Type type2 = ResolveProxies(type);
				if ((object)type2 != null)
				{
					type = type2;
					keyImpl = GetKeyImpl(type);
				}
			}
			return keyImpl;
		}

		protected abstract int GetKeyImpl(Type type);

		protected internal abstract void Serialize(int key, object value, ProtoWriter dest);

		protected internal abstract object Deserialize(int key, object value, ProtoReader source);

		public object DeepClone(object value)
		{
			if (value == null)
			{
				return null;
			}
			Type type = value.GetType();
			int key = GetKey(ref type);
			if (key >= 0 && !Helpers.IsEnum(type))
			{
				using (MemoryStream memoryStream = new MemoryStream())
				{
					using (ProtoWriter protoWriter = new ProtoWriter(memoryStream, this, null))
					{
						protoWriter.SetRootObject(value);
						Serialize(key, value, protoWriter);
						protoWriter.Close();
					}
					memoryStream.Position = 0L;
					ProtoReader protoReader = null;
					try
					{
						protoReader = ProtoReader.Create(memoryStream, this, null, -1);
						return Deserialize(key, null, protoReader);
					}
					finally
					{
						ProtoReader.Recycle(protoReader);
					}
				}
			}
			if ((object)type == typeof(byte[]))
			{
				byte[] array = (byte[])value;
				byte[] array2 = new byte[array.Length];
				Helpers.BlockCopy(array, 0, array2, 0, array.Length);
				return array2;
			}
			if (GetWireType(Helpers.GetTypeCode(type), DataFormat.Default, ref type, out var modelKey) != WireType.None && modelKey < 0)
			{
				return value;
			}
			using MemoryStream memoryStream2 = new MemoryStream();
			using (ProtoWriter protoWriter2 = new ProtoWriter(memoryStream2, this, null))
			{
				if (!TrySerializeAuxiliaryType(protoWriter2, type, DataFormat.Default, 1, value, isInsideList: false))
				{
					ThrowUnexpectedType(type);
				}
				protoWriter2.Close();
			}
			memoryStream2.Position = 0L;
			ProtoReader reader = null;
			try
			{
				reader = ProtoReader.Create(memoryStream2, this, null, -1);
				value = null;
				TryDeserializeAuxiliaryType(reader, DataFormat.Default, 1, type, ref value, skipOtherFields: true, asListItem: false, autoCreate: true, insideList: false);
				return value;
			}
			finally
			{
				ProtoReader.Recycle(reader);
			}
		}

		protected internal static void ThrowUnexpectedSubtype(Type expected, Type actual)
		{
			if ((object)expected != ResolveProxies(actual))
			{
				throw new InvalidOperationException("Unexpected sub-type: " + actual.FullName);
			}
		}

		protected internal static void ThrowUnexpectedType(Type type)
		{
			string text = (((object)type == null) ? "(unknown)" : type.FullName);
			if ((object)type != null)
			{
				Type baseType = type.BaseType;
				if ((object)baseType != null && baseType.IsGenericType && baseType.GetGenericTypeDefinition().Name == "GeneratedMessage`2")
				{
					throw new InvalidOperationException("Are you mixing protobuf-net and protobuf-csharp-port? See http://stackoverflow.com/q/11564914; type: " + text);
				}
			}
			throw new InvalidOperationException("Type is not expected, and no contract can be inferred: " + text);
		}

		internal static Exception CreateNestedListsNotSupported()
		{
			return new NotSupportedException("Nested or jagged lists and arrays are not supported");
		}

		public static void ThrowCannotCreateInstance(Type type)
		{
			throw new ProtoException("No parameterless constructor found for " + (((object)type == null) ? "(null)" : type.Name));
		}

		internal static string SerializeType(TypeModel model, Type type)
		{
			if (model != null)
			{
				TypeFormatEventHandler dynamicTypeFormatting = model.DynamicTypeFormatting;
				if (dynamicTypeFormatting != null)
				{
					TypeFormatEventArgs e = new TypeFormatEventArgs(type);
					dynamicTypeFormatting(model, e);
					if (!Helpers.IsNullOrEmpty(e.FormattedName))
					{
						return e.FormattedName;
					}
				}
			}
			return type.AssemblyQualifiedName;
		}

		internal static Type DeserializeType(TypeModel model, string value)
		{
			if (model != null)
			{
				TypeFormatEventHandler dynamicTypeFormatting = model.DynamicTypeFormatting;
				if (dynamicTypeFormatting != null)
				{
					TypeFormatEventArgs e = new TypeFormatEventArgs(value);
					dynamicTypeFormatting(model, e);
					if ((object)e.Type != null)
					{
						return e.Type;
					}
				}
			}
			return Type.GetType(value);
		}

		public bool CanSerializeContractType(Type type)
		{
			return CanSerialize(type, allowBasic: false, allowContract: true, allowLists: true);
		}

		public bool CanSerialize(Type type)
		{
			return CanSerialize(type, allowBasic: true, allowContract: true, allowLists: true);
		}

		public bool CanSerializeBasicType(Type type)
		{
			return CanSerialize(type, allowBasic: true, allowContract: false, allowLists: true);
		}

		private bool CanSerialize(Type type, bool allowBasic, bool allowContract, bool allowLists)
		{
			if ((object)type == null)
			{
				throw new ArgumentNullException("type");
			}
			Type underlyingType = Helpers.GetUnderlyingType(type);
			if ((object)underlyingType != null)
			{
				type = underlyingType;
			}
			switch (Helpers.GetTypeCode(type))
			{
			default:
				return allowBasic;
			case ProtoTypeCode.Empty:
			case ProtoTypeCode.Unknown:
			{
				int key = GetKey(ref type);
				if (key >= 0)
				{
					return allowContract;
				}
				if (allowLists)
				{
					Type type2 = null;
					if (type.IsArray)
					{
						if (type.GetArrayRank() == 1)
						{
							type2 = type.GetElementType();
						}
					}
					else
					{
						type2 = GetListItemType(this, type);
					}
					if ((object)type2 != null)
					{
						return CanSerialize(type2, allowBasic, allowContract, allowLists: false);
					}
				}
				return false;
			}
			}
		}

		public virtual string GetSchema(Type type)
		{
			throw new NotSupportedException();
		}

		public IFormatter CreateFormatter(Type type)
		{
			return new Formatter(this, type);
		}

		internal virtual Type GetType(string fullName, Assembly context)
		{
			return ResolveKnownType(fullName, this, context);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		internal static Type ResolveKnownType(string name, TypeModel model, Assembly assembly)
		{
			if (Helpers.IsNullOrEmpty(name))
			{
				return null;
			}
			try
			{
				Type type = Type.GetType(name);
				if ((object)type != null)
				{
					return type;
				}
			}
			catch
			{
			}
			try
			{
				int num = name.IndexOf(',');
				string name2 = ((num > 0) ? name.Substring(0, num) : name).Trim();
				if ((object)assembly == null)
				{
					assembly = Assembly.GetCallingAssembly();
				}
				Type type2 = assembly?.GetType(name2);
				if ((object)type2 != null)
				{
					return type2;
				}
			}
			catch
			{
			}
			return null;
		}
	}
	public sealed class RuntimeTypeModel : TypeModel
	{
		private sealed class Singleton
		{
			internal static readonly RuntimeTypeModel Value = new RuntimeTypeModel(isDefault: true);

			private Singleton()
			{
			}
		}

		private sealed class BasicType
		{
			private readonly Type type;

			private readonly IProtoSerializer serializer;

			public Type Type => type;

			public IProtoSerializer Serializer => serializer;

			public BasicType(Type type, IProtoSerializer serializer)
			{
				this.type = type;
				this.serializer = serializer;
			}
		}

		internal sealed class SerializerPair : IComparable
		{
			public readonly int MetaKey;

			public readonly int BaseKey;

			public readonly MetaType Type;

			public readonly MethodBuilder Serialize;

			public readonly MethodBuilder Deserialize;

			public readonly ILGenerator SerializeBody;

			public readonly ILGenerator DeserializeBody;

			int IComparable.CompareTo(object obj)
			{
				if (obj == null)
				{
					throw new ArgumentException("obj");
				}
				SerializerPair serializerPair = (SerializerPair)obj;
				if (BaseKey == MetaKey)
				{
					if (serializerPair.BaseKey == serializerPair.MetaKey)
					{
						int metaKey = MetaKey;
						return metaKey.CompareTo(serializerPair.MetaKey);
					}
					return 1;
				}
				if (serializerPair.BaseKey == serializerPair.MetaKey)
				{
					return -1;
				}
				int baseKey = BaseKey;
				int num = baseKey.CompareTo(serializerPair.BaseKey);
				if (num == 0)
				{
					int metaKey2 = MetaKey;
					num = metaKey2.CompareTo(serializerPair.MetaKey);
				}
				return num;
			}

			public SerializerPair(int metaKey, int baseKey, MetaType type, MethodBuilder serialize, MethodBuilder deserialize, ILGenerator serializeBody, ILGenerator deserializeBody)
			{
				MetaKey = metaKey;
				BaseKey = baseKey;
				Serialize = serialize;
				Deserialize = deserialize;
				SerializeBody = serializeBody;
				DeserializeBody = deserializeBody;
				Type = type;
			}
		}

		public sealed class CompilerOptions
		{
			private string targetFrameworkName;

			private string targetFrameworkDisplayName;

			private string typeName;

			private string outputPath;

			private string imageRuntimeVersion;

			private int metaDataVersion;

			private Accessibility accessibility;

			public string TargetFrameworkName
			{
				get
				{
					return targetFrameworkName;
				}
				set
				{
					targetFrameworkName = value;
				}
			}

			public string TargetFrameworkDisplayName
			{
				get
				{
					return targetFrameworkDisplayName;
				}
				set
				{
					targetFrameworkDisplayName = value;
				}
			}

			public string TypeName
			{
				get
				{
					return typeName;
				}
				set
				{
					typeName = value;
				}
			}

			public string OutputPath
			{
				get
				{
					return outputPath;
				}
				set
				{
					outputPath = value;
				}
			}

			public string ImageRuntimeVersion
			{
				get
				{
					return imageRuntimeVersion;
				}
				set
				{
					imageRuntimeVersion = value;
				}
			}

			public int MetaDataVersion
			{
				get
				{
					return metaDataVersion;
				}
				set
				{
					metaDataVersion = value;
				}
			}

			public Accessibility Accessibility
			{
				get
				{
					return accessibility;
				}
				set
				{
					accessibility = value;
				}
			}

			public void SetFrameworkOptions(MetaType from)
			{
				if (from == null)
				{
					throw new ArgumentNullException("from");
				}
				AttributeMap[] array = AttributeMap.Create(from.Model, from.Type.Assembly);
				AttributeMap[] array2 = array;
				foreach (AttributeMap attributeMap in array2)
				{
					if (attributeMap.AttributeType.FullName == "System.Runtime.Versioning.TargetFrameworkAttribute")
					{
						if (attributeMap.TryGet("FrameworkName", out var value))
						{
							TargetFrameworkName = (string)value;
						}
						if (attributeMap.TryGet("FrameworkDisplayName", out value))
						{
							TargetFrameworkDisplayName = (string)value;
						}
						break;
					}
				}
			}
		}

		public enum Accessibility
		{
			Public,
			Internal
		}

		private const byte OPTIONS_InferTagFromNameDefault = 1;

		private const byte OPTIONS_IsDefaultModel = 2;

		private const byte OPTIONS_Frozen = 4;

		private const byte OPTIONS_AutoAddMissingTypes = 8;

		private const byte OPTIONS_AutoCompile = 16;

		private const byte OPTIONS_UseImplicitZeroDefaults = 32;

		private const byte OPTIONS_AllowParseableTypes = 64;

		private const byte OPTIONS_AutoAddProtoContractTypesOnly = 128;

		private const int KnownTypes_Array = 1;

		private const int KnownTypes_Dictionary = 2;

		private const int KnownTypes_Hashtable = 3;

		private const int KnownTypes_ArrayCutoff = 20;

		private byte options;

		private static readonly BasicList.MatchPredicate MetaTypeFinder = MetaTypeFinderImpl;

		private static readonly BasicList.MatchPredicate BasicTypeFinder = BasicTypeFinderImpl;

		private BasicList basicTypes = new BasicList();

		private readonly BasicList types = new BasicList();

		private int metadataTimeoutMilliseconds = 5000;

		private int contentionCounter = 1;

		private readonly object contentionLock = new object();

		private MethodInfo defaultFactory;

		public bool InferTagFromNameDefault
		{
			get
			{
				return GetOption(1);
			}
			set
			{
				SetOption(1, value);
			}
		}

		public bool AutoAddProtoContractTypesOnly
		{
			get
			{
				return GetOption(128);
			}
			set
			{
				SetOption(128, value);
			}
		}

		public bool UseImplicitZeroDefaults
		{
			get
			{
				return GetOption(32);
			}
			set
			{
				if (!value && GetOption(2))
				{
					throw new InvalidOperationException("UseImplicitZeroDefaults cannot be disabled on the default model");
				}
				SetOption(32, value);
			}
		}

		public bool AllowParseableTypes
		{
			get
			{
				return GetOption(64);
			}
			set
			{
				SetOption(64, value);
			}
		}

		public static RuntimeTypeModel Default => Singleton.Value;

		public MetaType this[Type type] => (MetaType)types[FindOrAddAuto(type, demand: true, addWithContractOnly: false, addEvenIfAutoDisabled: false)];

		public bool AutoCompile
		{
			get
			{
				return GetOption(16);
			}
			set
			{
				SetOption(16, value);
			}
		}

		public bool AutoAddMissingTypes
		{
			get
			{
				return GetOption(8);
			}
			set
			{
				if (!value && GetOption(2))
				{
					throw new InvalidOperationException("The default model must allow missing types");
				}
				ThrowIfFrozen();
				SetOption(8, value);
			}
		}

		public int MetadataTimeoutMilliseconds
		{
			get
			{
				return metadataTimeoutMilliseconds;
			}
			set
			{
				if (value <= 0)
				{
					throw new ArgumentOutOfRangeException("MetadataTimeoutMilliseconds");
				}
				metadataTimeoutMilliseconds = value;
			}
		}

		public event LockContentedEventHandler LockContended;

		private bool GetOption(byte option)
		{
			return (options & option) == option;
		}

		private void SetOption(byte option, bool value)
		{
			if (value)
			{
				options |= option;
			}
			else
			{
				options &= (byte)(~option);
			}
		}

		public IEnumerable GetTypes()
		{
			return types;
		}

		public override string GetSchema(Type type)
		{
			BasicList basicList = new BasicList();
			MetaType metaType = null;
			bool flag = false;
			if ((object)type == null)
			{
				BasicList.NodeEnumerator enumerator = types.GetEnumerator();
				while (enumerator.MoveNext())
				{
					MetaType metaType2 = (MetaType)enumerator.Current;
					MetaType surrogateOrBaseOrSelf = metaType2.GetSurrogateOrBaseOrSelf(deep: false);
					if (!basicList.Contains(surrogateOrBaseOrSelf))
					{
						basicList.Add(surrogateOrBaseOrSelf);
						CascadeDependents(basicList, surrogateOrBaseOrSelf);
					}
				}
			}
			else
			{
				Type underlyingType = Helpers.GetUnderlyingType(type);
				if ((object)underlyingType != null)
				{
					type = underlyingType;
				}
				flag = ValueMember.TryGetCoreSerializer(this, DataFormat.Default, type, out var _, asReference: false, dynamicType: false, overwriteList: false, allowComplexTypes: false) != null;
				if (!flag)
				{
					int num = FindOrAddAuto(type, demand: false, addWithContractOnly: false, addEvenIfAutoDisabled: false);
					if (num < 0)
					{
						throw new ArgumentException("The type specified is not a contract-type", "type");
					}
					metaType = ((MetaType)types[num]).GetSurrogateOrBaseOrSelf(deep: false);
					basicList.Add(metaType);
					CascadeDependents(basicList, metaType);
				}
			}
			StringBuilder stringBuilder = new StringBuilder();
			string text = null;
			if (!flag)
			{
				IEnumerable enumerable = ((metaType == null) ? types : basicList);
				foreach (MetaType item in enumerable)
				{
					if (item.IsList)
					{
						continue;
					}
					string text2 = item.Type.Namespace;
					if (!Helpers.IsNullOrEmpty(text2) && !text2.StartsWith("System."))
					{
						if (text == null)
						{
							text = text2;
						}
						else if (!(text == text2))
						{
							text = null;
							break;
						}
					}
				}
			}
			if (!Helpers.IsNullOrEmpty(text))
			{
				stringBuilder.Append("package ").Append(text).Append(';');
				Helpers.AppendLine(stringBuilder);
			}
			bool requiresBclImport = false;
			StringBuilder stringBuilder2 = new StringBuilder();
			MetaType[] array = new MetaType[basicList.Count];
			basicList.CopyTo(array, 0);
			Array.Sort(array, MetaType.Comparer.Default);
			if (flag)
			{
				Helpers.AppendLine(stringBuilder2).Append("message ").Append(type.Name)
					.Append(" {");
				MetaType.NewLine(stringBuilder2, 1).Append("optional ").Append(GetSchemaTypeName(type, DataFormat.Default, asReference: false, dynamicType: false, ref requiresBclImport))
					.Append(" value = 1;");
				Helpers.AppendLine(stringBuilder2).Append('}');
			}
			else
			{
				foreach (MetaType metaType4 in array)
				{
					if (!metaType4.IsList || metaType4 == metaType)
					{
						metaType4.WriteSchema(stringBuilder2, 0, ref requiresBclImport);
					}
				}
			}
			if (requiresBclImport)
			{
				stringBuilder.Append("import \"bcl.proto\"; // schema for protobuf-net's handling of core .NET types");
				Helpers.AppendLine(stringBuilder);
			}
			return Helpers.AppendLine(stringBuilder.Append((object)stringBuilder2)).ToString();
		}

		private void CascadeDependents(BasicList list, MetaType metaType)
		{
			MetaType surrogateOrBaseOrSelf;
			if (metaType.IsList)
			{
				Type listItemType = TypeModel.GetListItemType(this, metaType.Type);
				WireType defaultWireType;
				IProtoSerializer protoSerializer = ValueMember.TryGetCoreSerializer(this, DataFormat.Default, listItemType, out defaultWireType, asReference: false, dynamicType: false, overwriteList: false, allowComplexTypes: false);
				if (protoSerializer != null)
				{
					return;
				}
				int num = FindOrAddAuto(listItemType, demand: false, addWithContractOnly: false, addEvenIfAutoDisabled: false);
				if (num >= 0)
				{
					surrogateOrBaseOrSelf = ((MetaType)types[num]).GetSurrogateOrBaseOrSelf(deep: false);
					if (!list.Contains(surrogateOrBaseOrSelf))
					{
						list.Add(surrogateOrBaseOrSelf);
						CascadeDependents(list, surrogateOrBaseOrSelf);
					}
				}
				return;
			}
			if (metaType.IsAutoTuple)
			{
				if ((object)MetaType.ResolveTupleConstructor(metaType.Type, out var mappedMembers) != null)
				{
					for (int i = 0; i < mappedMembers.Length; i++)
					{
						Type type = null;
						if (mappedMembers[i] is PropertyInfo)
						{
							type = ((PropertyInfo)mappedMembers[i]).PropertyType;
						}
						else if (mappedMembers[i] is FieldInfo)
						{
							type = ((FieldInfo)mappedMembers[i]).FieldType;
						}
						WireType defaultWireType2;
						IProtoSerializer protoSerializer2 = ValueMember.TryGetCoreSerializer(this, DataFormat.Default, type, out defaultWireType2, asReference: false, dynamicType: false, overwriteList: false, allowComplexTypes: false);
						if (protoSerializer2 != null)
						{
							continue;
						}
						int num2 = FindOrAddAuto(type, demand: false, addWithContractOnly: false, addEvenIfAutoDisabled: false);
						if (num2 >= 0)
						{
							surrogateOrBaseOrSelf = ((MetaType)types[num2]).GetSurrogateOrBaseOrSelf(deep: false);
							if (!list.Contains(surrogateOrBaseOrSelf))
							{
								list.Add(surrogateOrBaseOrSelf);
								CascadeDependents(list, surrogateOrBaseOrSelf);
							}
						}
					}
				}
			}
			else
			{
				foreach (ValueMember field in metaType.Fields)
				{
					Type type2 = field.ItemType;
					if ((object)type2 == null)
					{
						type2 = field.MemberType;
					}
					WireType defaultWireType3;
					IProtoSerializer protoSerializer3 = ValueMember.TryGetCoreSerializer(this, DataFormat.Default, type2, out defaultWireType3, asReference: false, dynamicType: false, overwriteList: false, allowComplexTypes: false);
					if (protoSerializer3 != null)
					{
						continue;
					}
					int num3 = FindOrAddAuto(type2, demand: false, addWithContractOnly: false, addEvenIfAutoDisabled: false);
					if (num3 >= 0)
					{
						surrogateOrBaseOrSelf = ((MetaType)types[num3]).GetSurrogateOrBaseOrSelf(deep: false);
						if (!list.Contains(surrogateOrBaseOrSelf))
						{
							list.Add(surrogateOrBaseOrSelf);
							CascadeDependents(list, surrogateOrBaseOrSelf);
						}
					}
				}
			}
			if (metaType.HasSubtypes)
			{
				SubType[] subtypes = metaType.GetSubtypes();
				foreach (SubType subType in subtypes)
				{
					surrogateOrBaseOrSelf = subType.DerivedType.GetSurrogateOrSelf();
					if (!list.Contains(surrogateOrBaseOrSelf))
					{
						list.Add(surrogateOrBaseOrSelf);
						CascadeDependents(list, surrogateOrBaseOrSelf);
					}
				}
			}
			surrogateOrBaseOrSelf = metaType.BaseType;
			if (surrogateOrBaseOrSelf != null)
			{
				surrogateOrBaseOrSelf = surrogateOrBaseOrSelf.GetSurrogateOrSelf();
			}
			if (surrogateOrBaseOrSelf != null && !list.Contains(surrogateOrBaseOrSelf))
			{
				list.Add(surrogateOrBaseOrSelf);
				CascadeDependents(list, surrogateOrBaseOrSelf);
			}
		}

		internal RuntimeTypeModel(bool isDefault)
		{
			AutoAddMissingTypes = true;
			UseImplicitZeroDefaults = true;
			SetOption(2, isDefault);
			AutoCompile = true;
		}

		internal MetaType FindWithoutAdd(Type type)
		{
			BasicList.NodeEnumerator enumerator = types.GetEnumerator();
			while (enumerator.MoveNext())
			{
				MetaType metaType = (MetaType)enumerator.Current;
				if ((object)metaType.Type == type)
				{
					if (metaType.Pending)
					{
						WaitOnLock(metaType);
					}
					return metaType;
				}
			}
			Type type2 = TypeModel.ResolveProxies(type);
			if ((object)type2 != null)
			{
				return FindWithoutAdd(type2);
			}
			return null;
		}

		private static bool MetaTypeFinderImpl(object value, object ctx)
		{
			return (object)((MetaType)value).Type == (Type)ctx;
		}

		private static bool BasicTypeFinderImpl(object value, object ctx)
		{
			return (object)((BasicType)value).Type == (Type)ctx;
		}

		private void WaitOnLock(MetaType type)
		{
			int opaqueToken = 0;
			try
			{
				TakeLock(ref opaqueToken);
			}
			finally
			{
				ReleaseLock(opaqueToken);
			}
		}

		internal IProtoSerializer TryGetBasicTypeSerializer(Type type)
		{
			int num = basicTypes.IndexOf(BasicTypeFinder, type);
			if (num >= 0)
			{
				return ((BasicType)basicTypes[num]).Serializer;
			}
			lock (basicTypes)
			{
				num = basicTypes.IndexOf(BasicTypeFinder, type);
				if (num >= 0)
				{
					return ((BasicType)basicTypes[num]).Serializer;
				}
				WireType defaultWireType;
				IProtoSerializer protoSerializer = ((MetaType.GetContractFamily(this, type, null) == MetaType.AttributeFamily.None) ? ValueMember.TryGetCoreSerializer(this, DataFormat.Default, type, out defaultWireType, asReference: false, dynamicType: false, overwriteList: false, allowComplexTypes: false) : null);
				if (protoSerializer != null)
				{
					basicTypes.Add(new BasicType(type, protoSerializer));
				}
				return protoSerializer;
			}
		}

		internal int FindOrAddAuto(Type type, bool demand, bool addWithContractOnly, bool addEvenIfAutoDisabled)
		{
			int num = types.IndexOf(MetaTypeFinder, type);
			if (num >= 0)
			{
				MetaType metaType = (MetaType)types[num];
				if (metaType.Pending)
				{
					WaitOnLock(metaType);
				}
				return num;
			}
			bool flag = AutoAddMissingTypes || addEvenIfAutoDisabled;
			if (!Helpers.IsEnum(type) && TryGetBasicTypeSerializer(type) != null)
			{
				if (flag && !addWithContractOnly)
				{
					throw MetaType.InbuiltType(type);
				}
				return -1;
			}
			Type type2 = TypeModel.ResolveProxies(type);
			if ((object)type2 != null)
			{
				num = types.IndexOf(MetaTypeFinder, type2);
				type = type2;
			}
			if (num < 0)
			{
				int opaqueToken = 0;
				try
				{
					TakeLock(ref opaqueToken);
					MetaType metaType;
					if ((metaType = RecogniseCommonTypes(type)) == null)
					{
						MetaType.AttributeFamily contractFamily = MetaType.GetContractFamily(this, type, null);
						if (contractFamily == MetaType.AttributeFamily.AutoTuple)
						{
							flag = (addEvenIfAutoDisabled = true);
						}
						if (!flag || (!Helpers.IsEnum(type) && addWithContractOnly && contractFamily == MetaType.AttributeFamily.None))
						{
							if (demand)
							{
								TypeModel.ThrowUnexpectedType(type);
							}
							return num;
						}
						metaType = Create(type);
					}
					metaType.Pending = true;
					bool flag2 = false;
					int num2 = types.IndexOf(MetaTypeFinder, type);
					if (num2 < 0)
					{
						ThrowIfFrozen();
						num = types.Add(metaType);
						flag2 = true;
					}
					else
					{
						num = num2;
					}
					if (flag2)
					{
						metaType.ApplyDefaultBehaviour();
						metaType.Pending = false;
					}
				}
				finally
				{
					ReleaseLock(opaqueToken);
				}
			}
			return num;
		}

		private MetaType RecogniseCommonTypes(Type type)
		{
			return null;
		}

		private MetaType Create(Type type)
		{
			ThrowIfFrozen();
			return new MetaType(this, type, defaultFactory);
		}

		public MetaType Add(Type type, bool applyDefaultBehaviour)
		{
			if ((object)type == null)
			{
				throw new ArgumentNullException("type");
			}
			MetaType metaType = FindWithoutAdd(type);
			if (metaType != null)
			{
				return metaType;
			}
			int opaqueToken = 0;
			if (type.IsInterface && MapType(MetaType.ienumerable).IsAssignableFrom(type) && (object)TypeModel.GetListItemType(this, type) == null)
			{
				throw new ArgumentException("IEnumerable[<T>] data cannot be used as a meta-type unless an Add method can be resolved");
			}
			try
			{
				metaType = RecogniseCommonTypes(type);
				if (metaType != null)
				{
					if (!applyDefaultBehaviour)
					{
						throw new ArgumentException("Default behaviour must be observed for certain types with special handling; " + type.FullName, "applyDefaultBehaviour");
					}
					applyDefaultBehaviour = false;
				}
				if (metaType == null)
				{
					metaType = Create(type);
				}
				metaType.Pending = true;
				TakeLock(ref opaqueToken);
				if (FindWithoutAdd(type) != null)
				{
					throw new ArgumentException("Duplicate type", "type");
				}
				ThrowIfFrozen();
				types.Add(metaType);
				if (applyDefaultBehaviour)
				{
					metaType.ApplyDefaultBehaviour();
				}
				metaType.Pending = false;
				return metaType;
			}
			finally
			{
				ReleaseLock(opaqueToken);
			}
		}

		private void ThrowIfFrozen()
		{
			if (GetOption(4))
			{
				throw new InvalidOperationException("The model cannot be changed once frozen");
			}
		}

		public void Freeze()
		{
			if (GetOption(2))
			{
				throw new InvalidOperationException("The default model cannot be frozen");
			}
			SetOption(4, value: true);
		}

		protected override int GetKeyImpl(Type type)
		{
			return GetKey(type, demand: false, getBaseKey: true);
		}

		internal int GetKey(Type type, bool demand, bool getBaseKey)
		{
			try
			{
				int num = FindOrAddAuto(type, demand, addWithContractOnly: true, addEvenIfAutoDisabled: false);
				if (num >= 0)
				{
					MetaType source = (MetaType)types[num];
					if (getBaseKey)
					{
						source = MetaType.GetRootType(source);
						num = FindOrAddAuto(source.Type, demand: true, addWithContractOnly: true, addEvenIfAutoDisabled: false);
					}
				}
				return num;
			}
			catch (NotSupportedException)
			{
				throw;
			}
			catch (Exception ex2)
			{
				if (ex2.Message.IndexOf(type.FullName) >= 0)
				{
					throw;
				}
				throw new ProtoException(ex2.Message + " (" + type.FullName + ")", ex2);
			}
		}

		protected internal override void Serialize(int key, object value, ProtoWriter dest)
		{
			((MetaType)types[key]).Serializer.Write(value, dest);
		}

		protected internal override object Deserialize(int key, object value, ProtoReader source)
		{
			IProtoSerializer serializer = ((MetaType)types[key]).Serializer;
			if (value == null && Helpers.IsValueType(serializer.ExpectedType))
			{
				if (serializer.RequiresOldValue)
				{
					value = Activator.CreateInstance(serializer.ExpectedType);
				}
				return serializer.Read(value, source);
			}
			return serializer.Read(value, source);
		}

		internal ProtoSerializer GetSerializer(IProtoSerializer serializer, bool compiled)
		{
			if (serializer == null)
			{
				throw new ArgumentNullException("serializer");
			}
			if (compiled)
			{
				return CompilerContext.BuildSerializer(serializer, this);
			}
			return serializer.Write;
		}

		public void CompileInPlace()
		{
			BasicList.NodeEnumerator enumerator = types.GetEnumerator();
			while (enumerator.MoveNext())
			{
				MetaType metaType = (MetaType)enumerator.Current;
				metaType.CompileInPlace();
			}
		}

		private void BuildAllSerializers()
		{
			for (int i = 0; i < types.Count; i++)
			{
				MetaType metaType = (MetaType)types[i];
				if (metaType.Serializer == null)
				{
					throw new InvalidOperationException("No serializer available for " + metaType.Type.Name);
				}
			}
		}

		public TypeModel Compile()
		{
			return Compile(null, null);
		}

		private static ILGenerator Override(TypeBuilder type, string name)
		{
			MethodInfo method = type.BaseType.GetMethod(name, BindingFlags.Instance | BindingFlags.NonPublic);
			ParameterInfo[] parameters = method.GetParameters();
			Type[] array = new Type[parameters.Length];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = parameters[i].ParameterType;
			}
			MethodBuilder methodBuilder = type.DefineMethod(method.Name, (method.Attributes & ~System.Reflection.MethodAttributes.Abstract) | System.Reflection.MethodAttributes.Final, method.CallingConvention, method.ReturnType, array);
			ILGenerator iLGenerator = methodBuilder.GetILGenerator();
			type.DefineMethodOverride(methodBuilder, method);
			return iLGenerator;
		}

		public TypeModel Compile(string name, string path)
		{
			CompilerOptions compilerOptions = new CompilerOptions();
			compilerOptions.TypeName = name;
			compilerOptions.OutputPath = path;
			return Compile(compilerOptions);
		}

		public TypeModel Compile(CompilerOptions options)
		{
			if (options == null)
			{
				throw new ArgumentNullException("options");
			}
			string text = options.TypeName;
			string outputPath = options.OutputPath;
			BuildAllSerializers();
			Freeze();
			bool flag = !Helpers.IsNullOrEmpty(outputPath);
			if (Helpers.IsNullOrEmpty(text))
			{
				if (flag)
				{
					throw new ArgumentNullException("typeName");
				}
				text = Guid.NewGuid().ToString();
			}
			string text2;
			string name;
			if (outputPath == null)
			{
				text2 = text;
				name = text2 + ".dll";
			}
			else
			{
				text2 = new FileInfo(Path.GetFileNameWithoutExtension(outputPath)).Name;
				name = text2 + Path.GetExtension(outputPath);
			}
			AssemblyName assemblyName = new AssemblyName();
			assemblyName.Name = text2;
			AssemblyBuilder assemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, (!flag) ? AssemblyBuilderAccess.Run : AssemblyBuilderAccess.RunAndSave);
			ModuleBuilder module = (flag ? assemblyBuilder.DefineDynamicModule(name, outputPath) : assemblyBuilder.DefineDynamicModule(name));
			WriteAssemblyAttributes(options, text2, assemblyBuilder);
			TypeBuilder typeBuilder = WriteBasicTypeModel(options, text, module);
			WriteSerializers(options, text2, typeBuilder, out var index, out var hasInheritance, out var methodPairs, out var ilVersion);
			WriteGetKeyImpl(typeBuilder, hasInheritance, methodPairs, ilVersion, text2, out var il, out var knownTypesCategory, out var knownTypes, out var knownTypesLookupType);
			CompilerContext ctx = WriteSerializeDeserialize(text2, typeBuilder, methodPairs, ilVersion, ref il);
			WriteConstructors(typeBuilder, ref index, methodPairs, ref il, knownTypesCategory, knownTypes, knownTypesLookupType, ctx);
			Type type = typeBuilder.CreateType();
			if (!Helpers.IsNullOrEmpty(outputPath))
			{
				assemblyBuilder.Save(outputPath);
			}
			return (TypeModel)Activator.CreateInstance(type);
		}

		private void WriteConstructors(TypeBuilder type, ref int index, SerializerPair[] methodPairs, ref ILGenerator il, int knownTypesCategory, FieldBuilder knownTypes, Type knownTypesLookupType, CompilerContext ctx)
		{
			type.DefineDefaultConstructor(System.Reflection.MethodAttributes.Public);
			il = type.DefineTypeInitializer().GetILGenerator();
			switch (knownTypesCategory)
			{
			case 1:
				CompilerContext.LoadValue(il, types.Count);
				il.Emit(System.Reflection.Emit.OpCodes.Newarr, ctx.MapType(typeof(Type)));
				index = 0;
				foreach (SerializerPair serializerPair3 in methodPairs)
				{
					il.Emit(System.Reflection.Emit.OpCodes.Dup);
					CompilerContext.LoadValue(il, index);
					il.Emit(System.Reflection.Emit.OpCodes.Ldtoken, serializerPair3.Type.Type);
					il.EmitCall(System.Reflection.Emit.OpCodes.Call, ctx.MapType(typeof(Type)).GetMethod("GetTypeFromHandle"), null);
					il.Emit(System.Reflection.Emit.OpCodes.Stelem_Ref);
					index++;
				}
				il.Emit(System.Reflection.Emit.OpCodes.Stsfld, knownTypes);
				il.Emit(System.Reflection.Emit.OpCodes.Ret);
				break;
			case 2:
			{
				CompilerContext.LoadValue(il, types.Count);
				il.Emit(System.Reflection.Emit.OpCodes.Newobj, knownTypesLookupType.GetConstructor(new Type[1] { MapType(typeof(int)) }));
				il.Emit(System.Reflection.Emit.OpCodes.Stsfld, knownTypes);
				int num2 = 0;
				foreach (SerializerPair serializerPair2 in methodPairs)
				{
					il.Emit(System.Reflection.Emit.OpCodes.Ldsfld, knownTypes);
					il.Emit(System.Reflection.Emit.OpCodes.Ldtoken, serializerPair2.Type.Type);
					il.EmitCall(System.Reflection.Emit.OpCodes.Call, ctx.MapType(typeof(Type)).GetMethod("GetTypeFromHandle"), null);
					int value2 = num2++;
					int baseKey2 = serializerPair2.BaseKey;
					if (baseKey2 != serializerPair2.MetaKey)
					{
						value2 = -1;
						for (int l = 0; l < methodPairs.Length; l++)
						{
							if (methodPairs[l].BaseKey == baseKey2 && methodPairs[l].MetaKey == baseKey2)
							{
								value2 = l;
								break;
							}
						}
					}
					CompilerContext.LoadValue(il, value2);
					il.EmitCall(System.Reflection.Emit.OpCodes.Callvirt, knownTypesLookupType.GetMethod("Add", new Type[2]
					{
						MapType(typeof(Type)),
						MapType(typeof(int))
					}), null);
				}
				il.Emit(System.Reflection.Emit.OpCodes.Ret);
				break;
			}
			case 3:
			{
				CompilerContext.LoadValue(il, types.Count);
				il.Emit(System.Reflection.Emit.OpCodes.Newobj, knownTypesLookupType.GetConstructor(new Type[1] { MapType(typeof(int)) }));
				il.Emit(System.Reflection.Emit.OpCodes.Stsfld, knownTypes);
				int num = 0;
				foreach (SerializerPair serializerPair in methodPairs)
				{
					il.Emit(System.Reflection.Emit.OpCodes.Ldsfld, knownTypes);
					il.Emit(System.Reflection.Emit.OpCodes.Ldtoken, serializerPair.Type.Type);
					il.EmitCall(System.Reflection.Emit.OpCodes.Call, ctx.MapType(typeof(Type)).GetMethod("GetTypeFromHandle"), null);
					int value = num++;
					int baseKey = serializerPair.BaseKey;
					if (baseKey != serializerPair.MetaKey)
					{
						value = -1;
						for (int j = 0; j < methodPairs.Length; j++)
						{
							if (methodPairs[j].BaseKey == baseKey && methodPairs[j].MetaKey == baseKey)
							{
								value = j;
								break;
							}
						}
					}
					CompilerContext.LoadValue(il, value);
					il.Emit(System.Reflection.Emit.OpCodes.Box, MapType(typeof(int)));
					il.EmitCall(System.Reflection.Emit.OpCodes.Callvirt, knownTypesLookupType.GetMethod("Add", new Type[2]
					{
						MapType(typeof(object)),
						MapType(typeof(object))
					}), null);
				}
				il.Emit(System.Reflection.Emit.OpCodes.Ret);
				break;
			}
			default:
				throw new InvalidOperationException();
			}
		}

		private CompilerContext WriteSerializeDeserialize(string assemblyName, TypeBuilder type, SerializerPair[] methodPairs, CompilerContext.ILVersion ilVersion, ref ILGenerator il)
		{
			il = Override(type, "Serialize");
			CompilerContext compilerContext = new CompilerContext(il, isStatic: false, isWriter: true, methodPairs, this, ilVersion, assemblyName, MapType(typeof(object)));
			CodeLabel[] array = new CodeLabel[types.Count];
			for (int i = 0; i < array.Length; i++)
			{
				ref CodeLabel reference = ref array[i];
				reference = compilerContext.DefineLabel();
			}
			il.Emit(System.Reflection.Emit.OpCodes.Ldarg_1);
			compilerContext.Switch(array);
			compilerContext.Return();
			for (int j = 0; j < array.Length; j++)
			{
				SerializerPair serializerPair = methodPairs[j];
				compilerContext.MarkLabel(array[j]);
				il.Emit(System.Reflection.Emit.OpCodes.Ldarg_2);
				compilerContext.CastFromObject(serializerPair.Type.Type);
				il.Emit(System.Reflection.Emit.OpCodes.Ldarg_3);
				il.EmitCall(System.Reflection.Emit.OpCodes.Call, serializerPair.Serialize, null);
				compilerContext.Return();
			}
			il = Override(type, "Deserialize");
			compilerContext = new CompilerContext(il, isStatic: false, isWriter: false, methodPairs, this, ilVersion, assemblyName, MapType(typeof(object)));
			for (int k = 0; k < array.Length; k++)
			{
				ref CodeLabel reference2 = ref array[k];
				reference2 = compilerContext.DefineLabel();
			}
			il.Emit(System.Reflection.Emit.OpCodes.Ldarg_1);
			compilerContext.Switch(array);
			compilerContext.LoadNullRef();
			compilerContext.Return();
			for (int l = 0; l < array.Length; l++)
			{
				SerializerPair serializerPair2 = methodPairs[l];
				compilerContext.MarkLabel(array[l]);
				Type type2 = serializerPair2.Type.Type;
				if (type2.IsValueType)
				{
					il.Emit(System.Reflection.Emit.OpCodes.Ldarg_2);
					il.Emit(System.Reflection.Emit.OpCodes.Ldarg_3);
					il.EmitCall(System.Reflection.Emit.OpCodes.Call, EmitBoxedSerializer(type, l, type2, methodPairs, this, ilVersion, assemblyName), null);
					compilerContext.Return();
				}
				else
				{
					il.Emit(System.Reflection.Emit.OpCodes.Ldarg_2);
					compilerContext.CastFromObject(type2);
					il.Emit(System.Reflection.Emit.OpCodes.Ldarg_3);
					il.EmitCall(System.Reflection.Emit.OpCodes.Call, serializerPair2.Deserialize, null);
					compilerContext.Return();
				}
			}
			return compilerContext;
		}

		private void WriteGetKeyImpl(TypeBuilder type, bool hasInheritance, SerializerPair[] methodPairs, CompilerContext.ILVersion ilVersion, string assemblyName, out ILGenerator il, out int knownTypesCategory, out FieldBuilder knownTypes, out Type knownTypesLookupType)
		{
			il = Override(type, "GetKeyImpl");
			CompilerContext compilerContext = new CompilerContext(il, isStatic: false, isWriter: false, methodPairs, this, ilVersion, assemblyName, MapType(typeof(Type), demand: true));
			if (types.Count <= 20)
			{
				knownTypesCategory = 1;
				knownTypesLookupType = MapType(typeof(Type[]), demand: true);
			}
			else
			{
				knownTypesLookupType = MapType(typeof(Dictionary<Type, int>), demand: false);
				if ((object)knownTypesLookupType == null)
				{
					knownTypesLookupType = MapType(typeof(Hashtable), demand: true);
					knownTypesCategory = 3;
				}
				else
				{
					knownTypesCategory = 2;
				}
			}
			knownTypes = type.DefineField("knownTypes", knownTypesLookupType, System.Reflection.FieldAttributes.Private | System.Reflection.FieldAttributes.Static | System.Reflection.FieldAttributes.InitOnly);
			switch (knownTypesCategory)
			{
			case 1:
				il.Emit(System.Reflection.Emit.OpCodes.Ldsfld, knownTypes);
				il.Emit(System.Reflection.Emit.OpCodes.Ldarg_1);
				il.EmitCall(System.Reflection.Emit.OpCodes.Callvirt, MapType(typeof(IList)).GetMethod("IndexOf", new Type[1] { MapType(typeof(object)) }), null);
				if (hasInheritance)
				{
					il.DeclareLocal(MapType(typeof(int)));
					il.Emit(System.Reflection.Emit.OpCodes.Dup);
					il.Emit(System.Reflection.Emit.OpCodes.Stloc_0);
					BasicList basicList = new BasicList();
					int num = -1;
					for (int i = 0; i < methodPairs.Length && methodPairs[i].MetaKey != methodPairs[i].BaseKey; i++)
					{
						if (num == methodPairs[i].BaseKey)
						{
							basicList.Add(basicList[basicList.Count - 1]);
							continue;
						}
						basicList.Add(compilerContext.DefineLabel());
						num = methodPairs[i].BaseKey;
					}
					CodeLabel[] array = new CodeLabel[basicList.Count];
					basicList.CopyTo(array, 0);
					compilerContext.Switch(array);
					il.Emit(System.Reflection.Emit.OpCodes.Ldloc_0);
					il.Emit(System.Reflection.Emit.OpCodes.Ret);
					num = -1;
					for (int num2 = array.Length - 1; num2 >= 0; num2--)
					{
						if (num != methodPairs[num2].BaseKey)
						{
							num = methodPairs[num2].BaseKey;
							int value = -1;
							for (int j = array.Length; j < methodPairs.Length; j++)
							{
								if (methodPairs[j].BaseKey == num && methodPairs[j].MetaKey == num)
								{
									value = j;
									break;
								}
							}
							compilerContext.MarkLabel(array[num2]);
							CompilerContext.LoadValue(il, value);
							il.Emit(System.Reflection.Emit.OpCodes.Ret);
						}
					}
				}
				else
				{
					il.Emit(System.Reflection.Emit.OpCodes.Ret);
				}
				break;
			case 2:
			{
				LocalBuilder local = il.DeclareLocal(MapType(typeof(int)));
				Label label2 = il.DefineLabel();
				il.Emit(System.Reflection.Emit.OpCodes.Ldsfld, knownTypes);
				il.Emit(System.Reflection.Emit.OpCodes.Ldarg_1);
				il.Emit(System.Reflection.Emit.OpCodes.Ldloca_S, local);
				il.EmitCall(System.Reflection.Emit.OpCodes.Callvirt, knownTypesLookupType.GetMethod("TryGetValue", BindingFlags.Instance | BindingFlags.Public), null);
				il.Emit(System.Reflection.Emit.OpCodes.Brfalse_S, label2);
				il.Emit(System.Reflection.Emit.OpCodes.Ldloc_S, local);
				il.Emit(System.Reflection.Emit.OpCodes.Ret);
				il.MarkLabel(label2);
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_M1);
				il.Emit(System.Reflection.Emit.OpCodes.Ret);
				break;
			}
			case 3:
			{
				Label label = il.DefineLabel();
				il.Emit(System.Reflection.Emit.OpCodes.Ldsfld, knownTypes);
				il.Emit(System.Reflection.Emit.OpCodes.Ldarg_1);
				il.EmitCall(System.Reflection.Emit.OpCodes.Callvirt, knownTypesLookupType.GetProperty("Item").GetGetMethod(), null);
				il.Emit(System.Reflection.Emit.OpCodes.Dup);
				il.Emit(System.Reflection.Emit.OpCodes.Brfalse_S, label);
				if (ilVersion == CompilerContext.ILVersion.Net1)
				{
					il.Emit(System.Reflection.Emit.OpCodes.Unbox, MapType(typeof(int)));
					il.Emit(System.Reflection.Emit.OpCodes.Ldobj, MapType(typeof(int)));
				}
				else
				{
					il.Emit(System.Reflection.Emit.OpCodes.Unbox_Any, MapType(typeof(int)));
				}
				il.Emit(System.Reflection.Emit.OpCodes.Ret);
				il.MarkLabel(label);
				il.Emit(System.Reflection.Emit.OpCodes.Pop);
				il.Emit(System.Reflection.Emit.OpCodes.Ldc_I4_M1);
				il.Emit(System.Reflection.Emit.OpCodes.Ret);
				break;
			}
			default:
				throw new InvalidOperationException();
			}
		}

		private void WriteSerializers(CompilerOptions options, string assemblyName, TypeBuilder type, out int index, out bool hasInheritance, out SerializerPair[] methodPairs, out CompilerContext.ILVersion ilVersion)
		{
			index = 0;
			hasInheritance = false;
			methodPairs = new SerializerPair[types.Count];
			BasicList.NodeEnumerator enumerator = types.GetEnumerator();
			while (enumerator.MoveNext())
			{
				MetaType metaType = (MetaType)enumerator.Current;
				MethodBuilder methodBuilder = type.DefineMethod("Write", System.Reflection.MethodAttributes.Private | System.Reflection.MethodAttributes.Static, CallingConventions.Standard, MapType(typeof(void)), new Type[2]
				{
					metaType.Type,
					MapType(typeof(ProtoWriter))
				});
				MethodBuilder methodBuilder2 = type.DefineMethod("Read", System.Reflection.MethodAttributes.Private | System.Reflection.MethodAttributes.Static, CallingConventions.Standard, metaType.Type, new Type[2]
				{
					metaType.Type,
					MapType(typeof(ProtoReader))
				});
				SerializerPair serializerPair = new SerializerPair(GetKey(metaType.Type, demand: true, getBaseKey: false), GetKey(metaType.Type, demand: true, getBaseKey: true), metaType, methodBuilder, methodBuilder2, methodBuilder.GetILGenerator(), methodBuilder2.GetILGenerator());
				methodPairs[index++] = serializerPair;
				if (serializerPair.MetaKey != serializerPair.BaseKey)
				{
					hasInheritance = true;
				}
			}
			if (hasInheritance)
			{
				Array.Sort(methodPairs);
			}
			ilVersion = CompilerContext.ILVersion.Net2;
			if (options.MetaDataVersion == 65536)
			{
				ilVersion = CompilerContext.ILVersion.Net1;
			}
			for (index = 0; index < methodPairs.Length; index++)
			{
				SerializerPair serializerPair2 = methodPairs[index];
				CompilerContext compilerContext = new CompilerContext(serializerPair2.SerializeBody, isStatic: true, isWriter: true, methodPairs, this, ilVersion, assemblyName, serializerPair2.Type.Type);
				compilerContext.CheckAccessibility(serializerPair2.Deserialize.ReturnType);
				serializerPair2.Type.Serializer.EmitWrite(compilerContext, compilerContext.InputValue);
				compilerContext.Return();
				compilerContext = new CompilerContext(serializerPair2.DeserializeBody, isStatic: true, isWriter: false, methodPairs, this, ilVersion, assemblyName, serializerPair2.Type.Type);
				serializerPair2.Type.Serializer.EmitRead(compilerContext, compilerContext.InputValue);
				if (!serializerPair2.Type.Serializer.ReturnsValue)
				{
					compilerContext.LoadValue(compilerContext.InputValue);
				}
				compilerContext.Return();
			}
		}

		private TypeBuilder WriteBasicTypeModel(CompilerOptions options, string typeName, ModuleBuilder module)
		{
			Type type = MapType(typeof(TypeModel));
			System.Reflection.TypeAttributes typeAttributes = (type.Attributes & ~System.Reflection.TypeAttributes.Abstract) | System.Reflection.TypeAttributes.Sealed;
			if (options.Accessibility == Accessibility.Internal)
			{
				typeAttributes &= ~System.Reflection.TypeAttributes.Public;
			}
			return module.DefineType(typeName, typeAttributes, type);
		}

		private void WriteAssemblyAttributes(CompilerOptions options, string assemblyName, AssemblyBuilder asm)
		{
			if (!Helpers.IsNullOrEmpty(options.TargetFrameworkName))
			{
				Type type = null;
				try
				{
					type = GetType("System.Runtime.Versioning.TargetFrameworkAttribute", MapType(typeof(string)).Assembly);
				}
				catch
				{
				}
				if ((object)type != null)
				{
					PropertyInfo[] namedProperties;
					object[] propertyValues;
					if (Helpers.IsNullOrEmpty(options.TargetFrameworkDisplayName))
					{
						namedProperties = new PropertyInfo[0];
						propertyValues = new object[0];
					}
					else
					{
						namedProperties = new PropertyInfo[1] { type.GetProperty("FrameworkDisplayName") };
						propertyValues = new object[1] { options.TargetFrameworkDisplayName };
					}
					CustomAttributeBuilder customAttribute = new CustomAttributeBuilder(type.GetConstructor(new Type[1] { MapType(typeof(string)) }), new object[1] { options.TargetFrameworkName }, namedProperties, propertyValues);
					asm.SetCustomAttribute(customAttribute);
				}
			}
			Type type2 = null;
			try
			{
				type2 = MapType(typeof(InternalsVisibleToAttribute));
			}
			catch
			{
			}
			if ((object)type2 == null)
			{
				return;
			}
			BasicList basicList = new BasicList();
			BasicList basicList2 = new BasicList();
			BasicList.NodeEnumerator enumerator = types.GetEnumerator();
			while (enumerator.MoveNext())
			{
				MetaType metaType = (MetaType)enumerator.Current;
				Assembly assembly = metaType.Type.Assembly;
				if (basicList2.IndexOfReference(assembly) >= 0)
				{
					continue;
				}
				basicList2.Add(assembly);
				AttributeMap[] array = AttributeMap.Create(this, assembly);
				for (int i = 0; i < array.Length; i++)
				{
					if ((object)array[i].AttributeType == type2)
					{
						array[i].TryGet("AssemblyName", out var value);
						string text = value as string;
						if (!(text == assemblyName) && !Helpers.IsNullOrEmpty(text) && basicList.IndexOfString(text) < 0)
						{
							basicList.Add(text);
							CustomAttributeBuilder customAttribute2 = new CustomAttributeBuilder(type2.GetConstructor(new Type[1] { MapType(typeof(string)) }), new object[1] { text });
							asm.SetCustomAttribute(customAttribute2);
						}
					}
				}
			}
		}

		private static MethodBuilder EmitBoxedSerializer(TypeBuilder type, int i, Type valueType, SerializerPair[] methodPairs, TypeModel model, CompilerContext.ILVersion ilVersion, string assemblyName)
		{
			MethodInfo deserialize = methodPairs[i].Deserialize;
			MethodBuilder methodBuilder = type.DefineMethod("_" + i, System.Reflection.MethodAttributes.Static, CallingConventions.Standard, model.MapType(typeof(object)), new Type[2]
			{
				model.MapType(typeof(object)),
				model.MapType(typeof(ProtoReader))
			});
			CompilerContext compilerContext = new CompilerContext(methodBuilder.GetILGenerator(), isStatic: true, isWriter: false, methodPairs, model, ilVersion, assemblyName, model.MapType(typeof(object)));
			compilerContext.LoadValue(compilerContext.InputValue);
			CodeLabel label = compilerContext.DefineLabel();
			compilerContext.BranchIfFalse(label, @short: true);
			compilerContext.LoadValue(compilerContext.InputValue);
			compilerContext.CastFromObject(valueType);
			compilerContext.LoadReaderWriter();
			compilerContext.EmitCall(deserialize);
			compilerContext.CastToObject(valueType);
			compilerContext.Return();
			compilerContext.MarkLabel(label);
			using Local local = new Local(compilerContext, valueType);
			compilerContext.LoadAddress(local, valueType);
			compilerContext.EmitCtor(valueType);
			compilerContext.LoadValue(local);
			compilerContext.LoadReaderWriter();
			compilerContext.EmitCall(deserialize);
			compilerContext.CastToObject(valueType);
			compilerContext.Return();
			return methodBuilder;
		}

		internal bool IsPrepared(Type type)
		{
			return FindWithoutAdd(type)?.IsPrepared() ?? false;
		}

		internal EnumSerializer.EnumPair[] GetEnumMap(Type type)
		{
			int num = FindOrAddAuto(type, demand: false, addWithContractOnly: false, addEvenIfAutoDisabled: false);
			if (num >= 0)
			{
				return ((MetaType)types[num]).GetEnumMap();
			}
			return null;
		}

		internal void TakeLock(ref int opaqueToken)
		{
			opaqueToken = 0;
			if (Monitor.TryEnter(types, metadataTimeoutMilliseconds))
			{
				opaqueToken = GetContention();
				return;
			}
			AddContention();
			throw new TimeoutException("Timeout while inspecting metadata; this may indicate a deadlock. This can often be avoided by preparing necessary serializers during application initialization, rather than allowing multiple threads to perform the initial metadata inspection; please also see the LockContended event");
		}

		private int GetContention()
		{
			lock (contentionLock)
			{
				return contentionCounter;
			}
		}

		private void AddContention()
		{
			lock (contentionLock)
			{
				contentionCounter++;
			}
		}

		internal void ReleaseLock(int opaqueToken)
		{
			if (opaqueToken == 0)
			{
				return;
			}
			Monitor.Exit(types);
			if (opaqueToken == GetContention())
			{
				return;
			}
			LockContentedEventHandler lockContended = this.LockContended;
			if (lockContended != null)
			{
				string stackTrace;
				try
				{
					throw new ProtoException();
				}
				catch (Exception ex)
				{
					stackTrace = ex.StackTrace;
				}
				lockContended(this, new LockContentedEventArgs(stackTrace));
			}
		}

		internal void ResolveListTypes(Type type, ref Type itemType, ref Type defaultType)
		{
			if ((object)type == null || Helpers.GetTypeCode(type) != ProtoTypeCode.Unknown || this[type].IgnoreListHandling)
			{
				return;
			}
			if (type.IsArray)
			{
				if (type.GetArrayRank() != 1)
				{
					throw new NotSupportedException("Multi-dimension arrays are supported");
				}
				itemType = type.GetElementType();
				if ((object)itemType == MapType(typeof(byte)))
				{
					defaultType = (itemType = null);
				}
				else
				{
					defaultType = type;
				}
			}
			if ((object)itemType == null)
			{
				itemType = TypeModel.GetListItemType(this, type);
			}
			if ((object)itemType != null)
			{
				Type itemType2 = null;
				Type defaultType2 = null;
				ResolveListTypes(itemType, ref itemType2, ref defaultType2);
				if ((object)itemType2 != null)
				{
					throw TypeModel.CreateNestedListsNotSupported();
				}
			}
			if ((object)itemType == null || (object)defaultType != null)
			{
				return;
			}
			if (type.IsClass && !type.IsAbstract && (object)Helpers.GetConstructor(type, Helpers.EmptyTypes, nonPublic: true) != null)
			{
				defaultType = type;
			}
			if ((object)defaultType == null && type.IsInterface)
			{
				Type[] genericArguments;
				if (type.IsGenericType && (object)type.GetGenericTypeDefinition() == MapType(typeof(IDictionary<, >)) && (object)itemType == MapType(typeof(KeyValuePair<, >)).MakeGenericType(genericArguments = type.GetGenericArguments()))
				{
					defaultType = MapType(typeof(Dictionary<, >)).MakeGenericType(genericArguments);
				}
				else
				{
					defaultType = MapType(typeof(List<>)).MakeGenericType(itemType);
				}
			}
			if ((object)defaultType != null && !Helpers.IsAssignableFrom(type, defaultType))
			{
				defaultType = null;
			}
		}

		internal string GetSchemaTypeName(Type effectiveType, DataFormat dataFormat, bool asReference, bool dynamicType, ref bool requiresBclImport)
		{
			Type underlyingType = Helpers.GetUnderlyingType(effectiveType);
			if ((object)underlyingType != null)
			{
				effectiveType = underlyingType;
			}
			if ((object)effectiveType == MapType(typeof(byte[])))
			{
				return "bytes";
			}
			WireType defaultWireType;
			IProtoSerializer protoSerializer = ValueMember.TryGetCoreSerializer(this, dataFormat, effectiveType, out defaultWireType, asReference: false, dynamicType: false, overwriteList: false, allowComplexTypes: false);
			if (protoSerializer == null)
			{
				if (asReference || dynamicType)
				{
					requiresBclImport = true;
					return "bcl.NetObjectProxy";
				}
				return this[effectiveType].GetSurrogateOrBaseOrSelf(deep: true).GetSchemaTypeName();
			}
			if (protoSerializer is ParseableSerializer)
			{
				if (asReference)
				{
					requiresBclImport = true;
				}
				if (!asReference)
				{
					return "string";
				}
				return "bcl.NetObjectProxy";
			}
			switch (Helpers.GetTypeCode(effectiveType))
			{
			case ProtoTypeCode.Boolean:
				return "bool";
			case ProtoTypeCode.Single:
				return "float";
			case ProtoTypeCode.Double:
				return "double";
			case ProtoTypeCode.String:
				if (asReference)
				{
					requiresBclImport = true;
				}
				if (!asReference)
				{
					return "string";
				}
				return "bcl.NetObjectProxy";
			case ProtoTypeCode.Char:
			case ProtoTypeCode.Byte:
			case ProtoTypeCode.UInt16:
			case ProtoTypeCode.UInt32:
				if (dataFormat == DataFormat.FixedSize)
				{
					return "fixed32";
				}
				return "uint32";
			case ProtoTypeCode.SByte:
			case ProtoTypeCode.Int16:
			case ProtoTypeCode.Int32:
				return dataFormat switch
				{
					DataFormat.ZigZag => "sint32", 
					DataFormat.FixedSize => "sfixed32", 
					_ => "int32", 
				};
			case ProtoTypeCode.UInt64:
				if (dataFormat == DataFormat.FixedSize)
				{
					return "fixed64";
				}
				return "uint64";
			case ProtoTypeCode.Int64:
				return dataFormat switch
				{
					DataFormat.ZigZag => "sint64", 
					DataFormat.FixedSize => "sfixed64", 
					_ => "int64", 
				};
			case ProtoTypeCode.DateTime:
				requiresBclImport = true;
				return "bcl.DateTime";
			case ProtoTypeCode.TimeSpan:
				requiresBclImport = true;
				return "bcl.TimeSpan";
			case ProtoTypeCode.Decimal:
				requiresBclImport = true;
				return "bcl.Decimal";
			case ProtoTypeCode.Guid:
				requiresBclImport = true;
				return "bcl.Guid";
			default:
				throw new NotSupportedException("No .proto map found for: " + effectiveType.FullName);
			}
		}

		public void SetDefaultFactory(MethodInfo methodInfo)
		{
			VerifyFactory(methodInfo, null);
			defaultFactory = methodInfo;
		}

		internal void VerifyFactory(MethodInfo factory, Type type)
		{
			if ((object)factory != null)
			{
				if ((object)type != null && Helpers.IsValueType(type))
				{
					throw new InvalidOperationException();
				}
				if (!factory.IsStatic)
				{
					throw new ArgumentException("A factory-method must be static", "factory");
				}
				if ((object)type != null && (object)factory.ReturnType != type && (object)factory.ReturnType != MapType(typeof(object)))
				{
					throw new ArgumentException("The factory-method must return object" + (((object)type == null) ? "" : (" or " + type.FullName)), "factory");
				}
				if (!CallbackSet.CheckCallbackParameters(this, factory))
				{
					throw new ArgumentException("Invalid factory signature in " + factory.DeclaringType.FullName + "." + factory.Name, "factory");
				}
			}
		}
	}
	public sealed class LockContentedEventArgs : EventArgs
	{
		private readonly string ownerStackTrace;

		public string OwnerStackTrace => ownerStackTrace;

		internal LockContentedEventArgs(string ownerStackTrace)
		{
			this.ownerStackTrace = ownerStackTrace;
		}
	}
	public delegate void LockContentedEventHandler(object sender, LockContentedEventArgs args);
	public sealed class SubType
	{
		internal sealed class Comparer : IComparer, IComparer<SubType>
		{
			public static readonly Comparer Default = new Comparer();

			public int Compare(object x, object y)
			{
				return Compare(x as SubType, y as SubType);
			}

			public int Compare(SubType x, SubType y)
			{
				if (object.ReferenceEquals(x, y))
				{
					return 0;
				}
				if (x == null)
				{
					return -1;
				}
				if (y == null)
				{
					return 1;
				}
				return x.FieldNumber.CompareTo(y.FieldNumber);
			}
		}

		private readonly int fieldNumber;

		private readonly MetaType derivedType;

		private readonly DataFormat dataFormat;

		private IProtoSerializer serializer;

		public int FieldNumber => fieldNumber;

		public MetaType DerivedType => derivedType;

		internal IProtoSerializer Serializer
		{
			get
			{
				if (serializer == null)
				{
					serializer = BuildSerializer();
				}
				return serializer;
			}
		}

		public SubType(int fieldNumber, MetaType derivedType, DataFormat format)
		{
			if (derivedType == null)
			{
				throw new ArgumentNullException("derivedType");
			}
			if (fieldNumber <= 0)
			{
				throw new ArgumentOutOfRangeException("fieldNumber");
			}
			this.fieldNumber = fieldNumber;
			this.derivedType = derivedType;
			dataFormat = format;
		}

		private IProtoSerializer BuildSerializer()
		{
			WireType wireType = WireType.String;
			if (dataFormat == DataFormat.Group)
			{
				wireType = WireType.StartGroup;
			}
			IProtoSerializer tail = new SubItemSerializer(derivedType.Type, derivedType.GetKey(demand: false, getBaseKey: false), derivedType, recursionCheck: false);
			return new TagDecorator(fieldNumber, wireType, strict: false, tail);
		}
	}
	public class TypeFormatEventArgs : EventArgs
	{
		private Type type;

		private string formattedName;

		private readonly bool typeFixed;

		public Type Type
		{
			get
			{
				return type;
			}
			set
			{
				if ((object)type != value)
				{
					if (typeFixed)
					{
						throw new InvalidOperationException("The type is fixed and cannot be changed");
					}
					type = value;
				}
			}
		}

		public string FormattedName
		{
			get
			{
				return formattedName;
			}
			set
			{
				if (formattedName != value)
				{
					if (!typeFixed)
					{
						throw new InvalidOperationException("The formatted-name is fixed and cannot be changed");
					}
					formattedName = value;
				}
			}
		}

		internal TypeFormatEventArgs(string formattedName)
		{
			if (Helpers.IsNullOrEmpty(formattedName))
			{
				throw new ArgumentNullException("formattedName");
			}
			this.formattedName = formattedName;
		}

		internal TypeFormatEventArgs(Type type)
		{
			if ((object)type == null)
			{
				throw new ArgumentNullException("type");
			}
			this.type = type;
			typeFixed = true;
		}
	}
	public delegate void TypeFormatEventHandler(object sender, TypeFormatEventArgs args);
	public class ValueMember
	{
		internal sealed class Comparer : IComparer, IComparer<ValueMember>
		{
			public static readonly Comparer Default = new Comparer();

			public int Compare(object x, object y)
			{
				return Compare(x as ValueMember, y as ValueMember);
			}

			public int Compare(ValueMember x, ValueMember y)
			{
				if (object.ReferenceEquals(x, y))
				{
					return 0;
				}
				if (x == null)
				{
					return -1;
				}
				if (y == null)
				{
					return 1;
				}
				return x.FieldNumber.CompareTo(y.FieldNumber);
			}
		}

		private const byte OPTIONS_IsStrict = 1;

		private const byte OPTIONS_IsPacked = 2;

		private const byte OPTIONS_IsRequired = 4;

		private const byte OPTIONS_OverwriteList = 8;

		private const byte OPTIONS_SupportNull = 16;

		private readonly int fieldNumber;

		private readonly MemberInfo member;

		private readonly Type parentType;

		private readonly Type itemType;

		private readonly Type defaultType;

		private readonly Type memberType;

		private object defaultValue;

		private readonly RuntimeTypeModel model;

		private IProtoSerializer serializer;

		private DataFormat dataFormat;

		private bool asReference;

		private bool dynamicType;

		private MethodInfo getSpecified;

		private MethodInfo setSpecified;

		private string name;

		private byte flags;

		public int FieldNumber => fieldNumber;

		public MemberInfo Member => member;

		public Type ItemType => itemType;

		public Type MemberType => memberType;

		public Type DefaultType => defaultType;

		public Type ParentType => parentType;

		public object DefaultValue
		{
			get
			{
				return defaultValue;
			}
			set
			{
				ThrowIfFrozen();
				defaultValue = value;
			}
		}

		internal IProtoSerializer Serializer
		{
			get
			{
				if (serializer == null)
				{
					serializer = BuildSerializer();
				}
				return serializer;
			}
		}

		public DataFormat DataFormat
		{
			get
			{
				return dataFormat;
			}
			set
			{
				ThrowIfFrozen();
				dataFormat = value;
			}
		}

		public bool IsStrict
		{
			get
			{
				return HasFlag(1);
			}
			set
			{
				SetFlag(1, value, throwIfFrozen: true);
			}
		}

		public bool IsPacked
		{
			get
			{
				return HasFlag(2);
			}
			set
			{
				SetFlag(2, value, throwIfFrozen: true);
			}
		}

		public bool OverwriteList
		{
			get
			{
				return HasFlag(8);
			}
			set
			{
				SetFlag(8, value, throwIfFrozen: true);
			}
		}

		public bool IsRequired
		{
			get
			{
				return HasFlag(4);
			}
			set
			{
				SetFlag(4, value, throwIfFrozen: true);
			}
		}

		public bool AsReference
		{
			get
			{
				return asReference;
			}
			set
			{
				ThrowIfFrozen();
				asReference = value;
			}
		}

		public bool DynamicType
		{
			get
			{
				return dynamicType;
			}
			set
			{
				ThrowIfFrozen();
				dynamicType = value;
			}
		}

		public string Name
		{
			get
			{
				if (!Helpers.IsNullOrEmpty(name))
				{
					return name;
				}
				return member.Name;
			}
		}

		public bool SupportNull
		{
			get
			{
				return HasFlag(16);
			}
			set
			{
				SetFlag(16, value, throwIfFrozen: true);
			}
		}

		public ValueMember(RuntimeTypeModel model, Type parentType, int fieldNumber, MemberInfo member, Type memberType, Type itemType, Type defaultType, DataFormat dataFormat, object defaultValue)
			: this(model, fieldNumber, memberType, itemType, defaultType, dataFormat)
		{
			if ((object)member == null)
			{
				throw new ArgumentNullException("member");
			}
			if ((object)parentType == null)
			{
				throw new ArgumentNullException("parentType");
			}
			if (fieldNumber < 1 && !Helpers.IsEnum(parentType))
			{
				throw new ArgumentOutOfRangeException("fieldNumber");
			}
			this.member = member;
			this.parentType = parentType;
			if (fieldNumber < 1 && !Helpers.IsEnum(parentType))
			{
				throw new ArgumentOutOfRangeException("fieldNumber");
			}
			if (defaultValue != null && (object)model.MapType(defaultValue.GetType()) != memberType)
			{
				defaultValue = ParseDefaultValue(memberType, defaultValue);
			}
			this.defaultValue = defaultValue;
			MetaType metaType = model.FindWithoutAdd(memberType);
			if (metaType != null)
			{
				asReference = metaType.AsReferenceDefault;
			}
			else
			{
				asReference = MetaType.GetAsReferenceDefault(model, memberType);
			}
		}

		internal ValueMember(RuntimeTypeModel model, int fieldNumber, Type memberType, Type itemType, Type defaultType, DataFormat dataFormat)
		{
			if ((object)memberType == null)
			{
				throw new ArgumentNullException("memberType");
			}
			if (model == null)
			{
				throw new ArgumentNullException("model");
			}
			this.fieldNumber = fieldNumber;
			this.memberType = memberType;
			this.itemType = itemType;
			this.defaultType = defaultType;
			this.model = model;
			this.dataFormat = dataFormat;
		}

		internal object GetRawEnumValue()
		{
			return ((FieldInfo)member).GetRawConstantValue();
		}

		private static object ParseDefaultValue(Type type, object value)
		{
			Type underlyingType = Helpers.GetUnderlyingType(type);
			if ((object)underlyingType != null)
			{
				type = underlyingType;
			}
			if (value is string)
			{
				string text = (string)value;
				if (Helpers.IsEnum(type))
				{
					return Helpers.ParseEnum(type, text);
				}
				switch (Helpers.GetTypeCode(type))
				{
				case ProtoTypeCode.Boolean:
					return bool.Parse(text);
				case ProtoTypeCode.Byte:
					return byte.Parse(text, NumberStyles.Integer, CultureInfo.InvariantCulture);
				case ProtoTypeCode.Char:
					if (text.Length == 1)
					{
						return text[0];
					}
					throw new FormatException("Single character expected: \"" + text + "\"");
				case ProtoTypeCode.DateTime:
					return DateTime.Parse(text, CultureInfo.InvariantCulture);
				case ProtoTypeCode.Decimal:
					return decimal.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
				case ProtoTypeCode.Double:
					return double.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
				case ProtoTypeCode.Int16:
					return short.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
				case ProtoTypeCode.Int32:
					return int.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
				case ProtoTypeCode.Int64:
					return long.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
				case ProtoTypeCode.SByte:
					return sbyte.Parse(text, NumberStyles.Integer, CultureInfo.InvariantCulture);
				case ProtoTypeCode.Single:
					return float.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
				case ProtoTypeCode.String:
					return text;
				case ProtoTypeCode.UInt16:
					return ushort.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
				case ProtoTypeCode.UInt32:
					return uint.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
				case ProtoTypeCode.UInt64:
					return ulong.Parse(text, NumberStyles.Any, CultureInfo.InvariantCulture);
				case ProtoTypeCode.TimeSpan:
					return TimeSpan.Parse(text);
				case ProtoTypeCode.Uri:
					return text;
				case ProtoTypeCode.Guid:
					return new Guid(text);
				}
			}
			if (Helpers.IsEnum(type))
			{
				return Enum.ToObject(type, value);
			}
			return Convert.ChangeType(value, type, CultureInfo.InvariantCulture);
		}

		public void SetSpecified(MethodInfo getSpecified, MethodInfo setSpecified)
		{
			if ((object)getSpecified != null && ((object)getSpecified.ReturnType != model.MapType(typeof(bool)) || getSpecified.IsStatic || getSpecified.GetParameters().Length != 0))
			{
				throw new ArgumentException("Invalid pattern for checking member-specified", "getSpecified");
			}
			ParameterInfo[] parameters;
			if ((object)setSpecified != null && ((object)setSpecified.ReturnType != model.MapType(typeof(void)) || setSpecified.IsStatic || (parameters = setSpecified.GetParameters()).Length != 1 || (object)parameters[0].ParameterType != model.MapType(typeof(bool))))
			{
				throw new ArgumentException("Invalid pattern for setting member-specified", "setSpecified");
			}
			ThrowIfFrozen();
			this.getSpecified = getSpecified;
			this.setSpecified = setSpecified;
		}

		private void ThrowIfFrozen()
		{
			if (serializer != null)
			{
				throw new InvalidOperationException("The type cannot be changed once a serializer has been generated");
			}
		}

		private IProtoSerializer BuildSerializer()
		{
			int opaqueToken = 0;
			try
			{
				model.TakeLock(ref opaqueToken);
				Type type = (((object)itemType == null) ? memberType : itemType);
				IProtoSerializer protoSerializer = TryGetCoreSerializer(model, dataFormat, type, out var defaultWireType, asReference, dynamicType, OverwriteList, allowComplexTypes: true);
				if (protoSerializer == null)
				{
					throw new InvalidOperationException("No serializer defined for type: " + type.FullName);
				}
				if ((object)itemType != null && SupportNull)
				{
					if (IsPacked)
					{
						throw new NotSupportedException("Packed encodings cannot support null values");
					}
					protoSerializer = new TagDecorator(1, defaultWireType, IsStrict, protoSerializer);
					protoSerializer = new NullDecorator(model, protoSerializer);
					protoSerializer = new TagDecorator(fieldNumber, WireType.StartGroup, strict: false, protoSerializer);
				}
				else
				{
					protoSerializer = new TagDecorator(fieldNumber, defaultWireType, IsStrict, protoSerializer);
				}
				if ((object)itemType != null)
				{
					if (!SupportNull)
					{
						Helpers.GetUnderlyingType(itemType);
					}
					protoSerializer = ((!memberType.IsArray) ? ((ProtoDecoratorBase)ListDecorator.Create(model, memberType, defaultType, protoSerializer, fieldNumber, IsPacked, defaultWireType, (object)member != null && PropertyDecorator.CanWrite(model, member), OverwriteList, SupportNull)) : ((ProtoDecoratorBase)new ArrayDecorator(model, protoSerializer, fieldNumber, IsPacked, defaultWireType, memberType, OverwriteList, SupportNull)));
				}
				else if (defaultValue != null && !IsRequired && (object)getSpecified == null)
				{
					protoSerializer = new DefaultValueDecorator(model, defaultValue, protoSerializer);
				}
				if ((object)memberType == model.MapType(typeof(Uri)))
				{
					protoSerializer = new UriDecorator(model, protoSerializer);
				}
				if ((object)member != null)
				{
					if (member is PropertyInfo)
					{
						protoSerializer = new PropertyDecorator(model, parentType, (PropertyInfo)member, protoSerializer);
					}
					else
					{
						if (!(member is FieldInfo))
						{
							throw new InvalidOperationException();
						}
						protoSerializer = new FieldDecorator(parentType, (FieldInfo)member, protoSerializer);
					}
					if ((object)getSpecified != null || (object)setSpecified != null)
					{
						protoSerializer = new MemberSpecifiedDecorator(getSpecified, setSpecified, protoSerializer);
					}
				}
				return protoSerializer;
			}
			finally
			{
				model.ReleaseLock(opaqueToken);
			}
		}

		private static WireType GetIntWireType(DataFormat format, int width)
		{
			switch (format)
			{
			case DataFormat.ZigZag:
				return WireType.SignedVariant;
			case DataFormat.FixedSize:
				if (width != 32)
				{
					return WireType.Fixed64;
				}
				return WireType.Fixed32;
			case DataFormat.Default:
			case DataFormat.TwosComplement:
				return WireType.Variant;
			default:
				throw new InvalidOperationException();
			}
		}

		private static WireType GetDateTimeWireType(DataFormat format)
		{
			return format switch
			{
				DataFormat.Group => WireType.StartGroup, 
				DataFormat.FixedSize => WireType.Fixed64, 
				DataFormat.Default => WireType.String, 
				_ => throw new InvalidOperationException(), 
			};
		}

		internal static IProtoSerializer TryGetCoreSerializer(RuntimeTypeModel model, DataFormat dataFormat, Type type, out WireType defaultWireType, bool asReference, bool dynamicType, bool overwriteList, bool allowComplexTypes)
		{
			Type underlyingType = Helpers.GetUnderlyingType(type);
			if ((object)underlyingType != null)
			{
				type = underlyingType;
			}
			if (Helpers.IsEnum(type))
			{
				if (allowComplexTypes && model != null)
				{
					defaultWireType = WireType.Variant;
					return new EnumSerializer(type, model.GetEnumMap(type));
				}
				defaultWireType = WireType.None;
				return null;
			}
			switch (Helpers.GetTypeCode(type))
			{
			case ProtoTypeCode.Int32:
				defaultWireType = GetIntWireType(dataFormat, 32);
				return new Int32Serializer(model);
			case ProtoTypeCode.UInt32:
				defaultWireType = GetIntWireType(dataFormat, 32);
				return new UInt32Serializer(model);
			case ProtoTypeCode.Int64:
				defaultWireType = GetIntWireType(dataFormat, 64);
				return new Int64Serializer(model);
			case ProtoTypeCode.UInt64:
				defaultWireType = GetIntWireType(dataFormat, 64);
				return new UInt64Serializer(model);
			case ProtoTypeCode.String:
				defaultWireType = WireType.String;
				if (asReference)
				{
					return new NetObjectSerializer(model, model.MapType(typeof(string)), 0, BclHelpers.NetObjectOptions.AsReference);
				}
				return new StringSerializer(model);
			case ProtoTypeCode.Single:
				defaultWireType = WireType.Fixed32;
				return new SingleSerializer(model);
			case ProtoTypeCode.Double:
				defaultWireType = WireType.Fixed64;
				return new DoubleSerializer(model);
			case ProtoTypeCode.Boolean:
				defaultWireType = WireType.Variant;
				return new BooleanSerializer(model);
			case ProtoTypeCode.DateTime:
				defaultWireType = GetDateTimeWireType(dataFormat);
				return new DateTimeSerializer(model);
			case ProtoTypeCode.Decimal:
				defaultWireType = WireType.String;
				return new DecimalSerializer(model);
			case ProtoTypeCode.Byte:
				defaultWireType = GetIntWireType(dataFormat, 32);
				return new ByteSerializer(model);
			case ProtoTypeCode.SByte:
				defaultWireType = GetIntWireType(dataFormat, 32);
				return new SByteSerializer(model);
			case ProtoTypeCode.Char:
				defaultWireType = WireType.Variant;
				return new CharSerializer(model);
			case ProtoTypeCode.Int16:
				defaultWireType = GetIntWireType(dataFormat, 32);
				return new Int16Serializer(model);
			case ProtoTypeCode.UInt16:
				defaultWireType = GetIntWireType(dataFormat, 32);
				return new UInt16Serializer(model);
			case ProtoTypeCode.TimeSpan:
				defaultWireType = GetDateTimeWireType(dataFormat);
				return new TimeSpanSerializer(model);
			case ProtoTypeCode.Guid:
				defaultWireType = WireType.String;
				return new GuidSerializer(model);
			case ProtoTypeCode.Uri:
				defaultWireType = WireType.String;
				return new StringSerializer(model);
			case ProtoTypeCode.ByteArray:
				defaultWireType = WireType.String;
				return new BlobSerializer(model, overwriteList);
			case ProtoTypeCode.Type:
				defaultWireType = WireType.String;
				return new SystemTypeSerializer(model);
			default:
			{
				IProtoSerializer protoSerializer = (model.AllowParseableTypes ? ParseableSerializer.TryCreate(type, model) : null);
				if (protoSerializer != null)
				{
					defaultWireType = WireType.String;
					return protoSerializer;
				}
				if (allowComplexTypes && model != null)
				{
					int key = model.GetKey(type, demand: false, getBaseKey: true);
					if (asReference || dynamicType)
					{
						defaultWireType = ((dataFormat == DataFormat.Group) ? WireType.StartGroup : WireType.String);
						BclHelpers.NetObjectOptions netObjectOptions = BclHelpers.NetObjectOptions.None;
						if (asReference)
						{
							netObjectOptions |= BclHelpers.NetObjectOptions.AsReference;
						}
						if (dynamicType)
						{
							netObjectOptions |= BclHelpers.NetObjectOptions.DynamicType;
						}
						if (key >= 0)
						{
							if (asReference && Helpers.IsValueType(type))
							{
								string text = "AsReference cannot be used with value-types";
								text = ((!(type.Name == "KeyValuePair`2")) ? (text + ": " + type.FullName) : (text + "; please see http://stackoverflow.com/q/14436606/"));
								throw new InvalidOperationException(text);
							}
							MetaType metaType = model[type];
							if (asReference && metaType.IsAutoTuple)
							{
								netObjectOptions |= BclHelpers.NetObjectOptions.LateSet;
							}
							if (metaType.UseConstructor)
							{
								netObjectOptions |= BclHelpers.NetObjectOptions.UseConstructor;
							}
						}
						return new NetObjectSerializer(model, type, key, netObjectOptions);
					}
					if (key >= 0)
					{
						defaultWireType = ((dataFormat == DataFormat.Group) ? WireType.StartGroup : WireType.String);
						return new SubItemSerializer(type, key, model[type], recursionCheck: true);
					}
				}
				defaultWireType = WireType.None;
				return null;
			}
			}
		}

		internal void SetName(string name)
		{
			ThrowIfFrozen();
			this.name = name;
		}

		private bool HasFlag(byte flag)
		{
			return (flags & flag) == flag;
		}

		private void SetFlag(byte flag, bool value, bool throwIfFrozen)
		{
			if (throwIfFrozen && HasFlag(flag) != value)
			{
				ThrowIfFrozen();
			}
			if (value)
			{
				flags |= flag;
			}
			else
			{
				flags = (byte)(flags & ~flag);
			}
		}

		internal string GetSchemaTypeName(bool applyNetObjectProxy, ref bool requiresBclImport)
		{
			Type type = ItemType;
			if ((object)type == null)
			{
				type = MemberType;
			}
			return model.GetSchemaTypeName(type, DataFormat, applyNetObjectProxy && asReference, applyNetObjectProxy && dynamicType, ref requiresBclImport);
		}
	}
}
namespace ProtoBuf
{
	internal sealed class NetObjectCache
	{
		private sealed class ReferenceComparer : IEqualityComparer<object>
		{
			public static readonly ReferenceComparer Default = new ReferenceComparer();

			private ReferenceComparer()
			{
			}

			bool IEqualityComparer<object>.Equals(object x, object y)
			{
				return x == y;
			}

			int IEqualityComparer<object>.GetHashCode(object obj)
			{
				return RuntimeHelpers.GetHashCode(obj);
			}
		}

		internal const int Root = 0;

		private MutableList underlyingList;

		private object rootObject;

		private int trapStartIndex;

		private Dictionary<string, int> stringKeys;

		private Dictionary<object, int> objectKeys;

		private MutableList List
		{
			get
			{
				if (underlyingList == null)
				{
					underlyingList = new MutableList();
				}
				return underlyingList;
			}
		}

		internal object GetKeyedObject(int key)
		{
			if (key-- == 0)
			{
				if (rootObject == null)
				{
					throw new ProtoException("No root object assigned");
				}
				return rootObject;
			}
			BasicList list = List;
			if (key < 0 || key >= list.Count)
			{
				throw new ProtoException("Internal error; a missing key occurred");
			}
			object obj = list[key];
			if (obj == null)
			{
				throw new ProtoException("A deferred key does not have a value yet");
			}
			return obj;
		}

		internal void SetKeyedObject(int key, object value)
		{
			if (key-- == 0)
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				if (rootObject != null && rootObject != value)
				{
					throw new ProtoException("The root object cannot be reassigned");
				}
				rootObject = value;
				return;
			}
			MutableList list = List;
			if (key < list.Count)
			{
				object obj = list[key];
				if (obj == null)
				{
					list[key] = value;
				}
				else if (!object.ReferenceEquals(obj, value))
				{
					throw new ProtoException("Reference-tracked objects cannot change reference");
				}
			}
			else if (key != list.Add(value))
			{
				throw new ProtoException("Internal error; a key mismatch occurred");
			}
		}

		internal int AddObjectKey(object value, out bool existing)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (value == rootObject)
			{
				existing = true;
				return 0;
			}
			string text = value as string;
			BasicList list = List;
			int value2;
			if (text == null)
			{
				if (objectKeys == null)
				{
					objectKeys = new Dictionary<object, int>(ReferenceComparer.Default);
					value2 = -1;
				}
				else if (!objectKeys.TryGetValue(value, out value2))
				{
					value2 = -1;
				}
			}
			else if (stringKeys == null)
			{
				stringKeys = new Dictionary<string, int>();
				value2 = -1;
			}
			else if (!stringKeys.TryGetValue(text, out value2))
			{
				value2 = -1;
			}
			if (!(existing = value2 >= 0))
			{
				value2 = list.Add(value);
				if (text == null)
				{
					objectKeys.Add(value, value2);
				}
				else
				{
					stringKeys.Add(text, value2);
				}
			}
			return value2 + 1;
		}

		internal void RegisterTrappedObject(object value)
		{
			if (rootObject == null)
			{
				rootObject = value;
			}
			else
			{
				if (underlyingList == null)
				{
					return;
				}
				for (int i = trapStartIndex; i < underlyingList.Count; i++)
				{
					trapStartIndex = i + 1;
					if (underlyingList[i] == null)
					{
						underlyingList[i] = value;
						break;
					}
				}
			}
		}

		internal void Clear()
		{
			trapStartIndex = 0;
			rootObject = null;
			if (underlyingList != null)
			{
				underlyingList.Clear();
			}
			if (stringKeys != null)
			{
				stringKeys.Clear();
			}
			if (objectKeys != null)
			{
				objectKeys.Clear();
			}
		}
	}
	public enum PrefixStyle
	{
		None,
		Base128,
		Fixed32,
		Fixed32BigEndian
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]
	public sealed class ProtoContractAttribute : Attribute
	{
		private const byte OPTIONS_InferTagFromName = 1;

		private const byte OPTIONS_InferTagFromNameHasValue = 2;

		private const byte OPTIONS_UseProtoMembersOnly = 4;

		private const byte OPTIONS_SkipConstructor = 8;

		private const byte OPTIONS_IgnoreListHandling = 16;

		private const byte OPTIONS_AsReferenceDefault = 32;

		private const byte OPTIONS_EnumPassthru = 64;

		private const byte OPTIONS_EnumPassthruHasValue = 128;

		private string name;

		private int implicitFirstTag;

		private ImplicitFields implicitFields;

		private int dataMemberOffset;

		private byte flags;

		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public int ImplicitFirstTag
		{
			get
			{
				return implicitFirstTag;
			}
			set
			{
				if (value < 1)
				{
					throw new ArgumentOutOfRangeException("ImplicitFirstTag");
				}
				implicitFirstTag = value;
			}
		}

		public bool UseProtoMembersOnly
		{
			get
			{
				return HasFlag(4);
			}
			set
			{
				SetFlag(4, value);
			}
		}

		public bool IgnoreListHandling
		{
			get
			{
				return HasFlag(16);
			}
			set
			{
				SetFlag(16, value);
			}
		}

		public ImplicitFields ImplicitFields
		{
			get
			{
				return implicitFields;
			}
			set
			{
				implicitFields = value;
			}
		}

		public bool InferTagFromName
		{
			get
			{
				return HasFlag(1);
			}
			set
			{
				SetFlag(1, value);
				SetFlag(2, value: true);
			}
		}

		internal bool InferTagFromNameHasValue => HasFlag(2);

		public int DataMemberOffset
		{
			get
			{
				return dataMemberOffset;
			}
			set
			{
				dataMemberOffset = value;
			}
		}

		public bool SkipConstructor
		{
			get
			{
				return HasFlag(8);
			}
			set
			{
				SetFlag(8, value);
			}
		}

		public bool AsReferenceDefault
		{
			get
			{
				return HasFlag(32);
			}
			set
			{
				SetFlag(32, value);
			}
		}

		public bool EnumPassthru
		{
			get
			{
				return HasFlag(64);
			}
			set
			{
				SetFlag(64, value);
				SetFlag(128, value: true);
			}
		}

		internal bool EnumPassthruHasValue => HasFlag(128);

		private bool HasFlag(byte flag)
		{
			return (flags & flag) == flag;
		}

		private void SetFlag(byte flag, bool value)
		{
			if (value)
			{
				flags |= flag;
			}
			else
			{
				flags = (byte)(flags & ~flag);
			}
		}
	}
	[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
	public sealed class ProtoEnumAttribute : Attribute
	{
		private bool hasValue;

		private int enumValue;

		private string name;

		public int Value
		{
			get
			{
				return enumValue;
			}
			set
			{
				enumValue = value;
				hasValue = true;
			}
		}

		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public bool HasValue()
		{
			return hasValue;
		}
	}
	[Serializable]
	public class ProtoException : Exception
	{
		public ProtoException()
		{
		}

		public ProtoException(string message)
			: base(message)
		{
		}

		public ProtoException(string message, Exception innerException)
			: base(message, innerException)
		{
		}

		protected ProtoException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ProtoIgnoreAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
	public sealed class ProtoPartialIgnoreAttribute : ProtoIgnoreAttribute
	{
		private readonly string memberName;

		public string MemberName => memberName;

		public ProtoPartialIgnoreAttribute(string memberName)
		{
			if (Helpers.IsNullOrEmpty(memberName))
			{
				throw new ArgumentNullException("memberName");
			}
			this.memberName = memberName;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = true, Inherited = false)]
	public sealed class ProtoIncludeAttribute : Attribute
	{
		private readonly int tag;

		private readonly string knownTypeName;

		private DataFormat dataFormat;

		public int Tag => tag;

		public string KnownTypeName => knownTypeName;

		public Type KnownType => TypeModel.ResolveKnownType(KnownTypeName, null, null);

		[DefaultValue(DataFormat.Default)]
		public DataFormat DataFormat
		{
			get
			{
				return dataFormat;
			}
			set
			{
				dataFormat = value;
			}
		}

		public ProtoIncludeAttribute(int tag, Type knownType)
			: this(tag, ((object)knownType == null) ? "" : knownType.AssemblyQualifiedName)
		{
		}

		public ProtoIncludeAttribute(int tag, string knownTypeName)
		{
			if (tag <= 0)
			{
				throw new ArgumentOutOfRangeException("tag", "Tags must be positive integers");
			}
			if (Helpers.IsNullOrEmpty(knownTypeName))
			{
				throw new ArgumentNullException("knownTypeName", "Known type cannot be blank");
			}
			this.tag = tag;
			this.knownTypeName = knownTypeName;
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false, Inherited = true)]
	public class ProtoMemberAttribute : Attribute, IComparable, IComparable<ProtoMemberAttribute>
	{
		internal MemberInfo Member;

		internal bool TagIsPinned;

		private string name;

		private DataFormat dataFormat;

		private int tag;

		private MemberSerializationOptions options;

		public string Name
		{
			get
			{
				return name;
			}
			set
			{
				name = value;
			}
		}

		public DataFormat DataFormat
		{
			get
			{
				return dataFormat;
			}
			set
			{
				dataFormat = value;
			}
		}

		public int Tag => tag;

		public bool IsRequired
		{
			get
			{
				return (options & MemberSerializationOptions.Required) == MemberSerializationOptions.Required;
			}
			set
			{
				if (value)
				{
					options |= MemberSerializationOptions.Required;
				}
				else
				{
					options &= ~MemberSerializationOptions.Required;
				}
			}
		}

		public bool IsPacked
		{
			get
			{
				return (options & MemberSerializationOptions.Packed) == MemberSerializationOptions.Packed;
			}
			set
			{
				if (value)
				{
					options |= MemberSerializationOptions.Packed;
				}
				else
				{
					options &= ~MemberSerializationOptions.Packed;
				}
			}
		}

		public bool OverwriteList
		{
			get
			{
				return (options & MemberSerializationOptions.OverwriteList) == MemberSerializationOptions.OverwriteList;
			}
			set
			{
				if (value)
				{
					options |= MemberSerializationOptions.OverwriteList;
				}
				else
				{
					options &= ~MemberSerializationOptions.OverwriteList;
				}
			}
		}

		public bool AsReference
		{
			get
			{
				return (options & MemberSerializationOptions.AsReference) == MemberSerializationOptions.AsReference;
			}
			set
			{
				if (value)
				{
					options |= MemberSerializationOptions.AsReference;
				}
				else
				{
					options &= ~MemberSerializationOptions.AsReference;
				}
				options |= MemberSerializationOptions.AsReferenceHasValue;
			}
		}

		internal bool AsReferenceHasValue
		{
			get
			{
				return (options & MemberSerializationOptions.AsReferenceHasValue) == MemberSerializationOptions.AsReferenceHasValue;
			}
			set
			{
				if (value)
				{
					options |= MemberSerializationOptions.AsReferenceHasValue;
				}
				else
				{
					options &= ~MemberSerializationOptions.AsReferenceHasValue;
				}
			}
		}

		public bool DynamicType
		{
			get
			{
				return (options & MemberSerializationOptions.DynamicType) == MemberSerializationOptions.DynamicType;
			}
			set
			{
				if (value)
				{
					options |= MemberSerializationOptions.DynamicType;
				}
				else
				{
					options &= ~MemberSerializationOptions.DynamicType;
				}
			}
		}

		public MemberSerializationOptions Options
		{
			get
			{
				return options;
			}
			set
			{
				options = value;
			}
		}

		public int CompareTo(object other)
		{
			return CompareTo(other as ProtoMemberAttribute);
		}

		public int CompareTo(ProtoMemberAttribute other)
		{
			if (other == null)
			{
				return -1;
			}
			if (this == other)
			{
				return 0;
			}
			int num = tag.CompareTo(other.tag);
			if (num == 0)
			{
				num = string.CompareOrdinal(name, other.name);
			}
			return num;
		}

		public ProtoMemberAttribute(int tag)
			: this(tag, forced: false)
		{
		}

		internal ProtoMemberAttribute(int tag, bool forced)
		{
			if (tag <= 0 && !forced)
			{
				throw new ArgumentOutOfRangeException("tag");
			}
			this.tag = tag;
		}

		internal void Rebase(int tag)
		{
			this.tag = tag;
		}
	}
	[Flags]
	public enum MemberSerializationOptions
	{
		None = 0,
		Packed = 1,
		Required = 2,
		AsReference = 4,
		DynamicType = 8,
		OverwriteList = 0x10,
		AsReferenceHasValue = 0x20
	}
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
	public sealed class ProtoPartialMemberAttribute : ProtoMemberAttribute
	{
		private readonly string memberName;

		public string MemberName => memberName;

		public ProtoPartialMemberAttribute(int tag, string memberName)
			: base(tag)
		{
			if (Helpers.IsNullOrEmpty(memberName))
			{
				throw new ArgumentNullException("memberName");
			}
			this.memberName = memberName;
		}
	}
	public sealed class ProtoReader : IDisposable
	{
		internal const int TO_EOF = -1;

		private const long Int64Msb = long.MinValue;

		private const int Int32Msb = int.MinValue;

		private Stream source;

		private byte[] ioBuffer;

		private TypeModel model;

		private int fieldNumber;

		private int depth;

		private int dataRemaining;

		private int ioIndex;

		private int position;

		private int available;

		private int blockEnd;

		private WireType wireType;

		private bool isFixedLength;

		private bool internStrings;

		private NetObjectCache netCache;

		private uint trapCount;

		private SerializationContext context;

		private Dictionary<string, string> stringInterner;

		private static readonly UTF8Encoding encoding = new UTF8Encoding();

		private static readonly byte[] EmptyBlob = new byte[0];

		[ThreadStatic]
		private static ProtoReader lastReader;

		public int FieldNumber => fieldNumber;

		public WireType WireType => wireType;

		public bool InternStrings
		{
			get
			{
				return internStrings;
			}
			set
			{
				internStrings = value;
			}
		}

		public SerializationContext Context => context;

		public int Position => position;

		public TypeModel Model => model;

		internal NetObjectCache NetCache => netCache;

		public ProtoReader(Stream source, TypeModel model, SerializationContext context)
		{
			Init(this, source, model, context, -1);
		}

		public ProtoReader(Stream source, TypeModel model, SerializationContext context, int length)
		{
			Init(this, source, model, context, length);
		}

		private static void Init(ProtoReader reader, Stream source, TypeModel model, SerializationContext context, int length)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (!source.CanRead)
			{
				throw new ArgumentException("Cannot read from stream", "source");
			}
			reader.source = source;
			reader.ioBuffer = BufferPool.GetBuffer();
			reader.model = model;
			reader.dataRemaining = ((reader.isFixedLength = length >= 0) ? length : 0);
			if (context == null)
			{
				context = SerializationContext.Default;
			}
			else
			{
				context.Freeze();
			}
			reader.context = context;
			reader.position = (reader.available = (reader.depth = (reader.fieldNumber = (reader.ioIndex = 0))));
			reader.blockEnd = int.MaxValue;
			reader.internStrings = true;
			reader.wireType = WireType.None;
			reader.trapCount = 1u;
			if (reader.netCache == null)
			{
				reader.netCache = new NetObjectCache();
			}
		}

		public void Dispose()
		{
			source = null;
			model = null;
			BufferPool.ReleaseBufferToPool(ref ioBuffer);
			if (stringInterner != null)
			{
				stringInterner.Clear();
			}
			if (netCache != null)
			{
				netCache.Clear();
			}
		}

		internal int TryReadUInt32VariantWithoutMoving(bool trimNegative, out uint value)
		{
			if (available < 10)
			{
				Ensure(10, strict: false);
			}
			if (available == 0)
			{
				value = 0u;
				return 0;
			}
			int num = ioIndex;
			value = ioBuffer[num++];
			if ((value & 0x80) == 0)
			{
				return 1;
			}
			value &= 127u;
			if (available == 1)
			{
				throw EoF(this);
			}
			uint num2 = ioBuffer[num++];
			value |= (num2 & 0x7F) << 7;
			if ((num2 & 0x80) == 0)
			{
				return 2;
			}
			if (available == 2)
			{
				throw EoF(this);
			}
			num2 = ioBuffer[num++];
			value |= (num2 & 0x7F) << 14;
			if ((num2 & 0x80) == 0)
			{
				return 3;
			}
			if (available == 3)
			{
				throw EoF(this);
			}
			num2 = ioBuffer[num++];
			value |= (num2 & 0x7F) << 21;
			if ((num2 & 0x80) == 0)
			{
				return 4;
			}
			if (available == 4)
			{
				throw EoF(this);
			}
			num2 = ioBuffer[num];
			value |= num2 << 28;
			if ((num2 & 0xF0) == 0)
			{
				return 5;
			}
			if (trimNegative && (num2 & 0xF0) == 240 && available >= 10 && ioBuffer[++num] == byte.MaxValue && ioBuffer[++num] == byte.MaxValue && ioBuffer[++num] == byte.MaxValue && ioBuffer[++num] == byte.MaxValue && ioBuffer[++num] == 1)
			{
				return 10;
			}
			throw AddErrorData(new OverflowException(), this);
		}

		private uint ReadUInt32Variant(bool trimNegative)
		{
			uint value;
			int num = TryReadUInt32VariantWithoutMoving(trimNegative, out value);
			if (num > 0)
			{
				ioIndex += num;
				available -= num;
				position += num;
				return value;
			}
			throw EoF(this);
		}

		private bool TryReadUInt32Variant(out uint value)
		{
			int num = TryReadUInt32VariantWithoutMoving(trimNegative: false, out value);
			if (num > 0)
			{
				ioIndex += num;
				available -= num;
				position += num;
				return true;
			}
			return false;
		}

		public uint ReadUInt32()
		{
			switch (wireType)
			{
			case WireType.Variant:
				return ReadUInt32Variant(trimNegative: false);
			case WireType.Fixed32:
				if (available < 4)
				{
					Ensure(4, strict: true);
				}
				position += 4;
				available -= 4;
				return (uint)(ioBuffer[ioIndex++] | (ioBuffer[ioIndex++] << 8) | (ioBuffer[ioIndex++] << 16) | (ioBuffer[ioIndex++] << 24));
			case WireType.Fixed64:
			{
				ulong num = ReadUInt64();
				return checked((uint)num);
			}
			default:
				throw CreateWireTypeException();
			}
		}

		internal void Ensure(int count, bool strict)
		{
			if (count > ioBuffer.Length)
			{
				BufferPool.ResizeAndFlushLeft(ref ioBuffer, count, ioIndex, available);
				ioIndex = 0;
			}
			else if (ioIndex + count >= ioBuffer.Length)
			{
				Helpers.BlockCopy(ioBuffer, ioIndex, ioBuffer, 0, available);
				ioIndex = 0;
			}
			count -= available;
			int num = ioIndex + available;
			int num2 = ioBuffer.Length - num;
			if (isFixedLength && dataRemaining < num2)
			{
				num2 = dataRemaining;
			}
			int num3;
			while (count > 0 && num2 > 0 && (num3 = source.Read(ioBuffer, num, num2)) > 0)
			{
				available += num3;
				count -= num3;
				num2 -= num3;
				num += num3;
				if (isFixedLength)
				{
					dataRemaining -= num3;
				}
			}
			if (strict && count > 0)
			{
				throw EoF(this);
			}
		}

		public short ReadInt16()
		{
			return checked((short)ReadInt32());
		}

		public ushort ReadUInt16()
		{
			return checked((ushort)ReadUInt32());
		}

		public byte ReadByte()
		{
			return checked((byte)ReadUInt32());
		}

		public sbyte ReadSByte()
		{
			return checked((sbyte)ReadInt32());
		}

		public int ReadInt32()
		{
			switch (wireType)
			{
			case WireType.Variant:
				return (int)ReadUInt32Variant(trimNegative: true);
			case WireType.Fixed32:
				if (available < 4)
				{
					Ensure(4, strict: true);
				}
				position += 4;
				available -= 4;
				return ioBuffer[ioIndex++] | (ioBuffer[ioIndex++] << 8) | (ioBuffer[ioIndex++] << 16) | (ioBuffer[ioIndex++] << 24);
			case WireType.Fixed64:
			{
				long num = ReadInt64();
				return checked((int)num);
			}
			case WireType.SignedVariant:
				return Zag(ReadUInt32Variant(trimNegative: true));
			default:
				throw CreateWireTypeException();
			}
		}

		private static int Zag(uint ziggedValue)
		{
			return (int)(0 - (ziggedValue & 1)) ^ (((int)ziggedValue >> 1) & 0x7FFFFFFF);
		}

		private static long Zag(ulong ziggedValue)
		{
			return (long)(0L - (ziggedValue & 1)) ^ (((long)ziggedValue >> 1) & 0x7FFFFFFFFFFFFFFFL);
		}

		public long ReadInt64()
		{
			switch (wireType)
			{
			case WireType.Variant:
				return (long)ReadUInt64Variant();
			case WireType.Fixed32:
				return ReadInt32();
			case WireType.Fixed64:
				if (available < 8)
				{
					Ensure(8, strict: true);
				}
				position += 8;
				available -= 8;
				return (long)(ioBuffer[ioIndex++] | ((ulong)ioBuffer[ioIndex++] << 8) | ((ulong)ioBuffer[ioIndex++] << 16) | ((ulong)ioBuffer[ioIndex++] << 24) | ((ulong)ioBuffer[ioIndex++] << 32) | ((ulong)ioBuffer[ioIndex++] << 40) | ((ulong)ioBuffer[ioIndex++] << 48) | ((ulong)ioBuffer[ioIndex++] << 56));
			case WireType.SignedVariant:
				return Zag(ReadUInt64Variant());
			default:
				throw CreateWireTypeException();
			}
		}

		private int TryReadUInt64VariantWithoutMoving(out ulong value)
		{
			if (available < 10)
			{
				Ensure(10, strict: false);
			}
			if (available == 0)
			{
				value = 0uL;
				return 0;
			}
			int num = ioIndex;
			value = ioBuffer[num++];
			if ((value & 0x80) == 0)
			{
				return 1;
			}
			value &= 127uL;
			if (available == 1)
			{
				throw EoF(this);
			}
			ulong num2 = ioBuffer[num++];
			value |= (num2 & 0x7F) << 7;
			if ((num2 & 0x80) == 0)
			{
				return 2;
			}
			if (available == 2)
			{
				throw EoF(this);
			}
			num2 = ioBuffer[num++];
			value |= (num2 & 0x7F) << 14;
			if ((num2 & 0x80) == 0)
			{
				return 3;
			}
			if (available == 3)
			{
				throw EoF(this);
			}
			num2 = ioBuffer[num++];
			value |= (num2 & 0x7F) << 21;
			if ((num2 & 0x80) == 0)
			{
				return 4;
			}
			if (available == 4)
			{
				throw EoF(this);
			}
			num2 = ioBuffer[num++];
			value |= (num2 & 0x7F) << 28;
			if ((num2 & 0x80) == 0)
			{
				return 5;
			}
			if (available == 5)
			{
				throw EoF(this);
			}
			num2 = ioBuffer[num++];
			value |= (num2 & 0x7F) << 35;
			if ((num2 & 0x80) == 0)
			{
				return 6;
			}
			if (available == 6)
			{
				throw EoF(this);
			}
			num2 = ioBuffer[num++];
			value |= (num2 & 0x7F) << 42;
			if ((num2 & 0x80) == 0)
			{
				return 7;
			}
			if (available == 7)
			{
				throw EoF(this);
			}
			num2 = ioBuffer[num++];
			value |= (num2 & 0x7F) << 49;
			if ((num2 & 0x80) == 0)
			{
				return 8;
			}
			if (available == 8)
			{
				throw EoF(this);
			}
			num2 = ioBuffer[num++];
			value |= (num2 & 0x7F) << 56;
			if ((num2 & 0x80) == 0)
			{
				return 9;
			}
			if (available == 9)
			{
				throw EoF(this);
			}
			num2 = ioBuffer[num];
			value |= num2 << 63;
			if ((num2 & 0xFFFFFFFFFFFFFFFEuL) != 0)
			{
				throw AddErrorData(new OverflowException(), this);
			}
			return 10;
		}

		private ulong ReadUInt64Variant()
		{
			ulong value;
			int num = TryReadUInt64VariantWithoutMoving(out value);
			if (num > 0)
			{
				ioIndex += num;
				available -= num;
				position += num;
				return value;
			}
			throw EoF(this);
		}

		private string Intern(string value)
		{
			if (value == null)
			{
				return null;
			}
			if (value.Length == 0)
			{
				return "";
			}
			string value2;
			if (stringInterner == null)
			{
				stringInterner = new Dictionary<string, string>();
				stringInterner.Add(value, value);
			}
			else if (stringInterner.TryGetValue(value, out value2))
			{
				value = value2;
			}
			else
			{
				stringInterner.Add(value, value);
			}
			return value;
		}

		public string ReadString()
		{
			if (wireType == WireType.String)
			{
				int num = (int)ReadUInt32Variant(trimNegative: false);
				if (num == 0)
				{
					return "";
				}
				if (available < num)
				{
					Ensure(num, strict: true);
				}
				string text = encoding.GetString(ioBuffer, ioIndex, num);
				if (internStrings)
				{
					text = Intern(text);
				}
				available -= num;
				position += num;
				ioIndex += num;
				return text;
			}
			throw CreateWireTypeException();
		}

		public void ThrowEnumException(Type type, int value)
		{
			string text = (((object)type == null) ? "<null>" : type.FullName);
			throw AddErrorData(new ProtoException("No " + text + " enum is mapped to the wire-value " + value), this);
		}

		private Exception CreateWireTypeException()
		{
			return CreateException("Invalid wire-type; this usually means you have over-written a file without truncating or setting the length; see http://stackoverflow.com/q/2152978/23354");
		}

		private Exception CreateException(string message)
		{
			return AddErrorData(new ProtoException(message), this);
		}

		public double ReadDouble()
		{
			switch (wireType)
			{
			case WireType.Fixed32:
				return ReadSingle();
			case WireType.Fixed64:
			{
				long value = ReadInt64();
				return BitConverter.ToDouble(BitConverter.GetBytes(value), 0);
			}
			default:
				throw CreateWireTypeException();
			}
		}

		public static object ReadObject(object value, int key, ProtoReader reader)
		{
			return ReadTypedObject(value, key, reader, null);
		}

		internal static object ReadTypedObject(object value, int key, ProtoReader reader, Type type)
		{
			if (reader.model == null)
			{
				throw AddErrorData(new InvalidOperationException("Cannot deserialize sub-objects unless a model is provided"), reader);
			}
			SubItemToken token = StartSubItem(reader);
			if (key >= 0)
			{
				value = reader.model.Deserialize(key, value, reader);
			}
			else if ((object)type == null || !reader.model.TryDeserializeAuxiliaryType(reader, DataFormat.Default, 1, type, ref value, skipOtherFields: true, asListItem: false, autoCreate: true, insideList: false))
			{
				TypeModel.ThrowUnexpectedType(type);
			}
			EndSubItem(token, reader);
			return value;
		}

		public static void EndSubItem(SubItemToken token, ProtoReader reader)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			int value = token.value;
			WireType wireType = reader.wireType;
			if (wireType == WireType.EndGroup)
			{
				if (value >= 0)
				{
					throw AddErrorData(new ArgumentException("token"), reader);
				}
				if (-value != reader.fieldNumber)
				{
					throw reader.CreateException("Wrong group was ended");
				}
				reader.wireType = WireType.None;
				reader.depth--;
			}
			else
			{
				if (value < reader.position)
				{
					throw reader.CreateException("Sub-message not read entirely");
				}
				if (reader.blockEnd != reader.position && reader.blockEnd != int.MaxValue)
				{
					throw reader.CreateException("Sub-message not read correctly");
				}
				reader.blockEnd = value;
				reader.depth--;
			}
		}

		public static SubItemToken StartSubItem(ProtoReader reader)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			switch (reader.wireType)
			{
			case WireType.StartGroup:
				reader.wireType = WireType.None;
				reader.depth++;
				return new SubItemToken(-reader.fieldNumber);
			case WireType.String:
			{
				int num = (int)reader.ReadUInt32Variant(trimNegative: false);
				if (num < 0)
				{
					throw AddErrorData(new InvalidOperationException(), reader);
				}
				int value = reader.blockEnd;
				reader.blockEnd = reader.position + num;
				reader.depth++;
				return new SubItemToken(value);
			}
			default:
				throw reader.CreateWireTypeException();
			}
		}

		public int ReadFieldHeader()
		{
			if (blockEnd <= position || wireType == WireType.EndGroup)
			{
				return 0;
			}
			if (TryReadUInt32Variant(out var value))
			{
				wireType = (WireType)(value & 7);
				fieldNumber = (int)(value >> 3);
				if (fieldNumber < 1)
				{
					throw new ProtoException("Invalid field in source data: " + fieldNumber);
				}
			}
			else
			{
				wireType = WireType.None;
				fieldNumber = 0;
			}
			if (wireType == WireType.EndGroup)
			{
				if (depth > 0)
				{
					return 0;
				}
				throw new ProtoException("Unexpected end-group in source data; this usually means the source data is corrupt");
			}
			return fieldNumber;
		}

		public bool TryReadFieldHeader(int field)
		{
			if (blockEnd <= position || this.wireType == WireType.EndGroup)
			{
				return false;
			}
			uint value;
			int num = TryReadUInt32VariantWithoutMoving(trimNegative: false, out value);
			WireType wireType;
			if (num > 0 && (int)value >> 3 == field && (wireType = (WireType)(value & 7)) != WireType.EndGroup)
			{
				this.wireType = wireType;
				fieldNumber = field;
				position += num;
				ioIndex += num;
				available -= num;
				return true;
			}
			return false;
		}

		public void Hint(WireType wireType)
		{
			if (this.wireType != wireType && (wireType & (WireType)7) == this.wireType)
			{
				this.wireType = wireType;
			}
		}

		public void Assert(WireType wireType)
		{
			if (this.wireType != wireType)
			{
				if ((wireType & (WireType)7) != this.wireType)
				{
					throw CreateWireTypeException();
				}
				this.wireType = wireType;
			}
		}

		public void SkipField()
		{
			switch (wireType)
			{
			case WireType.Fixed32:
				if (available < 4)
				{
					Ensure(4, strict: true);
				}
				available -= 4;
				ioIndex += 4;
				position += 4;
				break;
			case WireType.Fixed64:
				if (available < 8)
				{
					Ensure(8, strict: true);
				}
				available -= 8;
				ioIndex += 8;
				position += 8;
				break;
			case WireType.String:
			{
				int num2 = (int)ReadUInt32Variant(trimNegative: false);
				if (num2 <= available)
				{
					available -= num2;
					ioIndex += num2;
					position += num2;
					break;
				}
				position += num2;
				num2 -= available;
				ioIndex = (available = 0);
				if (isFixedLength)
				{
					if (num2 > dataRemaining)
					{
						throw EoF(this);
					}
					dataRemaining -= num2;
				}
				Seek(source, num2, ioBuffer);
				break;
			}
			case WireType.Variant:
			case WireType.SignedVariant:
				ReadUInt64Variant();
				break;
			case WireType.StartGroup:
			{
				int num = fieldNumber;
				depth++;
				while (ReadFieldHeader() > 0)
				{
					SkipField();
				}
				depth--;
				if (wireType == WireType.EndGroup && fieldNumber == num)
				{
					wireType = WireType.None;
					break;
				}
				throw CreateWireTypeException();
			}
			default:
				throw CreateWireTypeException();
			}
		}

		public ulong ReadUInt64()
		{
			switch (wireType)
			{
			case WireType.Variant:
				return ReadUInt64Variant();
			case WireType.Fixed32:
				return ReadUInt32();
			case WireType.Fixed64:
				if (available < 8)
				{
					Ensure(8, strict: true);
				}
				position += 8;
				available -= 8;
				return ioBuffer[ioIndex++] | ((ulong)ioBuffer[ioIndex++] << 8) | ((ulong)ioBuffer[ioIndex++] << 16) | ((ulong)ioBuffer[ioIndex++] << 24) | ((ulong)ioBuffer[ioIndex++] << 32) | ((ulong)ioBuffer[ioIndex++] << 40) | ((ulong)ioBuffer[ioIndex++] << 48) | ((ulong)ioBuffer[ioIndex++] << 56);
			default:
				throw CreateWireTypeException();
			}
		}

		public float ReadSingle()
		{
			switch (wireType)
			{
			case WireType.Fixed32:
			{
				int value = ReadInt32();
				return BitConverter.ToSingle(BitConverter.GetBytes(value), 0);
			}
			case WireType.Fixed64:
			{
				double num = ReadDouble();
				float num2 = (float)num;
				if (Helpers.IsInfinity(num2) && !Helpers.IsInfinity(num))
				{
					throw AddErrorData(new OverflowException(), this);
				}
				return num2;
			}
			default:
				throw CreateWireTypeException();
			}
		}

		public bool ReadBoolean()
		{
			return ReadUInt32() switch
			{
				0u => false, 
				1u => true, 
				_ => throw CreateException("Unexpected boolean value"), 
			};
		}

		public static byte[] AppendBytes(byte[] value, ProtoReader reader)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			WireType wireType = reader.wireType;
			if (wireType == WireType.String)
			{
				int num = (int)reader.ReadUInt32Variant(trimNegative: false);
				reader.wireType = WireType.None;
				if (num == 0)
				{
					if (value != null)
					{
						return value;
					}
					return EmptyBlob;
				}
				int num2;
				if (value == null || value.Length == 0)
				{
					num2 = 0;
					value = new byte[num];
				}
				else
				{
					num2 = value.Length;
					byte[] array = new byte[value.Length + num];
					Helpers.BlockCopy(value, 0, array, 0, value.Length);
					value = array;
				}
				reader.position += num;
				while (num > reader.available)
				{
					if (reader.available > 0)
					{
						Helpers.BlockCopy(reader.ioBuffer, reader.ioIndex, value, num2, reader.available);
						num -= reader.available;
						num2 += reader.available;
						reader.ioIndex = (reader.available = 0);
					}
					int num3 = ((num > reader.ioBuffer.Length) ? reader.ioBuffer.Length : num);
					if (num3 > 0)
					{
						reader.Ensure(num3, strict: true);
					}
				}
				if (num > 0)
				{
					Helpers.BlockCopy(reader.ioBuffer, reader.ioIndex, value, num2, num);
					reader.ioIndex += num;
					reader.available -= num;
				}
				return value;
			}
			throw reader.CreateWireTypeException();
		}

		private static int ReadByteOrThrow(Stream source)
		{
			int num = source.ReadByte();
			if (num < 0)
			{
				throw EoF(null);
			}
			return num;
		}

		public static int ReadLengthPrefix(Stream source, bool expectHeader, PrefixStyle style, out int fieldNumber)
		{
			int bytesRead;
			return ReadLengthPrefix(source, expectHeader, style, out fieldNumber, out bytesRead);
		}

		public static int DirectReadLittleEndianInt32(Stream source)
		{
			return ReadByteOrThrow(source) | (ReadByteOrThrow(source) << 8) | (ReadByteOrThrow(source) << 16) | (ReadByteOrThrow(source) << 24);
		}

		public static int DirectReadBigEndianInt32(Stream source)
		{
			return (ReadByteOrThrow(source) << 24) | (ReadByteOrThrow(source) << 16) | (ReadByteOrThrow(source) << 8) | ReadByteOrThrow(source);
		}

		public static int DirectReadVarintInt32(Stream source)
		{
			uint value;
			int num = TryReadUInt32Variant(source, out value);
			if (num <= 0)
			{
				throw EoF(null);
			}
			return (int)value;
		}

		public static void DirectReadBytes(Stream source, byte[] buffer, int offset, int count)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			int num;
			while (count > 0 && (num = source.Read(buffer, offset, count)) > 0)
			{
				count -= num;
				offset += num;
			}
			if (count > 0)
			{
				throw EoF(null);
			}
		}

		public static byte[] DirectReadBytes(Stream source, int count)
		{
			byte[] array = new byte[count];
			DirectReadBytes(source, array, 0, count);
			return array;
		}

		public static string DirectReadString(Stream source, int length)
		{
			byte[] array = new byte[length];
			DirectReadBytes(source, array, 0, length);
			return Encoding.UTF8.GetString(array, 0, length);
		}

		public static int ReadLengthPrefix(Stream source, bool expectHeader, PrefixStyle style, out int fieldNumber, out int bytesRead)
		{
			fieldNumber = 0;
			switch (style)
			{
			case PrefixStyle.None:
				bytesRead = 0;
				return int.MaxValue;
			case PrefixStyle.Base128:
			{
				bytesRead = 0;
				uint value;
				int num2;
				if (expectHeader)
				{
					num2 = TryReadUInt32Variant(source, out value);
					bytesRead += num2;
					if (num2 > 0)
					{
						if ((value & 7) != 2)
						{
							throw new InvalidOperationException();
						}
						fieldNumber = (int)(value >> 3);
						num2 = TryReadUInt32Variant(source, out value);
						bytesRead += num2;
						if (bytesRead == 0)
						{
							throw EoF(null);
						}
						return (int)value;
					}
					bytesRead = 0;
					return -1;
				}
				num2 = TryReadUInt32Variant(source, out value);
				bytesRead += num2;
				if (bytesRead >= 0)
				{
					return (int)value;
				}
				return -1;
			}
			case PrefixStyle.Fixed32:
			{
				int num3 = source.ReadByte();
				if (num3 < 0)
				{
					bytesRead = 0;
					return -1;
				}
				bytesRead = 4;
				return num3 | (ReadByteOrThrow(source) << 8) | (ReadByteOrThrow(source) << 16) | (ReadByteOrThrow(source) << 24);
			}
			case PrefixStyle.Fixed32BigEndian:
			{
				int num = source.ReadByte();
				if (num < 0)
				{
					bytesRead = 0;
					return -1;
				}
				bytesRead = 4;
				return (num << 24) | (ReadByteOrThrow(source) << 16) | (ReadByteOrThrow(source) << 8) | ReadByteOrThrow(source);
			}
			default:
				throw new ArgumentOutOfRangeException("style");
			}
		}

		private static int TryReadUInt32Variant(Stream source, out uint value)
		{
			value = 0u;
			int num = source.ReadByte();
			if (num < 0)
			{
				return 0;
			}
			value = (uint)num;
			if ((value & 0x80) == 0)
			{
				return 1;
			}
			value &= 127u;
			num = source.ReadByte();
			if (num < 0)
			{
				throw EoF(null);
			}
			value |= (uint)((num & 0x7F) << 7);
			if ((num & 0x80) == 0)
			{
				return 2;
			}
			num = source.ReadByte();
			if (num < 0)
			{
				throw EoF(null);
			}
			value |= (uint)((num & 0x7F) << 14);
			if ((num & 0x80) == 0)
			{
				return 3;
			}
			num = source.ReadByte();
			if (num < 0)
			{
				throw EoF(null);
			}
			value |= (uint)((num & 0x7F) << 21);
			if ((num & 0x80) == 0)
			{
				return 4;
			}
			num = source.ReadByte();
			if (num < 0)
			{
				throw EoF(null);
			}
			value |= (uint)(num << 28);
			if ((num & 0xF0) == 0)
			{
				return 5;
			}
			throw new OverflowException();
		}

		internal static void Seek(Stream source, int count, byte[] buffer)
		{
			if (source.CanSeek)
			{
				source.Seek(count, SeekOrigin.Current);
				count = 0;
			}
			else if (buffer != null)
			{
				int num;
				while (count > buffer.Length && (num = source.Read(buffer, 0, buffer.Length)) > 0)
				{
					count -= num;
				}
				while (count > 0 && (num = source.Read(buffer, 0, count)) > 0)
				{
					count -= num;
				}
			}
			else
			{
				buffer = BufferPool.GetBuffer();
				try
				{
					int num2;
					while (count > buffer.Length && (num2 = source.Read(buffer, 0, buffer.Length)) > 0)
					{
						count -= num2;
					}
					while (count > 0 && (num2 = source.Read(buffer, 0, count)) > 0)
					{
						count -= num2;
					}
				}
				finally
				{
					BufferPool.ReleaseBufferToPool(ref buffer);
				}
			}
			if (count > 0)
			{
				throw EoF(null);
			}
		}

		internal static Exception AddErrorData(Exception exception, ProtoReader source)
		{
			if (exception != null && source != null && !exception.Data.Contains("protoSource"))
			{
				exception.Data.Add("protoSource", $"tag={source.fieldNumber}; wire-type={source.wireType}; offset={source.position}; depth={source.depth}");
			}
			return exception;
		}

		private static Exception EoF(ProtoReader source)
		{
			return AddErrorData(new EndOfStreamException(), source);
		}

		public void AppendExtensionData(IExtensible instance)
		{
			if (instance == null)
			{
				throw new ArgumentNullException("instance");
			}
			IExtension extensionObject = instance.GetExtensionObject(createIfMissing: true);
			bool commit = false;
			Stream stream = extensionObject.BeginAppend();
			try
			{
				using (ProtoWriter protoWriter = new ProtoWriter(stream, model, null))
				{
					AppendExtensionField(protoWriter);
					protoWriter.Close();
				}
				commit = true;
			}
			finally
			{
				extensionObject.EndAppend(stream, commit);
			}
		}

		private void AppendExtensionField(ProtoWriter writer)
		{
			ProtoWriter.WriteFieldHeader(fieldNumber, wireType, writer);
			switch (wireType)
			{
			case WireType.Fixed32:
				ProtoWriter.WriteInt32(ReadInt32(), writer);
				break;
			case WireType.Variant:
			case WireType.Fixed64:
			case WireType.SignedVariant:
				ProtoWriter.WriteInt64(ReadInt64(), writer);
				break;
			case WireType.String:
				ProtoWriter.WriteBytes(AppendBytes(null, this), writer);
				break;
			case WireType.StartGroup:
			{
				SubItemToken token = StartSubItem(this);
				SubItemToken token2 = ProtoWriter.StartSubItem(null, writer);
				while (ReadFieldHeader() > 0)
				{
					AppendExtensionField(writer);
				}
				EndSubItem(token, this);
				ProtoWriter.EndSubItem(token2, writer);
				break;
			}
			default:
				throw CreateWireTypeException();
			}
		}

		public static bool HasSubValue(WireType wireType, ProtoReader source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (source.blockEnd <= source.position || wireType == WireType.EndGroup)
			{
				return false;
			}
			source.wireType = wireType;
			return true;
		}

		internal int GetTypeKey(ref Type type)
		{
			return model.GetKey(ref type);
		}

		internal Type DeserializeType(string value)
		{
			return TypeModel.DeserializeType(model, value);
		}

		internal void SetRootObject(object value)
		{
			netCache.SetKeyedObject(0, value);
			trapCount--;
		}

		public static void NoteObject(object value, ProtoReader reader)
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			if (reader.trapCount != 0)
			{
				reader.netCache.RegisterTrappedObject(value);
				reader.trapCount--;
			}
		}

		public Type ReadType()
		{
			return TypeModel.DeserializeType(model, ReadString());
		}

		internal void TrapNextObject(int newObjectKey)
		{
			trapCount++;
			netCache.SetKeyedObject(newObjectKey, null);
		}

		internal void CheckFullyConsumed()
		{
			if (isFixedLength)
			{
				if (dataRemaining != 0)
				{
					throw new ProtoException("Incorrect number of bytes consumed");
				}
			}
			else if (available != 0)
			{
				throw new ProtoException("Unconsumed data left in the buffer; this suggests corrupt input");
			}
		}

		public static object Merge(ProtoReader parent, object from, object to)
		{
			if (parent == null)
			{
				throw new ArgumentNullException("parent");
			}
			TypeModel typeModel = parent.Model;
			SerializationContext serializationContext = parent.Context;
			if (typeModel == null)
			{
				throw new InvalidOperationException("Types cannot be merged unless a type-model has been specified");
			}
			using MemoryStream memoryStream = new MemoryStream();
			typeModel.Serialize(memoryStream, from, serializationContext);
			memoryStream.Position = 0L;
			return typeModel.Deserialize(memoryStream, to, null);
		}

		internal static ProtoReader Create(Stream source, TypeModel model, SerializationContext context, int len)
		{
			ProtoReader recycled = GetRecycled();
			if (recycled == null)
			{
				return new ProtoReader(source, model, context, len);
			}
			Init(recycled, source, model, context, len);
			return recycled;
		}

		private static ProtoReader GetRecycled()
		{
			ProtoReader result = lastReader;
			lastReader = null;
			return result;
		}

		internal static void Recycle(ProtoReader reader)
		{
			if (reader != null)
			{
				reader.Dispose();
				lastReader = reader;
			}
		}
	}
	public sealed class ProtoWriter : IDisposable
	{
		private const int RecursionCheckDepth = 25;

		private Stream dest;

		private TypeModel model;

		private readonly NetObjectCache netCache = new NetObjectCache();

		private int fieldNumber;

		private int flushLock;

		private WireType wireType;

		private int depth;

		private MutableList recursionStack;

		private readonly SerializationContext context;

		private byte[] ioBuffer;

		private int ioIndex;

		private int position;

		private static readonly UTF8Encoding encoding = new UTF8Encoding();

		private int packedFieldNumber;

		internal NetObjectCache NetCache => netCache;

		internal WireType WireType => wireType;

		public SerializationContext Context => context;

		public TypeModel Model => model;

		public static void WriteObject(object value, int key, ProtoWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			if (writer.model == null)
			{
				throw new InvalidOperationException("Cannot serialize sub-objects unless a model is provided");
			}
			SubItemToken token = StartSubItem(value, writer);
			if (key >= 0)
			{
				writer.model.Serialize(key, value, writer);
			}
			else if (writer.model == null || !writer.model.TrySerializeAuxiliaryType(writer, value.GetType(), DataFormat.Default, 1, value, isInsideList: false))
			{
				TypeModel.ThrowUnexpectedType(value.GetType());
			}
			EndSubItem(token, writer);
		}

		public static void WriteRecursionSafeObject(object value, int key, ProtoWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			if (writer.model == null)
			{
				throw new InvalidOperationException("Cannot serialize sub-objects unless a model is provided");
			}
			SubItemToken token = StartSubItem(null, writer);
			writer.model.Serialize(key, value, writer);
			EndSubItem(token, writer);
		}

		internal static void WriteObject(object value, int key, ProtoWriter writer, PrefixStyle style, int fieldNumber)
		{
			if (writer.model == null)
			{
				throw new InvalidOperationException("Cannot serialize sub-objects unless a model is provided");
			}
			if (writer.wireType != WireType.None)
			{
				throw CreateException(writer);
			}
			switch (style)
			{
			case PrefixStyle.Base128:
				writer.wireType = WireType.String;
				writer.fieldNumber = fieldNumber;
				if (fieldNumber > 0)
				{
					WriteHeaderCore(fieldNumber, WireType.String, writer);
				}
				break;
			case PrefixStyle.Fixed32:
			case PrefixStyle.Fixed32BigEndian:
				writer.fieldNumber = 0;
				writer.wireType = WireType.Fixed32;
				break;
			default:
				throw new ArgumentOutOfRangeException("style");
			}
			SubItemToken token = StartSubItem(value, writer, allowFixed: true);
			if (key < 0)
			{
				if (!writer.model.TrySerializeAuxiliaryType(writer, value.GetType(), DataFormat.Default, 1, value, isInsideList: false))
				{
					TypeModel.ThrowUnexpectedType(value.GetType());
				}
			}
			else
			{
				writer.model.Serialize(key, value, writer);
			}
			EndSubItem(token, writer, style);
		}

		internal int GetTypeKey(ref Type type)
		{
			return model.GetKey(ref type);
		}

		public static void WriteFieldHeader(int fieldNumber, WireType wireType, ProtoWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			if (writer.wireType != WireType.None)
			{
				throw new InvalidOperationException("Cannot write a " + wireType.ToString() + " header until the " + writer.wireType.ToString() + " data has been written");
			}
			if (fieldNumber < 0)
			{
				throw new ArgumentOutOfRangeException("fieldNumber");
			}
			if (writer.packedFieldNumber == 0)
			{
				writer.fieldNumber = fieldNumber;
				writer.wireType = wireType;
				WriteHeaderCore(fieldNumber, wireType, writer);
				return;
			}
			if (writer.packedFieldNumber == fieldNumber)
			{
				switch (wireType)
				{
				default:
					throw new InvalidOperationException("Wire-type cannot be encoded as packed: " + wireType);
				case WireType.Variant:
				case WireType.Fixed64:
				case WireType.Fixed32:
				case WireType.SignedVariant:
					writer.fieldNumber = fieldNumber;
					writer.wireType = wireType;
					break;
				}
				return;
			}
			throw new InvalidOperationException("Field mismatch during packed encoding; expected " + writer.packedFieldNumber + " but received " + fieldNumber);
		}

		internal static void WriteHeaderCore(int fieldNumber, WireType wireType, ProtoWriter writer)
		{
			uint value = (uint)(fieldNumber << 3) | (uint)(wireType & (WireType)7);
			WriteUInt32Variant(value, writer);
		}

		public static void WriteBytes(byte[] data, ProtoWriter writer)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			WriteBytes(data, 0, data.Length, writer);
		}

		public static void WriteBytes(byte[] data, int offset, int length, ProtoWriter writer)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			switch (writer.wireType)
			{
			case WireType.Fixed32:
				if (length != 4)
				{
					throw new ArgumentException("length");
				}
				break;
			case WireType.Fixed64:
				if (length != 8)
				{
					throw new ArgumentException("length");
				}
				break;
			case WireType.String:
				WriteUInt32Variant((uint)length, writer);
				writer.wireType = WireType.None;
				if (length == 0)
				{
					return;
				}
				if (writer.flushLock == 0 && length > writer.ioBuffer.Length)
				{
					Flush(writer);
					writer.dest.Write(data, offset, length);
					writer.position += length;
					return;
				}
				break;
			default:
				throw CreateException(writer);
			}
			DemandSpace(length, writer);
			Helpers.BlockCopy(data, offset, writer.ioBuffer, writer.ioIndex, length);
			IncrementedAndReset(length, writer);
		}

		private static void CopyRawFromStream(Stream source, ProtoWriter writer)
		{
			byte[] array = writer.ioBuffer;
			int num = array.Length - writer.ioIndex;
			int num2 = 1;
			while (num > 0 && (num2 = source.Read(array, writer.ioIndex, num)) > 0)
			{
				writer.ioIndex += num2;
				writer.position += num2;
				num -= num2;
			}
			if (num2 <= 0)
			{
				return;
			}
			if (writer.flushLock == 0)
			{
				Flush(writer);
				while ((num2 = source.Read(array, 0, array.Length)) > 0)
				{
					writer.dest.Write(array, 0, num2);
					writer.position += num2;
				}
				return;
			}
			while (true)
			{
				DemandSpace(128, writer);
				if ((num2 = source.Read(writer.ioBuffer, writer.ioIndex, writer.ioBuffer.Length - writer.ioIndex)) <= 0)
				{
					break;
				}
				writer.position += num2;
				writer.ioIndex += num2;
			}
		}

		private static void IncrementedAndReset(int length, ProtoWriter writer)
		{
			writer.ioIndex += length;
			writer.position += length;
			writer.wireType = WireType.None;
		}

		public static SubItemToken StartSubItem(object instance, ProtoWriter writer)
		{
			return StartSubItem(instance, writer, allowFixed: false);
		}

		private void CheckRecursionStackAndPush(object instance)
		{
			int num;
			if (recursionStack == null)
			{
				recursionStack = new MutableList();
			}
			else if (instance != null && (num = recursionStack.IndexOfReference(instance)) >= 0)
			{
				throw new ProtoException("Possible recursion detected (offset: " + (recursionStack.Count - num) + " level(s)): " + instance.ToString());
			}
			recursionStack.Add(instance);
		}

		private void PopRecursionStack()
		{
			recursionStack.RemoveLast();
		}

		private static SubItemToken StartSubItem(object instance, ProtoWriter writer, bool allowFixed)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			if (++writer.depth > 25)
			{
				writer.CheckRecursionStackAndPush(instance);
			}
			if (writer.packedFieldNumber != 0)
			{
				throw new InvalidOperationException("Cannot begin a sub-item while performing packed encoding");
			}
			switch (writer.wireType)
			{
			case WireType.StartGroup:
				writer.wireType = WireType.None;
				return new SubItemToken(-writer.fieldNumber);
			case WireType.String:
				writer.wireType = WireType.None;
				DemandSpace(32, writer);
				writer.flushLock++;
				writer.position++;
				return new SubItemToken(writer.ioIndex++);
			case WireType.Fixed32:
			{
				if (!allowFixed)
				{
					throw CreateException(writer);
				}
				DemandSpace(32, writer);
				writer.flushLock++;
				SubItemToken result = new SubItemToken(writer.ioIndex);
				IncrementedAndReset(4, writer);
				return result;
			}
			default:
				throw CreateException(writer);
			}
		}

		public static void EndSubItem(SubItemToken token, ProtoWriter writer)
		{
			EndSubItem(token, writer, PrefixStyle.Base128);
		}

		private static void EndSubItem(SubItemToken token, ProtoWriter writer, PrefixStyle style)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			if (writer.wireType != WireType.None)
			{
				throw CreateException(writer);
			}
			int value = token.value;
			if (writer.depth <= 0)
			{
				throw CreateException(writer);
			}
			if (writer.depth-- > 25)
			{
				writer.PopRecursionStack();
			}
			writer.packedFieldNumber = 0;
			if (value < 0)
			{
				WriteHeaderCore(-value, WireType.EndGroup, writer);
				writer.wireType = WireType.None;
				return;
			}
			switch (style)
			{
			case PrefixStyle.Fixed32:
			{
				int num = writer.ioIndex - value - 4;
				WriteInt32ToBuffer(num, writer.ioBuffer, value);
				break;
			}
			case PrefixStyle.Fixed32BigEndian:
			{
				int num = writer.ioIndex - value - 4;
				byte[] array2 = writer.ioBuffer;
				WriteInt32ToBuffer(num, array2, value);
				byte b = array2[value];
				array2[value] = array2[value + 3];
				array2[value + 3] = b;
				b = array2[value + 1];
				array2[value + 1] = array2[value + 2];
				array2[value + 2] = b;
				break;
			}
			case PrefixStyle.Base128:
			{
				int num = writer.ioIndex - value - 1;
				int num2 = 0;
				uint num3 = (uint)num;
				while ((num3 >>= 7) != 0)
				{
					num2++;
				}
				if (num2 == 0)
				{
					writer.ioBuffer[value] = (byte)(num & 0x7F);
					break;
				}
				DemandSpace(num2, writer);
				byte[] array = writer.ioBuffer;
				Helpers.BlockCopy(array, value + 1, array, value + 1 + num2, num);
				num3 = (uint)num;
				do
				{
					array[value++] = (byte)((num3 & 0x7F) | 0x80);
				}
				while ((num3 >>= 7) != 0);
				array[value - 1] = (byte)(array[value - 1] & -129);
				writer.position += num2;
				writer.ioIndex += num2;
				break;
			}
			default:
				throw new ArgumentOutOfRangeException("style");
			}
			if (--writer.flushLock == 0 && writer.ioIndex >= 1024)
			{
				Flush(writer);
			}
		}

		public ProtoWriter(Stream dest, TypeModel model, SerializationContext context)
		{
			if (dest == null)
			{
				throw new ArgumentNullException("dest");
			}
			if (!dest.CanWrite)
			{
				throw new ArgumentException("Cannot write to stream", "dest");
			}
			this.dest = dest;
			ioBuffer = BufferPool.GetBuffer();
			this.model = model;
			wireType = WireType.None;
			if (context == null)
			{
				context = SerializationContext.Default;
			}
			else
			{
				context.Freeze();
			}
			this.context = context;
		}

		void IDisposable.Dispose()
		{
			Dispose();
		}

		private void Dispose()
		{
			if (dest != null)
			{
				Flush(this);
				dest = null;
			}
			model = null;
			BufferPool.ReleaseBufferToPool(ref ioBuffer);
		}

		internal static int GetPosition(ProtoWriter writer)
		{
			return writer.position;
		}

		private static void DemandSpace(int required, ProtoWriter writer)
		{
			if (writer.ioBuffer.Length - writer.ioIndex >= required)
			{
				return;
			}
			if (writer.flushLock == 0)
			{
				Flush(writer);
				if (writer.ioBuffer.Length - writer.ioIndex >= required)
				{
					return;
				}
			}
			BufferPool.ResizeAndFlushLeft(ref writer.ioBuffer, required + writer.ioIndex, 0, writer.ioIndex);
		}

		public void Close()
		{
			if (depth != 0 || flushLock != 0)
			{
				throw new InvalidOperationException("Unable to close stream in an incomplete state");
			}
			Dispose();
		}

		internal void CheckDepthFlushlock()
		{
			if (depth != 0 || flushLock != 0)
			{
				throw new InvalidOperationException("The writer is in an incomplete state");
			}
		}

		internal static void Flush(ProtoWriter writer)
		{
			if (writer.flushLock == 0 && writer.ioIndex != 0)
			{
				writer.dest.Write(writer.ioBuffer, 0, writer.ioIndex);
				writer.ioIndex = 0;
			}
		}

		private static void WriteUInt32Variant(uint value, ProtoWriter writer)
		{
			DemandSpace(5, writer);
			int num = 0;
			do
			{
				writer.ioBuffer[writer.ioIndex++] = (byte)((value & 0x7F) | 0x80);
				num++;
			}
			while ((value >>= 7) != 0);
			writer.ioBuffer[writer.ioIndex - 1] &= 127;
			writer.position += num;
		}

		internal static uint Zig(int value)
		{
			return (uint)((value << 1) ^ (value >> 31));
		}

		internal static ulong Zig(long value)
		{
			return (ulong)((value << 1) ^ (value >> 63));
		}

		private static void WriteUInt64Variant(ulong value, ProtoWriter writer)
		{
			DemandSpace(10, writer);
			int num = 0;
			do
			{
				writer.ioBuffer[writer.ioIndex++] = (byte)((value & 0x7F) | 0x80);
				num++;
			}
			while ((value >>= 7) != 0);
			writer.ioBuffer[writer.ioIndex - 1] &= 127;
			writer.position += num;
		}

		public static void WriteString(string value, ProtoWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			if (writer.wireType != WireType.String)
			{
				throw CreateException(writer);
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (value.Length == 0)
			{
				WriteUInt32Variant(0u, writer);
				writer.wireType = WireType.None;
				return;
			}
			int byteCount = encoding.GetByteCount(value);
			WriteUInt32Variant((uint)byteCount, writer);
			DemandSpace(byteCount, writer);
			int bytes = encoding.GetBytes(value, 0, value.Length, writer.ioBuffer, writer.ioIndex);
			IncrementedAndReset(bytes, writer);
		}

		public static void WriteUInt64(ulong value, ProtoWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			switch (writer.wireType)
			{
			case WireType.Fixed64:
				WriteInt64((long)value, writer);
				break;
			case WireType.Variant:
				WriteUInt64Variant(value, writer);
				writer.wireType = WireType.None;
				break;
			case WireType.Fixed32:
				WriteUInt32(checked((uint)value), writer);
				break;
			default:
				throw CreateException(writer);
			}
		}

		public static void WriteInt64(long value, ProtoWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			switch (writer.wireType)
			{
			case WireType.Fixed64:
			{
				DemandSpace(8, writer);
				byte[] array = writer.ioBuffer;
				int num = writer.ioIndex;
				array[num] = (byte)value;
				array[num + 1] = (byte)(value >> 8);
				array[num + 2] = (byte)(value >> 16);
				array[num + 3] = (byte)(value >> 24);
				array[num + 4] = (byte)(value >> 32);
				array[num + 5] = (byte)(value >> 40);
				array[num + 6] = (byte)(value >> 48);
				array[num + 7] = (byte)(value >> 56);
				IncrementedAndReset(8, writer);
				break;
			}
			case WireType.SignedVariant:
				WriteUInt64Variant(Zig(value), writer);
				writer.wireType = WireType.None;
				break;
			case WireType.Variant:
			{
				if (value >= 0)
				{
					WriteUInt64Variant((ulong)value, writer);
					writer.wireType = WireType.None;
					break;
				}
				DemandSpace(10, writer);
				byte[] array = writer.ioBuffer;
				int num = writer.ioIndex;
				array[num] = (byte)(value | 0x80);
				array[num + 1] = (byte)((int)(value >> 7) | 0x80);
				array[num + 2] = (byte)((int)(value >> 14) | 0x80);
				array[num + 3] = (byte)((int)(value >> 21) | 0x80);
				array[num + 4] = (byte)((int)(value >> 28) | 0x80);
				array[num + 5] = (byte)((int)(value >> 35) | 0x80);
				array[num + 6] = (byte)((int)(value >> 42) | 0x80);
				array[num + 7] = (byte)((int)(value >> 49) | 0x80);
				array[num + 8] = (byte)((int)(value >> 56) | 0x80);
				array[num + 9] = 1;
				IncrementedAndReset(10, writer);
				break;
			}
			case WireType.Fixed32:
				WriteInt32(checked((int)value), writer);
				break;
			default:
				throw CreateException(writer);
			}
		}

		public static void WriteUInt32(uint value, ProtoWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			switch (writer.wireType)
			{
			case WireType.Fixed32:
				WriteInt32((int)value, writer);
				break;
			case WireType.Fixed64:
				WriteInt64((int)value, writer);
				break;
			case WireType.Variant:
				WriteUInt32Variant(value, writer);
				writer.wireType = WireType.None;
				break;
			default:
				throw CreateException(writer);
			}
		}

		public static void WriteInt16(short value, ProtoWriter writer)
		{
			WriteInt32(value, writer);
		}

		public static void WriteUInt16(ushort value, ProtoWriter writer)
		{
			WriteUInt32(value, writer);
		}

		public static void WriteByte(byte value, ProtoWriter writer)
		{
			WriteUInt32(value, writer);
		}

		public static void WriteSByte(sbyte value, ProtoWriter writer)
		{
			WriteInt32(value, writer);
		}

		private static void WriteInt32ToBuffer(int value, byte[] buffer, int index)
		{
			buffer[index] = (byte)value;
			buffer[index + 1] = (byte)(value >> 8);
			buffer[index + 2] = (byte)(value >> 16);
			buffer[index + 3] = (byte)(value >> 24);
		}

		public static void WriteInt32(int value, ProtoWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			switch (writer.wireType)
			{
			case WireType.Fixed32:
				DemandSpace(4, writer);
				WriteInt32ToBuffer(value, writer.ioBuffer, writer.ioIndex);
				IncrementedAndReset(4, writer);
				break;
			case WireType.Fixed64:
			{
				DemandSpace(8, writer);
				byte[] array = writer.ioBuffer;
				int num = writer.ioIndex;
				array[num] = (byte)value;
				array[num + 1] = (byte)(value >> 8);
				array[num + 2] = (byte)(value >> 16);
				array[num + 3] = (byte)(value >> 24);
				array[num + 4] = (array[num + 5] = (array[num + 6] = (array[num + 7] = 0)));
				IncrementedAndReset(8, writer);
				break;
			}
			case WireType.SignedVariant:
				WriteUInt32Variant(Zig(value), writer);
				writer.wireType = WireType.None;
				break;
			case WireType.Variant:
			{
				if (value >= 0)
				{
					WriteUInt32Variant((uint)value, writer);
					writer.wireType = WireType.None;
					break;
				}
				DemandSpace(10, writer);
				byte[] array = writer.ioBuffer;
				int num = writer.ioIndex;
				array[num] = (byte)(value | 0x80);
				array[num + 1] = (byte)((value >> 7) | 0x80);
				array[num + 2] = (byte)((value >> 14) | 0x80);
				array[num + 3] = (byte)((value >> 21) | 0x80);
				array[num + 4] = (byte)((value >> 28) | 0x80);
				byte[] array2 = array;
				int num2 = num + 5;
				byte[] array3 = array;
				int num3 = num + 6;
				byte[] array4 = array;
				int num4 = num + 7;
				byte b;
				array[num + 8] = (b = byte.MaxValue);
				array2[num2] = (array3[num3] = (array4[num4] = b));
				array[num + 9] = 1;
				IncrementedAndReset(10, writer);
				break;
			}
			default:
				throw CreateException(writer);
			}
		}

		public static void WriteDouble(double value, ProtoWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			switch (writer.wireType)
			{
			case WireType.Fixed32:
			{
				float value2 = (float)value;
				if (Helpers.IsInfinity(value2) && !Helpers.IsInfinity(value))
				{
					throw new OverflowException();
				}
				WriteSingle(value2, writer);
				break;
			}
			case WireType.Fixed64:
				WriteInt64(BitConverter.ToInt64(BitConverter.GetBytes(value), 0), writer);
				break;
			default:
				throw CreateException(writer);
			}
		}

		public static void WriteSingle(float value, ProtoWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			switch (writer.wireType)
			{
			case WireType.Fixed32:
				WriteInt32(BitConverter.ToInt32(BitConverter.GetBytes(value), 0), writer);
				break;
			case WireType.Fixed64:
				WriteDouble(value, writer);
				break;
			default:
				throw CreateException(writer);
			}
		}

		public static void ThrowEnumException(ProtoWriter writer, object enumValue)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			string text = ((enumValue == null) ? "<null>" : (enumValue.GetType().FullName + "." + enumValue.ToString()));
			throw new ProtoException("No wire-value is mapped to the enum " + text + " at position " + writer.position);
		}

		internal static Exception CreateException(ProtoWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			return new ProtoException("Invalid serialization operation with wire-type " + writer.wireType.ToString() + " at position " + writer.position);
		}

		public static void WriteBoolean(bool value, ProtoWriter writer)
		{
			WriteUInt32(value ? 1u : 0u, writer);
		}

		public static void AppendExtensionData(IExtensible instance, ProtoWriter writer)
		{
			if (instance == null)
			{
				throw new ArgumentNullException("instance");
			}
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			if (writer.wireType != WireType.None)
			{
				throw CreateException(writer);
			}
			IExtension extensionObject = instance.GetExtensionObject(createIfMissing: false);
			if (extensionObject != null)
			{
				Stream stream = extensionObject.BeginQuery();
				try
				{
					CopyRawFromStream(stream, writer);
				}
				finally
				{
					extensionObject.EndQuery(stream);
				}
			}
		}

		public static void SetPackedField(int fieldNumber, ProtoWriter writer)
		{
			if (fieldNumber <= 0)
			{
				throw new ArgumentOutOfRangeException("fieldNumber");
			}
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			writer.packedFieldNumber = fieldNumber;
		}

		internal string SerializeType(Type type)
		{
			return TypeModel.SerializeType(model, type);
		}

		public void SetRootObject(object value)
		{
			NetCache.SetKeyedObject(0, value);
		}

		public static void WriteType(Type value, ProtoWriter writer)
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			WriteString(writer.SerializeType(value), writer);
		}
	}
	public sealed class SerializationContext
	{
		private bool frozen;

		private object context;

		private static readonly SerializationContext @default;

		private StreamingContextStates state = StreamingContextStates.Persistence;

		public object Context
		{
			get
			{
				return context;
			}
			set
			{
				if (context != value)
				{
					ThrowIfFrozen();
					context = value;
				}
			}
		}

		internal static SerializationContext Default => @default;

		public StreamingContextStates State
		{
			get
			{
				return state;
			}
			set
			{
				if (state != value)
				{
					ThrowIfFrozen();
					state = value;
				}
			}
		}

		internal void Freeze()
		{
			frozen = true;
		}

		private void ThrowIfFrozen()
		{
			if (frozen)
			{
				throw new InvalidOperationException("The serialization-context cannot be changed once it is in use");
			}
		}

		static SerializationContext()
		{
			@default = new SerializationContext();
			@default.Freeze();
		}

		public static implicit operator StreamingContext(SerializationContext ctx)
		{
			if (ctx == null)
			{
				return new StreamingContext(StreamingContextStates.Persistence);
			}
			return new StreamingContext(ctx.state, ctx.context);
		}

		public static implicit operator SerializationContext(StreamingContext ctx)
		{
			SerializationContext serializationContext = new SerializationContext();
			serializationContext.Context = ctx.Context;
			serializationContext.State = ctx.State;
			return serializationContext;
		}
	}
	public static class Serializer
	{
		public static class NonGeneric
		{
			public static object DeepClone(object instance)
			{
				if (instance != null)
				{
					return RuntimeTypeModel.Default.DeepClone(instance);
				}
				return null;
			}

			public static void Serialize(Stream dest, object instance)
			{
				if (instance != null)
				{
					RuntimeTypeModel.Default.Serialize(dest, instance);
				}
			}

			public static object Deserialize(Type type, Stream source)
			{
				return RuntimeTypeModel.Default.Deserialize(source, null, type);
			}

			public static object Merge(Stream source, object instance)
			{
				if (instance == null)
				{
					throw new ArgumentNullException("instance");
				}
				return RuntimeTypeModel.Default.Deserialize(source, instance, instance.GetType(), null);
			}

			public static void SerializeWithLengthPrefix(Stream destination, object instance, PrefixStyle style, int fieldNumber)
			{
				if (instance == null)
				{
					throw new ArgumentNullException("instance");
				}
				RuntimeTypeModel runtimeTypeModel = RuntimeTypeModel.Default;
				runtimeTypeModel.SerializeWithLengthPrefix(destination, instance, runtimeTypeModel.MapType(instance.GetType()), style, fieldNumber);
			}

			public static bool TryDeserializeWithLengthPrefix(Stream source, PrefixStyle style, TypeResolver resolver, out object value)
			{
				value = RuntimeTypeModel.Default.DeserializeWithLengthPrefix(source, null, null, style, 0, resolver);
				return value != null;
			}

			public static bool CanSerialize(Type type)
			{
				return RuntimeTypeModel.Default.IsDefined(type);
			}
		}

		public static class GlobalOptions
		{
			[Obsolete("Please use RuntimeTypeModel.Default.InferTagFromNameDefault instead (or on a per-model basis)", false)]
			public static bool InferTagFromName
			{
				get
				{
					return RuntimeTypeModel.Default.InferTagFromNameDefault;
				}
				set
				{
					RuntimeTypeModel.Default.InferTagFromNameDefault = value;
				}
			}
		}

		public delegate Type TypeResolver(int fieldNumber);

		private const string ProtoBinaryField = "proto";

		public const int ListItemTag = 1;

		public static string GetProto<T>()
		{
			return RuntimeTypeModel.Default.GetSchema(RuntimeTypeModel.Default.MapType(typeof(T)));
		}

		public static T DeepClone<T>(T instance)
		{
			if (instance != null)
			{
				return (T)RuntimeTypeModel.Default.DeepClone(instance);
			}
			return instance;
		}

		public static T Merge<T>(Stream source, T instance)
		{
			return (T)RuntimeTypeModel.Default.Deserialize(source, instance, typeof(T));
		}

		public static T Deserialize<T>(Stream source)
		{
			return (T)RuntimeTypeModel.Default.Deserialize(source, null, typeof(T));
		}

		public static void Serialize<T>(Stream destination, T instance)
		{
			if (instance != null)
			{
				RuntimeTypeModel.Default.Serialize(destination, instance);
			}
		}

		public static TTo ChangeType<TFrom, TTo>(TFrom instance)
		{
			using MemoryStream memoryStream = new MemoryStream();
			Serialize(memoryStream, instance);
			memoryStream.Position = 0L;
			return Deserialize<TTo>(memoryStream);
		}

		public static void Serialize<T>(SerializationInfo info, T instance) where T : class, ISerializable
		{
			Serialize(info, new StreamingContext(StreamingContextStates.Persistence), instance);
		}

		public static void Serialize<T>(SerializationInfo info, StreamingContext context, T instance) where T : class, ISerializable
		{
			if (info == null)
			{
				throw new ArgumentNullException("info");
			}
			if (instance == null)
			{
				throw new ArgumentNullException("instance");
			}
			if ((object)instance.GetType() != typeof(T))
			{
				throw new ArgumentException("Incorrect type", "instance");
			}
			using MemoryStream memoryStream = new MemoryStream();
			RuntimeTypeModel.Default.Serialize(memoryStream, instance, context);
			info.AddValue("proto", memoryStream.ToArray());
		}

		public static void Serialize<T>(XmlWriter writer, T instance) where T : IXmlSerializable
		{
			if (writer == null)
			{
				throw new ArgumentNullException("writer");
			}
			if (instance == null)
			{
				throw new ArgumentNullException("instance");
			}
			using MemoryStream memoryStream = new MemoryStream();
			Serialize(memoryStream, instance);
			writer.WriteBase64(memoryStream.GetBuffer(), 0, (int)memoryStream.Length);
		}

		public static void Merge<T>(XmlReader reader, T instance) where T : IXmlSerializable
		{
			if (reader == null)
			{
				throw new ArgumentNullException("reader");
			}
			if (instance == null)
			{
				throw new ArgumentNullException("instance");
			}
			byte[] buffer = new byte[4096];
			using MemoryStream memoryStream = new MemoryStream();
			int depth = reader.Depth;
			while (reader.Read() && reader.Depth > depth)
			{
				if (reader.NodeType == XmlNodeType.Text)
				{
					int count;
					while ((count = reader.ReadContentAsBase64(buffer, 0, 4096)) > 0)
					{
						memoryStream.Write(buffer, 0, count);
					}
					if (reader.Depth <= depth)
					{
						break;
					}
				}
			}
			memoryStream.Position = 0L;
			Merge(memoryStream, instance);
		}

		public static void Merge<T>(SerializationInfo info, T instance) where T : class, ISerializable
		{
			Merge(info, new StreamingContext(StreamingContextStates.Persistence), instance);
		}

		public static void Merge<T>(SerializationInfo info, StreamingContext context, T instance) where T : class, ISerializable
		{
			if (info == null)
			{
				throw new ArgumentNullException("info");
			}
			if (instance == null)
			{
				throw new ArgumentNullException("instance");
			}
			if ((object)instance.GetType() != typeof(T))
			{
				throw new ArgumentException("Incorrect type", "instance");
			}
			byte[] buffer = (byte[])info.GetValue("proto", typeof(byte[]));
			using MemoryStream source = new MemoryStream(buffer);
			T objA = (T)RuntimeTypeModel.Default.Deserialize(source, instance, typeof(T), context);
			if (!object.ReferenceEquals(objA, instance))
			{
				throw new ProtoException("Deserialization changed the instance; cannot succeed.");
			}
		}

		public static void PrepareSerializer<T>()
		{
			RuntimeTypeModel runtimeTypeModel = RuntimeTypeModel.Default;
			runtimeTypeModel[runtimeTypeModel.MapType(typeof(T))].CompileInPlace();
		}

		public static IFormatter CreateFormatter<T>()
		{
			return RuntimeTypeModel.Default.CreateFormatter(typeof(T));
		}

		public static IEnumerable<T> DeserializeItems<T>(Stream source, PrefixStyle style, int fieldNumber)
		{
			return RuntimeTypeModel.Default.DeserializeItems<T>(source, style, fieldNumber);
		}

		public static T DeserializeWithLengthPrefix<T>(Stream source, PrefixStyle style)
		{
			return DeserializeWithLengthPrefix<T>(source, style, 0);
		}

		public static T DeserializeWithLengthPrefix<T>(Stream source, PrefixStyle style, int fieldNumber)
		{
			RuntimeTypeModel runtimeTypeModel = RuntimeTypeModel.Default;
			return (T)runtimeTypeModel.DeserializeWithLengthPrefix(source, null, runtimeTypeModel.MapType(typeof(T)), style, fieldNumber);
		}

		public static T MergeWithLengthPrefix<T>(Stream source, T instance, PrefixStyle style)
		{
			RuntimeTypeModel runtimeTypeModel = RuntimeTypeModel.Default;
			return (T)runtimeTypeModel.DeserializeWithLengthPrefix(source, instance, runtimeTypeModel.MapType(typeof(T)), style, 0);
		}

		public static void SerializeWithLengthPrefix<T>(Stream destination, T instance, PrefixStyle style)
		{
			SerializeWithLengthPrefix(destination, instance, style, 0);
		}

		public static void SerializeWithLengthPrefix<T>(Stream destination, T instance, PrefixStyle style, int fieldNumber)
		{
			RuntimeTypeModel runtimeTypeModel = RuntimeTypeModel.Default;
			runtimeTypeModel.SerializeWithLengthPrefix(destination, instance, runtimeTypeModel.MapType(typeof(T)), style, fieldNumber);
		}

		public static bool TryReadLengthPrefix(Stream source, PrefixStyle style, out int length)
		{
			length = ProtoReader.ReadLengthPrefix(source, expectHeader: false, style, out var _, out var bytesRead);
			return bytesRead > 0;
		}

		public static bool TryReadLengthPrefix(byte[] buffer, int index, int count, PrefixStyle style, out int length)
		{
			using Stream source = new MemoryStream(buffer, index, count);
			return TryReadLengthPrefix(source, style, out length);
		}

		public static void FlushPool()
		{
			BufferPool.Flush();
		}
	}
}
namespace ProtoBuf.Serializers
{
	internal interface IProtoSerializer
	{
		Type ExpectedType { get; }

		bool RequiresOldValue { get; }

		bool ReturnsValue { get; }

		void Write(object value, ProtoWriter dest);

		object Read(object value, ProtoReader source);

		void EmitWrite(CompilerContext ctx, Local valueFrom);

		void EmitRead(CompilerContext ctx, Local entity);
	}
	internal sealed class BlobSerializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(byte[]);

		private readonly bool overwriteList;

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => !overwriteList;

		bool IProtoSerializer.ReturnsValue => true;

		public BlobSerializer(TypeModel model, bool overwriteList)
		{
			this.overwriteList = overwriteList;
		}

		public object Read(object value, ProtoReader source)
		{
			return ProtoReader.AppendBytes(overwriteList ? null : ((byte[])value), source);
		}

		public void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteBytes((byte[])value, dest);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicWrite("WriteBytes", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			if (overwriteList)
			{
				ctx.LoadNullRef();
			}
			else
			{
				ctx.LoadValue(valueFrom);
			}
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("AppendBytes"));
		}
	}
	internal class UInt16Serializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(ushort);

		public virtual Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public UInt16Serializer(TypeModel model)
		{
		}

		public virtual object Read(object value, ProtoReader source)
		{
			return source.ReadUInt16();
		}

		public virtual void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteUInt16((ushort)value, dest);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicWrite("WriteUInt16", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead("ReadUInt16", ctx.MapType(typeof(ushort)));
		}
	}
	internal sealed class CharSerializer : UInt16Serializer
	{
		private static readonly Type expectedType = typeof(char);

		public override Type ExpectedType => expectedType;

		public CharSerializer(TypeModel model)
			: base(model)
		{
		}

		public override void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteUInt16((char)value, dest);
		}

		public override object Read(object value, ProtoReader source)
		{
			return (char)source.ReadUInt16();
		}
	}
	internal interface IProtoTypeSerializer : IProtoSerializer
	{
		bool HasCallbacks(TypeModel.CallbackType callbackType);

		bool CanCreateInstance();

		object CreateInstance(ProtoReader source);

		void Callback(object value, TypeModel.CallbackType callbackType, SerializationContext context);

		void EmitCallback(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType);

		void EmitCreateInstance(CompilerContext ctx);
	}
	internal sealed class CompiledSerializer : IProtoTypeSerializer, IProtoSerializer
	{
		private readonly IProtoTypeSerializer head;

		private readonly ProtoSerializer serializer;

		private readonly ProtoDeserializer deserializer;

		bool IProtoSerializer.RequiresOldValue => head.RequiresOldValue;

		bool IProtoSerializer.ReturnsValue => head.ReturnsValue;

		Type IProtoSerializer.ExpectedType => head.ExpectedType;

		bool IProtoTypeSerializer.HasCallbacks(TypeModel.CallbackType callbackType)
		{
			return head.HasCallbacks(callbackType);
		}

		bool IProtoTypeSerializer.CanCreateInstance()
		{
			return head.CanCreateInstance();
		}

		object IProtoTypeSerializer.CreateInstance(ProtoReader source)
		{
			return head.CreateInstance(source);
		}

		public void Callback(object value, TypeModel.CallbackType callbackType, SerializationContext context)
		{
			head.Callback(value, callbackType, context);
		}

		public static CompiledSerializer Wrap(IProtoTypeSerializer head, TypeModel model)
		{
			CompiledSerializer compiledSerializer = head as CompiledSerializer;
			if (compiledSerializer == null)
			{
				compiledSerializer = new CompiledSerializer(head, model);
			}
			return compiledSerializer;
		}

		private CompiledSerializer(IProtoTypeSerializer head, TypeModel model)
		{
			this.head = head;
			serializer = CompilerContext.BuildSerializer(head, model);
			deserializer = CompilerContext.BuildDeserializer(head, model);
		}

		void IProtoSerializer.Write(object value, ProtoWriter dest)
		{
			serializer(value, dest);
		}

		object IProtoSerializer.Read(object value, ProtoReader source)
		{
			return deserializer(value, source);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			head.EmitWrite(ctx, valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			head.EmitRead(ctx, valueFrom);
		}

		void IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType)
		{
			head.EmitCallback(ctx, valueFrom, callbackType);
		}

		void IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
		{
			head.EmitCreateInstance(ctx);
		}
	}
	internal sealed class BooleanSerializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(bool);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public BooleanSerializer(TypeModel model)
		{
		}

		public void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteBoolean((bool)value, dest);
		}

		public object Read(object value, ProtoReader source)
		{
			return source.ReadBoolean();
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicWrite("WriteBoolean", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead("ReadBoolean", ExpectedType);
		}
	}
	internal abstract class ProtoDecoratorBase : IProtoSerializer
	{
		protected readonly IProtoSerializer Tail;

		public abstract Type ExpectedType { get; }

		public abstract bool ReturnsValue { get; }

		public abstract bool RequiresOldValue { get; }

		protected ProtoDecoratorBase(IProtoSerializer tail)
		{
			Tail = tail;
		}

		public abstract void Write(object value, ProtoWriter dest);

		public abstract object Read(object value, ProtoReader source);

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			EmitWrite(ctx, valueFrom);
		}

		protected abstract void EmitWrite(CompilerContext ctx, Local valueFrom);

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			EmitRead(ctx, valueFrom);
		}

		protected abstract void EmitRead(CompilerContext ctx, Local valueFrom);
	}
	internal sealed class ArrayDecorator : ProtoDecoratorBase
	{
		private const byte OPTIONS_WritePacked = 1;

		private const byte OPTIONS_OverwriteList = 2;

		private const byte OPTIONS_SupportNull = 4;

		private readonly int fieldNumber;

		private readonly byte options;

		private readonly WireType packedWireType;

		private readonly Type arrayType;

		private readonly Type itemType;

		public override Type ExpectedType => arrayType;

		public override bool RequiresOldValue => AppendToCollection;

		public override bool ReturnsValue => true;

		private bool AppendToCollection => (options & 2) == 0;

		private bool SupportNull => (options & 4) != 0;

		public ArrayDecorator(TypeModel model, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, Type arrayType, bool overwriteList, bool supportNull)
			: base(tail)
		{
			itemType = arrayType.GetElementType();
			if (!supportNull)
			{
				Helpers.GetUnderlyingType(itemType);
			}
			if ((writePacked || packedWireType != WireType.None) && fieldNumber <= 0)
			{
				throw new ArgumentOutOfRangeException("fieldNumber");
			}
			if (!ListDecorator.CanPack(packedWireType))
			{
				if (writePacked)
				{
					throw new InvalidOperationException("Only simple data-types can use packed encoding");
				}
				packedWireType = WireType.None;
			}
			this.fieldNumber = fieldNumber;
			this.packedWireType = packedWireType;
			if (writePacked)
			{
				options |= 1;
			}
			if (overwriteList)
			{
				options |= 2;
			}
			if (supportNull)
			{
				options |= 4;
			}
			this.arrayType = arrayType;
		}

		protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			using Local local = ctx.GetLocalWithValue(arrayType, valueFrom);
			using Local i = new Local(ctx, ctx.MapType(typeof(int)));
			bool flag = (options & 1) != 0;
			using Local local2 = (flag ? new Local(ctx, ctx.MapType(typeof(SubItemToken))) : null);
			Type type = ctx.MapType(typeof(ProtoWriter));
			if (flag)
			{
				ctx.LoadValue(fieldNumber);
				ctx.LoadValue(2);
				ctx.LoadReaderWriter();
				ctx.EmitCall(type.GetMethod("WriteFieldHeader"));
				ctx.LoadValue(local);
				ctx.LoadReaderWriter();
				ctx.EmitCall(type.GetMethod("StartSubItem"));
				ctx.StoreValue(local2);
				ctx.LoadValue(fieldNumber);
				ctx.LoadReaderWriter();
				ctx.EmitCall(type.GetMethod("SetPackedField"));
			}
			EmitWriteArrayLoop(ctx, i, local);
			if (flag)
			{
				ctx.LoadValue(local2);
				ctx.LoadReaderWriter();
				ctx.EmitCall(type.GetMethod("EndSubItem"));
			}
		}

		private void EmitWriteArrayLoop(CompilerContext ctx, Local i, Local arr)
		{
			ctx.LoadValue(0);
			ctx.StoreValue(i);
			CodeLabel label = ctx.DefineLabel();
			CodeLabel label2 = ctx.DefineLabel();
			ctx.Branch(label, @short: false);
			ctx.MarkLabel(label2);
			ctx.LoadArrayValue(arr, i);
			if (SupportNull)
			{
				Tail.EmitWrite(ctx, null);
			}
			else
			{
				ctx.WriteNullCheckedTail(itemType, Tail, null);
			}
			ctx.LoadValue(i);
			ctx.LoadValue(1);
			ctx.Add();
			ctx.StoreValue(i);
			ctx.MarkLabel(label);
			ctx.LoadValue(i);
			ctx.LoadLength(arr, zeroIfNull: false);
			ctx.BranchIfLess(label2, @short: false);
		}

		public override void Write(object value, ProtoWriter dest)
		{
			IList list = (IList)value;
			int count = list.Count;
			bool flag = (options & 1) != 0;
			SubItemToken token;
			if (flag)
			{
				ProtoWriter.WriteFieldHeader(fieldNumber, WireType.String, dest);
				token = ProtoWriter.StartSubItem(value, dest);
				ProtoWriter.SetPackedField(fieldNumber, dest);
			}
			else
			{
				token = default(SubItemToken);
			}
			bool flag2 = !SupportNull;
			for (int i = 0; i < count; i++)
			{
				object obj = list[i];
				if (flag2 && obj == null)
				{
					throw new NullReferenceException();
				}
				Tail.Write(obj, dest);
			}
			if (flag)
			{
				ProtoWriter.EndSubItem(token, dest);
			}
		}

		public override object Read(object value, ProtoReader source)
		{
			int field = source.FieldNumber;
			BasicList basicList = new BasicList();
			if (packedWireType != WireType.None && source.WireType == WireType.String)
			{
				SubItemToken token = ProtoReader.StartSubItem(source);
				while (ProtoReader.HasSubValue(packedWireType, source))
				{
					basicList.Add(Tail.Read(null, source));
				}
				ProtoReader.EndSubItem(token, source);
			}
			else
			{
				do
				{
					basicList.Add(Tail.Read(null, source));
				}
				while (source.TryReadFieldHeader(field));
			}
			int num = (AppendToCollection ? ((value != null) ? ((Array)value).Length : 0) : 0);
			Array array = Array.CreateInstance(itemType, num + basicList.Count);
			if (num != 0)
			{
				((Array)value).CopyTo(array, 0);
			}
			basicList.CopyTo(array, num);
			return array;
		}

		protected override void EmitRead(CompilerContext ctx, Local valueFrom)
		{
			Type type = ctx.MapType(typeof(List<>)).MakeGenericType(itemType);
			Type expectedType = ExpectedType;
			using Local local = (AppendToCollection ? ctx.GetLocalWithValue(expectedType, valueFrom) : null);
			using Local local2 = new Local(ctx, expectedType);
			using Local local3 = new Local(ctx, type);
			ctx.EmitCtor(type);
			ctx.StoreValue(local3);
			ListDecorator.EmitReadList(ctx, local3, Tail, type.GetMethod("Add"), packedWireType, castListForAdd: false);
			using (Local local4 = (AppendToCollection ? new Local(ctx, ctx.MapType(typeof(int))) : null))
			{
				Type[] array = new Type[2]
				{
					ctx.MapType(typeof(Array)),
					ctx.MapType(typeof(int))
				};
				if (AppendToCollection)
				{
					ctx.LoadLength(local, zeroIfNull: true);
					ctx.CopyValue();
					ctx.StoreValue(local4);
					ctx.LoadAddress(local3, type);
					ctx.LoadValue(type.GetProperty("Count"));
					ctx.Add();
					ctx.CreateArray(itemType, null);
					ctx.StoreValue(local2);
					ctx.LoadValue(local4);
					CodeLabel label = ctx.DefineLabel();
					ctx.BranchIfFalse(label, @short: true);
					ctx.LoadValue(local);
					ctx.LoadValue(local2);
					ctx.LoadValue(0);
					ctx.EmitCall(expectedType.GetMethod("CopyTo", array));
					ctx.MarkLabel(label);
					ctx.LoadValue(local3);
					ctx.LoadValue(local2);
					ctx.LoadValue(local4);
				}
				else
				{
					ctx.LoadAddress(local3, type);
					ctx.LoadValue(type.GetProperty("Count"));
					ctx.CreateArray(itemType, null);
					ctx.StoreValue(local2);
					ctx.LoadAddress(local3, type);
					ctx.LoadValue(local2);
					ctx.LoadValue(0);
				}
				array[0] = expectedType;
				MethodInfo method = type.GetMethod("CopyTo", array);
				if ((object)method == null)
				{
					array[1] = ctx.MapType(typeof(Array));
					method = type.GetMethod("CopyTo", array);
				}
				ctx.EmitCall(method);
			}
			ctx.LoadValue(local2);
		}
	}
	internal sealed class ByteSerializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(byte);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public ByteSerializer(TypeModel model)
		{
		}

		public void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteByte((byte)value, dest);
		}

		public object Read(object value, ProtoReader source)
		{
			return source.ReadByte();
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicWrite("WriteByte", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead("ReadByte", ExpectedType);
		}
	}
	internal class ListDecorator : ProtoDecoratorBase
	{
		private const byte OPTIONS_IsList = 1;

		private const byte OPTIONS_SuppressIList = 2;

		private const byte OPTIONS_WritePacked = 4;

		private const byte OPTIONS_ReturnList = 8;

		private const byte OPTIONS_OverwriteList = 16;

		private const byte OPTIONS_SupportNull = 32;

		private readonly byte options;

		private readonly Type declaredType;

		private readonly Type concreteType;

		private readonly MethodInfo add;

		private readonly int fieldNumber;

		protected readonly WireType packedWireType;

		private static readonly Type ienumeratorType = typeof(IEnumerator);

		private static readonly Type ienumerableType = typeof(IEnumerable);

		private bool IsList => (options & 1) != 0;

		private bool SuppressIList => (options & 2) != 0;

		private bool WritePacked => (options & 4) != 0;

		private bool SupportNull => (options & 0x20) != 0;

		private bool ReturnList => (options & 8) != 0;

		protected virtual bool RequireAdd => true;

		public override Type ExpectedType => declaredType;

		public override bool RequiresOldValue => AppendToCollection;

		public override bool ReturnsValue => ReturnList;

		protected bool AppendToCollection => (options & 0x10) == 0;

		internal static bool CanPack(WireType wireType)
		{
			switch (wireType)
			{
			case WireType.Variant:
			case WireType.Fixed64:
			case WireType.Fixed32:
			case WireType.SignedVariant:
				return true;
			default:
				return false;
			}
		}

		internal static ListDecorator Create(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull)
		{
			if (returnList && ImmutableCollectionDecorator.IdentifyImmutable(model, declaredType, out var builderFactory, out var methodInfo, out var addRange, out var finish))
			{
				return new ImmutableCollectionDecorator(model, declaredType, concreteType, tail, fieldNumber, writePacked, packedWireType, returnList, overwriteList, supportNull, builderFactory, methodInfo, addRange, finish);
			}
			return new ListDecorator(model, declaredType, concreteType, tail, fieldNumber, writePacked, packedWireType, returnList, overwriteList, supportNull);
		}

		protected ListDecorator(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull)
			: base(tail)
		{
			if (returnList)
			{
				options |= 8;
			}
			if (overwriteList)
			{
				options |= 16;
			}
			if (supportNull)
			{
				options |= 32;
			}
			if ((writePacked || packedWireType != WireType.None) && fieldNumber <= 0)
			{
				throw new ArgumentOutOfRangeException("fieldNumber");
			}
			if (!CanPack(packedWireType))
			{
				if (writePacked)
				{
					throw new InvalidOperationException("Only simple data-types can use packed encoding");
				}
				packedWireType = WireType.None;
			}
			this.fieldNumber = fieldNumber;
			if (writePacked)
			{
				options |= 4;
			}
			this.packedWireType = packedWireType;
			if ((object)declaredType == null)
			{
				throw new ArgumentNullException("declaredType");
			}
			if (declaredType.IsArray)
			{
				throw new ArgumentException("Cannot treat arrays as lists", "declaredType");
			}
			this.declaredType = declaredType;
			this.concreteType = concreteType;
			if (!RequireAdd)
			{
				return;
			}
			add = TypeModel.ResolveListAdd(model, declaredType, tail.ExpectedType, out var isList);
			if (isList)
			{
				options |= 1;
				string fullName = declaredType.FullName;
				if (fullName != null && fullName.StartsWith("System.Data.Linq.EntitySet`1[["))
				{
					options |= 2;
				}
			}
			if ((object)add == null)
			{
				throw new InvalidOperationException("Unable to resolve a suitable Add method for " + declaredType.FullName);
			}
		}

		protected override void EmitRead(CompilerContext ctx, Local valueFrom)
		{
			bool returnList = ReturnList;
			using Local local = (AppendToCollection ? ctx.GetLocalWithValue(ExpectedType, valueFrom) : new Local(ctx, declaredType));
			using Local local2 = ((returnList && AppendToCollection) ? new Local(ctx, ExpectedType) : null);
			if (!AppendToCollection)
			{
				ctx.LoadNullRef();
				ctx.StoreValue(local);
			}
			else if (returnList)
			{
				ctx.LoadValue(local);
				ctx.StoreValue(local2);
			}
			if ((object)concreteType != null)
			{
				ctx.LoadValue(local);
				CodeLabel label = ctx.DefineLabel();
				ctx.BranchIfTrue(label, @short: true);
				ctx.EmitCtor(concreteType);
				ctx.StoreValue(local);
				ctx.MarkLabel(label);
			}
			bool castListForAdd = !add.DeclaringType.IsAssignableFrom(declaredType);
			EmitReadList(ctx, local, Tail, add, packedWireType, castListForAdd);
			if (returnList)
			{
				if (AppendToCollection)
				{
					ctx.LoadValue(local2);
					ctx.LoadValue(local);
					CodeLabel label2 = ctx.DefineLabel();
					CodeLabel label3 = ctx.DefineLabel();
					ctx.BranchIfEqual(label2, @short: true);
					ctx.LoadValue(local);
					ctx.Branch(label3, @short: true);
					ctx.MarkLabel(label2);
					ctx.LoadNullRef();
					ctx.MarkLabel(label3);
				}
				else
				{
					ctx.LoadValue(local);
				}
			}
		}

		internal static void EmitReadList(CompilerContext ctx, Local list, IProtoSerializer tail, MethodInfo add, WireType packedWireType, bool castListForAdd)
		{
			using Local local = new Local(ctx, ctx.MapType(typeof(int)));
			CodeLabel label = ((packedWireType == WireType.None) ? default(CodeLabel) : ctx.DefineLabel());
			if (packedWireType != WireType.None)
			{
				ctx.LoadReaderWriter();
				ctx.LoadValue(typeof(ProtoReader).GetProperty("WireType"));
				ctx.LoadValue(2);
				ctx.BranchIfEqual(label, @short: false);
			}
			ctx.LoadReaderWriter();
			ctx.LoadValue(typeof(ProtoReader).GetProperty("FieldNumber"));
			ctx.StoreValue(local);
			CodeLabel label2 = ctx.DefineLabel();
			ctx.MarkLabel(label2);
			EmitReadAndAddItem(ctx, list, tail, add, castListForAdd);
			ctx.LoadReaderWriter();
			ctx.LoadValue(local);
			ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("TryReadFieldHeader"));
			ctx.BranchIfTrue(label2, @short: false);
			if (packedWireType != WireType.None)
			{
				CodeLabel label3 = ctx.DefineLabel();
				ctx.Branch(label3, @short: false);
				ctx.MarkLabel(label);
				ctx.LoadReaderWriter();
				ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("StartSubItem"));
				CodeLabel label4 = ctx.DefineLabel();
				CodeLabel label5 = ctx.DefineLabel();
				ctx.MarkLabel(label4);
				ctx.LoadValue((int)packedWireType);
				ctx.LoadReaderWriter();
				ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("HasSubValue"));
				ctx.BranchIfFalse(label5, @short: false);
				EmitReadAndAddItem(ctx, list, tail, add, castListForAdd);
				ctx.Branch(label4, @short: false);
				ctx.MarkLabel(label5);
				ctx.LoadReaderWriter();
				ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("EndSubItem"));
				ctx.MarkLabel(label3);
			}
		}

		private static void EmitReadAndAddItem(CompilerContext ctx, Local list, IProtoSerializer tail, MethodInfo add, bool castListForAdd)
		{
			ctx.LoadAddress(list, list.Type);
			if (castListForAdd)
			{
				ctx.Cast(add.DeclaringType);
			}
			Type expectedType = tail.ExpectedType;
			bool returnsValue = tail.ReturnsValue;
			if (tail.RequiresOldValue)
			{
				if (expectedType.IsValueType || !returnsValue)
				{
					using Local local = new Local(ctx, expectedType);
					if (expectedType.IsValueType)
					{
						ctx.LoadAddress(local, expectedType);
						ctx.EmitCtor(expectedType);
					}
					else
					{
						ctx.LoadNullRef();
						ctx.StoreValue(local);
					}
					tail.EmitRead(ctx, local);
					if (!returnsValue)
					{
						ctx.LoadValue(local);
					}
				}
				else
				{
					ctx.LoadNullRef();
					tail.EmitRead(ctx, null);
				}
			}
			else
			{
				if (!returnsValue)
				{
					throw new InvalidOperationException();
				}
				tail.EmitRead(ctx, null);
			}
			Type parameterType = add.GetParameters()[0].ParameterType;
			if ((object)parameterType != expectedType)
			{
				if ((object)parameterType == ctx.MapType(typeof(object)))
				{
					ctx.CastToObject(expectedType);
				}
				else
				{
					if ((object)Helpers.GetUnderlyingType(parameterType) != expectedType)
					{
						throw new InvalidOperationException("Conflicting item/add type");
					}
					ConstructorInfo constructor = Helpers.GetConstructor(parameterType, new Type[1] { expectedType }, nonPublic: false);
					ctx.EmitCtor(constructor);
				}
			}
			ctx.EmitCall(add);
			if ((object)add.ReturnType != ctx.MapType(typeof(void)))
			{
				ctx.DiscardValue();
			}
		}

		protected MethodInfo GetEnumeratorInfo(TypeModel model, out MethodInfo moveNext, out MethodInfo current)
		{
			Type type = null;
			Type expectedType = ExpectedType;
			MethodInfo instanceMethod = Helpers.GetInstanceMethod(expectedType, "GetEnumerator", null);
			Type expectedType2 = Tail.ExpectedType;
			Type type2 = null;
			Type type3;
			if ((object)instanceMethod != null)
			{
				type2 = instanceMethod.ReturnType;
				type3 = type2;
				moveNext = Helpers.GetInstanceMethod(type3, "MoveNext", null);
				PropertyInfo property = Helpers.GetProperty(type3, "Current", nonPublic: false);
				current = (((object)property == null) ? null : Helpers.GetGetMethod(property, nonPublic: false, allowInternal: false));
				if ((object)moveNext == null && model.MapType(ienumeratorType).IsAssignableFrom(type3))
				{
					moveNext = Helpers.GetInstanceMethod(model.MapType(ienumeratorType), "MoveNext", null);
				}
				if ((object)moveNext != null && (object)moveNext.ReturnType == model.MapType(typeof(bool)) && (object)current != null && (object)current.ReturnType == expectedType2)
				{
					return instanceMethod;
				}
				moveNext = (current = (instanceMethod = null));
			}
			Type type4 = model.MapType(typeof(IEnumerable<>), demand: false);
			if ((object)type4 != null)
			{
				type4 = type4.MakeGenericType(expectedType2);
				type = type4;
			}
			if ((object)type != null && type.IsAssignableFrom(expectedType))
			{
				instanceMethod = Helpers.GetInstanceMethod(type, "GetEnumerator");
				type2 = instanceMethod.ReturnType;
				type3 = type2;
				moveNext = Helpers.GetInstanceMethod(model.MapType(ienumeratorType), "MoveNext");
				current = Helpers.GetGetMethod(Helpers.GetProperty(type3, "Current", nonPublic: false), nonPublic: false, allowInternal: false);
				return instanceMethod;
			}
			type = model.MapType(ienumerableType);
			instanceMethod = Helpers.GetInstanceMethod(type, "GetEnumerator");
			type2 = instanceMethod.ReturnType;
			type3 = type2;
			moveNext = Helpers.GetInstanceMethod(type3, "MoveNext");
			current = Helpers.GetGetMethod(Helpers.GetProperty(type3, "Current", nonPublic: false), nonPublic: false, allowInternal: false);
			return instanceMethod;
		}

		protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			using Local local = ctx.GetLocalWithValue(ExpectedType, valueFrom);
			MethodInfo moveNext;
			MethodInfo current;
			MethodInfo enumeratorInfo = GetEnumeratorInfo(ctx.Model, out moveNext, out current);
			Type returnType = enumeratorInfo.ReturnType;
			bool writePacked = WritePacked;
			using Local local2 = new Local(ctx, returnType);
			using Local local3 = (writePacked ? new Local(ctx, ctx.MapType(typeof(SubItemToken))) : null);
			if (writePacked)
			{
				ctx.LoadValue(fieldNumber);
				ctx.LoadValue(2);
				ctx.LoadReaderWriter();
				ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("WriteFieldHeader"));
				ctx.LoadValue(local);
				ctx.LoadReaderWriter();
				ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("StartSubItem"));
				ctx.StoreValue(local3);
				ctx.LoadValue(fieldNumber);
				ctx.LoadReaderWriter();
				ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("SetPackedField"));
			}
			ctx.LoadAddress(local, ExpectedType);
			ctx.EmitCall(enumeratorInfo);
			ctx.StoreValue(local2);
			using (ctx.Using(local2))
			{
				CodeLabel label = ctx.DefineLabel();
				CodeLabel label2 = ctx.DefineLabel();
				ctx.Branch(label2, @short: false);
				ctx.MarkLabel(label);
				ctx.LoadAddress(local2, returnType);
				ctx.EmitCall(current);
				Type expectedType = Tail.ExpectedType;
				if ((object)expectedType != ctx.MapType(typeof(object)) && (object)current.ReturnType == ctx.MapType(typeof(object)))
				{
					ctx.CastFromObject(expectedType);
				}
				Tail.EmitWrite(ctx, null);
				ctx.MarkLabel(label2);
				ctx.LoadAddress(local2, returnType);
				ctx.EmitCall(moveNext);
				ctx.BranchIfTrue(label, @short: false);
			}
			if (writePacked)
			{
				ctx.LoadValue(local3);
				ctx.LoadReaderWriter();
				ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("EndSubItem"));
			}
		}

		public override void Write(object value, ProtoWriter dest)
		{
			bool writePacked = WritePacked;
			SubItemToken token;
			if (writePacked)
			{
				ProtoWriter.WriteFieldHeader(fieldNumber, WireType.String, dest);
				token = ProtoWriter.StartSubItem(value, dest);
				ProtoWriter.SetPackedField(fieldNumber, dest);
			}
			else
			{
				token = default(SubItemToken);
			}
			bool flag = !SupportNull;
			foreach (object item in (IEnumerable)value)
			{
				if (flag && item == null)
				{
					throw new NullReferenceException();
				}
				Tail.Write(item, dest);
			}
			if (writePacked)
			{
				ProtoWriter.EndSubItem(token, dest);
			}
		}

		public override object Read(object value, ProtoReader source)
		{
			int field = source.FieldNumber;
			object obj = value;
			if (value == null)
			{
				value = Activator.CreateInstance(concreteType);
			}
			bool flag = IsList && !SuppressIList;
			if (packedWireType != WireType.None && source.WireType == WireType.String)
			{
				SubItemToken token = ProtoReader.StartSubItem(source);
				if (flag)
				{
					IList list = (IList)value;
					while (ProtoReader.HasSubValue(packedWireType, source))
					{
						list.Add(Tail.Read(null, source));
					}
				}
				else
				{
					object[] array = new object[1];
					while (ProtoReader.HasSubValue(packedWireType, source))
					{
						array[0] = Tail.Read(null, source);
						add.Invoke(value, array);
					}
				}
				ProtoReader.EndSubItem(token, source);
			}
			else if (flag)
			{
				IList list2 = (IList)value;
				do
				{
					list2.Add(Tail.Read(null, source));
				}
				while (source.TryReadFieldHeader(field));
			}
			else
			{
				object[] array2 = new object[1];
				do
				{
					array2[0] = Tail.Read(null, source);
					add.Invoke(value, array2);
				}
				while (source.TryReadFieldHeader(field));
			}
			if (obj != value)
			{
				return value;
			}
			return null;
		}
	}
	internal sealed class ImmutableCollectionDecorator : ListDecorator
	{
		private readonly MethodInfo builderFactory;

		private readonly MethodInfo add;

		private readonly MethodInfo addRange;

		private readonly MethodInfo finish;

		protected override bool RequireAdd => false;

		private static Type ResolveIReadOnlyCollection(Type declaredType, Type t)
		{
			Type[] interfaces = declaredType.GetInterfaces();
			foreach (Type type in interfaces)
			{
				if (!type.IsGenericType || !type.Name.StartsWith("IReadOnlyCollection`"))
				{
					continue;
				}
				if ((object)t != null)
				{
					Type[] genericArguments = type.GetGenericArguments();
					if (genericArguments.Length != 1 && (object)genericArguments[0] != t)
					{
						continue;
					}
				}
				return type;
			}
			return null;
		}

		internal static bool IdentifyImmutable(TypeModel model, Type declaredType, out MethodInfo builderFactory, out MethodInfo add, out MethodInfo addRange, out MethodInfo finish)
		{
			builderFactory = (add = (addRange = (finish = null)));
			if (model == null || (object)declaredType == null)
			{
				return false;
			}
			if (!declaredType.IsGenericType)
			{
				return false;
			}
			Type[] genericArguments = declaredType.GetGenericArguments();
			Type[] array;
			switch (genericArguments.Length)
			{
			case 1:
				array = genericArguments;
				break;
			case 2:
			{
				Type type = model.MapType(typeof(KeyValuePair<, >));
				if ((object)type == null)
				{
					return false;
				}
				type = type.MakeGenericType(genericArguments);
				array = new Type[1] { type };
				break;
			}
			default:
				return false;
			}
			if ((object)ResolveIReadOnlyCollection(declaredType, null) == null)
			{
				return false;
			}
			string name = declaredType.Name;
			int num = name.IndexOf('`');
			if (num <= 0)
			{
				return false;
			}
			name = (declaredType.IsInterface ? name.Substring(1, num - 1) : name.Substring(0, num));
			Type type2 = model.GetType(declaredType.Namespace + "." + name, declaredType.Assembly);
			if ((object)type2 == null && name == "ImmutableSet")
			{
				type2 = model.GetType(declaredType.Namespace + ".ImmutableHashSet", declaredType.Assembly);
			}
			if ((object)type2 == null)
			{
				return false;
			}
			MethodInfo[] methods = type2.GetMethods();
			foreach (MethodInfo methodInfo in methods)
			{
				if (methodInfo.IsStatic && !(methodInfo.Name != "CreateBuilder") && methodInfo.IsGenericMethodDefinition && methodInfo.GetParameters().Length == 0 && methodInfo.GetGenericArguments().Length == genericArguments.Length)
				{
					builderFactory = methodInfo.MakeGenericMethod(genericArguments);
					break;
				}
			}
			Type type3 = model.MapType(typeof(void));
			if ((object)builderFactory == null || (object)builderFactory.ReturnType == null || (object)builderFactory.ReturnType == type3)
			{
				return false;
			}
			add = Helpers.GetInstanceMethod(builderFactory.ReturnType, "Add", array);
			if ((object)add == null)
			{
				return false;
			}
			finish = Helpers.GetInstanceMethod(builderFactory.ReturnType, "ToImmutable", Helpers.EmptyTypes);
			if ((object)finish == null || (object)finish.ReturnType == null || (object)finish.ReturnType == type3)
			{
				return false;
			}
			if ((object)finish.ReturnType != declaredType && !Helpers.IsAssignableFrom(declaredType, finish.ReturnType))
			{
				return false;
			}
			addRange = Helpers.GetInstanceMethod(builderFactory.ReturnType, "AddRange", new Type[1] { declaredType });
			if ((object)addRange == null)
			{
				Type type4 = model.MapType(typeof(IEnumerable<>), demand: false);
				if ((object)type4 != null)
				{
					addRange = Helpers.GetInstanceMethod(builderFactory.ReturnType, "AddRange", new Type[1] { type4.MakeGenericType(array) });
				}
			}
			return true;
		}

		internal ImmutableCollectionDecorator(TypeModel model, Type declaredType, Type concreteType, IProtoSerializer tail, int fieldNumber, bool writePacked, WireType packedWireType, bool returnList, bool overwriteList, bool supportNull, MethodInfo builderFactory, MethodInfo add, MethodInfo addRange, MethodInfo finish)
			: base(model, declaredType, concreteType, tail, fieldNumber, writePacked, packedWireType, returnList, overwriteList, supportNull)
		{
			this.builderFactory = builderFactory;
			this.add = add;
			this.addRange = addRange;
			this.finish = finish;
		}

		public override object Read(object value, ProtoReader source)
		{
			object obj = builderFactory.Invoke(null, null);
			int field = source.FieldNumber;
			object[] array = new object[1];
			if (base.AppendToCollection && value != null && ((IList)value).Count != 0)
			{
				if ((object)addRange != null)
				{
					array[0] = value;
					addRange.Invoke(obj, array);
				}
				else
				{
					foreach (object item in (IList)value)
					{
						array[0] = item;
						add.Invoke(obj, array);
					}
				}
			}
			if (packedWireType != WireType.None && source.WireType == WireType.String)
			{
				SubItemToken token = ProtoReader.StartSubItem(source);
				while (ProtoReader.HasSubValue(packedWireType, source))
				{
					array[0] = Tail.Read(null, source);
					add.Invoke(obj, array);
				}
				ProtoReader.EndSubItem(token, source);
			}
			else
			{
				do
				{
					array[0] = Tail.Read(null, source);
					add.Invoke(obj, array);
				}
				while (source.TryReadFieldHeader(field));
			}
			return finish.Invoke(obj, null);
		}

		protected override void EmitRead(CompilerContext ctx, Local valueFrom)
		{
			using Local local = (base.AppendToCollection ? ctx.GetLocalWithValue(ExpectedType, valueFrom) : null);
			using Local local2 = new Local(ctx, builderFactory.ReturnType);
			ctx.EmitCall(builderFactory);
			ctx.StoreValue(local2);
			if (base.AppendToCollection)
			{
				CodeLabel label = ctx.DefineLabel();
				if (!ExpectedType.IsValueType)
				{
					ctx.LoadValue(local);
					ctx.BranchIfFalse(label, @short: false);
				}
				PropertyInfo property = Helpers.GetProperty(ExpectedType, "Length", nonPublic: false);
				if ((object)property == null)
				{
					property = Helpers.GetProperty(ExpectedType, "Count", nonPublic: false);
				}
				if ((object)property == null)
				{
					property = Helpers.GetProperty(ResolveIReadOnlyCollection(ExpectedType, Tail.ExpectedType), "Count", nonPublic: false);
				}
				ctx.LoadAddress(local, local.Type);
				ctx.EmitCall(Helpers.GetGetMethod(property, nonPublic: false, allowInternal: false));
				ctx.BranchIfFalse(label, @short: false);
				Type type = ctx.MapType(typeof(void));
				if ((object)addRange != null)
				{
					ctx.LoadValue(local2);
					ctx.LoadValue(local);
					ctx.EmitCall(addRange);
					if ((object)addRange.ReturnType != null && (object)add.ReturnType != type)
					{
						ctx.DiscardValue();
					}
				}
				else
				{
					MethodInfo moveNext;
					MethodInfo current;
					MethodInfo enumeratorInfo = GetEnumeratorInfo(ctx.Model, out moveNext, out current);
					Type returnType = enumeratorInfo.ReturnType;
					using Local local3 = new Local(ctx, returnType);
					ctx.LoadAddress(local, ExpectedType);
					ctx.EmitCall(enumeratorInfo);
					ctx.StoreValue(local3);
					using (ctx.Using(local3))
					{
						CodeLabel label2 = ctx.DefineLabel();
						CodeLabel label3 = ctx.DefineLabel();
						ctx.Branch(label3, @short: false);
						ctx.MarkLabel(label2);
						ctx.LoadAddress(local2, local2.Type);
						ctx.LoadAddress(local3, returnType);
						ctx.EmitCall(current);
						ctx.EmitCall(add);
						if ((object)add.ReturnType != null && (object)add.ReturnType != type)
						{
							ctx.DiscardValue();
						}
						ctx.MarkLabel(label3);
						ctx.LoadAddress(local3, returnType);
						ctx.EmitCall(moveNext);
						ctx.BranchIfTrue(label2, @short: false);
					}
				}
				ctx.MarkLabel(label);
			}
			ListDecorator.EmitReadList(ctx, local2, Tail, add, packedWireType, castListForAdd: false);
			ctx.LoadAddress(local2, local2.Type);
			ctx.EmitCall(finish);
			if ((object)ExpectedType != finish.ReturnType)
			{
				ctx.Cast(ExpectedType);
			}
		}
	}
	internal sealed class NullDecorator : ProtoDecoratorBase
	{
		public const int Tag = 1;

		private readonly Type expectedType;

		public override Type ExpectedType => expectedType;

		public override bool ReturnsValue => true;

		public override bool RequiresOldValue => true;

		public NullDecorator(TypeModel model, IProtoSerializer tail)
			: base(tail)
		{
			if (!tail.ReturnsValue)
			{
				throw new NotSupportedException("NullDecorator only supports implementations that return values");
			}
			Type type = tail.ExpectedType;
			if (Helpers.IsValueType(type))
			{
				expectedType = model.MapType(typeof(Nullable<>)).MakeGenericType(type);
			}
			else
			{
				expectedType = type;
			}
		}

		protected override void EmitRead(CompilerContext ctx, Local valueFrom)
		{
			using Local local = ctx.GetLocalWithValue(expectedType, valueFrom);
			using Local local2 = new Local(ctx, ctx.MapType(typeof(SubItemToken)));
			using Local local3 = new Local(ctx, ctx.MapType(typeof(int)));
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("StartSubItem"));
			ctx.StoreValue(local2);
			CodeLabel label = ctx.DefineLabel();
			CodeLabel label2 = ctx.DefineLabel();
			CodeLabel label3 = ctx.DefineLabel();
			ctx.MarkLabel(label);
			ctx.EmitBasicRead("ReadFieldHeader", ctx.MapType(typeof(int)));
			ctx.CopyValue();
			ctx.StoreValue(local3);
			ctx.LoadValue(1);
			ctx.BranchIfEqual(label2, @short: true);
			ctx.LoadValue(local3);
			ctx.LoadValue(1);
			ctx.BranchIfLess(label3, @short: false);
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("SkipField"));
			ctx.Branch(label, @short: true);
			ctx.MarkLabel(label2);
			if (Tail.RequiresOldValue)
			{
				if (expectedType.IsValueType)
				{
					ctx.LoadAddress(local, expectedType);
					ctx.EmitCall(expectedType.GetMethod("GetValueOrDefault", Helpers.EmptyTypes));
				}
				else
				{
					ctx.LoadValue(local);
				}
			}
			Tail.EmitRead(ctx, null);
			if (expectedType.IsValueType)
			{
				ctx.EmitCtor(expectedType, Tail.ExpectedType);
			}
			ctx.StoreValue(local);
			ctx.Branch(label, @short: false);
			ctx.MarkLabel(label3);
			ctx.LoadValue(local2);
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("EndSubItem"));
			ctx.LoadValue(local);
		}

		protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			using Local local = ctx.GetLocalWithValue(expectedType, valueFrom);
			using Local local2 = new Local(ctx, ctx.MapType(typeof(SubItemToken)));
			ctx.LoadNullRef();
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("StartSubItem"));
			ctx.StoreValue(local2);
			if (expectedType.IsValueType)
			{
				ctx.LoadAddress(local, expectedType);
				ctx.LoadValue(expectedType.GetProperty("HasValue"));
			}
			else
			{
				ctx.LoadValue(local);
			}
			CodeLabel label = ctx.DefineLabel();
			ctx.BranchIfFalse(label, @short: false);
			if (expectedType.IsValueType)
			{
				ctx.LoadAddress(local, expectedType);
				ctx.EmitCall(expectedType.GetMethod("GetValueOrDefault", Helpers.EmptyTypes));
			}
			else
			{
				ctx.LoadValue(local);
			}
			Tail.EmitWrite(ctx, null);
			ctx.MarkLabel(label);
			ctx.LoadValue(local2);
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("EndSubItem"));
		}

		public override object Read(object value, ProtoReader source)
		{
			SubItemToken token = ProtoReader.StartSubItem(source);
			int num;
			while ((num = source.ReadFieldHeader()) > 0)
			{
				if (num == 1)
				{
					value = Tail.Read(value, source);
				}
				else
				{
					source.SkipField();
				}
			}
			ProtoReader.EndSubItem(token, source);
			return value;
		}

		public override void Write(object value, ProtoWriter dest)
		{
			SubItemToken token = ProtoWriter.StartSubItem(null, dest);
			if (value != null)
			{
				Tail.Write(value, dest);
			}
			ProtoWriter.EndSubItem(token, dest);
		}
	}
	internal sealed class ParseableSerializer : IProtoSerializer
	{
		private readonly MethodInfo parse;

		public Type ExpectedType => parse.DeclaringType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public static ParseableSerializer TryCreate(Type type, TypeModel model)
		{
			if ((object)type == null)
			{
				throw new ArgumentNullException("type");
			}
			MethodInfo method = type.GetMethod("Parse", BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public, null, new Type[1] { model.MapType(typeof(string)) }, null);
			if ((object)method != null && (object)method.ReturnType == type)
			{
				if (Helpers.IsValueType(type))
				{
					MethodInfo customToString = GetCustomToString(type);
					if ((object)customToString == null || (object)customToString.ReturnType != model.MapType(typeof(string)))
					{
						return null;
					}
				}
				return new ParseableSerializer(method);
			}
			return null;
		}

		private static MethodInfo GetCustomToString(Type type)
		{
			return type.GetMethod("ToString", BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public, null, Helpers.EmptyTypes, null);
		}

		private ParseableSerializer(MethodInfo parse)
		{
			this.parse = parse;
		}

		public object Read(object value, ProtoReader source)
		{
			return parse.Invoke(null, new object[1] { source.ReadString() });
		}

		public void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteString(value.ToString(), dest);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			Type expectedType = ExpectedType;
			if (expectedType.IsValueType)
			{
				using Local local = ctx.GetLocalWithValue(expectedType, valueFrom);
				ctx.LoadAddress(local, expectedType);
				ctx.EmitCall(GetCustomToString(expectedType));
			}
			else
			{
				ctx.EmitCall(ctx.MapType(typeof(object)).GetMethod("ToString"));
			}
			ctx.EmitBasicWrite("WriteString", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead("ReadString", ctx.MapType(typeof(string)));
			ctx.EmitCall(parse);
		}
	}
	internal sealed class NetObjectSerializer : IProtoSerializer
	{
		private readonly int key;

		private readonly Type type;

		private readonly BclHelpers.NetObjectOptions options;

		public Type ExpectedType => type;

		public bool ReturnsValue => true;

		public bool RequiresOldValue => true;

		public NetObjectSerializer(TypeModel model, Type type, int key, BclHelpers.NetObjectOptions options)
		{
			bool flag = (options & BclHelpers.NetObjectOptions.DynamicType) != 0;
			this.key = (flag ? (-1) : key);
			this.type = (flag ? model.MapType(typeof(object)) : type);
			this.options = options;
		}

		public object Read(object value, ProtoReader source)
		{
			return BclHelpers.ReadNetObject(value, source, key, ((object)type == typeof(object)) ? null : type, options);
		}

		public void Write(object value, ProtoWriter dest)
		{
			BclHelpers.WriteNetObject(value, dest, key, options);
		}

		public void EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.LoadValue(valueFrom);
			ctx.CastToObject(type);
			ctx.LoadReaderWriter();
			ctx.LoadValue(ctx.MapMetaKeyToCompiledKey(key));
			if ((object)type == ctx.MapType(typeof(object)))
			{
				ctx.LoadNullRef();
			}
			else
			{
				ctx.LoadValue(type);
			}
			ctx.LoadValue((int)options);
			ctx.EmitCall(ctx.MapType(typeof(BclHelpers)).GetMethod("ReadNetObject"));
			ctx.CastFromObject(type);
		}

		public void EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.LoadValue(valueFrom);
			ctx.CastToObject(type);
			ctx.LoadReaderWriter();
			ctx.LoadValue(ctx.MapMetaKeyToCompiledKey(key));
			ctx.LoadValue((int)options);
			ctx.EmitCall(ctx.MapType(typeof(BclHelpers)).GetMethod("WriteNetObject"));
		}
	}
	internal sealed class SByteSerializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(sbyte);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public SByteSerializer(TypeModel model)
		{
		}

		public object Read(object value, ProtoReader source)
		{
			return source.ReadSByte();
		}

		public void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteSByte((sbyte)value, dest);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicWrite("WriteSByte", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead("ReadSByte", ExpectedType);
		}
	}
	internal sealed class MemberSpecifiedDecorator : ProtoDecoratorBase
	{
		private readonly MethodInfo getSpecified;

		private readonly MethodInfo setSpecified;

		public override Type ExpectedType => Tail.ExpectedType;

		public override bool RequiresOldValue => Tail.RequiresOldValue;

		public override bool ReturnsValue => Tail.ReturnsValue;

		public MemberSpecifiedDecorator(MethodInfo getSpecified, MethodInfo setSpecified, IProtoSerializer tail)
			: base(tail)
		{
			if ((object)getSpecified == null && (object)setSpecified == null)
			{
				throw new InvalidOperationException();
			}
			this.getSpecified = getSpecified;
			this.setSpecified = setSpecified;
		}

		public override void Write(object value, ProtoWriter dest)
		{
			if ((object)getSpecified == null || (bool)getSpecified.Invoke(value, null))
			{
				Tail.Write(value, dest);
			}
		}

		public override object Read(object value, ProtoReader source)
		{
			object result = Tail.Read(value, source);
			if ((object)setSpecified != null)
			{
				setSpecified.Invoke(value, new object[1] { true });
			}
			return result;
		}

		protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			if ((object)getSpecified == null)
			{
				Tail.EmitWrite(ctx, valueFrom);
				return;
			}
			using Local local = ctx.GetLocalWithValue(ExpectedType, valueFrom);
			ctx.LoadAddress(local, ExpectedType);
			ctx.EmitCall(getSpecified);
			CodeLabel label = ctx.DefineLabel();
			ctx.BranchIfFalse(label, @short: false);
			Tail.EmitWrite(ctx, local);
			ctx.MarkLabel(label);
		}

		protected override void EmitRead(CompilerContext ctx, Local valueFrom)
		{
			if ((object)setSpecified == null)
			{
				Tail.EmitRead(ctx, valueFrom);
				return;
			}
			using Local local = ctx.GetLocalWithValue(ExpectedType, valueFrom);
			Tail.EmitRead(ctx, local);
			ctx.LoadAddress(local, ExpectedType);
			ctx.LoadValue(1);
			ctx.EmitCall(setSpecified);
		}
	}
	internal sealed class SystemTypeSerializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(Type);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public SystemTypeSerializer(TypeModel model)
		{
		}

		void IProtoSerializer.Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteType((Type)value, dest);
		}

		object IProtoSerializer.Read(object value, ProtoReader source)
		{
			return source.ReadType();
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicWrite("WriteType", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead("ReadType", ExpectedType);
		}
	}
	internal sealed class TupleSerializer : IProtoTypeSerializer, IProtoSerializer
	{
		private readonly MemberInfo[] members;

		private readonly ConstructorInfo ctor;

		private IProtoSerializer[] tails;

		public Type ExpectedType => ctor.DeclaringType;

		public bool RequiresOldValue => true;

		public bool ReturnsValue => false;

		public TupleSerializer(RuntimeTypeModel model, ConstructorInfo ctor, MemberInfo[] members)
		{
			if ((object)ctor == null)
			{
				throw new ArgumentNullException("ctor");
			}
			if (members == null)
			{
				throw new ArgumentNullException("members");
			}
			this.ctor = ctor;
			this.members = members;
			tails = new IProtoSerializer[members.Length];
			ParameterInfo[] parameters = ctor.GetParameters();
			for (int i = 0; i < members.Length; i++)
			{
				Type parameterType = parameters[i].ParameterType;
				Type itemType = null;
				Type defaultType = null;
				MetaType.ResolveListTypes(model, parameterType, ref itemType, ref defaultType);
				Type type = (((object)itemType == null) ? parameterType : itemType);
				bool asReference = false;
				int num = model.FindOrAddAuto(type, demand: false, addWithContractOnly: true, addEvenIfAutoDisabled: false);
				if (num >= 0)
				{
					asReference = model[type].AsReferenceDefault;
				}
				IProtoSerializer protoSerializer = ValueMember.TryGetCoreSerializer(model, DataFormat.Default, type, out var defaultWireType, asReference, dynamicType: false, overwriteList: false, allowComplexTypes: true);
				if (protoSerializer == null)
				{
					throw new InvalidOperationException("No serializer defined for type: " + type.FullName);
				}
				protoSerializer = new TagDecorator(i + 1, defaultWireType, strict: false, protoSerializer);
				IProtoSerializer protoSerializer2 = (((object)itemType != null) ? ((!parameterType.IsArray) ? ((ProtoDecoratorBase)ListDecorator.Create(model, parameterType, defaultType, protoSerializer, i + 1, writePacked: false, defaultWireType, returnList: true, overwriteList: false, supportNull: false)) : ((ProtoDecoratorBase)new ArrayDecorator(model, protoSerializer, i + 1, writePacked: false, defaultWireType, parameterType, overwriteList: false, supportNull: false))) : protoSerializer);
				tails[i] = protoSerializer2;
			}
		}

		public bool HasCallbacks(TypeModel.CallbackType callbackType)
		{
			return false;
		}

		public void EmitCallback(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType)
		{
		}

		void IProtoTypeSerializer.Callback(object value, TypeModel.CallbackType callbackType, SerializationContext context)
		{
		}

		object IProtoTypeSerializer.CreateInstance(ProtoReader source)
		{
			throw new NotSupportedException();
		}

		private object GetValue(object obj, int index)
		{
			if (members[index] is PropertyInfo propertyInfo)
			{
				if (obj == null)
				{
					if (!Helpers.IsValueType(propertyInfo.PropertyType))
					{
						return null;
					}
					return Activator.CreateInstance(propertyInfo.PropertyType);
				}
				return propertyInfo.GetValue(obj, null);
			}
			if (members[index] is FieldInfo fieldInfo)
			{
				if (obj == null)
				{
					if (!Helpers.IsValueType(fieldInfo.FieldType))
					{
						return null;
					}
					return Activator.CreateInstance(fieldInfo.FieldType);
				}
				return fieldInfo.GetValue(obj);
			}
			throw new InvalidOperationException();
		}

		public object Read(object value, ProtoReader source)
		{
			object[] array = new object[members.Length];
			bool flag = false;
			if (value == null)
			{
				flag = true;
			}
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = GetValue(value, i);
			}
			int num;
			while ((num = source.ReadFieldHeader()) > 0)
			{
				flag = true;
				if (num <= tails.Length)
				{
					IProtoSerializer protoSerializer = tails[num - 1];
					array[num - 1] = tails[num - 1].Read(protoSerializer.RequiresOldValue ? array[num - 1] : null, source);
				}
				else
				{
					source.SkipField();
				}
			}
			if (!flag)
			{
				return value;
			}
			return ctor.Invoke(array);
		}

		public void Write(object value, ProtoWriter dest)
		{
			for (int i = 0; i < tails.Length; i++)
			{
				object value2 = GetValue(value, i);
				if (value2 != null)
				{
					tails[i].Write(value2, dest);
				}
			}
		}

		private Type GetMemberType(int index)
		{
			Type memberType = Helpers.GetMemberType(members[index]);
			if ((object)memberType == null)
			{
				throw new InvalidOperationException();
			}
			return memberType;
		}

		bool IProtoTypeSerializer.CanCreateInstance()
		{
			return false;
		}

		public void EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			using Local local = ctx.GetLocalWithValue(ctor.DeclaringType, valueFrom);
			for (int i = 0; i < tails.Length; i++)
			{
				Type memberType = GetMemberType(i);
				ctx.LoadAddress(local, ExpectedType);
				switch (members[i].MemberType)
				{
				case MemberTypes.Field:
					ctx.LoadValue((FieldInfo)members[i]);
					break;
				case MemberTypes.Property:
					ctx.LoadValue((PropertyInfo)members[i]);
					break;
				}
				ctx.WriteNullCheckedTail(memberType, tails[i], null);
			}
		}

		void IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
		{
			throw new NotSupportedException();
		}

		public void EmitRead(CompilerContext ctx, Local incoming)
		{
			using Local local = ctx.GetLocalWithValue(ExpectedType, incoming);
			Local[] array = new Local[members.Length];
			try
			{
				for (int i = 0; i < array.Length; i++)
				{
					Type memberType = GetMemberType(i);
					bool flag = true;
					array[i] = new Local(ctx, memberType);
					if (ExpectedType.IsValueType)
					{
						continue;
					}
					if (memberType.IsValueType)
					{
						switch (Helpers.GetTypeCode(memberType))
						{
						case ProtoTypeCode.Boolean:
						case ProtoTypeCode.SByte:
						case ProtoTypeCode.Byte:
						case ProtoTypeCode.Int16:
						case ProtoTypeCode.UInt16:
						case ProtoTypeCode.Int32:
						case ProtoTypeCode.UInt32:
							ctx.LoadValue(0);
							break;
						case ProtoTypeCode.Int64:
						case ProtoTypeCode.UInt64:
							ctx.LoadValue(0L);
							break;
						case ProtoTypeCode.Single:
							ctx.LoadValue(0f);
							break;
						case ProtoTypeCode.Double:
							ctx.LoadValue(0.0);
							break;
						case ProtoTypeCode.Decimal:
							ctx.LoadValue(0m);
							break;
						case ProtoTypeCode.Guid:
							ctx.LoadValue(Guid.Empty);
							break;
						default:
							ctx.LoadAddress(array[i], memberType);
							ctx.EmitCtor(memberType);
							flag = false;
							break;
						}
					}
					else
					{
						ctx.LoadNullRef();
					}
					if (flag)
					{
						ctx.StoreValue(array[i]);
					}
				}
				CodeLabel label = (ExpectedType.IsValueType ? default(CodeLabel) : ctx.DefineLabel());
				if (!ExpectedType.IsValueType)
				{
					ctx.LoadAddress(local, ExpectedType);
					ctx.BranchIfFalse(label, @short: false);
				}
				for (int j = 0; j < members.Length; j++)
				{
					ctx.LoadAddress(local, ExpectedType);
					switch (members[j].MemberType)
					{
					case MemberTypes.Field:
						ctx.LoadValue((FieldInfo)members[j]);
						break;
					case MemberTypes.Property:
						ctx.LoadValue((PropertyInfo)members[j]);
						break;
					}
					ctx.StoreValue(array[j]);
				}
				if (!ExpectedType.IsValueType)
				{
					ctx.MarkLabel(label);
				}
				using (Local local2 = new Local(ctx, ctx.MapType(typeof(int))))
				{
					CodeLabel label2 = ctx.DefineLabel();
					CodeLabel label3 = ctx.DefineLabel();
					CodeLabel label4 = ctx.DefineLabel();
					ctx.Branch(label2, @short: false);
					CodeLabel[] array2 = new CodeLabel[members.Length];
					for (int k = 0; k < members.Length; k++)
					{
						ref CodeLabel reference = ref array2[k];
						reference = ctx.DefineLabel();
					}
					ctx.MarkLabel(label3);
					ctx.LoadValue(local2);
					ctx.LoadValue(1);
					ctx.Subtract();
					ctx.Switch(array2);
					ctx.Branch(label4, @short: false);
					for (int l = 0; l < array2.Length; l++)
					{
						ctx.MarkLabel(array2[l]);
						IProtoSerializer protoSerializer = tails[l];
						Local valueFrom = (protoSerializer.RequiresOldValue ? array[l] : null);
						ctx.ReadNullCheckedTail(array[l].Type, protoSerializer, valueFrom);
						if (protoSerializer.ReturnsValue)
						{
							if (array[l].Type.IsValueType)
							{
								ctx.StoreValue(array[l]);
							}
							else
							{
								CodeLabel label5 = ctx.DefineLabel();
								CodeLabel label6 = ctx.DefineLabel();
								ctx.CopyValue();
								ctx.BranchIfTrue(label5, @short: true);
								ctx.DiscardValue();
								ctx.Branch(label6, @short: true);
								ctx.MarkLabel(label5);
								ctx.StoreValue(array[l]);
								ctx.MarkLabel(label6);
							}
						}
						ctx.Branch(label2, @short: false);
					}
					ctx.MarkLabel(label4);
					ctx.LoadReaderWriter();
					ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("SkipField"));
					ctx.MarkLabel(label2);
					ctx.EmitBasicRead("ReadFieldHeader", ctx.MapType(typeof(int)));
					ctx.CopyValue();
					ctx.StoreValue(local2);
					ctx.LoadValue(0);
					ctx.BranchIfGreater(label3, @short: false);
				}
				for (int m = 0; m < array.Length; m++)
				{
					ctx.LoadValue(array[m]);
				}
				ctx.EmitCtor(ctor);
				ctx.StoreValue(local);
			}
			finally
			{
				for (int n = 0; n < array.Length; n++)
				{
					if (array[n] != null)
					{
						array[n].Dispose();
					}
				}
			}
		}
	}
	internal sealed class UriDecorator : ProtoDecoratorBase
	{
		private static readonly Type expectedType = typeof(Uri);

		public override Type ExpectedType => expectedType;

		public override bool RequiresOldValue => false;

		public override bool ReturnsValue => true;

		public UriDecorator(TypeModel model, IProtoSerializer tail)
			: base(tail)
		{
		}

		public override void Write(object value, ProtoWriter dest)
		{
			Tail.Write(((Uri)value).AbsoluteUri, dest);
		}

		public override object Read(object value, ProtoReader source)
		{
			string text = (string)Tail.Read(null, source);
			if (text.Length != 0)
			{
				return new Uri(text);
			}
			return null;
		}

		protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.LoadValue(valueFrom);
			ctx.LoadValue(typeof(Uri).GetProperty("AbsoluteUri"));
			Tail.EmitWrite(ctx, null);
		}

		protected override void EmitRead(CompilerContext ctx, Local valueFrom)
		{
			Tail.EmitRead(ctx, valueFrom);
			ctx.CopyValue();
			CodeLabel label = ctx.DefineLabel();
			CodeLabel label2 = ctx.DefineLabel();
			ctx.LoadValue(typeof(string).GetProperty("Length"));
			ctx.BranchIfTrue(label, @short: true);
			ctx.DiscardValue();
			ctx.LoadNullRef();
			ctx.Branch(label2, @short: true);
			ctx.MarkLabel(label);
			ctx.EmitCtor(ctx.MapType(typeof(Uri)), ctx.MapType(typeof(string)));
			ctx.MarkLabel(label2);
		}
	}
	internal sealed class EnumSerializer : IProtoSerializer
	{
		public struct EnumPair
		{
			public readonly object RawValue;

			public readonly Enum TypedValue;

			public readonly int WireValue;

			public EnumPair(int wireValue, object raw, Type type)
			{
				WireValue = wireValue;
				RawValue = raw;
				TypedValue = (Enum)Enum.ToObject(type, raw);
			}
		}

		private readonly Type enumType;

		private readonly EnumPair[] map;

		public Type ExpectedType => enumType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public EnumSerializer(Type enumType, EnumPair[] map)
		{
			if ((object)enumType == null)
			{
				throw new ArgumentNullException("enumType");
			}
			this.enumType = enumType;
			this.map = map;
			if (map == null)
			{
				return;
			}
			for (int i = 1; i < map.Length; i++)
			{
				for (int j = 0; j < i; j++)
				{
					if (map[i].WireValue == map[j].WireValue && !object.Equals(map[i].RawValue, map[j].RawValue))
					{
						int wireValue = map[i].WireValue;
						throw new ProtoException("Multiple enums with wire-value " + wireValue);
					}
					if (object.Equals(map[i].RawValue, map[j].RawValue) && map[i].WireValue != map[j].WireValue)
					{
						throw new ProtoException("Multiple enums with deserialized-value " + map[i].RawValue);
					}
				}
			}
		}

		private ProtoTypeCode GetTypeCode()
		{
			Type underlyingType = Helpers.GetUnderlyingType(enumType);
			if ((object)underlyingType == null)
			{
				underlyingType = enumType;
			}
			return Helpers.GetTypeCode(underlyingType);
		}

		private int EnumToWire(object value)
		{
			return GetTypeCode() switch
			{
				ProtoTypeCode.Byte => (byte)value, 
				ProtoTypeCode.SByte => (sbyte)value, 
				ProtoTypeCode.Int16 => (short)value, 
				ProtoTypeCode.Int32 => (int)value, 
				ProtoTypeCode.Int64 => (int)(long)value, 
				ProtoTypeCode.UInt16 => (ushort)value, 
				ProtoTypeCode.UInt32 => (int)(uint)value, 
				ProtoTypeCode.UInt64 => (int)(ulong)value, 
				_ => throw new InvalidOperationException(), 
			};
		}

		private object WireToEnum(int value)
		{
			return GetTypeCode() switch
			{
				ProtoTypeCode.Byte => Enum.ToObject(enumType, (byte)value), 
				ProtoTypeCode.SByte => Enum.ToObject(enumType, (sbyte)value), 
				ProtoTypeCode.Int16 => Enum.ToObject(enumType, (short)value), 
				ProtoTypeCode.Int32 => Enum.ToObject(enumType, value), 
				ProtoTypeCode.Int64 => Enum.ToObject(enumType, (long)value), 
				ProtoTypeCode.UInt16 => Enum.ToObject(enumType, (ushort)value), 
				ProtoTypeCode.UInt32 => Enum.ToObject(enumType, (uint)value), 
				ProtoTypeCode.UInt64 => Enum.ToObject(enumType, (ulong)value), 
				_ => throw new InvalidOperationException(), 
			};
		}

		public object Read(object value, ProtoReader source)
		{
			int num = source.ReadInt32();
			if (map == null)
			{
				return WireToEnum(num);
			}
			for (int i = 0; i < map.Length; i++)
			{
				if (map[i].WireValue == num)
				{
					return map[i].TypedValue;
				}
			}
			source.ThrowEnumException(ExpectedType, num);
			return null;
		}

		public void Write(object value, ProtoWriter dest)
		{
			if (map == null)
			{
				ProtoWriter.WriteInt32(EnumToWire(value), dest);
				return;
			}
			for (int i = 0; i < map.Length; i++)
			{
				if (object.Equals(map[i].TypedValue, value))
				{
					ProtoWriter.WriteInt32(map[i].WireValue, dest);
					return;
				}
			}
			ProtoWriter.ThrowEnumException(dest, value);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ProtoTypeCode typeCode = GetTypeCode();
			if (map == null)
			{
				ctx.LoadValue(valueFrom);
				ctx.ConvertToInt32(typeCode, uint32Overflow: false);
				ctx.EmitBasicWrite("WriteInt32", null);
				return;
			}
			using Local local = ctx.GetLocalWithValue(ExpectedType, valueFrom);
			CodeLabel label = ctx.DefineLabel();
			for (int i = 0; i < map.Length; i++)
			{
				CodeLabel label2 = ctx.DefineLabel();
				CodeLabel label3 = ctx.DefineLabel();
				ctx.LoadValue(local);
				WriteEnumValue(ctx, typeCode, map[i].RawValue);
				ctx.BranchIfEqual(label3, @short: true);
				ctx.Branch(label2, @short: true);
				ctx.MarkLabel(label3);
				ctx.LoadValue(map[i].WireValue);
				ctx.EmitBasicWrite("WriteInt32", null);
				ctx.Branch(label, @short: false);
				ctx.MarkLabel(label2);
			}
			ctx.LoadReaderWriter();
			ctx.LoadValue(local);
			ctx.CastToObject(ExpectedType);
			ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("ThrowEnumException"));
			ctx.MarkLabel(label);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ProtoTypeCode typeCode = GetTypeCode();
			if (map == null)
			{
				ctx.EmitBasicRead("ReadInt32", ctx.MapType(typeof(int)));
				ctx.ConvertFromInt32(typeCode, uint32Overflow: false);
				return;
			}
			int[] array = new int[map.Length];
			object[] array2 = new object[map.Length];
			for (int i = 0; i < map.Length; i++)
			{
				array[i] = map[i].WireValue;
				array2[i] = map[i].RawValue;
			}
			using Local local = new Local(ctx, ExpectedType);
			using Local local2 = new Local(ctx, ctx.MapType(typeof(int)));
			ctx.EmitBasicRead("ReadInt32", ctx.MapType(typeof(int)));
			ctx.StoreValue(local2);
			CodeLabel codeLabel = ctx.DefineLabel();
			BasicList.NodeEnumerator enumerator = BasicList.GetContiguousGroups(array, array2).GetEnumerator();
			while (enumerator.MoveNext())
			{
				BasicList.Group obj = (BasicList.Group)enumerator.Current;
				CodeLabel label = ctx.DefineLabel();
				int count = obj.Items.Count;
				if (count == 1)
				{
					ctx.LoadValue(local2);
					ctx.LoadValue(obj.First);
					CodeLabel codeLabel2 = ctx.DefineLabel();
					ctx.BranchIfEqual(codeLabel2, @short: true);
					ctx.Branch(label, @short: false);
					WriteEnumValue(ctx, typeCode, codeLabel2, codeLabel, obj.Items[0], local);
				}
				else
				{
					ctx.LoadValue(local2);
					ctx.LoadValue(obj.First);
					ctx.Subtract();
					CodeLabel[] array3 = new CodeLabel[count];
					for (int j = 0; j < count; j++)
					{
						ref CodeLabel reference = ref array3[j];
						reference = ctx.DefineLabel();
					}
					ctx.Switch(array3);
					ctx.Branch(label, @short: false);
					for (int k = 0; k < count; k++)
					{
						WriteEnumValue(ctx, typeCode, array3[k], codeLabel, obj.Items[k], local);
					}
				}
				ctx.MarkLabel(label);
			}
			ctx.LoadReaderWriter();
			ctx.LoadValue(ExpectedType);
			ctx.LoadValue(local2);
			ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("ThrowEnumException"));
			ctx.MarkLabel(codeLabel);
			ctx.LoadValue(local);
		}

		private static void WriteEnumValue(CompilerContext ctx, ProtoTypeCode typeCode, object value)
		{
			switch (typeCode)
			{
			case ProtoTypeCode.Byte:
				ctx.LoadValue((byte)value);
				break;
			case ProtoTypeCode.SByte:
				ctx.LoadValue((sbyte)value);
				break;
			case ProtoTypeCode.Int16:
				ctx.LoadValue((short)value);
				break;
			case ProtoTypeCode.Int32:
				ctx.LoadValue((int)value);
				break;
			case ProtoTypeCode.Int64:
				ctx.LoadValue((long)value);
				break;
			case ProtoTypeCode.UInt16:
				ctx.LoadValue((ushort)value);
				break;
			case ProtoTypeCode.UInt32:
				ctx.LoadValue((int)(uint)value);
				break;
			case ProtoTypeCode.UInt64:
				ctx.LoadValue((long)(ulong)value);
				break;
			default:
				throw new InvalidOperationException();
			}
		}

		private static void WriteEnumValue(CompilerContext ctx, ProtoTypeCode typeCode, CodeLabel handler, CodeLabel @continue, object value, Local local)
		{
			ctx.MarkLabel(handler);
			WriteEnumValue(ctx, typeCode, value);
			ctx.StoreValue(local);
			ctx.Branch(@continue, @short: false);
		}
	}
	internal sealed class DefaultValueDecorator : ProtoDecoratorBase
	{
		private readonly object defaultValue;

		public override Type ExpectedType => Tail.ExpectedType;

		public override bool RequiresOldValue => Tail.RequiresOldValue;

		public override bool ReturnsValue => Tail.ReturnsValue;

		public DefaultValueDecorator(TypeModel model, object defaultValue, IProtoSerializer tail)
			: base(tail)
		{
			if (defaultValue == null)
			{
				throw new ArgumentNullException("defaultValue");
			}
			Type type = model.MapType(defaultValue.GetType());
			if ((object)type != tail.ExpectedType)
			{
				throw new ArgumentException("Default value is of incorrect type", "defaultValue");
			}
			this.defaultValue = defaultValue;
		}

		public override void Write(object value, ProtoWriter dest)
		{
			if (!object.Equals(value, defaultValue))
			{
				Tail.Write(value, dest);
			}
		}

		public override object Read(object value, ProtoReader source)
		{
			return Tail.Read(value, source);
		}

		protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			CodeLabel label = ctx.DefineLabel();
			if (valueFrom == null)
			{
				ctx.CopyValue();
				CodeLabel label2 = ctx.DefineLabel();
				EmitBranchIfDefaultValue(ctx, label2);
				Tail.EmitWrite(ctx, null);
				ctx.Branch(label, @short: true);
				ctx.MarkLabel(label2);
				ctx.DiscardValue();
			}
			else
			{
				ctx.LoadValue(valueFrom);
				EmitBranchIfDefaultValue(ctx, label);
				Tail.EmitWrite(ctx, valueFrom);
			}
			ctx.MarkLabel(label);
		}

		private void EmitBeq(CompilerContext ctx, CodeLabel label, Type type)
		{
			switch (Helpers.GetTypeCode(type))
			{
			case ProtoTypeCode.Boolean:
			case ProtoTypeCode.Char:
			case ProtoTypeCode.SByte:
			case ProtoTypeCode.Byte:
			case ProtoTypeCode.Int16:
			case ProtoTypeCode.UInt16:
			case ProtoTypeCode.Int32:
			case ProtoTypeCode.UInt32:
			case ProtoTypeCode.Int64:
			case ProtoTypeCode.UInt64:
			case ProtoTypeCode.Single:
			case ProtoTypeCode.Double:
				ctx.BranchIfEqual(label, @short: false);
				return;
			}
			MethodInfo method = type.GetMethod("op_Equality", BindingFlags.Static | BindingFlags.Public, null, new Type[2] { type, type }, null);
			if ((object)method == null || (object)method.ReturnType != ctx.MapType(typeof(bool)))
			{
				throw new InvalidOperationException("No suitable equality operator found for default-values of type: " + type.FullName);
			}
			ctx.EmitCall(method);
			ctx.BranchIfTrue(label, @short: false);
		}

		private void EmitBranchIfDefaultValue(CompilerContext ctx, CodeLabel label)
		{
			Type expectedType = ExpectedType;
			switch (Helpers.GetTypeCode(expectedType))
			{
			case ProtoTypeCode.Boolean:
				if ((bool)defaultValue)
				{
					ctx.BranchIfTrue(label, @short: false);
				}
				else
				{
					ctx.BranchIfFalse(label, @short: false);
				}
				break;
			case ProtoTypeCode.Byte:
				if ((byte)defaultValue == 0)
				{
					ctx.BranchIfFalse(label, @short: false);
					break;
				}
				ctx.LoadValue((byte)defaultValue);
				EmitBeq(ctx, label, expectedType);
				break;
			case ProtoTypeCode.SByte:
				if ((sbyte)defaultValue == 0)
				{
					ctx.BranchIfFalse(label, @short: false);
					break;
				}
				ctx.LoadValue((sbyte)defaultValue);
				EmitBeq(ctx, label, expectedType);
				break;
			case ProtoTypeCode.Int16:
				if ((short)defaultValue == 0)
				{
					ctx.BranchIfFalse(label, @short: false);
					break;
				}
				ctx.LoadValue((short)defaultValue);
				EmitBeq(ctx, label, expectedType);
				break;
			case ProtoTypeCode.UInt16:
				if ((ushort)defaultValue == 0)
				{
					ctx.BranchIfFalse(label, @short: false);
					break;
				}
				ctx.LoadValue((ushort)defaultValue);
				EmitBeq(ctx, label, expectedType);
				break;
			case ProtoTypeCode.Int32:
				if ((int)defaultValue == 0)
				{
					ctx.BranchIfFalse(label, @short: false);
					break;
				}
				ctx.LoadValue((int)defaultValue);
				EmitBeq(ctx, label, expectedType);
				break;
			case ProtoTypeCode.UInt32:
				if ((uint)defaultValue == 0)
				{
					ctx.BranchIfFalse(label, @short: false);
					break;
				}
				ctx.LoadValue((int)(uint)defaultValue);
				EmitBeq(ctx, label, expectedType);
				break;
			case ProtoTypeCode.Char:
				if ((char)defaultValue == '\0')
				{
					ctx.BranchIfFalse(label, @short: false);
					break;
				}
				ctx.LoadValue((char)defaultValue);
				EmitBeq(ctx, label, expectedType);
				break;
			case ProtoTypeCode.Int64:
				ctx.LoadValue((long)defaultValue);
				EmitBeq(ctx, label, expectedType);
				break;
			case ProtoTypeCode.UInt64:
				ctx.LoadValue((long)(ulong)defaultValue);
				EmitBeq(ctx, label, expectedType);
				break;
			case ProtoTypeCode.Double:
				ctx.LoadValue((double)defaultValue);
				EmitBeq(ctx, label, expectedType);
				break;
			case ProtoTypeCode.Single:
				ctx.LoadValue((float)defaultValue);
				EmitBeq(ctx, label, expectedType);
				break;
			case ProtoTypeCode.String:
				ctx.LoadValue((string)defaultValue);
				EmitBeq(ctx, label, expectedType);
				break;
			case ProtoTypeCode.Decimal:
			{
				decimal value = (decimal)defaultValue;
				ctx.LoadValue(value);
				EmitBeq(ctx, label, expectedType);
				break;
			}
			case ProtoTypeCode.TimeSpan:
			{
				TimeSpan timeSpan = (TimeSpan)defaultValue;
				if (timeSpan == TimeSpan.Zero)
				{
					ctx.LoadValue(typeof(TimeSpan).GetField("Zero"));
				}
				else
				{
					ctx.LoadValue(timeSpan.Ticks);
					ctx.EmitCall(ctx.MapType(typeof(TimeSpan)).GetMethod("FromTicks"));
				}
				EmitBeq(ctx, label, expectedType);
				break;
			}
			case ProtoTypeCode.Guid:
				ctx.LoadValue((Guid)defaultValue);
				EmitBeq(ctx, label, expectedType);
				break;
			case ProtoTypeCode.DateTime:
				ctx.LoadValue(((DateTime)defaultValue).ToBinary());
				ctx.EmitCall(ctx.MapType(typeof(DateTime)).GetMethod("FromBinary"));
				EmitBeq(ctx, label, expectedType);
				break;
			default:
				throw new NotSupportedException("Type cannot be represented as a default value: " + expectedType.FullName);
			}
		}

		protected override void EmitRead(CompilerContext ctx, Local valueFrom)
		{
			Tail.EmitRead(ctx, valueFrom);
		}
	}
	internal sealed class GuidSerializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(Guid);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public GuidSerializer(TypeModel model)
		{
		}

		public void Write(object value, ProtoWriter dest)
		{
			BclHelpers.WriteGuid((Guid)value, dest);
		}

		public object Read(object value, ProtoReader source)
		{
			return BclHelpers.ReadGuid(source);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitWrite(ctx.MapType(typeof(BclHelpers)), "WriteGuid", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead(ctx.MapType(typeof(BclHelpers)), "ReadGuid", ExpectedType);
		}
	}
	internal sealed class SurrogateSerializer : IProtoTypeSerializer, IProtoSerializer
	{
		private readonly Type forType;

		private readonly Type declaredType;

		private readonly MethodInfo toTail;

		private readonly MethodInfo fromTail;

		private IProtoTypeSerializer rootTail;

		public bool ReturnsValue => false;

		public bool RequiresOldValue => true;

		public Type ExpectedType => forType;

		bool IProtoTypeSerializer.HasCallbacks(TypeModel.CallbackType callbackType)
		{
			return false;
		}

		void IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType)
		{
		}

		void IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
		{
			throw new NotSupportedException();
		}

		bool IProtoTypeSerializer.CanCreateInstance()
		{
			return false;
		}

		object IProtoTypeSerializer.CreateInstance(ProtoReader source)
		{
			throw new NotSupportedException();
		}

		void IProtoTypeSerializer.Callback(object value, TypeModel.CallbackType callbackType, SerializationContext context)
		{
		}

		public SurrogateSerializer(Type forType, Type declaredType, IProtoTypeSerializer rootTail)
		{
			this.forType = forType;
			this.declaredType = declaredType;
			this.rootTail = rootTail;
			toTail = GetConversion(toTail: true);
			fromTail = GetConversion(toTail: false);
		}

		private static bool HasCast(Type type, Type from, Type to, out MethodInfo op)
		{
			MethodInfo[] methods = type.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			foreach (MethodInfo methodInfo in methods)
			{
				if ((!(methodInfo.Name != "op_Implicit") || !(methodInfo.Name != "op_Explicit")) && (object)methodInfo.ReturnType == to)
				{
					ParameterInfo[] parameters = methodInfo.GetParameters();
					if (parameters.Length == 1 && (object)parameters[0].ParameterType == from)
					{
						op = methodInfo;
						return true;
					}
				}
			}
			op = null;
			return false;
		}

		public MethodInfo GetConversion(bool toTail)
		{
			Type to = (toTail ? declaredType : forType);
			Type type = (toTail ? forType : declaredType);
			if (HasCast(declaredType, type, to, out var op) || HasCast(forType, type, to, out op))
			{
				return op;
			}
			throw new InvalidOperationException("No suitable conversion operator found for surrogate: " + forType.FullName + " / " + declaredType.FullName);
		}

		public void Write(object value, ProtoWriter writer)
		{
			rootTail.Write(toTail.Invoke(null, new object[1] { value }), writer);
		}

		public object Read(object value, ProtoReader source)
		{
			object[] array = new object[1] { value };
			value = toTail.Invoke(null, array);
			array[0] = rootTail.Read(value, source);
			return fromTail.Invoke(null, array);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			using Local local = new Local(ctx, declaredType);
			ctx.LoadValue(valueFrom);
			ctx.EmitCall(toTail);
			ctx.StoreValue(local);
			rootTail.EmitRead(ctx, local);
			ctx.LoadValue(local);
			ctx.EmitCall(fromTail);
			ctx.StoreValue(valueFrom);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.LoadValue(valueFrom);
			ctx.EmitCall(toTail);
			rootTail.EmitWrite(ctx, null);
		}
	}
	internal sealed class Int16Serializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(short);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public Int16Serializer(TypeModel model)
		{
		}

		public object Read(object value, ProtoReader source)
		{
			return source.ReadInt16();
		}

		public void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteInt16((short)value, dest);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicWrite("WriteInt16", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead("ReadInt16", ExpectedType);
		}
	}
	internal sealed class DecimalSerializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(decimal);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public DecimalSerializer(TypeModel model)
		{
		}

		public object Read(object value, ProtoReader source)
		{
			return BclHelpers.ReadDecimal(source);
		}

		public void Write(object value, ProtoWriter dest)
		{
			BclHelpers.WriteDecimal((decimal)value, dest);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitWrite(ctx.MapType(typeof(BclHelpers)), "WriteDecimal", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead(ctx.MapType(typeof(BclHelpers)), "ReadDecimal", ExpectedType);
		}
	}
	internal sealed class TimeSpanSerializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(TimeSpan);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public TimeSpanSerializer(TypeModel model)
		{
		}

		public object Read(object value, ProtoReader source)
		{
			return BclHelpers.ReadTimeSpan(source);
		}

		public void Write(object value, ProtoWriter dest)
		{
			BclHelpers.WriteTimeSpan((TimeSpan)value, dest);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitWrite(ctx.MapType(typeof(BclHelpers)), "WriteTimeSpan", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead(ctx.MapType(typeof(BclHelpers)), "ReadTimeSpan", ExpectedType);
		}
	}
	internal sealed class DateTimeSerializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(DateTime);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public DateTimeSerializer(TypeModel model)
		{
		}

		public object Read(object value, ProtoReader source)
		{
			return BclHelpers.ReadDateTime(source);
		}

		public void Write(object value, ProtoWriter dest)
		{
			BclHelpers.WriteDateTime((DateTime)value, dest);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitWrite(ctx.MapType(typeof(BclHelpers)), "WriteDateTime", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead(ctx.MapType(typeof(BclHelpers)), "ReadDateTime", ExpectedType);
		}
	}
	internal sealed class UInt32Serializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(uint);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public UInt32Serializer(TypeModel model)
		{
		}

		public object Read(object value, ProtoReader source)
		{
			return source.ReadUInt32();
		}

		public void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteUInt32((uint)value, dest);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicWrite("WriteUInt32", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead("ReadUInt32", ctx.MapType(typeof(uint)));
		}
	}
	internal sealed class UInt64Serializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(ulong);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public UInt64Serializer(TypeModel model)
		{
		}

		public object Read(object value, ProtoReader source)
		{
			return source.ReadUInt64();
		}

		public void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteUInt64((ulong)value, dest);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicWrite("WriteUInt64", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead("ReadUInt64", ExpectedType);
		}
	}
	internal sealed class Int64Serializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(long);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public Int64Serializer(TypeModel model)
		{
		}

		public object Read(object value, ProtoReader source)
		{
			return source.ReadInt64();
		}

		public void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteInt64((long)value, dest);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicWrite("WriteInt64", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead("ReadInt64", ExpectedType);
		}
	}
	internal sealed class DoubleSerializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(double);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public DoubleSerializer(TypeModel model)
		{
		}

		public object Read(object value, ProtoReader source)
		{
			return source.ReadDouble();
		}

		public void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteDouble((double)value, dest);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicWrite("WriteDouble", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead("ReadDouble", ExpectedType);
		}
	}
	internal sealed class SingleSerializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(float);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public SingleSerializer(TypeModel model)
		{
		}

		public object Read(object value, ProtoReader source)
		{
			return source.ReadSingle();
		}

		public void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteSingle((float)value, dest);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicWrite("WriteSingle", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead("ReadSingle", ExpectedType);
		}
	}
	internal sealed class FieldDecorator : ProtoDecoratorBase
	{
		private readonly FieldInfo field;

		private readonly Type forType;

		public override Type ExpectedType => forType;

		public override bool RequiresOldValue => true;

		public override bool ReturnsValue => false;

		public FieldDecorator(Type forType, FieldInfo field, IProtoSerializer tail)
			: base(tail)
		{
			this.forType = forType;
			this.field = field;
		}

		public override void Write(object value, ProtoWriter dest)
		{
			value = field.GetValue(value);
			if (value != null)
			{
				Tail.Write(value, dest);
			}
		}

		public override object Read(object value, ProtoReader source)
		{
			object obj = Tail.Read(Tail.RequiresOldValue ? field.GetValue(value) : null, source);
			if (obj != null)
			{
				field.SetValue(value, obj);
			}
			return null;
		}

		protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.LoadAddress(valueFrom, ExpectedType);
			ctx.LoadValue(field);
			ctx.WriteNullCheckedTail(field.FieldType, Tail, null);
		}

		protected override void EmitRead(CompilerContext ctx, Local valueFrom)
		{
			using Local local = ctx.GetLocalWithValue(ExpectedType, valueFrom);
			if (Tail.RequiresOldValue)
			{
				ctx.LoadAddress(local, ExpectedType);
				ctx.LoadValue(field);
			}
			ctx.ReadNullCheckedTail(field.FieldType, Tail, null);
			if (!Tail.ReturnsValue)
			{
				return;
			}
			using Local local2 = new Local(ctx, field.FieldType);
			ctx.StoreValue(local2);
			if (field.FieldType.IsValueType)
			{
				ctx.LoadAddress(local, ExpectedType);
				ctx.LoadValue(local2);
				ctx.StoreValue(field);
				return;
			}
			CodeLabel label = ctx.DefineLabel();
			ctx.LoadValue(local2);
			ctx.BranchIfFalse(label, @short: true);
			ctx.LoadAddress(local, ExpectedType);
			ctx.LoadValue(local2);
			ctx.StoreValue(field);
			ctx.MarkLabel(label);
		}
	}
	internal sealed class Int32Serializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(int);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public Int32Serializer(TypeModel model)
		{
		}

		public object Read(object value, ProtoReader source)
		{
			return source.ReadInt32();
		}

		public void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteInt32((int)value, dest);
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicWrite("WriteInt32", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead("ReadInt32", ExpectedType);
		}
	}
	internal sealed class PropertyDecorator : ProtoDecoratorBase
	{
		private readonly PropertyInfo property;

		private readonly Type forType;

		private readonly bool readOptionsWriteValue;

		private readonly MethodInfo shadowSetter;

		public override Type ExpectedType => forType;

		public override bool RequiresOldValue => true;

		public override bool ReturnsValue => false;

		public PropertyDecorator(TypeModel model, Type forType, PropertyInfo property, IProtoSerializer tail)
			: base(tail)
		{
			this.forType = forType;
			this.property = property;
			SanityCheck(model, property, tail, out readOptionsWriteValue, nonPublic: true, allowInternal: true);
			shadowSetter = GetShadowSetter(model, property);
		}

		private static void SanityCheck(TypeModel model, PropertyInfo property, IProtoSerializer tail, out bool writeValue, bool nonPublic, bool allowInternal)
		{
			if ((object)property == null)
			{
				throw new ArgumentNullException("property");
			}
			writeValue = tail.ReturnsValue && ((object)GetShadowSetter(model, property) != null || (property.CanWrite && (object)Helpers.GetSetMethod(property, nonPublic, allowInternal) != null));
			if (!property.CanRead || (object)Helpers.GetGetMethod(property, nonPublic, allowInternal) == null)
			{
				throw new InvalidOperationException("Cannot serialize property without a get accessor");
			}
			if (!writeValue && (!tail.RequiresOldValue || Helpers.IsValueType(tail.ExpectedType)))
			{
				throw new InvalidOperationException("Cannot apply changes to property " + property.DeclaringType.FullName + "." + property.Name);
			}
		}

		private static MethodInfo GetShadowSetter(TypeModel model, PropertyInfo property)
		{
			Type reflectedType = property.ReflectedType;
			MethodInfo instanceMethod = Helpers.GetInstanceMethod(reflectedType, "Set" + property.Name, new Type[1] { property.PropertyType });
			if ((object)instanceMethod == null || !instanceMethod.IsPublic || (object)instanceMethod.ReturnType != model.MapType(typeof(void)))
			{
				return null;
			}
			return instanceMethod;
		}

		public override void Write(object value, ProtoWriter dest)
		{
			value = property.GetValue(value, null);
			if (value != null)
			{
				Tail.Write(value, dest);
			}
		}

		public override object Read(object value, ProtoReader source)
		{
			object value2 = (Tail.RequiresOldValue ? property.GetValue(value, null) : null);
			object obj = Tail.Read(value2, source);
			if (readOptionsWriteValue && obj != null)
			{
				if ((object)shadowSetter == null)
				{
					property.SetValue(value, obj, null);
				}
				else
				{
					shadowSetter.Invoke(value, new object[1] { obj });
				}
			}
			return null;
		}

		protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.LoadAddress(valueFrom, ExpectedType);
			ctx.LoadValue(property);
			ctx.WriteNullCheckedTail(property.PropertyType, Tail, null);
		}

		protected override void EmitRead(CompilerContext ctx, Local valueFrom)
		{
			SanityCheck(ctx.Model, property, Tail, out var writeValue, ctx.NonPublic, ctx.AllowInternal(property));
			if (ExpectedType.IsValueType && valueFrom == null)
			{
				throw new InvalidOperationException("Attempt to mutate struct on the head of the stack; changes would be lost");
			}
			using Local local = ctx.GetLocalWithValue(ExpectedType, valueFrom);
			if (Tail.RequiresOldValue)
			{
				ctx.LoadAddress(local, ExpectedType);
				ctx.LoadValue(property);
			}
			Type propertyType = property.PropertyType;
			ctx.ReadNullCheckedTail(propertyType, Tail, null);
			if (writeValue)
			{
				using (Local local2 = new Local(ctx, property.PropertyType))
				{
					ctx.StoreValue(local2);
					CodeLabel label = default(CodeLabel);
					if (!propertyType.IsValueType)
					{
						label = ctx.DefineLabel();
						ctx.LoadValue(local2);
						ctx.BranchIfFalse(label, @short: true);
					}
					ctx.LoadAddress(local, ExpectedType);
					ctx.LoadValue(local2);
					if ((object)shadowSetter == null)
					{
						ctx.StoreValue(property);
					}
					else
					{
						ctx.EmitCall(shadowSetter);
					}
					if (!propertyType.IsValueType)
					{
						ctx.MarkLabel(label);
					}
					return;
				}
			}
			if (Tail.ReturnsValue)
			{
				ctx.DiscardValue();
			}
		}

		internal static bool CanWrite(TypeModel model, MemberInfo member)
		{
			if ((object)member == null)
			{
				throw new ArgumentNullException("member");
			}
			if (member is PropertyInfo propertyInfo)
			{
				if (!propertyInfo.CanWrite)
				{
					return (object)GetShadowSetter(model, propertyInfo) != null;
				}
				return true;
			}
			return member is FieldInfo;
		}
	}
	internal sealed class StringSerializer : IProtoSerializer
	{
		private static readonly Type expectedType = typeof(string);

		public Type ExpectedType => expectedType;

		bool IProtoSerializer.RequiresOldValue => false;

		bool IProtoSerializer.ReturnsValue => true;

		public StringSerializer(TypeModel model)
		{
		}

		public void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteString((string)value, dest);
		}

		public object Read(object value, ProtoReader source)
		{
			return source.ReadString();
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicWrite("WriteString", valueFrom);
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			ctx.EmitBasicRead("ReadString", ExpectedType);
		}
	}
	internal sealed class SubItemSerializer : IProtoTypeSerializer, IProtoSerializer
	{
		private readonly int key;

		private readonly Type type;

		private readonly ISerializerProxy proxy;

		private readonly bool recursionCheck;

		Type IProtoSerializer.ExpectedType => type;

		bool IProtoSerializer.RequiresOldValue => true;

		bool IProtoSerializer.ReturnsValue => true;

		bool IProtoTypeSerializer.HasCallbacks(TypeModel.CallbackType callbackType)
		{
			return ((IProtoTypeSerializer)proxy.Serializer).HasCallbacks(callbackType);
		}

		bool IProtoTypeSerializer.CanCreateInstance()
		{
			return ((IProtoTypeSerializer)proxy.Serializer).CanCreateInstance();
		}

		void IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType)
		{
			((IProtoTypeSerializer)proxy.Serializer).EmitCallback(ctx, valueFrom, callbackType);
		}

		void IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
		{
			((IProtoTypeSerializer)proxy.Serializer).EmitCreateInstance(ctx);
		}

		void IProtoTypeSerializer.Callback(object value, TypeModel.CallbackType callbackType, SerializationContext context)
		{
			((IProtoTypeSerializer)proxy.Serializer).Callback(value, callbackType, context);
		}

		object IProtoTypeSerializer.CreateInstance(ProtoReader source)
		{
			return ((IProtoTypeSerializer)proxy.Serializer).CreateInstance(source);
		}

		public SubItemSerializer(Type type, int key, ISerializerProxy proxy, bool recursionCheck)
		{
			if ((object)type == null)
			{
				throw new ArgumentNullException("type");
			}
			if (proxy == null)
			{
				throw new ArgumentNullException("proxy");
			}
			this.type = type;
			this.proxy = proxy;
			this.key = key;
			this.recursionCheck = recursionCheck;
		}

		void IProtoSerializer.Write(object value, ProtoWriter dest)
		{
			if (recursionCheck)
			{
				ProtoWriter.WriteObject(value, key, dest);
			}
			else
			{
				ProtoWriter.WriteRecursionSafeObject(value, key, dest);
			}
		}

		object IProtoSerializer.Read(object value, ProtoReader source)
		{
			return ProtoReader.ReadObject(value, key, source);
		}

		private bool EmitDedicatedMethod(CompilerContext ctx, Local valueFrom, bool read)
		{
			MethodBuilder dedicatedMethod = ctx.GetDedicatedMethod(key, read);
			if ((object)dedicatedMethod == null)
			{
				return false;
			}
			using (Local local = new Local(ctx, ctx.MapType(typeof(SubItemToken))))
			{
				Type type = ctx.MapType(read ? typeof(ProtoReader) : typeof(ProtoWriter));
				ctx.LoadValue(valueFrom);
				if (!read)
				{
					if (this.type.IsValueType || !recursionCheck)
					{
						ctx.LoadNullRef();
					}
					else
					{
						ctx.CopyValue();
					}
				}
				ctx.LoadReaderWriter();
				ctx.EmitCall(type.GetMethod("StartSubItem"));
				ctx.StoreValue(local);
				ctx.LoadReaderWriter();
				ctx.EmitCall(dedicatedMethod);
				if (read && (object)this.type != dedicatedMethod.ReturnType)
				{
					ctx.Cast(this.type);
				}
				ctx.LoadValue(local);
				ctx.LoadReaderWriter();
				ctx.EmitCall(type.GetMethod("EndSubItem"));
			}
			return true;
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			if (!EmitDedicatedMethod(ctx, valueFrom, read: false))
			{
				ctx.LoadValue(valueFrom);
				if (type.IsValueType)
				{
					ctx.CastToObject(type);
				}
				ctx.LoadValue(ctx.MapMetaKeyToCompiledKey(key));
				ctx.LoadReaderWriter();
				ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod(recursionCheck ? "WriteObject" : "WriteRecursionSafeObject"));
			}
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			if (!EmitDedicatedMethod(ctx, valueFrom, read: true))
			{
				ctx.LoadValue(valueFrom);
				if (type.IsValueType)
				{
					ctx.CastToObject(type);
				}
				ctx.LoadValue(ctx.MapMetaKeyToCompiledKey(key));
				ctx.LoadReaderWriter();
				ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("ReadObject"));
				ctx.CastFromObject(type);
			}
		}
	}
	internal sealed class TagDecorator : ProtoDecoratorBase, IProtoTypeSerializer, IProtoSerializer
	{
		private readonly bool strict;

		private readonly int fieldNumber;

		private readonly WireType wireType;

		public override Type ExpectedType => Tail.ExpectedType;

		public override bool RequiresOldValue => Tail.RequiresOldValue;

		public override bool ReturnsValue => Tail.ReturnsValue;

		private bool NeedsHint => (wireType & (WireType)(-8)) != 0;

		public bool HasCallbacks(TypeModel.CallbackType callbackType)
		{
			if (Tail is IProtoTypeSerializer protoTypeSerializer)
			{
				return protoTypeSerializer.HasCallbacks(callbackType);
			}
			return false;
		}

		public bool CanCreateInstance()
		{
			if (Tail is IProtoTypeSerializer protoTypeSerializer)
			{
				return protoTypeSerializer.CanCreateInstance();
			}
			return false;
		}

		public object CreateInstance(ProtoReader source)
		{
			return ((IProtoTypeSerializer)Tail).CreateInstance(source);
		}

		public void Callback(object value, TypeModel.CallbackType callbackType, SerializationContext context)
		{
			if (Tail is IProtoTypeSerializer protoTypeSerializer)
			{
				protoTypeSerializer.Callback(value, callbackType, context);
			}
		}

		public void EmitCallback(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType)
		{
			((IProtoTypeSerializer)Tail).EmitCallback(ctx, valueFrom, callbackType);
		}

		public void EmitCreateInstance(CompilerContext ctx)
		{
			((IProtoTypeSerializer)Tail).EmitCreateInstance(ctx);
		}

		public TagDecorator(int fieldNumber, WireType wireType, bool strict, IProtoSerializer tail)
			: base(tail)
		{
			this.fieldNumber = fieldNumber;
			this.wireType = wireType;
			this.strict = strict;
		}

		public override object Read(object value, ProtoReader source)
		{
			if (strict)
			{
				source.Assert(wireType);
			}
			else if (NeedsHint)
			{
				source.Hint(wireType);
			}
			return Tail.Read(value, source);
		}

		public override void Write(object value, ProtoWriter dest)
		{
			ProtoWriter.WriteFieldHeader(fieldNumber, wireType, dest);
			Tail.Write(value, dest);
		}

		protected override void EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			ctx.LoadValue(fieldNumber);
			ctx.LoadValue((int)wireType);
			ctx.LoadReaderWriter();
			ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("WriteFieldHeader"));
			Tail.EmitWrite(ctx, valueFrom);
		}

		protected override void EmitRead(CompilerContext ctx, Local valueFrom)
		{
			if (strict || NeedsHint)
			{
				ctx.LoadReaderWriter();
				ctx.LoadValue((int)wireType);
				ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod(strict ? "Assert" : "Hint"));
			}
			Tail.EmitRead(ctx, valueFrom);
		}
	}
	internal sealed class TypeSerializer : IProtoTypeSerializer, IProtoSerializer
	{
		private readonly Type forType;

		private readonly Type constructType;

		private readonly IProtoSerializer[] serializers;

		private readonly int[] fieldNumbers;

		private readonly bool isRootType;

		private readonly bool useConstructor;

		private readonly bool isExtensible;

		private readonly bool hasConstructor;

		private readonly CallbackSet callbacks;

		private readonly MethodInfo[] baseCtorCallbacks;

		private readonly MethodInfo factory;

		private static readonly Type iextensible = typeof(IExtensible);

		public Type ExpectedType => forType;

		private bool CanHaveInheritance
		{
			get
			{
				if (forType.IsClass || forType.IsInterface)
				{
					return !forType.IsSealed;
				}
				return false;
			}
		}

		bool IProtoSerializer.RequiresOldValue => true;

		bool IProtoSerializer.ReturnsValue => false;

		public bool HasCallbacks(TypeModel.CallbackType callbackType)
		{
			if (callbacks != null && (object)callbacks[callbackType] != null)
			{
				return true;
			}
			for (int i = 0; i < serializers.Length; i++)
			{
				if ((object)serializers[i].ExpectedType != forType && ((IProtoTypeSerializer)serializers[i]).HasCallbacks(callbackType))
				{
					return true;
				}
			}
			return false;
		}

		public TypeSerializer(TypeModel model, Type forType, int[] fieldNumbers, IProtoSerializer[] serializers, MethodInfo[] baseCtorCallbacks, bool isRootType, bool useConstructor, CallbackSet callbacks, Type constructType, MethodInfo factory)
		{
			Helpers.Sort(fieldNumbers, serializers);
			bool flag = false;
			for (int i = 1; i < fieldNumbers.Length; i++)
			{
				if (fieldNumbers[i] == fieldNumbers[i - 1])
				{
					throw new InvalidOperationException("Duplicate field-number detected; " + fieldNumbers[i] + " on: " + forType.FullName);
				}
				if (!flag && (object)serializers[i].ExpectedType != forType)
				{
					flag = true;
				}
			}
			this.forType = forType;
			this.factory = factory;
			if ((object)constructType == null)
			{
				constructType = forType;
			}
			else if (!forType.IsAssignableFrom(constructType))
			{
				throw new InvalidOperationException(forType.FullName + " cannot be assigned from " + constructType.FullName);
			}
			this.constructType = constructType;
			this.serializers = serializers;
			this.fieldNumbers = fieldNumbers;
			this.callbacks = callbacks;
			this.isRootType = isRootType;
			this.useConstructor = useConstructor;
			if (baseCtorCallbacks != null && baseCtorCallbacks.Length == 0)
			{
				baseCtorCallbacks = null;
			}
			this.baseCtorCallbacks = baseCtorCallbacks;
			if ((object)Helpers.GetUnderlyingType(forType) != null)
			{
				throw new ArgumentException("Cannot create a TypeSerializer for nullable types", "forType");
			}
			if (model.MapType(iextensible).IsAssignableFrom(forType))
			{
				if (forType.IsValueType || !isRootType || flag)
				{
					throw new NotSupportedException("IExtensible is not supported in structs or classes with inheritance");
				}
				isExtensible = true;
			}
			hasConstructor = !constructType.IsAbstract && (object)Helpers.GetConstructor(constructType, Helpers.EmptyTypes, nonPublic: true) != null;
			if ((object)constructType != forType && useConstructor && !hasConstructor)
			{
				throw new ArgumentException("The supplied default implementation cannot be created: " + constructType.FullName, "constructType");
			}
		}

		bool IProtoTypeSerializer.CanCreateInstance()
		{
			return true;
		}

		object IProtoTypeSerializer.CreateInstance(ProtoReader source)
		{
			return CreateInstance(source, includeLocalCallback: false);
		}

		public void Callback(object value, TypeModel.CallbackType callbackType, SerializationContext context)
		{
			if (callbacks != null)
			{
				InvokeCallback(callbacks[callbackType], value, context);
			}
			((IProtoTypeSerializer)GetMoreSpecificSerializer(value))?.Callback(value, callbackType, context);
		}

		private IProtoSerializer GetMoreSpecificSerializer(object value)
		{
			if (!CanHaveInheritance)
			{
				return null;
			}
			Type type = value.GetType();
			if ((object)type == forType)
			{
				return null;
			}
			for (int i = 0; i < serializers.Length; i++)
			{
				IProtoSerializer protoSerializer = serializers[i];
				if ((object)protoSerializer.ExpectedType != forType && Helpers.IsAssignableFrom(protoSerializer.ExpectedType, type))
				{
					return protoSerializer;
				}
			}
			if ((object)type == constructType)
			{
				return null;
			}
			TypeModel.ThrowUnexpectedSubtype(forType, type);
			return null;
		}

		public void Write(object value, ProtoWriter dest)
		{
			if (isRootType)
			{
				Callback(value, TypeModel.CallbackType.BeforeSerialize, dest.Context);
			}
			GetMoreSpecificSerializer(value)?.Write(value, dest);
			for (int i = 0; i < serializers.Length; i++)
			{
				IProtoSerializer protoSerializer = serializers[i];
				if ((object)protoSerializer.ExpectedType == forType)
				{
					protoSerializer.Write(value, dest);
				}
			}
			if (isExtensible)
			{
				ProtoWriter.AppendExtensionData((IExtensible)value, dest);
			}
			if (isRootType)
			{
				Callback(value, TypeModel.CallbackType.AfterSerialize, dest.Context);
			}
		}

		public object Read(object value, ProtoReader source)
		{
			if (isRootType && value != null)
			{
				Callback(value, TypeModel.CallbackType.BeforeDeserialize, source.Context);
			}
			int num = 0;
			int num2 = 0;
			int num3;
			while ((num3 = source.ReadFieldHeader()) > 0)
			{
				bool flag = false;
				if (num3 < num)
				{
					num = (num2 = 0);
				}
				for (int i = num2; i < fieldNumbers.Length; i++)
				{
					if (fieldNumbers[i] != num3)
					{
						continue;
					}
					IProtoSerializer protoSerializer = serializers[i];
					Type expectedType = protoSerializer.ExpectedType;
					if (value == null)
					{
						if ((object)expectedType == forType)
						{
							value = CreateInstance(source, includeLocalCallback: true);
						}
					}
					else if ((object)expectedType != forType && ((IProtoTypeSerializer)protoSerializer).CanCreateInstance() && expectedType.IsSubclassOf(value.GetType()))
					{
						value = ProtoReader.Merge(source, value, ((IProtoTypeSerializer)protoSerializer).CreateInstance(source));
					}
					if (protoSerializer.ReturnsValue)
					{
						value = protoSerializer.Read(value, source);
					}
					else
					{
						protoSerializer.Read(value, source);
					}
					num2 = i;
					num = num3;
					flag = true;
					break;
				}
				if (!flag)
				{
					if (value == null)
					{
						value = CreateInstance(source, includeLocalCallback: true);
					}
					if (isExtensible)
					{
						source.AppendExtensionData((IExtensible)value);
					}
					else
					{
						source.SkipField();
					}
				}
			}
			if (value == null)
			{
				value = CreateInstance(source, includeLocalCallback: true);
			}
			if (isRootType)
			{
				Callback(value, TypeModel.CallbackType.AfterDeserialize, source.Context);
			}
			return value;
		}

		private object InvokeCallback(MethodInfo method, object obj, SerializationContext context)
		{
			object result = null;
			if ((object)method != null)
			{
				ParameterInfo[] parameters = method.GetParameters();
				object[] array;
				bool flag;
				if (parameters.Length == 0)
				{
					array = null;
					flag = true;
				}
				else
				{
					array = new object[parameters.Length];
					flag = true;
					for (int i = 0; i < array.Length; i++)
					{
						Type parameterType = parameters[i].ParameterType;
						object obj2;
						if ((object)parameterType == typeof(SerializationContext))
						{
							obj2 = context;
						}
						else if ((object)parameterType == typeof(Type))
						{
							obj2 = constructType;
						}
						else if ((object)parameterType == typeof(StreamingContext))
						{
							obj2 = (StreamingContext)context;
						}
						else
						{
							obj2 = null;
							flag = false;
						}
						array[i] = obj2;
					}
				}
				if (!flag)
				{
					throw CallbackSet.CreateInvalidCallbackSignature(method);
				}
				result = method.Invoke(obj, array);
			}
			return result;
		}

		private object CreateInstance(ProtoReader source, bool includeLocalCallback)
		{
			object obj;
			if ((object)factory != null)
			{
				obj = InvokeCallback(factory, null, source.Context);
			}
			else if (useConstructor)
			{
				if (!hasConstructor)
				{
					TypeModel.ThrowCannotCreateInstance(constructType);
				}
				obj = Activator.CreateInstance(constructType, nonPublic: true);
			}
			else
			{
				obj = BclHelpers.GetUninitializedObject(constructType);
			}
			ProtoReader.NoteObject(obj, source);
			if (baseCtorCallbacks != null)
			{
				for (int i = 0; i < baseCtorCallbacks.Length; i++)
				{
					InvokeCallback(baseCtorCallbacks[i], obj, source.Context);
				}
			}
			if (includeLocalCallback && callbacks != null)
			{
				InvokeCallback(callbacks.BeforeDeserialize, obj, source.Context);
			}
			return obj;
		}

		void IProtoSerializer.EmitWrite(CompilerContext ctx, Local valueFrom)
		{
			Type expectedType = ExpectedType;
			using Local local = ctx.GetLocalWithValue(expectedType, valueFrom);
			EmitCallbackIfNeeded(ctx, local, TypeModel.CallbackType.BeforeSerialize);
			CodeLabel label = ctx.DefineLabel();
			if (CanHaveInheritance)
			{
				for (int i = 0; i < serializers.Length; i++)
				{
					IProtoSerializer protoSerializer = serializers[i];
					Type expectedType2 = protoSerializer.ExpectedType;
					if ((object)expectedType2 != forType)
					{
						CodeLabel label2 = ctx.DefineLabel();
						CodeLabel label3 = ctx.DefineLabel();
						ctx.LoadValue(local);
						ctx.TryCast(expectedType2);
						ctx.CopyValue();
						ctx.BranchIfTrue(label2, @short: true);
						ctx.DiscardValue();
						ctx.Branch(label3, @short: true);
						ctx.MarkLabel(label2);
						protoSerializer.EmitWrite(ctx, null);
						ctx.Branch(label, @short: false);
						ctx.MarkLabel(label3);
					}
				}
				if ((object)constructType != null && (object)constructType != forType)
				{
					using Local local2 = new Local(ctx, ctx.MapType(typeof(Type)));
					ctx.LoadValue(local);
					ctx.EmitCall(ctx.MapType(typeof(object)).GetMethod("GetType"));
					ctx.CopyValue();
					ctx.StoreValue(local2);
					ctx.LoadValue(forType);
					ctx.BranchIfEqual(label, @short: true);
					ctx.LoadValue(local2);
					ctx.LoadValue(constructType);
					ctx.BranchIfEqual(label, @short: true);
				}
				else
				{
					ctx.LoadValue(local);
					ctx.EmitCall(ctx.MapType(typeof(object)).GetMethod("GetType"));
					ctx.LoadValue(forType);
					ctx.BranchIfEqual(label, @short: true);
				}
				ctx.LoadValue(forType);
				ctx.LoadValue(local);
				ctx.EmitCall(ctx.MapType(typeof(object)).GetMethod("GetType"));
				ctx.EmitCall(ctx.MapType(typeof(TypeModel)).GetMethod("ThrowUnexpectedSubtype", BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic));
			}
			ctx.MarkLabel(label);
			for (int j = 0; j < serializers.Length; j++)
			{
				IProtoSerializer protoSerializer2 = serializers[j];
				if ((object)protoSerializer2.ExpectedType == forType)
				{
					protoSerializer2.EmitWrite(ctx, local);
				}
			}
			if (isExtensible)
			{
				ctx.LoadValue(local);
				ctx.LoadReaderWriter();
				ctx.EmitCall(ctx.MapType(typeof(ProtoWriter)).GetMethod("AppendExtensionData"));
			}
			EmitCallbackIfNeeded(ctx, local, TypeModel.CallbackType.AfterSerialize);
		}

		private static void EmitInvokeCallback(CompilerContext ctx, MethodInfo method, bool copyValue, Type constructType, Type type)
		{
			if ((object)method == null)
			{
				return;
			}
			if (copyValue)
			{
				ctx.CopyValue();
			}
			ParameterInfo[] parameters = method.GetParameters();
			bool flag = true;
			for (int i = 0; i < parameters.Length; i++)
			{
				Type parameterType = parameters[0].ParameterType;
				if ((object)parameterType == ctx.MapType(typeof(SerializationContext)))
				{
					ctx.LoadSerializationContext();
				}
				else if ((object)parameterType == ctx.MapType(typeof(Type)))
				{
					Type type2 = constructType;
					if ((object)type2 == null)
					{
						type2 = type;
					}
					ctx.LoadValue(type2);
				}
				else if ((object)parameterType == ctx.MapType(typeof(StreamingContext)))
				{
					ctx.LoadSerializationContext();
					MethodInfo method2 = ctx.MapType(typeof(SerializationContext)).GetMethod("op_Implicit", new Type[1] { ctx.MapType(typeof(SerializationContext)) });
					if ((object)method2 != null)
					{
						ctx.EmitCall(method2);
						flag = true;
					}
				}
				else
				{
					flag = false;
				}
			}
			if (flag)
			{
				ctx.EmitCall(method);
				if ((object)constructType != null && (object)method.ReturnType == ctx.MapType(typeof(object)))
				{
					ctx.CastFromObject(type);
				}
				return;
			}
			throw CallbackSet.CreateInvalidCallbackSignature(method);
		}

		private void EmitCallbackIfNeeded(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType)
		{
			if (isRootType && ((IProtoTypeSerializer)this).HasCallbacks(callbackType))
			{
				((IProtoTypeSerializer)this).EmitCallback(ctx, valueFrom, callbackType);
			}
		}

		void IProtoTypeSerializer.EmitCallback(CompilerContext ctx, Local valueFrom, TypeModel.CallbackType callbackType)
		{
			bool flag = false;
			if (CanHaveInheritance)
			{
				for (int i = 0; i < serializers.Length; i++)
				{
					IProtoSerializer protoSerializer = serializers[i];
					if ((object)protoSerializer.ExpectedType != forType && ((IProtoTypeSerializer)protoSerializer).HasCallbacks(callbackType))
					{
						flag = true;
					}
				}
			}
			MethodInfo methodInfo = ((callbacks == null) ? null : callbacks[callbackType]);
			if ((object)methodInfo == null && !flag)
			{
				return;
			}
			ctx.LoadAddress(valueFrom, ExpectedType);
			EmitInvokeCallback(ctx, methodInfo, flag, null, forType);
			if (!flag)
			{
				return;
			}
			CodeLabel label = ctx.DefineLabel();
			for (int j = 0; j < serializers.Length; j++)
			{
				IProtoSerializer protoSerializer2 = serializers[j];
				Type expectedType = protoSerializer2.ExpectedType;
				IProtoTypeSerializer protoTypeSerializer;
				if ((object)expectedType != forType && (protoTypeSerializer = (IProtoTypeSerializer)protoSerializer2).HasCallbacks(callbackType))
				{
					CodeLabel label2 = ctx.DefineLabel();
					CodeLabel label3 = ctx.DefineLabel();
					ctx.CopyValue();
					ctx.TryCast(expectedType);
					ctx.CopyValue();
					ctx.BranchIfTrue(label2, @short: true);
					ctx.DiscardValue();
					ctx.Branch(label3, @short: false);
					ctx.MarkLabel(label2);
					protoTypeSerializer.EmitCallback(ctx, null, callbackType);
					ctx.Branch(label, @short: false);
					ctx.MarkLabel(label3);
				}
			}
			ctx.MarkLabel(label);
			ctx.DiscardValue();
		}

		void IProtoSerializer.EmitRead(CompilerContext ctx, Local valueFrom)
		{
			Type expectedType = ExpectedType;
			using Local local = ctx.GetLocalWithValue(expectedType, valueFrom);
			using Local local2 = new Local(ctx, ctx.MapType(typeof(int)));
			if (HasCallbacks(TypeModel.CallbackType.BeforeDeserialize))
			{
				if (ExpectedType.IsValueType)
				{
					EmitCallbackIfNeeded(ctx, local, TypeModel.CallbackType.BeforeDeserialize);
				}
				else
				{
					CodeLabel label = ctx.DefineLabel();
					ctx.LoadValue(local);
					ctx.BranchIfFalse(label, @short: false);
					EmitCallbackIfNeeded(ctx, local, TypeModel.CallbackType.BeforeDeserialize);
					ctx.MarkLabel(label);
				}
			}
			CodeLabel codeLabel = ctx.DefineLabel();
			CodeLabel label2 = ctx.DefineLabel();
			ctx.Branch(codeLabel, @short: false);
			ctx.MarkLabel(label2);
			BasicList.NodeEnumerator enumerator = BasicList.GetContiguousGroups(fieldNumbers, serializers).GetEnumerator();
			while (enumerator.MoveNext())
			{
				BasicList.Group obj = (BasicList.Group)enumerator.Current;
				CodeLabel label3 = ctx.DefineLabel();
				int count = obj.Items.Count;
				if (count == 1)
				{
					ctx.LoadValue(local2);
					ctx.LoadValue(obj.First);
					CodeLabel codeLabel2 = ctx.DefineLabel();
					ctx.BranchIfEqual(codeLabel2, @short: true);
					ctx.Branch(label3, @short: false);
					WriteFieldHandler(ctx, expectedType, local, codeLabel2, codeLabel, (IProtoSerializer)obj.Items[0]);
				}
				else
				{
					ctx.LoadValue(local2);
					ctx.LoadValue(obj.First);
					ctx.Subtract();
					CodeLabel[] array = new CodeLabel[count];
					for (int i = 0; i < count; i++)
					{
						ref CodeLabel reference = ref array[i];
						reference = ctx.DefineLabel();
					}
					ctx.Switch(array);
					ctx.Branch(label3, @short: false);
					for (int j = 0; j < count; j++)
					{
						WriteFieldHandler(ctx, expectedType, local, array[j], codeLabel, (IProtoSerializer)obj.Items[j]);
					}
				}
				ctx.MarkLabel(label3);
			}
			EmitCreateIfNull(ctx, local);
			ctx.LoadReaderWriter();
			if (isExtensible)
			{
				ctx.LoadValue(local);
				ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("AppendExtensionData"));
			}
			else
			{
				ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("SkipField"));
			}
			ctx.MarkLabel(codeLabel);
			ctx.EmitBasicRead("ReadFieldHeader", ctx.MapType(typeof(int)));
			ctx.CopyValue();
			ctx.StoreValue(local2);
			ctx.LoadValue(0);
			ctx.BranchIfGreater(label2, @short: false);
			EmitCreateIfNull(ctx, local);
			EmitCallbackIfNeeded(ctx, local, TypeModel.CallbackType.AfterDeserialize);
			if (valueFrom != null && !local.IsSame(valueFrom))
			{
				ctx.LoadValue(local);
				ctx.Cast(valueFrom.Type);
				ctx.StoreValue(valueFrom);
			}
		}

		private void WriteFieldHandler(CompilerContext ctx, Type expected, Local loc, CodeLabel handler, CodeLabel @continue, IProtoSerializer serializer)
		{
			ctx.MarkLabel(handler);
			Type expectedType = serializer.ExpectedType;
			if ((object)expectedType == forType)
			{
				EmitCreateIfNull(ctx, loc);
				serializer.EmitRead(ctx, loc);
			}
			else
			{
				if (((IProtoTypeSerializer)serializer).CanCreateInstance())
				{
					CodeLabel label = ctx.DefineLabel();
					ctx.LoadValue(loc);
					ctx.BranchIfFalse(label, @short: false);
					ctx.LoadValue(loc);
					ctx.TryCast(expectedType);
					ctx.BranchIfTrue(label, @short: false);
					ctx.LoadReaderWriter();
					ctx.LoadValue(loc);
					((IProtoTypeSerializer)serializer).EmitCreateInstance(ctx);
					ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("Merge"));
					ctx.Cast(expected);
					ctx.StoreValue(loc);
					ctx.MarkLabel(label);
				}
				ctx.LoadValue(loc);
				ctx.Cast(expectedType);
				serializer.EmitRead(ctx, null);
			}
			if (serializer.ReturnsValue)
			{
				ctx.StoreValue(loc);
			}
			ctx.Branch(@continue, @short: false);
		}

		void IProtoTypeSerializer.EmitCreateInstance(CompilerContext ctx)
		{
			bool flag = true;
			if ((object)factory != null)
			{
				EmitInvokeCallback(ctx, factory, copyValue: false, constructType, forType);
			}
			else if (!useConstructor)
			{
				ctx.LoadValue(constructType);
				ctx.EmitCall(ctx.MapType(typeof(BclHelpers)).GetMethod("GetUninitializedObject"));
				ctx.Cast(forType);
			}
			else if (constructType.IsClass && hasConstructor)
			{
				ctx.EmitCtor(constructType);
			}
			else
			{
				ctx.LoadValue(ExpectedType);
				ctx.EmitCall(ctx.MapType(typeof(TypeModel)).GetMethod("ThrowCannotCreateInstance", BindingFlags.Static | BindingFlags.Public));
				ctx.LoadNullRef();
				flag = false;
			}
			if (flag)
			{
				ctx.CopyValue();
				ctx.LoadReaderWriter();
				ctx.EmitCall(ctx.MapType(typeof(ProtoReader)).GetMethod("NoteObject", BindingFlags.Static | BindingFlags.Public));
			}
			if (baseCtorCallbacks != null)
			{
				for (int i = 0; i < baseCtorCallbacks.Length; i++)
				{
					EmitInvokeCallback(ctx, baseCtorCallbacks[i], copyValue: true, null, forType);
				}
			}
		}

		private void EmitCreateIfNull(CompilerContext ctx, Local storage)
		{
			if (!ExpectedType.IsValueType)
			{
				CodeLabel label = ctx.DefineLabel();
				ctx.LoadValue(storage);
				ctx.BranchIfTrue(label, @short: false);
				((IProtoTypeSerializer)this).EmitCreateInstance(ctx);
				if (callbacks != null)
				{
					EmitInvokeCallback(ctx, callbacks.BeforeDeserialize, copyValue: true, null, forType);
				}
				ctx.StoreValue(storage);
				ctx.MarkLabel(label);
			}
		}
	}
}
namespace ProtoBuf
{
	public struct SubItemToken
	{
		internal readonly int value;

		internal SubItemToken(int value)
		{
			this.value = value;
		}
	}
	public enum WireType
	{
		None = -1,
		Variant = 0,
		Fixed64 = 1,
		String = 2,
		StartGroup = 3,
		EndGroup = 4,
		Fixed32 = 5,
		SignedVariant = 8
	}
}
