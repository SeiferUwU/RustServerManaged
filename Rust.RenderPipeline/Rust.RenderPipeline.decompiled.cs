#define UNITY_ASSERTIONS
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Text;
using Rust.RenderPipeline.Runtime.Passes;
using Rust.RenderPipeline.Runtime.Passes.Lighting;
using Rust.RenderPipeline.Runtime.Passes.PostProcessing;
using Rust.RenderPipeline.Runtime.RenderingContext;
using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Experimental.Rendering.RenderGraphModule;
using UnityEngine.Rendering;
using UnityEngine.Rendering.RendererUtils;
using UnityEngine.Scripting.APIUpdating;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("0.0.0.0")]
[module: UnverifiableCode]
[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		return new MonoScriptData
		{
			FilePathsData = new byte[3742]
			{
				0, 0, 0, 2, 0, 0, 0, 61, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 67, 97, 109, 101,
				114, 97, 66, 117, 102, 102, 101, 114, 83, 101,
				116, 116, 105, 110, 103, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 55, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 67, 97, 109, 101, 114,
				97, 68, 101, 98, 117, 103, 103, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 55,
				92, 80, 97, 99, 107, 97, 103, 101, 115, 92,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 67, 97,
				109, 101, 114, 97, 82, 101, 110, 100, 101, 114,
				101, 114, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 61, 92, 80, 97, 99, 107, 97, 103,
				101, 115, 92, 82, 117, 115, 116, 46, 82, 101,
				110, 100, 101, 114, 80, 105, 112, 101, 108, 105,
				110, 101, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 67, 97, 109, 101, 114, 97, 82, 101, 110,
				100, 101, 114, 101, 114, 67, 111, 112, 105, 101,
				114, 46, 99, 115, 0, 0, 0, 2, 0, 0,
				0, 55, 92, 80, 97, 99, 107, 97, 103, 101,
				115, 92, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				67, 97, 109, 101, 114, 97, 83, 101, 116, 116,
				105, 110, 103, 115, 46, 99, 115, 0, 0, 0,
				4, 0, 0, 0, 57, 92, 80, 97, 99, 107,
				97, 103, 101, 115, 92, 82, 117, 115, 116, 46,
				82, 101, 110, 100, 101, 114, 80, 105, 112, 101,
				108, 105, 110, 101, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 67, 111, 110, 116, 101, 120, 116,
				67, 111, 110, 116, 97, 105, 110, 101, 114, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 60,
				92, 80, 97, 99, 107, 97, 103, 101, 115, 92,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 70, 111,
				114, 119, 97, 114, 100, 80, 108, 117, 115, 83,
				101, 116, 116, 105, 110, 103, 115, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 61, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 73, 82, 101, 110,
				100, 101, 114, 71, 114, 97, 112, 104, 82, 101,
				99, 111, 114, 100, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 62, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 78, 97, 116, 105, 118,
				101, 65, 114, 114, 97, 121, 69, 120, 116, 101,
				110, 115, 105, 111, 110, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 67, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 80, 97, 115, 115, 101,
				115, 92, 67, 111, 112, 121, 65, 116, 116, 97,
				99, 104, 109, 101, 110, 116, 115, 80, 97, 115,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 57, 92, 80, 97, 99, 107, 97, 103, 101,
				115, 92, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				80, 97, 115, 115, 101, 115, 92, 68, 101, 98,
				117, 103, 80, 97, 115, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 57, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 80, 97, 115, 115, 101,
				115, 92, 70, 105, 110, 97, 108, 80, 97, 115,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 59, 92, 80, 97, 99, 107, 97, 103, 101,
				115, 92, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				80, 97, 115, 115, 101, 115, 92, 71, 66, 117,
				102, 102, 101, 114, 80, 97, 115, 115, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 60, 92,
				80, 97, 99, 107, 97, 103, 101, 115, 92, 82,
				117, 115, 116, 46, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 80, 97, 115,
				115, 101, 115, 92, 71, 101, 111, 109, 101, 116,
				114, 121, 80, 97, 115, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 58, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 80, 97, 115, 115, 101,
				115, 92, 71, 105, 122, 109, 111, 115, 80, 97,
				115, 115, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 76, 92, 80, 97, 99, 107, 97, 103,
				101, 115, 92, 82, 117, 115, 116, 46, 82, 101,
				110, 100, 101, 114, 80, 105, 112, 101, 108, 105,
				110, 101, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 80, 97, 115, 115, 101, 115, 92, 76, 105,
				103, 104, 116, 105, 110, 103, 92, 65, 100, 100,
				105, 116, 105, 111, 110, 97, 108, 76, 105, 103,
				104, 116, 68, 97, 116, 97, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 77, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 80, 97, 115, 115, 101,
				115, 92, 76, 105, 103, 104, 116, 105, 110, 103,
				92, 65, 100, 100, 105, 116, 105, 111, 110, 97,
				108, 83, 104, 97, 100, 111, 119, 68, 97, 116,
				97, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 85, 92, 80, 97, 99, 107, 97, 103, 101,
				115, 92, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				80, 97, 115, 115, 101, 115, 92, 76, 105, 103,
				104, 116, 105, 110, 103, 92, 68, 101, 102, 101,
				114, 114, 101, 100, 73, 110, 100, 105, 114, 101,
				99, 116, 76, 105, 103, 104, 116, 105, 110, 103,
				80, 97, 115, 115, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 77, 92, 80, 97, 99, 107,
				97, 103, 101, 115, 92, 82, 117, 115, 116, 46,
				82, 101, 110, 100, 101, 114, 80, 105, 112, 101,
				108, 105, 110, 101, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 80, 97, 115, 115, 101, 115, 92,
				76, 105, 103, 104, 116, 105, 110, 103, 92, 68,
				101, 102, 101, 114, 114, 101, 100, 76, 105, 103,
				104, 116, 105, 110, 103, 80, 97, 115, 115, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 77,
				92, 80, 97, 99, 107, 97, 103, 101, 115, 92,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 80, 97,
				115, 115, 101, 115, 92, 76, 105, 103, 104, 116,
				105, 110, 103, 92, 68, 105, 114, 101, 99, 116,
				105, 111, 110, 97, 108, 76, 105, 103, 104, 116,
				68, 97, 116, 97, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 81, 92, 80, 97, 99, 107,
				97, 103, 101, 115, 92, 82, 117, 115, 116, 46,
				82, 101, 110, 100, 101, 114, 80, 105, 112, 101,
				108, 105, 110, 101, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 80, 97, 115, 115, 101, 115, 92,
				76, 105, 103, 104, 116, 105, 110, 103, 92, 68,
				105, 114, 101, 99, 116, 105, 111, 110, 97, 108,
				83, 104, 97, 100, 111, 119, 67, 97, 115, 99,
				97, 100, 101, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 76, 92, 80, 97, 99, 107, 97,
				103, 101, 115, 92, 82, 117, 115, 116, 46, 82,
				101, 110, 100, 101, 114, 80, 105, 112, 101, 108,
				105, 110, 101, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 80, 97, 115, 115, 101, 115, 92, 76,
				105, 103, 104, 116, 105, 110, 103, 92, 70, 111,
				114, 119, 97, 114, 100, 80, 108, 117, 115, 84,
				105, 108, 101, 115, 74, 111, 98, 46, 99, 115,
				0, 0, 0, 9, 0, 0, 0, 75, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 80, 97, 115, 115,
				101, 115, 92, 76, 105, 103, 104, 116, 105, 110,
				103, 92, 76, 105, 103, 104, 116, 67, 111, 111,
				107, 105, 101, 77, 97, 110, 97, 103, 101, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				69, 92, 80, 97, 99, 107, 97, 103, 101, 115,
				92, 82, 117, 115, 116, 46, 82, 101, 110, 100,
				101, 114, 80, 105, 112, 101, 108, 105, 110, 101,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 80,
				97, 115, 115, 101, 115, 92, 76, 105, 103, 104,
				116, 105, 110, 103, 92, 76, 105, 103, 104, 116,
				105, 110, 103, 80, 97, 115, 115, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 71, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 80, 97, 115, 115,
				101, 115, 92, 76, 105, 103, 104, 116, 105, 110,
				103, 92, 83, 104, 97, 100, 101, 114, 66, 105,
				116, 65, 114, 114, 97, 121, 46, 99, 115, 0,
				0, 0, 3, 0, 0, 0, 64, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 80, 97, 115, 115, 101,
				115, 92, 76, 105, 103, 104, 116, 105, 110, 103,
				92, 83, 104, 97, 100, 111, 119, 115, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 72, 92,
				80, 97, 99, 107, 97, 103, 101, 115, 92, 82,
				117, 115, 116, 46, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 80, 97, 115,
				115, 101, 115, 92, 80, 111, 115, 116, 80, 114,
				111, 99, 101, 115, 115, 105, 110, 103, 92, 66,
				108, 111, 111, 109, 80, 97, 115, 115, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 75, 92,
				80, 97, 99, 107, 97, 103, 101, 115, 92, 82,
				117, 115, 116, 46, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 80, 97, 115,
				115, 101, 115, 92, 80, 111, 115, 116, 80, 114,
				111, 99, 101, 115, 115, 105, 110, 103, 92, 67,
				111, 108, 111, 114, 76, 117, 116, 80, 97, 115,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 76, 92, 80, 97, 99, 107, 97, 103, 101,
				115, 92, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				80, 97, 115, 115, 101, 115, 92, 80, 111, 115,
				116, 80, 114, 111, 99, 101, 115, 115, 105, 110,
				103, 92, 80, 111, 115, 116, 70, 88, 66, 108,
				105, 116, 116, 101, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 73, 92, 80, 97, 99,
				107, 97, 103, 101, 115, 92, 82, 117, 115, 116,
				46, 82, 101, 110, 100, 101, 114, 80, 105, 112,
				101, 108, 105, 110, 101, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 80, 97, 115, 115, 101, 115,
				92, 80, 111, 115, 116, 80, 114, 111, 99, 101,
				115, 115, 105, 110, 103, 92, 80, 111, 115, 116,
				70, 88, 80, 97, 115, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 57, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 80, 97, 115, 115, 101,
				115, 92, 83, 101, 116, 117, 112, 80, 97, 115,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 58, 92, 80, 97, 99, 107, 97, 103, 101,
				115, 92, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				80, 97, 115, 115, 101, 115, 92, 83, 107, 121,
				98, 111, 120, 80, 97, 115, 115, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 70, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 80, 97, 115, 115,
				101, 115, 92, 85, 110, 115, 117, 112, 112, 111,
				114, 116, 101, 100, 83, 104, 97, 100, 101, 114,
				115, 80, 97, 115, 115, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 54, 92, 80, 97, 99,
				107, 97, 103, 101, 115, 92, 82, 117, 115, 116,
				46, 82, 101, 110, 100, 101, 114, 80, 105, 112,
				101, 108, 105, 110, 101, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 80, 105, 112, 101, 108, 105,
				110, 101, 85, 116, 105, 108, 115, 46, 99, 115,
				0, 0, 0, 8, 0, 0, 0, 55, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 80, 111, 115, 116,
				70, 88, 83, 101, 116, 116, 105, 110, 103, 115,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				62, 92, 80, 97, 99, 107, 97, 103, 101, 115,
				92, 82, 117, 115, 116, 46, 82, 101, 110, 100,
				101, 114, 80, 105, 112, 101, 108, 105, 110, 101,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 82,
				101, 105, 110, 116, 101, 114, 112, 114, 101, 116,
				69, 120, 116, 101, 110, 115, 105, 111, 110, 115,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				75, 92, 80, 97, 99, 107, 97, 103, 101, 115,
				92, 82, 117, 115, 116, 46, 82, 101, 110, 100,
				101, 114, 80, 105, 112, 101, 108, 105, 110, 101,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 82,
				101, 110, 100, 101, 114, 105, 110, 103, 67, 111,
				110, 116, 101, 120, 116, 92, 82, 117, 115, 116,
				67, 97, 109, 101, 114, 97, 67, 111, 110, 116,
				101, 120, 116, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 78, 92, 80, 97, 99, 107, 97,
				103, 101, 115, 92, 82, 117, 115, 116, 46, 82,
				101, 110, 100, 101, 114, 80, 105, 112, 101, 108,
				105, 110, 101, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 67, 111, 110, 116, 101, 120, 116, 92, 82,
				117, 115, 116, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 67, 111, 110, 116, 101, 120, 116, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 81,
				92, 80, 97, 99, 107, 97, 103, 101, 115, 92,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 82, 101,
				110, 100, 101, 114, 105, 110, 103, 67, 111, 110,
				116, 101, 120, 116, 92, 82, 117, 115, 116, 82,
				101, 115, 111, 117, 114, 99, 101, 68, 97, 116,
				97, 67, 111, 110, 116, 101, 120, 116, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 73, 92,
				80, 97, 99, 107, 97, 103, 101, 115, 92, 82,
				117, 115, 116, 46, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 82, 101, 110,
				100, 101, 114, 105, 110, 103, 76, 97, 121, 101,
				114, 77, 97, 115, 107, 70, 105, 101, 108, 100,
				65, 116, 116, 114, 105, 98, 117, 116, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 56,
				92, 80, 97, 99, 107, 97, 103, 101, 115, 92,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 82, 101,
				110, 100, 101, 114, 80, 97, 115, 115, 69, 118,
				101, 110, 116, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 53, 92, 80, 97, 99, 107, 97,
				103, 101, 115, 92, 82, 117, 115, 116, 46, 82,
				101, 110, 100, 101, 114, 80, 105, 112, 101, 108,
				105, 110, 101, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 82, 117, 115, 116, 82, 101, 110, 100,
				101, 114, 101, 114, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 57, 92, 80, 97, 99, 107,
				97, 103, 101, 115, 92, 82, 117, 115, 116, 46,
				82, 101, 110, 100, 101, 114, 80, 105, 112, 101,
				108, 105, 110, 101, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 82, 117, 115, 116, 82, 101, 110,
				100, 101, 114, 101, 114, 68, 97, 116, 97, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 60,
				92, 80, 97, 99, 107, 97, 103, 101, 115, 92,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 82, 117,
				115, 116, 82, 101, 110, 100, 101, 114, 101, 114,
				70, 101, 97, 116, 117, 114, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 55, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 82, 117, 115, 116,
				82, 101, 110, 100, 101, 114, 80, 97, 115, 115,
				46, 99, 115, 0, 0, 0, 2, 0, 0, 0,
				59, 92, 80, 97, 99, 107, 97, 103, 101, 115,
				92, 82, 117, 115, 116, 46, 82, 101, 110, 100,
				101, 114, 80, 105, 112, 101, 108, 105, 110, 101,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 82,
				117, 115, 116, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 64, 92, 80,
				97, 99, 107, 97, 103, 101, 115, 92, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 82, 117, 115, 116,
				82, 101, 110, 100, 101, 114, 80, 105, 112, 101,
				108, 105, 110, 101, 65, 115, 115, 101, 116, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 71,
				92, 80, 97, 99, 107, 97, 103, 101, 115, 92,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 82, 117,
				115, 116, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 65, 115, 115, 101,
				116, 46, 69, 100, 105, 116, 111, 114, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 65, 92,
				80, 97, 99, 107, 97, 103, 101, 115, 92, 82,
				117, 115, 116, 46, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 82, 117, 115,
				116, 82, 101, 110, 100, 101, 114, 80, 105, 112,
				101, 108, 105, 110, 101, 67, 97, 109, 101, 114,
				97, 46, 99, 115, 0, 0, 0, 3, 0, 0,
				0, 67, 92, 80, 97, 99, 107, 97, 103, 101,
				115, 92, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				82, 117, 115, 116, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 83, 101,
				116, 116, 105, 110, 103, 115, 46, 99, 115, 0,
				0, 0, 3, 0, 0, 0, 55, 92, 80, 97,
				99, 107, 97, 103, 101, 115, 92, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 83, 104, 97, 100, 111,
				119, 83, 101, 116, 116, 105, 110, 103, 115, 46,
				99, 115
			},
			TypesData = new byte[4892]
			{
				0, 0, 0, 0, 48, 82, 117, 115, 116, 46,
				82, 101, 110, 100, 101, 114, 80, 105, 112, 101,
				108, 105, 110, 101, 46, 82, 117, 110, 116, 105,
				109, 101, 124, 67, 97, 109, 101, 114, 97, 66,
				117, 102, 102, 101, 114, 83, 101, 116, 116, 105,
				110, 103, 115, 0, 0, 0, 0, 41, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 46, 82, 117,
				110, 116, 105, 109, 101, 46, 124, 70, 120, 97,
				97, 83, 101, 116, 116, 105, 110, 103, 115, 0,
				0, 0, 0, 42, 82, 117, 115, 116, 46, 82,
				101, 110, 100, 101, 114, 80, 105, 112, 101, 108,
				105, 110, 101, 46, 82, 117, 110, 116, 105, 109,
				101, 124, 67, 97, 109, 101, 114, 97, 68, 101,
				98, 117, 103, 103, 101, 114, 0, 0, 0, 0,
				42, 82, 117, 115, 116, 46, 82, 101, 110, 100,
				101, 114, 80, 105, 112, 101, 108, 105, 110, 101,
				46, 82, 117, 110, 116, 105, 109, 101, 124, 67,
				97, 109, 101, 114, 97, 82, 101, 110, 100, 101,
				114, 101, 114, 0, 0, 0, 0, 48, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 46, 82, 117,
				110, 116, 105, 109, 101, 124, 67, 97, 109, 101,
				114, 97, 82, 101, 110, 100, 101, 114, 101, 114,
				67, 111, 112, 105, 101, 114, 0, 0, 0, 0,
				42, 82, 117, 115, 116, 46, 82, 101, 110, 100,
				101, 114, 80, 105, 112, 101, 108, 105, 110, 101,
				46, 82, 117, 110, 116, 105, 109, 101, 124, 67,
				97, 109, 101, 114, 97, 83, 101, 116, 116, 105,
				110, 103, 115, 0, 0, 0, 0, 57, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 46, 82, 117,
				110, 116, 105, 109, 101, 46, 67, 97, 109, 101,
				114, 97, 83, 101, 116, 116, 105, 110, 103, 115,
				124, 70, 105, 110, 97, 108, 66, 108, 101, 110,
				100, 77, 111, 100, 101, 0, 0, 0, 0, 44,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 46,
				82, 117, 110, 116, 105, 109, 101, 124, 67, 111,
				110, 116, 101, 120, 116, 67, 111, 110, 116, 97,
				105, 110, 101, 114, 0, 0, 0, 0, 51, 82,
				117, 115, 116, 46, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 46, 82,
				117, 110, 116, 105, 109, 101, 46, 67, 111, 110,
				116, 101, 120, 116, 67, 111, 110, 116, 97, 105,
				110, 101, 114, 124, 84, 121, 112, 101, 73, 100,
				0, 0, 0, 0, 49, 82, 117, 115, 116, 46,
				82, 101, 110, 100, 101, 114, 80, 105, 112, 101,
				108, 105, 110, 101, 46, 82, 117, 110, 116, 105,
				109, 101, 46, 67, 111, 110, 116, 101, 120, 116,
				67, 111, 110, 116, 97, 105, 110, 101, 114, 124,
				73, 116, 101, 109, 0, 0, 0, 0, 39, 82,
				117, 115, 116, 46, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 46, 82,
				117, 110, 116, 105, 109, 101, 124, 67, 111, 110,
				116, 101, 120, 116, 73, 116, 101, 109, 0, 0,
				0, 0, 47, 82, 117, 115, 116, 46, 82, 101,
				110, 100, 101, 114, 80, 105, 112, 101, 108, 105,
				110, 101, 46, 82, 117, 110, 116, 105, 109, 101,
				124, 70, 111, 114, 119, 97, 114, 100, 80, 108,
				117, 115, 83, 101, 116, 116, 105, 110, 103, 115,
				0, 0, 0, 0, 48, 82, 117, 115, 116, 46,
				82, 101, 110, 100, 101, 114, 80, 105, 112, 101,
				108, 105, 110, 101, 46, 82, 117, 110, 116, 105,
				109, 101, 124, 73, 82, 101, 110, 100, 101, 114,
				71, 114, 97, 112, 104, 82, 101, 99, 111, 114,
				100, 101, 114, 0, 0, 0, 0, 49, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 46, 82, 117,
				110, 116, 105, 109, 101, 124, 78, 97, 116, 105,
				118, 101, 65, 114, 114, 97, 121, 69, 120, 116,
				101, 110, 115, 105, 111, 110, 115, 0, 0, 0,
				0, 54, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 46, 82, 117, 110, 116, 105, 109, 101, 46,
				80, 97, 115, 115, 101, 115, 124, 67, 111, 112,
				121, 65, 116, 116, 97, 99, 104, 109, 101, 110,
				116, 115, 80, 97, 115, 115, 0, 0, 0, 0,
				44, 82, 117, 115, 116, 46, 82, 101, 110, 100,
				101, 114, 80, 105, 112, 101, 108, 105, 110, 101,
				46, 82, 117, 110, 116, 105, 109, 101, 46, 80,
				97, 115, 115, 101, 115, 124, 68, 101, 98, 117,
				103, 80, 97, 115, 115, 0, 0, 0, 0, 44,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 46,
				82, 117, 110, 116, 105, 109, 101, 46, 80, 97,
				115, 115, 101, 115, 124, 70, 105, 110, 97, 108,
				80, 97, 115, 115, 0, 0, 0, 0, 46, 82,
				117, 115, 116, 46, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 46, 82,
				117, 110, 116, 105, 109, 101, 46, 80, 97, 115,
				115, 101, 115, 124, 71, 66, 117, 102, 102, 101,
				114, 80, 97, 115, 115, 0, 0, 0, 0, 47,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 46,
				82, 117, 110, 116, 105, 109, 101, 46, 80, 97,
				115, 115, 101, 115, 124, 71, 101, 111, 109, 101,
				116, 114, 121, 80, 97, 115, 115, 0, 0, 0,
				0, 45, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 46, 82, 117, 110, 116, 105, 109, 101, 46,
				80, 97, 115, 115, 101, 115, 124, 71, 105, 122,
				109, 111, 115, 80, 97, 115, 115, 0, 0, 0,
				0, 63, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 46, 82, 117, 110, 116, 105, 109, 101, 46,
				80, 97, 115, 115, 101, 115, 46, 76, 105, 103,
				104, 116, 105, 110, 103, 124, 65, 100, 100, 105,
				116, 105, 111, 110, 97, 108, 76, 105, 103, 104,
				116, 68, 97, 116, 97, 0, 0, 0, 0, 64,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 46,
				82, 117, 110, 116, 105, 109, 101, 46, 80, 97,
				115, 115, 101, 115, 46, 76, 105, 103, 104, 116,
				105, 110, 103, 124, 65, 100, 100, 105, 116, 105,
				111, 110, 97, 108, 83, 104, 97, 100, 111, 119,
				68, 97, 116, 97, 0, 0, 0, 0, 72, 82,
				117, 115, 116, 46, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 46, 82,
				117, 110, 116, 105, 109, 101, 46, 80, 97, 115,
				115, 101, 115, 46, 76, 105, 103, 104, 116, 105,
				110, 103, 124, 68, 101, 102, 101, 114, 114, 101,
				100, 73, 110, 100, 105, 114, 101, 99, 116, 76,
				105, 103, 104, 116, 105, 110, 103, 80, 97, 115,
				115, 0, 0, 0, 0, 64, 82, 117, 115, 116,
				46, 82, 101, 110, 100, 101, 114, 80, 105, 112,
				101, 108, 105, 110, 101, 46, 82, 117, 110, 116,
				105, 109, 101, 46, 80, 97, 115, 115, 101, 115,
				46, 76, 105, 103, 104, 116, 105, 110, 103, 124,
				68, 101, 102, 101, 114, 114, 101, 100, 76, 105,
				103, 104, 116, 105, 110, 103, 80, 97, 115, 115,
				0, 0, 0, 0, 64, 82, 117, 115, 116, 46,
				82, 101, 110, 100, 101, 114, 80, 105, 112, 101,
				108, 105, 110, 101, 46, 82, 117, 110, 116, 105,
				109, 101, 46, 80, 97, 115, 115, 101, 115, 46,
				76, 105, 103, 104, 116, 105, 110, 103, 124, 68,
				105, 114, 101, 99, 116, 105, 111, 110, 97, 108,
				76, 105, 103, 104, 116, 68, 97, 116, 97, 0,
				0, 0, 0, 68, 82, 117, 115, 116, 46, 82,
				101, 110, 100, 101, 114, 80, 105, 112, 101, 108,
				105, 110, 101, 46, 82, 117, 110, 116, 105, 109,
				101, 46, 80, 97, 115, 115, 101, 115, 46, 76,
				105, 103, 104, 116, 105, 110, 103, 124, 68, 105,
				114, 101, 99, 116, 105, 111, 110, 97, 108, 83,
				104, 97, 100, 111, 119, 67, 97, 115, 99, 97,
				100, 101, 0, 0, 0, 0, 63, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 46, 82, 117, 110,
				116, 105, 109, 101, 46, 80, 97, 115, 115, 101,
				115, 46, 76, 105, 103, 104, 116, 105, 110, 103,
				124, 70, 111, 114, 119, 97, 114, 100, 80, 108,
				117, 115, 84, 105, 108, 101, 115, 74, 111, 98,
				0, 0, 0, 0, 62, 82, 117, 115, 116, 46,
				82, 101, 110, 100, 101, 114, 80, 105, 112, 101,
				108, 105, 110, 101, 46, 82, 117, 110, 116, 105,
				109, 101, 46, 80, 97, 115, 115, 101, 115, 46,
				76, 105, 103, 104, 116, 105, 110, 103, 124, 76,
				105, 103, 104, 116, 67, 111, 111, 107, 105, 101,
				77, 97, 110, 97, 103, 101, 114, 0, 0, 0,
				0, 77, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 46, 82, 117, 110, 116, 105, 109, 101, 46,
				80, 97, 115, 115, 101, 115, 46, 76, 105, 103,
				104, 116, 105, 110, 103, 46, 76, 105, 103, 104,
				116, 67, 111, 111, 107, 105, 101, 77, 97, 110,
				97, 103, 101, 114, 124, 83, 104, 97, 100, 101,
				114, 80, 114, 111, 112, 101, 114, 116, 121, 0,
				0, 0, 0, 71, 82, 117, 115, 116, 46, 82,
				101, 110, 100, 101, 114, 80, 105, 112, 101, 108,
				105, 110, 101, 46, 82, 117, 110, 116, 105, 109,
				101, 46, 80, 97, 115, 115, 101, 115, 46, 76,
				105, 103, 104, 116, 105, 110, 103, 46, 76, 105,
				103, 104, 116, 67, 111, 111, 107, 105, 101, 77,
				97, 110, 97, 103, 101, 114, 124, 83, 101, 116,
				116, 105, 110, 103, 115, 0, 0, 0, 0, 77,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 46,
				82, 117, 110, 116, 105, 109, 101, 46, 80, 97,
				115, 115, 101, 115, 46, 76, 105, 103, 104, 116,
				105, 110, 103, 46, 76, 105, 103, 104, 116, 67,
				111, 111, 107, 105, 101, 77, 97, 110, 97, 103,
				101, 114, 43, 124, 65, 116, 108, 97, 115, 83,
				101, 116, 116, 105, 110, 103, 115, 0, 0, 0,
				0, 70, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 46, 82, 117, 110, 116, 105, 109, 101, 46,
				80, 97, 115, 115, 101, 115, 46, 76, 105, 103,
				104, 116, 105, 110, 103, 46, 76, 105, 103, 104,
				116, 67, 111, 111, 107, 105, 101, 77, 97, 110,
				97, 103, 101, 114, 124, 83, 111, 114, 116, 105,
				110, 103, 0, 0, 0, 0, 81, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 46, 82, 117, 110,
				116, 105, 109, 101, 46, 80, 97, 115, 115, 101,
				115, 46, 76, 105, 103, 104, 116, 105, 110, 103,
				46, 76, 105, 103, 104, 116, 67, 111, 111, 107,
				105, 101, 77, 97, 110, 97, 103, 101, 114, 124,
				76, 105, 103, 104, 116, 67, 111, 111, 107, 105,
				101, 77, 97, 112, 112, 105, 110, 103, 0, 0,
				0, 0, 72, 82, 117, 115, 116, 46, 82, 101,
				110, 100, 101, 114, 80, 105, 112, 101, 108, 105,
				110, 101, 46, 82, 117, 110, 116, 105, 109, 101,
				46, 80, 97, 115, 115, 101, 115, 46, 76, 105,
				103, 104, 116, 105, 110, 103, 46, 76, 105, 103,
				104, 116, 67, 111, 111, 107, 105, 101, 77, 97,
				110, 97, 103, 101, 114, 124, 87, 111, 114, 107,
				83, 108, 105, 99, 101, 0, 0, 0, 0, 73,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 46,
				82, 117, 110, 116, 105, 109, 101, 46, 80, 97,
				115, 115, 101, 115, 46, 76, 105, 103, 104, 116,
				105, 110, 103, 46, 76, 105, 103, 104, 116, 67,
				111, 111, 107, 105, 101, 77, 97, 110, 97, 103,
				101, 114, 124, 87, 111, 114, 107, 77, 101, 109,
				111, 114, 121, 0, 0, 0, 0, 84, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 46, 82, 117,
				110, 116, 105, 109, 101, 46, 80, 97, 115, 115,
				101, 115, 46, 76, 105, 103, 104, 116, 105, 110,
				103, 46, 76, 105, 103, 104, 116, 67, 111, 111,
				107, 105, 101, 77, 97, 110, 97, 103, 101, 114,
				124, 76, 105, 103, 104, 116, 67, 111, 111, 107,
				105, 101, 83, 104, 97, 100, 101, 114, 68, 97,
				116, 97, 0, 0, 0, 0, 56, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 46, 82, 117, 110,
				116, 105, 109, 101, 46, 80, 97, 115, 115, 101,
				115, 46, 76, 105, 103, 104, 116, 105, 110, 103,
				124, 76, 105, 103, 104, 116, 105, 110, 103, 80,
				97, 115, 115, 0, 0, 0, 0, 58, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 46, 82, 117,
				110, 116, 105, 109, 101, 46, 80, 97, 115, 115,
				101, 115, 46, 76, 105, 103, 104, 116, 105, 110,
				103, 124, 83, 104, 97, 100, 101, 114, 66, 105,
				116, 65, 114, 114, 97, 121, 0, 0, 0, 0,
				51, 82, 117, 115, 116, 46, 82, 101, 110, 100,
				101, 114, 80, 105, 112, 101, 108, 105, 110, 101,
				46, 82, 117, 110, 116, 105, 109, 101, 46, 80,
				97, 115, 115, 101, 115, 46, 76, 105, 103, 104,
				116, 105, 110, 103, 124, 83, 104, 97, 100, 111,
				119, 115, 0, 0, 0, 0, 76, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 46, 82, 117, 110,
				116, 105, 109, 101, 46, 80, 97, 115, 115, 101,
				115, 46, 76, 105, 103, 104, 116, 105, 110, 103,
				46, 83, 104, 97, 100, 111, 119, 115, 124, 83,
				104, 97, 100, 111, 119, 101, 100, 68, 105, 114,
				101, 99, 116, 105, 111, 110, 97, 108, 76, 105,
				103, 104, 116, 0, 0, 0, 0, 75, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 46, 82, 117,
				110, 116, 105, 109, 101, 46, 80, 97, 115, 115,
				101, 115, 46, 76, 105, 103, 104, 116, 105, 110,
				103, 46, 83, 104, 97, 100, 111, 119, 115, 124,
				83, 104, 97, 100, 111, 119, 101, 100, 65, 100,
				100, 105, 116, 105, 111, 110, 97, 108, 76, 105,
				103, 104, 116, 0, 0, 0, 0, 59, 82, 117,
				115, 116, 46, 82, 101, 110, 100, 101, 114, 80,
				105, 112, 101, 108, 105, 110, 101, 46, 82, 117,
				110, 116, 105, 109, 101, 46, 80, 97, 115, 115,
				101, 115, 46, 80, 111, 115, 116, 80, 114, 111,
				99, 101, 115, 115, 105, 110, 103, 124, 66, 108,
				111, 111, 109, 80, 97, 115, 115, 0, 0, 0,
				0, 62, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 46, 82, 117, 110, 116, 105, 109, 101, 46,
				80, 97, 115, 115, 101, 115, 46, 80, 111, 115,
				116, 80, 114, 111, 99, 101, 115, 115, 105, 110,
				103, 124, 67, 111, 108, 111, 114, 76, 117, 116,
				80, 97, 115, 115, 0, 0, 0, 0, 63, 82,
				117, 115, 116, 46, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 46, 82,
				117, 110, 116, 105, 109, 101, 46, 80, 97, 115,
				115, 101, 115, 46, 80, 111, 115, 116, 80, 114,
				111, 99, 101, 115, 115, 105, 110, 103, 124, 80,
				111, 115, 116, 70, 88, 66, 108, 105, 116, 116,
				101, 114, 0, 0, 0, 0, 60, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 46, 82, 117, 110,
				116, 105, 109, 101, 46, 80, 97, 115, 115, 101,
				115, 46, 80, 111, 115, 116, 80, 114, 111, 99,
				101, 115, 115, 105, 110, 103, 124, 80, 111, 115,
				116, 70, 88, 80, 97, 115, 115, 0, 0, 0,
				0, 44, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 46, 82, 117, 110, 116, 105, 109, 101, 46,
				80, 97, 115, 115, 101, 115, 124, 83, 101, 116,
				117, 112, 80, 97, 115, 115, 0, 0, 0, 0,
				45, 82, 117, 115, 116, 46, 82, 101, 110, 100,
				101, 114, 80, 105, 112, 101, 108, 105, 110, 101,
				46, 82, 117, 110, 116, 105, 109, 101, 46, 80,
				97, 115, 115, 101, 115, 124, 83, 107, 121, 98,
				111, 120, 80, 97, 115, 115, 0, 0, 0, 0,
				57, 82, 117, 115, 116, 46, 82, 101, 110, 100,
				101, 114, 80, 105, 112, 101, 108, 105, 110, 101,
				46, 82, 117, 110, 116, 105, 109, 101, 46, 80,
				97, 115, 115, 101, 115, 124, 85, 110, 115, 117,
				112, 112, 111, 114, 116, 101, 100, 83, 104, 97,
				100, 101, 114, 115, 80, 97, 115, 115, 0, 0,
				0, 0, 41, 82, 117, 115, 116, 46, 82, 101,
				110, 100, 101, 114, 80, 105, 112, 101, 108, 105,
				110, 101, 46, 82, 117, 110, 116, 105, 109, 101,
				124, 80, 105, 112, 101, 108, 105, 110, 101, 85,
				116, 105, 108, 115, 0, 0, 0, 0, 42, 82,
				117, 115, 116, 46, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 46, 82,
				117, 110, 116, 105, 109, 101, 124, 80, 111, 115,
				116, 70, 88, 83, 101, 116, 116, 105, 110, 103,
				115, 0, 0, 0, 0, 56, 82, 117, 115, 116,
				46, 82, 101, 110, 100, 101, 114, 80, 105, 112,
				101, 108, 105, 110, 101, 46, 82, 117, 110, 116,
				105, 109, 101, 46, 80, 111, 115, 116, 70, 88,
				83, 101, 116, 116, 105, 110, 103, 115, 124, 66,
				108, 111, 111, 109, 83, 101, 116, 116, 105, 110,
				103, 115, 0, 0, 0, 0, 67, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 46, 82, 117, 110,
				116, 105, 109, 101, 46, 80, 111, 115, 116, 70,
				88, 83, 101, 116, 116, 105, 110, 103, 115, 124,
				67, 111, 108, 111, 114, 65, 100, 106, 117, 115,
				116, 109, 101, 110, 116, 115, 83, 101, 116, 116,
				105, 110, 103, 115, 0, 0, 0, 0, 63, 82,
				117, 115, 116, 46, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 46, 82,
				117, 110, 116, 105, 109, 101, 46, 80, 111, 115,
				116, 70, 88, 83, 101, 116, 116, 105, 110, 103,
				115, 124, 67, 104, 97, 110, 110, 101, 108, 77,
				105, 120, 101, 114, 83, 101, 116, 116, 105, 110,
				103, 115, 0, 0, 0, 0, 63, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 46, 82, 117, 110,
				116, 105, 109, 101, 46, 80, 111, 115, 116, 70,
				88, 83, 101, 116, 116, 105, 110, 103, 115, 124,
				87, 104, 105, 116, 101, 66, 97, 108, 97, 110,
				99, 101, 83, 101, 116, 116, 105, 110, 103, 115,
				0, 0, 0, 0, 62, 82, 117, 115, 116, 46,
				82, 101, 110, 100, 101, 114, 80, 105, 112, 101,
				108, 105, 110, 101, 46, 82, 117, 110, 116, 105,
				109, 101, 46, 80, 111, 115, 116, 70, 88, 83,
				101, 116, 116, 105, 110, 103, 115, 124, 83, 112,
				108, 105, 116, 84, 111, 110, 105, 110, 103, 83,
				101, 116, 116, 105, 110, 103, 115, 0, 0, 0,
				0, 62, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 46, 82, 117, 110, 116, 105, 109, 101, 46,
				80, 111, 115, 116, 70, 88, 83, 101, 116, 116,
				105, 110, 103, 115, 124, 84, 111, 110, 101, 77,
				97, 112, 112, 105, 110, 103, 83, 101, 116, 116,
				105, 110, 103, 115, 0, 0, 0, 0, 76, 82,
				117, 115, 116, 46, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 46, 82,
				117, 110, 116, 105, 109, 101, 46, 80, 111, 115,
				116, 70, 88, 83, 101, 116, 116, 105, 110, 103,
				115, 124, 83, 104, 97, 100, 111, 119, 115, 77,
				105, 100, 116, 111, 110, 101, 115, 72, 105, 103,
				104, 108, 105, 103, 104, 116, 115, 83, 101, 116,
				116, 105, 110, 103, 115, 0, 0, 0, 0, 49,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 46,
				82, 117, 110, 116, 105, 109, 101, 124, 82, 101,
				105, 110, 116, 101, 114, 112, 114, 101, 116, 69,
				120, 116, 101, 110, 115, 105, 111, 110, 115, 0,
				0, 0, 0, 58, 82, 117, 115, 116, 46, 82,
				101, 110, 100, 101, 114, 80, 105, 112, 101, 108,
				105, 110, 101, 46, 82, 117, 110, 116, 105, 109,
				101, 46, 82, 101, 105, 110, 116, 101, 114, 112,
				114, 101, 116, 69, 120, 116, 101, 110, 115, 105,
				111, 110, 115, 124, 73, 110, 116, 70, 108, 111,
				97, 116, 0, 0, 0, 0, 62, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 46, 82, 117, 110,
				116, 105, 109, 101, 46, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 67, 111, 110, 116, 101, 120,
				116, 124, 82, 117, 115, 116, 67, 97, 109, 101,
				114, 97, 67, 111, 110, 116, 101, 120, 116, 0,
				0, 0, 0, 65, 82, 117, 115, 116, 46, 82,
				101, 110, 100, 101, 114, 80, 105, 112, 101, 108,
				105, 110, 101, 46, 82, 117, 110, 116, 105, 109,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 67, 111, 110, 116, 101, 120, 116, 124, 82,
				117, 115, 116, 82, 101, 110, 100, 101, 114, 105,
				110, 103, 67, 111, 110, 116, 101, 120, 116, 0,
				0, 0, 0, 68, 82, 117, 115, 116, 46, 82,
				101, 110, 100, 101, 114, 80, 105, 112, 101, 108,
				105, 110, 101, 46, 82, 117, 110, 116, 105, 109,
				101, 46, 82, 101, 110, 100, 101, 114, 105, 110,
				103, 67, 111, 110, 116, 101, 120, 116, 124, 82,
				117, 115, 116, 82, 101, 115, 111, 117, 114, 99,
				101, 68, 97, 116, 97, 67, 111, 110, 116, 101,
				120, 116, 0, 0, 0, 0, 60, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 46, 82, 117, 110,
				116, 105, 109, 101, 124, 82, 101, 110, 100, 101,
				114, 105, 110, 103, 76, 97, 121, 101, 114, 77,
				97, 115, 107, 70, 105, 101, 108, 100, 65, 116,
				116, 114, 105, 98, 117, 116, 101, 0, 0, 0,
				0, 54, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 46, 82, 117, 110, 116, 105, 109, 101, 124,
				82, 101, 110, 100, 101, 114, 80, 97, 115, 115,
				69, 118, 101, 110, 116, 115, 69, 110, 117, 109,
				86, 97, 108, 117, 101, 115, 0, 0, 0, 0,
				40, 82, 117, 115, 116, 46, 82, 101, 110, 100,
				101, 114, 80, 105, 112, 101, 108, 105, 110, 101,
				46, 82, 117, 110, 116, 105, 109, 101, 124, 82,
				117, 115, 116, 82, 101, 110, 100, 101, 114, 101,
				114, 0, 0, 0, 0, 44, 82, 117, 115, 116,
				46, 82, 101, 110, 100, 101, 114, 80, 105, 112,
				101, 108, 105, 110, 101, 46, 82, 117, 110, 116,
				105, 109, 101, 124, 82, 117, 115, 116, 82, 101,
				110, 100, 101, 114, 101, 114, 68, 97, 116, 97,
				0, 0, 0, 0, 47, 82, 117, 115, 116, 46,
				82, 101, 110, 100, 101, 114, 80, 105, 112, 101,
				108, 105, 110, 101, 46, 82, 117, 110, 116, 105,
				109, 101, 124, 82, 117, 115, 116, 82, 101, 110,
				100, 101, 114, 101, 114, 70, 101, 97, 116, 117,
				114, 101, 0, 0, 0, 0, 42, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 46, 82, 117, 110,
				116, 105, 109, 101, 124, 82, 117, 115, 116, 82,
				101, 110, 100, 101, 114, 80, 97, 115, 115, 0,
				0, 0, 0, 46, 82, 117, 115, 116, 46, 82,
				101, 110, 100, 101, 114, 80, 105, 112, 101, 108,
				105, 110, 101, 46, 82, 117, 110, 116, 105, 109,
				101, 124, 82, 117, 115, 116, 82, 101, 110, 100,
				101, 114, 80, 105, 112, 101, 108, 105, 110, 101,
				0, 0, 0, 0, 64, 82, 117, 115, 116, 46,
				82, 101, 110, 100, 101, 114, 80, 105, 112, 101,
				108, 105, 110, 101, 46, 82, 117, 110, 116, 105,
				109, 101, 46, 82, 117, 115, 116, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 124, 80, 105, 112, 101, 108, 105, 110, 101,
				77, 97, 116, 101, 114, 105, 97, 108, 115, 1,
				0, 0, 0, 51, 82, 117, 115, 116, 46, 82,
				101, 110, 100, 101, 114, 80, 105, 112, 101, 108,
				105, 110, 101, 46, 82, 117, 110, 116, 105, 109,
				101, 124, 82, 117, 115, 116, 82, 101, 110, 100,
				101, 114, 80, 105, 112, 101, 108, 105, 110, 101,
				65, 115, 115, 101, 116, 1, 0, 0, 0, 51,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 46,
				82, 117, 110, 116, 105, 109, 101, 124, 82, 117,
				115, 116, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 65, 115, 115, 101,
				116, 0, 0, 0, 0, 52, 82, 117, 115, 116,
				46, 82, 101, 110, 100, 101, 114, 80, 105, 112,
				101, 108, 105, 110, 101, 46, 82, 117, 110, 116,
				105, 109, 101, 124, 82, 117, 115, 116, 82, 101,
				110, 100, 101, 114, 80, 105, 112, 101, 108, 105,
				110, 101, 67, 97, 109, 101, 114, 97, 0, 0,
				0, 0, 54, 82, 117, 115, 116, 46, 82, 101,
				110, 100, 101, 114, 80, 105, 112, 101, 108, 105,
				110, 101, 46, 82, 117, 110, 116, 105, 109, 101,
				124, 82, 117, 115, 116, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 83,
				101, 116, 116, 105, 110, 103, 115, 0, 0, 0,
				0, 70, 82, 117, 115, 116, 46, 82, 101, 110,
				100, 101, 114, 80, 105, 112, 101, 108, 105, 110,
				101, 46, 82, 117, 110, 116, 105, 109, 101, 46,
				82, 117, 115, 116, 82, 101, 110, 100, 101, 114,
				80, 105, 112, 101, 108, 105, 110, 101, 83, 101,
				116, 116, 105, 110, 103, 115, 124, 80, 105, 112,
				101, 108, 105, 110, 101, 83, 104, 97, 100, 101,
				114, 115, 0, 0, 0, 0, 71, 82, 117, 115,
				116, 46, 82, 101, 110, 100, 101, 114, 80, 105,
				112, 101, 108, 105, 110, 101, 46, 82, 117, 110,
				116, 105, 109, 101, 46, 82, 117, 115, 116, 82,
				101, 110, 100, 101, 114, 80, 105, 112, 101, 108,
				105, 110, 101, 83, 101, 116, 116, 105, 110, 103,
				115, 124, 80, 105, 112, 101, 108, 105, 110, 101,
				84, 101, 120, 116, 117, 114, 101, 115, 0, 0,
				0, 0, 42, 82, 117, 115, 116, 46, 82, 101,
				110, 100, 101, 114, 80, 105, 112, 101, 108, 105,
				110, 101, 46, 82, 117, 110, 116, 105, 109, 101,
				124, 83, 104, 97, 100, 111, 119, 83, 101, 116,
				116, 105, 110, 103, 115, 0, 0, 0, 0, 59,
				82, 117, 115, 116, 46, 82, 101, 110, 100, 101,
				114, 80, 105, 112, 101, 108, 105, 110, 101, 46,
				82, 117, 110, 116, 105, 109, 101, 46, 83, 104,
				97, 100, 111, 119, 83, 101, 116, 116, 105, 110,
				103, 115, 124, 68, 105, 114, 101, 99, 116, 105,
				111, 110, 97, 108, 76, 105, 103, 104, 116, 0,
				0, 0, 0, 58, 82, 117, 115, 116, 46, 82,
				101, 110, 100, 101, 114, 80, 105, 112, 101, 108,
				105, 110, 101, 46, 82, 117, 110, 116, 105, 109,
				101, 46, 83, 104, 97, 100, 111, 119, 83, 101,
				116, 116, 105, 110, 103, 115, 124, 65, 100, 100,
				105, 116, 105, 111, 110, 97, 108, 76, 105, 103,
				104, 116
			},
			TotalFiles = 51,
			TotalTypes = 79,
			IsEditorOnly = false
		};
	}
}
namespace Rust.RenderPipeline.Runtime
{
	[Serializable]
	public struct CameraBufferSettings
	{
		[Serializable]
		public struct FxaaSettings
		{
			public enum Quality
			{
				Low,
				Medium,
				High
			}

			public bool enabled;

			public Quality quality;

			[Range(0.0312f, 0.0833f)]
			public float fixedThreshold;

			[Range(0.063f, 0.333f)]
			public float relativeThreshold;

			[Range(0f, 1f)]
			public float subpixelBlending;
		}

		public enum BicubicRescalingMode
		{
			Off,
			UpOnly,
			UpAndDown
		}

		public bool allowHDR;

		public bool copyColor;

		public bool copyColorReflection;

		public bool copyDepth;

		public bool copyDepthReflection;

		[Range(0.1f, 2f)]
		public float renderScale;

		public BicubicRescalingMode bicubicRescaling;

		public FxaaSettings fxaaSettings;
	}
	public class CameraDebugger
	{
		private enum ShaderPasses
		{
			GBufferRendering,
			IndirectLightingRendering,
			ForwardPlusTiles
		}

		private enum GBufferTarget
		{
			None,
			GBuffer0,
			GBuffer1,
			GBuffer2,
			GBuffer3
		}

		private enum DeferredIndirectLightingTarget
		{
			None,
			Diffuse,
			Specular
		}

		private const string FORWARD_PLUS_PANEL_NAME = "Forward+";

		private const string DEFERRED_PANEL_NAME = "Deferred";

		private static readonly int opacityID = Shader.PropertyToID("_DebugOpacity");

		private static readonly int selectedGBufferTextureId = Shader.PropertyToID("_SelectedGBufferTexture");

		private static readonly int showGBufferTargetAlphaId = Shader.PropertyToID("_ShowGBufferTargetAlpha");

		private static readonly int selectedIndirectLightingTextureId = Shader.PropertyToID("_SelectedIndirectLightingTexture");

		private static readonly int showIndirectLightingAlphaId = Shader.PropertyToID("_ShowIndirectLightingAlpha");

		private static Material material;

		private static bool showTiles;

		private static float opacity = 0.5f;

		private static GBufferTarget gBufferTarget;

		private static bool showGBufferTargetAlpha;

		private static DeferredIndirectLightingTarget indirectLightingTarget;

		private static bool showIndirectLightingAlpha;

		public static bool IsActive
		{
			get
			{
				if ((!showTiles || !(opacity > 0f)) && gBufferTarget == GBufferTarget.None)
				{
					return indirectLightingTarget != DeferredIndirectLightingTarget.None;
				}
				return true;
			}
		}

		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("UNITY_EDITOR")]
		public static void Initialize(Material cameraDebuggerMaterial)
		{
			material = cameraDebuggerMaterial;
			DebugManager.instance.GetPanel("Forward+", createIfNull: true).children.Add(new DebugUI.FloatField
			{
				displayName = "Opacity",
				tooltip = "Opacity of the debug overlay.",
				min = () => 0f,
				max = () => 1f,
				getter = () => opacity,
				setter = delegate(float value)
				{
					opacity = value;
				}
			}, new DebugUI.BoolField
			{
				displayName = "Show Tiles",
				tooltip = "Whether the debug overlay is shown.",
				getter = () => showTiles,
				setter = delegate(bool value)
				{
					showTiles = value;
				}
			});
			DebugManager.instance.GetPanel("Deferred", createIfNull: true).children.Add(new DebugUI.EnumField
			{
				displayName = "Show GBuffer Output",
				tooltip = "Displays the output of the selected GBuffer render target.",
				getIndex = () => (int)gBufferTarget,
				setIndex = delegate(int value)
				{
					gBufferTarget = (GBufferTarget)value;
				},
				getter = () => (int)gBufferTarget,
				setter = delegate(int value)
				{
					gBufferTarget = (GBufferTarget)value;
				},
				autoEnum = typeof(GBufferTarget)
			}, new DebugUI.BoolField
			{
				displayName = "Show GBuffer Target Alpha",
				tooltip = "Whether the selected GBuffer target is displaying the alpha of the texture rather than RGB.",
				getter = () => showGBufferTargetAlpha,
				setter = delegate(bool value)
				{
					showGBufferTargetAlpha = value;
				}
			}, new DebugUI.EnumField
			{
				displayName = "Show Deferred Indirect Lighting Target",
				tooltip = "Displays the selected deferred indirect lighting render target.",
				getIndex = () => (int)indirectLightingTarget,
				setIndex = delegate(int value)
				{
					indirectLightingTarget = (DeferredIndirectLightingTarget)value;
				},
				getter = () => (int)indirectLightingTarget,
				setter = delegate(int value)
				{
					indirectLightingTarget = (DeferredIndirectLightingTarget)value;
				},
				autoEnum = typeof(DeferredIndirectLightingTarget)
			}, new DebugUI.BoolField
			{
				displayName = "Show Indirect Lighting Target Alpha",
				tooltip = "Whether the selected Indirect Lighting target is displaying the alpha of the texture rather than RGB.",
				getter = () => showIndirectLightingAlpha,
				setter = delegate(bool value)
				{
					showIndirectLightingAlpha = value;
				}
			});
		}

		private static void DrawFullscreenEffect(CommandBuffer cmd, ShaderPasses pass)
		{
			cmd.DrawProcedural(Matrix4x4.identity, material, (int)pass, MeshTopology.Triangles, 3);
		}

		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("UNITY_EDITOR")]
		public static void Render(RenderGraphContext context, DebugPass pass)
		{
			CommandBuffer cmd = context.cmd;
			if (gBufferTarget != GBufferTarget.None)
			{
				cmd.SetGlobalTexture(selectedGBufferTextureId, pass.gBufferHandles[(int)(gBufferTarget - 1)]);
				cmd.SetGlobalInt(showGBufferTargetAlphaId, showGBufferTargetAlpha ? 1 : 0);
				DrawFullscreenEffect(cmd, ShaderPasses.GBufferRendering);
			}
			if (indirectLightingTarget != DeferredIndirectLightingTarget.None)
			{
				TextureHandle textureHandle = indirectLightingTarget switch
				{
					DeferredIndirectLightingTarget.Diffuse => pass.indirectDiffuseHandle, 
					DeferredIndirectLightingTarget.Specular => pass.indirectSpecularHandle, 
					DeferredIndirectLightingTarget.None => TextureHandle.nullHandle, 
					_ => TextureHandle.nullHandle, 
				};
				cmd.SetGlobalTexture(selectedIndirectLightingTextureId, textureHandle);
				cmd.SetGlobalInt(showIndirectLightingAlphaId, showIndirectLightingAlpha ? 1 : 0);
				DrawFullscreenEffect(cmd, ShaderPasses.IndirectLightingRendering);
			}
			if (showTiles)
			{
				cmd.SetGlobalFloat(opacityID, opacity);
				DrawFullscreenEffect(cmd, ShaderPasses.ForwardPlusTiles);
			}
			context.renderContext.ExecuteCommandBuffer(cmd);
			cmd.Clear();
		}

		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("UNITY_EDITOR")]
		public static void Cleanup()
		{
			DebugManager.instance.RemovePanel("Forward+");
			DebugManager.instance.RemovePanel("Deferred");
		}
	}
	public class CameraRenderer
	{
		public const float RENDERSCALE_MIN = 0.1f;

		public const float RENDERSCALE_MAX = 2f;

		private static readonly CameraSettings defaultCameraSettings = new CameraSettings();

		private readonly RustRenderPipeline.PipelineMaterials pipelineMaterials;

		private RustRenderer rustRenderer;

		private LightCookieManager lightCookieManager;

		public CameraRenderer(RustRenderPipeline.PipelineMaterials pipelineMaterials)
		{
			this.pipelineMaterials = pipelineMaterials;
			LightCookieManager.Settings settings = LightCookieManager.Settings.Create();
			lightCookieManager = new LightCookieManager(ref settings);
		}

		public void Render(RenderGraph renderGraph, ScriptableRenderContext context, Camera camera, RustRenderPipelineSettings settings, RustRendererData rustRendererData)
		{
			CameraBufferSettings cameraBuffer = settings.cameraBuffer;
			PostFXSettings postFXSettings = settings.postFXSettings;
			ShadowSettings shadows = settings.shadows;
			if (rustRenderer == null)
			{
				rustRenderer = new RustRenderer();
			}
			rustRenderer.Initialize(rustRendererData);
			ProfilingSampler profilingSampler;
			CameraSettings settings2;
			if (camera.TryGetComponent<RustRenderPipelineCamera>(out var component))
			{
				profilingSampler = component.Sampler;
				settings2 = component.Settings;
			}
			else
			{
				profilingSampler = ProfilingSampler.Get(camera.cameraType);
				settings2 = defaultCameraSettings;
			}
			if (settings2.overridePostFX)
			{
				postFXSettings = settings2.postFXSettings;
			}
			bool postProcessingActive = settings.postProcessingEnabled && settings2.postProcessingEnabled && postFXSettings != null && PostFXSettings.AreApplicableTo(camera);
			bool useOpaqueColorTexture;
			bool useDepthTexture;
			if (camera.cameraType == CameraType.Reflection)
			{
				useOpaqueColorTexture = cameraBuffer.copyColorReflection;
				useDepthTexture = cameraBuffer.copyDepthReflection || settings.renderPath == RustRenderPipelineSettings.RenderPath.Deferred;
			}
			else
			{
				useOpaqueColorTexture = cameraBuffer.copyColor && settings2.copyColor;
				useDepthTexture = (cameraBuffer.copyDepth && settings2.copyDepth) || settings.renderPath == RustRenderPipelineSettings.RenderPath.Deferred;
			}
			float renderScale = settings2.GetRenderScale(cameraBuffer.renderScale);
			bool flag = !Mathf.Approximately(renderScale, 1f);
			if (!camera.TryGetCullingParameters(out var cullingParameters))
			{
				return;
			}
			cullingParameters.shadowDistance = Mathf.Min(shadows.maxDistance, camera.farClipPlane);
			CullingResults cullResults = context.Cull(ref cullingParameters);
			cameraBuffer.allowHDR &= camera.allowHDR;
			Vector2Int cameraBufferSize = default(Vector2Int);
			if (flag)
			{
				renderScale = Mathf.Clamp(renderScale, 0.1f, 2f);
				cameraBufferSize.x = (int)((float)camera.pixelWidth * renderScale);
				cameraBufferSize.y = (int)((float)camera.pixelHeight * renderScale);
			}
			else
			{
				cameraBufferSize.x = camera.pixelWidth;
				cameraBufferSize.y = camera.pixelHeight;
			}
			cameraBuffer.fxaaSettings.enabled &= settings2.allowFXAA;
			using ContextContainer contextContainer = rustRenderer.FrameData;
			RustRenderingContext rustRenderingContext = contextContainer.Create<RustRenderingContext>();
			rustRenderingContext.cullResults = cullResults;
			rustRenderingContext.pipelineSettings = settings;
			RustCameraContext rustCameraContext = contextContainer.Create<RustCameraContext>();
			rustCameraContext.Camera = camera;
			rustCameraContext.CameraSettings = settings2;
			rustCameraContext.CameraBufferSettings = cameraBuffer;
			rustCameraContext.CameraBufferSize = cameraBufferSize;
			rustCameraContext.UseOpaqueColorTexture = useOpaqueColorTexture;
			rustCameraContext.UseDepthTexture = useDepthTexture;
			rustCameraContext.PostProcessingActive = postProcessingActive;
			rustCameraContext.PostFXSettings = postFXSettings;
			RustResourceDataContext rustResourceDataContext = contextContainer.Create<RustResourceDataContext>();
			rustRenderer.AddRenderPasses();
			RenderGraphParameters parameters = new RenderGraphParameters
			{
				commandBuffer = CommandBufferPool.Get(),
				currentFrameIndex = Time.frameCount,
				executionName = profilingSampler.name,
				rendererListCulling = true,
				scriptableRenderContext = context
			};
			using (renderGraph.RecordAndExecute(in parameters))
			{
				using (new RenderGraphProfilingScope(renderGraph, profilingSampler))
				{
					rustResourceDataContext.InitFrame();
					switch (settings.renderPath)
					{
					case RustRenderPipelineSettings.RenderPath.ForwardPlus:
						ForwardPlusRenderPath(renderGraph);
						break;
					case RustRenderPipelineSettings.RenderPath.Deferred:
						DeferredRenderPath(renderGraph);
						break;
					default:
						throw new ArgumentOutOfRangeException();
					}
					rustResourceDataContext.EndFrame();
				}
			}
			context.ExecuteCommandBuffer(parameters.commandBuffer);
			context.Submit();
			CommandBufferPool.Release(parameters.commandBuffer);
		}

		private void ForwardPlusRenderPath(RenderGraph renderGraph)
		{
			ContextContainer frameData = rustRenderer.FrameData;
			RustCameraContext rustCameraContext = frameData.Get<RustCameraContext>();
			CameraRendererCopier copier = new CameraRendererCopier(pipelineMaterials.cameraRendererMaterial, rustCameraContext.Camera, rustCameraContext.CameraSettings.finalBlendMode);
			LightingPass.Record(renderGraph, frameData, lightCookieManager);
			SetupPass.Record(renderGraph, frameData);
			GeometryPass.Record(renderGraph, frameData, opaque: true);
			SkyboxPass.Record(renderGraph, frameData);
			CopyAttachmentsPass.Record(renderGraph, frameData, rustCameraContext.UseOpaqueColorTexture, rustCameraContext.UseDepthTexture, copier);
			GeometryPass.Record(renderGraph, frameData, opaque: false);
			if (rustCameraContext.PostProcessingActive)
			{
				PostFXPass.Record(renderGraph, frameData);
			}
			else
			{
				FinalPass.Record(renderGraph, frameData, copier);
			}
		}

		private void DeferredRenderPath(RenderGraph renderGraph)
		{
			ContextContainer frameData = rustRenderer.FrameData;
			RustCameraContext rustCameraContext = frameData.Get<RustCameraContext>();
			CameraRendererCopier copier = new CameraRendererCopier(pipelineMaterials.cameraRendererMaterial, rustCameraContext.Camera, rustCameraContext.CameraSettings.finalBlendMode);
			rustRenderer.RecordCustomRenderGraphPasses(renderGraph, RenderPassEvent.BeforeRendering, RenderPassEvent.BeforeRenderingShadows);
			LightingPass.Record(renderGraph, frameData, lightCookieManager);
			rustRenderer.RecordCustomRenderGraphPasses(renderGraph, RenderPassEvent.AfterRenderingShadows);
			SetupPass.Record(renderGraph, frameData);
			rustRenderer.RecordCustomRenderGraphPasses(renderGraph, RenderPassEvent.BeforeRenderingPrePasses, RenderPassEvent.AfterRenderingPrePasses);
			rustRenderer.RecordCustomRenderGraphPasses(renderGraph, RenderPassEvent.BeforeRenderingGBuffer);
			GBufferPass.Record(renderGraph, frameData);
			CopyAttachmentsPass.Record(renderGraph, frameData, copyColor: false, rustCameraContext.UseDepthTexture, copier);
			rustRenderer.RecordCustomRenderGraphPasses(renderGraph, RenderPassEvent.AfterRenderingGBuffer, RenderPassEvent.BeforeRenderingDeferredIndirectLighting);
			DeferredIndirectLightingPass.Record_DrawIndirectLighting(renderGraph, frameData, pipelineMaterials.deferredIndirectLightingMaterial);
			rustRenderer.RecordCustomRenderGraphPasses(renderGraph, RenderPassEvent.AfterRenderingDeferredIndirectLighting, RenderPassEvent.BeforeRenderingCombinedIndirectLighting);
			DeferredIndirectLightingPass.Record_CombineIndirectLighting(renderGraph, frameData, pipelineMaterials.deferredIndirectLightingMaterial);
			rustRenderer.RecordCustomRenderGraphPasses(renderGraph, RenderPassEvent.AfterRenderingCombinedIndirectLighting, RenderPassEvent.BeforeRenderingDeferredLights);
			DeferredLightingPass.Record(renderGraph, frameData, pipelineMaterials.deferredLightingMaterial);
			rustRenderer.RecordCustomRenderGraphPasses(renderGraph, RenderPassEvent.AfterRenderingDeferredLights);
			rustRenderer.RecordCustomRenderGraphPasses(renderGraph, RenderPassEvent.BeforeRenderingSkybox);
			SkyboxPass.Record(renderGraph, frameData);
			rustRenderer.RecordCustomRenderGraphPasses(renderGraph, RenderPassEvent.AfterRenderingSkybox);
			CopyAttachmentsPass.Record(renderGraph, frameData, rustCameraContext.UseOpaqueColorTexture, copyDepth: false, copier);
			rustRenderer.RecordCustomRenderGraphPasses(renderGraph, RenderPassEvent.BeforeRenderingTransparents);
			GeometryPass.Record(renderGraph, frameData, opaque: false);
			rustRenderer.RecordCustomRenderGraphPasses(renderGraph, RenderPassEvent.AfterRenderingTransparents);
			rustRenderer.RecordCustomRenderGraphPasses(renderGraph, RenderPassEvent.BeforeRenderingPostProcessing);
			if (rustCameraContext.PostProcessingActive)
			{
				PostFXPass.Record(renderGraph, frameData);
			}
			else
			{
				FinalPass.Record(renderGraph, frameData, copier);
			}
			RustResourceDataContext rustResourceDataContext = frameData.Get<RustResourceDataContext>();
			rustResourceDataContext.ActiveColorID = RustResourceDataContext.ActiveID.BackBuffer;
			rustResourceDataContext.ActiveDepthID = RustResourceDataContext.ActiveID.BackBuffer;
			rustRenderer.RecordCustomRenderGraphPasses(renderGraph, RenderPassEvent.AfterRenderingPostProcessing, RenderPassEvent.AfterRendering);
		}

		public void Dispose()
		{
			rustRenderer?.Dispose();
			lightCookieManager?.Dispose();
		}
	}
	public readonly struct CameraRendererCopier
	{
		private static readonly bool copyTextureSupported = SystemInfo.copyTextureSupport > CopyTextureSupport.None;

		private static readonly Rect fullViewRect = new Rect(0f, 0f, 1f, 1f);

		private static readonly int sourceTextureId = Shader.PropertyToID("_SourceTexture");

		private static readonly int srcBlendId = Shader.PropertyToID("_CameraSrcBlend");

		private static readonly int dstBlendId = Shader.PropertyToID("_CameraDstBlend");

		private readonly CameraSettings.FinalBlendMode finalBlendMode;

		private readonly Material material;

		private readonly Camera camera;

		public static bool RequiresRenderTargetResetAfterCopy => !copyTextureSupported;

		public Camera Camera => camera;

		public CameraRendererCopier(Material material, Camera camera, CameraSettings.FinalBlendMode finalBlendMode)
		{
			this.material = material;
			this.camera = camera;
			this.finalBlendMode = finalBlendMode;
		}

		public void Copy(CommandBuffer commandBuffer, RenderTargetIdentifier from, RenderTargetIdentifier to, bool isDepth)
		{
			if (copyTextureSupported)
			{
				commandBuffer.CopyTexture(from, to);
			}
			else
			{
				CopyByDrawing(commandBuffer, from, to, isDepth);
			}
		}

		public void CopyByDrawing(CommandBuffer commandBuffer, RenderTargetIdentifier from, RenderTargetIdentifier to, bool isDepth)
		{
			commandBuffer.SetGlobalTexture(sourceTextureId, from);
			commandBuffer.SetRenderTarget(to, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store);
			commandBuffer.SetViewport(camera.pixelRect);
			commandBuffer.DrawProcedural(Matrix4x4.identity, material, isDepth ? 1 : 0, MeshTopology.Triangles, 3);
		}

		public void CopyToCameraTarget(CommandBuffer commandBuffer, RenderTargetIdentifier from)
		{
			commandBuffer.SetGlobalFloat(srcBlendId, (float)finalBlendMode.source);
			commandBuffer.SetGlobalFloat(dstBlendId, (float)finalBlendMode.destination);
			commandBuffer.SetGlobalTexture(sourceTextureId, from);
			commandBuffer.SetRenderTarget(BuiltinRenderTextureType.CameraTarget, (finalBlendMode.destination == BlendMode.Zero && camera.rect == fullViewRect) ? RenderBufferLoadAction.DontCare : RenderBufferLoadAction.Load, RenderBufferStoreAction.Store);
			commandBuffer.SetViewport(camera.pixelRect);
			commandBuffer.DrawProcedural(Matrix4x4.identity, material, 0, MeshTopology.Triangles, 3);
			commandBuffer.SetGlobalFloat(srcBlendId, 1f);
			commandBuffer.SetGlobalFloat(dstBlendId, 0f);
		}
	}
	[Serializable]
	public class CameraSettings
	{
		public enum RenderScaleMode
		{
			Inherit,
			Multiply,
			Override
		}

		[Serializable]
		public struct FinalBlendMode
		{
			public BlendMode source;

			public BlendMode destination;
		}

		public RustRendererData rustRendererData;

		public bool copyColor = true;

		public bool copyDepth = true;

		[RenderingLayerMaskField]
		public int renderingLayerMask = -1;

		public bool maskLights;

		public RenderScaleMode renderScaleMode;

		[Range(0.1f, 2f)]
		public float renderScale = 1f;

		public bool postProcessingEnabled = true;

		public bool overridePostFX;

		public PostFXSettings postFXSettings;

		public FinalBlendMode finalBlendMode = new FinalBlendMode
		{
			source = BlendMode.One,
			destination = BlendMode.Zero
		};

		public bool allowFXAA;

		[Tooltip("Alpha is used to store Luma by default, which makes FXAA look better. Ticking this maintains transparency in the alpha channel after color grading")]
		public bool keepAlpha;

		public float GetRenderScale(float scale)
		{
			return renderScaleMode switch
			{
				RenderScaleMode.Inherit => scale, 
				RenderScaleMode.Override => renderScale, 
				RenderScaleMode.Multiply => scale * renderScale, 
				_ => scale, 
			};
		}
	}
	public class ContextContainer : IDisposable
	{
		private static class TypeId<T>
		{
			public static uint value = s_TypeCount++;
		}

		private struct Item
		{
			public ContextItem storage;

			public bool isSet;
		}

		private Item[] m_Items = new Item[64];

		private List<uint> m_ActiveItemIndices = new List<uint>();

		private static uint s_TypeCount;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public T Get<T>() where T : ContextItem, new()
		{
			uint value = TypeId<T>.value;
			if (!Contains(value))
			{
				throw new InvalidOperationException("Type " + typeof(T).FullName + " has not been created yet.");
			}
			return (T)m_Items[value].storage;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public T Create<T>() where T : ContextItem, new()
		{
			uint value = TypeId<T>.value;
			if (Contains(value))
			{
				throw new InvalidOperationException("Type " + typeof(T).FullName + " has already been created.");
			}
			return CreateAndGetData<T>(value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public T GetOrCreate<T>() where T : ContextItem, new()
		{
			uint value = TypeId<T>.value;
			if (Contains(value))
			{
				return (T)m_Items[value].storage;
			}
			return CreateAndGetData<T>(value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public bool Contains<T>() where T : ContextItem, new()
		{
			uint value = TypeId<T>.value;
			return Contains(value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private bool Contains(uint typeId)
		{
			if (typeId < m_Items.Length)
			{
				return m_Items[typeId].isSet;
			}
			return false;
		}

		private T CreateAndGetData<T>(uint typeId) where T : ContextItem, new()
		{
			if (m_Items.Length <= typeId)
			{
				Item[] array = new Item[math.max(math.ceilpow2(s_TypeCount), m_Items.Length * 2)];
				for (int i = 0; i < m_Items.Length; i++)
				{
					array[i] = m_Items[i];
				}
				m_Items = array;
			}
			m_ActiveItemIndices.Add(typeId);
			ref Item reference = ref m_Items[typeId];
			ref ContextItem storage = ref reference.storage;
			if (storage == null)
			{
				storage = new T();
			}
			reference.isSet = true;
			return (T)reference.storage;
		}

		public void Dispose()
		{
			foreach (uint activeItemIndex in m_ActiveItemIndices)
			{
				ref Item reference = ref m_Items[activeItemIndex];
				reference.storage.Reset();
				reference.isSet = false;
			}
			m_ActiveItemIndices.Clear();
		}
	}
	public abstract class ContextItem
	{
		public abstract void Reset();
	}
	[Serializable]
	public struct ForwardPlusSettings
	{
		public enum TileSize
		{
			Default = 0,
			_16 = 0x10,
			_32 = 0x20,
			_64 = 0x40,
			_128 = 0x80,
			_256 = 0x100
		}

		[Tooltip("Tile size in pixels per dimension, default is 64.")]
		public TileSize tileSize;

		[Range(0f, 99f)]
		[Tooltip("Maximum allowed lights per tile, 0 means default, which is 31.")]
		public int maxLightsPerTile;
	}
	[MovedFrom(true, "UnityEngine.Experimental.Rendering.RenderGraphModule", "UnityEngine.Rendering.RenderGraphModule", null)]
	public interface IRenderGraphRecorder
	{
		void RecordRenderGraph(RenderGraph renderGraph, ContextContainer frameData);
	}
	public static class NativeArrayExtensions
	{
		public unsafe static ref T UnsafeElementAt<T>(this NativeArray<T> array, int index) where T : struct
		{
			return ref UnsafeUtility.ArrayElementAsRef<T>(array.GetUnsafeReadOnlyPtr(), index);
		}

		public unsafe static ref T UnsafeElementAtMutable<T>(this NativeArray<T> array, int index) where T : struct
		{
			return ref UnsafeUtility.ArrayElementAsRef<T>(array.GetUnsafePtr(), index);
		}
	}
	public static class PipelineUtils
	{
		private static Dictionary<CameraEvent, string> cameraEventToString;

		public static Dictionary<CameraEvent, string> CameraEventToString
		{
			get
			{
				if (cameraEventToString != null)
				{
					return cameraEventToString;
				}
				cameraEventToString = Enum.GetValues(typeof(CameraEvent)).Cast<CameraEvent>().ToDictionary((CameraEvent k) => k, (CameraEvent v) => v.ToString());
				return cameraEventToString;
			}
		}
	}
	[CreateAssetMenu(menuName = "Rendering/Rust Post FX Settings")]
	public class PostFXSettings : ScriptableObject
	{
		[Serializable]
		public struct BloomSettings
		{
			public enum Mode
			{
				Additive,
				Scattering
			}

			public bool ignoreRenderScale;

			[Range(0f, 16f)]
			public int maxIterations;

			[Min(1f)]
			public int downscaleLimit;

			public bool bicubicUpsampling;

			[Min(0f)]
			public float threshold;

			[Range(0f, 1f)]
			public float thresholdKnee;

			[Min(0f)]
			public float intensity;

			public bool fadeFireflies;

			public Mode mode;

			[Range(0.05f, 0.95f)]
			public float scatter;
		}

		[Serializable]
		public struct ColorAdjustmentsSettings
		{
			public float postExposure;

			[Range(-100f, 100f)]
			public float contrast;

			[ColorUsage(false, true)]
			public Color colorFilter;

			[Range(-180f, 180f)]
			public float hueShift;

			[Range(-100f, 100f)]
			public float saturation;
		}

		[Serializable]
		public struct ChannelMixerSettings
		{
			public Vector3 red;

			public Vector3 green;

			public Vector3 blue;
		}

		[Serializable]
		public struct WhiteBalanceSettings
		{
			[Range(-100f, 100f)]
			public float temperature;

			[Range(-100f, 100f)]
			public float tint;
		}

		[Serializable]
		public struct SplitToningSettings
		{
			[ColorUsage(false)]
			public Color shadows;

			[ColorUsage(false)]
			public Color highlights;

			[Range(-100f, 100f)]
			public float balance;
		}

		[Serializable]
		public struct ToneMappingSettings
		{
			public enum Mode
			{
				None,
				ACES,
				Neutral,
				Reinhard
			}

			public Mode mode;
		}

		[Serializable]
		public struct ShadowsMidtonesHighlightsSettings
		{
			[ColorUsage(false, true)]
			public Color shadows;

			[ColorUsage(false, true)]
			public Color midtones;

			[ColorUsage(false, true)]
			public Color highlights;

			[Range(0f, 2f)]
			public float shadowsStart;

			[Range(0f, 2f)]
			public float shadowsEnd;

			[Range(0f, 2f)]
			public float highlightsStart;

			[Range(0f, 2f)]
			public float highLightsEnd;
		}

		[SerializeField]
		private Shader shader;

		[NonSerialized]
		private Material material;

		public Material Material
		{
			get
			{
				if (material == null && shader != null)
				{
					material = new Material(shader)
					{
						hideFlags = HideFlags.HideAndDontSave
					};
				}
				return material;
			}
		}

		[field: SerializeField]
		public BloomSettings Bloom { get; private set; } = new BloomSettings
		{
			scatter = 0.7f
		};

		[field: SerializeField]
		public ColorAdjustmentsSettings ColorAdjustments { get; private set; } = new ColorAdjustmentsSettings
		{
			colorFilter = Color.white
		};

		[field: SerializeField]
		public WhiteBalanceSettings WhiteBalance { get; private set; }

		[field: SerializeField]
		public SplitToningSettings SplitToning { get; private set; } = new SplitToningSettings
		{
			shadows = Color.gray,
			highlights = Color.gray
		};

		[field: SerializeField]
		public ChannelMixerSettings ChannelMixer { get; private set; } = new ChannelMixerSettings
		{
			red = Vector3.right,
			green = Vector3.up,
			blue = Vector3.forward
		};

		[field: SerializeField]
		public ShadowsMidtonesHighlightsSettings ShadowsMidtonesHighlights { get; private set; } = new ShadowsMidtonesHighlightsSettings
		{
			shadows = Color.white,
			midtones = Color.white,
			highlights = Color.white,
			shadowsEnd = 0.3f,
			highlightsStart = 0.55f,
			highLightsEnd = 1f
		};

		[field: SerializeField]
		public ToneMappingSettings ToneMapping { get; private set; }

		public static bool AreApplicableTo(Camera camera)
		{
			return camera.cameraType <= CameraType.SceneView;
		}
	}
	public static class ReinterpretExtensions
	{
		[StructLayout(LayoutKind.Explicit)]
		private struct IntFloat
		{
			[FieldOffset(0)]
			public int intValue;

			[FieldOffset(0)]
			public float floatValue;
		}

		public static float ReinterpretAsFloat(this int value)
		{
			IntFloat intFloat = new IntFloat
			{
				intValue = value
			};
			return intFloat.floatValue;
		}
	}
	public class RenderingLayerMaskFieldAttribute : PropertyAttribute
	{
	}
	public enum RenderPassEvent
	{
		BeforeRendering = 0,
		BeforeRenderingShadows = 50,
		AfterRenderingShadows = 100,
		BeforeRenderingPrePasses = 150,
		AfterRenderingPrePasses = 200,
		BeforeRenderingGBuffer = 210,
		AfterRenderingGBuffer = 220,
		BeforeRenderingDeferredLights = 230,
		BeforeRenderingDeferredIndirectLighting = 240,
		AfterRenderingDeferredIndirectLighting = 250,
		BeforeRenderingCombinedIndirectLighting = 260,
		AfterRenderingCombinedIndirectLighting = 270,
		AfterRenderingDeferredLights = 280,
		BeforeRenderingOpaques = 290,
		AfterRenderingOpaques = 300,
		BeforeRenderingSkybox = 350,
		AfterRenderingSkybox = 400,
		BeforeRenderingTransparents = 450,
		AfterRenderingTransparents = 500,
		BeforeRenderingPostProcessing = 550,
		AfterRenderingPostProcessing = 600,
		AfterRendering = 1000
	}
	internal static class RenderPassEventsEnumValues
	{
		public static int[] values;

		static RenderPassEventsEnumValues()
		{
			Array array = Enum.GetValues(typeof(RenderPassEvent));
			values = new int[array.Length];
			int num = 0;
			foreach (int item in array)
			{
				values[num] = item;
				num++;
			}
		}
	}
	public sealed class RustRenderer : IDisposable
	{
		private static readonly ProfilingSampler addRenderPassesSampler = new ProfilingSampler("Add Render Passes");

		private readonly List<RustRenderPass> activeRenderPassQueue = new List<RustRenderPass>(32);

		private readonly List<RustRendererFeature> rendererFeatures = new List<RustRendererFeature>(10);

		public ContextContainer FrameData { get; private set; } = new ContextContainer();

		public void Initialize(RustRendererData data)
		{
			rendererFeatures.Clear();
			foreach (RustRendererFeature rendererFeature in data.rendererFeatures)
			{
				if (!(rendererFeature == null))
				{
					rendererFeature.Create();
					rendererFeatures.Add(rendererFeature);
				}
			}
			activeRenderPassQueue.Clear();
		}

		public void EnqueuePass(RustRenderPass rustRenderPass)
		{
			activeRenderPassQueue.Add(rustRenderPass);
		}

		internal void AddRenderPasses()
		{
			foreach (RustRendererFeature rendererFeature in rendererFeatures)
			{
				if (rendererFeature.IsActive)
				{
					rendererFeature.AddRenderPasses(this);
				}
			}
		}

		internal static void SortStable(List<RustRenderPass> list)
		{
			for (int i = 1; i < list.Count; i++)
			{
				RustRenderPass rustRenderPass = list[i];
				int num = i - 1;
				while (num >= 0 && rustRenderPass < list[num])
				{
					list[num + 1] = list[num];
					num--;
				}
				list[num + 1] = rustRenderPass;
			}
		}

		internal void RecordCustomRenderGraphPassesInEventRange(RenderGraph renderGraph, RenderPassEvent eventStart, RenderPassEvent eventEnd)
		{
			if (eventStart == eventEnd)
			{
				return;
			}
			foreach (RustRenderPass item in activeRenderPassQueue)
			{
				if (item.renderPassEvent >= eventStart && item.renderPassEvent < eventEnd)
				{
					item.RecordRenderGraph(renderGraph, FrameData);
				}
			}
		}

		internal void RecordCustomRenderGraphPasses(RenderGraph renderGraph, RenderPassEvent startInjectionPoint, RenderPassEvent endInjectionPoint)
		{
			int renderPassEventRange = RustRenderPass.GetRenderPassEventRange(endInjectionPoint);
			RecordCustomRenderGraphPassesInEventRange(renderGraph, startInjectionPoint, endInjectionPoint + renderPassEventRange);
		}

		internal void RecordCustomRenderGraphPasses(RenderGraph renderGraph, RenderPassEvent injectionPoint)
		{
			RecordCustomRenderGraphPasses(renderGraph, injectionPoint, injectionPoint);
		}

		public void Dispose()
		{
			foreach (RustRendererFeature rendererFeature in rendererFeatures)
			{
				if (!(rendererFeature == null))
				{
					try
					{
						rendererFeature.Dispose();
					}
					catch (Exception exception)
					{
						UnityEngine.Debug.LogException(exception);
					}
				}
			}
		}
	}
	[CreateAssetMenu(menuName = "Rendering/Rust Render Pipeline Renderer")]
	public class RustRendererData : ScriptableObject
	{
		[SerializeField]
		internal List<RustRendererFeature> rendererFeatures = new List<RustRendererFeature>(10);

		public bool TryGetRendererFeature<T>(out T rendererFeature) where T : RustRendererFeature
		{
			foreach (RustRendererFeature rendererFeature2 in rendererFeatures)
			{
				if (rendererFeature2.GetType() == typeof(T))
				{
					rendererFeature = rendererFeature2 as T;
					return true;
				}
			}
			rendererFeature = null;
			return false;
		}
	}
	public abstract class RustRendererFeature : ScriptableObject, IDisposable
	{
		[SerializeField]
		protected bool active = true;

		public bool IsActive => active;

		public abstract void Create();

		public abstract void AddRenderPasses(RustRenderer renderer);

		private void OnEnable()
		{
			if (RenderPipelineManager.currentPipeline is RustRenderPipeline && IsActive)
			{
				Create();
			}
		}

		private void OnValidate()
		{
			if (RenderPipelineManager.currentPipeline is RustRenderPipeline && IsActive)
			{
				Create();
			}
		}

		public void SetActive(bool active)
		{
			this.active = active;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
		}
	}
	public abstract class RustRenderPass : IRenderGraphRecorder
	{
		public RenderPassEvent renderPassEvent { get; set; }

		public virtual void RecordRenderGraph(RenderGraph renderGraph, ContextContainer frameData)
		{
			UnityEngine.Debug.LogWarning("Rust Render pass (" + ToString() + " is missing an implementation of the RecordRenderGraph method!)");
		}

		public static bool operator <(RustRenderPass lhs, RustRenderPass rhs)
		{
			return lhs.renderPassEvent < rhs.renderPassEvent;
		}

		public static bool operator >(RustRenderPass lhs, RustRenderPass rhs)
		{
			return lhs.renderPassEvent > rhs.renderPassEvent;
		}

		internal static int GetRenderPassEventRange(RenderPassEvent renderPassEvent)
		{
			int num = RenderPassEventsEnumValues.values.Length;
			int num2 = 0;
			for (int i = 0; i < num; i++)
			{
				if (RenderPassEventsEnumValues.values[num2] == (int)renderPassEvent)
				{
					break;
				}
				num2++;
			}
			if (num2 >= num)
			{
				UnityEngine.Debug.LogError("GetRenderPassEventRange: invalid renderPassEvent value cannot be found in the RenderPassEvent enumeration");
				return 0;
			}
			if (num2 + 1 >= num)
			{
				return 50;
			}
			return (int)(RenderPassEventsEnumValues.values[num2 + 1] - renderPassEvent);
		}
	}
	public class RustRenderPipeline : UnityEngine.Rendering.RenderPipeline
	{
		public readonly struct PipelineMaterials
		{
			public readonly Material cameraRendererMaterial;

			public readonly Material cameraDebuggerMaterial;

			public readonly Material deferredLightingMaterial;

			public readonly Material deferredIndirectLightingMaterial;

			public PipelineMaterials(RustRenderPipelineSettings.PipelineShaders pipelineShaders)
			{
				cameraRendererMaterial = CoreUtils.CreateEngineMaterial(pipelineShaders.cameraRendererShader);
				cameraDebuggerMaterial = CoreUtils.CreateEngineMaterial(pipelineShaders.cameraDebuggerShader);
				deferredLightingMaterial = CoreUtils.CreateEngineMaterial(pipelineShaders.deferredLightingShader);
				deferredIndirectLightingMaterial = CoreUtils.CreateEngineMaterial(pipelineShaders.deferredIndirectLightingShader);
			}

			public void Dispose()
			{
				CoreUtils.Destroy(cameraRendererMaterial);
				CoreUtils.Destroy(cameraDebuggerMaterial);
				CoreUtils.Destroy(deferredLightingMaterial);
				CoreUtils.Destroy(deferredIndirectLightingMaterial);
			}
		}

		private readonly RenderGraph renderGraph = new RenderGraph("Rust SRP Render Graph");

		private readonly CameraRenderer cameraRenderer;

		private readonly RustRenderPipelineSettings settings;

		private readonly PipelineMaterials pipelineMaterials;

		private readonly RustRendererData defaultRendererData;

		public RustRenderPipeline(RustRendererData defaultRendererData, RustRenderPipelineSettings settings)
		{
			this.settings = settings;
			this.defaultRendererData = defaultRendererData;
			GraphicsSettings.useScriptableRenderPipelineBatching = settings.useSrpBatching;
			GraphicsSettings.lightsUseLinearIntensity = true;
			pipelineMaterials = new PipelineMaterials(settings.pipelineShaders);
			Blitter.Initialize(settings.pipelineShaders.coreBlit, settings.pipelineShaders.coreBlitColorAndDepth);
			cameraRenderer = new CameraRenderer(pipelineMaterials);
		}

		protected override void Render(ScriptableRenderContext context, List<Camera> cameras)
		{
			UnityEngine.Rendering.RenderPipeline.BeginContextRendering(context, cameras);
			foreach (Camera camera in cameras)
			{
				RustRenderPipelineCamera component = camera.GetComponent<RustRenderPipelineCamera>();
				RustRendererData rustRendererData = ((component == null || component.Settings.rustRendererData == null) ? defaultRendererData : component.Settings.rustRendererData);
				UnityEngine.Rendering.RenderPipeline.BeginCameraRendering(context, camera);
				cameraRenderer.Render(renderGraph, context, camera, settings, rustRendererData);
				UnityEngine.Rendering.RenderPipeline.EndCameraRendering(context, camera);
			}
			renderGraph.EndFrame();
			UnityEngine.Rendering.RenderPipeline.EndContextRendering(context, cameras);
		}

		protected override void Render(ScriptableRenderContext context, Camera[] cameras)
		{
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			cameraRenderer.Dispose();
			pipelineMaterials.Dispose();
			renderGraph.Cleanup();
			Blitter.Cleanup();
		}
	}
	[CreateAssetMenu(menuName = "Rendering/Rust Render Pipeline Asset")]
	public class RustRenderPipelineAsset : RenderPipelineAsset
	{
		[SerializeField]
		private RustRendererData defaultRendererData;

		[SerializeField]
		private RustRenderPipelineSettings settings;

		protected override UnityEngine.Rendering.RenderPipeline CreatePipeline()
		{
			return new RustRenderPipeline(defaultRendererData, settings);
		}
	}
	[DisallowMultipleComponent]
	[RequireComponent(typeof(Camera))]
	public class RustRenderPipelineCamera : MonoBehaviour
	{
		[SerializeField]
		private CameraSettings settings;

		private ProfilingSampler sampler;

		public CameraSettings Settings => settings ?? (settings = new CameraSettings());

		public ProfilingSampler Sampler => sampler ?? (sampler = new ProfilingSampler(GetComponent<Camera>().name));
	}
	[Serializable]
	public class RustRenderPipelineSettings
	{
		public enum ColorLutResolution
		{
			_16 = 0x10,
			_32 = 0x20,
			_64 = 0x40
		}

		public enum RenderPath
		{
			ForwardPlus,
			Deferred
		}

		[Serializable]
		public struct PipelineShaders
		{
			public Shader cameraRendererShader;

			public Shader cameraDebuggerShader;

			public Shader deferredLightingShader;

			public Shader deferredIndirectLightingShader;

			public Shader coreBlit;

			public Shader coreBlitColorAndDepth;
		}

		[Serializable]
		public struct PipelineTextures
		{
			public Texture blueNoise;

			public Texture preIntegratedFgdGgx;

			public Texture environmentBrdfLut;
		}

		public RenderPath renderPath;

		public CameraBufferSettings cameraBuffer = new CameraBufferSettings
		{
			allowHDR = true,
			renderScale = 1f,
			fxaaSettings = new CameraBufferSettings.FxaaSettings
			{
				fixedThreshold = 0.0833f,
				relativeThreshold = 0.166f,
				subpixelBlending = 0.75f
			}
		};

		public bool useSrpBatching = true;

		public ForwardPlusSettings forwardPlus;

		public ShadowSettings shadows;

		public bool postProcessingEnabled = true;

		public PostFXSettings postFXSettings;

		public ColorLutResolution colorLutResolution = ColorLutResolution._32;

		public PipelineShaders pipelineShaders;

		public PipelineTextures pipelineTextures;
	}
	[Serializable]
	public class ShadowSettings
	{
		public enum FilterQuality
		{
			Low,
			Medium,
			High
		}

		public enum MapSize
		{
			_256 = 0x100,
			_512 = 0x200,
			_1024 = 0x400,
			_2048 = 0x800,
			_4096 = 0x1000,
			_8192 = 0x2000
		}

		[Serializable]
		public struct DirectionalLight
		{
			public MapSize atlasSize;

			[Range(1f, 4f)]
			public int cascadeCount;

			[Range(0f, 1f)]
			public float cascadeRatio1;

			[Range(0f, 1f)]
			public float cascadeRatio2;

			[Range(0f, 1f)]
			public float cascadeRatio3;

			[Range(0.001f, 1f)]
			public float cascadeFade;

			public bool softCascadeBlend;

			public Vector3 CascadeRatios => new Vector3(cascadeRatio1, cascadeRatio2, cascadeRatio3);
		}

		[Serializable]
		public struct AdditionalLight
		{
			public MapSize atlasSize;

			public FilterMode filter;
		}

		[Min(0.001f)]
		public float maxDistance = 100f;

		[Range(0.001f, 1f)]
		public float distanceFade = 0.1f;

		public DirectionalLight directional = new DirectionalLight
		{
			atlasSize = MapSize._1024,
			cascadeCount = 4,
			cascadeRatio1 = 0.1f,
			cascadeRatio2 = 0.25f,
			cascadeRatio3 = 0.5f,
			cascadeFade = 0.1f
		};

		public AdditionalLight additional = new AdditionalLight
		{
			atlasSize = MapSize._1024
		};

		public FilterQuality filterQuality = FilterQuality.Medium;

		public float DirectionalFilterSize => (float)filterQuality + 2f;

		public float AdditionalFilterSize => (float)filterQuality + 2f;
	}
}
namespace Rust.RenderPipeline.Runtime.RenderingContext
{
	public class RustCameraContext : ContextItem
	{
		public Camera Camera { get; internal set; }

		public CameraSettings CameraSettings { get; internal set; }

		public CameraBufferSettings CameraBufferSettings { get; internal set; }

		public PostFXSettings PostFXSettings { get; internal set; }

		public TextureDesc CameraTargetDescriptor { get; internal set; }

		public Vector2Int CameraBufferSize { get; internal set; }

		public Matrix4x4 ViewMatrix { get; internal set; }

		public Matrix4x4 ProjectionMatrix { get; internal set; }

		public bool UseOpaqueColorTexture { get; internal set; }

		public bool UseDepthTexture { get; internal set; }

		public bool PostProcessingActive { get; internal set; }

		public override void Reset()
		{
			Camera = null;
			CameraSettings = null;
			CameraBufferSettings = default(CameraBufferSettings);
			PostFXSettings = null;
			CameraTargetDescriptor = default(TextureDesc);
			CameraBufferSize = default(Vector2Int);
			ViewMatrix = default(Matrix4x4);
			ProjectionMatrix = default(Matrix4x4);
			UseOpaqueColorTexture = false;
			UseDepthTexture = false;
			PostProcessingActive = false;
		}
	}
	public class RustRenderingContext : ContextItem
	{
		public RustRenderPipelineSettings pipelineSettings;

		public CullingResults cullResults;

		public PerObjectData perObjectData;

		public override void Reset()
		{
			pipelineSettings = null;
			cullResults = default(CullingResults);
			perObjectData = PerObjectData.None;
		}
	}
	public class RustResourceDataContext : ContextItem
	{
		internal enum ActiveID
		{
			Camera,
			BackBuffer
		}

		public static readonly int gBufferTextureCount = 4;

		private TextureHandle backBufferColor;

		private TextureHandle backBufferDepth;

		private TextureHandle cameraColor;

		private TextureHandle cameraDepth;

		private TextureHandle mainShadowsTexture;

		private TextureHandle additionalShadowsTexture;

		private ComputeBufferHandle shadowCascadesBuffer;

		private ComputeBufferHandle shadowMatricesBuffer;

		private ComputeBufferHandle additionalShadowDataBuffer;

		private ComputeBufferHandle directionalLightDataBuffer;

		private ComputeBufferHandle additionalLightDataBuffer;

		private ComputeBufferHandle lightTilesBuffer;

		private Dictionary<Light, Vector4> lightShadowData;

		private TextureHandle[] gBuffer = new TextureHandle[gBufferTextureCount];

		private TextureHandle cameraOpaqueTexture;

		private TextureHandle cameraDepthTexture;

		private TextureHandle indirectDiffuseHandle;

		private TextureHandle indirectSpecularHandle;

		internal bool IsAccessible { get; set; }

		internal ActiveID ActiveColorID { get; set; }

		public TextureHandle ActiveColorTexture
		{
			get
			{
				if (!CheckAndWarnAboutAccessibility())
				{
					return TextureHandle.nullHandle;
				}
				return ActiveColorID switch
				{
					ActiveID.Camera => CameraColor, 
					ActiveID.BackBuffer => BackBufferColor, 
					_ => throw new ArgumentOutOfRangeException(), 
				};
			}
		}

		internal ActiveID ActiveDepthID { get; set; }

		public TextureHandle ActiveDepthTexture
		{
			get
			{
				if (!CheckAndWarnAboutAccessibility())
				{
					return TextureHandle.nullHandle;
				}
				return ActiveDepthID switch
				{
					ActiveID.Camera => CameraDepth, 
					ActiveID.BackBuffer => BackBufferDepth, 
					_ => throw new ArgumentOutOfRangeException(), 
				};
			}
		}

		public TextureHandle BackBufferColor
		{
			get
			{
				return CheckAndGetTextureHandle(ref backBufferColor);
			}
			internal set
			{
				CheckAndSetTextureHandle(ref backBufferColor, value);
			}
		}

		public TextureHandle BackBufferDepth
		{
			get
			{
				return CheckAndGetTextureHandle(ref backBufferDepth);
			}
			internal set
			{
				CheckAndSetTextureHandle(ref backBufferDepth, value);
			}
		}

		public TextureHandle CameraColor
		{
			get
			{
				return CheckAndGetTextureHandle(ref cameraColor);
			}
			set
			{
				CheckAndSetTextureHandle(ref cameraColor, value);
			}
		}

		public TextureHandle CameraDepth
		{
			get
			{
				return CheckAndGetTextureHandle(ref cameraDepth);
			}
			set
			{
				CheckAndSetTextureHandle(ref cameraDepth, value);
			}
		}

		public TextureHandle MainShadowsTexture
		{
			get
			{
				return CheckAndGetTextureHandle(ref mainShadowsTexture);
			}
			set
			{
				CheckAndSetTextureHandle(ref mainShadowsTexture, value);
			}
		}

		public TextureHandle AdditionalShadowsTexture
		{
			get
			{
				return CheckAndGetTextureHandle(ref additionalShadowsTexture);
			}
			set
			{
				CheckAndSetTextureHandle(ref additionalShadowsTexture, value);
			}
		}

		public ComputeBufferHandle ShadowCascadesBuffer
		{
			get
			{
				return CheckAndGetComputeBufferHandle(ref shadowCascadesBuffer);
			}
			set
			{
				CheckAndSetComputeBufferHandle(ref shadowCascadesBuffer, value);
			}
		}

		public ComputeBufferHandle ShadowMatricesBuffer
		{
			get
			{
				return CheckAndGetComputeBufferHandle(ref shadowMatricesBuffer);
			}
			set
			{
				CheckAndSetComputeBufferHandle(ref shadowMatricesBuffer, value);
			}
		}

		public ComputeBufferHandle AdditionalShadowDataBuffer
		{
			get
			{
				return CheckAndGetComputeBufferHandle(ref additionalShadowDataBuffer);
			}
			set
			{
				CheckAndSetComputeBufferHandle(ref additionalShadowDataBuffer, value);
			}
		}

		public ComputeBufferHandle DirectionalLightDataBuffer
		{
			get
			{
				return CheckAndGetComputeBufferHandle(ref directionalLightDataBuffer);
			}
			set
			{
				CheckAndSetComputeBufferHandle(ref directionalLightDataBuffer, value);
			}
		}

		public ComputeBufferHandle AdditionalLightDataBuffer
		{
			get
			{
				return CheckAndGetComputeBufferHandle(ref additionalLightDataBuffer);
			}
			set
			{
				CheckAndSetComputeBufferHandle(ref additionalLightDataBuffer, value);
			}
		}

		public ComputeBufferHandle LightTilesBuffer
		{
			get
			{
				return CheckAndGetComputeBufferHandle(ref lightTilesBuffer);
			}
			set
			{
				CheckAndSetComputeBufferHandle(ref lightTilesBuffer, value);
			}
		}

		public Dictionary<Light, Vector4> LightShadowData
		{
			get
			{
				return lightShadowData;
			}
			set
			{
				lightShadowData = value;
			}
		}

		public TextureHandle[] GBuffer
		{
			get
			{
				return CheckAndGetTextureHandle(ref gBuffer);
			}
			set
			{
				CheckAndSetTextureHandle(ref gBuffer, value);
			}
		}

		public TextureHandle CameraOpaqueTexture
		{
			get
			{
				return CheckAndGetTextureHandle(ref cameraOpaqueTexture);
			}
			internal set
			{
				CheckAndSetTextureHandle(ref cameraOpaqueTexture, value);
			}
		}

		public TextureHandle CameraDepthTexture
		{
			get
			{
				return CheckAndGetTextureHandle(ref cameraDepthTexture);
			}
			internal set
			{
				CheckAndSetTextureHandle(ref cameraDepthTexture, value);
			}
		}

		public TextureHandle IndirectDiffuseHandle
		{
			get
			{
				return CheckAndGetTextureHandle(ref indirectDiffuseHandle);
			}
			internal set
			{
				CheckAndSetTextureHandle(ref indirectDiffuseHandle, value);
			}
		}

		public TextureHandle IndirectSpecularHandle
		{
			get
			{
				return CheckAndGetTextureHandle(ref indirectSpecularHandle);
			}
			internal set
			{
				CheckAndSetTextureHandle(ref indirectSpecularHandle, value);
			}
		}

		internal void InitFrame()
		{
			IsAccessible = true;
		}

		internal void EndFrame()
		{
			IsAccessible = false;
		}

		private void CheckAndSetTextureHandle(ref TextureHandle handle, TextureHandle newHandle)
		{
			if (CheckAndWarnAboutAccessibility())
			{
				handle = newHandle;
			}
		}

		private TextureHandle CheckAndGetTextureHandle(ref TextureHandle handle)
		{
			if (CheckAndWarnAboutAccessibility())
			{
				return handle;
			}
			return TextureHandle.nullHandle;
		}

		private void CheckAndSetTextureHandle(ref TextureHandle[] handle, TextureHandle[] newHandle)
		{
			if (CheckAndWarnAboutAccessibility())
			{
				if (handle == null || handle.Length != newHandle.Length)
				{
					handle = new TextureHandle[newHandle.Length];
				}
				for (int i = 0; i < newHandle.Length; i++)
				{
					handle[i] = newHandle[i];
				}
			}
		}

		private TextureHandle[] CheckAndGetTextureHandle(ref TextureHandle[] handle)
		{
			if (!CheckAndWarnAboutAccessibility())
			{
				return new TextureHandle[1] { TextureHandle.nullHandle };
			}
			return handle;
		}

		private ComputeBufferHandle CheckAndGetComputeBufferHandle(ref ComputeBufferHandle handle)
		{
			if (CheckAndWarnAboutAccessibility())
			{
				return handle;
			}
			return ComputeBufferHandle.nullHandle;
		}

		private void CheckAndSetComputeBufferHandle(ref ComputeBufferHandle handle, ComputeBufferHandle newHandle)
		{
			if (CheckAndWarnAboutAccessibility())
			{
				handle = newHandle;
			}
		}

		private bool CheckAndWarnAboutAccessibility()
		{
			if (!IsAccessible)
			{
				UnityEngine.Debug.LogError("Trying to access Universal Resources outside of the current frame setup.");
			}
			return IsAccessible;
		}

		public override void Reset()
		{
			backBufferColor = TextureHandle.nullHandle;
			backBufferDepth = TextureHandle.nullHandle;
			cameraColor = TextureHandle.nullHandle;
			cameraDepth = TextureHandle.nullHandle;
			mainShadowsTexture = TextureHandle.nullHandle;
			additionalShadowsTexture = TextureHandle.nullHandle;
			shadowCascadesBuffer = ComputeBufferHandle.nullHandle;
			shadowMatricesBuffer = ComputeBufferHandle.nullHandle;
			additionalShadowDataBuffer = ComputeBufferHandle.nullHandle;
			directionalLightDataBuffer = ComputeBufferHandle.nullHandle;
			additionalLightDataBuffer = ComputeBufferHandle.nullHandle;
			lightTilesBuffer = ComputeBufferHandle.nullHandle;
			cameraOpaqueTexture = TextureHandle.nullHandle;
			cameraDepthTexture = TextureHandle.nullHandle;
			indirectDiffuseHandle = TextureHandle.nullHandle;
			indirectSpecularHandle = TextureHandle.nullHandle;
			for (int i = 0; i < gBuffer.Length; i++)
			{
				gBuffer[i] = TextureHandle.nullHandle;
			}
		}
	}
}
namespace Rust.RenderPipeline.Runtime.Passes
{
	public class CopyAttachmentsPass
	{
		private static readonly ProfilingSampler profilingSampler = new ProfilingSampler("Copy Attachments");

		private static readonly int colorCopyID = Shader.PropertyToID("_CameraColorTexture");

		private static readonly int depthCopyID = Shader.PropertyToID("_CameraDepthTexture");

		private bool copyColor;

		private bool copyDepth;

		private CameraRendererCopier copier;

		private TextureHandle colorAttachment;

		private TextureHandle depthAttachment;

		private TextureHandle colorCopy;

		private TextureHandle depthCopy;

		private void Render(RenderGraphContext context)
		{
			CommandBuffer cmd = context.cmd;
			if (copyColor)
			{
				copier.Copy(cmd, colorAttachment, colorCopy, isDepth: false);
				cmd.SetGlobalTexture(colorCopyID, colorCopy);
			}
			if (copyDepth)
			{
				copier.Copy(cmd, depthAttachment, depthCopy, isDepth: true);
				cmd.SetGlobalTexture(depthCopyID, depthCopy);
			}
			if (CameraRendererCopier.RequiresRenderTargetResetAfterCopy)
			{
				cmd.SetRenderTarget(colorAttachment, RenderBufferLoadAction.Load, RenderBufferStoreAction.Store, depthAttachment, RenderBufferLoadAction.Load, RenderBufferStoreAction.Store);
			}
			context.renderContext.ExecuteCommandBuffer(cmd);
			cmd.Clear();
		}

		public static void Record(RenderGraph renderGraph, ContextContainer frameData, bool copyColor, bool copyDepth, CameraRendererCopier copier)
		{
			frameData.Get<RustCameraContext>();
			if (!copyColor && !copyDepth)
			{
				return;
			}
			RustResourceDataContext rustResourceDataContext = frameData.Get<RustResourceDataContext>();
			CopyAttachmentsPass passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<CopyAttachmentsPass>(profilingSampler.name, out passData, profilingSampler);
			passData.copyColor = copyColor;
			passData.copyDepth = copyDepth;
			passData.copier = copier;
			passData.colorAttachment = renderGraphBuilder.ReadTexture(rustResourceDataContext.CameraColor);
			passData.depthAttachment = renderGraphBuilder.ReadTexture(rustResourceDataContext.CameraDepth);
			if (copyColor)
			{
				passData.colorCopy = renderGraphBuilder.WriteTexture(rustResourceDataContext.CameraOpaqueTexture);
			}
			if (copyDepth)
			{
				passData.depthCopy = renderGraphBuilder.WriteTexture(rustResourceDataContext.CameraDepthTexture);
			}
			renderGraphBuilder.SetRenderFunc(delegate(CopyAttachmentsPass pass, RenderGraphContext context)
			{
				pass.Render(context);
			});
		}
	}
	public class DebugPass
	{
		private static readonly ProfilingSampler sampler = new ProfilingSampler("Debug");

		public TextureHandle[] gBufferHandles;

		public TextureHandle indirectDiffuseHandle;

		public TextureHandle indirectSpecularHandle;

		[Conditional("DEVELOPMENT_BUILD")]
		[Conditional("UNITY_EDITOR")]
		public static void Record(RenderGraph renderGraph, ContextContainer frameData)
		{
			RustCameraContext rustCameraContext = frameData.Get<RustCameraContext>();
			RustResourceDataContext rustResourceDataContext = frameData.Get<RustResourceDataContext>();
			if (!CameraDebugger.IsActive || rustCameraContext.Camera.cameraType > CameraType.SceneView)
			{
				return;
			}
			DebugPass passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<DebugPass>(sampler.name, out passData, sampler);
			passData.gBufferHandles = rustResourceDataContext.GBuffer;
			passData.indirectDiffuseHandle = rustResourceDataContext.IndirectDiffuseHandle;
			passData.indirectSpecularHandle = rustResourceDataContext.IndirectSpecularHandle;
			TextureHandle[] gBuffer = rustResourceDataContext.GBuffer;
			for (int i = 0; i < gBuffer.Length; i++)
			{
				TextureHandle input = gBuffer[i];
				renderGraphBuilder.ReadTexture(in input);
			}
			renderGraphBuilder.ReadTexture(rustResourceDataContext.IndirectDiffuseHandle);
			renderGraphBuilder.ReadTexture(rustResourceDataContext.IndirectSpecularHandle);
			renderGraphBuilder.ReadComputeBuffer(rustResourceDataContext.LightTilesBuffer);
			renderGraphBuilder.SetRenderFunc<DebugPass>(delegate
			{
			});
		}
	}
	public class FinalPass
	{
		private static readonly ProfilingSampler profilingSampler = new ProfilingSampler("Final");

		private CameraRendererCopier copier;

		private TextureHandle colorAttachment;

		private void Render(RenderGraphContext context)
		{
			CommandBuffer cmd = context.cmd;
			copier.CopyToCameraTarget(cmd, colorAttachment);
			context.renderContext.ExecuteCommandBuffer(cmd);
			cmd.Clear();
		}

		public static void Record(RenderGraph renderGraph, ContextContainer frameData, CameraRendererCopier copier)
		{
			RustResourceDataContext rustResourceDataContext = frameData.Get<RustResourceDataContext>();
			FinalPass passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<FinalPass>("Final", out passData, profilingSampler);
			passData.copier = copier;
			passData.colorAttachment = renderGraphBuilder.ReadTexture(rustResourceDataContext.CameraColor);
			renderGraphBuilder.SetRenderFunc(delegate(FinalPass pass, RenderGraphContext context)
			{
				pass.Render(context);
			});
		}
	}
	public class GBufferPass
	{
		private static readonly ProfilingSampler profilingSampler = new ProfilingSampler("GBuffer");

		private static readonly ShaderTagId[] shaderTagIds = new ShaderTagId[2]
		{
			new ShaderTagId("RustGBuffer"),
			new ShaderTagId("Deferred")
		};

		private readonly RenderTargetIdentifier[] gBufferRenderTargetIdentifiers = new RenderTargetIdentifier[RustResourceDataContext.gBufferTextureCount];

		private RendererListHandle renderListHandle;

		private readonly TextureHandle[] gBufferTextureHandles = new TextureHandle[RustResourceDataContext.gBufferTextureCount];

		private TextureHandle depthAttachment;

		private Camera camera;

		private void Render(RenderGraphContext context)
		{
			context.renderContext.SetupCameraProperties(camera);
			CommandBuffer cmd = context.cmd;
			for (int i = 0; i < gBufferRenderTargetIdentifiers.Length; i++)
			{
				gBufferRenderTargetIdentifiers[i] = gBufferTextureHandles[i];
			}
			cmd.SetRenderTarget(gBufferRenderTargetIdentifiers, depthAttachment);
			cmd.ClearRenderTarget(clearDepth: true, clearColor: true, Color.clear);
			context.cmd.DrawRendererList(renderListHandle);
			cmd.SetRenderTarget(gBufferRenderTargetIdentifiers[3], depthAttachment);
			context.renderContext.ExecuteCommandBuffer(context.cmd);
			context.cmd.Clear();
		}

		public static void Record(RenderGraph renderGraph, ContextContainer frameData)
		{
			RustRenderingContext rustRenderingContext = frameData.Get<RustRenderingContext>();
			RustResourceDataContext rustResourceDataContext = frameData.Get<RustResourceDataContext>();
			RustCameraContext rustCameraContext = frameData.Get<RustCameraContext>();
			GBufferPass passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<GBufferPass>(profilingSampler.name, out passData, profilingSampler);
			try
			{
				rustRenderingContext.perObjectData = PerObjectData.LightProbe | PerObjectData.ReflectionProbes;
				GBufferPass gBufferPass = passData;
				RendererListDesc desc = new RendererListDesc(shaderTagIds, rustRenderingContext.cullResults, rustCameraContext.Camera)
				{
					sortingCriteria = SortingCriteria.CommonOpaque,
					rendererConfiguration = rustRenderingContext.perObjectData,
					renderQueueRange = RenderQueueRange.opaque,
					renderingLayerMask = (uint)rustCameraContext.CameraSettings.renderingLayerMask
				};
				gBufferPass.renderListHandle = renderGraphBuilder.UseRendererList(renderGraph.CreateRendererList(in desc));
				passData.camera = rustCameraContext.Camera;
				passData.depthAttachment = renderGraphBuilder.ReadWriteTexture(rustResourceDataContext.CameraDepth);
				TextureDesc textureDesc = new TextureDesc(rustCameraContext.CameraBufferSize.x, rustCameraContext.CameraBufferSize.y);
				textureDesc.name = "GBuffer0";
				textureDesc.colorFormat = SystemInfo.GetGraphicsFormat(DefaultFormat.LDR);
				TextureDesc desc2 = textureDesc;
				rustResourceDataContext.GBuffer[0] = (passData.gBufferTextureHandles[0] = renderGraphBuilder.WriteTexture(renderGraph.CreateTexture(in desc2)));
				desc2.name = "GBuffer1";
				rustResourceDataContext.GBuffer[1] = (passData.gBufferTextureHandles[1] = renderGraphBuilder.WriteTexture(renderGraph.CreateTexture(in desc2)));
				desc2.name = "GBuffer2";
				desc2.colorFormat = GraphicsFormat.A2B10G10R10_UNormPack32;
				rustResourceDataContext.GBuffer[2] = (passData.gBufferTextureHandles[2] = renderGraphBuilder.WriteTexture(renderGraph.CreateTexture(in desc2)));
				desc2.name = "GBuffer3";
				rustResourceDataContext.GBuffer[3] = (passData.gBufferTextureHandles[3] = renderGraphBuilder.ReadWriteTexture(rustResourceDataContext.CameraColor));
				renderGraphBuilder.SetRenderFunc(delegate(GBufferPass pass, RenderGraphContext context)
				{
					pass.Render(context);
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder/*cast due to .constrained prefix*/).Dispose();
			}
		}
	}
	public class GeometryPass
	{
		private static readonly ProfilingSampler profilingSamplerOpaque = new ProfilingSampler("Opaque Geometry");

		private static readonly ProfilingSampler profilingSamplerTransparent = new ProfilingSampler("Transparent Geometry");

		private static readonly ShaderTagId[] shaderTagIds = new ShaderTagId[4]
		{
			new ShaderTagId("SRPDefaultUnlit"),
			new ShaderTagId("RustLit"),
			new ShaderTagId("ForwardBase"),
			new ShaderTagId("Vertex")
		};

		private RendererListHandle renderListHandle;

		private void Render(RenderGraphContext context)
		{
			context.cmd.DrawRendererList(renderListHandle);
			context.renderContext.ExecuteCommandBuffer(context.cmd);
			context.cmd.Clear();
		}

		public static void Record(RenderGraph renderGraph, ContextContainer frameData, bool opaque)
		{
			RustRenderingContext rustRenderingContext = frameData.Get<RustRenderingContext>();
			RustResourceDataContext rustResourceDataContext = frameData.Get<RustResourceDataContext>();
			RustCameraContext rustCameraContext = frameData.Get<RustCameraContext>();
			int renderingLayerMask = rustCameraContext.CameraSettings.renderingLayerMask;
			ProfilingSampler profilingSampler = (opaque ? profilingSamplerOpaque : profilingSamplerTransparent);
			GeometryPass passData;
			RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<GeometryPass>(profilingSampler.name, out passData, profilingSampler);
			try
			{
				rustRenderingContext.perObjectData = PerObjectData.LightProbe | PerObjectData.ReflectionProbes;
				GeometryPass geometryPass = passData;
				RendererListDesc desc = new RendererListDesc(shaderTagIds, rustRenderingContext.cullResults, rustCameraContext.Camera)
				{
					sortingCriteria = (opaque ? SortingCriteria.CommonOpaque : SortingCriteria.CommonTransparent),
					rendererConfiguration = rustRenderingContext.perObjectData,
					renderQueueRange = (opaque ? RenderQueueRange.opaque : RenderQueueRange.transparent),
					renderingLayerMask = (uint)renderingLayerMask
				};
				geometryPass.renderListHandle = renderGraphBuilder.UseRendererList(renderGraph.CreateRendererList(in desc));
				renderGraphBuilder.ReadWriteTexture(rustResourceDataContext.CameraColor);
				renderGraphBuilder.ReadWriteTexture(rustResourceDataContext.CameraDepth);
				if (!opaque)
				{
					if (rustResourceDataContext.CameraOpaqueTexture.IsValid())
					{
						renderGraphBuilder.ReadTexture(rustResourceDataContext.CameraOpaqueTexture);
					}
					if (rustResourceDataContext.CameraDepthTexture.IsValid())
					{
						renderGraphBuilder.ReadTexture(rustResourceDataContext.CameraDepthTexture);
					}
				}
				renderGraphBuilder.ReadComputeBuffer(rustResourceDataContext.DirectionalLightDataBuffer);
				renderGraphBuilder.ReadComputeBuffer(rustResourceDataContext.AdditionalLightDataBuffer);
				if (rustResourceDataContext.LightTilesBuffer.IsValid())
				{
					renderGraphBuilder.ReadComputeBuffer(rustResourceDataContext.LightTilesBuffer);
				}
				renderGraphBuilder.ReadTexture(rustResourceDataContext.MainShadowsTexture);
				renderGraphBuilder.ReadTexture(rustResourceDataContext.AdditionalShadowsTexture);
				renderGraphBuilder.ReadComputeBuffer(rustResourceDataContext.ShadowCascadesBuffer);
				renderGraphBuilder.ReadComputeBuffer(rustResourceDataContext.ShadowMatricesBuffer);
				renderGraphBuilder.ReadComputeBuffer(rustResourceDataContext.AdditionalShadowDataBuffer);
				renderGraphBuilder.SetRenderFunc(delegate(GeometryPass pass, RenderGraphContext context)
				{
					pass.Render(context);
				});
			}
			finally
			{
				((IDisposable)renderGraphBuilder/*cast due to .constrained prefix*/).Dispose();
			}
		}
	}
	public class GizmosPass
	{
		[Conditional("UNITY_EDITOR")]
		public static void Record(RenderGraph renderGraph, ContextContainer frameData, CameraRendererCopier copier)
		{
		}
	}
	public class SetupPass
	{
		private static readonly ProfilingSampler profilingSampler = new ProfilingSampler("Setup");

		private static readonly int attachmentSizeID = Shader.PropertyToID("_CameraBufferSize");

		private static readonly int envBrdfLutId = Shader.PropertyToID("global_EnvBrdfLut");

		private static readonly int envBrdfLutTexelSizeId = Shader.PropertyToID("global_EnvBrdfLut_TexelSize");

		private static readonly int blueNoiseId = Shader.PropertyToID("global_BlueNoise");

		private static readonly int blueNoiseRcpSizeId = Shader.PropertyToID("global_BlueNoiseRcpSize");

		private static readonly int preIntegratedFgdGgxId = Shader.PropertyToID("global_PFGD_GGX");

		private static readonly int preIntegratedFgdGgxTexelSizeId = Shader.PropertyToID("global_PFGD_GGX_TexelSize");

		private TextureHandle colorAttachment;

		private TextureHandle depthAttachment;

		private Vector2Int attachmentSize;

		private Camera camera;

		private CameraClearFlags clearFlags;

		private Texture envBrdfLutTexture;

		private Texture blueNoiseTexture;

		private Texture preIntegratedFgdGgxTexture;

		private void Render(RenderGraphContext context)
		{
			context.renderContext.SetupCameraProperties(camera);
			CommandBuffer cmd = context.cmd;
			cmd.SetRenderTarget(colorAttachment, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store, depthAttachment, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store);
			cmd.ClearRenderTarget(clearFlags <= CameraClearFlags.Depth, clearFlags <= CameraClearFlags.Color, (clearFlags == CameraClearFlags.Color) ? camera.backgroundColor.linear : Color.clear);
			cmd.SetGlobalVector(attachmentSizeID, new Vector4(1f / (float)attachmentSize.x, 1f / (float)attachmentSize.y, attachmentSize.x, attachmentSize.y));
			if (blueNoiseTexture != null)
			{
				cmd.SetGlobalTexture(blueNoiseId, blueNoiseTexture);
				cmd.SetGlobalFloat(blueNoiseRcpSizeId, 1f / (float)blueNoiseTexture.width);
			}
			if (preIntegratedFgdGgxTexture != null)
			{
				int width = preIntegratedFgdGgxTexture.width;
				int height = preIntegratedFgdGgxTexture.height;
				cmd.SetGlobalTexture(preIntegratedFgdGgxId, preIntegratedFgdGgxTexture);
				cmd.SetGlobalVector(preIntegratedFgdGgxTexelSizeId, new Vector4(1f / (float)width, 1f / (float)height, width, height));
			}
			if (envBrdfLutTexture != null)
			{
				int width2 = envBrdfLutTexture.width;
				int height2 = envBrdfLutTexture.height;
				cmd.SetGlobalTexture(envBrdfLutId, envBrdfLutTexture);
				cmd.SetGlobalVector(envBrdfLutTexelSizeId, new Vector4(1f / (float)width2, 1f / (float)height2, width2, height2));
			}
			context.renderContext.ExecuteCommandBuffer(cmd);
			cmd.Clear();
		}

		public static void Record(RenderGraph renderGraph, ContextContainer frameData)
		{
			RustResourceDataContext rustResourceDataContext = frameData.Get<RustResourceDataContext>();
			RustCameraContext rustCameraContext = frameData.Get<RustCameraContext>();
			RustRenderingContext rustRenderingContext = frameData.Get<RustRenderingContext>();
			SetupPass passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<SetupPass>("Setup", out passData, profilingSampler);
			passData.attachmentSize = rustCameraContext.CameraBufferSize;
			passData.camera = rustCameraContext.Camera;
			passData.clearFlags = rustCameraContext.Camera.clearFlags;
			RustRenderPipelineSettings.PipelineTextures pipelineTextures = rustRenderingContext.pipelineSettings.pipelineTextures;
			passData.envBrdfLutTexture = pipelineTextures.environmentBrdfLut;
			passData.blueNoiseTexture = pipelineTextures.blueNoise;
			passData.preIntegratedFgdGgxTexture = pipelineTextures.preIntegratedFgdGgx;
			if (passData.clearFlags > CameraClearFlags.Color)
			{
				passData.clearFlags = CameraClearFlags.Color;
			}
			TextureDesc textureDesc = new TextureDesc(rustCameraContext.CameraBufferSize.x, rustCameraContext.CameraBufferSize.y);
			textureDesc.colorFormat = SystemInfo.GetGraphicsFormat(rustCameraContext.CameraBufferSettings.allowHDR ? DefaultFormat.HDR : DefaultFormat.LDR);
			textureDesc.name = "Color Attachment";
			TextureDesc desc = (rustCameraContext.CameraTargetDescriptor = textureDesc);
			rustResourceDataContext.CameraColor = (passData.colorAttachment = renderGraphBuilder.WriteTexture(renderGraph.CreateTexture(in desc)));
			if (rustCameraContext.UseOpaqueColorTexture)
			{
				desc.name = "Color Copy";
				rustResourceDataContext.CameraOpaqueTexture = renderGraph.CreateTexture(in desc);
			}
			desc.depthBufferBits = DepthBits.Depth32;
			desc.name = "Depth Attachment";
			rustResourceDataContext.CameraDepth = (passData.depthAttachment = renderGraphBuilder.WriteTexture(renderGraph.CreateTexture(in desc)));
			if (rustCameraContext.UseDepthTexture)
			{
				desc.name = "Depth Copy";
				rustResourceDataContext.CameraDepthTexture = renderGraph.CreateTexture(in desc);
			}
			rustResourceDataContext.ActiveColorID = RustResourceDataContext.ActiveID.Camera;
			rustResourceDataContext.ActiveDepthID = RustResourceDataContext.ActiveID.Camera;
			renderGraphBuilder.AllowPassCulling(value: false);
			renderGraphBuilder.SetRenderFunc(delegate(SetupPass pass, RenderGraphContext context)
			{
				pass.Render(context);
			});
		}
	}
	public class SkyboxPass
	{
		private static readonly ProfilingSampler profilingSampler = new ProfilingSampler("Skybox");

		private Camera camera;

		private void Render(RenderGraphContext context)
		{
			context.renderContext.ExecuteCommandBuffer(context.cmd);
			context.cmd.Clear();
			context.renderContext.DrawSkybox(camera);
		}

		public static void Record(RenderGraph renderGraph, ContextContainer frameData)
		{
			RustResourceDataContext rustResourceDataContext = frameData.Get<RustResourceDataContext>();
			RustCameraContext rustCameraContext = frameData.Get<RustCameraContext>();
			if (rustCameraContext.Camera.clearFlags != CameraClearFlags.Skybox)
			{
				return;
			}
			SkyboxPass passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<SkyboxPass>(profilingSampler.name, out passData, profilingSampler);
			passData.camera = rustCameraContext.Camera;
			renderGraphBuilder.ReadWriteTexture(rustResourceDataContext.CameraColor);
			renderGraphBuilder.ReadTexture(rustResourceDataContext.CameraDepth);
			renderGraphBuilder.SetRenderFunc(delegate(SkyboxPass pass, RenderGraphContext context)
			{
				pass.Render(context);
			});
		}
	}
	public class UnsupportedShadersPass
	{
		[Conditional("UNITY_EDITOR")]
		public static void Record(RenderGraph renderGraph, ContextContainer frameData)
		{
		}
	}
}
namespace Rust.RenderPipeline.Runtime.Passes.PostProcessing
{
	public class BloomPass
	{
		private const int MAX_BLOOM_PYRAMID_LEVELS = 16;

		private static readonly ProfilingSampler sampler = new ProfilingSampler("Bloom");

		private static readonly int bicubicUpsamplingId = Shader.PropertyToID("_BloomBicubicUpsampling");

		private static readonly int intensityId = Shader.PropertyToID("_BloomIntensity");

		private static readonly int thresholdId = Shader.PropertyToID("_BloomThreshold");

		private static readonly int fxSource2Id = Shader.PropertyToID("_PostFXSource2");

		private readonly TextureHandle[] pyramid = new TextureHandle[33];

		private TextureHandle colorSource;

		private TextureHandle bloomResult;

		private PostFXBlitter postFXBlitter;

		private PostFXSettings.BloomSettings bloomSettings;

		private int stepCount;

		private void Render(RenderGraphContext context)
		{
			CommandBuffer cmd = context.cmd;
			Vector4 value = default(Vector4);
			value.x = Mathf.GammaToLinearSpace(bloomSettings.threshold);
			value.y = value.x * bloomSettings.thresholdKnee;
			value.z = 2f * value.y;
			value.w = 0.25f / (value.y + 1E-05f);
			value.y -= value.x;
			cmd.SetGlobalVector(thresholdId, value);
			postFXBlitter.Draw(cmd, colorSource, pyramid[0], bloomSettings.fadeFireflies ? PostFXPass.Pass.BloomPrefilterFireflies : PostFXPass.Pass.BloomPrefilter);
			int num = 0;
			int num2 = 2;
			int i;
			for (i = 0; i < stepCount; i++)
			{
				int num3 = num2 - 1;
				postFXBlitter.Draw(cmd, pyramid[num], pyramid[num3], PostFXPass.Pass.BloomHorizontal);
				postFXBlitter.Draw(cmd, pyramid[num3], pyramid[num2], PostFXPass.Pass.BloomVertical);
				num = num2;
				num2 += 2;
			}
			cmd.SetGlobalFloat(bicubicUpsamplingId, bloomSettings.bicubicUpsampling ? 1f : 0f);
			PostFXPass.Pass pass;
			PostFXPass.Pass pass2;
			float value2;
			if (bloomSettings.mode == PostFXSettings.BloomSettings.Mode.Additive)
			{
				pass = (pass2 = PostFXPass.Pass.BloomAdd);
				cmd.SetGlobalFloat(intensityId, 1f);
				value2 = bloomSettings.intensity;
			}
			else
			{
				pass = PostFXPass.Pass.BloomScatter;
				pass2 = PostFXPass.Pass.BloomScatterFinal;
				cmd.SetGlobalFloat(intensityId, bloomSettings.scatter);
				value2 = Mathf.Min(bloomSettings.intensity, 1f);
			}
			if (i > 1)
			{
				num2 -= 5;
				for (i--; i > 0; i--)
				{
					cmd.SetGlobalTexture(fxSource2Id, pyramid[num2 + 1]);
					postFXBlitter.Draw(cmd, pyramid[num], pyramid[num2], pass);
					num = num2;
					num2 -= 2;
				}
			}
			cmd.SetGlobalFloat(intensityId, value2);
			cmd.SetGlobalTexture(fxSource2Id, colorSource);
			postFXBlitter.Draw(cmd, pyramid[num], bloomResult, pass2);
		}

		public static TextureHandle Record(RenderGraph renderGraph, ContextContainer frameData, PostFXBlitter postFXBlitter)
		{
			RustResourceDataContext rustResourceDataContext = frameData.Get<RustResourceDataContext>();
			RustCameraContext rustCameraContext = frameData.Get<RustCameraContext>();
			PostFXSettings.BloomSettings bloom = rustCameraContext.PostFXSettings.Bloom;
			Camera camera = rustCameraContext.Camera;
			Vector2Int vector2Int = (bloom.ignoreRenderScale ? new Vector2Int(camera.pixelWidth, camera.pixelHeight) : rustCameraContext.CameraBufferSize) / 2;
			if (bloom.maxIterations == 0 || bloom.intensity <= 0f || vector2Int.y < bloom.downscaleLimit * 2 || vector2Int.x < bloom.downscaleLimit * 2)
			{
				return rustResourceDataContext.CameraColor;
			}
			BloomPass passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<BloomPass>(sampler.name, out passData, sampler);
			passData.postFXBlitter = postFXBlitter;
			passData.colorSource = renderGraphBuilder.ReadTexture(rustResourceDataContext.CameraColor);
			passData.bloomSettings = bloom;
			TextureDesc textureDesc = new TextureDesc(vector2Int.x, vector2Int.y);
			textureDesc.colorFormat = SystemInfo.GetGraphicsFormat(rustCameraContext.CameraBufferSettings.allowHDR ? DefaultFormat.HDR : DefaultFormat.LDR);
			textureDesc.name = "Bloom Prefilter";
			TextureDesc desc = textureDesc;
			TextureHandle[] array = passData.pyramid;
			array[0] = renderGraphBuilder.CreateTransientTexture(in desc);
			vector2Int /= 2;
			int num = 1;
			int num2 = 0;
			while (num2 < bloom.maxIterations && vector2Int.y >= bloom.downscaleLimit && vector2Int.x >= bloom.downscaleLimit)
			{
				desc.width = vector2Int.x;
				desc.height = vector2Int.y;
				desc.name = "Bloom Pyramid H";
				array[num] = renderGraphBuilder.CreateTransientTexture(in desc);
				desc.name = "Bloom Pyramid V";
				array[num + 1] = renderGraphBuilder.CreateTransientTexture(in desc);
				vector2Int /= 2;
				num2++;
				num += 2;
			}
			passData.stepCount = num2;
			desc.width = rustCameraContext.CameraBufferSize.x;
			desc.height = rustCameraContext.CameraBufferSize.y;
			desc.name = "Bloom Result";
			passData.bloomResult = renderGraphBuilder.WriteTexture(renderGraph.CreateTexture(in desc));
			renderGraphBuilder.SetRenderFunc(delegate(BloomPass pass, RenderGraphContext context)
			{
				pass.Render(context);
			});
			return passData.bloomResult;
		}
	}
	public class ColorLutPass
	{
		private static readonly ProfilingSampler sampler = new ProfilingSampler("Color LUT");

		private static readonly int colorGradingLutId = Shader.PropertyToID("_ColorGradingLUT");

		private static readonly int colorAdjustmentsId = Shader.PropertyToID("_ColorAdjustments");

		private static readonly int colorFilterId = Shader.PropertyToID("_ColorFilter");

		private static readonly int whiteBalanceId = Shader.PropertyToID("_WhiteBalance");

		private static readonly int splitToningShadowsId = Shader.PropertyToID("_SplitToningShadows");

		private static readonly int splitToningHighlightsId = Shader.PropertyToID("_SplitToningHighlights");

		private static readonly int channelMixerRedId = Shader.PropertyToID("_ChannelMixerRed");

		private static readonly int channelMixerGreenId = Shader.PropertyToID("_ChannelMixerGreen");

		private static readonly int channelMixerBlueId = Shader.PropertyToID("_ChannelMixerBlue");

		private static readonly int smhShadowsId = Shader.PropertyToID("_SMHShadows");

		private static readonly int smhMidtonesId = Shader.PropertyToID("_SMHMidtones");

		private static readonly int smhHighlightsId = Shader.PropertyToID("_SMHHighlights");

		private static readonly int smhRangeId = Shader.PropertyToID("_SMHRange");

		private static readonly int colorGradingLutParametersId = Shader.PropertyToID("_ColorGradingLUTParameters");

		private static readonly int colorGradingLutInLogCId = Shader.PropertyToID("_ColorGradingLUTInLogC");

		private static readonly GraphicsFormat colorFormat = SystemInfo.GetGraphicsFormat(DefaultFormat.HDR);

		private int colorLutResolution;

		private TextureHandle colorLut;

		private PostFXSettings postFXSettings;

		private PostFXBlitter postFXBlitter;

		private bool allowHDR;

		private void ConfigureColorAdjustments(CommandBuffer commandBuffer, PostFXSettings settings)
		{
			PostFXSettings.ColorAdjustmentsSettings colorAdjustments = settings.ColorAdjustments;
			commandBuffer.SetGlobalVector(colorAdjustmentsId, new Vector4(Mathf.Pow(2f, colorAdjustments.postExposure), colorAdjustments.contrast * 0.01f + 1f, colorAdjustments.hueShift * 0.0027777778f, colorAdjustments.saturation * 0.01f + 1f));
			commandBuffer.SetGlobalColor(colorFilterId, colorAdjustments.colorFilter.linear);
		}

		private void ConfigureWhiteBalance(CommandBuffer commandBuffer, PostFXSettings settings)
		{
			PostFXSettings.WhiteBalanceSettings whiteBalance = settings.WhiteBalance;
			commandBuffer.SetGlobalVector(whiteBalanceId, ColorUtils.ColorBalanceToLMSCoeffs(whiteBalance.temperature, whiteBalance.tint));
		}

		private void ConfigureSplitToning(CommandBuffer commandBuffer, PostFXSettings settings)
		{
			PostFXSettings.SplitToningSettings splitToning = settings.SplitToning;
			Color shadows = splitToning.shadows;
			shadows.a = splitToning.balance * 0.01f;
			commandBuffer.SetGlobalColor(splitToningShadowsId, shadows);
			commandBuffer.SetGlobalColor(splitToningHighlightsId, splitToning.highlights);
		}

		private void ConfigureChannelMixer(CommandBuffer commandBuffer, PostFXSettings settings)
		{
			PostFXSettings.ChannelMixerSettings channelMixer = settings.ChannelMixer;
			commandBuffer.SetGlobalVector(channelMixerRedId, channelMixer.red);
			commandBuffer.SetGlobalVector(channelMixerGreenId, channelMixer.green);
			commandBuffer.SetGlobalVector(channelMixerBlueId, channelMixer.blue);
		}

		private void ConfigureShadowsMidtonesHighlights(CommandBuffer commandBuffer, PostFXSettings settings)
		{
			PostFXSettings.ShadowsMidtonesHighlightsSettings shadowsMidtonesHighlights = settings.ShadowsMidtonesHighlights;
			commandBuffer.SetGlobalColor(smhShadowsId, shadowsMidtonesHighlights.shadows.linear);
			commandBuffer.SetGlobalColor(smhMidtonesId, shadowsMidtonesHighlights.midtones.linear);
			commandBuffer.SetGlobalColor(smhHighlightsId, shadowsMidtonesHighlights.highlights.linear);
			commandBuffer.SetGlobalVector(smhRangeId, new Vector4(shadowsMidtonesHighlights.shadowsStart, shadowsMidtonesHighlights.shadowsEnd, shadowsMidtonesHighlights.highlightsStart, shadowsMidtonesHighlights.highLightsEnd));
		}

		private void Render(RenderGraphContext context)
		{
			CommandBuffer cmd = context.cmd;
			ConfigureColorAdjustments(cmd, postFXSettings);
			ConfigureWhiteBalance(cmd, postFXSettings);
			ConfigureSplitToning(cmd, postFXSettings);
			ConfigureChannelMixer(cmd, postFXSettings);
			ConfigureShadowsMidtonesHighlights(cmd, postFXSettings);
			int num = colorLutResolution;
			int num2 = num * num;
			cmd.SetGlobalVector(colorGradingLutParametersId, new Vector4(num, 0.5f / (float)num2, 0.5f / (float)num, (float)num / ((float)num - 1f)));
			PostFXSettings.ToneMappingSettings.Mode mode = postFXSettings.ToneMapping.mode;
			PostFXPass.Pass pass = (PostFXPass.Pass)(7 + mode);
			cmd.SetGlobalFloat(colorGradingLutInLogCId, (allowHDR && pass != PostFXPass.Pass.ColorGradingNone) ? 1f : 0f);
			postFXBlitter.Draw(cmd, colorLut, pass);
			cmd.SetGlobalVector(colorGradingLutParametersId, new Vector4(1f / (float)num2, 1f / (float)num, (float)num - 1f));
			cmd.SetGlobalTexture(colorGradingLutId, colorLut);
		}

		public static TextureHandle Record(RenderGraph renderGraph, ContextContainer frameData, PostFXBlitter postFXBlitter)
		{
			RustCameraContext rustCameraContext = frameData.Get<RustCameraContext>();
			int num = (int)frameData.Get<RustRenderingContext>().pipelineSettings.colorLutResolution;
			ColorLutPass passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<ColorLutPass>(sampler.name, out passData, sampler);
			passData.colorLutResolution = num;
			passData.postFXSettings = rustCameraContext.PostFXSettings;
			passData.allowHDR = rustCameraContext.CameraBufferSettings.allowHDR;
			passData.postFXBlitter = postFXBlitter;
			int num2 = num;
			int width = num2 * num2;
			TextureDesc textureDesc = new TextureDesc(width, num2);
			textureDesc.colorFormat = colorFormat;
			textureDesc.name = "Color LUT";
			TextureDesc desc = textureDesc;
			passData.colorLut = renderGraphBuilder.WriteTexture(renderGraph.CreateTexture(in desc));
			renderGraphBuilder.SetRenderFunc(delegate(ColorLutPass pass, RenderGraphContext context)
			{
				pass.Render(context);
			});
			return passData.colorLut;
		}
	}
	public struct PostFXBlitter
	{
		private static readonly Rect fullViewRect = new Rect(0f, 0f, 1f, 1f);

		private static readonly int fxSourceId = Shader.PropertyToID("_PostFXSource");

		private static readonly int finalSrcBlendId = Shader.PropertyToID("_FinalSrcBlend");

		private static readonly int finalDstBlendId = Shader.PropertyToID("_FinalDstBlend");

		private readonly Camera camera;

		private readonly CameraSettings cameraSettings;

		private readonly PostFXSettings postFXSettings;

		public PostFXBlitter(ContextContainer frameData)
		{
			RustCameraContext rustCameraContext = frameData.Get<RustCameraContext>();
			camera = rustCameraContext.Camera;
			cameraSettings = rustCameraContext.CameraSettings;
			postFXSettings = rustCameraContext.PostFXSettings;
		}

		public void Draw(CommandBuffer commandBuffer, RenderTargetIdentifier to, PostFXPass.Pass pass)
		{
			commandBuffer.SetRenderTarget(to, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store);
			commandBuffer.DrawProcedural(Matrix4x4.identity, postFXSettings.Material, (int)pass, MeshTopology.Triangles, 3);
		}

		public void Draw(CommandBuffer commandBuffer, RenderTargetIdentifier from, RenderTargetIdentifier to, PostFXPass.Pass pass)
		{
			commandBuffer.SetGlobalTexture(fxSourceId, from);
			commandBuffer.SetRenderTarget(to, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store);
			commandBuffer.DrawProcedural(Matrix4x4.identity, postFXSettings.Material, (int)pass, MeshTopology.Triangles, 3);
		}

		public void DrawFinal(CommandBuffer commandBuffer, RenderTargetIdentifier from, PostFXPass.Pass pass)
		{
			commandBuffer.SetGlobalFloat(finalSrcBlendId, (float)cameraSettings.finalBlendMode.source);
			commandBuffer.SetGlobalFloat(finalDstBlendId, (float)cameraSettings.finalBlendMode.destination);
			commandBuffer.SetGlobalTexture(fxSourceId, from);
			commandBuffer.SetRenderTarget(BuiltinRenderTextureType.CameraTarget, (cameraSettings.finalBlendMode.destination == BlendMode.Zero && camera.rect == fullViewRect) ? RenderBufferLoadAction.DontCare : RenderBufferLoadAction.Load, RenderBufferStoreAction.Store);
			commandBuffer.SetViewport(camera.pixelRect);
			commandBuffer.DrawProcedural(Matrix4x4.identity, postFXSettings.Material, (int)pass, MeshTopology.Triangles, 3);
		}
	}
	public class PostFXPass
	{
		public enum Pass
		{
			BloomPrefilter,
			BloomPrefilterFireflies,
			BloomHorizontal,
			BloomVertical,
			BloomAdd,
			BloomScatter,
			BloomScatterFinal,
			ColorGradingNone,
			ColorGradingACES,
			ColorGradingNeutral,
			ColorGradingReinhard,
			ApplyColorGrading,
			ApplyColorGradingWithLuma,
			FXAA,
			FXAAWithLuma,
			FinalRescale,
			Copy
		}

		private enum ScaleMode
		{
			None,
			Bilinear,
			Bicubic
		}

		private static readonly ProfilingSampler groupSampler = new ProfilingSampler("Post FX");

		private static readonly ProfilingSampler finalSampler = new ProfilingSampler("Final Post FX");

		private static readonly int copyBicubicId = Shader.PropertyToID("_CopyBicubic");

		private static readonly int fxaaConfigId = Shader.PropertyToID("_FXAAConfig");

		private static readonly int finalSrcBlendId = Shader.PropertyToID("_FinalSrcBlend");

		private static readonly int finalDstBlendId = Shader.PropertyToID("_FinalDstBlend");

		private static readonly GlobalKeyword fxaaLowKeyword = GlobalKeyword.Create("FXAA_QUALITY_LOW");

		private static readonly GlobalKeyword fxaaMediumKeyword = GlobalKeyword.Create("FXAA_QUALITY_MEDIUM");

		private static readonly GraphicsFormat colorFormat = SystemInfo.GetGraphicsFormat(DefaultFormat.LDR);

		private bool keepAlpha;

		private ScaleMode scaleMode;

		private TextureHandle colorSource;

		private TextureHandle colorGradingResult;

		private TextureHandle scaledResult;

		private CameraBufferSettings.FxaaSettings fxaaSettings;

		private PostFXBlitter postFXBlitter;

		private void ConfigureFxaa(CommandBuffer commandBuffer)
		{
			commandBuffer.SetKeyword(in fxaaLowKeyword, fxaaSettings.quality == CameraBufferSettings.FxaaSettings.Quality.Low);
			commandBuffer.SetKeyword(in fxaaMediumKeyword, fxaaSettings.quality == CameraBufferSettings.FxaaSettings.Quality.Medium);
			commandBuffer.SetGlobalVector(fxaaConfigId, new Vector4(fxaaSettings.fixedThreshold, fxaaSettings.relativeThreshold, fxaaSettings.subpixelBlending));
		}

		private void Render(RenderGraphContext context)
		{
			CommandBuffer cmd = context.cmd;
			cmd.SetGlobalFloat(finalSrcBlendId, 1f);
			cmd.SetGlobalFloat(finalDstBlendId, 0f);
			RenderTargetIdentifier renderTargetIdentifier;
			Pass pass;
			if (fxaaSettings.enabled)
			{
				renderTargetIdentifier = colorGradingResult;
				pass = (keepAlpha ? Pass.FXAA : Pass.FXAAWithLuma);
				ConfigureFxaa(cmd);
				postFXBlitter.Draw(cmd, colorSource, renderTargetIdentifier, keepAlpha ? Pass.ApplyColorGrading : Pass.ApplyColorGradingWithLuma);
			}
			else
			{
				renderTargetIdentifier = colorSource;
				pass = Pass.ApplyColorGrading;
			}
			if (scaleMode == ScaleMode.None)
			{
				postFXBlitter.DrawFinal(cmd, renderTargetIdentifier, pass);
			}
			else
			{
				postFXBlitter.Draw(cmd, renderTargetIdentifier, scaledResult, pass);
				cmd.SetGlobalFloat(copyBicubicId, (scaleMode == ScaleMode.Bicubic) ? 1f : 0f);
				postFXBlitter.DrawFinal(cmd, scaledResult, Pass.FinalRescale);
			}
			context.renderContext.ExecuteCommandBuffer(cmd);
			cmd.Clear();
		}

		public static void Record(RenderGraph renderGraph, ContextContainer frameData)
		{
			RustCameraContext rustCameraContext = frameData.Get<RustCameraContext>();
			using (new RenderGraphProfilingScope(renderGraph, groupSampler))
			{
				bool flag = rustCameraContext.CameraSettings.keepAlpha;
				PostFXBlitter postFXBlitter = new PostFXBlitter(frameData);
				TextureHandle input = BloomPass.Record(renderGraph, frameData, postFXBlitter);
				TextureHandle input2 = ColorLutPass.Record(renderGraph, frameData, postFXBlitter);
				PostFXPass passData;
				using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<PostFXPass>(finalSampler.name, out passData, finalSampler);
				passData.keepAlpha = flag;
				passData.colorSource = renderGraphBuilder.ReadTexture(in input);
				passData.fxaaSettings = rustCameraContext.CameraBufferSettings.fxaaSettings;
				passData.postFXBlitter = postFXBlitter;
				renderGraphBuilder.ReadTexture(in input2);
				if (rustCameraContext.CameraBufferSize.x == rustCameraContext.Camera.pixelWidth)
				{
					passData.scaleMode = ScaleMode.None;
				}
				else
				{
					passData.scaleMode = ((rustCameraContext.CameraBufferSettings.bicubicRescaling != CameraBufferSettings.BicubicRescalingMode.UpAndDown && (rustCameraContext.CameraBufferSettings.bicubicRescaling != CameraBufferSettings.BicubicRescalingMode.UpOnly || rustCameraContext.CameraBufferSize.x >= rustCameraContext.Camera.pixelWidth)) ? ScaleMode.Bilinear : ScaleMode.Bicubic);
				}
				bool enabled = rustCameraContext.CameraBufferSettings.fxaaSettings.enabled;
				if (enabled || passData.scaleMode != ScaleMode.None)
				{
					TextureDesc textureDesc = new TextureDesc(rustCameraContext.CameraBufferSize.x, rustCameraContext.CameraBufferSize.y);
					textureDesc.colorFormat = colorFormat;
					TextureDesc desc = textureDesc;
					if (enabled)
					{
						desc.name = "Color Grading Result";
						passData.colorGradingResult = renderGraphBuilder.CreateTransientTexture(in desc);
					}
					if (passData.scaleMode != ScaleMode.None)
					{
						desc.name = "Scaled Result";
						passData.scaledResult = renderGraphBuilder.CreateTransientTexture(in desc);
					}
				}
				renderGraphBuilder.SetRenderFunc(delegate(PostFXPass pass, RenderGraphContext context)
				{
					pass.Render(context);
				});
			}
		}
	}
}
namespace Rust.RenderPipeline.Runtime.Passes.Lighting
{
	public struct AdditionalLightData
	{
		public const int STRIDE = 80;

		public Vector4 color;

		public Vector4 position;

		public Vector4 directionAndMask;

		public Vector4 spotAngle;

		public Vector4 shadowData;

		public static AdditionalLightData CreatePointLight(ref VisibleLight visibleLight, Light light, Vector4 shadowData)
		{
			AdditionalLightData result = default(AdditionalLightData);
			result.color = visibleLight.finalColor;
			result.position = visibleLight.localToWorldMatrix.GetColumn(3);
			result.position.w = 1f / Mathf.Max(visibleLight.range * visibleLight.range, 1E-05f);
			result.spotAngle = new Vector4(0f, 1f);
			result.directionAndMask = Vector4.zero;
			result.directionAndMask.w = light.renderingLayerMask.ReinterpretAsFloat();
			result.shadowData = shadowData;
			return result;
		}

		public static AdditionalLightData CreateSpotLight(ref VisibleLight visibleLight, Light light, Vector4 shadowData)
		{
			AdditionalLightData result = default(AdditionalLightData);
			result.color = visibleLight.finalColor;
			result.position = visibleLight.localToWorldMatrix.GetColumn(3);
			result.position.w = 1f / Mathf.Max(visibleLight.range * visibleLight.range, 1E-05f);
			result.directionAndMask = -visibleLight.localToWorldMatrix.GetColumn(2);
			result.directionAndMask.w = light.renderingLayerMask.ReinterpretAsFloat();
			float num = Mathf.Cos(MathF.PI / 360f * light.innerSpotAngle);
			float num2 = Mathf.Cos(MathF.PI / 360f * visibleLight.spotAngle);
			float num3 = 1f / Mathf.Max(num - num2, 0.001f);
			result.spotAngle = new Vector4(num3, (0f - num2) * num3);
			result.shadowData = shadowData;
			return result;
		}
	}
	public struct AdditionalShadowData
	{
		public const int STRIDE = 80;

		public Vector4 tileData;

		public Matrix4x4 shadowMatrix;

		public AdditionalShadowData(Vector2 offset, float scale, float bias, float border, Matrix4x4 matrix)
		{
			tileData.x = offset.x * scale + border;
			tileData.y = offset.y * scale + border;
			tileData.z = scale - border - border;
			tileData.w = bias;
			shadowMatrix = matrix;
		}
	}
	public class DeferredIndirectLightingPass
	{
		private enum Pass
		{
			IndirectLighting,
			Combine
		}

		private static readonly ProfilingSampler drawIndirectLightingSampler = new ProfilingSampler("Draw Indirect Lighting");

		private static readonly ProfilingSampler combineIndirectLightingSampler = new ProfilingSampler("Combine Indirect Lighting");

		private static readonly int indirectDiffuseTextureId = Shader.PropertyToID("_IndirectDiffuseTexture");

		private static readonly int indirectSpecularTextureId = Shader.PropertyToID("_IndirectSpecularTexture");

		private static readonly int inverseViewProjectionMatrixId = Shader.PropertyToID("_InvViewProjection");

		private static readonly int gBuffer0Id = Shader.PropertyToID("_CameraGBufferTexture0");

		private static readonly int gBuffer1Id = Shader.PropertyToID("_CameraGBufferTexture1");

		private static readonly int gBuffer2Id = Shader.PropertyToID("_CameraGBufferTexture2");

		private static readonly int gBuffer3Id = Shader.PropertyToID("_CameraGBufferTexture3");

		private readonly RenderTargetIdentifier[] indirectLightingRenderTargets = new RenderTargetIdentifier[2];

		private readonly TextureHandle[] gBufferTextureHandles = new TextureHandle[RustResourceDataContext.gBufferTextureCount];

		private TextureHandle indirectDiffuseHandle;

		private TextureHandle indirectSpecularHandle;

		private TextureHandle cameraColorHandle;

		private TextureHandle cameraDepthHandle;

		private Camera camera;

		private Material material;

		private void Setup(Camera camera, Material material)
		{
			this.camera = camera;
			this.material = material;
		}

		private void DrawIndirectLighting(RenderGraphContext context)
		{
			CommandBuffer cmd = context.cmd;
			Matrix4x4 inverse = (GL.GetGPUProjectionMatrix(camera.projectionMatrix, renderIntoTexture: true) * camera.worldToCameraMatrix).inverse;
			indirectLightingRenderTargets[0] = indirectDiffuseHandle;
			indirectLightingRenderTargets[1] = indirectSpecularHandle;
			cmd.SetGlobalMatrix(inverseViewProjectionMatrixId, inverse);
			cmd.GetTemporaryRT(indirectSpecularTextureId, camera.pixelWidth, camera.pixelHeight, 0, FilterMode.Point, GraphicsFormat.R16G16B16A16_SFloat);
			cmd.SetRenderTarget(indirectLightingRenderTargets, cameraDepthHandle);
			cmd.SetGlobalTexture(gBuffer0Id, gBufferTextureHandles[0]);
			cmd.SetGlobalTexture(gBuffer1Id, gBufferTextureHandles[1]);
			cmd.SetGlobalTexture(gBuffer2Id, gBufferTextureHandles[2]);
			cmd.SetGlobalTexture(gBuffer3Id, gBufferTextureHandles[3]);
			cmd.ClearRenderTarget(RTClearFlags.Color, Color.clear, 1f, 0u);
			cmd.DrawProcedural(Matrix4x4.identity, material, 0, MeshTopology.Triangles, 3);
		}

		private void CombineIndirectLighting(RenderGraphContext context)
		{
			CommandBuffer cmd = context.cmd;
			cmd.SetRenderTarget(cameraColorHandle, cameraDepthHandle);
			cmd.SetGlobalTexture(indirectDiffuseTextureId, indirectDiffuseHandle);
			cmd.SetGlobalTexture(indirectSpecularTextureId, indirectSpecularHandle);
			cmd.DrawProcedural(Matrix4x4.identity, material, 1, MeshTopology.Triangles, 3);
		}

		private static bool SkipPass(Camera camera)
		{
			return camera.cameraType == CameraType.Reflection;
		}

		public static void Record_DrawIndirectLighting(RenderGraph renderGraph, ContextContainer frameData, Material material)
		{
			RustCameraContext rustCameraContext = frameData.Get<RustCameraContext>();
			if (SkipPass(rustCameraContext.Camera))
			{
				return;
			}
			RustResourceDataContext rustResourceDataContext = frameData.Get<RustResourceDataContext>();
			DeferredIndirectLightingPass passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<DeferredIndirectLightingPass>(drawIndirectLightingSampler.name, out passData, drawIndirectLightingSampler);
			TextureDesc textureDesc = new TextureDesc(rustCameraContext.CameraBufferSize.x, rustCameraContext.CameraBufferSize.y);
			textureDesc.colorFormat = SystemInfo.GetGraphicsFormat(rustCameraContext.CameraBufferSettings.allowHDR ? DefaultFormat.HDR : DefaultFormat.LDR);
			textureDesc.name = "Indirect Diffuse";
			TextureDesc desc = textureDesc;
			rustResourceDataContext.IndirectDiffuseHandle = (passData.indirectDiffuseHandle = renderGraphBuilder.WriteTexture(renderGraph.CreateTexture(in desc)));
			desc.name = "Indirect Specular";
			rustResourceDataContext.IndirectSpecularHandle = (passData.indirectSpecularHandle = renderGraphBuilder.WriteTexture(renderGraph.CreateTexture(in desc)));
			passData.Setup(rustCameraContext.Camera, material);
			for (int i = 0; i < passData.gBufferTextureHandles.Length; i++)
			{
				passData.gBufferTextureHandles[i] = renderGraphBuilder.ReadTexture(in rustResourceDataContext.GBuffer[i]);
			}
			renderGraphBuilder.ReadTexture(rustResourceDataContext.CameraDepthTexture);
			passData.cameraDepthHandle = renderGraphBuilder.ReadTexture(rustResourceDataContext.CameraDepth);
			renderGraphBuilder.SetRenderFunc(delegate(DeferredIndirectLightingPass pass, RenderGraphContext context)
			{
				pass.DrawIndirectLighting(context);
			});
		}

		public static void Record_CombineIndirectLighting(RenderGraph renderGraph, ContextContainer frameData, Material material)
		{
			Camera camera = frameData.Get<RustCameraContext>().Camera;
			if (SkipPass(camera))
			{
				return;
			}
			RustResourceDataContext rustResourceDataContext = frameData.Get<RustResourceDataContext>();
			DeferredIndirectLightingPass passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<DeferredIndirectLightingPass>(combineIndirectLightingSampler.name, out passData, combineIndirectLightingSampler);
			passData.Setup(camera, material);
			passData.indirectDiffuseHandle = renderGraphBuilder.ReadTexture(rustResourceDataContext.IndirectDiffuseHandle);
			passData.indirectSpecularHandle = renderGraphBuilder.ReadTexture(rustResourceDataContext.IndirectSpecularHandle);
			passData.cameraColorHandle = renderGraphBuilder.ReadWriteTexture(rustResourceDataContext.CameraColor);
			passData.cameraDepthHandle = renderGraphBuilder.ReadTexture(rustResourceDataContext.CameraDepth);
			renderGraphBuilder.SetRenderFunc(delegate(DeferredIndirectLightingPass pass, RenderGraphContext context)
			{
				pass.CombineIndirectLighting(context);
			});
		}
	}
	public class DeferredLightingPass
	{
		private enum ShaderPasses
		{
			StencilVolume,
			Lighting,
			DirectionalLighting
		}

		private const float STENCIL_SHAPE_GUARD = 1.06067f;

		private static readonly ProfilingSampler profilingSampler = new ProfilingSampler("Deferred Lighting");

		private static readonly int gBuffer0Id = Shader.PropertyToID("_CameraGBufferTexture0");

		private static readonly int gBuffer1Id = Shader.PropertyToID("_CameraGBufferTexture1");

		private static readonly int gBuffer2Id = Shader.PropertyToID("_CameraGBufferTexture2");

		private static readonly int inverseViewProjId = Shader.PropertyToID("_InverseViewProj");

		private static readonly int spotLightScaleId = Shader.PropertyToID("_SpotLightScale");

		private static readonly int spotLightBiasId = Shader.PropertyToID("_SpotLightBias");

		private static readonly int spotLightGuardId = Shader.PropertyToID("_SpotLightGuard");

		private static readonly int lightColorId = Shader.PropertyToID("_LightColor");

		private static readonly int lightPositionAndRangeId = Shader.PropertyToID("_LightPositionAndRange");

		private static readonly int lightDirectionAndMaskId = Shader.PropertyToID("_LightDirectionAndMask");

		private static readonly int lightSpotAngleId = Shader.PropertyToID("_LightSpotAngles");

		private static readonly int lightShadowDataId = Shader.PropertyToID("_LightShadowData");

		private static readonly int deferredLightIndex = Shader.PropertyToID("_DeferredLightIndex");

		private readonly TextureHandle[] gBufferTextureHandles = new TextureHandle[RustResourceDataContext.gBufferTextureCount];

		private CullingResults cullingResults;

		private Mesh icoSphere;

		private Mesh icoHemisphere;

		private Material deferredLightingMaterial;

		private Camera camera;

		private CameraSettings cameraSettings;

		private Dictionary<Light, Vector4> lightShadowData;

		private int mainLightIndex;

		private static Mesh CreateSphereMesh()
		{
			Vector3[] vertices = new Vector3[42]
			{
				new Vector3(0f, 0f, -1.07f),
				new Vector3(0.174f, -0.535f, -0.91f),
				new Vector3(-0.455f, -0.331f, -0.91f),
				new Vector3(0.562f, 0f, -0.91f),
				new Vector3(-0.455f, 0.331f, -0.91f),
				new Vector3(0.174f, 0.535f, -0.91f),
				new Vector3(-0.281f, -0.865f, -0.562f),
				new Vector3(0.736f, -0.535f, -0.562f),
				new Vector3(0.296f, -0.91f, -0.468f),
				new Vector3(-0.91f, 0f, -0.562f),
				new Vector3(-0.774f, -0.562f, -0.478f),
				new Vector3(0f, -1.07f, 0f),
				new Vector3(-0.629f, -0.865f, 0f),
				new Vector3(0.629f, -0.865f, 0f),
				new Vector3(-1.017f, -0.331f, 0f),
				new Vector3(0.957f, 0f, -0.478f),
				new Vector3(0.736f, 0.535f, -0.562f),
				new Vector3(1.017f, -0.331f, 0f),
				new Vector3(1.017f, 0.331f, 0f),
				new Vector3(-0.296f, -0.91f, 0.478f),
				new Vector3(0.281f, -0.865f, 0.562f),
				new Vector3(0.774f, -0.562f, 0.478f),
				new Vector3(-0.736f, -0.535f, 0.562f),
				new Vector3(0.91f, 0f, 0.562f),
				new Vector3(0.455f, -0.331f, 0.91f),
				new Vector3(-0.174f, -0.535f, 0.91f),
				new Vector3(0.629f, 0.865f, 0f),
				new Vector3(0.774f, 0.562f, 0.478f),
				new Vector3(0.455f, 0.331f, 0.91f),
				new Vector3(0f, 0f, 1.07f),
				new Vector3(-0.562f, 0f, 0.91f),
				new Vector3(-0.957f, 0f, 0.478f),
				new Vector3(0.281f, 0.865f, 0.562f),
				new Vector3(-0.174f, 0.535f, 0.91f),
				new Vector3(0.296f, 0.91f, -0.478f),
				new Vector3(-1.017f, 0.331f, 0f),
				new Vector3(-0.736f, 0.535f, 0.562f),
				new Vector3(-0.296f, 0.91f, 0.478f),
				new Vector3(0f, 1.07f, 0f),
				new Vector3(-0.281f, 0.865f, -0.562f),
				new Vector3(-0.774f, 0.562f, -0.478f),
				new Vector3(-0.629f, 0.865f, 0f)
			};
			int[] triangles = new int[240]
			{
				0, 1, 2, 0, 3, 1, 2, 4, 0, 0,
				5, 3, 0, 4, 5, 1, 6, 2, 3, 7,
				1, 1, 8, 6, 1, 7, 8, 9, 4, 2,
				2, 6, 10, 10, 9, 2, 8, 11, 6, 6,
				12, 10, 11, 12, 6, 7, 13, 8, 8, 13,
				11, 10, 14, 9, 10, 12, 14, 3, 15, 7,
				5, 16, 3, 3, 16, 15, 15, 17, 7, 17,
				13, 7, 16, 18, 15, 15, 18, 17, 11, 19,
				12, 13, 20, 11, 11, 20, 19, 17, 21, 13,
				13, 21, 20, 12, 19, 22, 12, 22, 14, 17,
				23, 21, 18, 23, 17, 21, 24, 20, 23, 24,
				21, 20, 25, 19, 19, 25, 22, 24, 25, 20,
				26, 18, 16, 18, 27, 23, 26, 27, 18, 28,
				24, 23, 27, 28, 23, 24, 29, 25, 28, 29,
				24, 25, 30, 22, 25, 29, 30, 14, 22, 31,
				22, 30, 31, 32, 28, 27, 26, 32, 27, 33,
				29, 28, 30, 29, 33, 33, 28, 32, 34, 26,
				16, 5, 34, 16, 14, 31, 35, 14, 35, 9,
				31, 30, 36, 30, 33, 36, 35, 31, 36, 37,
				33, 32, 36, 33, 37, 38, 32, 26, 34, 38,
				26, 38, 37, 32, 5, 39, 34, 39, 38, 34,
				4, 39, 5, 9, 40, 4, 9, 35, 40, 4,
				40, 39, 35, 36, 41, 41, 36, 37, 41, 37,
				38, 40, 35, 41, 40, 41, 39, 41, 38, 39
			};
			return new Mesh
			{
				indexFormat = IndexFormat.UInt16,
				vertices = vertices,
				triangles = triangles,
				hideFlags = HideFlags.HideAndDontSave
			};
		}

		private static Mesh CreateHemisphereMesh()
		{
			Vector3[] vertices = new Vector3[42]
			{
				new Vector3(0f, 0f, 0f),
				new Vector3(1f, 0f, 0f),
				new Vector3(0.92388f, 0.382683f, 0f),
				new Vector3(0.707107f, 0.707107f, 0f),
				new Vector3(0.382683f, 0.92388f, 0f),
				new Vector3(-0f, 1f, 0f),
				new Vector3(-0.382684f, 0.92388f, 0f),
				new Vector3(-0.707107f, 0.707107f, 0f),
				new Vector3(-0.92388f, 0.382683f, 0f),
				new Vector3(-1f, -0f, 0f),
				new Vector3(-0.92388f, -0.382683f, 0f),
				new Vector3(-0.707107f, -0.707107f, 0f),
				new Vector3(-0.382683f, -0.92388f, 0f),
				new Vector3(0f, -1f, 0f),
				new Vector3(0.382684f, -0.923879f, 0f),
				new Vector3(0.707107f, -0.707107f, 0f),
				new Vector3(0.92388f, -0.382683f, 0f),
				new Vector3(0f, 0f, 1f),
				new Vector3(0.707107f, 0f, 0.707107f),
				new Vector3(0f, -0.707107f, 0.707107f),
				new Vector3(0f, 0.707107f, 0.707107f),
				new Vector3(-0.707107f, 0f, 0.707107f),
				new Vector3(0.816497f, -0.408248f, 0.408248f),
				new Vector3(0.408248f, -0.408248f, 0.816497f),
				new Vector3(0.408248f, -0.816497f, 0.408248f),
				new Vector3(0.408248f, 0.816497f, 0.408248f),
				new Vector3(0.408248f, 0.408248f, 0.816497f),
				new Vector3(0.816497f, 0.408248f, 0.408248f),
				new Vector3(-0.816497f, 0.408248f, 0.408248f),
				new Vector3(-0.408248f, 0.408248f, 0.816497f),
				new Vector3(-0.408248f, 0.816497f, 0.408248f),
				new Vector3(-0.408248f, -0.816497f, 0.408248f),
				new Vector3(-0.408248f, -0.408248f, 0.816497f),
				new Vector3(-0.816497f, -0.408248f, 0.408248f),
				new Vector3(0f, -0.92388f, 0.382683f),
				new Vector3(0.92388f, 0f, 0.382683f),
				new Vector3(0f, -0.382683f, 0.92388f),
				new Vector3(0.382683f, 0f, 0.92388f),
				new Vector3(0f, 0.92388f, 0.382683f),
				new Vector3(0f, 0.382683f, 0.92388f),
				new Vector3(-0.92388f, 0f, 0.382683f),
				new Vector3(-0.382683f, 0f, 0.92388f)
			};
			int[] triangles = new int[240]
			{
				0, 2, 1, 0, 3, 2, 0, 4, 3, 0,
				5, 4, 0, 6, 5, 0, 7, 6, 0, 8,
				7, 0, 9, 8, 0, 10, 9, 0, 11, 10,
				0, 12, 11, 0, 13, 12, 0, 14, 13, 0,
				15, 14, 0, 16, 15, 0, 1, 16, 22, 23,
				24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
				14, 24, 34, 35, 22, 16, 36, 23, 37, 2,
				27, 35, 38, 25, 4, 37, 26, 39, 6, 30,
				38, 40, 28, 8, 39, 29, 41, 10, 33, 40,
				34, 31, 12, 41, 32, 36, 15, 22, 24, 18,
				23, 22, 19, 24, 23, 3, 25, 27, 20, 26,
				25, 18, 27, 26, 7, 28, 30, 21, 29, 28,
				20, 30, 29, 11, 31, 33, 19, 32, 31, 21,
				33, 32, 13, 14, 34, 15, 24, 14, 19, 34,
				24, 1, 35, 16, 18, 22, 35, 15, 16, 22,
				17, 36, 37, 19, 23, 36, 18, 37, 23, 1,
				2, 35, 3, 27, 2, 18, 35, 27, 5, 38,
				4, 20, 25, 38, 3, 4, 25, 17, 37, 39,
				18, 26, 37, 20, 39, 26, 5, 6, 38, 7,
				30, 6, 20, 38, 30, 9, 40, 8, 21, 28,
				40, 7, 8, 28, 17, 39, 41, 20, 29, 39,
				21, 41, 29, 9, 10, 40, 11, 33, 10, 21,
				40, 33, 13, 34, 12, 19, 31, 34, 11, 12,
				31, 17, 41, 36, 21, 32, 41, 19, 36, 32
			};
			return new Mesh
			{
				indexFormat = IndexFormat.UInt16,
				vertices = vertices,
				triangles = triangles,
				hideFlags = HideFlags.HideAndDontSave
			};
		}

		private void Setup(Material deferredLightingMaterial, CullingResults cullingResults, ShadowSettings shadowSettings, int renderingLayerMask, Camera camera, CameraSettings cameraSettings)
		{
			this.deferredLightingMaterial = deferredLightingMaterial;
			this.cullingResults = cullingResults;
			this.camera = camera;
			this.cameraSettings = cameraSettings;
			if (icoSphere == null)
			{
				icoSphere = CreateSphereMesh();
			}
			if (icoHemisphere == null)
			{
				icoHemisphere = CreateHemisphereMesh();
			}
		}

		private void Render(RenderGraphContext context)
		{
			NativeArray<VisibleLight> visibleLights = cullingResults.visibleLights;
			CommandBuffer cmd = context.cmd;
			mainLightIndex = LightingPass.GetMainLightIndex(visibleLights);
			cmd.SetGlobalMatrix(value: (GL.GetGPUProjectionMatrix(camera.projectionMatrix, renderIntoTexture: true) * camera.worldToCameraMatrix).inverse, nameID: inverseViewProjId);
			cmd.SetGlobalTexture(gBuffer0Id, gBufferTextureHandles[0]);
			cmd.SetGlobalTexture(gBuffer1Id, gBufferTextureHandles[1]);
			cmd.SetGlobalTexture(gBuffer2Id, gBufferTextureHandles[2]);
			RenderPointLight(context, visibleLights);
			RenderSpotLight(context, visibleLights);
			RenderDirectionalLight(context, visibleLights);
			context.renderContext.ExecuteCommandBuffer(context.cmd);
			context.cmd.Clear();
		}

		private void RenderPointLight(RenderGraphContext context, NativeArray<VisibleLight> visibleLights)
		{
			CommandBuffer cmd = context.cmd;
			for (int i = 0; i < visibleLights.Length; i++)
			{
				VisibleLight visibleLight = visibleLights[i];
				if (visibleLight.lightType == LightType.Point && (visibleLight.light.renderingLayerMask & cameraSettings.renderingLayerMask) != 0)
				{
					Vector3 vector = visibleLight.localToWorldMatrix.GetColumn(3);
					Matrix4x4 matrix = new Matrix4x4(new Vector4(visibleLight.range, 0f, 0f, 0f), new Vector4(0f, visibleLight.range, 0f, 0f), new Vector4(0f, 0f, visibleLight.range, 0f), new Vector4(vector.x, vector.y, vector.z, 1f));
					if (!lightShadowData.TryGetValue(visibleLight.light, out var value))
					{
						value = Vector4.zero;
					}
					AdditionalLightData additionalLightData = AdditionalLightData.CreatePointLight(ref visibleLight, visibleLight.light, value);
					cmd.BeginSample("Point Light");
					cmd.SetGlobalVector(lightColorId, additionalLightData.color);
					cmd.SetGlobalVector(lightPositionAndRangeId, additionalLightData.position);
					cmd.SetGlobalVector(lightDirectionAndMaskId, additionalLightData.directionAndMask);
					cmd.SetGlobalVector(lightSpotAngleId, additionalLightData.spotAngle);
					cmd.SetGlobalVector(lightShadowDataId, additionalLightData.shadowData);
					cmd.SetGlobalInt(deferredLightIndex, (mainLightIndex == -1) ? i : (i - 1));
					cmd.DrawMesh(icoSphere, matrix, deferredLightingMaterial, 0, 0);
					cmd.DrawMesh(icoSphere, matrix, deferredLightingMaterial, 0, 1);
					cmd.EndSample("Point Light");
				}
			}
		}

		private void RenderSpotLight(RenderGraphContext context, NativeArray<VisibleLight> visibleLights)
		{
			CommandBuffer cmd = context.cmd;
			cmd.EnableShaderKeyword("_SPOT");
			for (int i = 0; i < visibleLights.Length; i++)
			{
				VisibleLight visibleLight = visibleLights[i];
				if (visibleLight.lightType == LightType.Spot && (visibleLight.light.renderingLayerMask & cameraSettings.renderingLayerMask) != 0)
				{
					float f = MathF.PI / 180f * visibleLight.spotAngle * 0.5f;
					float num = Mathf.Cos(f);
					float num2 = Mathf.Sin(f);
					float num3 = Mathf.Lerp(1f, 1.06067f, num2);
					if (!lightShadowData.TryGetValue(visibleLight.light, out var value))
					{
						value = Vector4.zero;
					}
					AdditionalLightData additionalLightData = AdditionalLightData.CreateSpotLight(ref visibleLight, visibleLight.light, value);
					_ = GL.GetGPUProjectionMatrix(Matrix4x4.Perspective(visibleLight.spotAngle, 1f, 0.001f, visibleLight.range), renderIntoTexture: true) * visibleLight.localToWorldMatrix.inverse;
					cmd.BeginSample("Spot Light");
					cmd.SetGlobalColor(lightColorId, additionalLightData.color);
					cmd.SetGlobalVector(lightPositionAndRangeId, additionalLightData.position);
					cmd.SetGlobalVector(lightDirectionAndMaskId, additionalLightData.directionAndMask);
					cmd.SetGlobalVector(lightSpotAngleId, additionalLightData.spotAngle);
					cmd.SetGlobalVector(lightShadowDataId, additionalLightData.shadowData);
					cmd.SetGlobalVector(spotLightScaleId, new Vector4(num2, num2, 1f - num, visibleLight.range));
					cmd.SetGlobalVector(spotLightBiasId, new Vector4(0f, 0f, num, 0f));
					cmd.SetGlobalVector(spotLightGuardId, new Vector4(num3, num3, num3, num * visibleLight.range));
					cmd.SetGlobalInt(deferredLightIndex, (mainLightIndex == -1) ? i : (i - 1));
					cmd.DrawMesh(icoHemisphere, visibleLight.localToWorldMatrix, deferredLightingMaterial, 0, 0);
					cmd.DrawMesh(icoHemisphere, visibleLight.localToWorldMatrix, deferredLightingMaterial, 0, 1);
					cmd.EndSample("Spot Light");
				}
			}
			cmd.DisableShaderKeyword("_SPOT");
		}

		private void RenderDirectionalLight(RenderGraphContext context, NativeArray<VisibleLight> visibleLights)
		{
			CommandBuffer cmd = context.cmd;
			cmd.EnableShaderKeyword("_DIRECTIONAL");
			for (int i = 0; i < visibleLights.Length; i++)
			{
				VisibleLight visibleLight = visibleLights[i];
				if (visibleLight.lightType == LightType.Directional && (visibleLight.light.renderingLayerMask & cameraSettings.renderingLayerMask) != 0)
				{
					if (!lightShadowData.TryGetValue(visibleLight.light, out var value))
					{
						value = Vector4.zero;
					}
					DirectionalLightData directionalLightData = new DirectionalLightData(ref visibleLight, visibleLight.light, value);
					cmd.BeginSample("Directional Light");
					cmd.SetGlobalColor(lightColorId, directionalLightData.color);
					cmd.SetGlobalVector(lightDirectionAndMaskId, directionalLightData.directionAndMask);
					cmd.SetGlobalVector(lightShadowDataId, directionalLightData.shadowData);
					cmd.DrawProcedural(Matrix4x4.identity, deferredLightingMaterial, 2, MeshTopology.Triangles, 3);
					cmd.EndSample("Directional Light");
				}
			}
			cmd.DisableShaderKeyword("_DIRECTIONAL");
		}

		public static void Record(RenderGraph renderGraph, ContextContainer frameData, Material deferredLightingMaterial)
		{
			RustResourceDataContext rustResourceDataContext = frameData.Get<RustResourceDataContext>();
			RustCameraContext rustCameraContext = frameData.Get<RustCameraContext>();
			RustRenderingContext rustRenderingContext = frameData.Get<RustRenderingContext>();
			CameraSettings cameraSettings = rustCameraContext.CameraSettings;
			ShadowSettings shadows = rustRenderingContext.pipelineSettings.shadows;
			DeferredLightingPass passData;
			using RenderGraphBuilder renderGraphBuilder = renderGraph.AddRenderPass<DeferredLightingPass>(profilingSampler.name, out passData);
			passData.Setup(deferredLightingMaterial, rustRenderingContext.cullResults, shadows, rustCameraContext.CameraSettings.renderingLayerMask, rustCameraContext.Camera, cameraSettings);
			passData.lightShadowData = rustResourceDataContext.LightShadowData;
			for (int i = 0; i < rustResourceDataContext.GBuffer.Length - 1; i++)
			{
				passData.gBufferTextureHandles[i] = renderGraphBuilder.ReadTexture(in rustResourceDataContext.GBuffer[i]);
			}
			passData.gBufferTextureHandles[3] = renderGraphBuilder.ReadWriteTexture(in rustResourceDataContext.GBuffer[3]);
			renderGraphBuilder.ReadWriteTexture(rustResourceDataContext.CameraDepth);
			renderGraphBuilder.ReadTexture(rustResourceDataContext.CameraDepthTexture);
			renderGraphBuilder.ReadTexture(rustResourceDataContext.MainShadowsTexture);
			renderGraphBuilder.ReadTexture(rustResourceDataContext.AdditionalShadowsTexture);
			renderGraphBuilder.ReadComputeBuffer(rustResourceDataContext.ShadowMatricesBuffer);
			renderGraphBuilder.ReadComputeBuffer(rustResourceDataContext.ShadowCascadesBuffer);
			renderGraphBuilder.ReadComputeBuffer(rustResourceDataContext.AdditionalShadowDataBuffer);
			renderGraphBuilder.SetRenderFunc(delegate(DeferredLightingPass pass, RenderGraphContext context)
			{
				pass.Render(context);
			});
		}
	}
	public struct DirectionalLightData
	{
		public const int STRIDE = 48;

		public Vector4 color;

		public Vector4 directionAndMask;

		public Vector4 shadowData;

		public DirectionalLightData(ref VisibleLight visibleLight, Light light, Vector4 shadowData)
		{
			color = visibleLight.finalColor;
			directionAndMask = -visibleLight.localToWorldMatrix.GetColumn(2);
			directionAndMask.w = light.renderingLayerMask.ReinterpretAsFloat();
			this.shadowData = shadowData;
		}
	}
	public struct DirectionalShadowCascade
	{
		public const int STRIDE = 32;

		public Vector4 cullingSphere;

		public Vector4 data;

		public DirectionalShadowCascade(Vector4 cullingSphere, float tileSize, float filterSize)
		{
			float num = 2f * cullingSphere.w / tileSize;
			filterSize *= num;
			cullingSphere.w -= filterSize;
			cullingSphere.w *= cullingSphere.w;
			this.cullingSphere = cullingSphere;
			data = new Vector4(1f / cullingSphere.w, filterSize * 1.4142137f);
		}
	}
	[BurstCompile(FloatPrecision.Standard, FloatMode.Fast)]
	public struct ForwardPlusTilesJob : IJobFor
	{
		[Unity.Collections.ReadOnly]
		public NativeArray<float4> lightBounds;

		[WriteOnly]
		[NativeDisableParallelForRestriction]
		public NativeArray<int> tileData;

		public int additionalLightCount;

		public float2 tileScreenUVSize;

		public int maxLightsPerTile;

		public int tilesPerRow;

		public int tileDataSize;

		public void Execute(int tileIndex)
		{
			int num = tileIndex / tilesPerRow;
			int num2 = tileIndex - num * tilesPerRow;
			float4 @float = math.float4(num2, num, num2 + 1, num + 1) * tileScreenUVSize.xyxy;
			int num3 = tileIndex * tileDataSize;
			int num4 = num3;
			int num5 = 0;
			for (int i = 0; i < additionalLightCount; i++)
			{
				float4 float2 = lightBounds[i];
				if (math.all(math.float4(float2.xy, @float.xy) <= math.float4(@float.zw, float2.zw)))
				{
					tileData[++num4] = i;
					if (++num5 >= maxLightsPerTile)
					{
						break;
					}
				}
			}
			tileData[num3] = num5;
		}
	}
	public class LightCookieManager : IDisposable
	{
		private static class ShaderProperty
		{
			public static readonly int mainLightTexture = Shader.PropertyToID("_MainLightCookieTexture");

			public static readonly int mainLightWorldToLight = Shader.PropertyToID("_MainLightWorldToLight");

			public static readonly int mainLightCookieTextureFormat = Shader.PropertyToID("_MainLightCookieTextureFormat");

			public static readonly int additionalLightsCookieAtlasTexture = Shader.PropertyToID("_AdditionalLightsCookieAtlasTexture");

			public static readonly int additionalLightsCookieAtlasTextureFormat = Shader.PropertyToID("_AdditionalLightsCookieAtlasTextureFormat");

			public static readonly int additionalLightsCookieEnableBits = Shader.PropertyToID("_AdditionalLightsCookieEnableBits");

			public static readonly int additionalLightsCookieAtlasUVRectBuffer = Shader.PropertyToID("_AdditionalLightsCookieAtlasUVRectBuffer");

			public static readonly int additionalLightsCookieAtlasUVRects = Shader.PropertyToID("_AdditionalLightsCookieAtlasUVRects");

			public static readonly int additionalLightsWorldToLightBuffer = Shader.PropertyToID("_AdditionalLightsWorldToLightBuffer");

			public static readonly int additionalLightsLightTypeBuffer = Shader.PropertyToID("_AdditionalLightsLightTypeBuffer");

			public static readonly int additionalLightsWorldToLights = Shader.PropertyToID("_AdditionalLightsWorldToLights");

			public static readonly int additionalLightsLightTypes = Shader.PropertyToID("_AdditionalLightsLightTypes");
		}

		private enum LightCookieShaderFormat
		{
			None = -1,
			RGB,
			Alpha,
			Red
		}

		public struct Settings
		{
			public struct AtlasSettings
			{
				public Vector2Int resolution;

				public GraphicsFormat format;

				public bool isPow2
				{
					get
					{
						if (Mathf.IsPowerOfTwo(resolution.x))
						{
							return Mathf.IsPowerOfTwo(resolution.y);
						}
						return false;
					}
				}

				public bool isSquare => resolution.x == resolution.y;
			}

			public AtlasSettings atlas;

			public int maxAdditionalLights;

			public float cubeOctahedralSizeScale;

			public bool useStructuredBuffer;

			public static Settings Create()
			{
				Settings result = default(Settings);
				result.atlas.resolution = new Vector2Int(1024, 1024);
				result.atlas.format = GraphicsFormat.R8G8B8A8_SRGB;
				result.maxAdditionalLights = 128;
				result.cubeOctahedralSizeScale = 2.5f;
				result.useStructuredBuffer = true;
				return result;
			}
		}

		[StructLayout(LayoutKind.Sequential, Size = 1)]
		private struct Sorting
		{
			public static void QuickSort<T>(T[] data, Func<T, T, int> compare)
			{
				QuickSort(data, 0, data.Length - 1, compare);
			}

			public static void QuickSort<T>(T[] data, int start, int end, Func<T, T, int> compare)
			{
				int num = end - start;
				if (num < 1)
				{
					return;
				}
				if (num < 8)
				{
					InsertionSort(data, start, end, compare);
					return;
				}
				Assert.IsTrue((uint)start < data.Length);
				Assert.IsTrue((uint)end < data.Length);
				if (start < end)
				{
					int num2 = Partition(data, start, end, compare);
					if (num2 >= 1)
					{
						QuickSort(data, start, num2, compare);
					}
					if (num2 + 1 < end)
					{
						QuickSort(data, num2 + 1, end, compare);
					}
				}
			}

			private static T Median3Pivot<T>(T[] data, int start, int pivot, int end, Func<T, T, int> compare)
			{
				if (compare(data[end], data[start]) < 0)
				{
					Swap(start, end);
				}
				if (compare(data[pivot], data[start]) < 0)
				{
					Swap(start, pivot);
				}
				if (compare(data[end], data[pivot]) < 0)
				{
					Swap(pivot, end);
				}
				return data[pivot];
				void Swap(int a, int b)
				{
					T val = data[a];
					data[a] = data[b];
					data[b] = val;
				}
			}

			private static int Partition<T>(T[] data, int start, int end, Func<T, T, int> compare)
			{
				int num = end - start;
				int pivot = start + num / 2;
				T arg = Median3Pivot(data, start, pivot, end, compare);
				while (true)
				{
					if (compare(data[start], arg) < 0)
					{
						start++;
						continue;
					}
					while (compare(data[end], arg) > 0)
					{
						end--;
					}
					if (start >= end)
					{
						break;
					}
					T val = data[start];
					data[start++] = data[end];
					data[end--] = val;
				}
				return end;
			}

			public static void InsertionSort<T>(T[] data, int start, int end, Func<T, T, int> compare)
			{
				Assert.IsTrue((uint)start < data.Length);
				Assert.IsTrue((uint)end < data.Length);
				for (int i = start + 1; i < end + 1; i++)
				{
					T val = data[i];
					int num = i - 1;
					while (num >= 0 && compare(val, data[num]) < 0)
					{
						data[num + 1] = data[num];
						num--;
					}
					data[num + 1] = val;
				}
			}
		}

		private struct LightCookieMapping
		{
			public ushort visibleLightIndex;

			public ushort lightBufferIndex;

			public Light light;

			public static Func<LightCookieMapping, LightCookieMapping, int> s_CompareByCookieSize = delegate(LightCookieMapping a, LightCookieMapping b)
			{
				Texture cookie = a.light.cookie;
				Texture cookie2 = b.light.cookie;
				int num = cookie.width * cookie.height;
				int num2 = cookie2.width * cookie2.height - num;
				if (num2 == 0)
				{
					int instanceID = cookie.GetInstanceID();
					int instanceID2 = cookie2.GetInstanceID();
					return instanceID - instanceID2;
				}
				return num2;
			};

			public static Func<LightCookieMapping, LightCookieMapping, int> s_CompareByBufferIndex = (LightCookieMapping a, LightCookieMapping b) => a.lightBufferIndex - b.lightBufferIndex;
		}

		private readonly struct WorkSlice<T>
		{
			private readonly T[] m_Data;

			private readonly int m_Start;

			private readonly int m_Length;

			public T this[int index]
			{
				get
				{
					return m_Data[m_Start + index];
				}
				set
				{
					m_Data[m_Start + index] = value;
				}
			}

			public int length => m_Length;

			public int capacity => m_Data.Length;

			public WorkSlice(T[] src, int srcLen = -1)
				: this(src, 0, srcLen)
			{
			}

			public WorkSlice(T[] src, int srcStart, int srcLen = -1)
			{
				m_Data = src;
				m_Start = srcStart;
				m_Length = ((srcLen < 0) ? src.Length : Math.Min(srcLen, src.Length));
				Assert.IsTrue(m_Start + m_Length <= capacity);
			}

			public void Sort(Func<T, T, int> compare)
			{
				if (m_Length > 1)
				{
					Sorting.QuickSort(m_Data, m_Start, m_Start + m_Length - 1, compare);
				}
			}
		}

		private class WorkMemory
		{
			public LightCookieMapping[] lightMappings;

			public Vector4[] uvRects;

			public void Resize(int size)
			{
				if (!(size <= lightMappings?.Length))
				{
					size = Math.Max(size, (size + 15) / 16 * 16);
					lightMappings = new LightCookieMapping[size];
					uvRects = new Vector4[size];
				}
			}
		}

		private class LightCookieShaderData : IDisposable
		{
			private int m_Size;

			private bool m_UseStructuredBuffer;

			private Matrix4x4[] m_WorldToLightCpuData;

			private Vector4[] m_AtlasUVRectCpuData;

			private float[] m_LightTypeCpuData;

			private ShaderBitArray m_CookieEnableBitsCpuData;

			private ComputeBuffer m_WorldToLightBuffer;

			private ComputeBuffer m_AtlasUVRectBuffer;

			private ComputeBuffer m_LightTypeBuffer;

			public Matrix4x4[] worldToLights => m_WorldToLightCpuData;

			public ShaderBitArray cookieEnableBits => m_CookieEnableBitsCpuData;

			public Vector4[] atlasUVRects => m_AtlasUVRectCpuData;

			public float[] lightTypes => m_LightTypeCpuData;

			public bool isUploaded { get; set; }

			public LightCookieShaderData(int size, bool useStructuredBuffer)
			{
				m_UseStructuredBuffer = useStructuredBuffer;
				Resize(size);
			}

			public void Dispose()
			{
				if (m_UseStructuredBuffer)
				{
					m_WorldToLightBuffer?.Dispose();
					m_AtlasUVRectBuffer?.Dispose();
					m_LightTypeBuffer?.Dispose();
				}
			}

			public void Resize(int size)
			{
				if (size > m_Size)
				{
					if (m_Size > 0)
					{
						Dispose();
					}
					m_WorldToLightCpuData = new Matrix4x4[size];
					m_AtlasUVRectCpuData = new Vector4[size];
					m_LightTypeCpuData = new float[size];
					m_CookieEnableBitsCpuData.Resize(size);
					if (m_UseStructuredBuffer)
					{
						m_WorldToLightBuffer = new ComputeBuffer(size, Marshal.SizeOf<Matrix4x4>());
						m_AtlasUVRectBuffer = new ComputeBuffer(size, Marshal.SizeOf<Vector4>());
						m_LightTypeBuffer = new ComputeBuffer(size, Marshal.SizeOf<float>());
					}
					m_Size = size;
				}
			}

			public void Upload(CommandBuffer cmd)
			{
				if (m_UseStructuredBuffer)
				{
					m_WorldToLightBuffer.SetData(m_WorldToLightCpuData);
					m_AtlasUVRectBuffer.SetData(m_AtlasUVRectCpuData);
					m_LightTypeBuffer.SetData(m_LightTypeCpuData);
					cmd.SetGlobalBuffer(ShaderProperty.additionalLightsWorldToLightBuffer, m_WorldToLightBuffer);
					cmd.SetGlobalBuffer(ShaderProperty.additionalLightsCookieAtlasUVRectBuffer, m_AtlasUVRectBuffer);
					cmd.SetGlobalBuffer(ShaderProperty.additionalLightsLightTypeBuffer, m_LightTypeBuffer);
				}
				else
				{
					cmd.SetGlobalMatrixArray(ShaderProperty.additionalLightsWorldToLights, m_WorldToLightCpuData);
					cmd.SetGlobalVectorArray(ShaderProperty.additionalLightsCookieAtlasUVRects, m_AtlasUVRectCpuData);
					cmd.SetGlobalFloatArray(ShaderProperty.additionalLightsLightTypes, m_LightTypeCpuData);
				}
				cmd.SetGlobalFloatArray(ShaderProperty.additionalLightsCookieEnableBits, m_CookieEnableBitsCpuData.data);
				isUploaded = true;
			}

			public void Clear(CommandBuffer cmd)
			{
				if (isUploaded)
				{
					m_CookieEnableBitsCpuData.Clear();
					cmd.SetGlobalFloatArray(ShaderProperty.additionalLightsCookieEnableBits, m_CookieEnableBitsCpuData.data);
					isUploaded = false;
				}
			}
		}

		private static readonly ProfilingSampler lightCookieProfilingSampler = new ProfilingSampler("Light Cookies");

		private readonly GlobalKeyword lightCookiesKeyword = GlobalKeyword.Create("_LIGHT_COOKIES");

		private static readonly Matrix4x4 s_DirLightProj = Matrix4x4.Ortho(-0.5f, 0.5f, -0.5f, 0.5f, -0.5f, 0.5f);

		private Texture2DAtlas m_AdditionalLightsCookieAtlas;

		private LightCookieShaderData m_AdditionalLightsCookieShaderData;

		private readonly Settings m_Settings;

		private WorkMemory m_WorkMem;

		private int[] m_VisibleLightIndexToShaderDataIndex;

		private const int k_MaxCookieSizeDivisor = 16;

		private int m_CookieSizeDivisor = 1;

		private uint m_PrevCookieRequestPixelCount = uint.MaxValue;

		private int m_PrevWarnFrame = -1;

		internal bool IsKeywordLightCookieEnabled { get; private set; }

		internal RTHandle AdditionalLightsCookieAtlasTexture => m_AdditionalLightsCookieAtlas?.AtlasTexture;

		public LightCookieManager(ref Settings settings)
		{
			m_Settings = settings;
			m_WorkMem = new WorkMemory();
		}

		private void InitAdditionalLights(int size)
		{
			m_AdditionalLightsCookieAtlas = new Texture2DAtlas(m_Settings.atlas.resolution.x, m_Settings.atlas.resolution.y, m_Settings.atlas.format, FilterMode.Bilinear, powerOfTwoPadding: false, "Rust Additional Light Cookie Atlas", useMipMap: false);
			m_AdditionalLightsCookieShaderData = new LightCookieShaderData(size, m_Settings.useStructuredBuffer);
			m_VisibleLightIndexToShaderDataIndex = new int[m_Settings.maxAdditionalLights + 1];
			m_CookieSizeDivisor = 1;
			m_PrevCookieRequestPixelCount = uint.MaxValue;
		}

		public bool isInitialized()
		{
			if (m_AdditionalLightsCookieAtlas != null)
			{
				return m_AdditionalLightsCookieShaderData != null;
			}
			return false;
		}

		public void Dispose()
		{
			m_AdditionalLightsCookieAtlas?.Release();
			m_AdditionalLightsCookieShaderData?.Dispose();
		}

		public int GetLightCookieShaderDataIndex(int visibleLightIndex)
		{
			if (!isInitialized())
			{
				return -1;
			}
			return m_VisibleLightIndexToShaderDataIndex[visibleLightIndex];
		}

		public void Setup(CommandBuffer cmd, ref NativeArray<VisibleLight> visibleLights, int mainLightIndex, int additionalLightsCount)
		{
			using (new ProfilingScope(cmd, lightCookieProfilingSampler))
			{
				bool flag = mainLightIndex >= 0;
				if (flag && visibleLights.Length > mainLightIndex)
				{
					VisibleLight visibleMainLight = visibleLights[mainLightIndex];
					flag = SetupMainLight(cmd, ref visibleMainLight);
				}
				bool flag2 = additionalLightsCount > 0;
				if (flag2)
				{
					flag2 = SetupAdditionalLights(cmd, ref visibleLights, mainLightIndex);
				}
				if (!flag2)
				{
					if (m_VisibleLightIndexToShaderDataIndex != null && m_AdditionalLightsCookieShaderData.isUploaded)
					{
						int num = m_VisibleLightIndexToShaderDataIndex.Length;
						for (int i = 0; i < num; i++)
						{
							m_VisibleLightIndexToShaderDataIndex[i] = -1;
						}
					}
					m_AdditionalLightsCookieShaderData?.Clear(cmd);
				}
				IsKeywordLightCookieEnabled = flag || flag2;
				cmd.SetKeyword(in lightCookiesKeyword, IsKeywordLightCookieEnabled);
			}
		}

		private bool SetupMainLight(CommandBuffer cmd, ref VisibleLight visibleMainLight)
		{
			Texture cookie = visibleMainLight.light.cookie;
			bool num = cookie != null;
			if (num)
			{
				float value = (float)GetLightCookieShaderFormat(cookie.graphicsFormat);
				Matrix4x4 value2 = s_DirLightProj * visibleMainLight.localToWorldMatrix.inverse;
				cmd.SetGlobalTexture(ShaderProperty.mainLightTexture, cookie);
				cmd.SetGlobalMatrix(ShaderProperty.mainLightWorldToLight, value2);
				cmd.SetGlobalFloat(ShaderProperty.mainLightCookieTextureFormat, value);
				return num;
			}
			cmd.SetGlobalTexture(ShaderProperty.mainLightTexture, Texture2D.whiteTexture);
			cmd.SetGlobalMatrix(ShaderProperty.mainLightWorldToLight, Matrix4x4.identity);
			cmd.SetGlobalFloat(ShaderProperty.mainLightCookieTextureFormat, -1f);
			return num;
		}

		private LightCookieShaderFormat GetLightCookieShaderFormat(GraphicsFormat cookieFormat)
		{
			switch (cookieFormat)
			{
			default:
				return LightCookieShaderFormat.RGB;
			case (GraphicsFormat)54:
			case (GraphicsFormat)55:
				return LightCookieShaderFormat.Alpha;
			case GraphicsFormat.R8_SRGB:
			case GraphicsFormat.R8_UNorm:
			case GraphicsFormat.R8_SNorm:
			case GraphicsFormat.R8_UInt:
			case GraphicsFormat.R8_SInt:
			case GraphicsFormat.R16_UNorm:
			case GraphicsFormat.R16_SNorm:
			case GraphicsFormat.R16_UInt:
			case GraphicsFormat.R16_SInt:
			case GraphicsFormat.R32_UInt:
			case GraphicsFormat.R32_SInt:
			case GraphicsFormat.R16_SFloat:
			case GraphicsFormat.R32_SFloat:
			case GraphicsFormat.R_BC4_UNorm:
			case GraphicsFormat.R_BC4_SNorm:
			case GraphicsFormat.R_EAC_UNorm:
			case GraphicsFormat.R_EAC_SNorm:
				return LightCookieShaderFormat.Red;
			}
		}

		private bool SetupAdditionalLights(CommandBuffer cmd, ref NativeArray<VisibleLight> visibleLights, int mainLightIndex)
		{
			int size = Math.Min(m_Settings.maxAdditionalLights, visibleLights.Length);
			m_WorkMem.Resize(size);
			int num = FilterAndValidateAdditionalLights(ref visibleLights, mainLightIndex, m_WorkMem.lightMappings);
			if (num <= 0)
			{
				return false;
			}
			if (!isInitialized())
			{
				InitAdditionalLights(num);
			}
			WorkSlice<LightCookieMapping> validLightMappings = new WorkSlice<LightCookieMapping>(m_WorkMem.lightMappings, num);
			int srcLen = UpdateAdditionalLightsAtlas(cmd, ref validLightMappings, m_WorkMem.uvRects);
			WorkSlice<Vector4> validUvRects = new WorkSlice<Vector4>(m_WorkMem.uvRects, srcLen);
			UploadAdditionalLights(cmd, ref visibleLights, ref validLightMappings, ref validUvRects);
			return validUvRects.length > 0;
		}

		private int FilterAndValidateAdditionalLights(ref NativeArray<VisibleLight> visibleLights, int mainLightIndex, LightCookieMapping[] validLightMappings)
		{
			int num = 0;
			int num2 = 0;
			int length = visibleLights.Length;
			LightCookieMapping lightCookieMapping = default(LightCookieMapping);
			for (int i = 0; i < length; i++)
			{
				if (i == mainLightIndex)
				{
					num--;
					continue;
				}
				ref VisibleLight reference = ref visibleLights.UnsafeElementAtMutable(i);
				Light light = reference.light;
				if (light.cookie == null)
				{
					continue;
				}
				LightType lightType = reference.lightType;
				if (lightType != LightType.Spot && lightType != LightType.Point && lightType != LightType.Directional)
				{
					UnityEngine.Debug.LogWarning("Additional " + lightType.ToString() + " light called '" + light.name + "' has a light cookie which will not be visible.", light);
					continue;
				}
				Assert.IsTrue(i < 65535);
				lightCookieMapping.visibleLightIndex = (ushort)i;
				lightCookieMapping.lightBufferIndex = (ushort)(i + num);
				lightCookieMapping.light = light;
				if (lightCookieMapping.lightBufferIndex >= validLightMappings.Length || num2 + 1 >= validLightMappings.Length)
				{
					if (length > m_Settings.maxAdditionalLights && Time.frameCount - m_PrevWarnFrame > 3600)
					{
						m_PrevWarnFrame = Time.frameCount;
						UnityEngine.Debug.LogWarning("Max light cookies (" + validLightMappings.Length + ") reached. Some visible lights (" + (length - i - 1) + ") might skip light cookie rendering.");
					}
					break;
				}
				validLightMappings[num2++] = lightCookieMapping;
			}
			return num2;
		}

		private int UpdateAdditionalLightsAtlas(CommandBuffer cmd, ref WorkSlice<LightCookieMapping> validLightMappings, Vector4[] textureAtlasUVRects)
		{
			validLightMappings.Sort(LightCookieMapping.s_CompareByCookieSize);
			uint num = ComputeCookieRequestPixelCount(ref validLightMappings);
			Vector2Int referenceSize = m_AdditionalLightsCookieAtlas.AtlasTexture.referenceSize;
			float requestAtlasRatio = (float)num / (float)(referenceSize.x * referenceSize.y);
			int num2 = ApproximateCookieSizeDivisor(requestAtlasRatio);
			if (num2 < m_CookieSizeDivisor && num < m_PrevCookieRequestPixelCount)
			{
				m_AdditionalLightsCookieAtlas.ResetAllocator();
				m_CookieSizeDivisor = num2;
			}
			int num3 = 0;
			while (num3 <= 0)
			{
				num3 = FetchUVRects(cmd, ref validLightMappings, textureAtlasUVRects, m_CookieSizeDivisor);
				if (num3 <= 0)
				{
					m_AdditionalLightsCookieAtlas.ResetAllocator();
					m_CookieSizeDivisor = Mathf.Max(m_CookieSizeDivisor + 1, num2);
					m_PrevCookieRequestPixelCount = num;
				}
			}
			return num3;
		}

		private int FetchUVRects(CommandBuffer cmd, ref WorkSlice<LightCookieMapping> validLightMappings, Vector4[] textureAtlasUVRects, int cookieSizeDivisor)
		{
			int result = 0;
			for (int i = 0; i < validLightMappings.length; i++)
			{
				Light light = validLightMappings[i].light;
				Texture cookie = light.cookie;
				Vector4 zero = Vector4.zero;
				if (cookie.dimension == TextureDimension.Cube)
				{
					Assert.IsTrue(light.type == LightType.Point);
					zero = FetchCube(cmd, cookie, cookieSizeDivisor);
				}
				else
				{
					Assert.IsTrue(light.type == LightType.Spot || light.type == LightType.Directional, "Light type needs 2D texture!");
					zero = Fetch2D(cmd, cookie, cookieSizeDivisor);
				}
				if (!(zero != Vector4.zero))
				{
					if (cookieSizeDivisor > 16)
					{
						UnityEngine.Debug.LogWarning("Light cookies atlas is extremely full! Some of the light cookies were discarded. Increase light cookie atlas space or reduce the amount of unique light cookies.");
						return result;
					}
					return 0;
				}
				if (!SystemInfo.graphicsUVStartsAtTop)
				{
					zero.w = 1f - zero.w - zero.y;
				}
				textureAtlasUVRects[result++] = zero;
			}
			return result;
		}

		private uint ComputeCookieRequestPixelCount(ref WorkSlice<LightCookieMapping> validLightMappings)
		{
			uint num = 0u;
			int num2 = 0;
			for (int i = 0; i < validLightMappings.length; i++)
			{
				Texture cookie = validLightMappings[i].light.cookie;
				int instanceID = cookie.GetInstanceID();
				if (instanceID != num2)
				{
					num2 = instanceID;
					int num3 = cookie.width * cookie.height;
					num += (uint)num3;
				}
			}
			return num;
		}

		private int ApproximateCookieSizeDivisor(float requestAtlasRatio)
		{
			return (int)Mathf.Max(Mathf.Ceil(Mathf.Sqrt(requestAtlasRatio)), 1f);
		}

		private Vector4 Fetch2D(CommandBuffer cmd, Texture cookie, int cookieSizeDivisor = 1)
		{
			Assert.IsTrue(cookie != null);
			Assert.IsTrue(cookie.dimension == TextureDimension.Tex2D);
			Vector4 scaleOffset = Vector4.zero;
			int num = Mathf.Max(cookie.width / cookieSizeDivisor, 4);
			int num2 = Mathf.Max(cookie.height / cookieSizeDivisor, 4);
			Vector2 cookieSize = new Vector2(num, num2);
			if (m_AdditionalLightsCookieAtlas.IsCached(out scaleOffset, cookie))
			{
				m_AdditionalLightsCookieAtlas.UpdateTexture(cmd, cookie, ref scaleOffset);
			}
			else
			{
				m_AdditionalLightsCookieAtlas.AllocateTexture(cmd, ref scaleOffset, cookie, num, num2);
			}
			AdjustUVRect(ref scaleOffset, cookie, ref cookieSize);
			return scaleOffset;
		}

		private Vector4 FetchCube(CommandBuffer cmd, Texture cookie, int cookieSizeDivisor = 1)
		{
			Assert.IsTrue(cookie != null);
			Assert.IsTrue(cookie.dimension == TextureDimension.Cube);
			Vector4 scaleOffset = Vector4.zero;
			int num = Mathf.Max(ComputeOctahedralCookieSize(cookie) / cookieSizeDivisor, 4);
			if (m_AdditionalLightsCookieAtlas.IsCached(out scaleOffset, cookie))
			{
				m_AdditionalLightsCookieAtlas.UpdateTexture(cmd, cookie, ref scaleOffset);
			}
			else
			{
				m_AdditionalLightsCookieAtlas.AllocateTexture(cmd, ref scaleOffset, cookie, num, num);
			}
			Vector2 cookieSize = Vector2.one * num;
			AdjustUVRect(ref scaleOffset, cookie, ref cookieSize);
			return scaleOffset;
		}

		private int ComputeOctahedralCookieSize(Texture cookie)
		{
			int num = Math.Max(cookie.width, cookie.height);
			if (m_Settings.atlas.isPow2)
			{
				return num * Mathf.NextPowerOfTwo((int)m_Settings.cubeOctahedralSizeScale);
			}
			return (int)((float)num * m_Settings.cubeOctahedralSizeScale + 0.5f);
		}

		private void AdjustUVRect(ref Vector4 uvScaleOffset, Texture cookie, ref Vector2 cookieSize)
		{
			if (uvScaleOffset != Vector4.zero)
			{
				ShrinkUVRect(ref uvScaleOffset, 0.5f, ref cookieSize);
			}
		}

		private void ShrinkUVRect(ref Vector4 uvScaleOffset, float amountPixels, ref Vector2 cookieSize)
		{
			Vector2 vector = Vector2.one * amountPixels / cookieSize;
			Vector2 vector2 = (cookieSize - Vector2.one * (amountPixels * 2f)) / cookieSize;
			uvScaleOffset.z += uvScaleOffset.x * vector.x;
			uvScaleOffset.w += uvScaleOffset.y * vector.y;
			uvScaleOffset.x *= vector2.x;
			uvScaleOffset.y *= vector2.y;
		}

		private void UploadAdditionalLights(CommandBuffer cmd, ref NativeArray<VisibleLight> visibleLights, ref WorkSlice<LightCookieMapping> validLightMappings, ref WorkSlice<Vector4> validUvRects)
		{
			Assert.IsTrue(m_AdditionalLightsCookieAtlas != null);
			Assert.IsTrue(m_AdditionalLightsCookieShaderData != null);
			cmd.SetGlobalTexture(ShaderProperty.additionalLightsCookieAtlasTexture, m_AdditionalLightsCookieAtlas.AtlasTexture);
			cmd.SetGlobalFloat(ShaderProperty.additionalLightsCookieAtlasTextureFormat, (float)GetLightCookieShaderFormat(m_AdditionalLightsCookieAtlas.AtlasTexture.rt.graphicsFormat));
			if (m_VisibleLightIndexToShaderDataIndex.Length < visibleLights.Length)
			{
				m_VisibleLightIndexToShaderDataIndex = new int[visibleLights.Length];
			}
			int num = Math.Min(m_VisibleLightIndexToShaderDataIndex.Length, visibleLights.Length);
			for (int i = 0; i < num; i++)
			{
				m_VisibleLightIndexToShaderDataIndex[i] = -1;
			}
			m_AdditionalLightsCookieShaderData.Resize(m_Settings.maxAdditionalLights);
			Matrix4x4[] worldToLights = m_AdditionalLightsCookieShaderData.worldToLights;
			ShaderBitArray cookieEnableBits = m_AdditionalLightsCookieShaderData.cookieEnableBits;
			Vector4[] atlasUVRects = m_AdditionalLightsCookieShaderData.atlasUVRects;
			float[] lightTypes = m_AdditionalLightsCookieShaderData.lightTypes;
			Array.Clear(atlasUVRects, 0, atlasUVRects.Length);
			cookieEnableBits.Clear();
			for (int j = 0; j < validUvRects.length; j++)
			{
				int visibleLightIndex = validLightMappings[j].visibleLightIndex;
				int lightBufferIndex = validLightMappings[j].lightBufferIndex;
				m_VisibleLightIndexToShaderDataIndex[visibleLightIndex] = lightBufferIndex;
				ref VisibleLight reference = ref visibleLights.UnsafeElementAtMutable(visibleLightIndex);
				lightTypes[lightBufferIndex] = (float)reference.lightType;
				worldToLights[lightBufferIndex] = reference.localToWorldMatrix.inverse;
				atlasUVRects[lightBufferIndex] = validUvRects[j];
				cookieEnableBits[lightBufferIndex] = true;
				if (reference.lightType == LightType.Spot)
				{
					float spotAngle = reference.spotAngle;
					float range = reference.range;
					Matrix4x4 matrix4x = Matrix4x4.Perspective(spotAngle, 1f, 0.001f, range);
					matrix4x.SetColumn(2, matrix4x.GetColumn(2) * -1f);
					worldToLights[lightBufferIndex] = matrix4x * worldToLights[lightBufferIndex];
				}
				else if (reference.lightType == LightType.Directional)
				{
					_ = reference.light;
					Matrix4x4 matrix4x2 = s_DirLightProj * reference.localToWorldMatrix.inverse;
					worldToLights[lightBufferIndex] = matrix4x2;
				}
			}
			m_AdditionalLightsCookieShaderData.Upload(cmd);
		}
	}
	public class LightingPass
	{
		public const int MAX_DIRECTIONAL_LIGHT_COUNT = 4;

		public const int MAX_ADDITIONAL_LIGHT_COUNT = 128;

		private static readonly ProfilingSampler profilingSampler = new ProfilingSampler("Lighting");

		private static readonly DirectionalLightData[] directionalLightData = new DirectionalLightData[4];

		private static readonly AdditionalLightData[] additionalLightData = new AdditionalLightData[128];

		private static readonly int dirLightCountId = Shader.PropertyToID("_DirectionalLightCount");

		private static readonly int directionalLightDataId = Shader.PropertyToID("_DirectionalLightData");

		private static readonly int additionalLightCountId = Shader.PropertyToID("_AdditionalLightCount");

		private static readonly int additionalLightDataId = Shader.PropertyToID("_AdditionalLightData");

		private static readonly int tilesId = Shader.PropertyToID("_ForwardPlusTiles");

		private static readonly int tileSettingsId = Shader.PropertyToID("_ForwardPlusTileSettings");

		private CullingResults cullingResults;

		private readonly Shadows shadows = new Shadows();

		private int directionalLightCount;

		private int additionalLightCount;

		private ComputeBufferHandle directionalLightDataBuffer;

		private ComputeBufferHandle additionalLightDataBuffer;

		private ComputeBufferHandle tilesBuffer;

		private Vector2 screenUvToTileCoordinates;

		private Vector2Int tileCount;

		private int maxLightsPerTile;

		private int tileDataSize;

		private int maxTileDataSize;

		private NativeArray<float4> lightBounds;

		private NativeArray<int> tileData;

		private JobHandle forwardPlusJobHandle;

		private readonly Dictionary<Light, Vector4> lightShadowData = new Dictionary<Light, Vector4>();

		private LightCookieManager lightCookieManager;

		private int mainLightIndex;

		private int TileCount => tileCount.x * tileCount.y;

		private void Setup(CullingResults cullingResults, Vector2Int attachmentSize, ForwardPlusSettings forwardPlusSettings, ShadowSettings shadowSettings, int renderingLayerMask)
		{
			this.cullingResults = cullingResults;
			shadows.Setup(cullingResults, shadowSettings);
			lightBounds = new NativeArray<float4>(128, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
			maxLightsPerTile = ((forwardPlusSettings.maxLightsPerTile <= 0) ? 31 : forwardPlusSettings.maxLightsPerTile);
			maxTileDataSize = (tileDataSize = maxLightsPerTile + 1);
			float num = ((forwardPlusSettings.tileSize <= ForwardPlusSettings.TileSize.Default) ? 64f : ((float)forwardPlusSettings.tileSize));
			screenUvToTileCoordinates.x = (float)attachmentSize.x / num;
			screenUvToTileCoordinates.y = (float)attachmentSize.y / num;
			tileCount.x = Mathf.CeilToInt(screenUvToTileCoordinates.x);
			tileCount.y = Mathf.CeilToInt(screenUvToTileCoordinates.y);
			SetupLights(renderingLayerMask);
		}

		private void SetupForwardPlus(int lightIndex, ref VisibleLight visibleLight)
		{
			Rect screenRect = visibleLight.screenRect;
			lightBounds[lightIndex] = math.float4(screenRect.xMin, screenRect.yMin, screenRect.xMax, screenRect.yMax);
		}

		public static int GetMainLightIndex(NativeArray<VisibleLight> visibleLights)
		{
			int length = visibleLights.Length;
			if (length == 0)
			{
				return -1;
			}
			Light sun = RenderSettings.sun;
			int result = -1;
			float num = 0f;
			for (int i = 0; i < length; i++)
			{
				ref VisibleLight reference = ref visibleLights.UnsafeElementAtMutable(i);
				Light light = reference.light;
				if (light == null)
				{
					break;
				}
				if (reference.lightType == LightType.Directional)
				{
					if (light == sun)
					{
						return i;
					}
					if (light.intensity > num)
					{
						num = light.intensity;
						result = i;
					}
				}
			}
			return result;
		}

		private void SetupLights(int renderingLayerMask)
		{
			NativeArray<VisibleLight> visibleLights = cullingResults.visibleLights;
			int num = Mathf.Min(maxLightsPerTile, visibleLights.Length);
			tileDataSize = num + 1;
			directionalLightCount = (additionalLightCount = 0);
			lightShadowData.Clear();
			mainLightIndex = GetMainLightIndex(visibleLights);
			for (int i = 0; i < visibleLights.Length; i++)
			{
				VisibleLight visibleLight = visibleLights[i];
				Light light = visibleLight.light;
				if ((light.renderingLayerMask & renderingLayerMask) == 0)
				{
					continue;
				}
				switch (visibleLight.lightType)
				{
				case LightType.Directional:
					if (directionalLightCount < 4)
					{
						lightShadowData[light] = shadows.ReserveDirectionalShadows(light, i);
						directionalLightData[directionalLightCount++] = new DirectionalLightData(ref visibleLight, light, lightShadowData[light]);
					}
					break;
				case LightType.Point:
					if (additionalLightCount < 128)
					{
						lightShadowData[light] = shadows.ReserveAdditionalShadows(light, i);
						SetupForwardPlus(additionalLightCount, ref visibleLight);
						additionalLightData[additionalLightCount++] = AdditionalLightData.CreatePointLight(ref visibleLight, light, lightShadowData[light]);
					}
					break;
				case LightType.Spot:
					if (additionalLightCount < 128)
					{
						lightShadowData[light] = shadows.ReserveAdditionalShadows(light, i);
						SetupForwardPlus(additionalLightCount, ref visibleLight);
						additionalLightData[additionalLightCount++] = AdditionalLightData.CreateSpotLight(ref visibleLight, light, lightShadowData[light]);
					}
					break;
				}
			}
			tileData = new NativeArray<int>(TileCount * tileDataSize, Allocator.TempJob);
			forwardPlusJobHandle = new ForwardPlusTilesJob
			{
				lightBounds = lightBounds,
				tileData = tileData,
				additionalLightCount = additionalLightCount,
				tileScreenUVSize = math.float2(1f / screenUvToTileCoordinates.x, 1f / screenUvToTileCoordinates.y),
				maxLightsPerTile = num,
				tilesPerRow = tileCount.x,
				tileDataSize = tileDataSize
			}.ScheduleParallel(TileCount, tileCount.x, default(JobHandle));
		}

		private void Render(RenderGraphContext context)
		{
			CommandBuffer cmd = context.cmd;
			cmd.SetGlobalInt(dirLightCountId, directionalLightCount);
			cmd.SetBufferData(directionalLightDataBuffer, directionalLightData, 0, 0, directionalLightCount);
			cmd.SetGlobalBuffer(directionalLightDataId, directionalLightDataBuffer);
			cmd.SetGlobalInt(additionalLightCountId, additionalLightCount);
			cmd.SetBufferData(additionalLightDataBuffer, additionalLightData, 0, 0, additionalLightCount);
			cmd.SetGlobalBuffer(additionalLightDataId, additionalLightDataBuffer);
			shadows.Render(context);
			forwardPlusJobHandle.Complete();
			cmd.SetBufferData(tilesBuffer, tileData, 0, 0, tileData.Length);
			cmd.SetGlobalBuffer(tilesId, tilesBuffer);
			cmd.SetGlobalVector(tileSettingsId, new Vector4(screenUvToTileCoordinates.x, screenUvToTileCoordinates.y, tileCount.x.ReinterpretAsFloat(), tileDataSize.ReinterpretAsFloat()));
			NativeArray<VisibleLight> visibleLights = cullingResults.visibleLights;
			lightCookieManager?.Setup(cmd, ref visibleLights, mainLightIndex, additionalLightCount);
			context.renderContext.ExecuteCommandBuffer(cmd);
			cmd.Clear();
			lightBounds.Dispose();
			tileData.Dispose();
		}

		public static void Record(RenderGraph renderGraph, ContextContainer frameData, LightCookieManager lightCookieManager)
		{
			RustResourceDataContext rustResourceDataContext = frameData.Get<RustResourceDataContext>();
			RustCameraContext rustCameraContext = frameData.Get<RustCameraContext>();
			RustRenderingContext rustRenderingContext = frameData.Get<RustRenderingContext>();
			CameraSettings cameraSettings = rustCameraContext.CameraSettings;
			ShadowSettings shadowSettings = rustRenderingContext.pipelineSettings.shadows;
			ForwardPlusSettings forwardPlus = rustRenderingContext.pipelineSettings.forwardPlus;
			int renderingLayerMask = (cameraSettings.maskLights ? cameraSettings.renderingLayerMask : (-1));
			LightingPass passData;
			RenderGraphBuilder builder = renderGraph.AddRenderPass<LightingPass>("Lighting", out passData, profilingSampler);
			try
			{
				passData.Setup(rustRenderingContext.cullResults, rustCameraContext.CameraBufferSize, forwardPlus, shadowSettings, renderingLayerMask);
				LightingPass lightingPass = passData;
				ComputeBufferDesc desc = new ComputeBufferDesc
				{
					name = "Directional Light Data",
					count = 4,
					stride = 48
				};
				lightingPass.directionalLightDataBuffer = builder.WriteComputeBuffer(renderGraph.CreateComputeBuffer(in desc));
				LightingPass lightingPass2 = passData;
				desc = new ComputeBufferDesc
				{
					name = "Additional Light Data",
					count = 128,
					stride = 80
				};
				lightingPass2.additionalLightDataBuffer = builder.WriteComputeBuffer(renderGraph.CreateComputeBuffer(in desc));
				LightingPass lightingPass3 = passData;
				desc = new ComputeBufferDesc
				{
					name = "Forward+ Tiles",
					count = passData.TileCount * passData.maxTileDataSize,
					stride = 4
				};
				lightingPass3.tilesBuffer = builder.WriteComputeBuffer(renderGraph.CreateComputeBuffer(in desc));
				builder.SetRenderFunc(delegate(LightingPass pass, RenderGraphContext context)
				{
					pass.Render(context);
				});
				passData.shadows.InitResources(renderGraph, builder, frameData);
				passData.lightCookieManager = lightCookieManager;
				builder.AllowPassCulling(value: false);
				rustResourceDataContext.DirectionalLightDataBuffer = passData.directionalLightDataBuffer;
				rustResourceDataContext.AdditionalLightDataBuffer = passData.additionalLightDataBuffer;
				rustResourceDataContext.LightTilesBuffer = passData.tilesBuffer;
				rustResourceDataContext.LightShadowData = passData.lightShadowData;
			}
			finally
			{
				((IDisposable)builder/*cast due to .constrained prefix*/).Dispose();
			}
		}
	}
	internal struct ShaderBitArray
	{
		private const int k_BitsPerElement = 32;

		private const int k_ElementShift = 5;

		private const int k_ElementMask = 31;

		private float[] m_Data;

		public int elemLength
		{
			get
			{
				if (m_Data != null)
				{
					return m_Data.Length;
				}
				return 0;
			}
		}

		public int bitCapacity => elemLength * 32;

		public float[] data => m_Data;

		public unsafe bool this[int index]
		{
			get
			{
				GetElementIndexAndBitOffset(index, out var elemIndex, out var bitOffset);
				fixed (float* ptr = m_Data)
				{
					uint* ptr2 = (uint*)(ptr + elemIndex);
					return (*ptr2 & (uint)(1 << bitOffset)) != 0;
				}
			}
			set
			{
				GetElementIndexAndBitOffset(index, out var elemIndex, out var bitOffset);
				fixed (float* ptr = m_Data)
				{
					uint* ptr2 = (uint*)(ptr + elemIndex);
					if (value)
					{
						*ptr2 |= (uint)(1 << bitOffset);
					}
					else
					{
						*ptr2 &= (uint)(~(1 << bitOffset));
					}
				}
			}
		}

		public void Resize(int bitCount)
		{
			if (bitCapacity > bitCount)
			{
				return;
			}
			int num = (bitCount + 31) / 32;
			if (num == m_Data?.Length)
			{
				return;
			}
			float[] array = new float[num];
			if (m_Data != null)
			{
				for (int i = 0; i < m_Data.Length; i++)
				{
					array[i] = m_Data[i];
				}
			}
			m_Data = array;
		}

		public void Clear()
		{
			for (int i = 0; i < m_Data.Length; i++)
			{
				m_Data[i] = 0f;
			}
		}

		private void GetElementIndexAndBitOffset(int index, out int elemIndex, out int bitOffset)
		{
			elemIndex = index >> 5;
			bitOffset = index & 0x1F;
		}

		public unsafe override string ToString()
		{
			UnityEngine.Debug.Assert(bitCapacity < 4096, "Bit string too long! It was truncated!");
			int num = Math.Min(bitCapacity, 4096);
			byte* ptr = stackalloc byte[(int)(uint)num];
			for (int i = 0; i < num; i++)
			{
				ptr[i] = (byte)(this[i] ? 49u : 48u);
			}
			return new string((sbyte*)ptr, 0, num, Encoding.UTF8);
		}
	}
	public class Shadows
	{
		private struct ShadowedDirectionalLight
		{
			public int visibleLightIndex;

			public float slopeScaleBias;

			public float nearPlaneOffset;

			public float normalBias;
		}

		private struct ShadowedAdditionalLight
		{
			public int visibleLightIndex;

			public float slopeScaleBias;

			public float normalBias;

			public bool isPoint;
		}

		private const float ROOT_TWO = 1.4142137f;

		private const int MAX_SHADOWED_DIRECTIONAL_LIGHT_COUNT = 4;

		private const int MAX_SHADOWED_ADDITIONAL_LIGHT_COUNT = 16;

		private const int MAX_CASCADES = 4;

		private static readonly int directionalShadowAtlasId = Shader.PropertyToID("_DirectionalShadowAtlas");

		private static readonly int directionalShadowMatricesId = Shader.PropertyToID("_DirectionalShadowMatrices");

		private static readonly int directionalShadowCascadesId = Shader.PropertyToID("_DirectionalShadowCascades");

		private static readonly int cascadeCountId = Shader.PropertyToID("_CascadeCount");

		private static readonly int additionalShadowAtlasId = Shader.PropertyToID("_AdditionalShadowAtlas");

		private static readonly int additionalShadowDataId = Shader.PropertyToID("_AdditionalShadowData");

		private static readonly int shadowAtlasSizeId = Shader.PropertyToID("_ShadowAtlasSize");

		private static readonly int shadowDistanceFadeId = Shader.PropertyToID("_ShadowDistanceFade");

		private static readonly int shadowPancakingId = Shader.PropertyToID("_ShadowPancaking");

		private static readonly int unityLightShadowBiasId = Shader.PropertyToID("unity_LightShadowBias");

		private static readonly DirectionalShadowCascade[] directionalShadowCascades = new DirectionalShadowCascade[4];

		private static readonly Matrix4x4[] directionalShadowMatrices = new Matrix4x4[16];

		private static readonly AdditionalShadowData[] additionalShadowData = new AdditionalShadowData[16];

		private static readonly GlobalKeyword[] filterQualityKeywords = new GlobalKeyword[2]
		{
			GlobalKeyword.Create("_SHADOW_FILTER_MEDIUM"),
			GlobalKeyword.Create("_SHADOW_FILTER_HIGH")
		};

		private static readonly GlobalKeyword softCascadeBlendKeyword = GlobalKeyword.Create("_SOFT_CASCADE_BLEND");

		private readonly ShadowedDirectionalLight[] shadowedDirectionalLights = new ShadowedDirectionalLight[4];

		private readonly ShadowedAdditionalLight[] shadowedAdditionalLights = new ShadowedAdditionalLight[16];

		private CommandBuffer commandBuffer;

		private TextureHandle directionalAtlas;

		private TextureHandle additionalAtlas;

		private ComputeBufferHandle directionalShadowCascadesBuffer;

		private ComputeBufferHandle directionalShadowMatricesBuffer;

		private ComputeBufferHandle additionalShadowDataBuffer;

		private ScriptableRenderContext context;

		private CullingResults cullingResults;

		private ShadowSettings settings;

		private int shadowedDirectionalLightCount;

		private int shadowedAdditionalLightCount;

		private Vector4 atlasSizes;

		public void Setup(CullingResults cullingResults, ShadowSettings settings)
		{
			this.cullingResults = cullingResults;
			this.settings = settings;
			shadowedDirectionalLightCount = (shadowedAdditionalLightCount = 0);
		}

		public void Render(RenderGraphContext context)
		{
			commandBuffer = context.cmd;
			this.context = context.renderContext;
			if (shadowedDirectionalLightCount > 0)
			{
				RenderDirectionalShadows();
			}
			if (shadowedAdditionalLightCount > 0)
			{
				RenderAdditionalShadows();
			}
			SetKeywords(filterQualityKeywords, (int)(settings.filterQuality - 1));
			commandBuffer.SetGlobalBuffer(directionalShadowCascadesId, directionalShadowCascadesBuffer);
			commandBuffer.SetGlobalBuffer(directionalShadowMatricesId, directionalShadowMatricesBuffer);
			commandBuffer.SetGlobalBuffer(additionalShadowDataId, additionalShadowDataBuffer);
			commandBuffer.SetGlobalTexture(directionalShadowAtlasId, directionalAtlas);
			commandBuffer.SetGlobalTexture(additionalShadowAtlasId, additionalAtlas);
			commandBuffer.SetGlobalInt(cascadeCountId, (shadowedDirectionalLightCount > 0) ? settings.directional.cascadeCount : 0);
			float num = 1f - settings.directional.cascadeFade;
			commandBuffer.SetGlobalVector(shadowDistanceFadeId, new Vector4(1f / settings.maxDistance, 1f / settings.distanceFade, 1f / (1f - num * num)));
			commandBuffer.SetGlobalVector(shadowAtlasSizeId, atlasSizes);
			ExecuteCommandBuffer();
		}

		public Vector3 ReserveDirectionalShadows(Light light, int visibleLightIndex)
		{
			if (shadowedDirectionalLightCount < 4 && light.shadows != LightShadows.None && light.shadowStrength > 0f && cullingResults.GetShadowCasterBounds(visibleLightIndex, out var _))
			{
				shadowedDirectionalLights[shadowedDirectionalLightCount] = new ShadowedDirectionalLight
				{
					visibleLightIndex = visibleLightIndex,
					slopeScaleBias = light.shadowBias,
					nearPlaneOffset = light.shadowNearPlane,
					normalBias = light.shadowNormalBias
				};
				return new Vector3(light.shadowStrength, settings.directional.cascadeCount * shadowedDirectionalLightCount++, 1f + light.shadowNormalBias);
			}
			return Vector3.zero;
		}

		public Vector4 ReserveAdditionalShadows(Light light, int visibleLightIndex)
		{
			if (light.shadows == LightShadows.None || light.shadowStrength <= 0f)
			{
				return new Vector4(0f, 0f, 0f, -1f);
			}
			bool flag = light.type == LightType.Point;
			int num = shadowedAdditionalLightCount + ((!flag) ? 1 : 6);
			if (num > 16 || !cullingResults.GetShadowCasterBounds(visibleLightIndex, out var _))
			{
				return new Vector4(0f - light.shadowStrength, 0f, 0f, -1f);
			}
			shadowedAdditionalLights[shadowedAdditionalLightCount] = new ShadowedAdditionalLight
			{
				visibleLightIndex = visibleLightIndex,
				slopeScaleBias = light.shadowBias,
				normalBias = 1f + light.shadowNormalBias,
				isPoint = flag
			};
			Vector4 result = new Vector4(light.shadowStrength, shadowedAdditionalLightCount, flag ? 1f : 0f, -1f);
			shadowedAdditionalLightCount = num;
			return result;
		}

		private void RenderDirectionalShadows()
		{
			int atlasSize = (int)settings.directional.atlasSize;
			atlasSizes.x = atlasSize;
			atlasSizes.y = 1f / (float)atlasSize;
			commandBuffer.SetRenderTarget(directionalAtlas, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store);
			commandBuffer.ClearRenderTarget(clearDepth: true, clearColor: false, Color.clear);
			commandBuffer.SetGlobalFloat(shadowPancakingId, 1f);
			commandBuffer.BeginSample("Directional Shadows");
			ExecuteCommandBuffer();
			int num = shadowedDirectionalLightCount * settings.directional.cascadeCount;
			int num2 = ((num <= 1) ? 1 : ((num <= 4) ? 2 : 4));
			int tileSize = atlasSize / num2;
			for (int i = 0; i < shadowedDirectionalLightCount; i++)
			{
				RenderDirectionalShadows(i, num2, tileSize);
			}
			commandBuffer.SetBufferData(directionalShadowCascadesBuffer, directionalShadowCascades, 0, 0, settings.directional.cascadeCount);
			commandBuffer.SetBufferData(directionalShadowMatricesBuffer, directionalShadowMatrices, 0, 0, shadowedDirectionalLightCount * settings.directional.cascadeCount);
			commandBuffer.SetKeyword(in softCascadeBlendKeyword, settings.directional.softCascadeBlend);
			commandBuffer.EndSample("Directional Shadows");
			ExecuteCommandBuffer();
		}

		private void RenderDirectionalShadows(int index, int split, int tileSize)
		{
			ShadowedDirectionalLight shadowedDirectionalLight = shadowedDirectionalLights[index];
			ShadowDrawingSettings shadowDrawingSettings = new ShadowDrawingSettings(cullingResults, shadowedDirectionalLight.visibleLightIndex, BatchCullingProjectionType.Orthographic);
			shadowDrawingSettings.useRenderingLayerMaskTest = true;
			ShadowDrawingSettings shadowDrawingSettings2 = shadowDrawingSettings;
			int cascadeCount = settings.directional.cascadeCount;
			int num = index * cascadeCount;
			Vector3 cascadeRatios = settings.directional.CascadeRatios;
			float shadowCascadeBlendCullingFactor = Mathf.Max(0f, 0.8f - settings.directional.cascadeFade);
			float scale = 1f / (float)split;
			for (int i = 0; i < cascadeCount; i++)
			{
				cullingResults.ComputeDirectionalShadowMatricesAndCullingPrimitives(shadowedDirectionalLight.visibleLightIndex, i, cascadeCount, cascadeRatios, tileSize, shadowedDirectionalLight.nearPlaneOffset, out var viewMatrix, out var projMatrix, out var shadowSplitData);
				shadowSplitData.shadowCascadeBlendCullingFactor = shadowCascadeBlendCullingFactor;
				shadowDrawingSettings2.splitData = shadowSplitData;
				if (index == 0)
				{
					directionalShadowCascades[i] = new DirectionalShadowCascade(shadowSplitData.cullingSphere, tileSize, settings.DirectionalFilterSize);
				}
				int num2 = num + i;
				directionalShadowMatrices[num2] = ConvertToAtlasMatrix(projMatrix * viewMatrix, SetTileViewport(num2, split, tileSize), scale);
				commandBuffer.SetViewProjectionMatrices(viewMatrix, projMatrix);
				commandBuffer.SetGlobalDepthBias(1f, 1f);
				float z = projMatrix.MultiplyVector(new Vector3(0f, 0f, shadowedDirectionalLight.slopeScaleBias * directionalShadowCascades[i].data.y)).z;
				commandBuffer.SetGlobalVector(unityLightShadowBiasId, new Vector4(z, 1f, shadowedDirectionalLight.normalBias * directionalShadowCascades[i].data.y, 0f));
				ExecuteCommandBuffer();
				context.DrawShadows(ref shadowDrawingSettings2);
				commandBuffer.SetGlobalDepthBias(0f, 0f);
			}
		}

		private void RenderAdditionalShadows()
		{
			int atlasSize = (int)settings.additional.atlasSize;
			atlasSizes.z = atlasSize;
			atlasSizes.w = 1f / (float)atlasSize;
			commandBuffer.SetRenderTarget(additionalAtlas, RenderBufferLoadAction.DontCare, RenderBufferStoreAction.Store);
			commandBuffer.ClearRenderTarget(clearDepth: true, clearColor: false, Color.clear);
			commandBuffer.SetGlobalFloat(shadowPancakingId, 0f);
			commandBuffer.BeginSample("Additional Shadows");
			ExecuteCommandBuffer();
			int num = shadowedAdditionalLightCount;
			int num2 = ((num <= 1) ? 1 : ((num <= 4) ? 2 : 4));
			int tileSize = atlasSize / num2;
			int num3 = 0;
			while (num3 < shadowedAdditionalLightCount)
			{
				if (shadowedAdditionalLights[num3].isPoint)
				{
					RenderPointShadows(num3, num2, tileSize);
					num3 += 6;
				}
				else
				{
					RenderSpotShadows(num3, num2, tileSize);
					num3++;
				}
			}
			commandBuffer.SetBufferData(additionalShadowDataBuffer, additionalShadowData, 0, 0, shadowedAdditionalLightCount);
			commandBuffer.EndSample("Additional Shadows");
			ExecuteCommandBuffer();
		}

		private void RenderSpotShadows(int index, int split, int tileSize)
		{
			ShadowedAdditionalLight shadowedAdditionalLight = shadowedAdditionalLights[index];
			ShadowDrawingSettings shadowDrawingSettings = new ShadowDrawingSettings(cullingResults, shadowedAdditionalLight.visibleLightIndex, BatchCullingProjectionType.Perspective);
			shadowDrawingSettings.useRenderingLayerMaskTest = true;
			ShadowDrawingSettings shadowDrawingSettings2 = shadowDrawingSettings;
			cullingResults.ComputeSpotShadowMatricesAndCullingPrimitives(shadowedAdditionalLight.visibleLightIndex, out var viewMatrix, out var projMatrix, out var shadowSplitData);
			shadowDrawingSettings2.splitData = shadowSplitData;
			float num = 2f / ((float)tileSize * projMatrix.m00) * settings.AdditionalFilterSize;
			float bias = shadowedAdditionalLight.normalBias * num * 1.4142137f;
			Vector2 offset = SetTileViewport(index, split, tileSize);
			float scale = 1f / (float)split;
			additionalShadowData[index] = new AdditionalShadowData(offset, scale, bias, atlasSizes.w * 0.5f, ConvertToAtlasMatrix(projMatrix * viewMatrix, offset, scale));
			commandBuffer.SetViewProjectionMatrices(viewMatrix, projMatrix);
			commandBuffer.SetGlobalDepthBias(1f, 1f);
			float z = projMatrix.MultiplyVector(new Vector3(0f, 0f, shadowedAdditionalLight.slopeScaleBias * num * 1.4142137f)).z;
			commandBuffer.SetGlobalVector(unityLightShadowBiasId, new Vector4(z, 0f, 0f, 0f));
			ExecuteCommandBuffer();
			context.DrawShadows(ref shadowDrawingSettings2);
			commandBuffer.SetGlobalDepthBias(0f, 0f);
		}

		private void RenderPointShadows(int index, int split, int tileSize)
		{
			ShadowedAdditionalLight shadowedAdditionalLight = shadowedAdditionalLights[index];
			ShadowDrawingSettings shadowDrawingSettings = new ShadowDrawingSettings(cullingResults, shadowedAdditionalLight.visibleLightIndex, BatchCullingProjectionType.Perspective);
			shadowDrawingSettings.useRenderingLayerMaskTest = true;
			ShadowDrawingSettings shadowDrawingSettings2 = shadowDrawingSettings;
			float num = 2f / (float)tileSize * ((float)settings.additional.filter + 1f);
			float num2 = shadowedAdditionalLight.normalBias * num * 1.4142137f;
			float scale = 1f / (float)split;
			for (int i = 0; i < 6; i++)
			{
				float fovBias = Mathf.Atan(1f + num2 + num) * 57.29578f * 2f - 90f;
				cullingResults.ComputePointShadowMatricesAndCullingPrimitives(shadowedAdditionalLight.visibleLightIndex, (CubemapFace)i, fovBias, out var viewMatrix, out var projMatrix, out var shadowSplitData);
				viewMatrix.m11 = 0f - viewMatrix.m11;
				viewMatrix.m12 = 0f - viewMatrix.m12;
				viewMatrix.m13 = 0f - viewMatrix.m13;
				shadowDrawingSettings2.splitData = shadowSplitData;
				int num3 = index + i;
				Vector2 offset = SetTileViewport(num3, split, tileSize);
				additionalShadowData[num3] = new AdditionalShadowData(offset, scale, num2, atlasSizes.w * 0.5f, ConvertToAtlasMatrix(projMatrix * viewMatrix, offset, scale));
				commandBuffer.SetViewProjectionMatrices(viewMatrix, projMatrix);
				commandBuffer.SetGlobalDepthBias(1f, 1f);
				float z = projMatrix.MultiplyVector(new Vector3(0f, 0f, shadowedAdditionalLight.slopeScaleBias * num * 1.4142137f)).z;
				commandBuffer.SetGlobalVector(unityLightShadowBiasId, new Vector4(z, 0f, 0f, 0f));
				ExecuteCommandBuffer();
				context.DrawShadows(ref shadowDrawingSettings2);
				commandBuffer.SetGlobalDepthBias(0f, 0f);
			}
		}

		private void SetKeywords(GlobalKeyword[] keywords, int enabledIndex)
		{
			for (int i = 0; i < keywords.Length; i++)
			{
				commandBuffer.SetKeyword(in keywords[i], i == enabledIndex);
			}
		}

		private Vector2 SetTileViewport(int index, int split, float tileSize)
		{
			Vector2 result = new Vector2(index % split, index / split);
			commandBuffer.SetViewport(new Rect(result.x * tileSize, result.y * tileSize, tileSize, tileSize));
			return result;
		}

		private Matrix4x4 ConvertToAtlasMatrix(Matrix4x4 m, Vector2 offset, float scale)
		{
			if (SystemInfo.usesReversedZBuffer)
			{
				m.m20 = 0f - m.m20;
				m.m21 = 0f - m.m21;
				m.m22 = 0f - m.m22;
				m.m23 = 0f - m.m23;
			}
			m.m00 = (0.5f * (m.m00 + m.m30) + offset.x * m.m30) * scale;
			m.m01 = (0.5f * (m.m01 + m.m31) + offset.x * m.m31) * scale;
			m.m02 = (0.5f * (m.m02 + m.m32) + offset.x * m.m32) * scale;
			m.m03 = (0.5f * (m.m03 + m.m33) + offset.x * m.m33) * scale;
			m.m10 = (0.5f * (m.m10 + m.m30) + offset.y * m.m30) * scale;
			m.m11 = (0.5f * (m.m11 + m.m31) + offset.y * m.m31) * scale;
			m.m12 = (0.5f * (m.m12 + m.m32) + offset.y * m.m32) * scale;
			m.m13 = (0.5f * (m.m13 + m.m33) + offset.y * m.m33) * scale;
			m.m20 = 0.5f * (m.m20 + m.m30);
			m.m21 = 0.5f * (m.m21 + m.m31);
			m.m22 = 0.5f * (m.m22 + m.m32);
			m.m23 = 0.5f * (m.m23 + m.m33);
			return m;
		}

		public void InitResources(RenderGraph renderGraph, RenderGraphBuilder builder, ContextContainer frameData)
		{
			int atlasSize = (int)settings.directional.atlasSize;
			TextureDesc textureDesc = new TextureDesc(atlasSize, atlasSize);
			textureDesc.depthBufferBits = DepthBits.Depth32;
			textureDesc.isShadowMap = true;
			textureDesc.name = "Directional Shadow Atlas";
			TextureDesc desc = textureDesc;
			directionalAtlas = ((shadowedDirectionalLightCount > 0) ? builder.WriteTexture(renderGraph.CreateTexture(in desc)) : renderGraph.defaultResources.defaultShadowTexture);
			directionalShadowCascadesBuffer = builder.WriteComputeBuffer(renderGraph.CreateComputeBuffer(new ComputeBufferDesc
			{
				name = "Shadow Cascades",
				stride = 32,
				count = 4
			}));
			directionalShadowMatricesBuffer = builder.WriteComputeBuffer(renderGraph.CreateComputeBuffer(new ComputeBufferDesc
			{
				name = "Directional Shadow Matrices",
				stride = 64,
				count = 16
			}));
			atlasSize = (int)settings.additional.atlasSize;
			desc.width = (desc.height = atlasSize);
			desc.name = "Additional Shadow Atlas";
			additionalAtlas = ((shadowedAdditionalLightCount > 0) ? builder.WriteTexture(renderGraph.CreateTexture(in desc)) : renderGraph.defaultResources.defaultShadowTexture);
			additionalShadowDataBuffer = builder.WriteComputeBuffer(renderGraph.CreateComputeBuffer(new ComputeBufferDesc
			{
				name = "Additional Shadow Data",
				stride = 80,
				count = 16
			}));
			RustResourceDataContext rustResourceDataContext = frameData.Get<RustResourceDataContext>();
			rustResourceDataContext.MainShadowsTexture = directionalAtlas;
			rustResourceDataContext.AdditionalShadowsTexture = additionalAtlas;
			rustResourceDataContext.ShadowCascadesBuffer = directionalShadowCascadesBuffer;
			rustResourceDataContext.ShadowMatricesBuffer = directionalShadowMatricesBuffer;
			rustResourceDataContext.AdditionalShadowDataBuffer = additionalShadowDataBuffer;
		}

		private void ExecuteCommandBuffer()
		{
			context.ExecuteCommandBuffer(commandBuffer);
			commandBuffer.Clear();
		}
	}
}
