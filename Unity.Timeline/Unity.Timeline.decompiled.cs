#define UNITY_ASSERTIONS
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Globalization;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using UnityEngine.Animations;
using UnityEngine.Audio;
using UnityEngine.Events;
using UnityEngine.Playables;
using UnityEngine.Serialization;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyTitle("UnityEngine.Timeline")]
[assembly: AssemblyDescription("Unity Timeline")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Unity Technologies")]
[assembly: AssemblyProduct("UnityEngine.Timeline")]
[assembly: AssemblyCopyright("Copyright \ufffd 2016")]
[assembly: AssemblyTrademark("")]
[assembly: InternalsVisibleTo("Unity.Timeline.Editor")]
[assembly: ComVisible(false)]
[assembly: Guid("6A10B290-9283-487F-913B-00D94CD3FAF5")]
[assembly: AssemblyFileVersion("1.0.0.0")]
[assembly: InternalsVisibleTo("Assembly-CSharp-testable")]
[assembly: InternalsVisibleTo("Assembly-CSharp-Editor-testable")]
[assembly: InternalsVisibleTo("Unity.Timeline.EditorTests")]
[assembly: InternalsVisibleTo("Unity.Timeline.Tests")]
[assembly: InternalsVisibleTo("Unity.Timeline.Tests.Common")]
[assembly: InternalsVisibleTo("Unity.Timeline.Tests.Performance")]
[assembly: InternalsVisibleTo("Unity.Timeline.Tests.Performance.Editor")]
[assembly: AssemblyVersion("1.0.0.0")]
[CompilerGenerated]
[EditorBrowsable(EditorBrowsableState.Never)]
[GeneratedCode("Unity.MonoScriptGenerator.MonoScriptInfoGenerator", null)]
internal class UnitySourceGeneratedAssemblyMonoScriptTypes_v1
{
	private struct MonoScriptData
	{
		public byte[] FilePathsData;

		public byte[] TypesData;

		public int TotalTypes;

		public int TotalFiles;

		public bool IsEditorOnly;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static MonoScriptData Get()
	{
		return new MonoScriptData
		{
			FilePathsData = new byte[6198]
			{
				0, 0, 0, 1, 0, 0, 0, 92, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				116, 105, 109, 101, 108, 105, 110, 101, 64, 49,
				46, 55, 46, 54, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 65, 99, 116, 105, 118, 97, 116,
				105, 111, 110, 92, 65, 99, 116, 105, 118, 97,
				116, 105, 111, 110, 77, 105, 120, 101, 114, 80,
				108, 97, 121, 97, 98, 108, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 92, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				116, 105, 109, 101, 108, 105, 110, 101, 64, 49,
				46, 55, 46, 54, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 65, 99, 116, 105, 118, 97, 116,
				105, 111, 110, 92, 65, 99, 116, 105, 118, 97,
				116, 105, 111, 110, 80, 108, 97, 121, 97, 98,
				108, 101, 65, 115, 115, 101, 116, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 84, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				116, 105, 109, 101, 108, 105, 110, 101, 64, 49,
				46, 55, 46, 54, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 65, 99, 116, 105, 118, 97, 116,
				105, 111, 110, 92, 65, 99, 116, 105, 118, 97,
				116, 105, 111, 110, 84, 114, 97, 99, 107, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 98,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 116, 105, 109, 101, 108, 105, 110, 101,
				64, 49, 46, 55, 46, 54, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 65, 110, 105, 109, 97,
				116, 105, 111, 110, 92, 65, 110, 105, 109, 97,
				116, 105, 111, 110, 79, 117, 116, 112, 117, 116,
				87, 101, 105, 103, 104, 116, 80, 114, 111, 99,
				101, 115, 115, 111, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 90, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 116, 105,
				109, 101, 108, 105, 110, 101, 64, 49, 46, 55,
				46, 54, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 65, 110, 105, 109, 97, 116, 105, 111, 110,
				92, 65, 110, 105, 109, 97, 116, 105, 111, 110,
				80, 108, 97, 121, 97, 98, 108, 101, 65, 115,
				115, 101, 116, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 98, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 116, 105, 109, 101,
				108, 105, 110, 101, 64, 49, 46, 55, 46, 54,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 65,
				110, 105, 109, 97, 116, 105, 111, 110, 92, 65,
				110, 105, 109, 97, 116, 105, 111, 110, 80, 114,
				101, 118, 105, 101, 119, 85, 112, 100, 97, 116,
				101, 67, 97, 108, 108, 98, 97, 99, 107, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 82,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 116, 105, 109, 101, 108, 105, 110, 101,
				64, 49, 46, 55, 46, 54, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 65, 110, 105, 109, 97,
				116, 105, 111, 110, 92, 65, 110, 105, 109, 97,
				116, 105, 111, 110, 84, 114, 97, 99, 107, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 80,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 116, 105, 109, 101, 108, 105, 110, 101,
				64, 49, 46, 55, 46, 54, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 65, 110, 105, 109, 97,
				116, 105, 111, 110, 92, 73, 67, 117, 114, 118,
				101, 115, 79, 119, 110, 101, 114, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 100, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				116, 105, 109, 101, 108, 105, 110, 101, 64, 49,
				46, 55, 46, 54, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 65, 115, 115, 101, 116, 85, 112,
				103, 114, 97, 100, 101, 92, 65, 110, 105, 109,
				97, 116, 105, 111, 110, 80, 108, 97, 121, 97,
				98, 108, 101, 65, 115, 115, 101, 116, 85, 112,
				103, 114, 97, 100, 101, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 92, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 116, 105,
				109, 101, 108, 105, 110, 101, 64, 49, 46, 55,
				46, 54, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 65, 115, 115, 101, 116, 85, 112, 103, 114,
				97, 100, 101, 92, 65, 110, 105, 109, 97, 116,
				105, 111, 110, 84, 114, 97, 99, 107, 85, 112,
				103, 114, 97, 100, 101, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 82, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 116, 105,
				109, 101, 108, 105, 110, 101, 64, 49, 46, 55,
				46, 54, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 65, 115, 115, 101, 116, 85, 112, 103, 114,
				97, 100, 101, 92, 67, 108, 105, 112, 85, 112,
				103, 114, 97, 100, 101, 46, 99, 115, 0, 0,
				0, 2, 0, 0, 0, 86, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 116, 105,
				109, 101, 108, 105, 110, 101, 64, 49, 46, 55,
				46, 54, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 65, 115, 115, 101, 116, 85, 112, 103, 114,
				97, 100, 101, 92, 84, 105, 109, 101, 108, 105,
				110, 101, 85, 112, 103, 114, 97, 100, 101, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 83,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 116, 105, 109, 101, 108, 105, 110, 101,
				64, 49, 46, 55, 46, 54, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 65, 115, 115, 101, 116,
				85, 112, 103, 114, 97, 100, 101, 92, 84, 114,
				97, 99, 107, 85, 112, 103, 114, 97, 100, 101,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				93, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 116, 105, 109, 101, 108, 105, 110,
				101, 64, 49, 46, 55, 46, 54, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 65, 116, 116, 114,
				105, 98, 117, 116, 101, 115, 92, 84, 105, 109,
				101, 108, 105, 110, 101, 72, 101, 108, 112, 85,
				82, 76, 65, 116, 116, 114, 105, 98, 117, 116,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 88, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 116, 105, 109, 101, 108, 105,
				110, 101, 64, 49, 46, 55, 46, 54, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 65, 116, 116,
				114, 105, 98, 117, 116, 101, 115, 92, 84, 114,
				97, 99, 107, 67, 111, 108, 111, 114, 65, 116,
				116, 114, 105, 98, 117, 116, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 83, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				116, 105, 109, 101, 108, 105, 110, 101, 64, 49,
				46, 55, 46, 54, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 65, 117, 100, 105, 111, 92, 65,
				117, 100, 105, 111, 67, 108, 105, 112, 80, 114,
				111, 112, 101, 114, 116, 105, 101, 115, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 84, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 116, 105, 109, 101, 108, 105, 110, 101, 64,
				49, 46, 55, 46, 54, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 65, 117, 100, 105, 111, 92,
				65, 117, 100, 105, 111, 77, 105, 120, 101, 114,
				80, 114, 111, 112, 101, 114, 116, 105, 101, 115,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				82, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 116, 105, 109, 101, 108, 105, 110,
				101, 64, 49, 46, 55, 46, 54, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 65, 117, 100, 105,
				111, 92, 65, 117, 100, 105, 111, 80, 108, 97,
				121, 97, 98, 108, 101, 65, 115, 115, 101, 116,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				74, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 116, 105, 109, 101, 108, 105, 110,
				101, 64, 49, 46, 55, 46, 54, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 65, 117, 100, 105,
				111, 92, 65, 117, 100, 105, 111, 84, 114, 97,
				99, 107, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 66, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 116, 105, 109, 101, 108,
				105, 110, 101, 64, 49, 46, 55, 46, 54, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 67, 108,
				105, 112, 67, 97, 112, 115, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 86, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 116,
				105, 109, 101, 108, 105, 110, 101, 64, 49, 46,
				55, 46, 54, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 67, 111, 110, 116, 114, 111, 108, 92,
				67, 111, 110, 116, 114, 111, 108, 80, 108, 97,
				121, 97, 98, 108, 101, 65, 115, 115, 101, 116,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				78, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 116, 105, 109, 101, 108, 105, 110,
				101, 64, 49, 46, 55, 46, 54, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 67, 111, 110, 116,
				114, 111, 108, 92, 67, 111, 110, 116, 114, 111,
				108, 84, 114, 97, 99, 107, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 70, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 116,
				105, 109, 101, 108, 105, 110, 101, 64, 49, 46,
				55, 46, 54, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 68, 105, 115, 99, 114, 101, 116, 101,
				84, 105, 109, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 88, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 116, 105, 109,
				101, 108, 105, 110, 101, 64, 49, 46, 55, 46,
				54, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				69, 118, 97, 108, 117, 97, 116, 105, 111, 110,
				92, 73, 110, 102, 105, 110, 105, 116, 101, 82,
				117, 110, 116, 105, 109, 101, 67, 108, 105, 112,
				46, 99, 115, 0, 0, 0, 4, 0, 0, 0,
				81, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 116, 105, 109, 101, 108, 105, 110,
				101, 64, 49, 46, 55, 46, 54, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 69, 118, 97, 108,
				117, 97, 116, 105, 111, 110, 92, 73, 110, 116,
				101, 114, 118, 97, 108, 84, 114, 101, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 80,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 116, 105, 109, 101, 108, 105, 110, 101,
				64, 49, 46, 55, 46, 54, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 69, 118, 97, 108, 117,
				97, 116, 105, 111, 110, 92, 82, 117, 110, 116,
				105, 109, 101, 67, 108, 105, 112, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 84, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				116, 105, 109, 101, 108, 105, 110, 101, 64, 49,
				46, 55, 46, 54, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 69, 118, 97, 108, 117, 97, 116,
				105, 111, 110, 92, 82, 117, 110, 116, 105, 109,
				101, 67, 108, 105, 112, 66, 97, 115, 101, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 83,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 116, 105, 109, 101, 108, 105, 110, 101,
				64, 49, 46, 55, 46, 54, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 69, 118, 97, 108, 117,
				97, 116, 105, 111, 110, 92, 82, 117, 110, 116,
				105, 109, 101, 69, 108, 101, 109, 101, 110, 116,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				88, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 116, 105, 109, 101, 108, 105, 110,
				101, 64, 49, 46, 55, 46, 54, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 69, 118, 97, 108,
				117, 97, 116, 105, 111, 110, 92, 83, 99, 104,
				101, 100, 117, 108, 101, 82, 117, 110, 116, 105,
				109, 101, 67, 108, 105, 112, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 72, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 116,
				105, 109, 101, 108, 105, 110, 101, 64, 49, 46,
				55, 46, 54, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 69, 118, 101, 110, 116, 115, 92, 73,
				77, 97, 114, 107, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 92, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 116,
				105, 109, 101, 108, 105, 110, 101, 64, 49, 46,
				55, 46, 54, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 69, 118, 101, 110, 116, 115, 92, 73,
				78, 111, 116, 105, 102, 105, 99, 97, 116, 105,
				111, 110, 79, 112, 116, 105, 111, 110, 80, 114,
				111, 118, 105, 100, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 71, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 116,
				105, 109, 101, 108, 105, 110, 101, 64, 49, 46,
				55, 46, 54, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 69, 118, 101, 110, 116, 115, 92, 77,
				97, 114, 107, 101, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 75, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 116, 105,
				109, 101, 108, 105, 110, 101, 64, 49, 46, 55,
				46, 54, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 69, 118, 101, 110, 116, 115, 92, 77, 97,
				114, 107, 101, 114, 76, 105, 115, 116, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 76, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 116, 105, 109, 101, 108, 105, 110, 101, 64,
				49, 46, 55, 46, 54, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 69, 118, 101, 110, 116, 115,
				92, 77, 97, 114, 107, 101, 114, 84, 114, 97,
				99, 107, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 96, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 116, 105, 109, 101, 108,
				105, 110, 101, 64, 49, 46, 55, 46, 54, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 69, 118,
				101, 110, 116, 115, 92, 83, 105, 103, 110, 97,
				108, 115, 92, 67, 117, 115, 116, 111, 109, 83,
				105, 103, 110, 97, 108, 69, 118, 101, 110, 116,
				68, 114, 97, 119, 101, 114, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 84, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 116,
				105, 109, 101, 108, 105, 110, 101, 64, 49, 46,
				55, 46, 54, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 69, 118, 101, 110, 116, 115, 92, 83,
				105, 103, 110, 97, 108, 115, 92, 83, 105, 103,
				110, 97, 108, 65, 115, 115, 101, 116, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 86, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 116, 105, 109, 101, 108, 105, 110, 101, 64,
				49, 46, 55, 46, 54, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 69, 118, 101, 110, 116, 115,
				92, 83, 105, 103, 110, 97, 108, 115, 92, 83,
				105, 103, 110, 97, 108, 69, 109, 105, 116, 116,
				101, 114, 46, 99, 115, 0, 0, 0, 2, 0,
				0, 0, 87, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 116, 105, 109, 101, 108,
				105, 110, 101, 64, 49, 46, 55, 46, 54, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 69, 118,
				101, 110, 116, 115, 92, 83, 105, 103, 110, 97,
				108, 115, 92, 83, 105, 103, 110, 97, 108, 82,
				101, 99, 101, 105, 118, 101, 114, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 76, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				116, 105, 109, 101, 108, 105, 110, 101, 64, 49,
				46, 55, 46, 54, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 69, 118, 101, 110, 116, 115, 92,
				83, 105, 103, 110, 97, 108, 84, 114, 97, 99,
				107, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 84, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 116, 105, 109, 101, 108, 105,
				110, 101, 64, 49, 46, 55, 46, 54, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 69, 120, 116,
				101, 110, 115, 105, 111, 110, 115, 92, 84, 114,
				97, 99, 107, 69, 120, 116, 101, 110, 115, 105,
				111, 110, 115, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 68, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 116, 105, 109, 101,
				108, 105, 110, 101, 64, 49, 46, 55, 46, 54,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 71,
				114, 111, 117, 112, 84, 114, 97, 99, 107, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 68,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 116, 105, 109, 101, 108, 105, 110, 101,
				64, 49, 46, 55, 46, 54, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 73, 76, 97, 121, 101,
				114, 97, 98, 108, 101, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 93, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 116, 105,
				109, 101, 108, 105, 110, 101, 64, 49, 46, 55,
				46, 54, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 80, 108, 97, 121, 97, 98, 108, 101, 115,
				92, 65, 99, 116, 105, 118, 97, 116, 105, 111,
				110, 67, 111, 110, 116, 114, 111, 108, 80, 108,
				97, 121, 97, 98, 108, 101, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 87, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 116,
				105, 109, 101, 108, 105, 110, 101, 64, 49, 46,
				55, 46, 54, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 80, 108, 97, 121, 97, 98, 108, 101,
				115, 92, 66, 97, 115, 105, 99, 83, 99, 114,
				105, 112, 116, 80, 108, 97, 121, 97, 98, 108,
				101, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 91, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 116, 105, 109, 101, 108, 105,
				110, 101, 64, 49, 46, 55, 46, 54, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 80, 108, 97,
				121, 97, 98, 108, 101, 115, 92, 68, 105, 114,
				101, 99, 116, 111, 114, 67, 111, 110, 116, 114,
				111, 108, 80, 108, 97, 121, 97, 98, 108, 101,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				80, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 116, 105, 109, 101, 108, 105, 110,
				101, 64, 49, 46, 55, 46, 54, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 80, 108, 97, 121,
				97, 98, 108, 101, 115, 92, 73, 84, 105, 109,
				101, 67, 111, 110, 116, 114, 111, 108, 46, 99,
				115, 0, 0, 0, 1, 0, 0, 0, 91, 92,
				76, 105, 98, 114, 97, 114, 121, 92, 80, 97,
				99, 107, 97, 103, 101, 67, 97, 99, 104, 101,
				92, 99, 111, 109, 46, 117, 110, 105, 116, 121,
				46, 116, 105, 109, 101, 108, 105, 110, 101, 64,
				49, 46, 55, 46, 54, 92, 82, 117, 110, 116,
				105, 109, 101, 92, 80, 108, 97, 121, 97, 98,
				108, 101, 115, 92, 80, 97, 114, 116, 105, 99,
				108, 101, 67, 111, 110, 116, 114, 111, 108, 80,
				108, 97, 121, 97, 98, 108, 101, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 89, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				116, 105, 109, 101, 108, 105, 110, 101, 64, 49,
				46, 55, 46, 54, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 80, 108, 97, 121, 97, 98, 108,
				101, 115, 92, 80, 114, 101, 102, 97, 98, 67,
				111, 110, 116, 114, 111, 108, 80, 108, 97, 121,
				97, 98, 108, 101, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 87, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 116, 105, 109,
				101, 108, 105, 110, 101, 64, 49, 46, 55, 46,
				54, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				80, 108, 97, 121, 97, 98, 108, 101, 115, 92,
				84, 105, 109, 101, 67, 111, 110, 116, 114, 111,
				108, 80, 108, 97, 121, 97, 98, 108, 101, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 93,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 116, 105, 109, 101, 108, 105, 110, 101,
				64, 49, 46, 55, 46, 54, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 80, 108, 97, 121, 97,
				98, 108, 101, 115, 92, 84, 105, 109, 101, 78,
				111, 116, 105, 102, 105, 99, 97, 116, 105, 111,
				110, 66, 101, 104, 97, 118, 105, 111, 117, 114,
				46, 99, 115, 0, 0, 0, 1, 0, 0, 0,
				81, 92, 76, 105, 98, 114, 97, 114, 121, 92,
				80, 97, 99, 107, 97, 103, 101, 67, 97, 99,
				104, 101, 92, 99, 111, 109, 46, 117, 110, 105,
				116, 121, 46, 116, 105, 109, 101, 108, 105, 110,
				101, 64, 49, 46, 55, 46, 54, 92, 82, 117,
				110, 116, 105, 109, 101, 92, 83, 99, 114, 105,
				112, 116, 105, 110, 103, 92, 80, 108, 97, 121,
				97, 98, 108, 101, 84, 114, 97, 99, 107, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 77,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 116, 105, 109, 101, 108, 105, 110, 101,
				64, 49, 46, 55, 46, 54, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 84, 105, 109, 101, 108,
				105, 110, 101, 46, 100, 101, 112, 114, 101, 99,
				97, 116, 101, 100, 46, 99, 115, 0, 0, 0,
				2, 0, 0, 0, 71, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 116, 105, 109,
				101, 108, 105, 110, 101, 64, 49, 46, 55, 46,
				54, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				84, 105, 109, 101, 108, 105, 110, 101, 65, 115,
				115, 101, 116, 46, 99, 115, 0, 0, 0, 1,
				0, 0, 0, 84, 92, 76, 105, 98, 114, 97,
				114, 121, 92, 80, 97, 99, 107, 97, 103, 101,
				67, 97, 99, 104, 101, 92, 99, 111, 109, 46,
				117, 110, 105, 116, 121, 46, 116, 105, 109, 101,
				108, 105, 110, 101, 64, 49, 46, 55, 46, 54,
				92, 82, 117, 110, 116, 105, 109, 101, 92, 84,
				105, 109, 101, 108, 105, 110, 101, 65, 115, 115,
				101, 116, 95, 67, 114, 101, 97, 116, 101, 82,
				101, 109, 111, 118, 101, 46, 99, 115, 0, 0,
				0, 10, 0, 0, 0, 76, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 116, 105,
				109, 101, 108, 105, 110, 101, 64, 49, 46, 55,
				46, 54, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 84, 105, 109, 101, 108, 105, 110, 101, 65,
				116, 116, 114, 105, 98, 117, 116, 101, 115, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 70,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 116, 105, 109, 101, 108, 105, 110, 101,
				64, 49, 46, 55, 46, 54, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 84, 105, 109, 101, 108,
				105, 110, 101, 67, 108, 105, 112, 46, 99, 115,
				0, 0, 0, 2, 0, 0, 0, 74, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				116, 105, 109, 101, 108, 105, 110, 101, 64, 49,
				46, 55, 46, 54, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 84, 105, 109, 101, 108, 105, 110,
				101, 80, 108, 97, 121, 97, 98, 108, 101, 46,
				99, 115, 0, 0, 0, 2, 0, 0, 0, 68,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 116, 105, 109, 101, 108, 105, 110, 101,
				64, 49, 46, 55, 46, 54, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 84, 114, 97, 99, 107,
				65, 115, 115, 101, 116, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 81, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 116, 105,
				109, 101, 108, 105, 110, 101, 64, 49, 46, 55,
				46, 54, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 85, 116, 105, 108, 105, 116, 105, 101, 115,
				92, 69, 120, 116, 114, 97, 112, 111, 108, 97,
				116, 105, 111, 110, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 79, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 116, 105, 109,
				101, 108, 105, 110, 101, 64, 49, 46, 55, 46,
				54, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				85, 116, 105, 108, 105, 116, 105, 101, 115, 92,
				72, 97, 115, 104, 85, 116, 105, 108, 105, 116,
				121, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 86, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 116, 105, 109, 101, 108, 105,
				110, 101, 64, 49, 46, 55, 46, 54, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 85, 116, 105,
				108, 105, 116, 105, 101, 115, 92, 73, 80, 114,
				111, 112, 101, 114, 116, 121, 67, 111, 108, 108,
				101, 99, 116, 111, 114, 46, 99, 115, 0, 0,
				0, 1, 0, 0, 0, 84, 92, 76, 105, 98,
				114, 97, 114, 121, 92, 80, 97, 99, 107, 97,
				103, 101, 67, 97, 99, 104, 101, 92, 99, 111,
				109, 46, 117, 110, 105, 116, 121, 46, 116, 105,
				109, 101, 108, 105, 110, 101, 64, 49, 46, 55,
				46, 54, 92, 82, 117, 110, 116, 105, 109, 101,
				92, 85, 116, 105, 108, 105, 116, 105, 101, 115,
				92, 73, 80, 114, 111, 112, 101, 114, 116, 121,
				80, 114, 101, 118, 105, 101, 119, 46, 99, 115,
				0, 0, 0, 1, 0, 0, 0, 89, 92, 76,
				105, 98, 114, 97, 114, 121, 92, 80, 97, 99,
				107, 97, 103, 101, 67, 97, 99, 104, 101, 92,
				99, 111, 109, 46, 117, 110, 105, 116, 121, 46,
				116, 105, 109, 101, 108, 105, 110, 101, 64, 49,
				46, 55, 46, 54, 92, 82, 117, 110, 116, 105,
				109, 101, 92, 85, 116, 105, 108, 105, 116, 105,
				101, 115, 92, 78, 111, 116, 105, 102, 105, 99,
				97, 116, 105, 111, 110, 85, 116, 105, 108, 105,
				116, 105, 101, 115, 46, 99, 115, 0, 0, 0,
				1, 0, 0, 0, 90, 92, 76, 105, 98, 114,
				97, 114, 121, 92, 80, 97, 99, 107, 97, 103,
				101, 67, 97, 99, 104, 101, 92, 99, 111, 109,
				46, 117, 110, 105, 116, 121, 46, 116, 105, 109,
				101, 108, 105, 110, 101, 64, 49, 46, 55, 46,
				54, 92, 82, 117, 110, 116, 105, 109, 101, 92,
				85, 116, 105, 108, 105, 116, 105, 101, 115, 92,
				84, 105, 109, 101, 108, 105, 110, 101, 67, 108,
				105, 112, 69, 120, 116, 101, 110, 115, 105, 111,
				110, 115, 46, 99, 115, 0, 0, 0, 1, 0,
				0, 0, 91, 92, 76, 105, 98, 114, 97, 114,
				121, 92, 80, 97, 99, 107, 97, 103, 101, 67,
				97, 99, 104, 101, 92, 99, 111, 109, 46, 117,
				110, 105, 116, 121, 46, 116, 105, 109, 101, 108,
				105, 110, 101, 64, 49, 46, 55, 46, 54, 92,
				82, 117, 110, 116, 105, 109, 101, 92, 85, 116,
				105, 108, 105, 116, 105, 101, 115, 92, 84, 105,
				109, 101, 108, 105, 110, 101, 67, 114, 101, 97,
				116, 101, 85, 116, 105, 108, 105, 116, 105, 101,
				115, 46, 99, 115, 0, 0, 0, 1, 0, 0,
				0, 80, 92, 76, 105, 98, 114, 97, 114, 121,
				92, 80, 97, 99, 107, 97, 103, 101, 67, 97,
				99, 104, 101, 92, 99, 111, 109, 46, 117, 110,
				105, 116, 121, 46, 116, 105, 109, 101, 108, 105,
				110, 101, 64, 49, 46, 55, 46, 54, 92, 82,
				117, 110, 116, 105, 109, 101, 92, 85, 116, 105,
				108, 105, 116, 105, 101, 115, 92, 84, 105, 109,
				101, 108, 105, 110, 101, 85, 110, 100, 111, 46,
				99, 115, 0, 0, 0, 1, 0, 0, 0, 79,
				92, 76, 105, 98, 114, 97, 114, 121, 92, 80,
				97, 99, 107, 97, 103, 101, 67, 97, 99, 104,
				101, 92, 99, 111, 109, 46, 117, 110, 105, 116,
				121, 46, 116, 105, 109, 101, 108, 105, 110, 101,
				64, 49, 46, 55, 46, 54, 92, 82, 117, 110,
				116, 105, 109, 101, 92, 85, 116, 105, 108, 105,
				116, 105, 101, 115, 92, 84, 105, 109, 101, 85,
				116, 105, 108, 105, 116, 121, 46, 99, 115, 0,
				0, 0, 1, 0, 0, 0, 81, 92, 76, 105,
				98, 114, 97, 114, 121, 92, 80, 97, 99, 107,
				97, 103, 101, 67, 97, 99, 104, 101, 92, 99,
				111, 109, 46, 117, 110, 105, 116, 121, 46, 116,
				105, 109, 101, 108, 105, 110, 101, 64, 49, 46,
				55, 46, 54, 92, 82, 117, 110, 116, 105, 109,
				101, 92, 85, 116, 105, 108, 105, 116, 105, 101,
				115, 92, 87, 101, 105, 103, 104, 116, 85, 116,
				105, 108, 105, 116, 121, 46, 99, 115
			},
			TypesData = new byte[4248]
			{
				0, 0, 0, 0, 44, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 84, 105, 109,
				101, 108, 105, 110, 101, 124, 65, 99, 116, 105,
				118, 97, 116, 105, 111, 110, 77, 105, 120, 101,
				114, 80, 108, 97, 121, 97, 98, 108, 101, 0,
				0, 0, 0, 44, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 84, 105, 109, 101,
				108, 105, 110, 101, 124, 65, 99, 116, 105, 118,
				97, 116, 105, 111, 110, 80, 108, 97, 121, 97,
				98, 108, 101, 65, 115, 115, 101, 116, 0, 0,
				0, 0, 36, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 124, 65, 99, 116, 105, 118, 97,
				116, 105, 111, 110, 84, 114, 97, 99, 107, 0,
				0, 0, 0, 51, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 84, 105, 109, 101,
				108, 105, 110, 101, 124, 65, 110, 105, 109, 97,
				116, 105, 111, 110, 79, 117, 116, 112, 117, 116,
				87, 101, 105, 103, 104, 116, 80, 114, 111, 99,
				101, 115, 115, 111, 114, 0, 0, 0, 0, 62,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 84, 105, 109, 101, 108, 105, 110, 101,
				46, 65, 110, 105, 109, 97, 116, 105, 111, 110,
				79, 117, 116, 112, 117, 116, 87, 101, 105, 103,
				104, 116, 80, 114, 111, 99, 101, 115, 115, 111,
				114, 124, 87, 101, 105, 103, 104, 116, 73, 110,
				102, 111, 1, 0, 0, 0, 43, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 84,
				105, 109, 101, 108, 105, 110, 101, 124, 65, 110,
				105, 109, 97, 116, 105, 111, 110, 80, 108, 97,
				121, 97, 98, 108, 101, 65, 115, 115, 101, 116,
				0, 0, 0, 0, 51, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 84, 105, 109,
				101, 108, 105, 110, 101, 124, 65, 110, 105, 109,
				97, 116, 105, 111, 110, 80, 114, 101, 118, 105,
				101, 119, 85, 112, 100, 97, 116, 101, 67, 97,
				108, 108, 98, 97, 99, 107, 0, 0, 0, 0,
				46, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 84, 105, 109, 101, 108, 105, 110,
				101, 124, 77, 97, 116, 99, 104, 84, 97, 114,
				103, 101, 116, 70, 105, 101, 108, 100, 67, 111,
				110, 115, 116, 97, 110, 116, 115, 1, 0, 0,
				0, 35, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 84, 105, 109, 101, 108, 105,
				110, 101, 124, 65, 110, 105, 109, 97, 116, 105,
				111, 110, 84, 114, 97, 99, 107, 0, 0, 0,
				0, 33, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 84, 105, 109, 101, 108, 105,
				110, 101, 124, 73, 67, 117, 114, 118, 101, 115,
				79, 119, 110, 101, 114, 1, 0, 0, 0, 43,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 84, 105, 109, 101, 108, 105, 110, 101,
				124, 65, 110, 105, 109, 97, 116, 105, 111, 110,
				80, 108, 97, 121, 97, 98, 108, 101, 65, 115,
				115, 101, 116, 0, 0, 0, 0, 73, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				84, 105, 109, 101, 108, 105, 110, 101, 46, 65,
				110, 105, 109, 97, 116, 105, 111, 110, 80, 108,
				97, 121, 97, 98, 108, 101, 65, 115, 115, 101,
				116, 124, 65, 110, 105, 109, 97, 116, 105, 111,
				110, 80, 108, 97, 121, 97, 98, 108, 101, 65,
				115, 115, 101, 116, 85, 112, 103, 114, 97, 100,
				101, 1, 0, 0, 0, 35, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 84, 105,
				109, 101, 108, 105, 110, 101, 124, 65, 110, 105,
				109, 97, 116, 105, 111, 110, 84, 114, 97, 99,
				107, 0, 0, 0, 0, 57, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 84, 105,
				109, 101, 108, 105, 110, 101, 46, 65, 110, 105,
				109, 97, 116, 105, 111, 110, 84, 114, 97, 99,
				107, 124, 65, 110, 105, 109, 97, 116, 105, 111,
				110, 84, 114, 97, 99, 107, 85, 112, 103, 114,
				97, 100, 101, 1, 0, 0, 0, 33, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				84, 105, 109, 101, 108, 105, 110, 101, 124, 84,
				105, 109, 101, 108, 105, 110, 101, 67, 108, 105,
				112, 0, 0, 0, 0, 53, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 84, 105,
				109, 101, 108, 105, 110, 101, 46, 84, 105, 109,
				101, 108, 105, 110, 101, 67, 108, 105, 112, 124,
				84, 105, 109, 101, 108, 105, 110, 101, 67, 108,
				105, 112, 85, 112, 103, 114, 97, 100, 101, 1,
				0, 0, 0, 34, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 84, 105, 109, 101,
				108, 105, 110, 101, 124, 84, 105, 109, 101, 108,
				105, 110, 101, 65, 115, 115, 101, 116, 0, 0,
				0, 0, 55, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 46, 84, 105, 109, 101, 108, 105,
				110, 101, 65, 115, 115, 101, 116, 124, 84, 105,
				109, 101, 108, 105, 110, 101, 65, 115, 115, 101,
				116, 85, 112, 103, 114, 97, 100, 101, 1, 0,
				0, 0, 31, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 124, 84, 114, 97, 99, 107, 65,
				115, 115, 101, 116, 0, 0, 0, 0, 49, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 84, 105, 109, 101, 108, 105, 110, 101, 46,
				84, 114, 97, 99, 107, 65, 115, 115, 101, 116,
				124, 84, 114, 97, 99, 107, 65, 115, 115, 101,
				116, 85, 112, 103, 114, 97, 100, 101, 0, 0,
				0, 0, 45, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 124, 84, 105, 109, 101, 108, 105,
				110, 101, 72, 101, 108, 112, 85, 82, 76, 65,
				116, 116, 114, 105, 98, 117, 116, 101, 0, 0,
				0, 0, 40, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 124, 84, 114, 97, 99, 107, 67,
				111, 108, 111, 114, 65, 116, 116, 114, 105, 98,
				117, 116, 101, 0, 0, 0, 0, 40, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				84, 105, 109, 101, 108, 105, 110, 101, 124, 65,
				117, 100, 105, 111, 67, 108, 105, 112, 80, 114,
				111, 112, 101, 114, 116, 105, 101, 115, 0, 0,
				0, 0, 41, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 124, 65, 117, 100, 105, 111, 77,
				105, 120, 101, 114, 80, 114, 111, 112, 101, 114,
				116, 105, 101, 115, 0, 0, 0, 0, 39, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 84, 105, 109, 101, 108, 105, 110, 101, 124,
				65, 117, 100, 105, 111, 80, 108, 97, 121, 97,
				98, 108, 101, 65, 115, 115, 101, 116, 0, 0,
				0, 0, 31, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 124, 65, 117, 100, 105, 111, 84,
				114, 97, 99, 107, 0, 0, 0, 0, 47, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 84, 105, 109, 101, 108, 105, 110, 101, 124,
				84, 105, 109, 101, 108, 105, 110, 101, 67, 108,
				105, 112, 67, 97, 112, 115, 69, 120, 116, 101,
				110, 115, 105, 111, 110, 115, 0, 0, 0, 0,
				41, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 84, 105, 109, 101, 108, 105, 110,
				101, 124, 67, 111, 110, 116, 114, 111, 108, 80,
				108, 97, 121, 97, 98, 108, 101, 65, 115, 115,
				101, 116, 0, 0, 0, 0, 33, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 84,
				105, 109, 101, 108, 105, 110, 101, 124, 67, 111,
				110, 116, 114, 111, 108, 84, 114, 97, 99, 107,
				0, 0, 0, 0, 33, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 84, 105, 109,
				101, 108, 105, 110, 101, 124, 68, 105, 115, 99,
				114, 101, 116, 101, 84, 105, 109, 101, 0, 0,
				0, 0, 40, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 124, 73, 110, 102, 105, 110, 105,
				116, 101, 82, 117, 110, 116, 105, 109, 101, 67,
				108, 105, 112, 0, 0, 0, 0, 30, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				84, 105, 109, 101, 108, 105, 110, 101, 124, 73,
				73, 110, 116, 101, 114, 118, 97, 108, 0, 0,
				0, 0, 37, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 124, 73, 110, 116, 101, 114, 118,
				97, 108, 84, 114, 101, 101, 78, 111, 100, 101,
				0, 0, 0, 0, 33, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 84, 105, 109,
				101, 108, 105, 110, 101, 124, 73, 110, 116, 101,
				114, 118, 97, 108, 84, 114, 101, 101, 0, 0,
				0, 0, 39, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 46, 73, 110, 116, 101, 114, 118,
				97, 108, 84, 114, 101, 101, 124, 69, 110, 116,
				114, 121, 0, 0, 0, 0, 32, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 84,
				105, 109, 101, 108, 105, 110, 101, 124, 82, 117,
				110, 116, 105, 109, 101, 67, 108, 105, 112, 0,
				0, 0, 0, 36, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 84, 105, 109, 101,
				108, 105, 110, 101, 124, 82, 117, 110, 116, 105,
				109, 101, 67, 108, 105, 112, 66, 97, 115, 101,
				0, 0, 0, 0, 35, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 84, 105, 109,
				101, 108, 105, 110, 101, 124, 82, 117, 110, 116,
				105, 109, 101, 69, 108, 101, 109, 101, 110, 116,
				0, 0, 0, 0, 40, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 84, 105, 109,
				101, 108, 105, 110, 101, 124, 83, 99, 104, 101,
				100, 117, 108, 101, 82, 117, 110, 116, 105, 109,
				101, 67, 108, 105, 112, 0, 0, 0, 0, 28,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 84, 105, 109, 101, 108, 105, 110, 101,
				124, 73, 77, 97, 114, 107, 101, 114, 0, 0,
				0, 0, 48, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 124, 73, 78, 111, 116, 105, 102,
				105, 99, 97, 116, 105, 111, 110, 79, 112, 116,
				105, 111, 110, 80, 114, 111, 118, 105, 100, 101,
				114, 0, 0, 0, 0, 27, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 84, 105,
				109, 101, 108, 105, 110, 101, 124, 77, 97, 114,
				107, 101, 114, 0, 0, 0, 0, 31, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				84, 105, 109, 101, 108, 105, 110, 101, 124, 77,
				97, 114, 107, 101, 114, 76, 105, 115, 116, 0,
				0, 0, 0, 32, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 84, 105, 109, 101,
				108, 105, 110, 101, 124, 77, 97, 114, 107, 101,
				114, 84, 114, 97, 99, 107, 0, 0, 0, 0,
				44, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 84, 105, 109, 101, 108, 105, 110,
				101, 124, 67, 117, 115, 116, 111, 109, 83, 105,
				103, 110, 97, 108, 69, 118, 101, 110, 116, 68,
				114, 97, 119, 101, 114, 0, 0, 0, 0, 32,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 84, 105, 109, 101, 108, 105, 110, 101,
				124, 83, 105, 103, 110, 97, 108, 65, 115, 115,
				101, 116, 0, 0, 0, 0, 34, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 84,
				105, 109, 101, 108, 105, 110, 101, 124, 83, 105,
				103, 110, 97, 108, 69, 109, 105, 116, 116, 101,
				114, 0, 0, 0, 0, 35, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 84, 105,
				109, 101, 108, 105, 110, 101, 124, 83, 105, 103,
				110, 97, 108, 82, 101, 99, 101, 105, 118, 101,
				114, 0, 0, 0, 0, 49, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 84, 105,
				109, 101, 108, 105, 110, 101, 46, 83, 105, 103,
				110, 97, 108, 82, 101, 99, 101, 105, 118, 101,
				114, 124, 69, 118, 101, 110, 116, 75, 101, 121,
				86, 97, 108, 117, 101, 0, 0, 0, 0, 32,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 84, 105, 109, 101, 108, 105, 110, 101,
				124, 83, 105, 103, 110, 97, 108, 84, 114, 97,
				99, 107, 0, 0, 0, 0, 41, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 84,
				105, 109, 101, 108, 105, 110, 101, 124, 84, 114,
				97, 99, 107, 65, 115, 115, 101, 116, 69, 120,
				116, 101, 110, 115, 105, 111, 110, 115, 0, 0,
				0, 0, 31, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 124, 71, 114, 111, 117, 112, 84,
				114, 97, 99, 107, 0, 0, 0, 0, 31, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 84, 105, 109, 101, 108, 105, 110, 101, 124,
				73, 76, 97, 121, 101, 114, 97, 98, 108, 101,
				0, 0, 0, 0, 46, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 84, 105, 109,
				101, 108, 105, 110, 101, 124, 65, 99, 116, 105,
				118, 97, 116, 105, 111, 110, 67, 111, 110, 116,
				114, 111, 108, 80, 108, 97, 121, 97, 98, 108,
				101, 0, 0, 0, 0, 43, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 84, 105,
				109, 101, 108, 105, 110, 101, 124, 66, 97, 115,
				105, 99, 80, 108, 97, 121, 97, 98, 108, 101,
				66, 101, 104, 97, 118, 105, 111, 117, 114, 0,
				0, 0, 0, 44, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 84, 105, 109, 101,
				108, 105, 110, 101, 124, 68, 105, 114, 101, 99,
				116, 111, 114, 67, 111, 110, 116, 114, 111, 108,
				80, 108, 97, 121, 97, 98, 108, 101, 0, 0,
				0, 0, 33, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 124, 73, 84, 105, 109, 101, 67,
				111, 110, 116, 114, 111, 108, 0, 0, 0, 0,
				44, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 84, 105, 109, 101, 108, 105, 110,
				101, 124, 80, 97, 114, 116, 105, 99, 108, 101,
				67, 111, 110, 116, 114, 111, 108, 80, 108, 97,
				121, 97, 98, 108, 101, 0, 0, 0, 0, 42,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 84, 105, 109, 101, 108, 105, 110, 101,
				124, 80, 114, 101, 102, 97, 98, 67, 111, 110,
				116, 114, 111, 108, 80, 108, 97, 121, 97, 98,
				108, 101, 0, 0, 0, 0, 40, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 84,
				105, 109, 101, 108, 105, 110, 101, 124, 84, 105,
				109, 101, 67, 111, 110, 116, 114, 111, 108, 80,
				108, 97, 121, 97, 98, 108, 101, 0, 0, 0,
				0, 46, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 84, 105, 109, 101, 108, 105,
				110, 101, 124, 84, 105, 109, 101, 78, 111, 116,
				105, 102, 105, 99, 97, 116, 105, 111, 110, 66,
				101, 104, 97, 118, 105, 111, 117, 114, 0, 0,
				0, 0, 64, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 46, 84, 105, 109, 101, 78, 111,
				116, 105, 102, 105, 99, 97, 116, 105, 111, 110,
				66, 101, 104, 97, 118, 105, 111, 117, 114, 124,
				78, 111, 116, 105, 102, 105, 99, 97, 116, 105,
				111, 110, 69, 110, 116, 114, 121, 0, 0, 0,
				0, 34, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 84, 105, 109, 101, 108, 105,
				110, 101, 124, 80, 108, 97, 121, 97, 98, 108,
				101, 84, 114, 97, 99, 107, 1, 0, 0, 0,
				34, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 84, 105, 109, 101, 108, 105, 110,
				101, 124, 84, 105, 109, 101, 108, 105, 110, 101,
				65, 115, 115, 101, 116, 0, 0, 0, 0, 35,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 84, 105, 109, 101, 108, 105, 110, 101,
				124, 84, 114, 97, 99, 107, 77, 101, 100, 105,
				97, 84, 121, 112, 101, 1, 0, 0, 0, 34,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 84, 105, 109, 101, 108, 105, 110, 101,
				124, 84, 105, 109, 101, 108, 105, 110, 101, 65,
				115, 115, 101, 116, 0, 0, 0, 0, 49, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 84, 105, 109, 101, 108, 105, 110, 101, 46,
				84, 105, 109, 101, 108, 105, 110, 101, 65, 115,
				115, 101, 116, 124, 69, 100, 105, 116, 111, 114,
				83, 101, 116, 116, 105, 110, 103, 115, 1, 0,
				0, 0, 34, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 124, 84, 105, 109, 101, 108, 105,
				110, 101, 65, 115, 115, 101, 116, 0, 0, 0,
				0, 43, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 84, 105, 109, 101, 108, 105,
				110, 101, 124, 84, 114, 97, 99, 107, 67, 108,
				105, 112, 84, 121, 112, 101, 65, 116, 116, 114,
				105, 98, 117, 116, 101, 0, 0, 0, 0, 40,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 84, 105, 109, 101, 108, 105, 110, 101,
				124, 78, 111, 116, 75, 101, 121, 97, 98, 108,
				101, 65, 116, 116, 114, 105, 98, 117, 116, 101,
				0, 0, 0, 0, 46, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 84, 105, 109,
				101, 108, 105, 110, 101, 124, 84, 114, 97, 99,
				107, 66, 105, 110, 100, 105, 110, 103, 84, 121,
				112, 101, 65, 116, 116, 114, 105, 98, 117, 116,
				101, 0, 0, 0, 0, 49, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 84, 105,
				109, 101, 108, 105, 110, 101, 124, 83, 117, 112,
				112, 111, 114, 116, 115, 67, 104, 105, 108, 100,
				84, 114, 97, 99, 107, 115, 65, 116, 116, 114,
				105, 98, 117, 116, 101, 0, 0, 0, 0, 51,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 84, 105, 109, 101, 108, 105, 110, 101,
				124, 73, 103, 110, 111, 114, 101, 79, 110, 80,
				108, 97, 121, 97, 98, 108, 101, 84, 114, 97,
				99, 107, 65, 116, 116, 114, 105, 98, 117, 116,
				101, 0, 0, 0, 0, 39, 85, 110, 105, 116,
				121, 69, 110, 103, 105, 110, 101, 46, 84, 105,
				109, 101, 108, 105, 110, 101, 124, 84, 105, 109,
				101, 70, 105, 101, 108, 100, 65, 116, 116, 114,
				105, 98, 117, 116, 101, 0, 0, 0, 0, 44,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 84, 105, 109, 101, 108, 105, 110, 101,
				124, 70, 114, 97, 109, 101, 82, 97, 116, 101,
				70, 105, 101, 108, 100, 65, 116, 116, 114, 105,
				98, 117, 116, 101, 0, 0, 0, 0, 40, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 84, 105, 109, 101, 108, 105, 110, 101, 124,
				72, 105, 100, 101, 73, 110, 77, 101, 110, 117,
				65, 116, 116, 114, 105, 98, 117, 116, 101, 0,
				0, 0, 0, 41, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 84, 105, 109, 101,
				108, 105, 110, 101, 124, 67, 117, 115, 116, 111,
				109, 83, 116, 121, 108, 101, 65, 116, 116, 114,
				105, 98, 117, 116, 101, 0, 0, 0, 0, 42,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 84, 105, 109, 101, 108, 105, 110, 101,
				124, 77, 101, 110, 117, 67, 97, 116, 101, 103,
				111, 114, 121, 65, 116, 116, 114, 105, 98, 117,
				116, 101, 0, 0, 0, 0, 39, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 84,
				105, 109, 101, 108, 105, 110, 101, 124, 73, 84,
				105, 109, 101, 108, 105, 110, 101, 67, 108, 105,
				112, 65, 115, 115, 101, 116, 1, 0, 0, 0,
				33, 85, 110, 105, 116, 121, 69, 110, 103, 105,
				110, 101, 46, 84, 105, 109, 101, 108, 105, 110,
				101, 124, 84, 105, 109, 101, 108, 105, 110, 101,
				67, 108, 105, 112, 0, 0, 0, 0, 46, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 84, 105, 109, 101, 108, 105, 110, 101, 124,
				73, 84, 105, 109, 101, 108, 105, 110, 101, 69,
				118, 97, 108, 117, 97, 116, 101, 67, 97, 108,
				108, 98, 97, 99, 107, 0, 0, 0, 0, 37,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 84, 105, 109, 101, 108, 105, 110, 101,
				124, 84, 105, 109, 101, 108, 105, 110, 101, 80,
				108, 97, 121, 97, 98, 108, 101, 1, 0, 0,
				0, 31, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 84, 105, 109, 101, 108, 105,
				110, 101, 124, 84, 114, 97, 99, 107, 65, 115,
				115, 101, 116, 0, 0, 0, 0, 50, 85, 110,
				105, 116, 121, 69, 110, 103, 105, 110, 101, 46,
				84, 105, 109, 101, 108, 105, 110, 101, 46, 84,
				114, 97, 99, 107, 65, 115, 115, 101, 116, 124,
				84, 114, 97, 110, 115, 105, 101, 110, 116, 66,
				117, 105, 108, 100, 68, 97, 116, 97, 0, 0,
				0, 0, 34, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 124, 69, 120, 116, 114, 97, 112,
				111, 108, 97, 116, 105, 111, 110, 0, 0, 0,
				0, 32, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 84, 105, 109, 101, 108, 105,
				110, 101, 124, 72, 97, 115, 104, 85, 116, 105,
				108, 105, 116, 121, 0, 0, 0, 0, 39, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 84, 105, 109, 101, 108, 105, 110, 101, 124,
				73, 80, 114, 111, 112, 101, 114, 116, 121, 67,
				111, 108, 108, 101, 99, 116, 111, 114, 0, 0,
				0, 0, 37, 85, 110, 105, 116, 121, 69, 110,
				103, 105, 110, 101, 46, 84, 105, 109, 101, 108,
				105, 110, 101, 124, 73, 80, 114, 111, 112, 101,
				114, 116, 121, 80, 114, 101, 118, 105, 101, 119,
				0, 0, 0, 0, 42, 85, 110, 105, 116, 121,
				69, 110, 103, 105, 110, 101, 46, 84, 105, 109,
				101, 108, 105, 110, 101, 124, 78, 111, 116, 105,
				102, 105, 99, 97, 116, 105, 111, 110, 85, 116,
				105, 108, 105, 116, 105, 101, 115, 0, 0, 0,
				0, 43, 85, 110, 105, 116, 121, 69, 110, 103,
				105, 110, 101, 46, 84, 105, 109, 101, 108, 105,
				110, 101, 124, 84, 105, 109, 101, 108, 105, 110,
				101, 67, 108, 105, 112, 69, 120, 116, 101, 110,
				115, 105, 111, 110, 115, 0, 0, 0, 0, 44,
				85, 110, 105, 116, 121, 69, 110, 103, 105, 110,
				101, 46, 84, 105, 109, 101, 108, 105, 110, 101,
				124, 84, 105, 109, 101, 108, 105, 110, 101, 67,
				114, 101, 97, 116, 101, 85, 116, 105, 108, 105,
				116, 105, 101, 115, 0, 0, 0, 0, 33, 85,
				110, 105, 116, 121, 69, 110, 103, 105, 110, 101,
				46, 84, 105, 109, 101, 108, 105, 110, 101, 124,
				84, 105, 109, 101, 108, 105, 110, 101, 85, 110,
				100, 111, 0, 0, 0, 0, 32, 85, 110, 105,
				116, 121, 69, 110, 103, 105, 110, 101, 46, 84,
				105, 109, 101, 108, 105, 110, 101, 124, 84, 105,
				109, 101, 85, 116, 105, 108, 105, 116, 121, 0,
				0, 0, 0, 34, 85, 110, 105, 116, 121, 69,
				110, 103, 105, 110, 101, 46, 84, 105, 109, 101,
				108, 105, 110, 101, 124, 87, 101, 105, 103, 104,
				116, 85, 116, 105, 108, 105, 116, 121
			},
			TotalFiles = 68,
			TotalTypes = 94,
			IsEditorOnly = false
		};
	}
}
namespace UnityEngine.Timeline;

internal class ActivationMixerPlayable : PlayableBehaviour
{
	private ActivationTrack.PostPlaybackState m_PostPlaybackState;

	private bool m_BoundGameObjectInitialStateIsActive;

	private GameObject m_BoundGameObject;

	public ActivationTrack.PostPlaybackState postPlaybackState
	{
		get
		{
			return m_PostPlaybackState;
		}
		set
		{
			m_PostPlaybackState = value;
		}
	}

	public static ScriptPlayable<ActivationMixerPlayable> Create(PlayableGraph graph, int inputCount)
	{
		return ScriptPlayable<ActivationMixerPlayable>.Create(graph, inputCount);
	}

	public override void OnPlayableDestroy(Playable playable)
	{
		if (!(m_BoundGameObject == null))
		{
			switch (m_PostPlaybackState)
			{
			case ActivationTrack.PostPlaybackState.Active:
				m_BoundGameObject.SetActive(value: true);
				break;
			case ActivationTrack.PostPlaybackState.Inactive:
				m_BoundGameObject.SetActive(value: false);
				break;
			case ActivationTrack.PostPlaybackState.Revert:
				m_BoundGameObject.SetActive(m_BoundGameObjectInitialStateIsActive);
				break;
			case ActivationTrack.PostPlaybackState.LeaveAsIs:
				break;
			}
		}
	}

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		if (m_BoundGameObject == null)
		{
			m_BoundGameObject = playerData as GameObject;
			m_BoundGameObjectInitialStateIsActive = m_BoundGameObject != null && m_BoundGameObject.activeSelf;
		}
		if (m_BoundGameObject == null)
		{
			return;
		}
		int inputCount = playable.GetInputCount();
		bool active = false;
		for (int i = 0; i < inputCount; i++)
		{
			if (playable.GetInputWeight(i) > 0f)
			{
				active = true;
				break;
			}
		}
		m_BoundGameObject.SetActive(active);
	}
}
internal class ActivationPlayableAsset : PlayableAsset, ITimelineClipAsset
{
	public ClipCaps clipCaps => ClipCaps.None;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject go)
	{
		return Playable.Create(graph);
	}
}
[Serializable]
[TrackClipType(typeof(ActivationPlayableAsset))]
[TrackBindingType(typeof(GameObject))]
[ExcludeFromPreset]
public class ActivationTrack : TrackAsset
{
	public enum PostPlaybackState
	{
		Active,
		Inactive,
		Revert,
		LeaveAsIs
	}

	[SerializeField]
	private PostPlaybackState m_PostPlaybackState = PostPlaybackState.LeaveAsIs;

	private ActivationMixerPlayable m_ActivationMixer;

	public PostPlaybackState postPlaybackState
	{
		get
		{
			return m_PostPlaybackState;
		}
		set
		{
			m_PostPlaybackState = value;
			UpdateTrackMode();
		}
	}

	internal override bool CanCompileClips()
	{
		if (base.hasClips)
		{
			return base.CanCompileClips();
		}
		return true;
	}

	public override Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		ScriptPlayable<ActivationMixerPlayable> scriptPlayable = ActivationMixerPlayable.Create(graph, inputCount);
		m_ActivationMixer = scriptPlayable.GetBehaviour();
		UpdateTrackMode();
		return scriptPlayable;
	}

	internal void UpdateTrackMode()
	{
		if (m_ActivationMixer != null)
		{
			m_ActivationMixer.postPlaybackState = m_PostPlaybackState;
		}
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		GameObject gameObjectBinding = GetGameObjectBinding(director);
		if (gameObjectBinding != null)
		{
			driver.AddFromName(gameObjectBinding, "m_IsActive");
		}
	}

	protected override void OnCreateClip(TimelineClip clip)
	{
		clip.displayName = "Active";
		base.OnCreateClip(clip);
	}
}
internal class AnimationOutputWeightProcessor : ITimelineEvaluateCallback
{
	private struct WeightInfo
	{
		public Playable mixer;

		public Playable parentMixer;

		public int port;
	}

	private AnimationPlayableOutput m_Output;

	private AnimationMotionXToDeltaPlayable m_MotionXPlayable;

	private readonly List<WeightInfo> m_Mixers = new List<WeightInfo>();

	public AnimationOutputWeightProcessor(AnimationPlayableOutput output)
	{
		m_Output = output;
		output.SetWeight(0f);
		FindMixers();
	}

	private void FindMixers()
	{
		Playable sourcePlayable = m_Output.GetSourcePlayable();
		int sourceOutputPort = m_Output.GetSourceOutputPort();
		m_Mixers.Clear();
		FindMixers(sourcePlayable, sourceOutputPort, sourcePlayable.GetInput(sourceOutputPort));
	}

	private void FindMixers(Playable parent, int port, Playable node)
	{
		if (!node.IsValid())
		{
			return;
		}
		Type playableType = node.GetPlayableType();
		if (playableType == typeof(AnimationMixerPlayable) || playableType == typeof(AnimationLayerMixerPlayable))
		{
			int inputCount = node.GetInputCount();
			for (int i = 0; i < inputCount; i++)
			{
				FindMixers(node, i, node.GetInput(i));
			}
			WeightInfo item = new WeightInfo
			{
				parentMixer = parent,
				mixer = node,
				port = port
			};
			m_Mixers.Add(item);
		}
		else
		{
			int inputCount2 = node.GetInputCount();
			for (int j = 0; j < inputCount2; j++)
			{
				FindMixers(parent, port, node.GetInput(j));
			}
		}
	}

	public void Evaluate()
	{
		float num = 1f;
		m_Output.SetWeight(1f);
		for (int i = 0; i < m_Mixers.Count; i++)
		{
			WeightInfo weightInfo = m_Mixers[i];
			num = WeightUtility.NormalizeMixer(weightInfo.mixer);
			weightInfo.parentMixer.SetInputWeight(weightInfo.port, num);
		}
		if (Application.isPlaying)
		{
			m_Output.SetWeight(num);
		}
	}
}
[Serializable]
[NotKeyable]
public class AnimationPlayableAsset : PlayableAsset, ITimelineClipAsset, IPropertyPreview, ISerializationCallbackReceiver
{
	public enum LoopMode
	{
		[Tooltip("Use the loop time setting from the source AnimationClip.")]
		UseSourceAsset,
		[Tooltip("The source AnimationClip loops during playback.")]
		On,
		[Tooltip("The source AnimationClip does not loop during playback.")]
		Off
	}

	private enum Versions
	{
		Initial,
		RotationAsEuler
	}

	private static class AnimationPlayableAssetUpgrade
	{
		public static void ConvertRotationToEuler(AnimationPlayableAsset asset)
		{
			asset.m_EulerAngles = asset.m_Rotation.eulerAngles;
		}
	}

	[SerializeField]
	private AnimationClip m_Clip;

	[SerializeField]
	private Vector3 m_Position = Vector3.zero;

	[SerializeField]
	private Vector3 m_EulerAngles = Vector3.zero;

	[SerializeField]
	private bool m_UseTrackMatchFields = true;

	[SerializeField]
	private MatchTargetFields m_MatchTargetFields = MatchTargetFieldConstants.All;

	[SerializeField]
	private bool m_RemoveStartOffset = true;

	[SerializeField]
	private bool m_ApplyFootIK = true;

	[SerializeField]
	private LoopMode m_Loop;

	private static readonly int k_LatestVersion = 1;

	[SerializeField]
	[HideInInspector]
	private int m_Version;

	[SerializeField]
	[Obsolete("Use m_RotationEuler Instead", false)]
	[HideInInspector]
	private Quaternion m_Rotation = Quaternion.identity;

	public Vector3 position
	{
		get
		{
			return m_Position;
		}
		set
		{
			m_Position = value;
		}
	}

	public Quaternion rotation
	{
		get
		{
			return Quaternion.Euler(m_EulerAngles);
		}
		set
		{
			m_EulerAngles = value.eulerAngles;
		}
	}

	public Vector3 eulerAngles
	{
		get
		{
			return m_EulerAngles;
		}
		set
		{
			m_EulerAngles = value;
		}
	}

	public bool useTrackMatchFields
	{
		get
		{
			return m_UseTrackMatchFields;
		}
		set
		{
			m_UseTrackMatchFields = value;
		}
	}

	public MatchTargetFields matchTargetFields
	{
		get
		{
			return m_MatchTargetFields;
		}
		set
		{
			m_MatchTargetFields = value;
		}
	}

	public bool removeStartOffset
	{
		get
		{
			return m_RemoveStartOffset;
		}
		set
		{
			m_RemoveStartOffset = value;
		}
	}

	public bool applyFootIK
	{
		get
		{
			return m_ApplyFootIK;
		}
		set
		{
			m_ApplyFootIK = value;
		}
	}

	public LoopMode loop
	{
		get
		{
			return m_Loop;
		}
		set
		{
			m_Loop = value;
		}
	}

	internal bool hasRootTransforms
	{
		get
		{
			if (m_Clip != null)
			{
				return HasRootTransforms(m_Clip);
			}
			return false;
		}
	}

	internal AppliedOffsetMode appliedOffsetMode { get; set; }

	public AnimationClip clip
	{
		get
		{
			return m_Clip;
		}
		set
		{
			if (value != null)
			{
				base.name = "AnimationPlayableAsset of " + value.name;
			}
			m_Clip = value;
		}
	}

	public override double duration
	{
		get
		{
			double animationClipLength = TimeUtility.GetAnimationClipLength(clip);
			if (animationClipLength < 1.401298464324817E-45)
			{
				return base.duration;
			}
			return animationClipLength;
		}
	}

	public override IEnumerable<PlayableBinding> outputs
	{
		get
		{
			yield return AnimationPlayableBinding.Create(base.name, this);
		}
	}

	public ClipCaps clipCaps
	{
		get
		{
			ClipCaps clipCaps = ClipCaps.Extrapolation | ClipCaps.SpeedMultiplier | ClipCaps.Blending;
			if (m_Clip != null && m_Loop != LoopMode.Off && (m_Loop != LoopMode.UseSourceAsset || m_Clip.isLooping))
			{
				clipCaps |= ClipCaps.Looping;
			}
			if (m_Clip != null && !m_Clip.empty)
			{
				clipCaps |= ClipCaps.ClipIn;
			}
			return clipCaps;
		}
	}

	public override Playable CreatePlayable(PlayableGraph graph, GameObject go)
	{
		return CreatePlayable(graph, m_Clip, position, eulerAngles, removeStartOffset, appliedOffsetMode, applyFootIK, m_Loop);
	}

	internal static Playable CreatePlayable(PlayableGraph graph, AnimationClip clip, Vector3 positionOffset, Vector3 eulerOffset, bool removeStartOffset, AppliedOffsetMode mode, bool applyFootIK, LoopMode loop)
	{
		if (clip == null || clip.legacy)
		{
			return Playable.Null;
		}
		AnimationClipPlayable animationClipPlayable = AnimationClipPlayable.Create(graph, clip);
		animationClipPlayable.SetRemoveStartOffset(removeStartOffset);
		animationClipPlayable.SetApplyFootIK(applyFootIK);
		animationClipPlayable.SetOverrideLoopTime(loop != LoopMode.UseSourceAsset);
		animationClipPlayable.SetLoopTime(loop == LoopMode.On);
		Playable playable = animationClipPlayable;
		if (ShouldApplyScaleRemove(mode))
		{
			AnimationRemoveScalePlayable animationRemoveScalePlayable = AnimationRemoveScalePlayable.Create(graph, 1);
			graph.Connect(playable, 0, animationRemoveScalePlayable, 0);
			animationRemoveScalePlayable.SetInputWeight(0, 1f);
			playable = animationRemoveScalePlayable;
		}
		if (ShouldApplyOffset(mode, clip))
		{
			AnimationOffsetPlayable animationOffsetPlayable = AnimationOffsetPlayable.Create(graph, positionOffset, Quaternion.Euler(eulerOffset), 1);
			graph.Connect(playable, 0, animationOffsetPlayable, 0);
			animationOffsetPlayable.SetInputWeight(0, 1f);
			playable = animationOffsetPlayable;
		}
		return playable;
	}

	private static bool ShouldApplyOffset(AppliedOffsetMode mode, AnimationClip clip)
	{
		if (mode == AppliedOffsetMode.NoRootTransform || mode == AppliedOffsetMode.SceneOffsetLegacy)
		{
			return false;
		}
		return HasRootTransforms(clip);
	}

	private static bool ShouldApplyScaleRemove(AppliedOffsetMode mode)
	{
		if (mode != AppliedOffsetMode.SceneOffsetLegacyEditor && mode != AppliedOffsetMode.SceneOffsetLegacy)
		{
			return mode == AppliedOffsetMode.TransformOffsetLegacy;
		}
		return true;
	}

	public void ResetOffsets()
	{
		position = Vector3.zero;
		eulerAngles = Vector3.zero;
	}

	public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		driver.AddFromClip(m_Clip);
	}

	internal static bool HasRootTransforms(AnimationClip clip)
	{
		if (clip == null || clip.empty)
		{
			return false;
		}
		if (!clip.hasRootMotion && !clip.hasGenericRootTransform && !clip.hasMotionCurves)
		{
			return clip.hasRootCurves;
		}
		return true;
	}

	void ISerializationCallbackReceiver.OnBeforeSerialize()
	{
		m_Version = k_LatestVersion;
	}

	void ISerializationCallbackReceiver.OnAfterDeserialize()
	{
		if (m_Version < k_LatestVersion)
		{
			OnUpgradeFromVersion(m_Version);
		}
	}

	private void OnUpgradeFromVersion(int oldVersion)
	{
		if (oldVersion < 1)
		{
			AnimationPlayableAssetUpgrade.ConvertRotationToEuler(this);
		}
	}
}
internal class AnimationPreviewUpdateCallback : ITimelineEvaluateCallback
{
	private AnimationPlayableOutput m_Output;

	private PlayableGraph m_Graph;

	private List<IAnimationWindowPreview> m_PreviewComponents;

	public AnimationPreviewUpdateCallback(AnimationPlayableOutput output)
	{
		m_Output = output;
		Playable sourcePlayable = m_Output.GetSourcePlayable();
		if (sourcePlayable.IsValid())
		{
			m_Graph = sourcePlayable.GetGraph();
		}
	}

	public void Evaluate()
	{
		if (!m_Graph.IsValid())
		{
			return;
		}
		if (m_PreviewComponents == null)
		{
			FetchPreviewComponents();
		}
		foreach (IAnimationWindowPreview previewComponent in m_PreviewComponents)
		{
			previewComponent?.UpdatePreviewGraph(m_Graph);
		}
	}

	private void FetchPreviewComponents()
	{
		m_PreviewComponents = new List<IAnimationWindowPreview>();
		Animator target = m_Output.GetTarget();
		if (!(target == null))
		{
			GameObject gameObject = target.gameObject;
			m_PreviewComponents.AddRange(gameObject.GetComponents<IAnimationWindowPreview>());
		}
	}
}
[Flags]
public enum MatchTargetFields
{
	PositionX = 1,
	PositionY = 2,
	PositionZ = 4,
	RotationX = 8,
	RotationY = 0x10,
	RotationZ = 0x20
}
public enum TrackOffset
{
	ApplyTransformOffsets,
	ApplySceneOffsets,
	Auto
}
internal enum AppliedOffsetMode
{
	NoRootTransform,
	TransformOffset,
	SceneOffset,
	TransformOffsetLegacy,
	SceneOffsetLegacy,
	SceneOffsetEditor,
	SceneOffsetLegacyEditor
}
internal static class MatchTargetFieldConstants
{
	public static MatchTargetFields All = MatchTargetFields.PositionX | MatchTargetFields.PositionY | MatchTargetFields.PositionZ | MatchTargetFields.RotationX | MatchTargetFields.RotationY | MatchTargetFields.RotationZ;

	public static MatchTargetFields None = (MatchTargetFields)0;

	public static MatchTargetFields Position = MatchTargetFields.PositionX | MatchTargetFields.PositionY | MatchTargetFields.PositionZ;

	public static MatchTargetFields Rotation = MatchTargetFields.RotationX | MatchTargetFields.RotationY | MatchTargetFields.RotationZ;

	public static bool HasAny(this MatchTargetFields me, MatchTargetFields fields)
	{
		return (me & fields) != None;
	}

	public static MatchTargetFields Toggle(this MatchTargetFields me, MatchTargetFields flag)
	{
		return me ^ flag;
	}
}
[Serializable]
[TrackClipType(typeof(AnimationPlayableAsset), false)]
[TrackBindingType(typeof(Animator))]
[ExcludeFromPreset]
public class AnimationTrack : TrackAsset, ILayerable
{
	private static class AnimationTrackUpgrade
	{
		public static void ConvertRotationsToEuler(AnimationTrack track)
		{
			track.m_EulerAngles = track.m_Rotation.eulerAngles;
			track.m_InfiniteClipOffsetEulerAngles = track.m_OpenClipOffsetRotation.eulerAngles;
		}

		public static void ConvertRootMotion(AnimationTrack track)
		{
			track.m_TrackOffset = TrackOffset.Auto;
			if (!track.m_ApplyOffsets)
			{
				track.m_Position = Vector3.zero;
				track.m_EulerAngles = Vector3.zero;
			}
		}

		public static void ConvertInfiniteTrack(AnimationTrack track)
		{
			track.m_InfiniteClip = track.m_AnimClip;
			track.m_AnimClip = null;
		}
	}

	private const string k_DefaultInfiniteClipName = "Recorded";

	private const string k_DefaultRecordableClipName = "Recorded";

	[SerializeField]
	[FormerlySerializedAs("m_OpenClipPreExtrapolation")]
	private TimelineClip.ClipExtrapolation m_InfiniteClipPreExtrapolation;

	[SerializeField]
	[FormerlySerializedAs("m_OpenClipPostExtrapolation")]
	private TimelineClip.ClipExtrapolation m_InfiniteClipPostExtrapolation;

	[SerializeField]
	[FormerlySerializedAs("m_OpenClipOffsetPosition")]
	private Vector3 m_InfiniteClipOffsetPosition = Vector3.zero;

	[SerializeField]
	[FormerlySerializedAs("m_OpenClipOffsetEulerAngles")]
	private Vector3 m_InfiniteClipOffsetEulerAngles = Vector3.zero;

	[SerializeField]
	[FormerlySerializedAs("m_OpenClipTimeOffset")]
	private double m_InfiniteClipTimeOffset;

	[SerializeField]
	[FormerlySerializedAs("m_OpenClipRemoveOffset")]
	private bool m_InfiniteClipRemoveOffset;

	[SerializeField]
	private bool m_InfiniteClipApplyFootIK = true;

	[SerializeField]
	[HideInInspector]
	private AnimationPlayableAsset.LoopMode mInfiniteClipLoop;

	[SerializeField]
	private MatchTargetFields m_MatchTargetFields = MatchTargetFieldConstants.All;

	[SerializeField]
	private Vector3 m_Position = Vector3.zero;

	[SerializeField]
	private Vector3 m_EulerAngles = Vector3.zero;

	[SerializeField]
	private AvatarMask m_AvatarMask;

	[SerializeField]
	private bool m_ApplyAvatarMask = true;

	[SerializeField]
	private TrackOffset m_TrackOffset;

	[SerializeField]
	[HideInInspector]
	private AnimationClip m_InfiniteClip;

	private static readonly Queue<Transform> s_CachedQueue = new Queue<Transform>(100);

	[SerializeField]
	[Obsolete("Use m_InfiniteClipOffsetEulerAngles Instead", false)]
	[HideInInspector]
	private Quaternion m_OpenClipOffsetRotation = Quaternion.identity;

	[SerializeField]
	[Obsolete("Use m_RotationEuler Instead", false)]
	[HideInInspector]
	private Quaternion m_Rotation = Quaternion.identity;

	[SerializeField]
	[Obsolete("Use m_RootTransformOffsetMode", false)]
	[HideInInspector]
	private bool m_ApplyOffsets;

	public Vector3 position
	{
		get
		{
			return m_Position;
		}
		set
		{
			m_Position = value;
		}
	}

	public Quaternion rotation
	{
		get
		{
			return Quaternion.Euler(m_EulerAngles);
		}
		set
		{
			m_EulerAngles = value.eulerAngles;
		}
	}

	public Vector3 eulerAngles
	{
		get
		{
			return m_EulerAngles;
		}
		set
		{
			m_EulerAngles = value;
		}
	}

	[Obsolete("applyOffset is deprecated. Use trackOffset instead", true)]
	public bool applyOffsets
	{
		get
		{
			return false;
		}
		set
		{
		}
	}

	public TrackOffset trackOffset
	{
		get
		{
			return m_TrackOffset;
		}
		set
		{
			m_TrackOffset = value;
		}
	}

	public MatchTargetFields matchTargetFields
	{
		get
		{
			return m_MatchTargetFields;
		}
		set
		{
			m_MatchTargetFields = value & MatchTargetFieldConstants.All;
		}
	}

	public AnimationClip infiniteClip
	{
		get
		{
			return m_InfiniteClip;
		}
		internal set
		{
			m_InfiniteClip = value;
		}
	}

	internal bool infiniteClipRemoveOffset
	{
		get
		{
			return m_InfiniteClipRemoveOffset;
		}
		set
		{
			m_InfiniteClipRemoveOffset = value;
		}
	}

	public AvatarMask avatarMask
	{
		get
		{
			return m_AvatarMask;
		}
		set
		{
			m_AvatarMask = value;
		}
	}

	public bool applyAvatarMask
	{
		get
		{
			return m_ApplyAvatarMask;
		}
		set
		{
			m_ApplyAvatarMask = value;
		}
	}

	public override IEnumerable<PlayableBinding> outputs
	{
		get
		{
			yield return AnimationPlayableBinding.Create(base.name, this);
		}
	}

	public bool inClipMode
	{
		get
		{
			if (base.clips != null)
			{
				return base.clips.Length != 0;
			}
			return false;
		}
	}

	public Vector3 infiniteClipOffsetPosition
	{
		get
		{
			return m_InfiniteClipOffsetPosition;
		}
		set
		{
			m_InfiniteClipOffsetPosition = value;
		}
	}

	public Quaternion infiniteClipOffsetRotation
	{
		get
		{
			return Quaternion.Euler(m_InfiniteClipOffsetEulerAngles);
		}
		set
		{
			m_InfiniteClipOffsetEulerAngles = value.eulerAngles;
		}
	}

	public Vector3 infiniteClipOffsetEulerAngles
	{
		get
		{
			return m_InfiniteClipOffsetEulerAngles;
		}
		set
		{
			m_InfiniteClipOffsetEulerAngles = value;
		}
	}

	internal bool infiniteClipApplyFootIK
	{
		get
		{
			return m_InfiniteClipApplyFootIK;
		}
		set
		{
			m_InfiniteClipApplyFootIK = value;
		}
	}

	internal double infiniteClipTimeOffset
	{
		get
		{
			return m_InfiniteClipTimeOffset;
		}
		set
		{
			m_InfiniteClipTimeOffset = value;
		}
	}

	public TimelineClip.ClipExtrapolation infiniteClipPreExtrapolation
	{
		get
		{
			return m_InfiniteClipPreExtrapolation;
		}
		set
		{
			m_InfiniteClipPreExtrapolation = value;
		}
	}

	public TimelineClip.ClipExtrapolation infiniteClipPostExtrapolation
	{
		get
		{
			return m_InfiniteClipPostExtrapolation;
		}
		set
		{
			m_InfiniteClipPostExtrapolation = value;
		}
	}

	internal AnimationPlayableAsset.LoopMode infiniteClipLoop
	{
		get
		{
			return mInfiniteClipLoop;
		}
		set
		{
			mInfiniteClipLoop = value;
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[Obsolete("openClipOffsetPosition has been deprecated. Use infiniteClipOffsetPosition instead. (UnityUpgradable) -> infiniteClipOffsetPosition", true)]
	public Vector3 openClipOffsetPosition
	{
		get
		{
			return infiniteClipOffsetPosition;
		}
		set
		{
			infiniteClipOffsetPosition = value;
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[Obsolete("openClipOffsetRotation has been deprecated. Use infiniteClipOffsetRotation instead. (UnityUpgradable) -> infiniteClipOffsetRotation", true)]
	public Quaternion openClipOffsetRotation
	{
		get
		{
			return infiniteClipOffsetRotation;
		}
		set
		{
			infiniteClipOffsetRotation = value;
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[Obsolete("openClipOffsetEulerAngles has been deprecated. Use infiniteClipOffsetEulerAngles instead. (UnityUpgradable) -> infiniteClipOffsetEulerAngles", true)]
	public Vector3 openClipOffsetEulerAngles
	{
		get
		{
			return infiniteClipOffsetEulerAngles;
		}
		set
		{
			infiniteClipOffsetEulerAngles = value;
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[Obsolete("openClipPreExtrapolation has been deprecated. Use infiniteClipPreExtrapolation instead. (UnityUpgradable) -> infiniteClipPreExtrapolation", true)]
	public TimelineClip.ClipExtrapolation openClipPreExtrapolation
	{
		get
		{
			return infiniteClipPreExtrapolation;
		}
		set
		{
			infiniteClipPreExtrapolation = value;
		}
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[Obsolete("openClipPostExtrapolation has been deprecated. Use infiniteClipPostExtrapolation instead. (UnityUpgradable) -> infiniteClipPostExtrapolation", true)]
	public TimelineClip.ClipExtrapolation openClipPostExtrapolation
	{
		get
		{
			return infiniteClipPostExtrapolation;
		}
		set
		{
			infiniteClipPostExtrapolation = value;
		}
	}

	internal override bool CanCompileClips()
	{
		if (!base.muted)
		{
			if (m_Clips.Count <= 0)
			{
				if (m_InfiniteClip != null)
				{
					return !m_InfiniteClip.empty;
				}
				return false;
			}
			return true;
		}
		return false;
	}

	[ContextMenu("Reset Offsets")]
	private void ResetOffsets()
	{
		m_Position = Vector3.zero;
		m_EulerAngles = Vector3.zero;
		UpdateClipOffsets();
	}

	public TimelineClip CreateClip(AnimationClip clip)
	{
		if (clip == null)
		{
			return null;
		}
		TimelineClip timelineClip = CreateClip<AnimationPlayableAsset>();
		AssignAnimationClip(timelineClip, clip);
		return timelineClip;
	}

	public void CreateInfiniteClip(string infiniteClipName)
	{
		if (inClipMode)
		{
			Debug.LogWarning("CreateInfiniteClip cannot create an infinite clip for an AnimationTrack that contains one or more Timeline Clips.");
		}
		else if (!(m_InfiniteClip != null))
		{
			m_InfiniteClip = TimelineCreateUtilities.CreateAnimationClipForTrack(string.IsNullOrEmpty(infiniteClipName) ? "Recorded" : infiniteClipName, this, isLegacy: false);
		}
	}

	public TimelineClip CreateRecordableClip(string animClipName)
	{
		AnimationClip clip = TimelineCreateUtilities.CreateAnimationClipForTrack(string.IsNullOrEmpty(animClipName) ? "Recorded" : animClipName, this, isLegacy: false);
		TimelineClip timelineClip = CreateClip(clip);
		timelineClip.displayName = animClipName;
		timelineClip.recordable = true;
		timelineClip.start = 0.0;
		timelineClip.duration = 1.0;
		AnimationPlayableAsset animationPlayableAsset = timelineClip.asset as AnimationPlayableAsset;
		if (animationPlayableAsset != null)
		{
			animationPlayableAsset.removeStartOffset = false;
		}
		return timelineClip;
	}

	protected override void OnCreateClip(TimelineClip clip)
	{
		TimelineClip.ClipExtrapolation clipExtrapolation = TimelineClip.ClipExtrapolation.None;
		if (!base.isSubTrack)
		{
			clipExtrapolation = TimelineClip.ClipExtrapolation.Hold;
		}
		clip.preExtrapolationMode = clipExtrapolation;
		clip.postExtrapolationMode = clipExtrapolation;
	}

	protected internal override int CalculateItemsHash()
	{
		return TrackAsset.GetAnimationClipHash(m_InfiniteClip).CombineHash(base.CalculateItemsHash());
	}

	internal void UpdateClipOffsets()
	{
	}

	private Playable CompileTrackPlayable(PlayableGraph graph, AnimationTrack track, GameObject go, IntervalTree<RuntimeElement> tree, AppliedOffsetMode mode)
	{
		AnimationMixerPlayable animationMixerPlayable = AnimationMixerPlayable.Create(graph, track.clips.Length);
		for (int i = 0; i < track.clips.Length; i++)
		{
			TimelineClip timelineClip = track.clips[i];
			PlayableAsset playableAsset = timelineClip.asset as PlayableAsset;
			if (!(playableAsset == null))
			{
				AnimationPlayableAsset animationPlayableAsset = playableAsset as AnimationPlayableAsset;
				if (animationPlayableAsset != null)
				{
					animationPlayableAsset.appliedOffsetMode = mode;
				}
				Playable playable = playableAsset.CreatePlayable(graph, go);
				if (playable.IsValid())
				{
					RuntimeClip item = new RuntimeClip(timelineClip, playable, animationMixerPlayable);
					tree.Add(item);
					graph.Connect(playable, 0, animationMixerPlayable, i);
					animationMixerPlayable.SetInputWeight(i, 0f);
				}
			}
		}
		if (!track.AnimatesRootTransform())
		{
			return animationMixerPlayable;
		}
		return ApplyTrackOffset(graph, animationMixerPlayable, go, mode);
	}

	Playable ILayerable.CreateLayerMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return Playable.Null;
	}

	internal override Playable CreateMixerPlayableGraph(PlayableGraph graph, GameObject go, IntervalTree<RuntimeElement> tree)
	{
		if (base.isSubTrack)
		{
			throw new InvalidOperationException("Nested animation tracks should never be asked to create a graph directly");
		}
		List<AnimationTrack> list = new List<AnimationTrack>();
		if (CanCompileClips())
		{
			list.Add(this);
		}
		Transform genericRootNode = GetGenericRootNode(go);
		bool flag = AnimatesRootTransform();
		bool flag2 = flag && !IsRootTransformDisabledByMask(go, genericRootNode);
		foreach (TrackAsset childTrack in GetChildTracks())
		{
			AnimationTrack animationTrack = childTrack as AnimationTrack;
			if (animationTrack != null && animationTrack.CanCompileClips())
			{
				bool flag3 = animationTrack.AnimatesRootTransform();
				flag |= animationTrack.AnimatesRootTransform();
				flag2 |= flag3 && !animationTrack.IsRootTransformDisabledByMask(go, genericRootNode);
				list.Add(animationTrack);
			}
		}
		AppliedOffsetMode offsetMode = GetOffsetMode(go, flag2);
		int defaultBlendCount = GetDefaultBlendCount();
		AnimationLayerMixerPlayable animationLayerMixerPlayable = CreateGroupMixer(graph, go, list.Count + defaultBlendCount);
		for (int i = 0; i < list.Count; i++)
		{
			int num = i + defaultBlendCount;
			AppliedOffsetMode mode = offsetMode;
			if (offsetMode != AppliedOffsetMode.NoRootTransform && list[i].IsRootTransformDisabledByMask(go, genericRootNode))
			{
				mode = AppliedOffsetMode.NoRootTransform;
			}
			Playable source = (list[i].inClipMode ? CompileTrackPlayable(graph, list[i], go, tree, mode) : list[i].CreateInfiniteTrackPlayable(graph, go, tree, mode));
			graph.Connect(source, 0, animationLayerMixerPlayable, num);
			animationLayerMixerPlayable.SetInputWeight(num, (!list[i].inClipMode) ? 1 : 0);
			if (list[i].applyAvatarMask && list[i].avatarMask != null)
			{
				animationLayerMixerPlayable.SetLayerMaskFromAvatarMask((uint)num, list[i].avatarMask);
			}
		}
		bool flag4 = RequiresMotionXPlayable(offsetMode, go);
		flag4 |= defaultBlendCount > 0 && RequiresMotionXPlayable(GetOffsetMode(go, flag), go);
		AttachDefaultBlend(graph, animationLayerMixerPlayable, flag4);
		Playable playable = animationLayerMixerPlayable;
		if (flag4)
		{
			AnimationMotionXToDeltaPlayable animationMotionXToDeltaPlayable = AnimationMotionXToDeltaPlayable.Create(graph);
			graph.Connect(playable, 0, animationMotionXToDeltaPlayable, 0);
			animationMotionXToDeltaPlayable.SetInputWeight(0, 1f);
			animationMotionXToDeltaPlayable.SetAbsoluteMotion(UsesAbsoluteMotion(offsetMode));
			playable = animationMotionXToDeltaPlayable;
		}
		return playable;
	}

	private int GetDefaultBlendCount()
	{
		return 0;
	}

	private void AttachDefaultBlend(PlayableGraph graph, AnimationLayerMixerPlayable mixer, bool requireOffset)
	{
	}

	private Playable AttachOffsetPlayable(PlayableGraph graph, Playable playable, Vector3 pos, Quaternion rot)
	{
		AnimationOffsetPlayable animationOffsetPlayable = AnimationOffsetPlayable.Create(graph, pos, rot, 1);
		animationOffsetPlayable.SetInputWeight(0, 1f);
		graph.Connect(playable, 0, animationOffsetPlayable, 0);
		return animationOffsetPlayable;
	}

	private bool RequiresMotionXPlayable(AppliedOffsetMode mode, GameObject gameObject)
	{
		switch (mode)
		{
		case AppliedOffsetMode.NoRootTransform:
			return false;
		case AppliedOffsetMode.SceneOffsetLegacy:
		{
			Animator binding = GetBinding((gameObject != null) ? gameObject.GetComponent<PlayableDirector>() : null);
			if (binding != null)
			{
				return binding.hasRootMotion;
			}
			return false;
		}
		default:
			return true;
		}
	}

	private static bool UsesAbsoluteMotion(AppliedOffsetMode mode)
	{
		if (mode != AppliedOffsetMode.SceneOffset)
		{
			return mode != AppliedOffsetMode.SceneOffsetLegacy;
		}
		return false;
	}

	private bool HasController(GameObject gameObject)
	{
		Animator binding = GetBinding((gameObject != null) ? gameObject.GetComponent<PlayableDirector>() : null);
		if (binding != null)
		{
			return binding.runtimeAnimatorController != null;
		}
		return false;
	}

	internal Animator GetBinding(PlayableDirector director)
	{
		if (director == null)
		{
			return null;
		}
		Object key = this;
		if (base.isSubTrack)
		{
			key = base.parent;
		}
		Object obj = null;
		if (director != null)
		{
			obj = director.GetGenericBinding(key);
		}
		Animator animator = null;
		if (obj != null)
		{
			animator = obj as Animator;
			GameObject gameObject = obj as GameObject;
			if (animator == null && gameObject != null)
			{
				animator = gameObject.GetComponent<Animator>();
			}
		}
		return animator;
	}

	private static AnimationLayerMixerPlayable CreateGroupMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return AnimationLayerMixerPlayable.Create(graph, inputCount, singleLayerOptimization: false);
	}

	private Playable CreateInfiniteTrackPlayable(PlayableGraph graph, GameObject go, IntervalTree<RuntimeElement> tree, AppliedOffsetMode mode)
	{
		if (m_InfiniteClip == null)
		{
			return Playable.Null;
		}
		AnimationMixerPlayable animationMixerPlayable = AnimationMixerPlayable.Create(graph, 1);
		Playable playable = AnimationPlayableAsset.CreatePlayable(graph, m_InfiniteClip, m_InfiniteClipOffsetPosition, m_InfiniteClipOffsetEulerAngles, removeStartOffset: false, mode, infiniteClipApplyFootIK, AnimationPlayableAsset.LoopMode.Off);
		if (playable.IsValid())
		{
			tree.Add(new InfiniteRuntimeClip(playable));
			graph.Connect(playable, 0, animationMixerPlayable, 0);
			animationMixerPlayable.SetInputWeight(0, 1f);
		}
		if (!AnimatesRootTransform())
		{
			return animationMixerPlayable;
		}
		return (base.isSubTrack ? ((AnimationTrack)base.parent) : this).ApplyTrackOffset(graph, animationMixerPlayable, go, mode);
	}

	private Playable ApplyTrackOffset(PlayableGraph graph, Playable root, GameObject go, AppliedOffsetMode mode)
	{
		if (mode == AppliedOffsetMode.SceneOffsetLegacy || mode == AppliedOffsetMode.SceneOffset || mode == AppliedOffsetMode.NoRootTransform)
		{
			return root;
		}
		Vector3 vector = position;
		Quaternion quaternion = rotation;
		AnimationOffsetPlayable animationOffsetPlayable = AnimationOffsetPlayable.Create(graph, vector, quaternion, 1);
		graph.Connect(root, 0, animationOffsetPlayable, 0);
		animationOffsetPlayable.SetInputWeight(0, 1f);
		return animationOffsetPlayable;
	}

	internal override void GetEvaluationTime(out double outStart, out double outDuration)
	{
		if (inClipMode)
		{
			base.GetEvaluationTime(out outStart, out outDuration);
			return;
		}
		outStart = 0.0;
		outDuration = TimelineClip.kMaxTimeValue;
	}

	internal override void GetSequenceTime(out double outStart, out double outDuration)
	{
		if (inClipMode)
		{
			base.GetSequenceTime(out outStart, out outDuration);
			return;
		}
		outStart = 0.0;
		outDuration = Math.Max(GetNotificationDuration(), TimeUtility.GetAnimationClipLength(m_InfiniteClip));
	}

	private void AssignAnimationClip(TimelineClip clip, AnimationClip animClip)
	{
		if (clip == null || animClip == null)
		{
			return;
		}
		if (animClip.legacy)
		{
			throw new InvalidOperationException("Legacy Animation Clips are not supported");
		}
		AnimationPlayableAsset animationPlayableAsset = clip.asset as AnimationPlayableAsset;
		if (animationPlayableAsset != null)
		{
			animationPlayableAsset.clip = animClip;
			animationPlayableAsset.name = animClip.name;
			double num = animationPlayableAsset.duration;
			if (!double.IsInfinity(num) && num >= TimelineClip.kMinDuration && num < TimelineClip.kMaxTimeValue)
			{
				clip.duration = num;
			}
		}
		clip.displayName = animClip.name;
	}

	public override void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
	}

	private void GetAnimationClips(List<AnimationClip> animClips)
	{
		TimelineClip[] array = base.clips;
		for (int i = 0; i < array.Length; i++)
		{
			AnimationPlayableAsset animationPlayableAsset = array[i].asset as AnimationPlayableAsset;
			if (animationPlayableAsset != null && animationPlayableAsset.clip != null)
			{
				animClips.Add(animationPlayableAsset.clip);
			}
		}
		if (m_InfiniteClip != null)
		{
			animClips.Add(m_InfiniteClip);
		}
		foreach (TrackAsset childTrack in GetChildTracks())
		{
			AnimationTrack animationTrack = childTrack as AnimationTrack;
			if (animationTrack != null)
			{
				animationTrack.GetAnimationClips(animClips);
			}
		}
	}

	private AppliedOffsetMode GetOffsetMode(GameObject go, bool animatesRootTransform)
	{
		if (!animatesRootTransform)
		{
			return AppliedOffsetMode.NoRootTransform;
		}
		if (m_TrackOffset == TrackOffset.ApplyTransformOffsets)
		{
			return AppliedOffsetMode.TransformOffset;
		}
		if (m_TrackOffset == TrackOffset.ApplySceneOffsets)
		{
			if (!Application.isPlaying)
			{
				return AppliedOffsetMode.SceneOffsetEditor;
			}
			return AppliedOffsetMode.SceneOffset;
		}
		if (HasController(go))
		{
			if (!Application.isPlaying)
			{
				return AppliedOffsetMode.SceneOffsetLegacyEditor;
			}
			return AppliedOffsetMode.SceneOffsetLegacy;
		}
		return AppliedOffsetMode.TransformOffsetLegacy;
	}

	private bool IsRootTransformDisabledByMask(GameObject gameObject, Transform genericRootNode)
	{
		if (avatarMask == null || !applyAvatarMask)
		{
			return false;
		}
		Animator binding = GetBinding((gameObject != null) ? gameObject.GetComponent<PlayableDirector>() : null);
		if (binding == null)
		{
			return false;
		}
		if (binding.isHuman)
		{
			return !avatarMask.GetHumanoidBodyPartActive(AvatarMaskBodyPart.Root);
		}
		if (avatarMask.transformCount == 0)
		{
			return false;
		}
		if (genericRootNode == null)
		{
			if (string.IsNullOrEmpty(avatarMask.GetTransformPath(0)))
			{
				return !avatarMask.GetTransformActive(0);
			}
			return false;
		}
		for (int i = 0; i < avatarMask.transformCount; i++)
		{
			if (genericRootNode == binding.transform.Find(avatarMask.GetTransformPath(i)))
			{
				return !avatarMask.GetTransformActive(i);
			}
		}
		return false;
	}

	private Transform GetGenericRootNode(GameObject gameObject)
	{
		Animator binding = GetBinding((gameObject != null) ? gameObject.GetComponent<PlayableDirector>() : null);
		if (binding == null)
		{
			return null;
		}
		if (binding.isHuman)
		{
			return null;
		}
		if (binding.avatar == null)
		{
			return null;
		}
		string rootMotionBoneName = binding.avatar.humanDescription.m_RootMotionBoneName;
		if (rootMotionBoneName == binding.name || string.IsNullOrEmpty(rootMotionBoneName))
		{
			return null;
		}
		return FindInHierarchyBreadthFirst(binding.transform, rootMotionBoneName);
	}

	internal bool AnimatesRootTransform()
	{
		if (AnimationPlayableAsset.HasRootTransforms(m_InfiniteClip))
		{
			return true;
		}
		foreach (TimelineClip clip in GetClips())
		{
			AnimationPlayableAsset animationPlayableAsset = clip.asset as AnimationPlayableAsset;
			if (animationPlayableAsset != null && animationPlayableAsset.hasRootTransforms)
			{
				return true;
			}
		}
		return false;
	}

	private static Transform FindInHierarchyBreadthFirst(Transform t, string name)
	{
		s_CachedQueue.Clear();
		s_CachedQueue.Enqueue(t);
		while (s_CachedQueue.Count > 0)
		{
			Transform transform = s_CachedQueue.Dequeue();
			if (transform.name == name)
			{
				return transform;
			}
			for (int i = 0; i < transform.childCount; i++)
			{
				s_CachedQueue.Enqueue(transform.GetChild(i));
			}
		}
		return null;
	}

	internal override void OnUpgradeFromVersion(int oldVersion)
	{
		if (oldVersion < 1)
		{
			AnimationTrackUpgrade.ConvertRotationsToEuler(this);
		}
		if (oldVersion < 2)
		{
			AnimationTrackUpgrade.ConvertRootMotion(this);
		}
		if (oldVersion < 3)
		{
			AnimationTrackUpgrade.ConvertInfiniteTrack(this);
		}
	}
}
internal interface ICurvesOwner
{
	AnimationClip curves { get; }

	bool hasCurves { get; }

	double duration { get; }

	string defaultCurvesName { get; }

	Object asset { get; }

	Object assetOwner { get; }

	TrackAsset targetTrack { get; }

	void CreateCurves(string curvesClipName);
}
[Serializable]
public class TimelineClip : ICurvesOwner, ISerializationCallbackReceiver
{
	private enum Versions
	{
		Initial,
		ClipInFromGlobalToLocal
	}

	private static class TimelineClipUpgrade
	{
		public static void UpgradeClipInFromGlobalToLocal(TimelineClip clip)
		{
			if (clip.m_ClipIn > 0.0 && clip.m_TimeScale > 1.401298464324817E-45)
			{
				clip.m_ClipIn *= clip.m_TimeScale;
			}
		}
	}

	public enum ClipExtrapolation
	{
		None,
		Hold,
		Loop,
		PingPong,
		Continue
	}

	public enum BlendCurveMode
	{
		Auto,
		Manual
	}

	private const int k_LatestVersion = 1;

	[SerializeField]
	[HideInInspector]
	private int m_Version;

	public static readonly ClipCaps kDefaultClipCaps = ClipCaps.Blending;

	public static readonly float kDefaultClipDurationInSeconds = 5f;

	public static readonly double kTimeScaleMin = 0.001;

	public static readonly double kTimeScaleMax = 1000.0;

	internal static readonly string kDefaultCurvesName = "Clip Parameters";

	internal static readonly double kMinDuration = 1.0 / 60.0;

	internal static readonly double kMaxTimeValue = 1000000.0;

	[SerializeField]
	private double m_Start;

	[SerializeField]
	private double m_ClipIn;

	[SerializeField]
	private Object m_Asset;

	[SerializeField]
	[FormerlySerializedAs("m_HackDuration")]
	private double m_Duration;

	[SerializeField]
	private double m_TimeScale = 1.0;

	[SerializeField]
	private TrackAsset m_ParentTrack;

	[SerializeField]
	private double m_EaseInDuration;

	[SerializeField]
	private double m_EaseOutDuration;

	[SerializeField]
	private double m_BlendInDuration = -1.0;

	[SerializeField]
	private double m_BlendOutDuration = -1.0;

	[SerializeField]
	private AnimationCurve m_MixInCurve;

	[SerializeField]
	private AnimationCurve m_MixOutCurve;

	[SerializeField]
	private BlendCurveMode m_BlendInCurveMode;

	[SerializeField]
	private BlendCurveMode m_BlendOutCurveMode;

	[SerializeField]
	private List<string> m_ExposedParameterNames;

	[SerializeField]
	private AnimationClip m_AnimationCurves;

	[SerializeField]
	private bool m_Recordable;

	[SerializeField]
	private ClipExtrapolation m_PostExtrapolationMode;

	[SerializeField]
	private ClipExtrapolation m_PreExtrapolationMode;

	[SerializeField]
	private double m_PostExtrapolationTime;

	[SerializeField]
	private double m_PreExtrapolationTime;

	[SerializeField]
	private string m_DisplayName;

	public bool hasPreExtrapolation
	{
		get
		{
			if (m_PreExtrapolationMode != ClipExtrapolation.None)
			{
				return m_PreExtrapolationTime > 0.0;
			}
			return false;
		}
	}

	public bool hasPostExtrapolation
	{
		get
		{
			if (m_PostExtrapolationMode != ClipExtrapolation.None)
			{
				return m_PostExtrapolationTime > 0.0;
			}
			return false;
		}
	}

	public double timeScale
	{
		get
		{
			if (!clipCaps.HasAny(ClipCaps.SpeedMultiplier))
			{
				return 1.0;
			}
			return Math.Max(kTimeScaleMin, Math.Min(m_TimeScale, kTimeScaleMax));
		}
		set
		{
			UpdateDirty(m_TimeScale, value);
			m_TimeScale = (clipCaps.HasAny(ClipCaps.SpeedMultiplier) ? Math.Max(kTimeScaleMin, Math.Min(value, kTimeScaleMax)) : 1.0);
		}
	}

	public double start
	{
		get
		{
			return m_Start;
		}
		set
		{
			UpdateDirty(value, m_Start);
			double num = Math.Max(SanitizeTimeValue(value, m_Start), 0.0);
			if (m_ParentTrack != null && m_Start != num)
			{
				m_ParentTrack.OnClipMove();
			}
			m_Start = num;
		}
	}

	public double duration
	{
		get
		{
			return m_Duration;
		}
		set
		{
			UpdateDirty(m_Duration, value);
			m_Duration = Math.Max(SanitizeTimeValue(value, m_Duration), double.Epsilon);
		}
	}

	public double end => m_Start + m_Duration;

	public double clipIn
	{
		get
		{
			if (!clipCaps.HasAny(ClipCaps.ClipIn))
			{
				return 0.0;
			}
			return m_ClipIn;
		}
		set
		{
			UpdateDirty(m_ClipIn, value);
			m_ClipIn = (clipCaps.HasAny(ClipCaps.ClipIn) ? Math.Max(Math.Min(SanitizeTimeValue(value, m_ClipIn), kMaxTimeValue), 0.0) : 0.0);
		}
	}

	public string displayName
	{
		get
		{
			return m_DisplayName;
		}
		set
		{
			m_DisplayName = value;
		}
	}

	public double clipAssetDuration
	{
		get
		{
			if (!(m_Asset is IPlayableAsset playableAsset))
			{
				return double.MaxValue;
			}
			return playableAsset.duration;
		}
	}

	public AnimationClip curves
	{
		get
		{
			return m_AnimationCurves;
		}
		internal set
		{
			m_AnimationCurves = value;
		}
	}

	string ICurvesOwner.defaultCurvesName => kDefaultCurvesName;

	public bool hasCurves
	{
		get
		{
			if (m_AnimationCurves != null)
			{
				return !m_AnimationCurves.empty;
			}
			return false;
		}
	}

	public Object asset
	{
		get
		{
			return m_Asset;
		}
		set
		{
			m_Asset = value;
		}
	}

	Object ICurvesOwner.assetOwner => GetParentTrack();

	TrackAsset ICurvesOwner.targetTrack => GetParentTrack();

	[Obsolete("underlyingAsset property is obsolete. Use asset property instead", true)]
	public Object underlyingAsset
	{
		get
		{
			return null;
		}
		set
		{
		}
	}

	[Obsolete("parentTrack is deprecated and will be removed in a future release. Use GetParentTrack() and TimelineClipExtensions::MoveToTrack() or TimelineClipExtensions::TryMoveToTrack() instead.", false)]
	public TrackAsset parentTrack
	{
		get
		{
			return m_ParentTrack;
		}
		set
		{
			SetParentTrack_Internal(value);
		}
	}

	public double easeInDuration
	{
		get
		{
			double val = (hasBlendOut ? (duration - m_BlendOutDuration) : duration);
			if (!clipCaps.HasAny(ClipCaps.Blending))
			{
				return 0.0;
			}
			return Math.Min(Math.Max(m_EaseInDuration, 0.0), val);
		}
		set
		{
			double val = (hasBlendOut ? (duration - m_BlendOutDuration) : duration);
			m_EaseInDuration = (clipCaps.HasAny(ClipCaps.Blending) ? Math.Max(0.0, Math.Min(SanitizeTimeValue(value, m_EaseInDuration), val)) : 0.0);
		}
	}

	public double easeOutDuration
	{
		get
		{
			double val = (hasBlendIn ? (duration - m_BlendInDuration) : duration);
			if (!clipCaps.HasAny(ClipCaps.Blending))
			{
				return 0.0;
			}
			return Math.Min(Math.Max(m_EaseOutDuration, 0.0), val);
		}
		set
		{
			double val = (hasBlendIn ? (duration - m_BlendInDuration) : duration);
			m_EaseOutDuration = (clipCaps.HasAny(ClipCaps.Blending) ? Math.Max(0.0, Math.Min(SanitizeTimeValue(value, m_EaseOutDuration), val)) : 0.0);
		}
	}

	[Obsolete("Use easeOutTime instead (UnityUpgradable) -> easeOutTime", true)]
	public double eastOutTime => duration - easeOutDuration + m_Start;

	public double easeOutTime => duration - easeOutDuration + m_Start;

	public double blendInDuration
	{
		get
		{
			if (!clipCaps.HasAny(ClipCaps.Blending))
			{
				return 0.0;
			}
			return m_BlendInDuration;
		}
		set
		{
			m_BlendInDuration = (clipCaps.HasAny(ClipCaps.Blending) ? SanitizeTimeValue(value, m_BlendInDuration) : 0.0);
		}
	}

	public double blendOutDuration
	{
		get
		{
			if (!clipCaps.HasAny(ClipCaps.Blending))
			{
				return 0.0;
			}
			return m_BlendOutDuration;
		}
		set
		{
			m_BlendOutDuration = (clipCaps.HasAny(ClipCaps.Blending) ? SanitizeTimeValue(value, m_BlendOutDuration) : 0.0);
		}
	}

	public BlendCurveMode blendInCurveMode
	{
		get
		{
			return m_BlendInCurveMode;
		}
		set
		{
			m_BlendInCurveMode = value;
		}
	}

	public BlendCurveMode blendOutCurveMode
	{
		get
		{
			return m_BlendOutCurveMode;
		}
		set
		{
			m_BlendOutCurveMode = value;
		}
	}

	public bool hasBlendIn
	{
		get
		{
			if (clipCaps.HasAny(ClipCaps.Blending))
			{
				return m_BlendInDuration > 0.0;
			}
			return false;
		}
	}

	public bool hasBlendOut
	{
		get
		{
			if (clipCaps.HasAny(ClipCaps.Blending))
			{
				return m_BlendOutDuration > 0.0;
			}
			return false;
		}
	}

	public AnimationCurve mixInCurve
	{
		get
		{
			if (m_MixInCurve == null || m_MixInCurve.length < 2)
			{
				m_MixInCurve = GetDefaultMixInCurve();
			}
			return m_MixInCurve;
		}
		set
		{
			m_MixInCurve = value;
		}
	}

	public float mixInPercentage => (float)(mixInDuration / duration);

	public double mixInDuration
	{
		get
		{
			if (!hasBlendIn)
			{
				return easeInDuration;
			}
			return blendInDuration;
		}
	}

	public AnimationCurve mixOutCurve
	{
		get
		{
			if (m_MixOutCurve == null || m_MixOutCurve.length < 2)
			{
				m_MixOutCurve = GetDefaultMixOutCurve();
			}
			return m_MixOutCurve;
		}
		set
		{
			m_MixOutCurve = value;
		}
	}

	public double mixOutTime => duration - mixOutDuration + m_Start;

	public double mixOutDuration
	{
		get
		{
			if (!hasBlendOut)
			{
				return easeOutDuration;
			}
			return blendOutDuration;
		}
	}

	public float mixOutPercentage => (float)(mixOutDuration / duration);

	public bool recordable
	{
		get
		{
			return m_Recordable;
		}
		internal set
		{
			m_Recordable = value;
		}
	}

	[Obsolete("exposedParameter is deprecated and will be removed in a future release", true)]
	public List<string> exposedParameters => m_ExposedParameterNames ?? (m_ExposedParameterNames = new List<string>());

	public ClipCaps clipCaps
	{
		get
		{
			if (!(asset is ITimelineClipAsset timelineClipAsset))
			{
				return kDefaultClipCaps;
			}
			return timelineClipAsset.clipCaps;
		}
	}

	public AnimationClip animationClip
	{
		get
		{
			if (m_Asset == null)
			{
				return null;
			}
			AnimationPlayableAsset animationPlayableAsset = m_Asset as AnimationPlayableAsset;
			if (!(animationPlayableAsset != null))
			{
				return null;
			}
			return animationPlayableAsset.clip;
		}
	}

	public ClipExtrapolation postExtrapolationMode
	{
		get
		{
			if (!clipCaps.HasAny(ClipCaps.Extrapolation))
			{
				return ClipExtrapolation.None;
			}
			return m_PostExtrapolationMode;
		}
		internal set
		{
			m_PostExtrapolationMode = (clipCaps.HasAny(ClipCaps.Extrapolation) ? value : ClipExtrapolation.None);
		}
	}

	public ClipExtrapolation preExtrapolationMode
	{
		get
		{
			if (!clipCaps.HasAny(ClipCaps.Extrapolation))
			{
				return ClipExtrapolation.None;
			}
			return m_PreExtrapolationMode;
		}
		internal set
		{
			m_PreExtrapolationMode = (clipCaps.HasAny(ClipCaps.Extrapolation) ? value : ClipExtrapolation.None);
		}
	}

	public double extrapolatedStart
	{
		get
		{
			if (m_PreExtrapolationMode != ClipExtrapolation.None)
			{
				return m_Start - m_PreExtrapolationTime;
			}
			return m_Start;
		}
	}

	public double extrapolatedDuration
	{
		get
		{
			double num = m_Duration;
			if (m_PostExtrapolationMode != ClipExtrapolation.None)
			{
				num += Math.Min(m_PostExtrapolationTime, kMaxTimeValue);
			}
			if (m_PreExtrapolationMode != ClipExtrapolation.None)
			{
				num += m_PreExtrapolationTime;
			}
			return num;
		}
	}

	private void UpgradeToLatestVersion()
	{
		if (m_Version < 1)
		{
			TimelineClipUpgrade.UpgradeClipInFromGlobalToLocal(this);
		}
	}

	internal TimelineClip(TrackAsset parent)
	{
		SetParentTrack_Internal(parent);
	}

	public TrackAsset GetParentTrack()
	{
		return m_ParentTrack;
	}

	internal void SetParentTrack_Internal(TrackAsset newParentTrack)
	{
		if (!(m_ParentTrack == newParentTrack))
		{
			if (m_ParentTrack != null)
			{
				m_ParentTrack.RemoveClip(this);
			}
			m_ParentTrack = newParentTrack;
			if (m_ParentTrack != null)
			{
				m_ParentTrack.AddClip(this);
			}
		}
	}

	internal int Hash()
	{
		int hashCode = m_Start.GetHashCode();
		int hashCode2 = m_Duration.GetHashCode();
		int hashCode3 = m_TimeScale.GetHashCode();
		int hashCode4 = m_ClipIn.GetHashCode();
		int num = (int)m_PreExtrapolationMode;
		int hashCode5 = num.GetHashCode();
		num = (int)m_PostExtrapolationMode;
		return HashUtility.CombineHash(hashCode, hashCode2, hashCode3, hashCode4, hashCode5, num.GetHashCode());
	}

	public float EvaluateMixOut(double time)
	{
		if (!clipCaps.HasAny(ClipCaps.Blending))
		{
			return 1f;
		}
		if (mixOutDuration > (double)Mathf.Epsilon)
		{
			float time2 = (float)(time - mixOutTime) / (float)mixOutDuration;
			return Mathf.Clamp01(mixOutCurve.Evaluate(time2));
		}
		return 1f;
	}

	public float EvaluateMixIn(double time)
	{
		if (!clipCaps.HasAny(ClipCaps.Blending))
		{
			return 1f;
		}
		if (mixInDuration > (double)Mathf.Epsilon)
		{
			float time2 = (float)(time - m_Start) / (float)mixInDuration;
			return Mathf.Clamp01(mixInCurve.Evaluate(time2));
		}
		return 1f;
	}

	private static AnimationCurve GetDefaultMixInCurve()
	{
		return AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);
	}

	private static AnimationCurve GetDefaultMixOutCurve()
	{
		return AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);
	}

	public double ToLocalTime(double time)
	{
		if (time < 0.0)
		{
			return time;
		}
		time = (IsPreExtrapolatedTime(time) ? GetExtrapolatedTime(time - m_Start, m_PreExtrapolationMode, m_Duration) : ((!IsPostExtrapolatedTime(time)) ? (time - m_Start) : GetExtrapolatedTime(time - m_Start, m_PostExtrapolationMode, m_Duration)));
		time *= timeScale;
		time += clipIn;
		return time;
	}

	public double ToLocalTimeUnbound(double time)
	{
		return (time - m_Start) * timeScale + clipIn;
	}

	internal double FromLocalTimeUnbound(double time)
	{
		return (time - clipIn) / timeScale + m_Start;
	}

	private static double SanitizeTimeValue(double value, double defaultValue)
	{
		if (double.IsInfinity(value) || double.IsNaN(value))
		{
			Debug.LogError("Invalid time value assigned");
			return defaultValue;
		}
		return Math.Max(0.0 - kMaxTimeValue, Math.Min(kMaxTimeValue, value));
	}

	internal void SetPostExtrapolationTime(double time)
	{
		m_PostExtrapolationTime = time;
	}

	internal void SetPreExtrapolationTime(double time)
	{
		m_PreExtrapolationTime = time;
	}

	public bool IsExtrapolatedTime(double sequenceTime)
	{
		if (!IsPreExtrapolatedTime(sequenceTime))
		{
			return IsPostExtrapolatedTime(sequenceTime);
		}
		return true;
	}

	public bool IsPreExtrapolatedTime(double sequenceTime)
	{
		if (preExtrapolationMode != ClipExtrapolation.None && sequenceTime < m_Start)
		{
			return sequenceTime >= m_Start - m_PreExtrapolationTime;
		}
		return false;
	}

	public bool IsPostExtrapolatedTime(double sequenceTime)
	{
		if (postExtrapolationMode != ClipExtrapolation.None && sequenceTime > end)
		{
			return sequenceTime - end < m_PostExtrapolationTime;
		}
		return false;
	}

	private static double GetExtrapolatedTime(double time, ClipExtrapolation mode, double duration)
	{
		if (duration == 0.0)
		{
			return 0.0;
		}
		switch (mode)
		{
		case ClipExtrapolation.Loop:
			if (time < 0.0)
			{
				time = duration - (0.0 - time) % duration;
			}
			else if (time > duration)
			{
				time %= duration;
			}
			break;
		case ClipExtrapolation.Hold:
			if (time < 0.0)
			{
				return 0.0;
			}
			if (time > duration)
			{
				return duration;
			}
			break;
		case ClipExtrapolation.PingPong:
			if (time < 0.0)
			{
				time = duration * 2.0 - (0.0 - time) % (duration * 2.0);
				time = duration - Math.Abs(time - duration);
			}
			else
			{
				time %= duration * 2.0;
				time = duration - Math.Abs(time - duration);
			}
			break;
		}
		return time;
	}

	public void CreateCurves(string curvesClipName)
	{
		if (!(m_AnimationCurves != null))
		{
			m_AnimationCurves = TimelineCreateUtilities.CreateAnimationClipForTrack(string.IsNullOrEmpty(curvesClipName) ? kDefaultCurvesName : curvesClipName, GetParentTrack(), isLegacy: true);
		}
	}

	void ISerializationCallbackReceiver.OnBeforeSerialize()
	{
		m_Version = 1;
	}

	void ISerializationCallbackReceiver.OnAfterDeserialize()
	{
		if (m_Version < 1)
		{
			UpgradeToLatestVersion();
		}
	}

	public override string ToString()
	{
		return UnityString.Format("{0} ({1:F2}, {2:F2}):{3:F2} | {4}", displayName, start, end, clipIn, GetParentTrack());
	}

	public void ConformEaseValues()
	{
		if (m_EaseInDuration + m_EaseOutDuration > duration)
		{
			double num = CalculateEasingRatio(m_EaseInDuration, m_EaseOutDuration);
			m_EaseInDuration = duration * num;
			m_EaseOutDuration = duration * (1.0 - num);
		}
	}

	private static double CalculateEasingRatio(double easeIn, double easeOut)
	{
		if (Math.Abs(easeIn - easeOut) < TimeUtility.kTimeEpsilon)
		{
			return 0.5;
		}
		if (easeIn == 0.0)
		{
			return 0.0;
		}
		if (easeOut == 0.0)
		{
			return 1.0;
		}
		return easeIn / (easeIn + easeOut);
	}

	private void UpdateDirty(double oldValue, double newValue)
	{
	}
}
[Serializable]
[ExcludeFromPreset]
public class TimelineAsset : PlayableAsset, ISerializationCallbackReceiver, ITimelineClipAsset, IPropertyPreview
{
	private enum Versions
	{
		Initial
	}

	private static class TimelineAssetUpgrade
	{
	}

	[Obsolete("MediaType has been deprecated. It is no longer required, and will be removed in a future release.", false)]
	public enum MediaType
	{
		Animation = 0,
		Audio = 1,
		Texture = 2,
		[Obsolete("Use Texture MediaType instead. (UnityUpgradable) -> UnityEngine.Timeline.TimelineAsset/MediaType.Texture", false)]
		Video = 2,
		Script = 3,
		Hybrid = 4,
		Group = 5
	}

	public enum DurationMode
	{
		BasedOnClips,
		FixedLength
	}

	[Serializable]
	public class EditorSettings
	{
		internal static readonly double kMinFrameRate = TimeUtility.kFrameRateEpsilon;

		internal static readonly double kMaxFrameRate = 1000.0;

		internal static readonly double kDefaultFrameRate = 60.0;

		[HideInInspector]
		[SerializeField]
		[FrameRateField]
		private double m_Framerate = kDefaultFrameRate;

		[HideInInspector]
		[SerializeField]
		private bool m_ScenePreview = true;

		[Obsolete("EditorSettings.fps has been deprecated. Use editorSettings.frameRate instead.", false)]
		public float fps
		{
			get
			{
				return (float)m_Framerate;
			}
			set
			{
				m_Framerate = Mathf.Clamp(value, (float)kMinFrameRate, (float)kMaxFrameRate);
			}
		}

		public double frameRate
		{
			get
			{
				return m_Framerate;
			}
			set
			{
				m_Framerate = GetValidFrameRate(value);
			}
		}

		public bool scenePreview
		{
			get
			{
				return m_ScenePreview;
			}
			set
			{
				m_ScenePreview = value;
			}
		}

		public void SetStandardFrameRate(StandardFrameRates enumValue)
		{
			FrameRate frameRate = TimeUtility.ToFrameRate(enumValue);
			if (frameRate.IsValid())
			{
				throw new ArgumentException($"StandardFrameRates {enumValue.ToString()}, is not defined");
			}
			m_Framerate = frameRate.rate;
		}
	}

	private const int k_LatestVersion = 0;

	[SerializeField]
	[HideInInspector]
	private int m_Version;

	[HideInInspector]
	[SerializeField]
	private List<ScriptableObject> m_Tracks;

	[HideInInspector]
	[SerializeField]
	private double m_FixedDuration;

	[NonSerialized]
	[HideInInspector]
	private TrackAsset[] m_CacheOutputTracks;

	[NonSerialized]
	[HideInInspector]
	private List<TrackAsset> m_CacheRootTracks;

	[NonSerialized]
	[HideInInspector]
	private TrackAsset[] m_CacheFlattenedTracks;

	[HideInInspector]
	[SerializeField]
	private EditorSettings m_EditorSettings = new EditorSettings();

	[SerializeField]
	private DurationMode m_DurationMode;

	[HideInInspector]
	[SerializeField]
	private MarkerTrack m_MarkerTrack;

	public EditorSettings editorSettings => m_EditorSettings;

	public override double duration
	{
		get
		{
			if (m_DurationMode == DurationMode.BasedOnClips)
			{
				DiscreteTime discreteTime = CalculateItemsDuration();
				if (discreteTime <= 0)
				{
					return 0.0;
				}
				return (double)discreteTime.OneTickBefore();
			}
			return m_FixedDuration;
		}
	}

	public double fixedDuration
	{
		get
		{
			DiscreteTime discreteTime = (DiscreteTime)m_FixedDuration;
			if (discreteTime <= 0)
			{
				return 0.0;
			}
			return (double)discreteTime.OneTickBefore();
		}
		set
		{
			m_FixedDuration = Math.Max(0.0, value);
		}
	}

	public DurationMode durationMode
	{
		get
		{
			return m_DurationMode;
		}
		set
		{
			m_DurationMode = value;
		}
	}

	public override IEnumerable<PlayableBinding> outputs
	{
		get
		{
			foreach (TrackAsset outputTrack in GetOutputTracks())
			{
				foreach (PlayableBinding output in outputTrack.outputs)
				{
					yield return output;
				}
			}
		}
	}

	public ClipCaps clipCaps
	{
		get
		{
			ClipCaps clipCaps = ClipCaps.All;
			foreach (TrackAsset rootTrack in GetRootTracks())
			{
				TimelineClip[] clips = rootTrack.clips;
				foreach (TimelineClip timelineClip in clips)
				{
					clipCaps &= timelineClip.clipCaps;
				}
			}
			return clipCaps;
		}
	}

	public int outputTrackCount
	{
		get
		{
			UpdateOutputTrackCache();
			return m_CacheOutputTracks.Length;
		}
	}

	public int rootTrackCount
	{
		get
		{
			UpdateRootTrackCache();
			return m_CacheRootTracks.Count;
		}
	}

	internal TrackAsset[] flattenedTracks
	{
		get
		{
			if (m_CacheFlattenedTracks == null)
			{
				List<TrackAsset> allTracks = new List<TrackAsset>(m_Tracks.Count * 2);
				UpdateRootTrackCache();
				allTracks.AddRange(m_CacheRootTracks);
				for (int i = 0; i < m_CacheRootTracks.Count; i++)
				{
					AddSubTracksRecursive(m_CacheRootTracks[i], ref allTracks);
				}
				m_CacheFlattenedTracks = allTracks.ToArray();
			}
			return m_CacheFlattenedTracks;
		}
	}

	public MarkerTrack markerTrack => m_MarkerTrack;

	internal List<ScriptableObject> trackObjects => m_Tracks;

	private void UpgradeToLatestVersion()
	{
	}

	private void OnValidate()
	{
		editorSettings.frameRate = GetValidFrameRate(editorSettings.frameRate);
	}

	public TrackAsset GetRootTrack(int index)
	{
		UpdateRootTrackCache();
		return m_CacheRootTracks[index];
	}

	public IEnumerable<TrackAsset> GetRootTracks()
	{
		UpdateRootTrackCache();
		return m_CacheRootTracks;
	}

	public TrackAsset GetOutputTrack(int index)
	{
		UpdateOutputTrackCache();
		return m_CacheOutputTracks[index];
	}

	public IEnumerable<TrackAsset> GetOutputTracks()
	{
		UpdateOutputTrackCache();
		return m_CacheOutputTracks;
	}

	private static double GetValidFrameRate(double frameRate)
	{
		return Math.Min(Math.Max(frameRate, EditorSettings.kMinFrameRate), EditorSettings.kMaxFrameRate);
	}

	private void UpdateRootTrackCache()
	{
		if (m_CacheRootTracks != null)
		{
			return;
		}
		if (m_Tracks == null)
		{
			m_CacheRootTracks = new List<TrackAsset>();
			return;
		}
		m_CacheRootTracks = new List<TrackAsset>(m_Tracks.Count);
		if (markerTrack != null)
		{
			m_CacheRootTracks.Add(markerTrack);
		}
		foreach (ScriptableObject track in m_Tracks)
		{
			TrackAsset trackAsset = track as TrackAsset;
			if (trackAsset != null)
			{
				m_CacheRootTracks.Add(trackAsset);
			}
		}
	}

	private void UpdateOutputTrackCache()
	{
		if (m_CacheOutputTracks != null)
		{
			return;
		}
		List<TrackAsset> list = new List<TrackAsset>();
		TrackAsset[] array = flattenedTracks;
		foreach (TrackAsset trackAsset in array)
		{
			if (trackAsset != null && trackAsset.GetType() != typeof(GroupTrack) && !trackAsset.isSubTrack)
			{
				list.Add(trackAsset);
			}
		}
		m_CacheOutputTracks = list.ToArray();
	}

	internal void AddTrackInternal(TrackAsset track)
	{
		m_Tracks.Add(track);
		track.parent = this;
		Invalidate();
	}

	internal void RemoveTrack(TrackAsset track)
	{
		m_Tracks.Remove(track);
		Invalidate();
		TrackAsset trackAsset = track.parent as TrackAsset;
		if (trackAsset != null)
		{
			trackAsset.RemoveSubTrack(track);
		}
	}

	public override Playable CreatePlayable(PlayableGraph graph, GameObject go)
	{
		bool autoRebalance = false;
		bool createOutputs = graph.GetPlayableCount() == 0;
		ScriptPlayable<TimelinePlayable> scriptPlayable = TimelinePlayable.Create(graph, GetOutputTracks(), go, autoRebalance, createOutputs);
		scriptPlayable.SetDuration(duration);
		scriptPlayable.SetPropagateSetTime(value: true);
		if (!scriptPlayable.IsValid())
		{
			return Playable.Null;
		}
		return scriptPlayable;
	}

	void ISerializationCallbackReceiver.OnBeforeSerialize()
	{
		m_Version = 0;
	}

	void ISerializationCallbackReceiver.OnAfterDeserialize()
	{
		Invalidate();
		if (m_Version < 0)
		{
			UpgradeToLatestVersion();
		}
	}

	private void __internalAwake()
	{
		if (m_Tracks == null)
		{
			m_Tracks = new List<ScriptableObject>();
		}
		for (int num = m_Tracks.Count - 1; num >= 0; num--)
		{
			TrackAsset trackAsset = m_Tracks[num] as TrackAsset;
			if (trackAsset != null)
			{
				trackAsset.parent = this;
			}
		}
	}

	public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		foreach (TrackAsset outputTrack in GetOutputTracks())
		{
			if (!outputTrack.mutedInHierarchy)
			{
				outputTrack.GatherProperties(director, driver);
			}
		}
	}

	public void CreateMarkerTrack()
	{
		if (m_MarkerTrack == null)
		{
			m_MarkerTrack = ScriptableObject.CreateInstance<MarkerTrack>();
			TimelineCreateUtilities.SaveAssetIntoObject(m_MarkerTrack, this);
			m_MarkerTrack.parent = this;
			m_MarkerTrack.name = "Markers";
			Invalidate();
		}
	}

	internal void Invalidate()
	{
		m_CacheRootTracks = null;
		m_CacheOutputTracks = null;
		m_CacheFlattenedTracks = null;
	}

	internal void UpdateFixedDurationWithItemsDuration()
	{
		m_FixedDuration = (double)CalculateItemsDuration();
	}

	private DiscreteTime CalculateItemsDuration()
	{
		DiscreteTime discreteTime = new DiscreteTime(0);
		TrackAsset[] array = flattenedTracks;
		foreach (TrackAsset trackAsset in array)
		{
			if (!trackAsset.muted)
			{
				discreteTime = DiscreteTime.Max(discreteTime, (DiscreteTime)trackAsset.end);
			}
		}
		if (discreteTime <= 0)
		{
			return new DiscreteTime(0);
		}
		return discreteTime;
	}

	private static void AddSubTracksRecursive(TrackAsset track, ref List<TrackAsset> allTracks)
	{
		if (track == null)
		{
			return;
		}
		allTracks.AddRange(track.GetChildTracks());
		foreach (TrackAsset childTrack in track.GetChildTracks())
		{
			AddSubTracksRecursive(childTrack, ref allTracks);
		}
	}

	public TrackAsset CreateTrack(Type type, TrackAsset parent, string name)
	{
		if (parent != null && parent.timelineAsset != this)
		{
			throw new InvalidOperationException("Addtrack cannot parent to a track not in the Timeline");
		}
		if (!typeof(TrackAsset).IsAssignableFrom(type))
		{
			throw new InvalidOperationException("Supplied type must be a track asset");
		}
		if (parent != null && !TimelineCreateUtilities.ValidateParentTrack(parent, type))
		{
			throw new InvalidOperationException("Cannot assign a child of type " + type.Name + " to a parent of type " + parent.GetType().Name);
		}
		string text = name;
		if (string.IsNullOrEmpty(text))
		{
			text = type.Name;
		}
		string text2 = text;
		text2 = ((!(parent != null)) ? TimelineCreateUtilities.GenerateUniqueActorName(trackObjects, text) : TimelineCreateUtilities.GenerateUniqueActorName(parent.subTracksObjects, text));
		return AllocateTrack(parent, text2, type);
	}

	public T CreateTrack<T>(TrackAsset parent, string trackName) where T : TrackAsset, new()
	{
		return (T)CreateTrack(typeof(T), parent, trackName);
	}

	public T CreateTrack<T>(string trackName) where T : TrackAsset, new()
	{
		return (T)CreateTrack(typeof(T), null, trackName);
	}

	public T CreateTrack<T>() where T : TrackAsset, new()
	{
		return (T)CreateTrack(typeof(T), null, null);
	}

	public bool DeleteClip(TimelineClip clip)
	{
		if (clip == null || clip.GetParentTrack() == null)
		{
			return false;
		}
		if (this != clip.GetParentTrack().timelineAsset)
		{
			Debug.LogError("Cannot delete a clip from this timeline");
			return false;
		}
		if (clip.curves != null)
		{
			TimelineUndo.PushDestroyUndo(this, clip.GetParentTrack(), clip.curves);
		}
		if (clip.asset != null)
		{
			DeleteRecordedAnimation(clip);
			TimelineUndo.PushDestroyUndo(this, clip.GetParentTrack(), clip.asset);
		}
		TrackAsset parentTrack = clip.GetParentTrack();
		parentTrack.RemoveClip(clip);
		parentTrack.CalculateExtrapolationTimes();
		return true;
	}

	public bool DeleteTrack(TrackAsset track)
	{
		if (track.timelineAsset != this)
		{
			return false;
		}
		_ = track.parent as TrackAsset != null;
		foreach (TrackAsset childTrack in track.GetChildTracks())
		{
			DeleteTrack(childTrack);
		}
		DeleteRecordedAnimation(track);
		foreach (TimelineClip item in new List<TimelineClip>(track.clips))
		{
			DeleteClip(item);
		}
		RemoveTrack(track);
		TimelineUndo.PushDestroyUndo(this, this, track);
		return true;
	}

	internal void MoveLastTrackBefore(TrackAsset asset)
	{
		if (m_Tracks == null || m_Tracks.Count < 2 || asset == null)
		{
			return;
		}
		ScriptableObject scriptableObject = m_Tracks[m_Tracks.Count - 1];
		if (scriptableObject == asset)
		{
			return;
		}
		for (int i = 0; i < m_Tracks.Count - 1; i++)
		{
			if (m_Tracks[i] == asset)
			{
				for (int num = m_Tracks.Count - 1; num > i; num--)
				{
					m_Tracks[num] = m_Tracks[num - 1];
				}
				m_Tracks[i] = scriptableObject;
				Invalidate();
				break;
			}
		}
	}

	private TrackAsset AllocateTrack(TrackAsset trackAssetParent, string trackName, Type trackType)
	{
		if (trackAssetParent != null && trackAssetParent.timelineAsset != this)
		{
			throw new InvalidOperationException("Addtrack cannot parent to a track not in the Timeline");
		}
		if (!typeof(TrackAsset).IsAssignableFrom(trackType))
		{
			throw new InvalidOperationException("Supplied type must be a track asset");
		}
		TrackAsset trackAsset = (TrackAsset)ScriptableObject.CreateInstance(trackType);
		trackAsset.name = trackName;
		PlayableAsset masterAsset = ((trackAssetParent != null) ? ((PlayableAsset)trackAssetParent) : ((PlayableAsset)this));
		TimelineCreateUtilities.SaveAssetIntoObject(trackAsset, masterAsset);
		if (trackAssetParent != null)
		{
			trackAssetParent.AddChild(trackAsset);
		}
		else
		{
			AddTrackInternal(trackAsset);
		}
		return trackAsset;
	}

	private void DeleteRecordedAnimation(TrackAsset track)
	{
		AnimationTrack animationTrack = track as AnimationTrack;
		if (animationTrack != null && animationTrack.infiniteClip != null)
		{
			TimelineUndo.PushDestroyUndo(this, track, animationTrack.infiniteClip);
		}
		if (track.curves != null)
		{
			TimelineUndo.PushDestroyUndo(this, track, track.curves);
		}
	}

	private void DeleteRecordedAnimation(TimelineClip clip)
	{
		if (clip == null)
		{
			return;
		}
		if (clip.curves != null)
		{
			TimelineUndo.PushDestroyUndo(this, clip.GetParentTrack(), clip.curves);
		}
		if (clip.recordable)
		{
			AnimationPlayableAsset animationPlayableAsset = clip.asset as AnimationPlayableAsset;
			if (!(animationPlayableAsset == null) && !(animationPlayableAsset.clip == null))
			{
				TimelineUndo.PushDestroyUndo(this, animationPlayableAsset, animationPlayableAsset.clip);
			}
		}
	}
}
[Serializable]
[IgnoreOnPlayableTrack]
public abstract class TrackAsset : PlayableAsset, ISerializationCallbackReceiver, IPropertyPreview, ICurvesOwner
{
	internal enum Versions
	{
		Initial,
		RotationAsEuler,
		RootMotionUpgrade,
		AnimatedTrackProperties
	}

	private static class TrackAssetUpgrade
	{
	}

	private struct TransientBuildData
	{
		public List<TrackAsset> trackList;

		public List<TimelineClip> clipList;

		public List<IMarker> markerList;

		public static TransientBuildData Create()
		{
			return new TransientBuildData
			{
				trackList = new List<TrackAsset>(20),
				clipList = new List<TimelineClip>(500),
				markerList = new List<IMarker>(100)
			};
		}

		public void Clear()
		{
			trackList.Clear();
			clipList.Clear();
			markerList.Clear();
		}
	}

	private const int k_LatestVersion = 3;

	[SerializeField]
	[HideInInspector]
	private int m_Version;

	[Obsolete("Please use m_InfiniteClip (on AnimationTrack) instead.", false)]
	[SerializeField]
	[HideInInspector]
	[FormerlySerializedAs("m_animClip")]
	internal AnimationClip m_AnimClip;

	private static TransientBuildData s_BuildData = TransientBuildData.Create();

	internal const string kDefaultCurvesName = "Track Parameters";

	[SerializeField]
	[HideInInspector]
	private bool m_Locked;

	[SerializeField]
	[HideInInspector]
	private bool m_Muted;

	[SerializeField]
	[HideInInspector]
	private string m_CustomPlayableFullTypename = string.Empty;

	[SerializeField]
	[HideInInspector]
	private AnimationClip m_Curves;

	[SerializeField]
	[HideInInspector]
	private PlayableAsset m_Parent;

	[SerializeField]
	[HideInInspector]
	private List<ScriptableObject> m_Children;

	[NonSerialized]
	private int m_ItemsHash;

	[NonSerialized]
	private TimelineClip[] m_ClipsCache;

	private DiscreteTime m_Start;

	private DiscreteTime m_End;

	private bool m_CacheSorted;

	private bool? m_SupportsNotifications;

	private static TrackAsset[] s_EmptyCache = new TrackAsset[0];

	private IEnumerable<TrackAsset> m_ChildTrackCache;

	private static Dictionary<Type, TrackBindingTypeAttribute> s_TrackBindingTypeAttributeCache = new Dictionary<Type, TrackBindingTypeAttribute>();

	[SerializeField]
	[HideInInspector]
	protected internal List<TimelineClip> m_Clips = new List<TimelineClip>();

	[SerializeField]
	[HideInInspector]
	private MarkerList m_Markers = new MarkerList(0);

	public double start
	{
		get
		{
			UpdateDuration();
			return (double)m_Start;
		}
	}

	public double end
	{
		get
		{
			UpdateDuration();
			return (double)m_End;
		}
	}

	public sealed override double duration
	{
		get
		{
			UpdateDuration();
			return (double)(m_End - m_Start);
		}
	}

	public bool muted
	{
		get
		{
			return m_Muted;
		}
		set
		{
			m_Muted = value;
		}
	}

	public bool mutedInHierarchy
	{
		get
		{
			if (muted)
			{
				return true;
			}
			TrackAsset trackAsset = this;
			while (trackAsset.parent as TrackAsset != null)
			{
				trackAsset = (TrackAsset)trackAsset.parent;
				if (trackAsset as GroupTrack != null)
				{
					return trackAsset.mutedInHierarchy;
				}
			}
			return false;
		}
	}

	public TimelineAsset timelineAsset
	{
		get
		{
			TrackAsset trackAsset = this;
			while (trackAsset != null)
			{
				if (trackAsset.parent == null)
				{
					return null;
				}
				TimelineAsset timelineAsset = trackAsset.parent as TimelineAsset;
				if (timelineAsset != null)
				{
					return timelineAsset;
				}
				trackAsset = trackAsset.parent as TrackAsset;
			}
			return null;
		}
	}

	public PlayableAsset parent
	{
		get
		{
			return m_Parent;
		}
		internal set
		{
			m_Parent = value;
		}
	}

	internal TimelineClip[] clips
	{
		get
		{
			if (m_Clips == null)
			{
				m_Clips = new List<TimelineClip>();
			}
			if (m_ClipsCache == null)
			{
				m_CacheSorted = false;
				m_ClipsCache = m_Clips.ToArray();
			}
			return m_ClipsCache;
		}
	}

	public virtual bool isEmpty
	{
		get
		{
			if (!hasClips && !hasCurves)
			{
				return GetMarkerCount() == 0;
			}
			return false;
		}
	}

	public bool hasClips
	{
		get
		{
			if (m_Clips != null)
			{
				return m_Clips.Count != 0;
			}
			return false;
		}
	}

	public bool hasCurves
	{
		get
		{
			if (m_Curves != null)
			{
				return !m_Curves.empty;
			}
			return false;
		}
	}

	public bool isSubTrack
	{
		get
		{
			TrackAsset trackAsset = parent as TrackAsset;
			if (trackAsset != null)
			{
				return trackAsset.GetType() == GetType();
			}
			return false;
		}
	}

	public override IEnumerable<PlayableBinding> outputs
	{
		get
		{
			if (!s_TrackBindingTypeAttributeCache.TryGetValue(GetType(), out var value))
			{
				value = (TrackBindingTypeAttribute)Attribute.GetCustomAttribute(GetType(), typeof(TrackBindingTypeAttribute));
				s_TrackBindingTypeAttributeCache.Add(GetType(), value);
			}
			Type type = value?.type;
			yield return ScriptPlayableBinding.Create(base.name, this, type);
		}
	}

	internal string customPlayableTypename
	{
		get
		{
			return m_CustomPlayableFullTypename;
		}
		set
		{
			m_CustomPlayableFullTypename = value;
		}
	}

	public AnimationClip curves
	{
		get
		{
			return m_Curves;
		}
		internal set
		{
			m_Curves = value;
		}
	}

	string ICurvesOwner.defaultCurvesName => "Track Parameters";

	Object ICurvesOwner.asset => this;

	Object ICurvesOwner.assetOwner => timelineAsset;

	TrackAsset ICurvesOwner.targetTrack => this;

	internal List<ScriptableObject> subTracksObjects => m_Children;

	public bool locked
	{
		get
		{
			return m_Locked;
		}
		set
		{
			m_Locked = value;
		}
	}

	public bool lockedInHierarchy
	{
		get
		{
			if (locked)
			{
				return true;
			}
			TrackAsset trackAsset = this;
			while (trackAsset.parent as TrackAsset != null)
			{
				trackAsset = (TrackAsset)trackAsset.parent;
				if (trackAsset as GroupTrack != null)
				{
					return trackAsset.lockedInHierarchy;
				}
			}
			return false;
		}
	}

	public bool supportsNotifications
	{
		get
		{
			if (!m_SupportsNotifications.HasValue)
			{
				m_SupportsNotifications = NotificationUtilities.TrackTypeSupportsNotifications(GetType());
			}
			return m_SupportsNotifications.Value;
		}
	}

	internal static event Action<TimelineClip, GameObject, Playable> OnClipPlayableCreate;

	internal static event Action<TrackAsset, GameObject, Playable> OnTrackAnimationPlayableCreate;

	protected virtual void OnBeforeTrackSerialize()
	{
	}

	protected virtual void OnAfterTrackDeserialize()
	{
	}

	internal virtual void OnUpgradeFromVersion(int oldVersion)
	{
	}

	void ISerializationCallbackReceiver.OnBeforeSerialize()
	{
		m_Version = 3;
		if (m_Children != null)
		{
			for (int num = m_Children.Count - 1; num >= 0; num--)
			{
				TrackAsset trackAsset = m_Children[num] as TrackAsset;
				if (trackAsset != null && trackAsset.parent != this)
				{
					trackAsset.parent = this;
				}
			}
		}
		OnBeforeTrackSerialize();
	}

	void ISerializationCallbackReceiver.OnAfterDeserialize()
	{
		m_ClipsCache = null;
		Invalidate();
		if (m_Version < 3)
		{
			UpgradeToLatestVersion();
			OnUpgradeFromVersion(m_Version);
		}
		foreach (IMarker marker in GetMarkers())
		{
			marker.Initialize(this);
		}
		OnAfterTrackDeserialize();
	}

	private void UpgradeToLatestVersion()
	{
	}

	public IEnumerable<TimelineClip> GetClips()
	{
		return clips;
	}

	public IEnumerable<TrackAsset> GetChildTracks()
	{
		UpdateChildTrackCache();
		return m_ChildTrackCache;
	}

	private void __internalAwake()
	{
		if (m_Clips == null)
		{
			m_Clips = new List<TimelineClip>();
		}
		m_ChildTrackCache = null;
		if (m_Children == null)
		{
			m_Children = new List<ScriptableObject>();
		}
	}

	public void CreateCurves(string curvesClipName)
	{
		if (!(m_Curves != null))
		{
			m_Curves = TimelineCreateUtilities.CreateAnimationClipForTrack(string.IsNullOrEmpty(curvesClipName) ? "Track Parameters" : curvesClipName, this, isLegacy: true);
		}
	}

	public virtual Playable CreateTrackMixer(PlayableGraph graph, GameObject go, int inputCount)
	{
		return Playable.Create(graph, inputCount);
	}

	public sealed override Playable CreatePlayable(PlayableGraph graph, GameObject go)
	{
		return Playable.Null;
	}

	public TimelineClip CreateDefaultClip()
	{
		object[] customAttributes = GetType().GetCustomAttributes(typeof(TrackClipTypeAttribute), inherit: true);
		Type type = null;
		object[] array = customAttributes;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] is TrackClipTypeAttribute trackClipTypeAttribute && typeof(IPlayableAsset).IsAssignableFrom(trackClipTypeAttribute.inspectedType) && typeof(ScriptableObject).IsAssignableFrom(trackClipTypeAttribute.inspectedType))
			{
				type = trackClipTypeAttribute.inspectedType;
				break;
			}
		}
		if (type == null)
		{
			Debug.LogWarning("Cannot create a default clip for type " + GetType());
			return null;
		}
		return CreateAndAddNewClipOfType(type);
	}

	public TimelineClip CreateClip<T>() where T : ScriptableObject, IPlayableAsset
	{
		return CreateClip(typeof(T));
	}

	public bool DeleteClip(TimelineClip clip)
	{
		if (!m_Clips.Contains(clip))
		{
			throw new InvalidOperationException("Cannot delete clip since it is not a child of the TrackAsset.");
		}
		if (timelineAsset != null)
		{
			return timelineAsset.DeleteClip(clip);
		}
		return false;
	}

	public IMarker CreateMarker(Type type, double time)
	{
		return m_Markers.CreateMarker(type, time, this);
	}

	public T CreateMarker<T>(double time) where T : ScriptableObject, IMarker
	{
		return (T)CreateMarker(typeof(T), time);
	}

	public bool DeleteMarker(IMarker marker)
	{
		return m_Markers.Remove(marker);
	}

	public IEnumerable<IMarker> GetMarkers()
	{
		return m_Markers.GetMarkers();
	}

	public int GetMarkerCount()
	{
		return m_Markers.Count;
	}

	public IMarker GetMarker(int idx)
	{
		return m_Markers[idx];
	}

	internal TimelineClip CreateClip(Type requestedType)
	{
		if (ValidateClipType(requestedType))
		{
			return CreateAndAddNewClipOfType(requestedType);
		}
		throw new InvalidOperationException("Clips of type " + requestedType?.ToString() + " are not permitted on tracks of type " + GetType());
	}

	internal TimelineClip CreateAndAddNewClipOfType(Type requestedType)
	{
		TimelineClip timelineClip = CreateClipOfType(requestedType);
		AddClip(timelineClip);
		return timelineClip;
	}

	internal TimelineClip CreateClipOfType(Type requestedType)
	{
		if (!ValidateClipType(requestedType))
		{
			throw new InvalidOperationException("Clips of type " + requestedType?.ToString() + " are not permitted on tracks of type " + GetType());
		}
		ScriptableObject scriptableObject = ScriptableObject.CreateInstance(requestedType);
		if (scriptableObject == null)
		{
			throw new InvalidOperationException("Could not create an instance of the ScriptableObject type " + requestedType.Name);
		}
		scriptableObject.name = requestedType.Name;
		TimelineCreateUtilities.SaveAssetIntoObject(scriptableObject, this);
		return CreateClipFromAsset(scriptableObject);
	}

	internal TimelineClip CreateClipFromPlayableAsset(IPlayableAsset asset)
	{
		if (asset == null)
		{
			throw new ArgumentNullException("asset");
		}
		if (asset as ScriptableObject == null)
		{
			throw new ArgumentException("CreateClipFromPlayableAsset  only supports ScriptableObject-derived Types");
		}
		if (!ValidateClipType(asset.GetType()))
		{
			throw new InvalidOperationException("Clips of type " + asset.GetType()?.ToString() + " are not permitted on tracks of type " + GetType());
		}
		return CreateClipFromAsset(asset as ScriptableObject);
	}

	private TimelineClip CreateClipFromAsset(ScriptableObject playableAsset)
	{
		TimelineClip timelineClip = CreateNewClipContainerInternal();
		timelineClip.displayName = playableAsset.name;
		timelineClip.asset = playableAsset;
		if (playableAsset is IPlayableAsset { duration: var num } && !double.IsInfinity(num) && num > 0.0)
		{
			timelineClip.duration = Math.Min(Math.Max(num, TimelineClip.kMinDuration), TimelineClip.kMaxTimeValue);
		}
		try
		{
			OnCreateClip(timelineClip);
			return timelineClip;
		}
		catch (Exception ex)
		{
			Debug.LogError(ex.Message, playableAsset);
			return null;
		}
	}

	internal IEnumerable<ScriptableObject> GetMarkersRaw()
	{
		return m_Markers.GetRawMarkerList();
	}

	internal void ClearMarkers()
	{
		m_Markers.Clear();
	}

	internal void AddMarker(ScriptableObject e)
	{
		m_Markers.Add(e);
	}

	internal bool DeleteMarkerRaw(ScriptableObject marker)
	{
		return m_Markers.Remove(marker, timelineAsset, this);
	}

	private int GetTimeRangeHash()
	{
		double num = double.MaxValue;
		double num2 = double.MinValue;
		_ = m_Markers.Count;
		for (int i = 0; i < m_Markers.Count; i++)
		{
			IMarker marker = m_Markers[i];
			if (marker is INotification)
			{
				if (marker.time < num)
				{
					num = marker.time;
				}
				if (marker.time > num2)
				{
					num2 = marker.time;
				}
			}
		}
		return num.GetHashCode().CombineHash(num2.GetHashCode());
	}

	internal void AddClip(TimelineClip newClip)
	{
		if (!m_Clips.Contains(newClip))
		{
			m_Clips.Add(newClip);
			m_ClipsCache = null;
		}
	}

	private Playable CreateNotificationsPlayable(PlayableGraph graph, Playable mixerPlayable, GameObject go, Playable timelinePlayable)
	{
		s_BuildData.markerList.Clear();
		GatherNotifications(s_BuildData.markerList);
		PlayableDirector component;
		ScriptPlayable<TimeNotificationBehaviour> scriptPlayable = ((!go.TryGetComponent<PlayableDirector>(out component)) ? NotificationUtilities.CreateNotificationsPlayable(graph, s_BuildData.markerList, timelineAsset) : NotificationUtilities.CreateNotificationsPlayable(graph, s_BuildData.markerList, component));
		if (scriptPlayable.IsValid())
		{
			scriptPlayable.GetBehaviour().timeSource = timelinePlayable;
			if (mixerPlayable.IsValid())
			{
				scriptPlayable.SetInputCount(1);
				graph.Connect(mixerPlayable, 0, scriptPlayable, 0);
				scriptPlayable.SetInputWeight(mixerPlayable, 1f);
			}
		}
		return scriptPlayable;
	}

	internal Playable CreatePlayableGraph(PlayableGraph graph, GameObject go, IntervalTree<RuntimeElement> tree, Playable timelinePlayable)
	{
		UpdateDuration();
		Playable playable = Playable.Null;
		if (CanCreateMixerRecursive())
		{
			playable = CreateMixerPlayableGraph(graph, go, tree);
		}
		Playable playable2 = CreateNotificationsPlayable(graph, playable, go, timelinePlayable);
		s_BuildData.Clear();
		if (!playable2.IsValid() && !playable.IsValid())
		{
			Debug.LogErrorFormat("Track {0} of type {1} has no notifications and returns an invalid mixer Playable", base.name, GetType().FullName);
			return Playable.Create(graph);
		}
		if (!playable2.IsValid())
		{
			return playable;
		}
		return playable2;
	}

	internal virtual Playable CompileClips(PlayableGraph graph, GameObject go, IList<TimelineClip> timelineClips, IntervalTree<RuntimeElement> tree)
	{
		Playable playable = CreateTrackMixer(graph, go, timelineClips.Count);
		for (int i = 0; i < timelineClips.Count; i++)
		{
			Playable playable2 = CreatePlayable(graph, go, timelineClips[i]);
			if (playable2.IsValid())
			{
				playable2.SetDuration(timelineClips[i].duration);
				RuntimeClip item = new RuntimeClip(timelineClips[i], playable2, playable);
				tree.Add(item);
				graph.Connect(playable2, 0, playable, i);
				playable.SetInputWeight(i, 0f);
			}
		}
		ConfigureTrackAnimation(tree, go, playable);
		return playable;
	}

	private void GatherCompilableTracks(IList<TrackAsset> tracks)
	{
		if (!muted && CanCreateTrackMixer())
		{
			tracks.Add(this);
		}
		foreach (TrackAsset childTrack in GetChildTracks())
		{
			if (childTrack != null)
			{
				childTrack.GatherCompilableTracks(tracks);
			}
		}
	}

	private void GatherNotifications(List<IMarker> markers)
	{
		if (!muted && CanCompileNotifications())
		{
			markers.AddRange(GetMarkers());
		}
		foreach (TrackAsset childTrack in GetChildTracks())
		{
			if (childTrack != null)
			{
				childTrack.GatherNotifications(markers);
			}
		}
	}

	internal virtual Playable CreateMixerPlayableGraph(PlayableGraph graph, GameObject go, IntervalTree<RuntimeElement> tree)
	{
		if (tree == null)
		{
			throw new ArgumentException("IntervalTree argument cannot be null", "tree");
		}
		if (go == null)
		{
			throw new ArgumentException("GameObject argument cannot be null", "go");
		}
		s_BuildData.Clear();
		GatherCompilableTracks(s_BuildData.trackList);
		if (s_BuildData.trackList.Count == 0)
		{
			return Playable.Null;
		}
		Playable playable = Playable.Null;
		if (this is ILayerable layerable)
		{
			playable = layerable.CreateLayerMixer(graph, go, s_BuildData.trackList.Count);
		}
		if (playable.IsValid())
		{
			for (int i = 0; i < s_BuildData.trackList.Count; i++)
			{
				Playable playable2 = s_BuildData.trackList[i].CompileClips(graph, go, s_BuildData.trackList[i].clips, tree);
				if (playable2.IsValid())
				{
					graph.Connect(playable2, 0, playable, i);
					playable.SetInputWeight(i, 1f);
				}
			}
			return playable;
		}
		if (s_BuildData.trackList.Count == 1)
		{
			return s_BuildData.trackList[0].CompileClips(graph, go, s_BuildData.trackList[0].clips, tree);
		}
		for (int j = 0; j < s_BuildData.trackList.Count; j++)
		{
			s_BuildData.clipList.AddRange(s_BuildData.trackList[j].clips);
		}
		return CompileClips(graph, go, s_BuildData.clipList, tree);
	}

	internal void ConfigureTrackAnimation(IntervalTree<RuntimeElement> tree, GameObject go, Playable blend)
	{
		if (hasCurves)
		{
			blend.SetAnimatedProperties(m_Curves);
			tree.Add(new InfiniteRuntimeClip(blend));
			if (TrackAsset.OnTrackAnimationPlayableCreate != null)
			{
				TrackAsset.OnTrackAnimationPlayableCreate(this, go, blend);
			}
		}
	}

	internal void SortClips()
	{
		_ = clips;
		if (!m_CacheSorted)
		{
			Array.Sort(clips, (TimelineClip clip1, TimelineClip clip2) => clip1.start.CompareTo(clip2.start));
			m_CacheSorted = true;
		}
	}

	internal void ClearClipsInternal()
	{
		m_Clips = new List<TimelineClip>();
		m_ClipsCache = null;
	}

	internal void ClearSubTracksInternal()
	{
		m_Children = new List<ScriptableObject>();
		Invalidate();
	}

	internal void OnClipMove()
	{
		m_CacheSorted = false;
	}

	internal TimelineClip CreateNewClipContainerInternal()
	{
		TimelineClip timelineClip = new TimelineClip(this);
		timelineClip.asset = null;
		double val = 0.0;
		for (int i = 0; i < m_Clips.Count - 1; i++)
		{
			double num = m_Clips[i].duration;
			if (double.IsInfinity(num))
			{
				num = TimelineClip.kDefaultClipDurationInSeconds;
			}
			val = Math.Max(val, m_Clips[i].start + num);
		}
		timelineClip.mixInCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);
		timelineClip.mixOutCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);
		timelineClip.start = val;
		timelineClip.duration = TimelineClip.kDefaultClipDurationInSeconds;
		timelineClip.displayName = "untitled";
		return timelineClip;
	}

	internal void AddChild(TrackAsset child)
	{
		if (!(child == null))
		{
			m_Children.Add(child);
			child.parent = this;
			Invalidate();
		}
	}

	internal void MoveLastTrackBefore(TrackAsset asset)
	{
		if (m_Children == null || m_Children.Count < 2 || asset == null)
		{
			return;
		}
		ScriptableObject scriptableObject = m_Children[m_Children.Count - 1];
		if (scriptableObject == asset)
		{
			return;
		}
		for (int i = 0; i < m_Children.Count - 1; i++)
		{
			if (m_Children[i] == asset)
			{
				for (int num = m_Children.Count - 1; num > i; num--)
				{
					m_Children[num] = m_Children[num - 1];
				}
				m_Children[i] = scriptableObject;
				Invalidate();
				break;
			}
		}
	}

	internal bool RemoveSubTrack(TrackAsset child)
	{
		if (m_Children.Remove(child))
		{
			Invalidate();
			child.parent = null;
			return true;
		}
		return false;
	}

	internal void RemoveClip(TimelineClip clip)
	{
		m_Clips.Remove(clip);
		m_ClipsCache = null;
	}

	internal virtual void GetEvaluationTime(out double outStart, out double outDuration)
	{
		outStart = 0.0;
		outDuration = 1.0;
		outStart = double.PositiveInfinity;
		double num = double.NegativeInfinity;
		if (hasCurves)
		{
			outStart = 0.0;
			num = TimeUtility.GetAnimationClipLength(curves);
		}
		TimelineClip[] array = clips;
		foreach (TimelineClip timelineClip in array)
		{
			outStart = Math.Min(timelineClip.start, outStart);
			num = Math.Max(timelineClip.end, num);
		}
		if (HasNotifications())
		{
			double notificationDuration = GetNotificationDuration();
			outStart = Math.Min(notificationDuration, outStart);
			num = Math.Max(notificationDuration, num);
		}
		if (double.IsInfinity(outStart) || double.IsInfinity(num))
		{
			outStart = (outDuration = 0.0);
		}
		else
		{
			outDuration = num - outStart;
		}
	}

	internal virtual void GetSequenceTime(out double outStart, out double outDuration)
	{
		GetEvaluationTime(out outStart, out outDuration);
	}

	public virtual void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		GameObject gameObjectBinding = GetGameObjectBinding(director);
		if (gameObjectBinding != null)
		{
			driver.PushActiveGameObject(gameObjectBinding);
		}
		if (hasCurves)
		{
			driver.AddObjectProperties(this, m_Curves);
		}
		TimelineClip[] array = clips;
		foreach (TimelineClip timelineClip in array)
		{
			if (timelineClip.curves != null && timelineClip.asset != null)
			{
				driver.AddObjectProperties(timelineClip.asset, timelineClip.curves);
			}
			if (timelineClip.asset is IPropertyPreview propertyPreview)
			{
				propertyPreview.GatherProperties(director, driver);
			}
		}
		foreach (TrackAsset childTrack in GetChildTracks())
		{
			if (childTrack != null)
			{
				childTrack.GatherProperties(director, driver);
			}
		}
		if (gameObjectBinding != null)
		{
			driver.PopActiveGameObject();
		}
	}

	internal GameObject GetGameObjectBinding(PlayableDirector director)
	{
		if (director == null)
		{
			return null;
		}
		Object genericBinding = director.GetGenericBinding(this);
		GameObject gameObject = genericBinding as GameObject;
		if (gameObject != null)
		{
			return gameObject;
		}
		Component component = genericBinding as Component;
		if (component != null)
		{
			return component.gameObject;
		}
		return null;
	}

	internal bool ValidateClipType(Type clipType)
	{
		object[] customAttributes = GetType().GetCustomAttributes(typeof(TrackClipTypeAttribute), inherit: true);
		for (int i = 0; i < customAttributes.Length; i++)
		{
			if (((TrackClipTypeAttribute)customAttributes[i]).inspectedType.IsAssignableFrom(clipType))
			{
				return true;
			}
		}
		if (typeof(PlayableTrack).IsAssignableFrom(GetType()) && typeof(IPlayableAsset).IsAssignableFrom(clipType))
		{
			return typeof(ScriptableObject).IsAssignableFrom(clipType);
		}
		return false;
	}

	protected virtual void OnCreateClip(TimelineClip clip)
	{
	}

	private void UpdateDuration()
	{
		int num = CalculateItemsHash();
		if (num != m_ItemsHash)
		{
			m_ItemsHash = num;
			GetSequenceTime(out var outStart, out var outDuration);
			m_Start = (DiscreteTime)outStart;
			m_End = (DiscreteTime)(outStart + outDuration);
			this.CalculateExtrapolationTimes();
		}
	}

	protected internal virtual int CalculateItemsHash()
	{
		return HashUtility.CombineHash(GetClipsHash(), GetAnimationClipHash(m_Curves), GetTimeRangeHash());
	}

	protected virtual Playable CreatePlayable(PlayableGraph graph, GameObject gameObject, TimelineClip clip)
	{
		if (!graph.IsValid())
		{
			throw new ArgumentException("graph must be a valid PlayableGraph");
		}
		if (clip == null)
		{
			throw new ArgumentNullException("clip");
		}
		if (clip.asset is IPlayableAsset playableAsset)
		{
			Playable playable = playableAsset.CreatePlayable(graph, gameObject);
			if (playable.IsValid())
			{
				playable.SetAnimatedProperties(clip.curves);
				playable.SetSpeed(clip.timeScale);
				if (TrackAsset.OnClipPlayableCreate != null)
				{
					TrackAsset.OnClipPlayableCreate(clip, gameObject, playable);
				}
			}
			return playable;
		}
		return Playable.Null;
	}

	internal void Invalidate()
	{
		m_ChildTrackCache = null;
		TimelineAsset timelineAsset = this.timelineAsset;
		if (timelineAsset != null)
		{
			timelineAsset.Invalidate();
		}
	}

	internal double GetNotificationDuration()
	{
		if (!supportsNotifications)
		{
			return 0.0;
		}
		double num = 0.0;
		int count = m_Markers.Count;
		for (int i = 0; i < count; i++)
		{
			IMarker marker = m_Markers[i];
			if (marker is INotification)
			{
				num = Math.Max(num, marker.time);
			}
		}
		return num;
	}

	internal virtual bool CanCompileClips()
	{
		if (!hasClips)
		{
			return hasCurves;
		}
		return true;
	}

	public virtual bool CanCreateTrackMixer()
	{
		return CanCompileClips();
	}

	internal bool IsCompilable()
	{
		if (typeof(GroupTrack).IsAssignableFrom(GetType()))
		{
			return false;
		}
		bool flag = !mutedInHierarchy && (CanCreateTrackMixer() || CanCompileNotifications());
		if (!flag)
		{
			foreach (TrackAsset childTrack in GetChildTracks())
			{
				if (childTrack.IsCompilable())
				{
					return true;
				}
			}
		}
		return flag;
	}

	private void UpdateChildTrackCache()
	{
		if (m_ChildTrackCache != null)
		{
			return;
		}
		if (m_Children == null || m_Children.Count == 0)
		{
			m_ChildTrackCache = s_EmptyCache;
			return;
		}
		List<TrackAsset> list = new List<TrackAsset>(m_Children.Count);
		for (int i = 0; i < m_Children.Count; i++)
		{
			TrackAsset trackAsset = m_Children[i] as TrackAsset;
			if (trackAsset != null)
			{
				list.Add(trackAsset);
			}
		}
		m_ChildTrackCache = list;
	}

	internal virtual int Hash()
	{
		return clips.Length + (m_Markers.Count << 16);
	}

	private int GetClipsHash()
	{
		int num = 0;
		foreach (TimelineClip clip in m_Clips)
		{
			num = num.CombineHash(clip.Hash());
		}
		return num;
	}

	protected static int GetAnimationClipHash(AnimationClip clip)
	{
		int num = 0;
		if (clip != null && !clip.empty)
		{
			num = num.CombineHash(clip.frameRate.GetHashCode()).CombineHash(clip.length.GetHashCode());
		}
		return num;
	}

	private bool HasNotifications()
	{
		return m_Markers.HasNotifications();
	}

	private bool CanCompileNotifications()
	{
		if (supportsNotifications)
		{
			return m_Markers.HasNotifications();
		}
		return false;
	}

	private bool CanCreateMixerRecursive()
	{
		if (CanCreateTrackMixer())
		{
			return true;
		}
		foreach (TrackAsset childTrack in GetChildTracks())
		{
			if (childTrack.CanCreateMixerRecursive())
			{
				return true;
			}
		}
		return false;
	}
}
[Conditional("UNITY_EDITOR")]
internal class TimelineHelpURLAttribute : Attribute
{
	public TimelineHelpURLAttribute(Type type)
	{
	}
}
[AttributeUsage(AttributeTargets.Class)]
public class TrackColorAttribute : Attribute
{
	private Color m_Color;

	public Color color => m_Color;

	public TrackColorAttribute(float r, float g, float b)
	{
		m_Color = new Color(r, g, b);
	}
}
[Serializable]
[NotKeyable]
internal class AudioClipProperties : PlayableBehaviour
{
	[Range(0f, 1f)]
	public float volume = 1f;
}
[Serializable]
internal class AudioMixerProperties : PlayableBehaviour
{
	[Range(0f, 1f)]
	public float volume = 1f;

	[Range(-1f, 1f)]
	public float stereoPan;

	[Range(0f, 1f)]
	public float spatialBlend;

	public override void PrepareFrame(Playable playable, FrameData info)
	{
		if (!playable.IsValid() || !playable.IsPlayableOfType<AudioMixerPlayable>())
		{
			return;
		}
		int inputCount = playable.GetInputCount();
		for (int i = 0; i < inputCount; i++)
		{
			if (playable.GetInputWeight(i) > 0f)
			{
				Playable input = playable.GetInput(i);
				if (input.IsValid() && input.IsPlayableOfType<AudioClipPlayable>())
				{
					AudioClipPlayable audioClipPlayable = (AudioClipPlayable)input;
					AudioClipProperties audioClipProperties = input.GetHandle().GetObject<AudioClipProperties>();
					audioClipPlayable.SetVolume(Mathf.Clamp01(volume * audioClipProperties.volume));
					audioClipPlayable.SetStereoPan(Mathf.Clamp(stereoPan, -1f, 1f));
					audioClipPlayable.SetSpatialBlend(Mathf.Clamp01(spatialBlend));
				}
			}
		}
	}
}
[Serializable]
public class AudioPlayableAsset : PlayableAsset, ITimelineClipAsset
{
	[SerializeField]
	private AudioClip m_Clip;

	[SerializeField]
	private bool m_Loop;

	[SerializeField]
	[HideInInspector]
	private float m_bufferingTime = 0.1f;

	[SerializeField]
	private AudioClipProperties m_ClipProperties = new AudioClipProperties();

	internal float bufferingTime
	{
		get
		{
			return m_bufferingTime;
		}
		set
		{
			m_bufferingTime = value;
		}
	}

	public AudioClip clip
	{
		get
		{
			return m_Clip;
		}
		set
		{
			m_Clip = value;
		}
	}

	public bool loop
	{
		get
		{
			return m_Loop;
		}
		set
		{
			m_Loop = value;
		}
	}

	public override double duration
	{
		get
		{
			if (m_Clip == null)
			{
				return base.duration;
			}
			return (double)m_Clip.samples / (double)m_Clip.frequency;
		}
	}

	public override IEnumerable<PlayableBinding> outputs
	{
		get
		{
			yield return AudioPlayableBinding.Create(base.name, this);
		}
	}

	public ClipCaps clipCaps => (ClipCaps)(0x1C | (m_Loop ? 1 : 0));

	public override Playable CreatePlayable(PlayableGraph graph, GameObject go)
	{
		if (m_Clip == null)
		{
			return Playable.Null;
		}
		AudioClipPlayable audioClipPlayable = AudioClipPlayable.Create(graph, m_Clip, m_Loop);
		audioClipPlayable.GetHandle().SetScriptInstance(m_ClipProperties.Clone());
		return audioClipPlayable;
	}
}
[Serializable]
[TrackClipType(typeof(AudioPlayableAsset), false)]
[TrackBindingType(typeof(AudioSource))]
[ExcludeFromPreset]
public class AudioTrack : TrackAsset
{
	[SerializeField]
	private AudioMixerProperties m_TrackProperties = new AudioMixerProperties();

	public override IEnumerable<PlayableBinding> outputs
	{
		get
		{
			yield return AudioPlayableBinding.Create(base.name, this);
		}
	}

	public TimelineClip CreateClip(AudioClip clip)
	{
		if (clip == null)
		{
			return null;
		}
		TimelineClip timelineClip = CreateDefaultClip();
		AudioPlayableAsset audioPlayableAsset = timelineClip.asset as AudioPlayableAsset;
		if (audioPlayableAsset != null)
		{
			audioPlayableAsset.clip = clip;
		}
		timelineClip.duration = clip.length;
		timelineClip.displayName = clip.name;
		return timelineClip;
	}

	internal override Playable CompileClips(PlayableGraph graph, GameObject go, IList<TimelineClip> timelineClips, IntervalTree<RuntimeElement> tree)
	{
		AudioMixerPlayable audioMixerPlayable = AudioMixerPlayable.Create(graph, timelineClips.Count);
		if (base.hasCurves)
		{
			audioMixerPlayable.GetHandle().SetScriptInstance(m_TrackProperties.Clone());
		}
		for (int i = 0; i < timelineClips.Count; i++)
		{
			TimelineClip timelineClip = timelineClips[i];
			PlayableAsset playableAsset = timelineClip.asset as PlayableAsset;
			if (playableAsset == null)
			{
				continue;
			}
			float num = 0.1f;
			AudioPlayableAsset audioPlayableAsset = timelineClip.asset as AudioPlayableAsset;
			if (audioPlayableAsset != null)
			{
				num = audioPlayableAsset.bufferingTime;
			}
			Playable playable = playableAsset.CreatePlayable(graph, go);
			if (playable.IsValid())
			{
				if (playable.IsPlayableOfType<AudioClipPlayable>())
				{
					AudioClipPlayable audioClipPlayable = (AudioClipPlayable)playable;
					AudioClipProperties audioClipProperties = audioClipPlayable.GetHandle().GetObject<AudioClipProperties>();
					audioClipPlayable.SetVolume(Mathf.Clamp01(m_TrackProperties.volume * audioClipProperties.volume));
					audioClipPlayable.SetStereoPan(Mathf.Clamp(m_TrackProperties.stereoPan, -1f, 1f));
					audioClipPlayable.SetSpatialBlend(Mathf.Clamp01(m_TrackProperties.spatialBlend));
				}
				tree.Add(new ScheduleRuntimeClip(timelineClip, playable, audioMixerPlayable, num));
				graph.Connect(playable, 0, audioMixerPlayable, i);
				playable.SetSpeed(timelineClip.timeScale);
				playable.SetDuration(timelineClip.extrapolatedDuration);
				audioMixerPlayable.SetInputWeight(playable, 1f);
			}
		}
		ConfigureTrackAnimation(tree, go, audioMixerPlayable);
		return audioMixerPlayable;
	}

	private void OnValidate()
	{
		m_TrackProperties.volume = Mathf.Clamp01(m_TrackProperties.volume);
		m_TrackProperties.stereoPan = Mathf.Clamp(m_TrackProperties.stereoPan, -1f, 1f);
		m_TrackProperties.spatialBlend = Mathf.Clamp01(m_TrackProperties.spatialBlend);
	}
}
[Flags]
public enum ClipCaps
{
	None = 0,
	Looping = 1,
	Extrapolation = 2,
	ClipIn = 4,
	SpeedMultiplier = 8,
	Blending = 0x10,
	AutoScale = 0x28,
	All = -1
}
internal static class TimelineClipCapsExtensions
{
	public static bool SupportsLooping(this TimelineClip clip)
	{
		if (clip != null)
		{
			return (clip.clipCaps & ClipCaps.Looping) != 0;
		}
		return false;
	}

	public static bool SupportsExtrapolation(this TimelineClip clip)
	{
		if (clip != null)
		{
			return (clip.clipCaps & ClipCaps.Extrapolation) != 0;
		}
		return false;
	}

	public static bool SupportsClipIn(this TimelineClip clip)
	{
		if (clip != null)
		{
			return (clip.clipCaps & ClipCaps.ClipIn) != 0;
		}
		return false;
	}

	public static bool SupportsSpeedMultiplier(this TimelineClip clip)
	{
		if (clip != null)
		{
			return (clip.clipCaps & ClipCaps.SpeedMultiplier) != 0;
		}
		return false;
	}

	public static bool SupportsBlending(this TimelineClip clip)
	{
		if (clip != null)
		{
			return (clip.clipCaps & ClipCaps.Blending) != 0;
		}
		return false;
	}

	public static bool HasAll(this ClipCaps caps, ClipCaps flags)
	{
		return (caps & flags) == flags;
	}

	public static bool HasAny(this ClipCaps caps, ClipCaps flags)
	{
		return (caps & flags) != 0;
	}
}
[Serializable]
[NotKeyable]
public class ControlPlayableAsset : PlayableAsset, IPropertyPreview, ITimelineClipAsset
{
	private const int k_MaxRandInt = 10000;

	private static readonly List<PlayableDirector> k_EmptyDirectorsList = new List<PlayableDirector>(0);

	private static readonly List<ParticleSystem> k_EmptyParticlesList = new List<ParticleSystem>(0);

	private static readonly HashSet<ParticleSystem> s_SubEmitterCollector = new HashSet<ParticleSystem>();

	[SerializeField]
	public ExposedReference<GameObject> sourceGameObject;

	[SerializeField]
	public GameObject prefabGameObject;

	[SerializeField]
	public bool updateParticle = true;

	[SerializeField]
	public uint particleRandomSeed;

	[SerializeField]
	public bool updateDirector = true;

	[SerializeField]
	public bool updateITimeControl = true;

	[SerializeField]
	public bool searchHierarchy;

	[SerializeField]
	public bool active = true;

	[SerializeField]
	public ActivationControlPlayable.PostPlaybackState postPlayback = ActivationControlPlayable.PostPlaybackState.Revert;

	private PlayableAsset m_ControlDirectorAsset;

	private double m_Duration = PlayableBinding.DefaultDuration;

	private bool m_SupportLoop;

	private static HashSet<PlayableDirector> s_ProcessedDirectors = new HashSet<PlayableDirector>();

	private static HashSet<GameObject> s_CreatedPrefabs = new HashSet<GameObject>();

	internal bool controllingDirectors { get; private set; }

	internal bool controllingParticles { get; private set; }

	public override double duration => m_Duration;

	public ClipCaps clipCaps => (ClipCaps)(0xC | (m_SupportLoop ? 1 : 0));

	public void OnEnable()
	{
		if (particleRandomSeed == 0)
		{
			particleRandomSeed = (uint)Random.Range(1, 10000);
		}
	}

	public override Playable CreatePlayable(PlayableGraph graph, GameObject go)
	{
		if (prefabGameObject != null)
		{
			if (s_CreatedPrefabs.Contains(prefabGameObject))
			{
				Debug.LogWarningFormat("Control Track Clip ({0}) is causing a prefab to instantiate itself recursively. Aborting further instances.", base.name);
				return Playable.Create(graph);
			}
			s_CreatedPrefabs.Add(prefabGameObject);
		}
		Playable playable = Playable.Null;
		List<Playable> list = new List<Playable>();
		GameObject gameObject = sourceGameObject.Resolve(graph.GetResolver());
		if (prefabGameObject != null)
		{
			Transform parentTransform = ((gameObject != null) ? gameObject.transform : null);
			ScriptPlayable<PrefabControlPlayable> scriptPlayable = PrefabControlPlayable.Create(graph, prefabGameObject, parentTransform);
			gameObject = scriptPlayable.GetBehaviour().prefabInstance;
			list.Add(scriptPlayable);
		}
		m_Duration = PlayableBinding.DefaultDuration;
		m_SupportLoop = false;
		controllingParticles = false;
		controllingDirectors = false;
		if (gameObject != null)
		{
			IList<PlayableDirector> list3;
			if (!updateDirector)
			{
				IList<PlayableDirector> list2 = k_EmptyDirectorsList;
				list3 = list2;
			}
			else
			{
				list3 = GetComponent<PlayableDirector>(gameObject);
			}
			IList<PlayableDirector> directors = list3;
			IList<ParticleSystem> list5;
			if (!updateParticle)
			{
				IList<ParticleSystem> list4 = k_EmptyParticlesList;
				list5 = list4;
			}
			else
			{
				list5 = GetControllableParticleSystems(gameObject);
			}
			IList<ParticleSystem> particleSystems = list5;
			UpdateDurationAndLoopFlag(directors, particleSystems);
			PlayableDirector component = go.GetComponent<PlayableDirector>();
			if (component != null)
			{
				m_ControlDirectorAsset = component.playableAsset;
			}
			if (go == gameObject && prefabGameObject == null)
			{
				Debug.LogWarningFormat("Control Playable ({0}) is referencing the same PlayableDirector component than the one in which it is playing.", base.name);
				active = false;
				if (!searchHierarchy)
				{
					updateDirector = false;
				}
			}
			if (active)
			{
				CreateActivationPlayable(gameObject, graph, list);
			}
			if (updateDirector)
			{
				SearchHierarchyAndConnectDirector(directors, graph, list, prefabGameObject != null);
			}
			if (updateParticle)
			{
				SearchHierarchyAndConnectParticleSystem(particleSystems, graph, list);
			}
			if (updateITimeControl)
			{
				SearchHierarchyAndConnectControlableScripts(GetControlableScripts(gameObject), graph, list);
			}
			playable = ConnectPlayablesToMixer(graph, list);
		}
		if (prefabGameObject != null)
		{
			s_CreatedPrefabs.Remove(prefabGameObject);
		}
		if (!playable.IsValid())
		{
			playable = Playable.Create(graph);
		}
		return playable;
	}

	private static Playable ConnectPlayablesToMixer(PlayableGraph graph, List<Playable> playables)
	{
		Playable playable = Playable.Create(graph, playables.Count);
		for (int i = 0; i != playables.Count; i++)
		{
			ConnectMixerAndPlayable(graph, playable, playables[i], i);
		}
		playable.SetPropagateSetTime(value: true);
		return playable;
	}

	private void CreateActivationPlayable(GameObject root, PlayableGraph graph, List<Playable> outplayables)
	{
		ScriptPlayable<ActivationControlPlayable> scriptPlayable = ActivationControlPlayable.Create(graph, root, postPlayback);
		if (scriptPlayable.IsValid())
		{
			outplayables.Add(scriptPlayable);
		}
	}

	private void SearchHierarchyAndConnectParticleSystem(IEnumerable<ParticleSystem> particleSystems, PlayableGraph graph, List<Playable> outplayables)
	{
		foreach (ParticleSystem particleSystem in particleSystems)
		{
			if (particleSystem != null)
			{
				controllingParticles = true;
				outplayables.Add(ParticleControlPlayable.Create(graph, particleSystem, particleRandomSeed));
			}
		}
	}

	private void SearchHierarchyAndConnectDirector(IEnumerable<PlayableDirector> directors, PlayableGraph graph, List<Playable> outplayables, bool disableSelfReferences)
	{
		foreach (PlayableDirector director in directors)
		{
			if (director != null)
			{
				if (director.playableAsset != m_ControlDirectorAsset)
				{
					outplayables.Add(DirectorControlPlayable.Create(graph, director));
					controllingDirectors = true;
				}
				else if (disableSelfReferences)
				{
					director.enabled = false;
				}
			}
		}
	}

	private static void SearchHierarchyAndConnectControlableScripts(IEnumerable<MonoBehaviour> controlableScripts, PlayableGraph graph, List<Playable> outplayables)
	{
		foreach (MonoBehaviour controlableScript in controlableScripts)
		{
			outplayables.Add(TimeControlPlayable.Create(graph, (ITimeControl)controlableScript));
		}
	}

	private static void ConnectMixerAndPlayable(PlayableGraph graph, Playable mixer, Playable playable, int portIndex)
	{
		graph.Connect(playable, 0, mixer, portIndex);
		mixer.SetInputWeight(playable, 1f);
	}

	internal IList<T> GetComponent<T>(GameObject gameObject)
	{
		List<T> list = new List<T>();
		if (gameObject != null)
		{
			if (searchHierarchy)
			{
				gameObject.GetComponentsInChildren(includeInactive: true, list);
			}
			else
			{
				gameObject.GetComponents(list);
			}
		}
		return list;
	}

	internal static IEnumerable<MonoBehaviour> GetControlableScripts(GameObject root)
	{
		if (root == null)
		{
			yield break;
		}
		MonoBehaviour[] componentsInChildren = root.GetComponentsInChildren<MonoBehaviour>();
		foreach (MonoBehaviour monoBehaviour in componentsInChildren)
		{
			if (monoBehaviour is ITimeControl)
			{
				yield return monoBehaviour;
			}
		}
	}

	internal void UpdateDurationAndLoopFlag(IList<PlayableDirector> directors, IList<ParticleSystem> particleSystems)
	{
		if (directors.Count == 0 && particleSystems.Count == 0)
		{
			return;
		}
		double num = double.NegativeInfinity;
		bool flag = false;
		foreach (PlayableDirector director in directors)
		{
			if (director.playableAsset != null)
			{
				double num2 = director.playableAsset.duration;
				if (director.playableAsset is TimelineAsset && num2 > 0.0)
				{
					num2 = (double)((DiscreteTime)num2).OneTickAfter();
				}
				num = Math.Max(num, num2);
				flag = flag || director.extrapolationMode == DirectorWrapMode.Loop;
			}
		}
		foreach (ParticleSystem particleSystem in particleSystems)
		{
			num = Math.Max(num, particleSystem.main.duration);
			flag = flag || particleSystem.main.loop;
		}
		m_Duration = (double.IsNegativeInfinity(num) ? PlayableBinding.DefaultDuration : num);
		m_SupportLoop = flag;
	}

	private IList<ParticleSystem> GetControllableParticleSystems(GameObject go)
	{
		List<ParticleSystem> list = new List<ParticleSystem>();
		if (searchHierarchy || go.GetComponent<ParticleSystem>() != null)
		{
			GetControllableParticleSystems(go.transform, list, s_SubEmitterCollector);
			s_SubEmitterCollector.Clear();
		}
		return list;
	}

	private static void GetControllableParticleSystems(Transform t, ICollection<ParticleSystem> roots, HashSet<ParticleSystem> subEmitters)
	{
		ParticleSystem component = t.GetComponent<ParticleSystem>();
		if (component != null && !subEmitters.Contains(component))
		{
			roots.Add(component);
			CacheSubEmitters(component, subEmitters);
		}
		for (int i = 0; i < t.childCount; i++)
		{
			GetControllableParticleSystems(t.GetChild(i), roots, subEmitters);
		}
	}

	private static void CacheSubEmitters(ParticleSystem ps, HashSet<ParticleSystem> subEmitters)
	{
		if (!(ps == null))
		{
			for (int i = 0; i < ps.subEmitters.subEmittersCount; i++)
			{
				subEmitters.Add(ps.subEmitters.GetSubEmitterSystem(i));
			}
		}
	}

	public void GatherProperties(PlayableDirector director, IPropertyCollector driver)
	{
		if (director == null || s_ProcessedDirectors.Contains(director))
		{
			return;
		}
		s_ProcessedDirectors.Add(director);
		GameObject gameObject = sourceGameObject.Resolve(director);
		if (gameObject != null)
		{
			if (updateParticle)
			{
				PreviewParticles(driver, gameObject.GetComponentsInChildren<ParticleSystem>(includeInactive: true));
			}
			if (active)
			{
				PreviewActivation(driver, new GameObject[1] { gameObject });
			}
			if (updateITimeControl)
			{
				PreviewTimeControl(driver, director, GetControlableScripts(gameObject));
			}
			if (updateDirector)
			{
				PreviewDirectors(driver, GetComponent<PlayableDirector>(gameObject));
			}
		}
		s_ProcessedDirectors.Remove(director);
	}

	internal static void PreviewParticles(IPropertyCollector driver, IEnumerable<ParticleSystem> particles)
	{
		foreach (ParticleSystem particle in particles)
		{
			driver.AddFromName<ParticleSystem>(particle.gameObject, "randomSeed");
			driver.AddFromName<ParticleSystem>(particle.gameObject, "autoRandomSeed");
		}
	}

	internal static void PreviewActivation(IPropertyCollector driver, IEnumerable<GameObject> objects)
	{
		foreach (GameObject @object in objects)
		{
			driver.AddFromName(@object, "m_IsActive");
		}
	}

	internal static void PreviewTimeControl(IPropertyCollector driver, PlayableDirector director, IEnumerable<MonoBehaviour> scripts)
	{
		foreach (MonoBehaviour script in scripts)
		{
			if (script is IPropertyPreview propertyPreview)
			{
				propertyPreview.GatherProperties(director, driver);
			}
			else
			{
				driver.AddFromComponent(script.gameObject, script);
			}
		}
	}

	internal static void PreviewDirectors(IPropertyCollector driver, IEnumerable<PlayableDirector> directors)
	{
		foreach (PlayableDirector director in directors)
		{
			if (!(director == null))
			{
				TimelineAsset timelineAsset = director.playableAsset as TimelineAsset;
				if (!(timelineAsset == null))
				{
					timelineAsset.GatherProperties(director, driver);
				}
			}
		}
	}
}
[TrackClipType(typeof(ControlPlayableAsset), false)]
[ExcludeFromPreset]
public class ControlTrack : TrackAsset
{
}
internal struct DiscreteTime : IComparable
{
	private const double k_Tick = 1E-12;

	public static readonly DiscreteTime kMaxTime = new DiscreteTime(long.MaxValue);

	private readonly long m_DiscreteTime;

	public static double tickValue => 1E-12;

	public DiscreteTime(DiscreteTime time)
	{
		m_DiscreteTime = time.m_DiscreteTime;
	}

	private DiscreteTime(long time)
	{
		m_DiscreteTime = time;
	}

	public DiscreteTime(double time)
	{
		m_DiscreteTime = DoubleToDiscreteTime(time);
	}

	public DiscreteTime(float time)
	{
		m_DiscreteTime = FloatToDiscreteTime(time);
	}

	public DiscreteTime(int time)
	{
		m_DiscreteTime = IntToDiscreteTime(time);
	}

	public DiscreteTime(int frame, double fps)
	{
		m_DiscreteTime = DoubleToDiscreteTime((double)frame * fps);
	}

	public DiscreteTime OneTickBefore()
	{
		return new DiscreteTime(m_DiscreteTime - 1);
	}

	public DiscreteTime OneTickAfter()
	{
		return new DiscreteTime(m_DiscreteTime + 1);
	}

	public long GetTick()
	{
		return m_DiscreteTime;
	}

	public static DiscreteTime FromTicks(long ticks)
	{
		return new DiscreteTime(ticks);
	}

	public int CompareTo(object obj)
	{
		if (obj is DiscreteTime)
		{
			long discreteTime = m_DiscreteTime;
			return discreteTime.CompareTo(((DiscreteTime)obj).m_DiscreteTime);
		}
		return 1;
	}

	public bool Equals(DiscreteTime other)
	{
		return m_DiscreteTime == other.m_DiscreteTime;
	}

	public override bool Equals(object obj)
	{
		if (obj is DiscreteTime)
		{
			return Equals((DiscreteTime)obj);
		}
		return false;
	}

	private static long DoubleToDiscreteTime(double time)
	{
		double num = time / 1E-12 + 0.5;
		if (num < 9.223372036854776E+18 && num > -9.223372036854776E+18)
		{
			return (long)num;
		}
		throw new ArgumentOutOfRangeException("Time is over the discrete range.");
	}

	private static long FloatToDiscreteTime(float time)
	{
		float num = time / 1E-12f + 0.5f;
		if (num < 9.223372E+18f && num > -9.223372E+18f)
		{
			return (long)num;
		}
		throw new ArgumentOutOfRangeException("Time is over the discrete range.");
	}

	private static long IntToDiscreteTime(int time)
	{
		return DoubleToDiscreteTime(time);
	}

	private static double ToDouble(long time)
	{
		return (double)time * 1E-12;
	}

	private static float ToFloat(long time)
	{
		return (float)ToDouble(time);
	}

	public static explicit operator double(DiscreteTime b)
	{
		return ToDouble(b.m_DiscreteTime);
	}

	public static explicit operator float(DiscreteTime b)
	{
		return ToFloat(b.m_DiscreteTime);
	}

	public static explicit operator long(DiscreteTime b)
	{
		return b.m_DiscreteTime;
	}

	public static explicit operator DiscreteTime(double time)
	{
		return new DiscreteTime(time);
	}

	public static explicit operator DiscreteTime(float time)
	{
		return new DiscreteTime(time);
	}

	public static implicit operator DiscreteTime(int time)
	{
		return new DiscreteTime(time);
	}

	public static explicit operator DiscreteTime(long time)
	{
		return new DiscreteTime(time);
	}

	public static bool operator ==(DiscreteTime lhs, DiscreteTime rhs)
	{
		return lhs.m_DiscreteTime == rhs.m_DiscreteTime;
	}

	public static bool operator !=(DiscreteTime lhs, DiscreteTime rhs)
	{
		return !(lhs == rhs);
	}

	public static bool operator >(DiscreteTime lhs, DiscreteTime rhs)
	{
		return lhs.m_DiscreteTime > rhs.m_DiscreteTime;
	}

	public static bool operator <(DiscreteTime lhs, DiscreteTime rhs)
	{
		return lhs.m_DiscreteTime < rhs.m_DiscreteTime;
	}

	public static bool operator <=(DiscreteTime lhs, DiscreteTime rhs)
	{
		return lhs.m_DiscreteTime <= rhs.m_DiscreteTime;
	}

	public static bool operator >=(DiscreteTime lhs, DiscreteTime rhs)
	{
		return lhs.m_DiscreteTime >= rhs.m_DiscreteTime;
	}

	public static DiscreteTime operator +(DiscreteTime lhs, DiscreteTime rhs)
	{
		return new DiscreteTime(lhs.m_DiscreteTime + rhs.m_DiscreteTime);
	}

	public static DiscreteTime operator -(DiscreteTime lhs, DiscreteTime rhs)
	{
		return new DiscreteTime(lhs.m_DiscreteTime - rhs.m_DiscreteTime);
	}

	public override string ToString()
	{
		long discreteTime = m_DiscreteTime;
		return discreteTime.ToString();
	}

	public override int GetHashCode()
	{
		long discreteTime = m_DiscreteTime;
		return discreteTime.GetHashCode();
	}

	public static DiscreteTime Min(DiscreteTime lhs, DiscreteTime rhs)
	{
		return new DiscreteTime(Math.Min(lhs.m_DiscreteTime, rhs.m_DiscreteTime));
	}

	public static DiscreteTime Max(DiscreteTime lhs, DiscreteTime rhs)
	{
		return new DiscreteTime(Math.Max(lhs.m_DiscreteTime, rhs.m_DiscreteTime));
	}

	public static double SnapToNearestTick(double time)
	{
		return ToDouble(DoubleToDiscreteTime(time));
	}

	public static float SnapToNearestTick(float time)
	{
		return ToFloat(FloatToDiscreteTime(time));
	}

	public static long GetNearestTick(double time)
	{
		return DoubleToDiscreteTime(time);
	}
}
internal class InfiniteRuntimeClip : RuntimeElement
{
	private Playable m_Playable;

	private static readonly long kIntervalEnd = DiscreteTime.GetNearestTick(TimelineClip.kMaxTimeValue);

	public override long intervalStart => 0L;

	public override long intervalEnd => kIntervalEnd;

	public override bool enable
	{
		set
		{
			if (value)
			{
				m_Playable.Play();
			}
			else
			{
				m_Playable.Pause();
			}
		}
	}

	public InfiniteRuntimeClip(Playable playable)
	{
		m_Playable = playable;
	}

	public override void EvaluateAt(double localTime, FrameData frameData)
	{
		m_Playable.SetTime(localTime);
	}

	public override void DisableAt(double localTime, double rootDuration, FrameData frameData)
	{
		m_Playable.SetTime(localTime);
		enable = false;
	}
}
internal interface IInterval
{
	long intervalStart { get; }

	long intervalEnd { get; }
}
internal struct IntervalTreeNode
{
	public long center;

	public int first;

	public int last;

	public int left;

	public int right;
}
internal class IntervalTree<T> where T : IInterval
{
	internal struct Entry
	{
		public long intervalStart;

		public long intervalEnd;

		public T item;
	}

	private const int kMinNodeSize = 10;

	private const int kInvalidNode = -1;

	private const long kCenterUnknown = long.MaxValue;

	private readonly List<Entry> m_Entries = new List<Entry>();

	private readonly List<IntervalTreeNode> m_Nodes = new List<IntervalTreeNode>();

	public bool dirty { get; internal set; }

	public void Add(T item)
	{
		if (item != null)
		{
			m_Entries.Add(new Entry
			{
				intervalStart = item.intervalStart,
				intervalEnd = item.intervalEnd,
				item = item
			});
			dirty = true;
		}
	}

	public void IntersectsWith(long value, List<T> results)
	{
		if (m_Entries.Count != 0)
		{
			if (dirty)
			{
				Rebuild();
				dirty = false;
			}
			if (m_Nodes.Count > 0)
			{
				Query(m_Nodes[0], value, results);
			}
		}
	}

	public void IntersectsWithRange(long start, long end, List<T> results)
	{
		if (start <= end && m_Entries.Count != 0)
		{
			if (dirty)
			{
				Rebuild();
				dirty = false;
			}
			if (m_Nodes.Count > 0)
			{
				QueryRange(m_Nodes[0], start, end, results);
			}
		}
	}

	public void UpdateIntervals()
	{
		bool flag = false;
		for (int i = 0; i < m_Entries.Count; i++)
		{
			Entry entry = m_Entries[i];
			long intervalStart = entry.item.intervalStart;
			long intervalEnd = entry.item.intervalEnd;
			flag |= entry.intervalStart != intervalStart;
			flag |= entry.intervalEnd != intervalEnd;
			m_Entries[i] = new Entry
			{
				intervalStart = intervalStart,
				intervalEnd = intervalEnd,
				item = entry.item
			};
		}
		dirty |= flag;
	}

	private void Query(IntervalTreeNode intervalTreeNode, long value, List<T> results)
	{
		for (int i = intervalTreeNode.first; i <= intervalTreeNode.last; i++)
		{
			Entry entry = m_Entries[i];
			if (value >= entry.intervalStart && value < entry.intervalEnd)
			{
				results.Add(entry.item);
			}
		}
		if (intervalTreeNode.center != long.MaxValue)
		{
			if (intervalTreeNode.left != -1 && value < intervalTreeNode.center)
			{
				Query(m_Nodes[intervalTreeNode.left], value, results);
			}
			if (intervalTreeNode.right != -1 && value > intervalTreeNode.center)
			{
				Query(m_Nodes[intervalTreeNode.right], value, results);
			}
		}
	}

	private void QueryRange(IntervalTreeNode intervalTreeNode, long start, long end, List<T> results)
	{
		for (int i = intervalTreeNode.first; i <= intervalTreeNode.last; i++)
		{
			Entry entry = m_Entries[i];
			if (end >= entry.intervalStart && start < entry.intervalEnd)
			{
				results.Add(entry.item);
			}
		}
		if (intervalTreeNode.center != long.MaxValue)
		{
			if (intervalTreeNode.left != -1 && start < intervalTreeNode.center)
			{
				QueryRange(m_Nodes[intervalTreeNode.left], start, end, results);
			}
			if (intervalTreeNode.right != -1 && end > intervalTreeNode.center)
			{
				QueryRange(m_Nodes[intervalTreeNode.right], start, end, results);
			}
		}
	}

	private void Rebuild()
	{
		m_Nodes.Clear();
		m_Nodes.Capacity = m_Entries.Capacity;
		Rebuild(0, m_Entries.Count - 1);
	}

	private int Rebuild(int start, int end)
	{
		IntervalTreeNode value = default(IntervalTreeNode);
		if (end - start + 1 < 10)
		{
			value = new IntervalTreeNode
			{
				center = long.MaxValue,
				first = start,
				last = end,
				left = -1,
				right = -1
			};
			m_Nodes.Add(value);
			return m_Nodes.Count - 1;
		}
		long num = long.MaxValue;
		long num2 = long.MinValue;
		for (int i = start; i <= end; i++)
		{
			Entry entry = m_Entries[i];
			num = Math.Min(num, entry.intervalStart);
			num2 = Math.Max(num2, entry.intervalEnd);
		}
		long num3 = (value.center = (num2 + num) / 2);
		int num4 = start;
		int num5 = end;
		while (true)
		{
			if (num4 <= end && m_Entries[num4].intervalEnd < num3)
			{
				num4++;
				continue;
			}
			while (num5 >= start && m_Entries[num5].intervalEnd >= num3)
			{
				num5--;
			}
			if (num4 > num5)
			{
				break;
			}
			Entry value2 = m_Entries[num4];
			Entry value3 = m_Entries[num5];
			m_Entries[num5] = value2;
			m_Entries[num4] = value3;
		}
		value.first = num4;
		num5 = end;
		while (true)
		{
			if (num4 <= end && m_Entries[num4].intervalStart <= num3)
			{
				num4++;
				continue;
			}
			while (num5 >= start && m_Entries[num5].intervalStart > num3)
			{
				num5--;
			}
			if (num4 > num5)
			{
				break;
			}
			Entry value4 = m_Entries[num4];
			Entry value5 = m_Entries[num5];
			m_Entries[num5] = value4;
			m_Entries[num4] = value5;
		}
		value.last = num5;
		m_Nodes.Add(default(IntervalTreeNode));
		int num6 = m_Nodes.Count - 1;
		value.left = -1;
		value.right = -1;
		if (start < value.first)
		{
			value.left = Rebuild(start, value.first - 1);
		}
		if (end > value.last)
		{
			value.right = Rebuild(value.last + 1, end);
		}
		m_Nodes[num6] = value;
		return num6;
	}

	public void Clear()
	{
		m_Entries.Clear();
		m_Nodes.Clear();
	}
}
internal class RuntimeClip : RuntimeClipBase
{
	private TimelineClip m_Clip;

	private Playable m_Playable;

	private Playable m_ParentMixer;

	public override double start => m_Clip.extrapolatedStart;

	public override double duration => m_Clip.extrapolatedDuration;

	public TimelineClip clip => m_Clip;

	public Playable mixer => m_ParentMixer;

	public Playable playable => m_Playable;

	public override bool enable
	{
		set
		{
			if (value && m_Playable.GetPlayState() != PlayState.Playing)
			{
				m_Playable.Play();
				SetTime(m_Clip.clipIn);
			}
			else if (!value && m_Playable.GetPlayState() != PlayState.Paused)
			{
				m_Playable.Pause();
				if (m_ParentMixer.IsValid())
				{
					m_ParentMixer.SetInputWeight(m_Playable, 0f);
				}
			}
		}
	}

	public RuntimeClip(TimelineClip clip, Playable clipPlayable, Playable parentMixer)
	{
		Create(clip, clipPlayable, parentMixer);
	}

	private void Create(TimelineClip clip, Playable clipPlayable, Playable parentMixer)
	{
		m_Clip = clip;
		m_Playable = clipPlayable;
		m_ParentMixer = parentMixer;
		clipPlayable.Pause();
	}

	public void SetTime(double time)
	{
		m_Playable.SetTime(time);
	}

	public void SetDuration(double duration)
	{
		m_Playable.SetDuration(duration);
	}

	public override void EvaluateAt(double localTime, FrameData frameData)
	{
		enable = true;
		if (frameData.timeLooped)
		{
			SetTime(clip.clipIn);
			SetTime(clip.clipIn);
		}
		float num = 1f;
		num = (clip.IsPreExtrapolatedTime(localTime) ? clip.EvaluateMixIn((float)clip.start) : ((!clip.IsPostExtrapolatedTime(localTime)) ? (clip.EvaluateMixIn(localTime) * clip.EvaluateMixOut(localTime)) : clip.EvaluateMixOut((float)clip.end)));
		if (mixer.IsValid())
		{
			mixer.SetInputWeight(playable, num);
		}
		double num2 = clip.ToLocalTime(localTime);
		if (num2 >= (0.0 - DiscreteTime.tickValue) / 2.0)
		{
			SetTime(num2);
		}
		SetDuration(clip.extrapolatedDuration);
	}

	public override void DisableAt(double localTime, double rootDuration, FrameData frameData)
	{
		double num = Math.Min(localTime, (double)DiscreteTime.FromTicks(intervalEnd));
		if (frameData.timeLooped)
		{
			num = Math.Min(num, rootDuration);
		}
		double num2 = clip.ToLocalTime(num);
		if (num2 > (0.0 - DiscreteTime.tickValue) / 2.0)
		{
			SetTime(num2);
		}
		enable = false;
	}
}
internal abstract class RuntimeClipBase : RuntimeElement
{
	public abstract double start { get; }

	public abstract double duration { get; }

	public override long intervalStart => DiscreteTime.GetNearestTick(start);

	public override long intervalEnd => DiscreteTime.GetNearestTick(start + duration);
}
internal abstract class RuntimeElement : IInterval
{
	public abstract long intervalStart { get; }

	public abstract long intervalEnd { get; }

	public int intervalBit { get; set; }

	public abstract bool enable { set; }

	public abstract void EvaluateAt(double localTime, FrameData frameData);

	public abstract void DisableAt(double localTime, double rootDuration, FrameData frameData);
}
internal class ScheduleRuntimeClip : RuntimeClipBase
{
	private TimelineClip m_Clip;

	private Playable m_Playable;

	private Playable m_ParentMixer;

	private double m_StartDelay;

	private double m_FinishTail;

	private bool m_Started;

	public override double start => Math.Max(0.0, m_Clip.start - m_StartDelay);

	public override double duration => m_Clip.duration + m_FinishTail + m_Clip.start - start;

	public TimelineClip clip => m_Clip;

	public Playable mixer => m_ParentMixer;

	public Playable playable => m_Playable;

	public override bool enable
	{
		set
		{
			if (value && m_Playable.GetPlayState() != PlayState.Playing)
			{
				m_Playable.Play();
			}
			else if (!value && m_Playable.GetPlayState() != PlayState.Paused)
			{
				m_Playable.Pause();
				if (m_ParentMixer.IsValid())
				{
					m_ParentMixer.SetInputWeight(m_Playable, 0f);
				}
			}
			m_Started &= value;
		}
	}

	public void SetTime(double time)
	{
		m_Playable.SetTime(time);
	}

	public ScheduleRuntimeClip(TimelineClip clip, Playable clipPlayable, Playable parentMixer, double startDelay = 0.2, double finishTail = 0.1)
	{
		Create(clip, clipPlayable, parentMixer, startDelay, finishTail);
	}

	private void Create(TimelineClip clip, Playable clipPlayable, Playable parentMixer, double startDelay, double finishTail)
	{
		m_Clip = clip;
		m_Playable = clipPlayable;
		m_ParentMixer = parentMixer;
		m_StartDelay = startDelay;
		m_FinishTail = finishTail;
		clipPlayable.Pause();
	}

	public override void EvaluateAt(double localTime, FrameData frameData)
	{
		if (frameData.timeHeld)
		{
			enable = false;
			return;
		}
		bool flag = frameData.seekOccurred || frameData.timeLooped || frameData.evaluationType == FrameData.EvaluationType.Evaluate;
		if (localTime > start + duration - m_FinishTail)
		{
			return;
		}
		float weight = clip.EvaluateMixIn(localTime) * clip.EvaluateMixOut(localTime);
		if (mixer.IsValid())
		{
			mixer.SetInputWeight(playable, weight);
		}
		if (!m_Started || flag)
		{
			double startTime = clip.ToLocalTime(Math.Max(localTime, clip.start));
			double startDelay = Math.Max(clip.start - localTime, 0.0) * clip.timeScale;
			double num = m_Clip.duration * clip.timeScale;
			if (m_Playable.IsPlayableOfType<AudioClipPlayable>())
			{
				((AudioClipPlayable)m_Playable).Seek(startTime, startDelay, num);
			}
			m_Started = true;
		}
	}

	public override void DisableAt(double localTime, double rootDuration, FrameData frameData)
	{
		enable = false;
	}
}
public interface IMarker
{
	double time { get; set; }

	TrackAsset parent { get; }

	void Initialize(TrackAsset parent);
}
public interface INotificationOptionProvider
{
	NotificationFlags flags { get; }
}
public abstract class Marker : ScriptableObject, IMarker
{
	[SerializeField]
	[TimeField(TimeFieldAttribute.UseEditMode.ApplyEditMode)]
	[Tooltip("Time for the marker")]
	private double m_Time;

	public TrackAsset parent { get; private set; }

	public double time
	{
		get
		{
			return m_Time;
		}
		set
		{
			m_Time = Math.Max(value, 0.0);
		}
	}

	void IMarker.Initialize(TrackAsset parentTrack)
	{
		if (parent == null)
		{
			parent = parentTrack;
			try
			{
				OnInitialize(parentTrack);
			}
			catch (Exception ex)
			{
				Debug.LogError(ex.Message, this);
			}
		}
	}

	public virtual void OnInitialize(TrackAsset aPent)
	{
	}
}
[Serializable]
internal struct MarkerList : ISerializationCallbackReceiver
{
	[SerializeField]
	[HideInInspector]
	private List<ScriptableObject> m_Objects;

	[NonSerialized]
	[HideInInspector]
	private List<IMarker> m_Cache;

	private bool m_CacheDirty;

	private bool m_HasNotifications;

	public List<IMarker> markers
	{
		get
		{
			BuildCache();
			return m_Cache;
		}
	}

	public int Count => markers.Count;

	public IMarker this[int idx] => markers[idx];

	public MarkerList(int capacity)
	{
		m_Objects = new List<ScriptableObject>(capacity);
		m_Cache = new List<IMarker>(capacity);
		m_CacheDirty = true;
		m_HasNotifications = false;
	}

	public void Add(ScriptableObject item)
	{
		if (!(item == null))
		{
			m_Objects.Add(item);
			m_CacheDirty = true;
		}
	}

	public bool Remove(IMarker item)
	{
		if (!(item is ScriptableObject))
		{
			throw new InvalidOperationException("Supplied type must be a ScriptableObject");
		}
		return Remove((ScriptableObject)item, item.parent.timelineAsset, item.parent);
	}

	public bool Remove(ScriptableObject item, TimelineAsset timelineAsset, PlayableAsset thingToDirty)
	{
		if (!m_Objects.Contains(item))
		{
			return false;
		}
		m_Objects.Remove(item);
		m_CacheDirty = true;
		TimelineUndo.PushDestroyUndo(timelineAsset, thingToDirty, item);
		return true;
	}

	public void Clear()
	{
		m_Objects.Clear();
		m_CacheDirty = true;
	}

	public bool Contains(ScriptableObject item)
	{
		return m_Objects.Contains(item);
	}

	public IEnumerable<IMarker> GetMarkers()
	{
		return markers;
	}

	public List<ScriptableObject> GetRawMarkerList()
	{
		return m_Objects;
	}

	public IMarker CreateMarker(Type type, double time, TrackAsset owner)
	{
		if (!typeof(ScriptableObject).IsAssignableFrom(type) || !typeof(IMarker).IsAssignableFrom(type))
		{
			throw new InvalidOperationException("The requested type needs to inherit from ScriptableObject and implement IMarker");
		}
		if (!owner.supportsNotifications && typeof(INotification).IsAssignableFrom(type))
		{
			throw new InvalidOperationException("Markers implementing the INotification interface cannot be added on tracks that do not support notifications");
		}
		ScriptableObject scriptableObject = ScriptableObject.CreateInstance(type);
		IMarker obj = (IMarker)scriptableObject;
		obj.time = time;
		TimelineCreateUtilities.SaveAssetIntoObject(scriptableObject, owner);
		Add(scriptableObject);
		obj.Initialize(owner);
		return obj;
	}

	public bool HasNotifications()
	{
		BuildCache();
		return m_HasNotifications;
	}

	void ISerializationCallbackReceiver.OnBeforeSerialize()
	{
	}

	void ISerializationCallbackReceiver.OnAfterDeserialize()
	{
		m_CacheDirty = true;
	}

	private void BuildCache()
	{
		if (!m_CacheDirty)
		{
			return;
		}
		m_Cache = new List<IMarker>(m_Objects.Count);
		m_HasNotifications = false;
		foreach (ScriptableObject @object in m_Objects)
		{
			if (@object != null)
			{
				m_Cache.Add(@object as IMarker);
				if (@object is INotification)
				{
					m_HasNotifications = true;
				}
			}
		}
		m_CacheDirty = false;
	}
}
[Serializable]
[TrackBindingType(typeof(GameObject))]
[HideInMenu]
[ExcludeFromPreset]
public class MarkerTrack : TrackAsset
{
	public override IEnumerable<PlayableBinding> outputs
	{
		get
		{
			if (!(this == base.timelineAsset?.markerTrack))
			{
				return base.outputs;
			}
			return new List<PlayableBinding> { ScriptPlayableBinding.Create(base.name, null, typeof(GameObject)) };
		}
	}
}
internal class CustomSignalEventDrawer : PropertyAttribute
{
}
[AssetFileNameExtension("signal", new string[] { })]
public class SignalAsset : ScriptableObject
{
	internal static event Action<SignalAsset> OnEnableCallback;

	private void OnEnable()
	{
		if (SignalAsset.OnEnableCallback != null)
		{
			SignalAsset.OnEnableCallback(this);
		}
	}
}
[Serializable]
[CustomStyle("SignalEmitter")]
[ExcludeFromPreset]
public class SignalEmitter : Marker, INotification, INotificationOptionProvider
{
	[SerializeField]
	private bool m_Retroactive;

	[SerializeField]
	private bool m_EmitOnce;

	[SerializeField]
	private SignalAsset m_Asset;

	public bool retroactive
	{
		get
		{
			return m_Retroactive;
		}
		set
		{
			m_Retroactive = value;
		}
	}

	public bool emitOnce
	{
		get
		{
			return m_EmitOnce;
		}
		set
		{
			m_EmitOnce = value;
		}
	}

	public SignalAsset asset
	{
		get
		{
			return m_Asset;
		}
		set
		{
			m_Asset = value;
		}
	}

	PropertyName INotification.id
	{
		get
		{
			if (m_Asset != null)
			{
				return new PropertyName(m_Asset.name);
			}
			return new PropertyName(string.Empty);
		}
	}

	NotificationFlags INotificationOptionProvider.flags => (NotificationFlags)((retroactive ? 2 : 0) | (emitOnce ? 4 : 0) | 1);
}
public class SignalReceiver : MonoBehaviour, INotificationReceiver
{
	[Serializable]
	private class EventKeyValue
	{
		[SerializeField]
		private List<SignalAsset> m_Signals = new List<SignalAsset>();

		[SerializeField]
		[CustomSignalEventDrawer]
		private List<UnityEvent> m_Events = new List<UnityEvent>();

		public List<SignalAsset> signals => m_Signals;

		public List<UnityEvent> events => m_Events;

		public bool TryGetValue(SignalAsset key, out UnityEvent value)
		{
			int num = m_Signals.IndexOf(key);
			if (num != -1)
			{
				value = m_Events[num];
				return true;
			}
			value = null;
			return false;
		}

		public void Append(SignalAsset key, UnityEvent value)
		{
			m_Signals.Add(key);
			m_Events.Add(value);
		}

		public void Remove(int idx)
		{
			if (idx != -1)
			{
				m_Signals.RemoveAt(idx);
				m_Events.RemoveAt(idx);
			}
		}

		public void Remove(SignalAsset key)
		{
			int num = m_Signals.IndexOf(key);
			if (num != -1)
			{
				m_Signals.RemoveAt(num);
				m_Events.RemoveAt(num);
			}
		}
	}

	[SerializeField]
	private EventKeyValue m_Events = new EventKeyValue();

	public void OnNotify(Playable origin, INotification notification, object context)
	{
		SignalEmitter signalEmitter = notification as SignalEmitter;
		if (signalEmitter != null && signalEmitter.asset != null && m_Events.TryGetValue(signalEmitter.asset, out var value))
		{
			value?.Invoke();
		}
	}

	public void AddReaction(SignalAsset asset, UnityEvent reaction)
	{
		if (asset == null)
		{
			throw new ArgumentNullException("asset");
		}
		if (m_Events.signals.Contains(asset))
		{
			throw new ArgumentException("SignalAsset already used.");
		}
		m_Events.Append(asset, reaction);
	}

	public int AddEmptyReaction(UnityEvent reaction)
	{
		m_Events.Append(null, reaction);
		return m_Events.events.Count - 1;
	}

	public void Remove(SignalAsset asset)
	{
		if (!m_Events.signals.Contains(asset))
		{
			throw new ArgumentException("The SignalAsset is not registered with this receiver.");
		}
		m_Events.Remove(asset);
	}

	public IEnumerable<SignalAsset> GetRegisteredSignals()
	{
		return m_Events.signals;
	}

	public UnityEvent GetReaction(SignalAsset key)
	{
		if (m_Events.TryGetValue(key, out var value))
		{
			return value;
		}
		return null;
	}

	public int Count()
	{
		return m_Events.signals.Count;
	}

	public void ChangeSignalAtIndex(int idx, SignalAsset newKey)
	{
		if (idx < 0 || idx > m_Events.signals.Count - 1)
		{
			throw new IndexOutOfRangeException();
		}
		if (!(m_Events.signals[idx] == newKey))
		{
			bool flag = m_Events.signals.Contains(newKey);
			if (newKey == null || m_Events.signals[idx] == null || !flag)
			{
				m_Events.signals[idx] = newKey;
			}
			if (newKey != null && flag)
			{
				throw new ArgumentException("SignalAsset already used.");
			}
		}
	}

	public void RemoveAtIndex(int idx)
	{
		if (idx < 0 || idx > m_Events.signals.Count - 1)
		{
			throw new IndexOutOfRangeException();
		}
		m_Events.Remove(idx);
	}

	public void ChangeReactionAtIndex(int idx, UnityEvent reaction)
	{
		if (idx < 0 || idx > m_Events.events.Count - 1)
		{
			throw new IndexOutOfRangeException();
		}
		m_Events.events[idx] = reaction;
	}

	public UnityEvent GetReactionAtIndex(int idx)
	{
		if (idx < 0 || idx > m_Events.events.Count - 1)
		{
			throw new IndexOutOfRangeException();
		}
		return m_Events.events[idx];
	}

	public SignalAsset GetSignalAssetAtIndex(int idx)
	{
		if (idx < 0 || idx > m_Events.signals.Count - 1)
		{
			throw new IndexOutOfRangeException();
		}
		return m_Events.signals[idx];
	}

	private void OnEnable()
	{
	}
}
[Serializable]
[TrackBindingType(typeof(SignalReceiver))]
[TrackColor(0.25f, 0.25f, 0.25f)]
[ExcludeFromPreset]
public class SignalTrack : MarkerTrack
{
}
public static class TrackAssetExtensions
{
	public static GroupTrack GetGroup(this TrackAsset asset)
	{
		if (asset == null)
		{
			return null;
		}
		return asset.parent as GroupTrack;
	}

	public static void SetGroup(this TrackAsset asset, GroupTrack group)
	{
		if (asset == null || asset == group || asset.parent == group)
		{
			return;
		}
		if (group != null && asset.timelineAsset != group.timelineAsset)
		{
			throw new InvalidOperationException("Cannot assign to a group in a different timeline");
		}
		TimelineAsset timelineAsset = asset.timelineAsset;
		TrackAsset trackAsset = asset.parent as TrackAsset;
		TimelineAsset timelineAsset2 = asset.parent as TimelineAsset;
		if (trackAsset != null || timelineAsset2 != null)
		{
			if (timelineAsset2 != null)
			{
				timelineAsset2.RemoveTrack(asset);
			}
			else
			{
				trackAsset.RemoveSubTrack(asset);
			}
		}
		if (group == null)
		{
			asset.parent = asset.timelineAsset;
			timelineAsset.AddTrackInternal(asset);
		}
		else
		{
			group.AddChild(asset);
		}
	}
}
[Serializable]
[TrackClipType(typeof(TrackAsset))]
[SupportsChildTracks(null, int.MaxValue)]
[ExcludeFromPreset]
public class GroupTrack : TrackAsset
{
	public override IEnumerable<PlayableBinding> outputs => PlayableBinding.None;

	internal override bool CanCompileClips()
	{
		return false;
	}
}
public interface ILayerable
{
	Playable CreateLayerMixer(PlayableGraph graph, GameObject go, int inputCount);
}
public class ActivationControlPlayable : PlayableBehaviour
{
	public enum PostPlaybackState
	{
		Active,
		Inactive,
		Revert
	}

	private enum InitialState
	{
		Unset,
		Active,
		Inactive
	}

	public GameObject gameObject;

	public PostPlaybackState postPlayback = PostPlaybackState.Revert;

	private InitialState m_InitialState;

	public static ScriptPlayable<ActivationControlPlayable> Create(PlayableGraph graph, GameObject gameObject, PostPlaybackState postPlaybackState)
	{
		if (gameObject == null)
		{
			return ScriptPlayable<ActivationControlPlayable>.Null;
		}
		ScriptPlayable<ActivationControlPlayable> result = ScriptPlayable<ActivationControlPlayable>.Create(graph);
		ActivationControlPlayable behaviour = result.GetBehaviour();
		behaviour.gameObject = gameObject;
		behaviour.postPlayback = postPlaybackState;
		return result;
	}

	public override void OnBehaviourPlay(Playable playable, FrameData info)
	{
		if (!(gameObject == null))
		{
			gameObject.SetActive(value: true);
		}
	}

	public override void OnBehaviourPause(Playable playable, FrameData info)
	{
		if (gameObject != null && info.effectivePlayState == PlayState.Paused)
		{
			gameObject.SetActive(value: false);
		}
	}

	public override void ProcessFrame(Playable playable, FrameData info, object userData)
	{
		if (gameObject != null)
		{
			gameObject.SetActive(value: true);
		}
	}

	public override void OnGraphStart(Playable playable)
	{
		if (gameObject != null && m_InitialState == InitialState.Unset)
		{
			m_InitialState = (gameObject.activeSelf ? InitialState.Active : InitialState.Inactive);
		}
	}

	public override void OnPlayableDestroy(Playable playable)
	{
		if (!(gameObject == null) && m_InitialState != InitialState.Unset)
		{
			switch (postPlayback)
			{
			case PostPlaybackState.Active:
				gameObject.SetActive(value: true);
				break;
			case PostPlaybackState.Inactive:
				gameObject.SetActive(value: false);
				break;
			case PostPlaybackState.Revert:
				gameObject.SetActive(m_InitialState == InitialState.Active);
				break;
			}
		}
	}
}
[Serializable]
[Obsolete("For best performance use PlayableAsset and PlayableBehaviour.")]
public class BasicPlayableBehaviour : ScriptableObject, IPlayableAsset, IPlayableBehaviour
{
	public virtual double duration => PlayableBinding.DefaultDuration;

	public virtual IEnumerable<PlayableBinding> outputs => PlayableBinding.None;

	public virtual void OnGraphStart(Playable playable)
	{
	}

	public virtual void OnGraphStop(Playable playable)
	{
	}

	public virtual void OnPlayableCreate(Playable playable)
	{
	}

	public virtual void OnPlayableDestroy(Playable playable)
	{
	}

	public virtual void OnBehaviourPlay(Playable playable, FrameData info)
	{
	}

	public virtual void OnBehaviourPause(Playable playable, FrameData info)
	{
	}

	public virtual void PrepareFrame(Playable playable, FrameData info)
	{
	}

	public virtual void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
	}

	public virtual Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		return ScriptPlayable<BasicPlayableBehaviour>.Create(graph, this);
	}
}
public class DirectorControlPlayable : PlayableBehaviour
{
	public PlayableDirector director;

	private bool m_SyncTime;

	private double m_AssetDuration = double.MaxValue;

	public static ScriptPlayable<DirectorControlPlayable> Create(PlayableGraph graph, PlayableDirector director)
	{
		if (director == null)
		{
			return ScriptPlayable<DirectorControlPlayable>.Null;
		}
		ScriptPlayable<DirectorControlPlayable> result = ScriptPlayable<DirectorControlPlayable>.Create(graph);
		result.GetBehaviour().director = director;
		return result;
	}

	public override void OnPlayableDestroy(Playable playable)
	{
		if (director != null && director.playableAsset != null)
		{
			director.Stop();
		}
	}

	public override void PrepareFrame(Playable playable, FrameData info)
	{
		if (!(director == null) && director.isActiveAndEnabled && !(director.playableAsset == null))
		{
			m_SyncTime |= info.evaluationType == FrameData.EvaluationType.Evaluate || DetectDiscontinuity(playable, info);
			SyncSpeed(info.effectiveSpeed);
			SyncStart(playable.GetGraph(), playable.GetTime());
		}
	}

	public override void OnBehaviourPlay(Playable playable, FrameData info)
	{
		m_SyncTime = true;
		if (director != null && director.playableAsset != null)
		{
			m_AssetDuration = director.playableAsset.duration;
		}
	}

	public override void OnBehaviourPause(Playable playable, FrameData info)
	{
		if (director != null && director.playableAsset != null)
		{
			if (info.effectivePlayState == PlayState.Playing)
			{
				director.Pause();
			}
			else
			{
				director.Stop();
			}
		}
	}

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
		if (director == null || !director.isActiveAndEnabled || director.playableAsset == null)
		{
			return;
		}
		if (m_SyncTime || DetectOutOfSync(playable))
		{
			UpdateTime(playable);
			if (director.playableGraph.IsValid())
			{
				director.playableGraph.Evaluate();
				director.playableGraph.SynchronizeEvaluation(playable.GetGraph());
			}
			else
			{
				director.Evaluate();
			}
		}
		m_SyncTime = false;
		SyncStop(playable.GetGraph(), playable.GetTime());
	}

	private void SyncSpeed(double speed)
	{
		if (!director.playableGraph.IsValid())
		{
			return;
		}
		int rootPlayableCount = director.playableGraph.GetRootPlayableCount();
		for (int i = 0; i < rootPlayableCount; i++)
		{
			Playable rootPlayable = director.playableGraph.GetRootPlayable(i);
			if (rootPlayable.IsValid())
			{
				rootPlayable.SetSpeed(speed);
			}
		}
	}

	private void SyncStart(PlayableGraph graph, double time)
	{
		if (director.state != PlayState.Playing && graph.IsPlaying() && (director.extrapolationMode != DirectorWrapMode.None || !(time > m_AssetDuration)))
		{
			if (graph.IsMatchFrameRateEnabled())
			{
				director.Play(graph.GetFrameRate());
			}
			else
			{
				director.Play();
			}
		}
	}

	private void SyncStop(PlayableGraph graph, double time)
	{
		if (director.state != PlayState.Paused && (!graph.IsPlaying() || (director.extrapolationMode == DirectorWrapMode.None && !(time < m_AssetDuration))) && director.state != PlayState.Paused && ((director.extrapolationMode == DirectorWrapMode.None && time > m_AssetDuration) || !graph.IsPlaying()))
		{
			director.Pause();
		}
	}

	private bool DetectDiscontinuity(Playable playable, FrameData info)
	{
		return Math.Abs(playable.GetTime() - playable.GetPreviousTime() - info.m_DeltaTime * (double)info.m_EffectiveSpeed) > DiscreteTime.tickValue;
	}

	private bool DetectOutOfSync(Playable playable)
	{
		double num = playable.GetTime();
		if (playable.GetTime() >= m_AssetDuration)
		{
			switch (director.extrapolationMode)
			{
			case DirectorWrapMode.None:
				num = m_AssetDuration;
				break;
			case DirectorWrapMode.Hold:
				num = m_AssetDuration;
				break;
			case DirectorWrapMode.Loop:
				num %= m_AssetDuration;
				break;
			}
		}
		if (!Mathf.Approximately((float)num, (float)director.time))
		{
			return true;
		}
		return false;
	}

	private void UpdateTime(Playable playable)
	{
		double num = Math.Max(0.1, director.playableAsset.duration);
		switch (director.extrapolationMode)
		{
		case DirectorWrapMode.Hold:
			director.time = Math.Min(num, Math.Max(0.0, playable.GetTime()));
			break;
		case DirectorWrapMode.Loop:
			director.time = Math.Max(0.0, playable.GetTime() % num);
			break;
		case DirectorWrapMode.None:
			director.time = Math.Min(num, Math.Max(0.0, playable.GetTime()));
			break;
		}
	}
}
public interface ITimeControl
{
	void SetTime(double time);

	void OnControlTimeStart();

	void OnControlTimeStop();
}
[Serializable]
[Flags]
public enum NotificationFlags : short
{
	TriggerInEditMode = 1,
	Retroactive = 2,
	TriggerOnce = 4
}
public class ParticleControlPlayable : PlayableBehaviour
{
	private const float kUnsetTime = float.MaxValue;

	private float m_LastPlayableTime = float.MaxValue;

	private float m_LastParticleTime = float.MaxValue;

	private uint m_RandomSeed = 1u;

	public ParticleSystem particleSystem { get; private set; }

	public static ScriptPlayable<ParticleControlPlayable> Create(PlayableGraph graph, ParticleSystem component, uint randomSeed)
	{
		if (component == null)
		{
			return ScriptPlayable<ParticleControlPlayable>.Null;
		}
		ScriptPlayable<ParticleControlPlayable> result = ScriptPlayable<ParticleControlPlayable>.Create(graph);
		result.GetBehaviour().Initialize(component, randomSeed);
		return result;
	}

	public void Initialize(ParticleSystem ps, uint randomSeed)
	{
		m_RandomSeed = Math.Max(1u, randomSeed);
		particleSystem = ps;
		SetRandomSeed(particleSystem, m_RandomSeed);
	}

	private static void SetRandomSeed(ParticleSystem particleSystem, uint randomSeed)
	{
		if (!(particleSystem == null))
		{
			particleSystem.Stop(withChildren: true, ParticleSystemStopBehavior.StopEmittingAndClear);
			if (particleSystem.useAutoRandomSeed)
			{
				particleSystem.useAutoRandomSeed = false;
				particleSystem.randomSeed = randomSeed;
			}
			for (int i = 0; i < particleSystem.subEmitters.subEmittersCount; i++)
			{
				SetRandomSeed(particleSystem.subEmitters.GetSubEmitterSystem(i), ++randomSeed);
			}
		}
	}

	public override void PrepareFrame(Playable playable, FrameData data)
	{
		if (particleSystem == null || !particleSystem.gameObject.activeInHierarchy)
		{
			m_LastPlayableTime = float.MaxValue;
			return;
		}
		float num = (float)playable.GetTime();
		float time = particleSystem.time;
		if (m_LastPlayableTime > num || !Mathf.Approximately(time, m_LastParticleTime))
		{
			Simulate(num, restart: true);
		}
		else if (m_LastPlayableTime < num)
		{
			Simulate(num - m_LastPlayableTime, restart: false);
		}
		m_LastPlayableTime = num;
		m_LastParticleTime = particleSystem.time;
	}

	public override void OnBehaviourPlay(Playable playable, FrameData info)
	{
		m_LastPlayableTime = float.MaxValue;
	}

	public override void OnBehaviourPause(Playable playable, FrameData info)
	{
		m_LastPlayableTime = float.MaxValue;
	}

	private void Simulate(float time, bool restart)
	{
		float maximumDeltaTime = Time.maximumDeltaTime;
		if (restart)
		{
			particleSystem.Simulate(0f, withChildren: false, restart: true, fixedTimeStep: false);
		}
		while (time > maximumDeltaTime)
		{
			particleSystem.Simulate(maximumDeltaTime, withChildren: false, restart: false, fixedTimeStep: false);
			time -= maximumDeltaTime;
		}
		if (time > 0f)
		{
			particleSystem.Simulate(time, withChildren: false, restart: false, fixedTimeStep: false);
		}
	}
}
public class PrefabControlPlayable : PlayableBehaviour
{
	private GameObject m_Instance;

	public GameObject prefabInstance => m_Instance;

	public static ScriptPlayable<PrefabControlPlayable> Create(PlayableGraph graph, GameObject prefabGameObject, Transform parentTransform)
	{
		if (prefabGameObject == null)
		{
			return ScriptPlayable<PrefabControlPlayable>.Null;
		}
		ScriptPlayable<PrefabControlPlayable> result = ScriptPlayable<PrefabControlPlayable>.Create(graph);
		result.GetBehaviour().Initialize(prefabGameObject, parentTransform);
		return result;
	}

	public GameObject Initialize(GameObject prefabGameObject, Transform parentTransform)
	{
		if (prefabGameObject == null)
		{
			throw new ArgumentNullException("Prefab cannot be null");
		}
		if (m_Instance != null)
		{
			Debug.LogWarningFormat("Prefab Control Playable ({0}) has already been initialized with a Prefab ({1}).", prefabGameObject.name, m_Instance.name);
		}
		else
		{
			m_Instance = Object.Instantiate(prefabGameObject, parentTransform, worldPositionStays: false);
			m_Instance.name = prefabGameObject.name + " [Timeline]";
			m_Instance.SetActive(value: false);
			SetHideFlagsRecursive(m_Instance);
		}
		return m_Instance;
	}

	public override void OnPlayableDestroy(Playable playable)
	{
		if ((bool)m_Instance)
		{
			if (Application.isPlaying)
			{
				Object.Destroy(m_Instance);
			}
			else
			{
				Object.DestroyImmediate(m_Instance);
			}
		}
	}

	public override void OnBehaviourPlay(Playable playable, FrameData info)
	{
		if (!(m_Instance == null))
		{
			m_Instance.SetActive(value: true);
		}
	}

	public override void OnBehaviourPause(Playable playable, FrameData info)
	{
		if (m_Instance != null && info.effectivePlayState == PlayState.Paused)
		{
			m_Instance.SetActive(value: false);
		}
	}

	private static void SetHideFlagsRecursive(GameObject gameObject)
	{
		if (gameObject == null)
		{
			return;
		}
		gameObject.hideFlags = HideFlags.DontSaveInEditor | HideFlags.DontSaveInBuild;
		if (!Application.isPlaying)
		{
			gameObject.hideFlags |= HideFlags.HideInHierarchy;
		}
		foreach (Transform item in gameObject.transform)
		{
			SetHideFlagsRecursive(item.gameObject);
		}
	}
}
public class TimeControlPlayable : PlayableBehaviour
{
	private ITimeControl m_timeControl;

	private bool m_started;

	public static ScriptPlayable<TimeControlPlayable> Create(PlayableGraph graph, ITimeControl timeControl)
	{
		if (timeControl == null)
		{
			return ScriptPlayable<TimeControlPlayable>.Null;
		}
		ScriptPlayable<TimeControlPlayable> result = ScriptPlayable<TimeControlPlayable>.Create(graph);
		result.GetBehaviour().Initialize(timeControl);
		return result;
	}

	public void Initialize(ITimeControl timeControl)
	{
		m_timeControl = timeControl;
	}

	public override void PrepareFrame(Playable playable, FrameData info)
	{
		Debug.Assert(m_started, "PrepareFrame has been called without OnControlTimeStart being called first.");
		if (m_timeControl != null)
		{
			m_timeControl.SetTime(playable.GetTime());
		}
	}

	public override void OnBehaviourPlay(Playable playable, FrameData info)
	{
		if (m_timeControl != null && !m_started)
		{
			m_timeControl.OnControlTimeStart();
			m_started = true;
		}
	}

	public override void OnBehaviourPause(Playable playable, FrameData info)
	{
		if (m_timeControl != null && m_started)
		{
			m_timeControl.OnControlTimeStop();
			m_started = false;
		}
	}
}
public class TimeNotificationBehaviour : PlayableBehaviour
{
	private struct NotificationEntry
	{
		public double time;

		public INotification payload;

		public bool notificationFired;

		public NotificationFlags flags;

		public bool triggerInEditor => (flags & NotificationFlags.TriggerInEditMode) != 0;

		public bool prewarm => (flags & NotificationFlags.Retroactive) != 0;

		public bool triggerOnce => (flags & NotificationFlags.TriggerOnce) != 0;
	}

	private readonly List<NotificationEntry> m_Notifications = new List<NotificationEntry>();

	private double m_PreviousTime;

	private bool m_NeedSortNotifications;

	private Playable m_TimeSource;

	public Playable timeSource
	{
		set
		{
			m_TimeSource = value;
		}
	}

	public static ScriptPlayable<TimeNotificationBehaviour> Create(PlayableGraph graph, double duration, DirectorWrapMode loopMode)
	{
		ScriptPlayable<TimeNotificationBehaviour> scriptPlayable = ScriptPlayable<TimeNotificationBehaviour>.Create(graph);
		scriptPlayable.SetDuration(duration);
		scriptPlayable.SetTimeWrapMode(loopMode);
		scriptPlayable.SetPropagateSetTime(value: true);
		return scriptPlayable;
	}

	public void AddNotification(double time, INotification payload, NotificationFlags flags = NotificationFlags.Retroactive)
	{
		m_Notifications.Add(new NotificationEntry
		{
			time = time,
			payload = payload,
			flags = flags
		});
		m_NeedSortNotifications = true;
	}

	public override void OnGraphStart(Playable playable)
	{
		SortNotifications();
		double time = playable.GetTime();
		for (int i = 0; i < m_Notifications.Count; i++)
		{
			if (m_Notifications[i].time > time && !m_Notifications[i].triggerOnce)
			{
				NotificationEntry value = m_Notifications[i];
				value.notificationFired = false;
				m_Notifications[i] = value;
			}
		}
		m_PreviousTime = playable.GetTime();
	}

	public override void OnBehaviourPause(Playable playable, FrameData info)
	{
		if (!playable.IsDone())
		{
			return;
		}
		SortNotifications();
		for (int i = 0; i < m_Notifications.Count; i++)
		{
			NotificationEntry e = m_Notifications[i];
			if (!e.notificationFired)
			{
				double duration = playable.GetDuration();
				if (m_PreviousTime <= e.time && e.time <= duration)
				{
					Trigger_internal(playable, info.output, ref e);
					m_Notifications[i] = e;
				}
			}
		}
	}

	public override void PrepareFrame(Playable playable, FrameData info)
	{
		if (info.evaluationType == FrameData.EvaluationType.Evaluate)
		{
			return;
		}
		SyncDurationWithExternalSource(playable);
		SortNotifications();
		double time = playable.GetTime();
		if (info.timeLooped)
		{
			double duration = playable.GetDuration();
			TriggerNotificationsInRange(m_PreviousTime, duration, info, playable, checkState: true);
			double num = playable.GetDuration() - m_PreviousTime;
			int num2 = (int)(((double)(info.deltaTime * info.effectiveSpeed) - num) / playable.GetDuration());
			for (int i = 0; i < num2; i++)
			{
				TriggerNotificationsInRange(0.0, duration, info, playable, checkState: false);
			}
			TriggerNotificationsInRange(0.0, time, info, playable, checkState: false);
		}
		else
		{
			double time2 = playable.GetTime();
			TriggerNotificationsInRange(m_PreviousTime, time2, info, playable, checkState: true);
		}
		for (int j = 0; j < m_Notifications.Count; j++)
		{
			NotificationEntry e = m_Notifications[j];
			if (e.notificationFired && CanRestoreNotification(e, info, time, m_PreviousTime))
			{
				Restore_internal(ref e);
				m_Notifications[j] = e;
			}
		}
		m_PreviousTime = playable.GetTime();
	}

	private void SortNotifications()
	{
		if (m_NeedSortNotifications)
		{
			m_Notifications.Sort((NotificationEntry x, NotificationEntry y) => x.time.CompareTo(y.time));
			m_NeedSortNotifications = false;
		}
	}

	private static bool CanRestoreNotification(NotificationEntry e, FrameData info, double currentTime, double previousTime)
	{
		if (e.triggerOnce)
		{
			return false;
		}
		if (info.timeLooped)
		{
			return true;
		}
		if (previousTime > currentTime)
		{
			return currentTime <= e.time;
		}
		return false;
	}

	private void TriggerNotificationsInRange(double start, double end, FrameData info, Playable playable, bool checkState)
	{
		if (!(start <= end))
		{
			return;
		}
		bool isPlaying = Application.isPlaying;
		for (int i = 0; i < m_Notifications.Count; i++)
		{
			NotificationEntry e = m_Notifications[i];
			if (!e.notificationFired || (!checkState && !e.triggerOnce))
			{
				double time = e.time;
				if (e.prewarm && time < end && (e.triggerInEditor || isPlaying))
				{
					Trigger_internal(playable, info.output, ref e);
					m_Notifications[i] = e;
				}
				else if (!(time < start) && !(time > end) && (e.triggerInEditor || isPlaying))
				{
					Trigger_internal(playable, info.output, ref e);
					m_Notifications[i] = e;
				}
			}
		}
	}

	private void SyncDurationWithExternalSource(Playable playable)
	{
		if (m_TimeSource.IsValid())
		{
			playable.SetDuration(m_TimeSource.GetDuration());
			playable.SetTimeWrapMode(m_TimeSource.GetTimeWrapMode());
		}
	}

	private static void Trigger_internal(Playable playable, PlayableOutput output, ref NotificationEntry e)
	{
		output.PushNotification(playable, e.payload);
		e.notificationFired = true;
	}

	private static void Restore_internal(ref NotificationEntry e)
	{
		e.notificationFired = false;
	}
}
[Serializable]
public class PlayableTrack : TrackAsset
{
	protected override void OnCreateClip(TimelineClip clip)
	{
		if (clip.asset != null)
		{
			clip.displayName = clip.asset.GetType().Name;
		}
	}
}
[AttributeUsage(AttributeTargets.Class)]
[Obsolete("TrackMediaType has been deprecated. It is no longer required, and will be removed in a future release.", false)]
public class TrackMediaType : Attribute
{
	public readonly TimelineAsset.MediaType m_MediaType;

	public TrackMediaType(TimelineAsset.MediaType mt)
	{
		m_MediaType = mt;
	}
}
[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public class TrackClipTypeAttribute : Attribute
{
	public readonly Type inspectedType;

	public readonly bool allowAutoCreate;

	public TrackClipTypeAttribute(Type clipClass)
	{
		inspectedType = clipClass;
		allowAutoCreate = true;
	}

	public TrackClipTypeAttribute(Type clipClass, bool allowAutoCreate)
	{
		inspectedType = clipClass;
		allowAutoCreate = false;
	}
}
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Field)]
public class NotKeyableAttribute : Attribute
{
}
[Flags]
public enum TrackBindingFlags
{
	None = 0,
	AllowCreateComponent = 1,
	All = 1
}
[AttributeUsage(AttributeTargets.Class)]
public class TrackBindingTypeAttribute : Attribute
{
	public readonly Type type;

	public readonly TrackBindingFlags flags;

	public TrackBindingTypeAttribute(Type type)
	{
		this.type = type;
		flags = TrackBindingFlags.AllowCreateComponent;
	}

	public TrackBindingTypeAttribute(Type type, TrackBindingFlags flags)
	{
		this.type = type;
		this.flags = flags;
	}
}
[AttributeUsage(AttributeTargets.Class, Inherited = false)]
internal class SupportsChildTracksAttribute : Attribute
{
	public readonly Type childType;

	public readonly int levels;

	public SupportsChildTracksAttribute(Type childType = null, int levels = int.MaxValue)
	{
		this.childType = childType;
		this.levels = levels;
	}
}
[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = true)]
internal class IgnoreOnPlayableTrackAttribute : Attribute
{
}
internal class TimeFieldAttribute : PropertyAttribute
{
	public enum UseEditMode
	{
		None,
		ApplyEditMode
	}

	public UseEditMode useEditMode { get; }

	public TimeFieldAttribute(UseEditMode useEditMode = UseEditMode.ApplyEditMode)
	{
		this.useEditMode = useEditMode;
	}
}
internal class FrameRateFieldAttribute : PropertyAttribute
{
}
[AttributeUsage(AttributeTargets.Class, Inherited = false)]
public class HideInMenuAttribute : Attribute
{
}
[AttributeUsage(AttributeTargets.Class)]
public class CustomStyleAttribute : Attribute
{
	public readonly string ussStyle;

	public CustomStyleAttribute(string ussStyle)
	{
		this.ussStyle = ussStyle;
	}
}
[AttributeUsage(AttributeTargets.Class)]
internal class MenuCategoryAttribute : Attribute
{
	public readonly string category;

	public MenuCategoryAttribute(string category)
	{
		this.category = category ?? string.Empty;
	}
}
public interface ITimelineClipAsset
{
	ClipCaps clipCaps { get; }
}
internal interface ITimelineEvaluateCallback
{
	void Evaluate();
}
public class TimelinePlayable : PlayableBehaviour
{
	private IntervalTree<RuntimeElement> m_IntervalTree = new IntervalTree<RuntimeElement>();

	private List<RuntimeElement> m_ActiveClips = new List<RuntimeElement>();

	private List<RuntimeElement> m_CurrentListOfActiveClips;

	private int m_ActiveBit;

	private List<ITimelineEvaluateCallback> m_EvaluateCallbacks = new List<ITimelineEvaluateCallback>();

	private Dictionary<TrackAsset, Playable> m_PlayableCache = new Dictionary<TrackAsset, Playable>();

	internal static bool muteAudioScrubbing = true;

	public static ScriptPlayable<TimelinePlayable> Create(PlayableGraph graph, IEnumerable<TrackAsset> tracks, GameObject go, bool autoRebalance, bool createOutputs)
	{
		if (tracks == null)
		{
			throw new ArgumentNullException("Tracks list is null", "tracks");
		}
		if (go == null)
		{
			throw new ArgumentNullException("GameObject parameter is null", "go");
		}
		ScriptPlayable<TimelinePlayable> scriptPlayable = ScriptPlayable<TimelinePlayable>.Create(graph);
		scriptPlayable.SetTraversalMode(PlayableTraversalMode.Passthrough);
		scriptPlayable.GetBehaviour().Compile(graph, scriptPlayable, tracks, go, autoRebalance, createOutputs);
		return scriptPlayable;
	}

	public void Compile(PlayableGraph graph, Playable timelinePlayable, IEnumerable<TrackAsset> tracks, GameObject go, bool autoRebalance, bool createOutputs)
	{
		if (tracks == null)
		{
			throw new ArgumentNullException("Tracks list is null", "tracks");
		}
		if (go == null)
		{
			throw new ArgumentNullException("GameObject parameter is null", "go");
		}
		List<TrackAsset> list = new List<TrackAsset>(tracks);
		int capacity = list.Count * 2 + list.Count;
		m_CurrentListOfActiveClips = new List<RuntimeElement>(capacity);
		m_ActiveClips = new List<RuntimeElement>(capacity);
		m_EvaluateCallbacks.Clear();
		m_PlayableCache.Clear();
		CompileTrackList(graph, timelinePlayable, list, go, createOutputs);
	}

	private void CompileTrackList(PlayableGraph graph, Playable timelinePlayable, IEnumerable<TrackAsset> tracks, GameObject go, bool createOutputs)
	{
		foreach (TrackAsset track in tracks)
		{
			if (track.IsCompilable() && !m_PlayableCache.ContainsKey(track))
			{
				track.SortClips();
				CreateTrackPlayable(graph, timelinePlayable, track, go, createOutputs);
			}
		}
	}

	private void CreateTrackOutput(PlayableGraph graph, TrackAsset track, GameObject go, Playable playable, int port)
	{
		if (track.isSubTrack)
		{
			return;
		}
		foreach (PlayableBinding output in track.outputs)
		{
			PlayableOutput playableOutput = output.CreateOutput(graph);
			playableOutput.SetReferenceObject(output.sourceObject);
			playableOutput.SetSourcePlayable(playable, port);
			playableOutput.SetWeight(1f);
			if (track as AnimationTrack != null)
			{
				EvaluateWeightsForAnimationPlayableOutput(track, (AnimationPlayableOutput)playableOutput);
			}
			if (playableOutput.IsPlayableOutputOfType<AudioPlayableOutput>())
			{
				((AudioPlayableOutput)playableOutput).SetEvaluateOnSeek(!muteAudioScrubbing);
			}
			if (track.timelineAsset.markerTrack == track)
			{
				PlayableDirector component = go.GetComponent<PlayableDirector>();
				playableOutput.SetUserData(component);
				INotificationReceiver[] components = go.GetComponents<INotificationReceiver>();
				foreach (INotificationReceiver receiver in components)
				{
					playableOutput.AddNotificationReceiver(receiver);
				}
			}
		}
	}

	private void EvaluateWeightsForAnimationPlayableOutput(TrackAsset track, AnimationPlayableOutput animOutput)
	{
		m_EvaluateCallbacks.Add(new AnimationOutputWeightProcessor(animOutput));
	}

	private void EvaluateAnimationPreviewUpdateCallback(TrackAsset track, AnimationPlayableOutput animOutput)
	{
		m_EvaluateCallbacks.Add(new AnimationPreviewUpdateCallback(animOutput));
	}

	private Playable CreateTrackPlayable(PlayableGraph graph, Playable timelinePlayable, TrackAsset track, GameObject go, bool createOutputs)
	{
		if (!track.IsCompilable())
		{
			return timelinePlayable;
		}
		if (m_PlayableCache.TryGetValue(track, out var value))
		{
			return value;
		}
		if (track.name == "root")
		{
			return timelinePlayable;
		}
		TrackAsset trackAsset = track.parent as TrackAsset;
		Playable playable = ((trackAsset != null) ? CreateTrackPlayable(graph, timelinePlayable, trackAsset, go, createOutputs) : timelinePlayable);
		Playable playable2 = track.CreatePlayableGraph(graph, go, m_IntervalTree, timelinePlayable);
		bool flag = false;
		if (!playable2.IsValid())
		{
			throw new InvalidOperationException(track.name + "(" + track.GetType()?.ToString() + ") did not produce a valid playable.");
		}
		if (playable.IsValid() && playable2.IsValid())
		{
			int inputCount = playable.GetInputCount();
			playable.SetInputCount(inputCount + 1);
			flag = graph.Connect(playable2, 0, playable, inputCount);
			playable.SetInputWeight(inputCount, 1f);
		}
		if (createOutputs && flag)
		{
			CreateTrackOutput(graph, track, go, playable, playable.GetInputCount() - 1);
		}
		CacheTrack(track, playable2, flag ? (playable.GetInputCount() - 1) : (-1), playable);
		return playable2;
	}

	public override void PrepareFrame(Playable playable, FrameData info)
	{
		Evaluate(playable, info);
	}

	private void Evaluate(Playable playable, FrameData frameData)
	{
		if (m_IntervalTree == null)
		{
			return;
		}
		double time = playable.GetTime();
		m_ActiveBit = ((m_ActiveBit == 0) ? 1 : 0);
		m_CurrentListOfActiveClips.Clear();
		m_IntervalTree.IntersectsWith(DiscreteTime.GetNearestTick(time), m_CurrentListOfActiveClips);
		foreach (RuntimeElement currentListOfActiveClip in m_CurrentListOfActiveClips)
		{
			currentListOfActiveClip.intervalBit = m_ActiveBit;
		}
		double rootDuration = (double)new DiscreteTime(playable.GetDuration());
		foreach (RuntimeElement activeClip in m_ActiveClips)
		{
			if (activeClip.intervalBit != m_ActiveBit)
			{
				activeClip.DisableAt(time, rootDuration, frameData);
			}
		}
		m_ActiveClips.Clear();
		for (int i = 0; i < m_CurrentListOfActiveClips.Count; i++)
		{
			m_CurrentListOfActiveClips[i].EvaluateAt(time, frameData);
			m_ActiveClips.Add(m_CurrentListOfActiveClips[i]);
		}
		int count = m_EvaluateCallbacks.Count;
		for (int j = 0; j < count; j++)
		{
			m_EvaluateCallbacks[j].Evaluate();
		}
	}

	private void CacheTrack(TrackAsset track, Playable playable, int port, Playable parent)
	{
		m_PlayableCache[track] = playable;
	}

	private static void ForAOTCompilationOnly()
	{
		new List<IntervalTree<RuntimeElement>.Entry>();
	}
}
internal static class Extrapolation
{
	internal static readonly double kMinExtrapolationTime = TimeUtility.kTimeEpsilon * 1000.0;

	internal static void CalculateExtrapolationTimes(this TrackAsset asset)
	{
		TimelineClip[] clips = asset.clips;
		if (clips == null || clips.Length == 0 || !clips[0].SupportsExtrapolation())
		{
			return;
		}
		TimelineClip[] array = SortClipsByStartTime(clips);
		if (array.Length == 0)
		{
			return;
		}
		for (int i = 0; i < array.Length; i++)
		{
			double num = double.PositiveInfinity;
			for (int j = 0; j < array.Length; j++)
			{
				if (i != j)
				{
					double num2 = array[j].start - array[i].end;
					if (num2 >= 0.0 - TimeUtility.kTimeEpsilon && num2 < num)
					{
						num = Math.Min(num, num2);
					}
					if (array[j].start <= array[i].end && array[j].end > array[i].end)
					{
						num = 0.0;
					}
				}
			}
			num = ((num <= kMinExtrapolationTime) ? 0.0 : num);
			array[i].SetPostExtrapolationTime(num);
		}
		array[0].SetPreExtrapolationTime(Math.Max(0.0, array[0].start));
		for (int k = 1; k < array.Length; k++)
		{
			double num3 = 0.0;
			int num4 = -1;
			for (int l = 0; l < k; l++)
			{
				if (array[l].end > array[k].start)
				{
					num4 = -1;
					num3 = 0.0;
					break;
				}
				double num5 = array[k].start - array[l].end;
				if (num4 == -1 || num5 < num3)
				{
					num3 = num5;
					num4 = l;
				}
			}
			if (num4 >= 0 && array[num4].postExtrapolationMode != TimelineClip.ClipExtrapolation.None)
			{
				num3 = 0.0;
			}
			num3 = ((num3 <= kMinExtrapolationTime) ? 0.0 : num3);
			array[k].SetPreExtrapolationTime(num3);
		}
	}

	private static TimelineClip[] SortClipsByStartTime(TimelineClip[] clips)
	{
		TimelineClip[] array = new TimelineClip[clips.Length];
		Array.Copy(clips, array, clips.Length);
		Array.Sort(array, (TimelineClip clip1, TimelineClip clip2) => clip1.start.CompareTo(clip2.start));
		return array;
	}
}
internal static class HashUtility
{
	public static int CombineHash(this int h1, int h2)
	{
		return h1 ^ (int)(h2 + 2654435769u + (h1 << 6) + (h1 >> 2));
	}

	public static int CombineHash(int h1, int h2, int h3)
	{
		return h1.CombineHash(h2).CombineHash(h3);
	}

	public static int CombineHash(int h1, int h2, int h3, int h4)
	{
		return CombineHash(h1, h2, h3).CombineHash(h4);
	}

	public static int CombineHash(int h1, int h2, int h3, int h4, int h5)
	{
		return CombineHash(h1, h2, h3, h4).CombineHash(h5);
	}

	public static int CombineHash(int h1, int h2, int h3, int h4, int h5, int h6)
	{
		return CombineHash(h1, h2, h3, h4, h5).CombineHash(h6);
	}

	public static int CombineHash(int h1, int h2, int h3, int h4, int h5, int h6, int h7)
	{
		return CombineHash(h1, h2, h3, h4, h5, h6).CombineHash(h7);
	}

	public static int CombineHash(int[] hashes)
	{
		if (hashes == null || hashes.Length == 0)
		{
			return 0;
		}
		int num = hashes[0];
		for (int i = 1; i < hashes.Length; i++)
		{
			num = num.CombineHash(hashes[i]);
		}
		return num;
	}
}
public interface IPropertyCollector
{
	void PushActiveGameObject(GameObject gameObject);

	void PopActiveGameObject();

	void AddFromClip(AnimationClip clip);

	void AddFromClips(IEnumerable<AnimationClip> clips);

	void AddFromName<T>(string name) where T : Component;

	void AddFromName(string name);

	void AddFromClip(GameObject obj, AnimationClip clip);

	void AddFromClips(GameObject obj, IEnumerable<AnimationClip> clips);

	void AddFromName<T>(GameObject obj, string name) where T : Component;

	void AddFromName(GameObject obj, string name);

	void AddFromName(Component component, string name);

	void AddFromComponent(GameObject obj, Component component);

	void AddObjectProperties(Object obj, AnimationClip clip);
}
public interface IPropertyPreview
{
	void GatherProperties(PlayableDirector director, IPropertyCollector driver);
}
internal static class NotificationUtilities
{
	public static ScriptPlayable<TimeNotificationBehaviour> CreateNotificationsPlayable(PlayableGraph graph, IEnumerable<IMarker> markers, PlayableDirector director)
	{
		return CreateNotificationsPlayable(graph, markers, null, director);
	}

	public static ScriptPlayable<TimeNotificationBehaviour> CreateNotificationsPlayable(PlayableGraph graph, IEnumerable<IMarker> markers, TimelineAsset timelineAsset)
	{
		return CreateNotificationsPlayable(graph, markers, timelineAsset, null);
	}

	private static ScriptPlayable<TimeNotificationBehaviour> CreateNotificationsPlayable(PlayableGraph graph, IEnumerable<IMarker> markers, IPlayableAsset asset, PlayableDirector director)
	{
		ScriptPlayable<TimeNotificationBehaviour> result = ScriptPlayable<TimeNotificationBehaviour>.Null;
		DirectorWrapMode loopMode = ((director != null) ? director.extrapolationMode : DirectorWrapMode.None);
		bool flag = false;
		double num = 0.0;
		foreach (IMarker marker in markers)
		{
			if (marker is INotification payload)
			{
				if (!flag)
				{
					num = ((director != null) ? director.playableAsset.duration : asset.duration);
					flag = true;
				}
				if (result.Equals(ScriptPlayable<TimeNotificationBehaviour>.Null))
				{
					result = TimeNotificationBehaviour.Create(graph, num, loopMode);
				}
				DiscreteTime discreteTime = (DiscreteTime)marker.time;
				DiscreteTime discreteTime2 = (DiscreteTime)num;
				if (discreteTime >= discreteTime2 && discreteTime <= discreteTime2.OneTickAfter() && discreteTime2 != 0)
				{
					discreteTime = discreteTime2.OneTickBefore();
				}
				if (marker is INotificationOptionProvider notificationOptionProvider)
				{
					result.GetBehaviour().AddNotification((double)discreteTime, payload, notificationOptionProvider.flags);
				}
				else
				{
					result.GetBehaviour().AddNotification((double)discreteTime, payload);
				}
			}
		}
		return result;
	}

	public static bool TrackTypeSupportsNotifications(Type type)
	{
		TrackBindingTypeAttribute trackBindingTypeAttribute = (TrackBindingTypeAttribute)Attribute.GetCustomAttribute(type, typeof(TrackBindingTypeAttribute));
		if (trackBindingTypeAttribute != null)
		{
			if (!typeof(Component).IsAssignableFrom(trackBindingTypeAttribute.type))
			{
				return typeof(GameObject).IsAssignableFrom(trackBindingTypeAttribute.type);
			}
			return true;
		}
		return false;
	}
}
public static class TimelineClipExtensions
{
	private static readonly string k_UndoSetParentTrackText = "Move Clip";

	public static void MoveToTrack(this TimelineClip clip, TrackAsset destinationTrack)
	{
		if (clip == null)
		{
			throw new ArgumentNullException("'this' argument for MoveToTrack cannot be null.");
		}
		if (destinationTrack == null)
		{
			throw new ArgumentNullException("Cannot move TimelineClip to a null track.");
		}
		TrackAsset parentTrack = clip.GetParentTrack();
		Object asset = clip.asset;
		if (asset == null)
		{
			throw new InvalidOperationException("Cannot move a TimelineClip to a different track if the TimelineClip's PlayableAsset is null.");
		}
		if (parentTrack == destinationTrack)
		{
			throw new InvalidOperationException("TimelineClip is already on " + destinationTrack.name + ".");
		}
		if (!destinationTrack.ValidateClipType(asset.GetType()))
		{
			throw new InvalidOperationException("Track " + destinationTrack.name + " cannot contain clips of type " + clip.GetType().Name + ".");
		}
		MoveToTrack_Impl(clip, destinationTrack, asset, parentTrack);
	}

	public static bool TryMoveToTrack(this TimelineClip clip, TrackAsset destinationTrack)
	{
		if (clip == null)
		{
			throw new ArgumentNullException("'this' argument for TryMoveToTrack cannot be null.");
		}
		if (destinationTrack == null)
		{
			throw new ArgumentNullException("Cannot move TimelineClip to a null parent.");
		}
		TrackAsset parentTrack = clip.GetParentTrack();
		Object asset = clip.asset;
		if (asset == null)
		{
			return false;
		}
		if (parentTrack != destinationTrack)
		{
			if (!destinationTrack.ValidateClipType(asset.GetType()))
			{
				return false;
			}
			MoveToTrack_Impl(clip, destinationTrack, asset, parentTrack);
			return true;
		}
		return false;
	}

	private static void MoveToTrack_Impl(TimelineClip clip, TrackAsset destinationTrack, Object asset, TrackAsset parentTrack)
	{
		_ = parentTrack != null;
		clip.SetParentTrack_Internal(destinationTrack);
		if (parentTrack == null)
		{
			TimelineCreateUtilities.SaveAssetIntoObject(asset, destinationTrack);
		}
		else if (parentTrack.timelineAsset != destinationTrack.timelineAsset)
		{
			TimelineCreateUtilities.RemoveAssetFromObject(asset, parentTrack);
			TimelineCreateUtilities.SaveAssetIntoObject(asset, destinationTrack);
		}
	}
}
internal static class TimelineCreateUtilities
{
	public static string GenerateUniqueActorName(List<ScriptableObject> tracks, string name)
	{
		if (!tracks.Exists((ScriptableObject x) => (object)x != null && x.name == name))
		{
			return name;
		}
		int result = 0;
		string text = name;
		if (!string.IsNullOrEmpty(name) && name[name.Length - 1] == ')')
		{
			int num = name.LastIndexOf('(');
			if (num > 0 && int.TryParse(name.Substring(num + 1, name.Length - num - 2), out result))
			{
				result++;
				text = name.Substring(0, num);
			}
		}
		text = text.TrimEnd();
		for (int num2 = result; num2 < result + 5000; num2++)
		{
			if (num2 > 0)
			{
				string result2 = $"{text} ({num2})";
				if (!tracks.Exists((ScriptableObject x) => (object)x != null && x.name == result2))
				{
					return result2;
				}
			}
		}
		return name;
	}

	public static void SaveAssetIntoObject(Object childAsset, Object masterAsset)
	{
		if (!(childAsset == null) && !(masterAsset == null))
		{
			if ((masterAsset.hideFlags & HideFlags.DontSave) != HideFlags.None)
			{
				childAsset.hideFlags |= HideFlags.DontSave;
			}
			else
			{
				childAsset.hideFlags |= HideFlags.HideInHierarchy;
			}
		}
	}

	public static void RemoveAssetFromObject(Object childAsset, Object masterAsset)
	{
		if (!(childAsset == null))
		{
			_ = masterAsset == null;
		}
	}

	public static AnimationClip CreateAnimationClipForTrack(string name, TrackAsset track, bool isLegacy)
	{
		TimelineAsset timelineAsset = ((track != null) ? track.timelineAsset : null);
		HideFlags hideFlags = ((track != null) ? track.hideFlags : HideFlags.None);
		AnimationClip obj = new AnimationClip
		{
			legacy = isLegacy,
			name = name,
			frameRate = ((timelineAsset == null) ? ((float)TimelineAsset.EditorSettings.kDefaultFrameRate) : ((float)timelineAsset.editorSettings.frameRate))
		};
		SaveAssetIntoObject(obj, timelineAsset);
		obj.hideFlags = hideFlags & ~HideFlags.HideInHierarchy;
		return obj;
	}

	public static bool ValidateParentTrack(TrackAsset parent, Type childType)
	{
		if (childType == null || !typeof(TrackAsset).IsAssignableFrom(childType))
		{
			return false;
		}
		if (parent == null)
		{
			return true;
		}
		if (parent is ILayerable && !parent.isSubTrack && parent.GetType() == childType)
		{
			return true;
		}
		if (!(Attribute.GetCustomAttribute(parent.GetType(), typeof(SupportsChildTracksAttribute)) is SupportsChildTracksAttribute supportsChildTracksAttribute))
		{
			return false;
		}
		if (supportsChildTracksAttribute.childType == null)
		{
			return true;
		}
		if (childType == supportsChildTracksAttribute.childType)
		{
			int num = 0;
			TrackAsset trackAsset = parent;
			while (trackAsset != null && trackAsset.isSubTrack)
			{
				num++;
				trackAsset = trackAsset.parent as TrackAsset;
			}
			return num < supportsChildTracksAttribute.levels;
		}
		return false;
	}
}
internal static class TimelineUndo
{
	internal static bool undoEnabled => false;

	public static void PushDestroyUndo(TimelineAsset timeline, Object thingToDirty, Object objectToDestroy)
	{
		if (objectToDestroy != null)
		{
			Object.Destroy(objectToDestroy);
		}
	}

	[Conditional("UNITY_EDITOR")]
	public static void PushUndo(Object[] thingsToDirty, string operation)
	{
	}

	[Conditional("UNITY_EDITOR")]
	public static void PushUndo(Object thingToDirty, string operation)
	{
	}

	[Conditional("UNITY_EDITOR")]
	public static void RegisterCreatedObjectUndo(Object thingCreated, string operation)
	{
	}

	internal static string UndoName(string name)
	{
		return "Timeline " + name;
	}
}
public enum StandardFrameRates
{
	Fps24,
	Fps23_97,
	Fps25,
	Fps30,
	Fps29_97,
	Fps50,
	Fps60,
	Fps59_94
}
internal static class TimeUtility
{
	public static readonly double kTimeEpsilon = 1E-14;

	public static readonly double kFrameRateEpsilon = 1E-06;

	public static readonly double k_MaxTimelineDurationInSeconds = 9000000.0;

	public static readonly double kFrameRateRounding = 0.01;

	private static void ValidateFrameRate(double frameRate)
	{
		if (frameRate <= kTimeEpsilon)
		{
			throw new ArgumentException("frame rate cannot be 0 or negative");
		}
	}

	public static int ToFrames(double time, double frameRate)
	{
		ValidateFrameRate(frameRate);
		time = Math.Min(Math.Max(time, 0.0 - k_MaxTimelineDurationInSeconds), k_MaxTimelineDurationInSeconds);
		double epsilon = GetEpsilon(time, frameRate);
		if (time < 0.0)
		{
			return (int)Math.Ceiling(time * frameRate - epsilon);
		}
		return (int)Math.Floor(time * frameRate + epsilon);
	}

	public static double ToExactFrames(double time, double frameRate)
	{
		ValidateFrameRate(frameRate);
		return time * frameRate;
	}

	public static double FromFrames(int frames, double frameRate)
	{
		ValidateFrameRate(frameRate);
		return (double)frames / frameRate;
	}

	public static double FromFrames(double frames, double frameRate)
	{
		ValidateFrameRate(frameRate);
		return frames / frameRate;
	}

	public static bool OnFrameBoundary(double time, double frameRate)
	{
		return OnFrameBoundary(time, frameRate, GetEpsilon(time, frameRate));
	}

	public static double GetEpsilon(double time, double frameRate)
	{
		return Math.Max(Math.Abs(time), 1.0) * frameRate * kTimeEpsilon;
	}

	public static int PreviousFrame(double time, double frameRate)
	{
		return Math.Max(0, ToFrames(time, frameRate) - 1);
	}

	public static int NextFrame(double time, double frameRate)
	{
		return ToFrames(time, frameRate) + 1;
	}

	public static double PreviousFrameTime(double time, double frameRate)
	{
		return FromFrames(PreviousFrame(time, frameRate), frameRate);
	}

	public static double NextFrameTime(double time, double frameRate)
	{
		return FromFrames(NextFrame(time, frameRate), frameRate);
	}

	public static bool OnFrameBoundary(double time, double frameRate, double epsilon)
	{
		ValidateFrameRate(frameRate);
		double num = ToExactFrames(time, frameRate);
		double num2 = Math.Round(num);
		return Math.Abs(num - num2) < epsilon;
	}

	public static double RoundToFrame(double time, double frameRate)
	{
		ValidateFrameRate(frameRate);
		double num = (double)(int)Math.Floor(time * frameRate) / frameRate;
		double num2 = (double)(int)Math.Ceiling(time * frameRate) / frameRate;
		if (!(Math.Abs(time - num) < Math.Abs(time - num2)))
		{
			return num2;
		}
		return num;
	}

	public static string TimeAsFrames(double timeValue, double frameRate, string format = "F2")
	{
		if (OnFrameBoundary(timeValue, frameRate))
		{
			return ToFrames(timeValue, frameRate).ToString();
		}
		return ToExactFrames(timeValue, frameRate).ToString(format);
	}

	public static string TimeAsTimeCode(double timeValue, double frameRate, string format = "F2")
	{
		ValidateFrameRate(frameRate);
		int num = (int)Math.Abs(timeValue);
		int num2 = num / 3600;
		int num3 = num % 3600 / 60;
		int num4 = num % 60;
		string text = ((timeValue < 0.0) ? "-" : string.Empty);
		string text2 = ((num2 > 0) ? (num2 + ":" + num3.ToString("D2") + ":" + num4.ToString("D2")) : ((num3 <= 0) ? num4.ToString() : (num3 + ":" + num4.ToString("D2"))));
		int totalWidth = (int)Math.Floor(Math.Log10(frameRate) + 1.0);
		string text3 = (ToFrames(timeValue, frameRate) - ToFrames(num, frameRate)).ToString().PadLeft(totalWidth, '0');
		if (!OnFrameBoundary(timeValue, frameRate))
		{
			string text4 = ToExactFrames(timeValue, frameRate).ToString(format);
			int num5 = text4.IndexOf('.');
			if (num5 >= 0)
			{
				text3 = text3 + " [" + text4.Substring(num5) + "]";
			}
		}
		return text + text2 + ":" + text3;
	}

	public static double ParseTimeCode(string timeCode, double frameRate, double defaultValue)
	{
		timeCode = RemoveChar(timeCode, (char c) => char.IsWhiteSpace(c));
		string[] array = timeCode.Split(':');
		if (array.Length == 0 || array.Length > 4)
		{
			return defaultValue;
		}
		int num = 0;
		int num2 = 0;
		double num3 = 0.0;
		double num4 = 0.0;
		try
		{
			string text = array[^1];
			if (Regex.Match(text, "^\\d+\\.\\d+$").Success)
			{
				num3 = double.Parse(text);
				if (array.Length > 3)
				{
					return defaultValue;
				}
				if (array.Length > 1)
				{
					num2 = int.Parse(array[^2]);
				}
				if (array.Length > 2)
				{
					num = int.Parse(array[^3]);
				}
			}
			else
			{
				if (Regex.Match(text, "^\\d+\\[\\.\\d+\\]$").Success)
				{
					num4 = double.Parse(RemoveChar(text, (char c) => c == '[' || c == ']'));
				}
				else
				{
					if (!Regex.Match(text, "^\\d*$").Success)
					{
						return defaultValue;
					}
					num4 = int.Parse(text);
				}
				if (array.Length > 1)
				{
					num3 = int.Parse(array[^2]);
				}
				if (array.Length > 2)
				{
					num2 = int.Parse(array[^3]);
				}
				if (array.Length > 3)
				{
					num = int.Parse(array[^4]);
				}
			}
		}
		catch (FormatException)
		{
			return defaultValue;
		}
		return num4 / frameRate + num3 + (double)(num2 * 60) + (double)(num * 3600);
	}

	public static double ParseTimeSeconds(string timeCode, double frameRate, double defaultValue)
	{
		timeCode = RemoveChar(timeCode, (char c) => char.IsWhiteSpace(c));
		string[] array = timeCode.Split(':');
		if (array.Length == 0 || array.Length > 4)
		{
			return defaultValue;
		}
		int num = 0;
		int num2 = 0;
		double result = 0.0;
		try
		{
			string text = array[^1];
			if (!double.TryParse(text, NumberStyles.Integer, CultureInfo.InvariantCulture, out result))
			{
				if (!Regex.Match(text, "^\\d+\\.\\d+$").Success)
				{
					return defaultValue;
				}
				result = double.Parse(text);
			}
			if (!double.TryParse(text, NumberStyles.Float, CultureInfo.InvariantCulture, out result))
			{
				return defaultValue;
			}
			if (array.Length > 3)
			{
				return defaultValue;
			}
			if (array.Length > 1)
			{
				num2 = int.Parse(array[^2]);
			}
			if (array.Length > 2)
			{
				num = int.Parse(array[^3]);
			}
		}
		catch (FormatException)
		{
			return defaultValue;
		}
		return result + (double)(num2 * 60) + (double)(num * 3600);
	}

	public static double GetAnimationClipLength(AnimationClip clip)
	{
		if (clip == null || clip.empty)
		{
			return 0.0;
		}
		double result = clip.length;
		if (clip.frameRate > 0f)
		{
			result = (double)Mathf.Round(clip.length * clip.frameRate) / (double)clip.frameRate;
		}
		return result;
	}

	private static string RemoveChar(string str, Func<char, bool> charToRemoveFunc)
	{
		int length = str.Length;
		char[] array = str.ToCharArray();
		int length2 = 0;
		for (int i = 0; i < length; i++)
		{
			if (!charToRemoveFunc(array[i]))
			{
				array[length2++] = array[i];
			}
		}
		return new string(array, 0, length2);
	}

	public static FrameRate GetClosestFrameRate(double frameRate)
	{
		ValidateFrameRate(frameRate);
		FrameRate result = FrameRate.DoubleToFrameRate(frameRate);
		if (!(Math.Abs(frameRate - result.rate) < kFrameRateRounding))
		{
			return default(FrameRate);
		}
		return result;
	}

	public static FrameRate ToFrameRate(StandardFrameRates enumValue)
	{
		return enumValue switch
		{
			StandardFrameRates.Fps23_97 => FrameRate.k_23_976Fps, 
			StandardFrameRates.Fps24 => FrameRate.k_24Fps, 
			StandardFrameRates.Fps25 => FrameRate.k_25Fps, 
			StandardFrameRates.Fps29_97 => FrameRate.k_29_97Fps, 
			StandardFrameRates.Fps30 => FrameRate.k_30Fps, 
			StandardFrameRates.Fps50 => FrameRate.k_50Fps, 
			StandardFrameRates.Fps59_94 => FrameRate.k_59_94Fps, 
			StandardFrameRates.Fps60 => FrameRate.k_60Fps, 
			_ => default(FrameRate), 
		};
	}

	internal static bool ToStandardFrameRate(FrameRate rate, out StandardFrameRates standard)
	{
		if (rate == FrameRate.k_23_976Fps)
		{
			standard = StandardFrameRates.Fps23_97;
		}
		else if (rate == FrameRate.k_24Fps)
		{
			standard = StandardFrameRates.Fps24;
		}
		else if (rate == FrameRate.k_25Fps)
		{
			standard = StandardFrameRates.Fps25;
		}
		else if (rate == FrameRate.k_30Fps)
		{
			standard = StandardFrameRates.Fps30;
		}
		else if (rate == FrameRate.k_29_97Fps)
		{
			standard = StandardFrameRates.Fps29_97;
		}
		else if (rate == FrameRate.k_50Fps)
		{
			standard = StandardFrameRates.Fps50;
		}
		else if (rate == FrameRate.k_59_94Fps)
		{
			standard = StandardFrameRates.Fps59_94;
		}
		else
		{
			if (!(rate == FrameRate.k_60Fps))
			{
				standard = (StandardFrameRates)Enum.GetValues(typeof(StandardFrameRates)).Length;
				return false;
			}
			standard = StandardFrameRates.Fps60;
		}
		return true;
	}
}
internal static class WeightUtility
{
	public static float NormalizeMixer(Playable mixer)
	{
		if (!mixer.IsValid())
		{
			return 0f;
		}
		int inputCount = mixer.GetInputCount();
		float num = 0f;
		for (int i = 0; i < inputCount; i++)
		{
			num += mixer.GetInputWeight(i);
		}
		if (num > Mathf.Epsilon && num < 1f)
		{
			for (int j = 0; j < inputCount; j++)
			{
				mixer.SetInputWeight(j, mixer.GetInputWeight(j) / num);
			}
		}
		return Mathf.Clamp01(num);
	}
}
