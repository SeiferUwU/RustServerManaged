using System;
using System.Buffers;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics.Tracing;
using System.Dynamic;
using System.Dynamic.Utils;
using System.Globalization;
using System.IO;
using System.IO.MemoryMappedFiles;
using System.Linq;
using System.Linq.Expressions;
using System.Linq.Expressions.Compiler;
using System.Linq.Parallel;
using System.Reflection;
using System.Reflection.Emit;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Runtime.Serialization;
using System.Security;
using System.Security.AccessControl;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Security.Permissions;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Win32.SafeHandles;
using Mono.Security.Cryptography;
using Unity;

[assembly: DefaultDependency(LoadHint.Always)]
[assembly: AssemblyKeyFile("../ecma.pub")]
[assembly: AssemblyDelaySign(true)]
[assembly: CLSCompliant(true)]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: AssemblyFileVersion("4.6.57.0")]
[assembly: AssemblyInformationalVersion("4.6.57.0")]
[assembly: SatelliteContractVersion("4.0.0.0")]
[assembly: AssemblyCopyright("(c) Various Mono authors")]
[assembly: AssemblyProduct("Mono Common Language Infrastructure")]
[assembly: AssemblyCompany("Mono development team")]
[assembly: AssemblyDefaultAlias("System.Core.dll")]
[assembly: AssemblyDescription("System.Core.dll")]
[assembly: AssemblyTitle("System.Core.dll")]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: AllowPartiallyTrustedCallers]
[assembly: CompilationRelaxations(8)]
[assembly: StringFreezing]
[assembly: ComVisible(false)]
[assembly: SecurityCritical]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("4.0.0.0")]
[assembly: TypeForwardedTo(typeof(Action))]
[assembly: TypeForwardedTo(typeof(Action<, >))]
[assembly: TypeForwardedTo(typeof(Action<, , >))]
[assembly: TypeForwardedTo(typeof(Action<, , , >))]
[assembly: TypeForwardedTo(typeof(Func<>))]
[assembly: TypeForwardedTo(typeof(Func<, >))]
[assembly: TypeForwardedTo(typeof(Func<, , >))]
[assembly: TypeForwardedTo(typeof(Func<, , , >))]
[assembly: TypeForwardedTo(typeof(Func<, , , , >))]
[assembly: TypeForwardedTo(typeof(InvalidTimeZoneException))]
[assembly: TypeForwardedTo(typeof(Lazy<>))]
[assembly: TypeForwardedTo(typeof(ExtensionAttribute))]
[assembly: TypeForwardedTo(typeof(Aes))]
[assembly: TypeForwardedTo(typeof(LazyThreadSafetyMode))]
[assembly: TypeForwardedTo(typeof(LockRecursionException))]
[assembly: TypeForwardedTo(typeof(TimeZoneInfo))]
[assembly: TypeForwardedTo(typeof(TimeZoneNotFoundException))]
[module: UnverifiableCode]
internal static class Interop
{
	internal enum BOOL
	{
		FALSE,
		TRUE
	}

	internal class Errors
	{
		internal const int ERROR_SUCCESS = 0;

		internal const int ERROR_INVALID_FUNCTION = 1;

		internal const int ERROR_FILE_NOT_FOUND = 2;

		internal const int ERROR_PATH_NOT_FOUND = 3;

		internal const int ERROR_ACCESS_DENIED = 5;

		internal const int ERROR_INVALID_HANDLE = 6;

		internal const int ERROR_NOT_ENOUGH_MEMORY = 8;

		internal const int ERROR_INVALID_DATA = 13;

		internal const int ERROR_INVALID_DRIVE = 15;

		internal const int ERROR_NO_MORE_FILES = 18;

		internal const int ERROR_NOT_READY = 21;

		internal const int ERROR_BAD_COMMAND = 22;

		internal const int ERROR_BAD_LENGTH = 24;

		internal const int ERROR_SHARING_VIOLATION = 32;

		internal const int ERROR_LOCK_VIOLATION = 33;

		internal const int ERROR_HANDLE_EOF = 38;

		internal const int ERROR_BAD_NETPATH = 53;

		internal const int ERROR_BAD_NET_NAME = 67;

		internal const int ERROR_FILE_EXISTS = 80;

		internal const int ERROR_INVALID_PARAMETER = 87;

		internal const int ERROR_BROKEN_PIPE = 109;

		internal const int ERROR_SEM_TIMEOUT = 121;

		internal const int ERROR_CALL_NOT_IMPLEMENTED = 120;

		internal const int ERROR_INSUFFICIENT_BUFFER = 122;

		internal const int ERROR_INVALID_NAME = 123;

		internal const int ERROR_NEGATIVE_SEEK = 131;

		internal const int ERROR_DIR_NOT_EMPTY = 145;

		internal const int ERROR_BAD_PATHNAME = 161;

		internal const int ERROR_LOCK_FAILED = 167;

		internal const int ERROR_BUSY = 170;

		internal const int ERROR_ALREADY_EXISTS = 183;

		internal const int ERROR_BAD_EXE_FORMAT = 193;

		internal const int ERROR_ENVVAR_NOT_FOUND = 203;

		internal const int ERROR_FILENAME_EXCED_RANGE = 206;

		internal const int ERROR_EXE_MACHINE_TYPE_MISMATCH = 216;

		internal const int ERROR_PIPE_BUSY = 231;

		internal const int ERROR_NO_DATA = 232;

		internal const int ERROR_PIPE_NOT_CONNECTED = 233;

		internal const int ERROR_MORE_DATA = 234;

		internal const int ERROR_NO_MORE_ITEMS = 259;

		internal const int ERROR_DIRECTORY = 267;

		internal const int ERROR_PARTIAL_COPY = 299;

		internal const int ERROR_ARITHMETIC_OVERFLOW = 534;

		internal const int ERROR_PIPE_CONNECTED = 535;

		internal const int ERROR_PIPE_LISTENING = 536;

		internal const int ERROR_OPERATION_ABORTED = 995;

		internal const int ERROR_IO_INCOMPLETE = 996;

		internal const int ERROR_IO_PENDING = 997;

		internal const int ERROR_NO_TOKEN = 1008;

		internal const int ERROR_DLL_INIT_FAILED = 1114;

		internal const int ERROR_COUNTER_TIMEOUT = 1121;

		internal const int ERROR_NO_ASSOCIATION = 1155;

		internal const int ERROR_DDE_FAIL = 1156;

		internal const int ERROR_DLL_NOT_FOUND = 1157;

		internal const int ERROR_NOT_FOUND = 1168;

		internal const int ERROR_NETWORK_UNREACHABLE = 1231;

		internal const int ERROR_NON_ACCOUNT_SID = 1257;

		internal const int ERROR_NOT_ALL_ASSIGNED = 1300;

		internal const int ERROR_UNKNOWN_REVISION = 1305;

		internal const int ERROR_INVALID_OWNER = 1307;

		internal const int ERROR_INVALID_PRIMARY_GROUP = 1308;

		internal const int ERROR_NO_SUCH_PRIVILEGE = 1313;

		internal const int ERROR_PRIVILEGE_NOT_HELD = 1314;

		internal const int ERROR_INVALID_ACL = 1336;

		internal const int ERROR_INVALID_SECURITY_DESCR = 1338;

		internal const int ERROR_INVALID_SID = 1337;

		internal const int ERROR_BAD_IMPERSONATION_LEVEL = 1346;

		internal const int ERROR_CANT_OPEN_ANONYMOUS = 1347;

		internal const int ERROR_NO_SECURITY_ON_OBJECT = 1350;

		internal const int ERROR_CLASS_ALREADY_EXISTS = 1410;

		internal const int ERROR_TRUSTED_RELATIONSHIP_FAILURE = 1789;

		internal const int ERROR_RESOURCE_LANG_NOT_FOUND = 1815;

		internal const int EFail = -2147467259;

		internal const int E_FILENOTFOUND = -2147024894;
	}

	internal static class Libraries
	{
		internal const string Advapi32 = "advapi32.dll";

		internal const string BCrypt = "BCrypt.dll";

		internal const string CoreComm_L1_1_1 = "api-ms-win-core-comm-l1-1-1.dll";

		internal const string Crypt32 = "crypt32.dll";

		internal const string Error_L1 = "api-ms-win-core-winrt-error-l1-1-0.dll";

		internal const string HttpApi = "httpapi.dll";

		internal const string IpHlpApi = "iphlpapi.dll";

		internal const string Kernel32 = "kernel32.dll";

		internal const string Memory_L1_3 = "api-ms-win-core-memory-l1-1-3.dll";

		internal const string Mswsock = "mswsock.dll";

		internal const string NCrypt = "ncrypt.dll";

		internal const string NtDll = "ntdll.dll";

		internal const string Odbc32 = "odbc32.dll";

		internal const string OleAut32 = "oleaut32.dll";

		internal const string PerfCounter = "perfcounter.dll";

		internal const string RoBuffer = "api-ms-win-core-winrt-robuffer-l1-1-0.dll";

		internal const string Secur32 = "secur32.dll";

		internal const string Shell32 = "shell32.dll";

		internal const string SspiCli = "sspicli.dll";

		internal const string User32 = "user32.dll";

		internal const string Version = "version.dll";

		internal const string WebSocket = "websocket.dll";

		internal const string WinHttp = "winhttp.dll";

		internal const string Ws2_32 = "ws2_32.dll";

		internal const string Wtsapi32 = "wtsapi32.dll";

		internal const string CompressionNative = "clrcompression.dll";
	}

	internal static class Advapi32
	{
		[DllImport("advapi32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool ImpersonateNamedPipeClient(SafePipeHandle hNamedPipe);

		[DllImport("advapi32.dll", CharSet = CharSet.Unicode, ExactSpelling = true, SetLastError = true)]
		internal static extern bool RevertToSelf();
	}

	internal class Kernel32
	{
		internal class IOReparseOptions
		{
			internal const uint IO_REPARSE_TAG_FILE_PLACEHOLDER = 2147483669u;

			internal const uint IO_REPARSE_TAG_MOUNT_POINT = 2684354563u;
		}

		internal class FileOperations
		{
			internal const int OPEN_EXISTING = 3;

			internal const int COPY_FILE_FAIL_IF_EXISTS = 1;

			internal const int FILE_ACTION_ADDED = 1;

			internal const int FILE_ACTION_REMOVED = 2;

			internal const int FILE_ACTION_MODIFIED = 3;

			internal const int FILE_ACTION_RENAMED_OLD_NAME = 4;

			internal const int FILE_ACTION_RENAMED_NEW_NAME = 5;

			internal const int FILE_FLAG_BACKUP_SEMANTICS = 33554432;

			internal const int FILE_FLAG_FIRST_PIPE_INSTANCE = 524288;

			internal const int FILE_FLAG_OVERLAPPED = 1073741824;

			internal const int FILE_LIST_DIRECTORY = 1;
		}

		internal class FileTypes
		{
			internal const int FILE_TYPE_UNKNOWN = 0;

			internal const int FILE_TYPE_DISK = 1;

			internal const int FILE_TYPE_CHAR = 2;

			internal const int FILE_TYPE_PIPE = 3;
		}

		internal class GenericOperations
		{
			internal const int GENERIC_READ = int.MinValue;

			internal const int GENERIC_WRITE = 1073741824;
		}

		internal class HandleOptions
		{
			internal const int DUPLICATE_SAME_ACCESS = 2;

			internal const int STILL_ACTIVE = 259;

			internal const int TOKEN_ADJUST_PRIVILEGES = 32;
		}

		internal class PipeOptions
		{
			internal const int PIPE_ACCESS_INBOUND = 1;

			internal const int PIPE_ACCESS_OUTBOUND = 2;

			internal const int PIPE_ACCESS_DUPLEX = 3;

			internal const int PIPE_TYPE_BYTE = 0;

			internal const int PIPE_TYPE_MESSAGE = 4;

			internal const int PIPE_READMODE_BYTE = 0;

			internal const int PIPE_READMODE_MESSAGE = 2;

			internal const int PIPE_UNLIMITED_INSTANCES = 255;
		}

		internal struct SECURITY_ATTRIBUTES
		{
			internal uint nLength;

			internal IntPtr lpSecurityDescriptor;

			internal BOOL bInheritHandle;
		}

		internal class SecurityOptions
		{
			internal const int SECURITY_SQOS_PRESENT = 1048576;

			internal const int SECURITY_ANONYMOUS = 0;

			internal const int SECURITY_IDENTIFICATION = 65536;

			internal const int SECURITY_IMPERSONATION = 131072;

			internal const int SECURITY_DELEGATION = 196608;
		}

		internal const uint SEM_FAILCRITICALERRORS = 1u;

		private const int FORMAT_MESSAGE_IGNORE_INSERTS = 512;

		private const int FORMAT_MESSAGE_FROM_HMODULE = 2048;

		private const int FORMAT_MESSAGE_FROM_SYSTEM = 4096;

		private const int FORMAT_MESSAGE_ARGUMENT_ARRAY = 8192;

		private const int ERROR_INSUFFICIENT_BUFFER = 122;

		private const int InitialBufferSize = 256;

		private const int BufferSizeIncreaseFactor = 4;

		private const int MaxAllowedBufferSize = 66560;

		internal const int MAX_PATH = 260;

		internal const int CREDUI_MAX_USERNAME_LENGTH = 513;

		[DllImport("kernel32.dll", SetLastError = true)]
		internal unsafe static extern bool CancelIoEx(SafeHandle handle, NativeOverlapped* lpOverlapped);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool CloseHandle(IntPtr handle);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal unsafe static extern bool ConnectNamedPipe(SafePipeHandle handle, NativeOverlapped* overlapped);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool ConnectNamedPipe(SafePipeHandle handle, IntPtr overlapped);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Unicode, EntryPoint = "CreateNamedPipeW", SetLastError = true)]
		internal static extern SafePipeHandle CreateNamedPipe(string pipeName, int openMode, int pipeMode, int maxInstances, int outBufferSize, int inBufferSize, int defaultTimeout, ref SECURITY_ATTRIBUTES securityAttributes);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Unicode, EntryPoint = "CreateFileW", SetLastError = true)]
		internal static extern SafePipeHandle CreateNamedPipeClient(string lpFileName, int dwDesiredAccess, FileShare dwShareMode, ref SECURITY_ATTRIBUTES secAttrs, FileMode dwCreationDisposition, int dwFlagsAndAttributes, IntPtr hTemplateFile);

		[DllImport("kernel32.dll", SetLastError = true)]
		internal static extern bool CreatePipe(out SafePipeHandle hReadPipe, out SafePipeHandle hWritePipe, ref SECURITY_ATTRIBUTES lpPipeAttributes, int nSize);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool DisconnectNamedPipe(SafePipeHandle hNamedPipe);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool DuplicateHandle(IntPtr hSourceProcessHandle, SafePipeHandle hSourceHandle, IntPtr hTargetProcessHandle, out SafePipeHandle lpTargetHandle, uint dwDesiredAccess, [MarshalAs(UnmanagedType.Bool)] bool bInheritHandle, uint dwOptions);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool FlushFileBuffers(SafeHandle hHandle);

		[DllImport("kernel32.dll", BestFitMapping = true, CharSet = CharSet.Unicode, EntryPoint = "FormatMessageW", SetLastError = true)]
		private unsafe static extern int FormatMessage(int dwFlags, IntPtr lpSource, uint dwMessageId, int dwLanguageId, char* lpBuffer, int nSize, IntPtr[] arguments);

		internal static string GetMessage(int errorCode)
		{
			return GetMessage(IntPtr.Zero, errorCode);
		}

		internal static string GetMessage(IntPtr moduleHandle, int errorCode)
		{
			Span<char> buffer = stackalloc char[256];
			do
			{
				if (TryGetErrorMessage(moduleHandle, errorCode, buffer, out var errorMsg))
				{
					return errorMsg;
				}
				buffer = new char[buffer.Length * 4];
			}
			while (buffer.Length < 66560);
			return $"Unknown error (0x{errorCode:x})";
		}

		private unsafe static bool TryGetErrorMessage(IntPtr moduleHandle, int errorCode, Span<char> buffer, out string errorMsg)
		{
			int num = 12800;
			if (moduleHandle != IntPtr.Zero)
			{
				num |= 0x800;
			}
			int num2;
			fixed (char* reference = &MemoryMarshal.GetReference(buffer))
			{
				num2 = FormatMessage(num, moduleHandle, (uint)errorCode, 0, reference, buffer.Length, null);
			}
			if (num2 != 0)
			{
				int num3;
				for (num3 = num2; num3 > 0; num3--)
				{
					char c = buffer[num3 - 1];
					if (c > ' ' && c != '.')
					{
						break;
					}
				}
				errorMsg = buffer.Slice(0, num3).ToString();
			}
			else
			{
				if (Marshal.GetLastWin32Error() == 122)
				{
					errorMsg = "";
					return false;
				}
				errorMsg = $"Unknown error (0x{errorCode:x})";
			}
			return true;
		}

		[DllImport("kernel32.dll", SetLastError = true)]
		internal static extern IntPtr GetCurrentProcess();

		[DllImport("kernel32.dll", SetLastError = true)]
		internal static extern int GetFileType(SafeHandle hFile);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Unicode, EntryPoint = "GetNamedPipeHandleStateW", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool GetNamedPipeHandleState(SafePipeHandle hNamedPipe, out int lpState, IntPtr lpCurInstances, IntPtr lpMaxCollectionCount, IntPtr lpCollectDataTimeout, IntPtr lpUserName, int nMaxUserNameSize);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Unicode, EntryPoint = "GetNamedPipeHandleStateW", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool GetNamedPipeHandleState(SafePipeHandle hNamedPipe, IntPtr lpState, IntPtr lpCurInstances, IntPtr lpMaxCollectionCount, IntPtr lpCollectDataTimeout, [Out] StringBuilder lpUserName, int nMaxUserNameSize);

		[DllImport("kernel32.dll", EntryPoint = "GetNamedPipeHandleStateW", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool GetNamedPipeHandleState(SafePipeHandle hNamedPipe, IntPtr lpState, out int lpCurInstances, IntPtr lpMaxCollectionCount, IntPtr lpCollectDataTimeout, IntPtr lpUserName, int nMaxUserNameSize);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool GetNamedPipeInfo(SafePipeHandle hNamedPipe, out int lpFlags, IntPtr lpOutBufferSize, IntPtr lpInBufferSize, IntPtr lpMaxInstances);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool GetNamedPipeInfo(SafePipeHandle hNamedPipe, IntPtr lpFlags, out int lpOutBufferSize, IntPtr lpInBufferSize, IntPtr lpMaxInstances);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool GetNamedPipeInfo(SafePipeHandle hNamedPipe, IntPtr lpFlags, IntPtr lpOutBufferSize, out int lpInBufferSize, IntPtr lpMaxInstances);

		[DllImport("kernel32.dll", SetLastError = true)]
		internal unsafe static extern int ReadFile(SafeHandle handle, byte* bytes, int numBytesToRead, out int numBytesRead, IntPtr mustBeZero);

		[DllImport("kernel32.dll", SetLastError = true)]
		internal unsafe static extern int ReadFile(SafeHandle handle, byte* bytes, int numBytesToRead, IntPtr numBytesRead_mustBeZero, NativeOverlapped* overlapped);

		[DllImport("kernel32.dll", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal unsafe static extern bool SetNamedPipeHandleState(SafePipeHandle hNamedPipe, int* lpMode, IntPtr lpMaxCollectionCount, IntPtr lpCollectDataTimeout);

		[DllImport("kernel32.dll", BestFitMapping = false, CharSet = CharSet.Unicode, EntryPoint = "WaitNamedPipeW", SetLastError = true)]
		[return: MarshalAs(UnmanagedType.Bool)]
		internal static extern bool WaitNamedPipe(string name, int timeout);

		[DllImport("kernel32.dll", SetLastError = true)]
		internal unsafe static extern int WriteFile(SafeHandle handle, byte* bytes, int numBytesToWrite, out int numBytesWritten, IntPtr mustBeZero);

		[DllImport("kernel32.dll", SetLastError = true)]
		internal unsafe static extern int WriteFile(SafeHandle handle, byte* bytes, int numBytesToWrite, IntPtr numBytesWritten_mustBeZero, NativeOverlapped* lpOverlapped);
	}
}
internal static class Consts
{
	public const string MonoCorlibVersion = "1A5E0066-58DC-428A-B21C-0AD6CDAE2789";

	public const string MonoVersion = "6.13.0.0";

	public const string MonoCompany = "Mono development team";

	public const string MonoProduct = "Mono Common Language Infrastructure";

	public const string MonoCopyright = "(c) Various Mono authors";

	public const string FxVersion = "4.0.0.0";

	public const string FxFileVersion = "4.6.57.0";

	public const string EnvironmentVersion = "4.0.30319.42000";

	public const string VsVersion = "0.0.0.0";

	public const string VsFileVersion = "11.0.0.0";

	private const string PublicKeyToken = "b77a5c561934e089";

	public const string AssemblyI18N = "I18N, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMicrosoft_JScript = "Microsoft.JScript, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblyMicrosoft_VisualStudio = "Microsoft.VisualStudio, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblyMicrosoft_VisualStudio_Web = "Microsoft.VisualStudio.Web, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblyMicrosoft_VSDesigner = "Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblyMono_Http = "Mono.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMono_Posix = "Mono.Posix, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMono_Security = "Mono.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyMono_Messaging_RabbitMQ = "Mono.Messaging.RabbitMQ, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";

	public const string AssemblyCorlib = "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem = "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem_Data = "System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem_Design = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_DirectoryServices = "System.DirectoryServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Drawing = "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Drawing_Design = "System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Messaging = "System.Messaging, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Security = "System.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_ServiceProcess = "System.ServiceProcess, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Web = "System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";

	public const string AssemblySystem_Windows_Forms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem_2_0 = "System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystemCore_3_5 = "System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string AssemblySystem_Core = "System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";

	public const string WindowsBase_3_0 = "WindowsBase, Version=3.0.0.0, PublicKeyToken=31bf3856ad364e35";

	public const string AssemblyWindowsBase = "WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	public const string AssemblyPresentationCore_3_5 = "PresentationCore, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	public const string AssemblyPresentationCore_4_0 = "PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	public const string AssemblyPresentationFramework_3_5 = "PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";

	public const string AssemblySystemServiceModel_3_0 = "System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
}
internal static class SR
{
	public const string ReducibleMustOverrideReduce = "reducible nodes must override Expression.Reduce()";

	public const string MustReduceToDifferent = "node cannot reduce to itself or null";

	public const string ReducedNotCompatible = "cannot assign from the reduced node type to the original node type";

	public const string SetterHasNoParams = "Setter must have parameters.";

	public const string PropertyCannotHaveRefType = "Property cannot have a managed pointer type.";

	public const string IndexesOfSetGetMustMatch = "Indexing parameters of getter and setter must match.";

	public const string AccessorsCannotHaveVarArgs = "Accessor method should not have VarArgs.";

	public const string AccessorsCannotHaveByRefArgs = "Accessor indexes cannot be passed ByRef.";

	public const string BoundsCannotBeLessThanOne = "Bounds count cannot be less than 1";

	public const string TypeMustNotBeByRef = "Type must not be ByRef";

	public const string TypeMustNotBePointer = "Type must not be a pointer type";

	public const string SetterMustBeVoid = "Setter should have void type.";

	public const string PropertyTypeMustMatchGetter = "Property type must match the value type of getter";

	public const string PropertyTypeMustMatchSetter = "Property type must match the value type of setter";

	public const string BothAccessorsMustBeStatic = "Both accessors must be static.";

	public const string OnlyStaticFieldsHaveNullInstance = "Static field requires null instance, non-static field requires non-null instance.";

	public const string OnlyStaticPropertiesHaveNullInstance = "Static property requires null instance, non-static property requires non-null instance.";

	public const string OnlyStaticMethodsHaveNullInstance = "Static method requires null instance, non-static method requires non-null instance.";

	public const string PropertyTypeCannotBeVoid = "Property cannot have a void type.";

	public const string InvalidUnboxType = "Can only unbox from an object or interface type to a value type.";

	public const string ExpressionMustBeWriteable = "Expression must be writeable";

	public const string ArgumentMustNotHaveValueType = "Argument must not have a value type.";

	public const string MustBeReducible = "must be reducible node";

	public const string AllTestValuesMustHaveSameType = "All test values must have the same type.";

	public const string AllCaseBodiesMustHaveSameType = "All case bodies and the default body must have the same type.";

	public const string DefaultBodyMustBeSupplied = "Default body must be supplied if case bodies are not System.Void.";

	public const string LabelMustBeVoidOrHaveExpression = "Label type must be System.Void if an expression is not supplied";

	public const string LabelTypeMustBeVoid = "Type must be System.Void for this label argument";

	public const string QuotedExpressionMustBeLambda = "Quoted expression must be a lambda";

	public const string VariableMustNotBeByRef = "Variable '{0}' uses unsupported type '{1}'. Reference types are not supported for variables.";

	public const string DuplicateVariable = "Found duplicate parameter '{0}'. Each ParameterExpression in the list must be a unique object.";

	public const string StartEndMustBeOrdered = "Start and End must be well ordered";

	public const string FaultCannotHaveCatchOrFinally = "fault cannot be used with catch or finally clauses";

	public const string TryMustHaveCatchFinallyOrFault = "try must have at least one catch, finally, or fault clause";

	public const string BodyOfCatchMustHaveSameTypeAsBodyOfTry = "Body of catch must have the same type as body of try.";

	public const string ExtensionNodeMustOverrideProperty = "Extension node must override the property {0}.";

	public const string UserDefinedOperatorMustBeStatic = "User-defined operator method '{0}' must be static.";

	public const string UserDefinedOperatorMustNotBeVoid = "User-defined operator method '{0}' must not be void.";

	public const string CoercionOperatorNotDefined = "No coercion operator is defined between types '{0}' and '{1}'.";

	public const string UnaryOperatorNotDefined = "The unary operator {0} is not defined for the type '{1}'.";

	public const string BinaryOperatorNotDefined = "The binary operator {0} is not defined for the types '{1}' and '{2}'.";

	public const string ReferenceEqualityNotDefined = "Reference equality is not defined for the types '{0}' and '{1}'.";

	public const string OperandTypesDoNotMatchParameters = "The operands for operator '{0}' do not match the parameters of method '{1}'.";

	public const string OverloadOperatorTypeDoesNotMatchConversionType = "The return type of overload method for operator '{0}' does not match the parameter type of conversion method '{1}'.";

	public const string ConversionIsNotSupportedForArithmeticTypes = "Conversion is not supported for arithmetic types without operator overloading.";

	public const string ArgumentMustBeArray = "Argument must be array";

	public const string ArgumentMustBeBoolean = "Argument must be boolean";

	public const string EqualityMustReturnBoolean = "The user-defined equality method '{0}' must return a boolean value.";

	public const string ArgumentMustBeFieldInfoOrPropertyInfo = "Argument must be either a FieldInfo or PropertyInfo";

	public const string ArgumentMustBeFieldInfoOrPropertyInfoOrMethod = "Argument must be either a FieldInfo, PropertyInfo or MethodInfo";

	public const string ArgumentMustBeInstanceMember = "Argument must be an instance member";

	public const string ArgumentMustBeInteger = "Argument must be of an integer type";

	public const string ArgumentMustBeArrayIndexType = "Argument for array index must be of type Int32";

	public const string ArgumentMustBeSingleDimensionalArrayType = "Argument must be single-dimensional, zero-based array type";

	public const string ArgumentTypesMustMatch = "Argument types do not match";

	public const string CannotAutoInitializeValueTypeElementThroughProperty = "Cannot auto initialize elements of value type through property '{0}', use assignment instead";

	public const string CannotAutoInitializeValueTypeMemberThroughProperty = "Cannot auto initialize members of value type through property '{0}', use assignment instead";

	public const string IncorrectTypeForTypeAs = "The type used in TypeAs Expression must be of reference or nullable type, {0} is neither";

	public const string CoalesceUsedOnNonNullType = "Coalesce used with type that cannot be null";

	public const string ExpressionTypeCannotInitializeArrayType = "An expression of type '{0}' cannot be used to initialize an array of type '{1}'";

	public const string ArgumentTypeDoesNotMatchMember = " Argument type '{0}' does not match the corresponding member type '{1}'";

	public const string ArgumentMemberNotDeclOnType = " The member '{0}' is not declared on type '{1}' being created";

	public const string ExpressionTypeDoesNotMatchReturn = "Expression of type '{0}' cannot be used for return type '{1}'";

	public const string ExpressionTypeDoesNotMatchAssignment = "Expression of type '{0}' cannot be used for assignment to type '{1}'";

	public const string ExpressionTypeDoesNotMatchLabel = "Expression of type '{0}' cannot be used for label of type '{1}'";

	public const string ExpressionTypeNotInvocable = "Expression of type '{0}' cannot be invoked";

	public const string FieldNotDefinedForType = "Field '{0}' is not defined for type '{1}'";

	public const string InstanceFieldNotDefinedForType = "Instance field '{0}' is not defined for type '{1}'";

	public const string FieldInfoNotDefinedForType = "Field '{0}.{1}' is not defined for type '{2}'";

	public const string IncorrectNumberOfIndexes = "Incorrect number of indexes";

	public const string IncorrectNumberOfLambdaDeclarationParameters = "Incorrect number of parameters supplied for lambda declaration";

	public const string IncorrectNumberOfMembersForGivenConstructor = " Incorrect number of members for constructor";

	public const string IncorrectNumberOfArgumentsForMembers = "Incorrect number of arguments for the given members ";

	public const string LambdaTypeMustBeDerivedFromSystemDelegate = "Lambda type parameter must be derived from System.MulticastDelegate";

	public const string MemberNotFieldOrProperty = "Member '{0}' not field or property";

	public const string MethodContainsGenericParameters = "Method {0} contains generic parameters";

	public const string MethodIsGeneric = "Method {0} is a generic method definition";

	public const string MethodNotPropertyAccessor = "The method '{0}.{1}' is not a property accessor";

	public const string PropertyDoesNotHaveGetter = "The property '{0}' has no 'get' accessor";

	public const string PropertyDoesNotHaveSetter = "The property '{0}' has no 'set' accessor";

	public const string PropertyDoesNotHaveAccessor = "The property '{0}' has no 'get' or 'set' accessors";

	public const string NotAMemberOfType = "'{0}' is not a member of type '{1}'";

	public const string NotAMemberOfAnyType = "'{0}' is not a member of any type";

	public const string UnsupportedExpressionType = "The expression type '{0}' is not supported";

	public const string ParameterExpressionNotValidAsDelegate = "ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'";

	public const string PropertyNotDefinedForType = "Property '{0}' is not defined for type '{1}'";

	public const string InstancePropertyNotDefinedForType = "Instance property '{0}' is not defined for type '{1}'";

	public const string InstancePropertyWithoutParameterNotDefinedForType = "Instance property '{0}' that takes no argument is not defined for type '{1}'";

	public const string InstancePropertyWithSpecifiedParametersNotDefinedForType = "Instance property '{0}{1}' is not defined for type '{2}'";

	public const string InstanceAndMethodTypeMismatch = "Method '{0}' declared on type '{1}' cannot be called with instance of type '{2}'";

	public const string TypeContainsGenericParameters = "Type {0} contains generic parameters";

	public const string TypeIsGeneric = "Type {0} is a generic type definition";

	public const string TypeMissingDefaultConstructor = "Type '{0}' does not have a default constructor";

	public const string ElementInitializerMethodNotAdd = "Element initializer method must be named 'Add'";

	public const string ElementInitializerMethodNoRefOutParam = "Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter";

	public const string ElementInitializerMethodWithZeroArgs = "Element initializer method must have at least 1 parameter";

	public const string ElementInitializerMethodStatic = "Element initializer method must be an instance method";

	public const string TypeNotIEnumerable = "Type '{0}' is not IEnumerable";

	public const string UnhandledBinary = "Unhandled binary: {0}";

	public const string UnhandledBinding = "Unhandled binding ";

	public const string UnhandledBindingType = "Unhandled Binding Type: {0}";

	public const string UnhandledUnary = "Unhandled unary: {0}";

	public const string UnknownBindingType = "Unknown binding type";

	public const string UserDefinedOpMustHaveConsistentTypes = "The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types.";

	public const string UserDefinedOpMustHaveValidReturnType = "The user-defined operator method '{1}' for operator '{0}' must return the same type as its parameter or a derived type.";

	public const string LogicalOperatorMustHaveBooleanOperators = "The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators.";

	public const string MethodWithArgsDoesNotExistOnType = "No method '{0}' on type '{1}' is compatible with the supplied arguments.";

	public const string GenericMethodWithArgsDoesNotExistOnType = "No generic method '{0}' on type '{1}' is compatible with the supplied type arguments and arguments. No type arguments should be provided if the method is non-generic. ";

	public const string MethodWithMoreThanOneMatch = "More than one method '{0}' on type '{1}' is compatible with the supplied arguments.";

	public const string PropertyWithMoreThanOneMatch = "More than one property '{0}' on type '{1}' is compatible with the supplied arguments.";

	public const string IncorrectNumberOfTypeArgsForFunc = "An incorrect number of type arguments were specified for the declaration of a Func type.";

	public const string IncorrectNumberOfTypeArgsForAction = "An incorrect number of type arguments were specified for the declaration of an Action type.";

	public const string ArgumentCannotBeOfTypeVoid = "Argument type cannot be System.Void.";

	public const string OutOfRange = "{0} must be greater than or equal to {1}";

	public const string LabelTargetAlreadyDefined = "Cannot redefine label '{0}' in an inner block.";

	public const string LabelTargetUndefined = "Cannot jump to undefined label '{0}'.";

	public const string ControlCannotLeaveFinally = "Control cannot leave a finally block.";

	public const string ControlCannotLeaveFilterTest = "Control cannot leave a filter test.";

	public const string AmbiguousJump = "Cannot jump to ambiguous label '{0}'.";

	public const string ControlCannotEnterTry = "Control cannot enter a try block.";

	public const string ControlCannotEnterExpression = "Control cannot enter an expression--only statements can be jumped into.";

	public const string NonLocalJumpWithValue = "Cannot jump to non-local label '{0}' with a value. Only jumps to labels defined in outer blocks can pass values.";

	public const string CannotCompileConstant = "CompileToMethod cannot compile constant '{0}' because it is a non-trivial value, such as a live object. Instead, create an expression tree that can construct this value.";

	public const string CannotCompileDynamic = "Dynamic expressions are not supported by CompileToMethod. Instead, create an expression tree that uses System.Runtime.CompilerServices.CallSite.";

	public const string InvalidLvalue = "Invalid lvalue for assignment: {0}.";

	public const string UndefinedVariable = "variable '{0}' of type '{1}' referenced from scope '{2}', but it is not defined";

	public const string CannotCloseOverByRef = "Cannot close over byref parameter '{0}' referenced in lambda '{1}'";

	public const string UnexpectedVarArgsCall = "Unexpected VarArgs call to method '{0}'";

	public const string RethrowRequiresCatch = "Rethrow statement is valid only inside a Catch block.";

	public const string TryNotAllowedInFilter = "Try expression is not allowed inside a filter body.";

	public const string MustRewriteToSameNode = "When called from '{0}', rewriting a node of type '{1}' must return a non-null value of the same type. Alternatively, override '{2}' and change it to not visit children of this type.";

	public const string MustRewriteChildToSameType = "Rewriting child expression from type '{0}' to type '{1}' is not allowed, because it would change the meaning of the operation. If this is intentional, override '{2}' and change it to allow this rewrite.";

	public const string MustRewriteWithoutMethod = "Rewritten expression calls operator method '{0}', but the original node had no operator method. If this is intentional, override '{1}' and change it to allow this rewrite.";

	public const string InvalidNullValue = "The value null is not of type '{0}' and cannot be used in this collection.";

	public const string InvalidObjectType = "The value '{0}' is not of type '{1}' and cannot be used in this collection.";

	public const string TryNotSupportedForMethodsWithRefArgs = "TryExpression is not supported as an argument to method '{0}' because it has an argument with by-ref type. Construct the tree so the TryExpression is not nested inside of this expression.";

	public const string TryNotSupportedForValueTypeInstances = "TryExpression is not supported as a child expression when accessing a member on type '{0}' because it is a value type. Construct the tree so the TryExpression is not nested inside of this expression.";

	public const string EnumerationIsDone = "Enumeration has either not started or has already finished.";

	public const string TestValueTypeDoesNotMatchComparisonMethodParameter = "Test value of type '{0}' cannot be used for the comparison method parameter of type '{1}'";

	public const string SwitchValueTypeDoesNotMatchComparisonMethodParameter = "Switch value of type '{0}' cannot be used for the comparison method parameter of type '{1}'";

	public const string PdbGeneratorNeedsExpressionCompiler = "DebugInfoGenerator created by CreatePdbGenerator can only be used with LambdaExpression.CompileToMethod.";

	public const string InvalidArgumentValue = "Invalid argument value";

	public const string NonEmptyCollectionRequired = "Non-empty collection required";

	public const string CollectionModifiedWhileEnumerating = "Collection was modified; enumeration operation may not execute.";

	public const string ExpressionMustBeReadable = "Expression must be readable";

	public const string ExpressionTypeDoesNotMatchMethodParameter = "Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'";

	public const string ExpressionTypeDoesNotMatchParameter = "Expression of type '{0}' cannot be used for parameter of type '{1}'";

	public const string ExpressionTypeDoesNotMatchConstructorParameter = "Expression of type '{0}' cannot be used for constructor parameter of type '{1}'";

	public const string IncorrectNumberOfMethodCallArguments = "Incorrect number of arguments supplied for call to method '{0}'";

	public const string IncorrectNumberOfLambdaArguments = "Incorrect number of arguments supplied for lambda invocation";

	public const string IncorrectNumberOfConstructorArguments = "Incorrect number of arguments for constructor";

	public const string NonStaticConstructorRequired = "The constructor should not be static";

	public const string NonAbstractConstructorRequired = "Can't compile a NewExpression with a constructor declared on an abstract class";

	public const string FirstArgumentMustBeCallSite = "First argument of delegate must be CallSite";

	public const string NoOrInvalidRuleProduced = "No or Invalid rule produced";

	public const string TypeMustBeDerivedFromSystemDelegate = "Type must be derived from System.Delegate";

	public const string TypeParameterIsNotDelegate = "Type parameter is {0}. Expected a delegate.";

	public const string ArgumentTypeCannotBeVoid = "Argument type cannot be void";

	public const string ArgCntMustBeGreaterThanNameCnt = "Argument count must be greater than number of named arguments.";

	public const string BinderNotCompatibleWithCallSite = "The result type '{0}' of the binder '{1}' is not compatible with the result type '{2}' expected by the call site.";

	public const string BindingCannotBeNull = "Bind cannot return null.";

	public const string DynamicBinderResultNotAssignable = "The result type '{0}' of the dynamic binding produced by binder '{1}' is not compatible with the result type '{2}' expected by the call site.";

	public const string DynamicBindingNeedsRestrictions = "The result of the dynamic binding produced by the object with type '{0}' for the binder '{1}' needs at least one restriction.";

	public const string DynamicObjectResultNotAssignable = "The result type '{0}' of the dynamic binding produced by the object with type '{1}' for the binder '{2}' is not compatible with the result type '{3}' expected by the call site.";

	public const string InvalidMetaObjectCreated = "An IDynamicMetaObjectProvider {0} created an invalid DynamicMetaObject instance.";

	public const string AmbiguousMatchInExpandoObject = "More than one key matching '{0}' was found in the ExpandoObject.";

	public const string CollectionReadOnly = "Collection is read-only.";

	public const string KeyDoesNotExistInExpando = "The specified key '{0}' does not exist in the ExpandoObject.";

	public const string SameKeyExistsInExpando = "An element with the same key '{0}' already exists in the ExpandoObject.";

	public const string Arg_KeyNotFoundWithKey = "The given key '{0}' was not present in the dictionary.";

	public const string EmptyEnumerable = "Enumeration yielded no results";

	public const string MoreThanOneElement = "Sequence contains more than one element";

	public const string MoreThanOneMatch = "Sequence contains more than one matching element";

	public const string NoElements = "Sequence contains no elements";

	public const string NoMatch = "Sequence contains no matching element";

	public const string ParallelPartitionable_NullReturn = "The return value must not be null.";

	public const string ParallelPartitionable_IncorretElementCount = "The returned array's length must equal the number of partitions requested.";

	public const string ParallelPartitionable_NullElement = "Elements returned must not be null.";

	public const string PLINQ_CommonEnumerator_Current_NotStarted = "Enumeration has not started. MoveNext must be called to initiate enumeration.";

	public const string PLINQ_ExternalCancellationRequested = "The query has been canceled via the token supplied to WithCancellation.";

	public const string PLINQ_DisposeRequested = "The query enumerator has been disposed.";

	public const string ParallelQuery_DuplicateTaskScheduler = "The WithTaskScheduler operator may be used at most once in a query.";

	public const string ParallelQuery_DuplicateDOP = "The WithDegreeOfParallelism operator may be used at most once in a query.";

	public const string ParallelQuery_DuplicateExecutionMode = "The WithExecutionMode operator may be used at most once in a query.";

	public const string PartitionerQueryOperator_NullPartitionList = "Partitioner returned null instead of a list of partitions.";

	public const string PartitionerQueryOperator_WrongNumberOfPartitions = "Partitioner returned a wrong number of partitions.";

	public const string PartitionerQueryOperator_NullPartition = "Partitioner returned a null partition.";

	public const string ParallelQuery_DuplicateWithCancellation = "The WithCancellation operator may by used at most once in a query.";

	public const string ParallelQuery_DuplicateMergeOptions = "The WithMergeOptions operator may be used at most once in a query.";

	public const string PLINQ_EnumerationPreviouslyFailed = "The query enumerator previously threw an exception.";

	public const string ParallelQuery_PartitionerNotOrderable = "AsOrdered may not be used with a partitioner that is not orderable.";

	public const string ParallelQuery_InvalidAsOrderedCall = "AsOrdered may only be called on the result of AsParallel, ParallelEnumerable.Range, or ParallelEnumerable.Repeat.";

	public const string ParallelQuery_InvalidNonGenericAsOrderedCall = "Non-generic AsOrdered may only be called on the result of the non-generic AsParallel.";

	public const string ParallelEnumerable_BinaryOpMustUseAsParallel = "The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.";

	public const string ParallelEnumerable_WithQueryExecutionMode_InvalidMode = "The executionMode argument contains an invalid value.";

	public const string ParallelEnumerable_WithMergeOptions_InvalidOptions = "The mergeOptions argument contains an invalid value.";

	public const string ArgumentNotIEnumerableGeneric = "{0} is not IEnumerable<>";

	public const string ArgumentNotValid = "Argument {0} is not valid";

	public const string NoMethodOnType = "There is no method '{0}' on type '{1}'";

	public const string NoMethodOnTypeMatchingArguments = "There is no method '{0}' on type '{1}' that matches the specified arguments";

	public const string EnumeratingNullEnumerableExpression = "Cannot enumerate a query created from a null IEnumerable<>";

	public const string ArgumentOutOfRange_NeedNonNegNum = "Non negative number is required.";

	public const string ArgumentOutOfRange_NeedValidPipeAccessRights = "Invalid PipeAccessRights value.";

	public const string Argument_InvalidOffLen = "Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.";

	public const string Argument_NeedNonemptyPipeName = "pipeName cannot be an empty string.";

	public const string Argument_NonContainerInvalidAnyFlag = "This flag may not be set on a pipe.";

	public const string Argument_EmptyServerName = "serverName cannot be an empty string.  Use \\\\\\\".\\\\\\\" for current machine.";

	public const string Argument_InvalidHandle = "Invalid handle.";

	public const string ArgumentNull_Buffer = "Buffer cannot be null.";

	public const string ArgumentNull_ServerName = "serverName cannot be null. Use \\\".\\\" for current machine.";

	public const string ArgumentOutOfRange_AnonymousReserved = "The pipeName \\\"anonymous\\\" is reserved.";

	public const string ArgumentOutOfRange_TransmissionModeByteOrMsg = "For named pipes, transmission mode can be TransmissionMode.Byte or PipeTransmissionMode.Message. For anonymous pipes, transmission mode can be TransmissionMode.Byte.";

	public const string ArgumentOutOfRange_DirectionModeInOutOrInOut = "For named pipes, the pipe direction can be PipeDirection.In, PipeDirection.Out or PipeDirection.InOut. For anonymous pipes, the pipe direction can be PipeDirection.In or PipeDirection.Out.";

	public const string ArgumentOutOfRange_ImpersonationInvalid = "TokenImpersonationLevel.None, TokenImpersonationLevel.Anonymous, TokenImpersonationLevel.Identification, TokenImpersonationLevel.Impersonation or TokenImpersonationLevel.Delegation required.";

	public const string ArgumentOutOfRange_OptionsInvalid = "options contains an invalid flag.";

	public const string ArgumentOutOfRange_HandleInheritabilityNoneOrInheritable = "HandleInheritability.None or HandleInheritability.Inheritable required.";

	public const string ArgumentOutOfRange_InvalidTimeout = "Timeout must be non-negative or equal to -1 (Timeout.Infinite)";

	public const string ArgumentOutOfRange_MaxNumServerInstances = "maxNumberOfServerInstances must either be a value between 1 and 254, or NamedPipeServerStream.MaxAllowedServerInstances (to obtain the maximum number allowed by system resources).";

	public const string ArgumentOutOfRange_NeedPosNum = "Positive number required.";

	public const string InvalidOperation_PipeNotYetConnected = "Pipe hasn't been connected yet.";

	public const string InvalidOperation_PipeDisconnected = "Pipe is in a disconnected state.";

	public const string InvalidOperation_PipeHandleNotSet = "Pipe handle has not been set.  Did your PipeStream implementation call InitializeHandle?";

	public const string InvalidOperation_PipeNotAsync = "Pipe is not opened in asynchronous mode.";

	public const string InvalidOperation_PipeReadModeNotMessage = "ReadMode is not of PipeTransmissionMode.Message.";

	public const string InvalidOperation_PipeAlreadyConnected = "Already in a connected state.";

	public const string InvalidOperation_PipeAlreadyDisconnected = "Already in a disconnected state.";

	public const string IO_EOF_ReadBeyondEOF = "Unable to read beyond the end of the stream.";

	public const string IO_FileNotFound = "Unable to find the specified file.";

	public const string IO_FileNotFound_FileName = "Could not find file '{0}'.";

	public const string IO_AlreadyExists_Name = "Cannot create \\\"{0}\\\" because a file or directory with the same name already exists.";

	public const string IO_FileExists_Name = "The file '{0}' already exists.";

	public const string IO_IO_PipeBroken = "Pipe is broken.";

	public const string IO_OperationAborted = "IO operation was aborted unexpectedly.";

	public const string IO_SharingViolation_File = "The process cannot access the file '{0}' because it is being used by another process.";

	public const string IO_SharingViolation_NoFileName = "The process cannot access the file because it is being used by another process.";

	public const string IO_PipeBroken = "Pipe is broken.";

	public const string IO_InvalidPipeHandle = "Invalid pipe handle.";

	public const string IO_PathNotFound_Path = "Could not find a part of the path '{0}'.";

	public const string IO_PathNotFound_NoPathName = "Could not find a part of the path.";

	public const string IO_PathTooLong = "The specified file name or path is too long, or a component of the specified path is too long.";

	public const string NotSupported_UnreadableStream = "Stream does not support reading.";

	public const string NotSupported_UnseekableStream = "Stream does not support seeking.";

	public const string NotSupported_UnwritableStream = "Stream does not support writing.";

	public const string NotSupported_AnonymousPipeUnidirectional = "Anonymous pipes can only be in one direction.";

	public const string NotSupported_AnonymousPipeMessagesNotSupported = "Anonymous pipes do not support PipeTransmissionMode.Message ReadMode.";

	public const string ObjectDisposed_PipeClosed = "Cannot access a closed pipe.";

	public const string UnauthorizedAccess_IODenied_Path = "Access to the path '{0}' is denied.";

	public const string UnauthorizedAccess_IODenied_NoPathName = "Access to the path is denied.";

	public const string ArgumentOutOfRange_FileLengthTooBig = "Specified file length was too large for the file system.";

	public const string PlatformNotSupported_MessageTransmissionMode = "Message transmission mode is not supported on this platform.";

	public const string PlatformNotSupported_RemotePipes = "Access to remote named pipes is not supported on this platform.";

	public const string PlatformNotSupported_InvalidPipeNameChars = "The name of a pipe on this platform must be a valid file name or a valid absolute path to a file name.";

	public const string ObjectDisposed_StreamClosed = "Cannot access a closed Stream.";

	public const string PlatformNotSupported_OperatingSystemError = "The operating system returned error '{0}' indicating that the operation is not supported.";

	public const string IO_AllPipeInstancesAreBusy = "All pipe instances are busy.";

	public const string IO_PathTooLong_Path = "The path '{0}' is too long, or a component of the specified path is too long.";

	public const string UnauthorizedAccess_NotOwnedByCurrentUser = "Could not connect to the pipe because it was not owned by the current user.";

	public const string UnauthorizedAccess_ClientIsNotCurrentUser = "Client connection (user id {0}) was refused because it was not owned by the current user (id {1}).";

	public const string net_invalidversion = "This protocol version is not supported.";

	public const string net_noseek = "This stream does not support seek operations.";

	public const string net_invasync = "Cannot block a call on this socket while an earlier asynchronous call is in progress.";

	public const string net_io_timeout_use_gt_zero = "Timeout can be only be set to 'System.Threading.Timeout.Infinite' or a value > 0.";

	public const string net_notconnected = "The operation is not allowed on non-connected sockets.";

	public const string net_notstream = "The operation is not allowed on non-stream oriented sockets.";

	public const string net_stopped = "Not listening. You must call the Start() method before calling this method.";

	public const string net_udpconnected = "Cannot send packets to an arbitrary host while connected.";

	public const string net_readonlystream = "The stream does not support writing.";

	public const string net_writeonlystream = "The stream does not support reading.";

	public const string net_InvalidAddressFamily = "The AddressFamily {0} is not valid for the {1} end point, use {2} instead.";

	public const string net_InvalidEndPointAddressFamily = "The supplied EndPoint of AddressFamily {0} is not valid for this Socket, use {1} instead.";

	public const string net_InvalidSocketAddressSize = "The supplied {0} is an invalid size for the {1} end point.";

	public const string net_invalidAddressList = "None of the discovered or specified addresses match the socket address family.";

	public const string net_completed_result = "This operation cannot be performed on a completed asynchronous result object.";

	public const string net_protocol_invalid_family = "'{0}' Client can only accept InterNetwork or InterNetworkV6 addresses.";

	public const string net_protocol_invalid_multicast_family = "Multicast family is not the same as the family of the '{0}' Client.";

	public const string net_sockets_zerolist = "The parameter {0} must contain one or more elements.";

	public const string net_sockets_blocking = "The operation is not allowed on a non-blocking Socket.";

	public const string net_sockets_useblocking = "Use the Blocking property to change the status of the Socket.";

	public const string net_sockets_select = "The operation is not allowed on objects of type {0}. Use only objects of type {1}.";

	public const string net_sockets_toolarge_select = "The {0} list contains too many items; a maximum of {1} is allowed.";

	public const string net_sockets_empty_select = "All lists are either null or empty.";

	public const string net_sockets_mustbind = "You must call the Bind method before performing this operation.";

	public const string net_sockets_mustlisten = "You must call the Listen method before performing this operation.";

	public const string net_sockets_mustnotlisten = "You may not perform this operation after calling the Listen method.";

	public const string net_sockets_mustnotbebound = "The socket must not be bound or connected.";

	public const string net_sockets_namedmustnotbebound = "{0}: The socket must not be bound or connected.";

	public const string net_sockets_invalid_ipaddress_length = "The number of specified IP addresses has to be greater than 0.";

	public const string net_sockets_invalid_optionValue = "The specified value is not a valid '{0}'.";

	public const string net_sockets_invalid_optionValue_all = "The specified value is not valid.";

	public const string net_sockets_invalid_dnsendpoint = "The parameter {0} must not be of type DnsEndPoint.";

	public const string net_sockets_disconnectedConnect = "Once the socket has been disconnected, you can only reconnect again asynchronously, and only to a different EndPoint.  BeginConnect must be called on a thread that won't exit until the operation has been completed.";

	public const string net_sockets_disconnectedAccept = "Once the socket has been disconnected, you can only accept again asynchronously.  BeginAccept must be called on a thread that won't exit until the operation has been completed.";

	public const string net_tcplistener_mustbestopped = "The TcpListener must not be listening before performing this operation.";

	public const string net_socketopinprogress = "An asynchronous socket operation is already in progress using this SocketAsyncEventArgs instance.";

	public const string net_buffercounttoosmall = "The Buffer space specified by the Count property is insufficient for the AcceptAsync method.";

	public const string net_multibuffernotsupported = "Multiple buffers cannot be used with this method.";

	public const string net_ambiguousbuffers = "Buffer and BufferList properties cannot both be non-null.";

	public const string net_io_writefailure = "Unable to write data to the transport connection: {0}.";

	public const string net_io_readfailure = "Unable to read data from the transport connection: {0}.";

	public const string net_io_invalidasyncresult = "The IAsyncResult object was not returned from the corresponding asynchronous method on this class.";

	public const string net_io_invalidendcall = "{0} can only be called once for each asynchronous operation.";

	public const string net_value_cannot_be_negative = "The specified value cannot be negative.";

	public const string ArgumentOutOfRange_Bounds_Lower_Upper = "Argument must be between {0} and {1}.";

	public const string net_sockets_connect_multiconnect_notsupported = "Sockets on this platform are invalid for use after a failed connection attempt.";

	public const string net_sockets_dualmode_receivefrom_notsupported = "This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.";

	public const string net_sockets_accept_receive_notsupported = "This platform does not support receiving data with Socket.AcceptAsync.  Instead, make a separate call to Socket.ReceiveAsync.";

	public const string net_sockets_duplicateandclose_notsupported = "This platform does not support Socket.DuplicateAndClose.  Instead, create a new socket.";

	public const string net_sockets_transmitfileoptions_notsupported = "This platform does not support TransmitFileOptions other than TransmitFileOptions.UseDefaultWorkerThread.";

	public const string ArgumentOutOfRange_PathLengthInvalid = "The path '{0}' is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and {1} characters, inclusive.";

	public const string net_io_readwritefailure = "Unable to transfer data on the transport connection: {0}.";

	public const string PlatformNotSupported_AcceptSocket = "Accepting into an existing Socket is not supported on this platform.";

	public const string PlatformNotSupported_IOControl = "Socket.IOControl handles Windows-specific control codes and is not supported on this platform.";

	public const string PlatformNotSupported_IPProtectionLevel = "IP protection level cannot be controlled on this platform.";

	public const string InvalidOperation_BufferNotExplicitArray = "This operation may only be performed when the buffer was set using the SetBuffer overload that accepts an array.";

	public const string InvalidOperation_IncorrectToken = "The result of the operation was already consumed and may not be used again.";

	public const string InvalidOperation_MultipleContinuations = "Another continuation was already registered.";

	public const string Argument_InvalidOidValue = "The OID value was invalid.";

	public const string Argument_InvalidValue = "Value was invalid.";

	public const string Arg_CryptographyException = "Error occurred during a cryptographic operation.";

	public const string Cryptography_ArgECDHKeySizeMismatch = "The keys from both parties must be the same size to generate a secret agreement.";

	public const string Cryptography_ArgECDHRequiresECDHKey = "Keys used with the ECDiffieHellmanCng algorithm must have an algorithm group of ECDiffieHellman.";

	public const string Cryptography_TlsRequiresLabelAndSeed = "The TLS key derivation function requires both the label and seed properties to be set.";

	public const string Cryptography_TlsRequires64ByteSeed = "The TLS key derivation function requires a seed value of exactly 64 bytes.";

	public const string Cryptography_BadHashSize_ForAlgorithm = "The provided value of {0} bytes does not match the expected size of {1} bytes for the algorithm ({2}).";

	public const string Cryptography_Config_EncodedOIDError = "Encoded OID length is too large (greater than 0x7f bytes).";

	public const string Cryptography_CSP_NoPrivateKey = "Object contains only the public half of a key pair. A private key must also be provided.";

	public const string Cryptography_Der_Invalid_Encoding = "ASN1 corrupted data.";

	public const string Cryptography_DSA_KeyGenNotSupported = "DSA keys can be imported, but new key generation is not supported on this platform.";

	public const string Cryptography_Encryption_MessageTooLong = "The message exceeds the maximum allowable length for the chosen options ({0}).";

	public const string Cryptography_ECXmlSerializationFormatRequired = "XML serialization of an elliptic curve key requires using an overload which specifies the XML format to be used.";

	public const string Cryptography_ECC_NamedCurvesOnly = "Only named curves are supported on this platform.";

	public const string Cryptography_HashAlgorithmNameNullOrEmpty = "The hash algorithm name cannot be null or empty.";

	public const string Cryptography_InvalidOID = "Object identifier (OID) is unknown.";

	public const string Cryptography_CurveNotSupported = "The specified curve '{0}' or its parameters are not valid for this platform.";

	public const string Cryptography_InvalidCurveOid = "The specified Oid is not valid. The Oid.FriendlyName or Oid.Value property must be set.";

	public const string Cryptography_InvalidCurveKeyParameters = "The specified key parameters are not valid. Q.X and Q.Y are required fields. Q.X, Q.Y must be the same length. If D is specified it must be the same length as Q.X and Q.Y for named curves or the same length as Order for explicit curves.";

	public const string Cryptography_InvalidDsaParameters_MissingFields = "The specified DSA parameters are not valid; P, Q, G and Y are all required.";

	public const string Cryptography_InvalidDsaParameters_MismatchedPGY = "The specified DSA parameters are not valid; P, G and Y must be the same length (the key size).";

	public const string Cryptography_InvalidDsaParameters_MismatchedQX = "The specified DSA parameters are not valid; Q and X (if present) must be the same length.";

	public const string Cryptography_InvalidDsaParameters_MismatchedPJ = "The specified DSA parameters are not valid; J (if present) must be shorter than P.";

	public const string Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey = "The specified DSA parameters are not valid; Seed, if present, must be 20 bytes long for keys shorter than 1024 bits.";

	public const string Cryptography_InvalidDsaParameters_QRestriction_ShortKey = "The specified DSA parameters are not valid; Q must be 20 bytes long for keys shorter than 1024 bits.";

	public const string Cryptography_InvalidDsaParameters_QRestriction_LargeKey = "The specified DSA parameters are not valid; Q's length must be one of 20, 32 or 64 bytes.";

	public const string Cryptography_InvalidECCharacteristic2Curve = "The specified Characteristic2 curve parameters are not valid. Polynomial, A, B, G.X, G.Y, and Order are required. A, B, G.X, G.Y must be the same length, and the same length as Q.X, Q.Y and D if those are specified. Seed, Cofactor and Hash are optional. Other parameters are not allowed.";

	public const string Cryptography_InvalidECPrimeCurve = "The specified prime curve parameters are not valid. Prime, A, B, G.X, G.Y and Order are required and must be the same length, and the same length as Q.X, Q.Y and D if those are specified. Seed, Cofactor and Hash are optional. Other parameters are not allowed.";

	public const string Cryptography_InvalidECNamedCurve = "The specified named curve parameters are not valid. Only the Oid parameter must be set.";

	public const string Cryptography_InvalidKeySize = "Specified key is not a valid size for this algorithm.";

	public const string Cryptography_InvalidKey_SemiWeak = "Specified key is a known semi-weak key for '{0}' and cannot be used.";

	public const string Cryptography_InvalidKey_Weak = "Specified key is a known weak key for '{0}' and cannot be used.";

	public const string Cryptography_InvalidIVSize = "Specified initialization vector (IV) does not match the block size for this algorithm.";

	public const string Cryptography_InvalidOperation = "This operation is not supported for this class.";

	public const string Cryptography_InvalidPadding = "Padding is invalid and cannot be removed.";

	public const string Cryptography_InvalidRsaParameters = "The specified RSA parameters are not valid; both Exponent and Modulus are required fields.";

	public const string Cryptography_InvalidPaddingMode = "Specified padding mode is not valid for this algorithm.";

	public const string Cryptography_Invalid_IA5String = "The string contains a character not in the 7 bit ASCII character set.";

	public const string Cryptography_KeyTooSmall = "The key is too small for the requested operation.";

	public const string Cryptography_MissingIV = "The cipher mode specified requires that an initialization vector (IV) be used.";

	public const string Cryptography_MissingKey = "No asymmetric key object has been associated with this formatter object.";

	public const string Cryptography_MissingOID = "Required object identifier (OID) cannot be found.";

	public const string Cryptography_MustTransformWholeBlock = "TransformBlock may only process bytes in block sized increments.";

	public const string Cryptography_NotValidPrivateKey = "Key is not a valid private key.";

	public const string Cryptography_NotValidPublicOrPrivateKey = "Key is not a valid public or private key.";

	public const string Cryptography_OAEP_Decryption_Failed = "Error occurred while decoding OAEP padding.";

	public const string Cryptography_OpenInvalidHandle = "Cannot open an invalid handle.";

	public const string Cryptography_PartialBlock = "The input data is not a complete block.";

	public const string Cryptography_PasswordDerivedBytes_FewBytesSalt = "Salt is not at least eight bytes.";

	public const string Cryptography_RC2_EKS40 = "EffectiveKeySize value must be at least 40 bits.";

	public const string Cryptography_RC2_EKSKS = "KeySize value must be at least as large as the EffectiveKeySize value.";

	public const string Cryptography_RC2_EKSKS2 = "EffectiveKeySize must be the same as KeySize in this implementation.";

	public const string Cryptography_Rijndael_BlockSize = "BlockSize must be 128 in this implementation.";

	public const string Cryptography_RSA_DecryptWrongSize = "The length of the data to decrypt is not valid for the size of this key.";

	public const string Cryptography_SignHash_WrongSize = "The provided hash value is not the expected size for the specified hash algorithm.";

	public const string Cryptography_TransformBeyondEndOfBuffer = "Attempt to transform beyond end of buffer.";

	public const string Cryptography_CipherModeNotSupported = "The specified CipherMode '{0}' is not supported.";

	public const string Cryptography_UnknownHashAlgorithm = "'{0}' is not a known hash algorithm.";

	public const string Cryptography_UnknownPaddingMode = "Unknown padding mode used.";

	public const string Cryptography_UnexpectedTransformTruncation = "CNG provider unexpectedly terminated encryption or decryption prematurely.";

	public const string Cryptography_Unmapped_System_Typed_Error = "The system cryptographic library returned error '{0}' of type '{1}'";

	public const string Cryptography_UnsupportedPaddingMode = "The specified PaddingMode is not supported.";

	public const string NotSupported_Method = "Method not supported.";

	public const string NotSupported_SubclassOverride = "Method not supported. Derived class must override.";

	public const string Cryptography_AlgorithmTypesMustBeVisible = "Algorithms added to CryptoConfig must be accessable from outside their assembly.";

	public const string Cryptography_AddNullOrEmptyName = "CryptoConfig cannot add a mapping for a null or empty name.";

	public const string Argument_Invalid_SafeHandleInvalidOrClosed = "The method cannot be called with an invalid or closed SafeHandle.";

	public const string Cryptography_ArgExpectedECDiffieHellmanCngPublicKey = "DeriveKeyMaterial requires an ECDiffieHellmanCngPublicKey.";

	public const string Cryptography_ArgDSARequiresDSAKey = "Keys used with the DSACng algorithm must have an algorithm group of DSA.";

	public const string Cryptography_ArgECDsaRequiresECDsaKey = "Keys used with the ECDsaCng algorithm must have an algorithm group of ECDsa.";

	public const string Cryptography_ArgRSARequiresRSAKey = "Keys used with the RSACng algorithm must have an algorithm group of RSA.";

	public const string Cryptography_CngKeyWrongAlgorithm = "This key is for algorithm '{0}'. Expected '{1}'.";

	public const string Cryptography_InvalidAlgorithmGroup = "The algorithm group '{0}' is invalid.";

	public const string Cryptography_InvalidAlgorithmName = "The algorithm name '{0}' is invalid.";

	public const string Cryptography_InvalidCipherMode = "Specified cipher mode is not valid for this algorithm.";

	public const string Cryptography_InvalidKeyBlobFormat = "The key blob format '{0}' is invalid.";

	public const string Cryptography_InvalidProviderName = "The provider name '{0}' is invalid.";

	public const string Cryptography_KeyBlobParsingError = "Key Blob not in expected format.";

	public const string Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag = "The CNG key handle being opened was detected to be ephemeral, but the EphemeralKey open option was not specified.";

	public const string Cryptography_WeakKey = "Specified key is a known weak key for this algorithm and cannot be used.";

	public const string PlatformNotSupported_CryptographyCng = "Windows Cryptography Next Generation (CNG) is not supported on this platform.";

	public const string CountdownEvent_Increment_AlreadyZero = "The event is already signaled and cannot be incremented.";

	public const string CountdownEvent_Increment_AlreadyMax = "The increment operation would cause the CurrentCount to overflow.";

	public const string CountdownEvent_Decrement_BelowZero = "Invalid attempt made to decrement the event's count below zero.";

	public const string Common_OperationCanceled = "The operation was canceled.";

	public const string Barrier_Dispose = "The barrier has been disposed.";

	public const string Barrier_SignalAndWait_InvalidOperation_ZeroTotal = "The barrier has no registered participants.";

	public const string Barrier_SignalAndWait_ArgumentOutOfRange = "The specified timeout must represent a value between -1 and Int32.MaxValue, inclusive.";

	public const string Barrier_RemoveParticipants_InvalidOperation = "The participantCount argument is greater than the number of participants that haven't yet arrived at the barrier in this phase.";

	public const string Barrier_RemoveParticipants_ArgumentOutOfRange = "The participantCount argument must be less than or equal the number of participants.";

	public const string Barrier_RemoveParticipants_NonPositive_ArgumentOutOfRange = "The participantCount argument must be a positive value.";

	public const string Barrier_InvalidOperation_CalledFromPHA = "This method may not be called from within the postPhaseAction.";

	public const string Barrier_AddParticipants_NonPositive_ArgumentOutOfRange = "The participantCount argument must be a positive value.";

	public const string Barrier_SignalAndWait_InvalidOperation_ThreadsExceeded = "The number of threads using the barrier exceeded the total number of registered participants.";

	public const string BarrierPostPhaseException = "The postPhaseAction failed with an exception.";

	public const string Barrier_ctor_ArgumentOutOfRange = "The participantCount argument must be non-negative and less than or equal to 32767.";

	public const string Barrier_AddParticipants_Overflow_ArgumentOutOfRange = "Adding participantCount participants would result in the number of participants exceeding the maximum number allowed.";

	public const string SynchronizationLockException_IncorrectDispose = "The lock is being disposed while still being used. It either is being held by a thread and/or has active waiters waiting to acquire the lock.";

	public const string SynchronizationLockException_MisMatchedWrite = "The write lock is being released without being held.";

	public const string LockRecursionException_UpgradeAfterReadNotAllowed = "Upgradeable lock may not be acquired with read lock held.";

	public const string LockRecursionException_UpgradeAfterWriteNotAllowed = "Upgradeable lock may not be acquired with write lock held in this mode. Acquiring Upgradeable lock gives the ability to read along with an option to upgrade to a writer.";

	public const string SynchronizationLockException_MisMatchedUpgrade = "The upgradeable lock is being released without being held.";

	public const string SynchronizationLockException_MisMatchedRead = "The read lock is being released without being held.";

	public const string LockRecursionException_WriteAfterReadNotAllowed = "Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Please ensure that read locks are released before taking a write lock. If an upgrade is necessary, use an upgrade lock in place of the read lock.";

	public const string LockRecursionException_RecursiveWriteNotAllowed = "Recursive write lock acquisitions not allowed in this mode.";

	public const string LockRecursionException_ReadAfterWriteNotAllowed = "A read lock may not be acquired with the write lock held in this mode.";

	public const string LockRecursionException_RecursiveUpgradeNotAllowed = "Recursive upgradeable lock acquisitions not allowed in this mode.";

	public const string LockRecursionException_RecursiveReadNotAllowed = "Recursive read lock acquisitions not allowed in this mode.";

	public const string Overflow_UInt16 = "Value was either too large or too small for a UInt16.";

	public const string ReaderWriterLock_Timeout = "The operation has timed out. {0}";

	public const string ArgumentOutOfRange_TimeoutMilliseconds = "Timeout value in milliseconds must be nonnegative and less than or equal to Int32.MaxValue, or -1 for an infinite timeout.";

	public const string ReaderWriterLock_NotOwner = "Attempt to release a lock that is not owned by the calling thread. {0}";

	public const string ExceptionFromHResult = "(Exception from HRESULT: 0x{0:X})";

	public const string ReaderWriterLock_InvalidLockCookie = "The specified lock cookie is invalid for this operation. {0}";

	public const string ReaderWriterLock_RestoreLockWithOwnedLocks = "ReaderWriterLock.RestoreLock was called without releasing all locks acquired since the call to ReleaseLock.";

	public const string HostExecutionContextManager_InvalidOperation_NotNewCaptureContext = "Cannot apply a context that has been marshaled across AppDomains, that was not acquired through a Capture operation or that has already been the argument to a Set call.";

	public const string HostExecutionContextManager_InvalidOperation_CannotOverrideSetWithoutRevert = "Must override both HostExecutionContextManager.SetHostExecutionContext and HostExecutionContextManager.Revert.";

	public const string HostExecutionContextManager_InvalidOperation_CannotUseSwitcherOtherThread = "Undo operation must be performed on the thread where the corresponding context was Set.";

	public const string Arg_NonZeroLowerBound = "The lower bound of target array must be zero.";

	public const string Arg_WrongType = "The value '{0}' is not of type '{1}' and cannot be used in this generic collection.";

	public const string Arg_ArrayPlusOffTooSmall = "Destination array is not long enough to copy all the items in the collection. Check array index and length.";

	public const string ArgumentOutOfRange_SmallCapacity = "capacity was less than the current size.";

	public const string Argument_AddingDuplicate = "An item with the same key has already been added. Key: {0}";

	public const string InvalidOperation_ConcurrentOperationsNotSupported = "Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.";

	public const string InvalidOperation_EmptyQueue = "Queue empty.";

	public const string InvalidOperation_EnumOpCantHappen = "Enumeration has either not started or has already finished.";

	public const string InvalidOperation_EnumFailedVersion = "Collection was modified; enumeration operation may not execute.";

	public const string InvalidOperation_EmptyStack = "Stack empty.";

	public const string InvalidOperation_EnumNotStarted = "Enumeration has not started. Call MoveNext.";

	public const string InvalidOperation_EnumEnded = "Enumeration already finished.";

	public const string NotSupported_KeyCollectionSet = "Mutating a key collection derived from a dictionary is not allowed.";

	public const string NotSupported_ValueCollectionSet = "Mutating a value collection derived from a dictionary is not allowed.";

	public const string Arg_ArrayLengthsDiffer = "Array lengths must be the same.";

	public const string Arg_BitArrayTypeUnsupported = "Only supported array types for CopyTo on BitArrays are Boolean[], Int32[] and Byte[].";

	public const string Arg_HSCapacityOverflow = "HashSet capacity is too big.";

	public const string Arg_HTCapacityOverflow = "Hashtable's capacity overflowed and went negative. Check load factor, capacity and the current size of the table.";

	public const string Arg_InsufficientSpace = "Insufficient space in the target location to copy the information.";

	public const string Arg_RankMultiDimNotSupported = "Only single dimensional arrays are supported for the requested action.";

	public const string Argument_ArrayTooLarge = "The input array length must not exceed Int32.MaxValue / {0}. Otherwise BitArray.Length would exceed Int32.MaxValue.";

	public const string Argument_InvalidArrayType = "Target array type is not compatible with the type of items in the collection.";

	public const string ArgumentOutOfRange_BiggerThanCollection = "Must be less than or equal to the size of the collection.";

	public const string ArgumentOutOfRange_Index = "Index was out of range. Must be non-negative and less than the size of the collection.";

	public const string ExternalLinkedListNode = "The LinkedList node does not belong to current LinkedList.";

	public const string LinkedListEmpty = "The LinkedList is empty.";

	public const string LinkedListNodeIsAttached = "The LinkedList node already belongs to a LinkedList.";

	public const string NotSupported_SortedListNestedWrite = "This operation is not supported on SortedList nested types because they require modifying the original SortedList.";

	public const string SortedSet_LowerValueGreaterThanUpperValue = "Must be less than or equal to upperValue.";

	public const string Serialization_InvalidOnDeser = "OnDeserialization method was called while the object was not being deserialized.";

	public const string Serialization_MismatchedCount = "The serialized Count information doesn't match the number of items.";

	public const string Serialization_MissingKeys = "The keys for this dictionary are missing.";

	public const string Serialization_MissingValues = "The values for this dictionary are missing.";

	public const string Argument_MapNameEmptyString = "Map name cannot be an empty string.";

	public const string Argument_EmptyFile = "A positive capacity must be specified for a Memory Mapped File backed by an empty file.";

	public const string Argument_NewMMFWriteAccessNotAllowed = "MemoryMappedFileAccess.Write is not permitted when creating new memory mapped files. Use MemoryMappedFileAccess.ReadWrite instead.";

	public const string Argument_ReadAccessWithLargeCapacity = "When specifying MemoryMappedFileAccess.Read access, the capacity must not be larger than the file size.";

	public const string Argument_NewMMFAppendModeNotAllowed = "FileMode.Append is not permitted when creating new memory mapped files. Instead, use MemoryMappedFileView to ensure write-only access within a specified region.";

	public const string Argument_NewMMFTruncateModeNotAllowed = "FileMode.Truncate is not permitted when creating new memory mapped files.";

	public const string ArgumentNull_MapName = "Map name cannot be null.";

	public const string ArgumentNull_FileStream = "fileStream cannot be null.";

	public const string ArgumentOutOfRange_CapacityLargerThanLogicalAddressSpaceNotAllowed = "The capacity cannot be greater than the size of the system's logical address space.";

	public const string ArgumentOutOfRange_NeedPositiveNumber = "A positive number is required.";

	public const string ArgumentOutOfRange_PositiveOrDefaultCapacityRequired = "The capacity must be greater than or equal to 0. 0 represents the size of the file being mapped.";

	public const string ArgumentOutOfRange_PositiveOrDefaultSizeRequired = "The size must be greater than or equal to 0. If 0 is specified, the view extends from the specified offset to the end of the file mapping.";

	public const string ArgumentOutOfRange_CapacityGEFileSizeRequired = "The capacity may not be smaller than the file size.";

	public const string IO_NotEnoughMemory = "Not enough memory to map view.";

	public const string InvalidOperation_CantCreateFileMapping = "Cannot create file mapping.";

	public const string NotSupported_MMViewStreamsFixedLength = "MemoryMappedViewStreams are fixed length.";

	public const string ObjectDisposed_ViewAccessorClosed = "Cannot access a closed accessor.";

	public const string ObjectDisposed_StreamIsClosed = "Cannot access a closed Stream.";

	public const string PlatformNotSupported_NamedMaps = "Named maps are not supported.";

	public const string MethodBuilderDoesNotHaveTypeBuilder = "MethodBuilder does not have a valid TypeBuilder";

	public const string Cryptography_NonCompliantFIPSAlgorithm = "This implementation is not part of the Windows Platform FIPS validated cryptographic algorithms.";

	public const string InvalidOperation_ViewIsNull = "The underlying MemoryMappedView object is null.";

	public const string ArgumentOutOfRange_InvalidPipeAccessRights = "Invalid PipeAccessRights flag.";

	public const string ArgumentOutOfRange_AdditionalAccessLimited = "additionalAccessRights is limited to the PipeAccessRights.ChangePermissions, PipeAccessRights.TakeOwnership, and PipeAccessRights.AccessSystemSecurity flags when creating NamedPipeServerStreams.";

	public const string InterfaceType_Must_Be_Interface = "The type '{0}' must be an interface, not a class.";

	public const string BaseType_Cannot_Be_Sealed = "The base type '{0}' cannot be sealed.";

	public const string BaseType_Cannot_Be_Abstract = "The base type '{0}' cannot be abstract.";

	public const string BaseType_Must_Have_Default_Ctor = "The base type '{0}' must have a public parameterless constructor.";

	public const string Cryptography_Cert_AlreadyHasPrivateKey = "The certificate already has an associated private key.";

	public const string Cryptography_PrivateKey_WrongAlgorithm = "The provided key does not match the public key algorithm for this certificate.";

	public const string Cryptography_PrivateKey_DoesNotMatch = "The provided key does not match the public key for this certificate.";

	internal static string GetString(string name, params object[] args)
	{
		return GetString(CultureInfo.InvariantCulture, name, args);
	}

	internal static string GetString(CultureInfo culture, string name, params object[] args)
	{
		return string.Format(culture, name, args);
	}

	internal static string GetString(string name)
	{
		return name;
	}

	internal static string GetString(CultureInfo culture, string name)
	{
		return name;
	}

	internal static string Format(string resourceFormat, params object[] args)
	{
		if (args != null)
		{
			return string.Format(CultureInfo.InvariantCulture, resourceFormat, args);
		}
		return resourceFormat;
	}

	internal static string Format(string resourceFormat, object p1)
	{
		return string.Format(CultureInfo.InvariantCulture, resourceFormat, p1);
	}

	internal static string Format(string resourceFormat, object p1, object p2)
	{
		return string.Format(CultureInfo.InvariantCulture, resourceFormat, p1, p2);
	}

	internal static string Format(CultureInfo ci, string resourceFormat, object p1, object p2)
	{
		return string.Format(ci, resourceFormat, p1, p2);
	}

	internal static string Format(string resourceFormat, object p1, object p2, object p3)
	{
		return string.Format(CultureInfo.InvariantCulture, resourceFormat, p1, p2, p3);
	}

	internal static string GetResourceString(string str)
	{
		return str;
	}
}
namespace Microsoft.Win32.SafeHandles
{
	/// <summary>Represents a wrapper class for a pipe handle. </summary>
	public sealed class SafePipeHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		private const int DefaultInvalidHandle = 0;

		protected override bool ReleaseHandle()
		{
			return global::Interop.Kernel32.CloseHandle(handle);
		}

		internal SafePipeHandle()
			: this(new IntPtr(0), ownsHandle: true)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> class.</summary>
		/// <param name="preexistingHandle">An <see cref="T:System.IntPtr" /> object that represents the pre-existing handle to use.</param>
		/// <param name="ownsHandle">
		///       <see langword="true" /> to reliably release the handle during the finalization phase; <see langword="false" /> to prevent reliable release (not recommended).</param>
		public SafePipeHandle(IntPtr preexistingHandle, bool ownsHandle)
			: base(ownsHandle)
		{
			SetHandle(preexistingHandle);
		}

		internal void SetHandle(int descriptor)
		{
			SetHandle((IntPtr)descriptor);
		}
	}
	/// <summary>Provides a safe handle that represents a memory-mapped file for sequential access.</summary>
	public sealed class SafeMemoryMappedFileHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		public SafeMemoryMappedFileHandle(IntPtr preexistingHandle, bool ownsHandle)
			: base(ownsHandle)
		{
			handle = preexistingHandle;
		}

		protected override bool ReleaseHandle()
		{
			MemoryMapImpl.CloseMapping(handle);
			handle = IntPtr.Zero;
			return true;
		}

		internal SafeMemoryMappedFileHandle()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Provides a safe handle that represents a view of a block of unmanaged memory for random access. </summary>
	public sealed class SafeMemoryMappedViewHandle : SafeBuffer
	{
		private IntPtr mmap_handle;

		internal SafeMemoryMappedViewHandle(IntPtr mmap_handle, IntPtr base_address, long size)
			: base(ownsHandle: true)
		{
			this.mmap_handle = mmap_handle;
			handle = base_address;
			Initialize((ulong)size);
		}

		internal void Flush()
		{
			MemoryMapImpl.Flush(mmap_handle);
		}

		protected override bool ReleaseHandle()
		{
			if (handle != (IntPtr)(-1))
			{
				return MemoryMapImpl.Unmap(mmap_handle);
			}
			throw new NotImplementedException();
		}

		internal SafeMemoryMappedViewHandle()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Provides a safe handle that can be used by Cryptography Next Generation (CNG) objects.</summary>
	public abstract class SafeNCryptHandle : SafeHandleZeroOrMinusOneIsInvalid
	{
		public override bool IsInvalid
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.Win32.SafeHandles.SafeNCryptHandle" /> class.</summary>
		protected SafeNCryptHandle()
			: base(ownsHandle: true)
		{
		}

		/// <summary>Instantiates a new instance of the <see cref="T:Microsoft.Win32.SafeHandles.SafeNCryptHandle" /> class. </summary>
		/// <param name="handle">The pre-existing handle to use. Using <see cref="F:System.IntPtr.Zero" /> returns an invalid handle. </param>
		/// <param name="parentHandle">The parent handle of this <see cref="T:Microsoft.Win32.SafeHandles.SafeNCryptHandle" />. </param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="parentHandle" /> is <see langword="null" />.  </exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="parentHandle" /> is closed. -or-<paramref name="parentHandle" /> is invalid. </exception>
		protected SafeNCryptHandle(IntPtr handle, SafeHandle parentHandle)
			: base(ownsHandle: false)
		{
			throw new NotImplementedException();
		}

		/// <summary>Releases a handle used by a Cryptography Next Generation (CNG) object.</summary>
		/// <returns>
		///     <see langword="true" /> if the handle is released successfully; otherwise, <see langword="false" />.</returns>
		protected override bool ReleaseHandle()
		{
			return false;
		}

		/// <summary>Releases a native handle used by a Cryptography Next Generation (CNG) object.</summary>
		/// <returns>
		///     <see langword="true" /> if the handle is released successfully; otherwise, <see langword="false" />.</returns>
		protected abstract bool ReleaseNativeHandle();
	}
	/// <summary>Provides a safe handle that represents a key (NCRYPT_KEY_HANDLE).</summary>
	public sealed class SafeNCryptKeyHandle : SafeNCryptHandle
	{
		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle" /> class.</summary>
		public SafeNCryptKeyHandle()
		{
		}

		/// <summary>Instantiates a new instance of the <see cref="T:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle" /> class. </summary>
		/// <param name="handle">The pre-existing handle to use. Using <see cref="F:System.IntPtr.Zero" /> returns an invalid handle. </param>
		/// <param name="parentHandle">The parent handle of this <see cref="T:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle" />. </param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="parentHandle" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="parentHandle" /> is closed. -or-<paramref name="parentHandle" /> is invalid. </exception>
		public SafeNCryptKeyHandle(IntPtr handle, SafeHandle parentHandle)
			: base(handle, parentHandle)
		{
		}

		protected override bool ReleaseNativeHandle()
		{
			return false;
		}
	}
	/// <summary>Provides a safe handle that represents a key storage provider (NCRYPT_PROV_HANDLE).</summary>
	public sealed class SafeNCryptProviderHandle : SafeNCryptHandle
	{
		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle" /> class.</summary>
		public SafeNCryptProviderHandle()
		{
		}

		protected override bool ReleaseNativeHandle()
		{
			return false;
		}
	}
	/// <summary>Provides a safe handle that represents a secret agreement value (NCRYPT_SECRET_HANDLE).</summary>
	public sealed class SafeNCryptSecretHandle : SafeNCryptHandle
	{
		/// <summary>Initializes a new instance of the <see cref="T:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle" /> class.</summary>
		public SafeNCryptSecretHandle()
		{
		}

		protected override bool ReleaseNativeHandle()
		{
			return false;
		}
	}
}
namespace System
{
	internal static class NotImplemented
	{
		internal static Exception ByDesign => new NotImplementedException();

		internal static Exception ByDesignWithMessage(string message)
		{
			return new NotImplementedException(message);
		}

		internal static Exception ActiveIssue(string issue)
		{
			return new NotImplementedException();
		}
	}
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	internal class MonoTODOAttribute : Attribute
	{
		private string comment;

		public string Comment => comment;

		public MonoTODOAttribute()
		{
		}

		public MonoTODOAttribute(string comment)
		{
			this.comment = comment;
		}
	}
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	internal class MonoDocumentationNoteAttribute : MonoTODOAttribute
	{
		public MonoDocumentationNoteAttribute(string comment)
			: base(comment)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	internal class MonoExtensionAttribute : MonoTODOAttribute
	{
		public MonoExtensionAttribute(string comment)
			: base(comment)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	internal class MonoInternalNoteAttribute : MonoTODOAttribute
	{
		public MonoInternalNoteAttribute(string comment)
			: base(comment)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	internal class MonoLimitationAttribute : MonoTODOAttribute
	{
		public MonoLimitationAttribute(string comment)
			: base(comment)
		{
		}
	}
	[AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
	internal class MonoNotSupportedAttribute : MonoTODOAttribute
	{
		public MonoNotSupportedAttribute(string comment)
			: base(comment)
		{
		}
	}
	/// <summary>Encapsulates a method that has nine parameters and does not return a value.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
	/// <summary>Encapsulates a method that has 10 parameters and does not return a value.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
	public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
	/// <summary>Encapsulates a method that has 11 parameters and does not return a value.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
	public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
	/// <summary>Encapsulates a method that has 12 parameters and does not return a value.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
	public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
	/// <summary>Encapsulates a method that has 13 parameters and does not return a value.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
	public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
	/// <summary>Encapsulates a method that has 14 parameters and does not return a value.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
	public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
	/// <summary>Encapsulates a method that has 15 parameters and does not return a value.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates. </typeparam>
	/// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates.</typeparam>
	public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
	/// <summary>Encapsulates a method that has 16 parameters and does not return a value.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg16">The sixteenth parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T16">The type of the sixteenth parameter of the method that this delegate encapsulates.</typeparam>
	public delegate void Action<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, in T16>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
	/// <summary>Encapsulates a method that has nine parameters and returns a value of the type specified by the <paramref name="TResult" /> parameter.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
	/// <returns>The return value of the method that this delegate encapsulates.</returns>
	public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
	/// <summary>Encapsulates a method that has 10 parameters and returns a value of the type specified by the <paramref name="TResult" /> parameter.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
	/// <returns>The return value of the method that this delegate encapsulates.</returns>
	public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
	/// <summary>Encapsulates a method that has 11 parameters and returns a value of the type specified by the <paramref name="TResult" /> parameter.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
	/// <returns>The return value of the method that this delegate encapsulates.</returns>
	public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
	/// <summary>Encapsulates a method that has 12 parameters and returns a value of the type specified by the <paramref name="TResult" /> parameter.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
	/// <returns>The return value of the method that this delegate encapsulates.</returns>
	public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
	/// <summary>Encapsulates a method that has 13 parameters and returns a value of the type specified by the <paramref name="TResult" /> parameter.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
	/// <returns>The return value of the method that this delegate encapsulates.</returns>
	public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
	/// <summary>Encapsulates a method that has 14 parameters and returns a value of the type specified by the <paramref name="TResult" /> parameter.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
	/// <returns>The return value of the method that this delegate encapsulates.</returns>
	public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
	/// <summary>Encapsulates a method that has 15 parameters and returns a value of the type specified by the <paramref name="TResult" /> parameter.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
	/// <returns>The return value of the method that this delegate encapsulates.</returns>
	public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
	/// <summary>Encapsulates a method that has 16 parameters and returns a value of the type specified by the <paramref name="TResult" /> parameter.</summary>
	/// <param name="arg1">The first parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg2">The second parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg3">The third parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg4">The fourth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg5">The fifth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg6">The sixth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg7">The seventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg8">The eighth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg9">The ninth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg10">The tenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg11">The eleventh parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg12">The twelfth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg13">The thirteenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg14">The fourteenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg15">The fifteenth parameter of the method that this delegate encapsulates.</param>
	/// <param name="arg16">The sixteenth parameter of the method that this delegate encapsulates.</param>
	/// <typeparam name="T1">The type of the first parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T2">The type of the second parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T3">The type of the third parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T4">The type of the fourth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T5">The type of the fifth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T6">The type of the sixth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T7">The type of the seventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T8">The type of the eighth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T9">The type of the ninth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T10">The type of the tenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T11">The type of the eleventh parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T12">The type of the twelfth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T13">The type of the thirteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T14">The type of the fourteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T15">The type of the fifteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="T16">The type of the sixteenth parameter of the method that this delegate encapsulates.</typeparam>
	/// <typeparam name="TResult">The type of the return value of the method that this delegate encapsulates.</typeparam>
	/// <returns>The return value of the method that this delegate encapsulates.</returns>
	public delegate TResult Func<in T1, in T2, in T3, in T4, in T5, in T6, in T7, in T8, in T9, in T10, in T11, in T12, in T13, in T14, in T15, in T16, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
	internal static class MonoUtil
	{
		public static readonly bool IsUnix;

		static MonoUtil()
		{
			int platform = (int)Environment.OSVersion.Platform;
			IsUnix = platform == 4 || platform == 128 || platform == 6;
		}
	}
}
namespace System.Security.Cryptography
{
	/// <summary>Represents an elliptic curve.</summary>
	[DebuggerDisplay("ECCurve: {Oid}")]
	public struct ECCurve
	{
		/// <summary>Indicates how to interpret the data contained in an <see cref="T:System.Security.Cryptography.ECCurve" /> object.</summary>
		public enum ECCurveType
		{
			/// <summary>No curve data is interpreted. The caller is assumed to know what the curve is.</summary>
			Implicit,
			/// <summary>The curve parameters represent a prime curve with the formula y^2 = x^3 + A*x + B in the prime field P.</summary>
			PrimeShortWeierstrass,
			/// <summary>The curve parameters represent a prime curve with the formula A*x^2 + y^2 = 1 + B*x^2*y^2 in the prime field P.</summary>
			PrimeTwistedEdwards,
			/// <summary>The curve parameters represent a prime curve with the formula B*y^2 = x^3 + A*x^2 + x.</summary>
			PrimeMontgomery,
			/// <summary>The curve parameters represent a characteristic 2 curve.</summary>
			Characteristic2,
			/// <summary>The curve parameters represent a named curve.</summary>
			Named
		}

		/// <summary>Represents a factory class for creating named curves.</summary>
		public static class NamedCurves
		{
			private const string ECDSA_P256_OID_VALUE = "1.2.840.10045.3.1.7";

			private const string ECDSA_P384_OID_VALUE = "1.3.132.0.34";

			private const string ECDSA_P521_OID_VALUE = "1.3.132.0.35";

			/// <summary>Gets a brainpoolP160r1 named curve.</summary>
			/// <returns>A brainpoolP160r1 named curve.</returns>
			public static ECCurve brainpoolP160r1 => CreateFromFriendlyName("brainpoolP160r1");

			/// <summary>Gets a brainpoolP160t1 named curve.</summary>
			/// <returns>A brainpoolP160t1 named curve.</returns>
			public static ECCurve brainpoolP160t1 => CreateFromFriendlyName("brainpoolP160t1");

			/// <summary>Gets a brainpoolP192r1 named curve.</summary>
			/// <returns>A brainpoolP192r1 named curve.</returns>
			public static ECCurve brainpoolP192r1 => CreateFromFriendlyName("brainpoolP192r1");

			/// <summary>Gets a brainpoolP192t1 named curve.</summary>
			/// <returns>A brainpoolP192t1 named curve.</returns>
			public static ECCurve brainpoolP192t1 => CreateFromFriendlyName("brainpoolP192t1");

			/// <summary>Gets a brainpoolP224r1 named curve.</summary>
			/// <returns>A brainpoolP224r1 named curve.</returns>
			public static ECCurve brainpoolP224r1 => CreateFromFriendlyName("brainpoolP224r1");

			/// <summary>Gets a brainpoolP224t1 named curve.</summary>
			/// <returns>A brainpoolP224t1 named curve.</returns>
			public static ECCurve brainpoolP224t1 => CreateFromFriendlyName("brainpoolP224t1");

			/// <summary>Gets a brainpoolP256r1 named curve.</summary>
			/// <returns>A brainpoolP256r1 named curve.</returns>
			public static ECCurve brainpoolP256r1 => CreateFromFriendlyName("brainpoolP256r1");

			/// <summary>Gets a brainpoolP256t1 named curve.</summary>
			/// <returns>A brainpoolP256t1 named curve.</returns>
			public static ECCurve brainpoolP256t1 => CreateFromFriendlyName("brainpoolP256t1");

			/// <summary>Gets a brainpoolP320r1 named curve.</summary>
			/// <returns>A brainpoolP320r1 named curve.</returns>
			public static ECCurve brainpoolP320r1 => CreateFromFriendlyName("brainpoolP320r1");

			/// <summary>Gets a brainpoolP320t1 named curve.</summary>
			/// <returns>A brainpoolP320t1 named curve.</returns>
			public static ECCurve brainpoolP320t1 => CreateFromFriendlyName("brainpoolP320t1");

			/// <summary>Gets a brainpoolP384r1 named curve.</summary>
			/// <returns>A brainpoolP384r1 named curve.</returns>
			public static ECCurve brainpoolP384r1 => CreateFromFriendlyName("brainpoolP384r1");

			/// <summary>Gets a brainpoolP384t1 named curve.</summary>
			/// <returns>A brainpoolP384t1 named curve.</returns>
			public static ECCurve brainpoolP384t1 => CreateFromFriendlyName("brainpoolP384t1");

			/// <summary>Gets a brainpoolP512r1 named curve.</summary>
			/// <returns>A brainpoolP512r1 named curve.</returns>
			public static ECCurve brainpoolP512r1 => CreateFromFriendlyName("brainpoolP512r1");

			/// <summary>Gets a brainpoolP512t1 named curve.</summary>
			/// <returns>A brainpoolP512t1 named curve.</returns>
			public static ECCurve brainpoolP512t1 => CreateFromFriendlyName("brainpoolP512t1");

			/// <summary>Gets a nistP256 named curve.</summary>
			/// <returns>A nistP256 named curve.</returns>
			public static ECCurve nistP256 => CreateFromValueAndName("1.2.840.10045.3.1.7", "nistP256");

			/// <summary>Gets a nistP384 named curve.</summary>
			/// <returns>A nistP384 named curve.</returns>
			public static ECCurve nistP384 => CreateFromValueAndName("1.3.132.0.34", "nistP384");

			/// <summary>Gets a nistP521 named curve.</summary>
			/// <returns>A nistP521 named curve.</returns>
			public static ECCurve nistP521 => CreateFromValueAndName("1.3.132.0.35", "nistP521");
		}

		/// <summary>The first coefficient for an explicit curve. A for short Weierstrass, Montgomery, and Twisted Edwards curves.</summary>
		/// <returns>Coefficient A.</returns>
		public byte[] A;

		/// <summary>The second coefficient for an explicit curve. B for short Weierstrass and d for Twisted Edwards curves.</summary>
		/// <returns>Coefficient B.</returns>
		public byte[] B;

		/// <summary>The generator, or base point, for operations on the curve.</summary>
		/// <returns>The base point.</returns>
		public ECPoint G;

		/// <summary>The order of the curve. Applies only to explicit curves.</summary>
		/// <returns>The order of the curve. </returns>
		public byte[] Order;

		/// <summary>The cofactor of the curve.</summary>
		/// <returns>The cofactor of the curve.</returns>
		public byte[] Cofactor;

		/// <summary>The seed value for coefficient generation under the ANSI X9.62 generation algorithm. Applies only to explicit curves.</summary>
		/// <returns>The seed value.</returns>
		public byte[] Seed;

		/// <summary>Identifies the composition of the <see cref="T:System.Security.Cryptography.ECCurve" /> object.</summary>
		/// <returns>The curve type.</returns>
		public ECCurveType CurveType;

		/// <summary>The name of the hash algorithm which was used to generate the curve coefficients (<see cref="F:System.Security.Cryptography.ECCurve.A" /> and <see cref="F:System.Security.Cryptography.ECCurve.B" />) from the <see cref="F:System.Security.Cryptography.ECCurve.Seed" /> under the ANSI X9.62 generation algorithm. Applies only to explicit curves.</summary>
		/// <returns>The name of the hash algorithm used to generate the curve coefficients.</returns>
		public HashAlgorithmName? Hash;

		/// <summary>The curve polynomial. Applies only to characteristic 2 curves.</summary>
		/// <returns>The curve polynomial.</returns>
		public byte[] Polynomial;

		/// <summary>The prime specifying the base field. Applies only to prime curves.</summary>
		/// <returns>The prime P.</returns>
		public byte[] Prime;

		private Oid _oid;

		/// <summary>Gets the identifier of a named curve.</summary>
		/// <returns>The identifier of a named curve.</returns>
		public Oid Oid
		{
			get
			{
				return new Oid(_oid.Value, _oid.FriendlyName);
			}
			private set
			{
				if (value == null)
				{
					throw new ArgumentNullException("Oid");
				}
				if (string.IsNullOrEmpty(value.Value) && string.IsNullOrEmpty(value.FriendlyName))
				{
					throw new ArgumentException($"The specified Oid is not valid. The Oid.FriendlyName or Oid.Value property must be set.");
				}
				_oid = value;
			}
		}

		/// <summary>Gets a value that indicates whether the curve type indicates an explicit prime curve.</summary>
		/// <returns>
		///     <see langword="true" /> if the curve is an explicit prime curve; <see langword="false" /> if the curve is a named prime, characteristic 2 or implicit curves.</returns>
		public bool IsPrime
		{
			get
			{
				if (CurveType != ECCurveType.PrimeShortWeierstrass && CurveType != ECCurveType.PrimeMontgomery)
				{
					return CurveType == ECCurveType.PrimeTwistedEdwards;
				}
				return true;
			}
		}

		/// <summary>Gets a value that indicates whether the curve type indicates an explicit characteristic 2 curve.</summary>
		/// <returns>
		///     <see langword="true" /> if the curve is an explicit characteristic 2 curve; <see langword="false" /> if the curve is a named characteristic 2, prime, or implicit curve.</returns>
		public bool IsCharacteristic2 => CurveType == ECCurveType.Characteristic2;

		/// <summary>Gets a value that indicates whether the curve type indicates an explicit curve (either prime or characteristic 2).</summary>
		/// <returns>
		///     <see langword="true" /> if the curve is an explicit curve (either prime or characteristic 2); <see langword="false" /> if the curve is a named or implicit curve.</returns>
		public bool IsExplicit
		{
			get
			{
				if (!IsPrime)
				{
					return IsCharacteristic2;
				}
				return true;
			}
		}

		/// <summary>Gets a value that indicates whether the curve type indicates a named curve.</summary>
		/// <returns>
		///     <see langword="true" /> if the curve is a named curve; <see langword="false" /> if the curve is an implict or an  explicit curve (either prime or characteristic 2).</returns>
		public bool IsNamed => CurveType == ECCurveType.Named;

		private static ECCurve Create(Oid oid)
		{
			return new ECCurve
			{
				CurveType = ECCurveType.Named,
				Oid = oid
			};
		}

		/// <summary>Creates a named curve using the specified <see cref="T:System.Security.Cryptography.Oid" /> object.</summary>
		/// <param name="curveOid">The object identifier to use.</param>
		/// <returns>An object representing the named curve.</returns>
		public static ECCurve CreateFromOid(Oid curveOid)
		{
			return Create(new Oid(curveOid.Value, curveOid.FriendlyName));
		}

		/// <summary>Creates a named curve using the specified friendly name of the identifier.</summary>
		/// <param name="oidFriendlyName">The friendly name of the identifier.</param>
		/// <returns>An object representing the named curve.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="oidFriendlyName" /> is <see langword="null" />.</exception>
		public static ECCurve CreateFromFriendlyName(string oidFriendlyName)
		{
			if (oidFriendlyName == null)
			{
				throw new ArgumentNullException("oidFriendlyName");
			}
			return CreateFromValueAndName(null, oidFriendlyName);
		}

		/// <summary>Creates a named curve using the specified dotted-decimal representation of the identifier.</summary>
		/// <param name="oidValue">The dotted number of the identifier.</param>
		/// <returns>An object representing the named curve.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="oidValue" /> is <see langword="null" />.</exception>
		public static ECCurve CreateFromValue(string oidValue)
		{
			if (oidValue == null)
			{
				throw new ArgumentNullException("oidValue");
			}
			return CreateFromValueAndName(oidValue, null);
		}

		private static ECCurve CreateFromValueAndName(string oidValue, string oidFriendlyName)
		{
			return Create(new Oid(oidValue, oidFriendlyName));
		}

		/// <summary>Validates the integrity of the current curve. Throws a <see cref="T:System.Security.Cryptography.CryptographicException" /> exception if the structure is not valid.</summary>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The curve parameters are not valid for the current curve type.</exception>
		public void Validate()
		{
			if (IsNamed)
			{
				if (HasAnyExplicitParameters())
				{
					throw new CryptographicException("The specified named curve parameters are not valid. Only the Oid parameter must be set.");
				}
				if (Oid == null || (string.IsNullOrEmpty(Oid.FriendlyName) && string.IsNullOrEmpty(Oid.Value)))
				{
					throw new CryptographicException("The specified Oid is not valid. The Oid.FriendlyName or Oid.Value property must be set.");
				}
			}
			else if (IsExplicit)
			{
				bool flag = false;
				if (A == null || B == null || B.Length != A.Length || G.X == null || G.X.Length != A.Length || G.Y == null || G.Y.Length != A.Length || Order == null || Order.Length == 0 || Cofactor == null || Cofactor.Length == 0)
				{
					flag = true;
				}
				if (IsPrime)
				{
					if (!flag && (Prime == null || Prime.Length != A.Length))
					{
						flag = true;
					}
					if (flag)
					{
						throw new CryptographicException("The specified prime curve parameters are not valid. Prime, A, B, G.X, G.Y and Order are required and must be the same length, and the same length as Q.X, Q.Y and D if those are specified. Seed, Cofactor and Hash are optional. Other parameters are not allowed.");
					}
				}
				else if (IsCharacteristic2)
				{
					if (!flag && (Polynomial == null || Polynomial.Length == 0))
					{
						flag = true;
					}
					if (flag)
					{
						throw new CryptographicException("The specified Characteristic2 curve parameters are not valid. Polynomial, A, B, G.X, G.Y, and Order are required. A, B, G.X, G.Y must be the same length, and the same length as Q.X, Q.Y and D if those are specified. Seed, Cofactor and Hash are optional. Other parameters are not allowed.");
					}
				}
			}
			else if (HasAnyExplicitParameters() || Oid != null)
			{
				throw new CryptographicException($"The specified curve '{CurveType.ToString()}' or its parameters are not valid for this platform.");
			}
		}

		private bool HasAnyExplicitParameters()
		{
			if (A == null && B == null && G.X == null && G.Y == null && Order == null && Cofactor == null && Prime == null && Polynomial == null && Seed == null)
			{
				return Hash.HasValue;
			}
			return true;
		}
	}
	/// <summary>Represents the standard parameters for the elliptic curve cryptography (ECC) algorithm.</summary>
	public struct ECParameters
	{
		/// <summary>Represents the public key <see langword="Q" /> for the elliptic curve cryptography (ECC) algorithm.</summary>
		/// <returns>The <see langword="Q" /> parameter for the elliptic curve cryptography (ECC) algorithm.</returns>
		public ECPoint Q;

		/// <summary>Represents the private key <see langword="D" /> for the elliptic curve cryptography (ECC) algorithm, stored in big-endian format.</summary>
		/// <returns>The <see langword="D" /> parameter for the elliptic curve cryptography (ECC) algorithm.</returns>
		public byte[] D;

		/// <summary>Represents the curve associated with the public key (<see cref="F:System.Security.Cryptography.ECParameters.Q" />) and the optional private key (<see cref="F:System.Security.Cryptography.ECParameters.D" />).</summary>
		/// <returns>The curve.</returns>
		public ECCurve Curve;

		/// <summary>Validates the current object.</summary>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The key or curve parameters are not valid for the current curve type.</exception>
		public void Validate()
		{
			bool flag = false;
			if (Q.X == null || Q.Y == null || Q.X.Length != Q.Y.Length)
			{
				flag = true;
			}
			if (!flag)
			{
				if (Curve.IsExplicit)
				{
					flag = D != null && D.Length != Curve.Order.Length;
				}
				else if (Curve.IsNamed)
				{
					flag = D != null && D.Length != Q.X.Length;
				}
			}
			if (flag)
			{
				throw new CryptographicException("The specified key parameters are not valid. Q.X and Q.Y are required fields. Q.X, Q.Y must be the same length. If D is specified it must be the same length as Q.X and Q.Y for named curves or the same length as Order for explicit curves.");
			}
			Curve.Validate();
		}
	}
	/// <summary>Represents a (X,Y) coordinate pair for elliptic curve cryptography (ECC) structures.</summary>
	public struct ECPoint
	{
		/// <summary>Represents the X coordinate.</summary>
		/// <returns>The X coordinate.</returns>
		public byte[] X;

		/// <summary>Represents the Y coordinate.</summary>
		/// <returns>The Y coordinate.</returns>
		public byte[] Y;
	}
	/// <summary>Provides support for computing a hash or Hash-based Message Authentication Code (HMAC) value incrementally across several segments.</summary>
	public sealed class IncrementalHash : IDisposable
	{
		private const int NTE_BAD_ALGID = -2146893816;

		private readonly HashAlgorithmName _algorithmName;

		private HashAlgorithm _hash;

		private bool _disposed;

		private bool _resetPending;

		/// <summary>Gets the name of the algorithm being performed.</summary>
		/// <returns>The name of the algorithm being performed.</returns>
		public HashAlgorithmName AlgorithmName => _algorithmName;

		private IncrementalHash(HashAlgorithmName name, HashAlgorithm hash)
		{
			_algorithmName = name;
			_hash = hash;
		}

		/// <summary>Appends the specified data to the data already processed in the hash or HMAC.</summary>
		/// <param name="data">The data to process.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="data" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Security.Cryptography.IncrementalHash" /> object has already been disposed.</exception>
		public void AppendData(byte[] data)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			AppendData(data, 0, data.Length);
		}

		/// <summary>Appends the specified number of bytes from the specified data, starting at the specified offset, to the data already processed in the hash or Hash-based Message Authentication Code (HMAC).</summary>
		/// <param name="data">The data to process.</param>
		/// <param name="offset">The offset into the byte array from which to begin using data.</param>
		/// <param name="count">The number of bytes to use from <paramref name="data" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="data" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///   <paramref name="count" /> or <paramref name="offset" /> is negative.-or-<paramref name="count" /> is larger than the lenght of <paramref name="data" />.</exception>
		/// <exception cref="T:System.ArgumentException">The sum of <paramref name="offset" /> and <paramref name="count" /> is larger than the data length.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Security.Cryptography.IncrementalHash" /> object has already been disposed.</exception>
		public void AppendData(byte[] data, int offset, int count)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", "Non negative number is required.");
			}
			if (count < 0 || count > data.Length)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (data.Length - count < offset)
			{
				throw new ArgumentException("Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.");
			}
			if (_disposed)
			{
				throw new ObjectDisposedException(typeof(IncrementalHash).Name);
			}
			if (_resetPending)
			{
				_hash.Initialize();
				_resetPending = false;
			}
			_hash.TransformBlock(data, offset, count, null, 0);
		}

		/// <summary>Retrieves the hash or Hash-based Message Authentication Code (HMAC) for the data accumulated from prior calls to the
		///   <see cref="M:System.Security.Cryptography.IncrementalHash.AppendData(System.Byte[])" /> method,  and resets the object to its initial state.</summary>
		/// <returns>The computed hash or HMAC.</returns>
		/// <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Security.Cryptography.IncrementalHash" /> object has already been disposed.</exception>
		public byte[] GetHashAndReset()
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(typeof(IncrementalHash).Name);
			}
			if (_resetPending)
			{
				_hash.Initialize();
			}
			_hash.TransformFinalBlock(Array.Empty<byte>(), 0, 0);
			byte[] hash = _hash.Hash;
			_resetPending = true;
			return hash;
		}

		/// <summary>Releases the resources used by the current instance of the <see cref="T:System.Security.Cryptography.IncrementalHash" /> class.</summary>
		public void Dispose()
		{
			_disposed = true;
			if (_hash != null)
			{
				_hash.Dispose();
				_hash = null;
			}
		}

		/// <summary>Creates an <see cref="T:System.Security.Cryptography.IncrementalHash" /> for the specified algorithm.</summary>
		/// <param name="hashAlgorithm">The name of the hash algorithm to perform.</param>
		/// <returns>An <see cref="T:System.Security.Cryptography.IncrementalHash" /> instance ready to compute the hash algorithm specified by <paramref name="hashAlgorithm" />.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> is <see langword="null" /> or an empty string.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///   <paramref name="hashAlgorithm" /> is not a known hash algorithm.</exception>
		public static IncrementalHash CreateHash(HashAlgorithmName hashAlgorithm)
		{
			if (string.IsNullOrEmpty(hashAlgorithm.Name))
			{
				throw new ArgumentException("The hash algorithm name cannot be null or empty.", "hashAlgorithm");
			}
			return new IncrementalHash(hashAlgorithm, GetHashAlgorithm(hashAlgorithm));
		}

		/// <summary>Creates an <see cref="T:System.Security.Cryptography.IncrementalHash" /> for the Hash-based Message Authentication Code (HMAC)
		///   algorithm using the specified hash algorithm and key.</summary>
		/// <param name="hashAlgorithm">The name of the hash algorithm to perform within the HMAC.</param>
		/// <param name="key">     The secret key for the HMAC. The key can be of any length, but a key longer than the output size
		///   of the specified hash algorithm will be hashed to derive a correctly-sized key. Therefore,
		///   the recommended size of the secret key is the output size of the specified hash algorithm.</param>
		/// <returns>An instance of the <see cref="T:System.Security.Cryptography.IncrementalHash" /> class ready to compute the specified hash algorithm.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="key" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///   <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> is <see langword="null" /> or
		///   an empty string.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///   <paramref name="hashAlgorithm" /> is not a known hash algorithm.</exception>
		public static IncrementalHash CreateHMAC(HashAlgorithmName hashAlgorithm, byte[] key)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (string.IsNullOrEmpty(hashAlgorithm.Name))
			{
				throw new ArgumentException("The hash algorithm name cannot be null or empty.", "hashAlgorithm");
			}
			return new IncrementalHash(hashAlgorithm, GetHMAC(hashAlgorithm, key));
		}

		private static HashAlgorithm GetHashAlgorithm(HashAlgorithmName hashAlgorithm)
		{
			if (hashAlgorithm == HashAlgorithmName.MD5)
			{
				return new MD5CryptoServiceProvider();
			}
			if (hashAlgorithm == HashAlgorithmName.SHA1)
			{
				return new SHA1CryptoServiceProvider();
			}
			if (hashAlgorithm == HashAlgorithmName.SHA256)
			{
				return new SHA256CryptoServiceProvider();
			}
			if (hashAlgorithm == HashAlgorithmName.SHA384)
			{
				return new SHA384CryptoServiceProvider();
			}
			if (hashAlgorithm == HashAlgorithmName.SHA512)
			{
				return new SHA512CryptoServiceProvider();
			}
			throw new CryptographicException(-2146893816);
		}

		private static HashAlgorithm GetHMAC(HashAlgorithmName hashAlgorithm, byte[] key)
		{
			if (hashAlgorithm == HashAlgorithmName.MD5)
			{
				return new HMACMD5(key);
			}
			if (hashAlgorithm == HashAlgorithmName.SHA1)
			{
				return new HMACSHA1(key);
			}
			if (hashAlgorithm == HashAlgorithmName.SHA256)
			{
				return new HMACSHA256(key);
			}
			if (hashAlgorithm == HashAlgorithmName.SHA384)
			{
				return new HMACSHA384(key);
			}
			if (hashAlgorithm == HashAlgorithmName.SHA512)
			{
				return new HMACSHA512(key);
			}
			throw new CryptographicException(-2146893816);
		}

		public void AppendData(ReadOnlySpan<byte> data)
		{
			AppendData(data.ToArray());
		}

		public bool TryGetHashAndReset(Span<byte> destination, out int bytesWritten)
		{
			if (_disposed)
			{
				throw new ObjectDisposedException(typeof(IncrementalHash).Name);
			}
			byte[] hashAndReset = GetHashAndReset();
			if (hashAndReset.AsSpan().TryCopyTo(destination))
			{
				bytesWritten = hashAndReset.Length;
				return true;
			}
			bytesWritten = 0;
			return false;
		}

		internal IncrementalHash()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Provides a managed implementation of the Advanced Encryption Standard (AES) symmetric algorithm. </summary>
	public sealed class AesManaged : Aes
	{
		private RijndaelManaged m_rijndael;

		/// <summary>Gets or sets the number of bits to use as feedback. </summary>
		/// <returns>The feedback size, in bits.</returns>
		public override int FeedbackSize
		{
			get
			{
				return m_rijndael.FeedbackSize;
			}
			set
			{
				m_rijndael.FeedbackSize = value;
			}
		}

		/// <summary>Gets or sets the initialization vector (IV) to use for the symmetric algorithm. </summary>
		/// <returns>The initialization vector to use for the symmetric algorithm</returns>
		public override byte[] IV
		{
			get
			{
				return m_rijndael.IV;
			}
			set
			{
				m_rijndael.IV = value;
			}
		}

		/// <summary>Gets or sets the secret key used for the symmetric algorithm.</summary>
		/// <returns>The key for the symmetric algorithm.</returns>
		public override byte[] Key
		{
			get
			{
				return m_rijndael.Key;
			}
			set
			{
				m_rijndael.Key = value;
			}
		}

		/// <summary>Gets or sets the size, in bits, of the secret key used for the symmetric algorithm. </summary>
		/// <returns>The size, in bits, of the key used by the symmetric algorithm.</returns>
		public override int KeySize
		{
			get
			{
				return m_rijndael.KeySize;
			}
			set
			{
				m_rijndael.KeySize = value;
			}
		}

		/// <summary>Gets or sets the mode for operation of the symmetric algorithm.</summary>
		/// <returns>One of the enumeration values that specifies the block cipher mode to use for encryption. The default is <see cref="F:System.Security.Cryptography.CipherMode.CBC" />.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///         <see cref="P:System.Security.Cryptography.AesManaged.Mode" /> is set to <see cref="F:System.Security.Cryptography.CipherMode.CFB" /> or <see cref="F:System.Security.Cryptography.CipherMode.OFB" />.</exception>
		public override CipherMode Mode
		{
			get
			{
				return m_rijndael.Mode;
			}
			set
			{
				if (value == CipherMode.CFB || value == CipherMode.OFB)
				{
					throw new CryptographicException(SR.GetString("Specified cipher mode is not valid for this algorithm."));
				}
				m_rijndael.Mode = value;
			}
		}

		/// <summary>Gets or sets the padding mode used in the symmetric algorithm. </summary>
		/// <returns>One of the enumeration values that specifies the type of padding to apply. The default is <see cref="F:System.Security.Cryptography.PaddingMode.PKCS7" />.</returns>
		public override PaddingMode Padding
		{
			get
			{
				return m_rijndael.Padding;
			}
			set
			{
				m_rijndael.Padding = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.AesManaged" /> class. </summary>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The Windows security policy setting for FIPS is enabled.</exception>
		/// <exception cref="T:System.InvalidOperationException">This implementation is not part of the Windows Platform FIPS-validated cryptographic algorithms.</exception>
		public AesManaged()
		{
			if (CryptoConfig.AllowOnlyFipsAlgorithms)
			{
				throw new InvalidOperationException(SR.GetString("This implementation is not part of the Windows Platform FIPS validated cryptographic algorithms."));
			}
			m_rijndael = new RijndaelManaged();
			m_rijndael.BlockSize = BlockSize;
			m_rijndael.KeySize = KeySize;
		}

		/// <summary>Creates a symmetric decryptor object using the current key and initialization vector (IV).</summary>
		/// <returns>A symmetric decryptor object.</returns>
		public override ICryptoTransform CreateDecryptor()
		{
			return m_rijndael.CreateDecryptor();
		}

		/// <summary>Creates a symmetric decryptor object using the specified key and initialization vector (IV).</summary>
		/// <param name="key">The secret key to use for the symmetric algorithm.</param>
		/// <param name="iv">The initialization vector to use for the symmetric algorithm.</param>
		/// <returns>A symmetric decryptor object.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="key" /> or <paramref name="iv" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="key" /> is invalid.</exception>
		public override ICryptoTransform CreateDecryptor(byte[] key, byte[] iv)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (!ValidKeySize(key.Length * 8))
			{
				throw new ArgumentException(SR.GetString("Specified key is not a valid size for this algorithm."), "key");
			}
			if (iv != null && iv.Length * 8 != BlockSizeValue)
			{
				throw new ArgumentException(SR.GetString("Specified initialization vector (IV) does not match the block size for this algorithm."), "iv");
			}
			return m_rijndael.CreateDecryptor(key, iv);
		}

		/// <summary>Creates a symmetric encryptor object using the current key and initialization vector (IV).</summary>
		/// <returns>A symmetric encryptor object.</returns>
		public override ICryptoTransform CreateEncryptor()
		{
			return m_rijndael.CreateEncryptor();
		}

		/// <summary>Creates a symmetric encryptor object using the specified key and initialization vector (IV).</summary>
		/// <param name="key">The secret key to use for the symmetric algorithm.</param>
		/// <param name="iv">The initialization vector to use for the symmetric algorithm.</param>
		/// <returns>A symmetric encryptor object.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="key" /> or <paramref name="iv" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="key" /> is invalid.</exception>
		public override ICryptoTransform CreateEncryptor(byte[] key, byte[] iv)
		{
			if (key == null)
			{
				throw new ArgumentNullException("key");
			}
			if (!ValidKeySize(key.Length * 8))
			{
				throw new ArgumentException(SR.GetString("Specified key is not a valid size for this algorithm."), "key");
			}
			if (iv != null && iv.Length * 8 != BlockSizeValue)
			{
				throw new ArgumentException(SR.GetString("Specified initialization vector (IV) does not match the block size for this algorithm."), "iv");
			}
			return m_rijndael.CreateEncryptor(key, iv);
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				if (disposing)
				{
					((IDisposable)m_rijndael).Dispose();
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		/// <summary>Generates a random initialization vector (IV) to use for the symmetric algorithm.</summary>
		public override void GenerateIV()
		{
			m_rijndael.GenerateIV();
		}

		/// <summary>Generates a random key to use for the symmetric algorithm. </summary>
		public override void GenerateKey()
		{
			m_rijndael.GenerateKey();
		}
	}
	internal enum AsymmetricPaddingMode
	{
		None = 1,
		Pkcs1 = 2,
		Oaep = 4,
		Pss = 8
	}
	internal enum HASHALGORITHM_ENUM
	{
		DSA_HASH_ALGORITHM_SHA1,
		DSA_HASH_ALGORITHM_SHA256,
		DSA_HASH_ALGORITHM_SHA512
	}
	internal enum DSAFIPSVERSION_ENUM
	{
		DSA_FIPS186_2,
		DSA_FIPS186_3
	}
	internal static class BCryptNative
	{
		internal static class AlgorithmName
		{
			public const string ECDH = "ECDH";

			public const string ECDHP256 = "ECDH_P256";

			public const string ECDHP384 = "ECDH_P384";

			public const string ECDHP521 = "ECDH_P521";

			public const string ECDsa = "ECDSA";

			public const string ECDsaP256 = "ECDSA_P256";

			public const string ECDsaP384 = "ECDSA_P384";

			public const string ECDsaP521 = "ECDSA_P521";

			public const string MD5 = "MD5";

			public const string Sha1 = "SHA1";

			public const string Sha256 = "SHA256";

			public const string Sha384 = "SHA384";

			public const string Sha512 = "SHA512";

			internal const string Rsa = "RSA";
		}
	}
	/// <summary>Encapsulates the name of an encryption algorithm. </summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngAlgorithm : IEquatable<CngAlgorithm>
	{
		private static volatile CngAlgorithm s_ecdh;

		private static volatile CngAlgorithm s_ecdhp256;

		private static volatile CngAlgorithm s_ecdhp384;

		private static volatile CngAlgorithm s_ecdhp521;

		private static volatile CngAlgorithm s_ecdsa;

		private static volatile CngAlgorithm s_ecdsap256;

		private static volatile CngAlgorithm s_ecdsap384;

		private static volatile CngAlgorithm s_ecdsap521;

		private static volatile CngAlgorithm s_md5;

		private static volatile CngAlgorithm s_sha1;

		private static volatile CngAlgorithm s_sha256;

		private static volatile CngAlgorithm s_sha384;

		private static volatile CngAlgorithm s_sha512;

		private static volatile CngAlgorithm s_rsa;

		private string m_algorithm;

		/// <summary>Gets the algorithm name that the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object specifies.</summary>
		/// <returns>The embedded algorithm name.</returns>
		public string Algorithm => m_algorithm;

		/// <summary>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies the RSA hash algorithm.</summary>
		/// <returns>An object that specifies the RSA algorithm.</returns>
		public static CngAlgorithm Rsa
		{
			get
			{
				if (s_rsa == null)
				{
					s_rsa = new CngAlgorithm("RSA");
				}
				return s_rsa;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm whose curve is described via a key property.</summary>
		/// <returns>An object that specifies an ECDH key exchange algorithm whose curve is described via a key property.</returns>
		public static CngAlgorithm ECDiffieHellman
		{
			get
			{
				if (s_ecdh == null)
				{
					s_ecdh = new CngAlgorithm("ECDH");
				}
				return s_ecdh;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm that uses the P-256 curve.</summary>
		/// <returns>An object that specifies an ECDH algorithm that uses the P-256 curve.</returns>
		public static CngAlgorithm ECDiffieHellmanP256
		{
			get
			{
				if (s_ecdhp256 == null)
				{
					s_ecdhp256 = new CngAlgorithm("ECDH_P256");
				}
				return s_ecdhp256;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm that uses the P-384 curve.</summary>
		/// <returns>An object that specifies an ECDH algorithm that uses the P-384 curve.</returns>
		public static CngAlgorithm ECDiffieHellmanP384
		{
			get
			{
				if (s_ecdhp384 == null)
				{
					s_ecdhp384 = new CngAlgorithm("ECDH_P384");
				}
				return s_ecdhp384;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies an Elliptic Curve Diffie-Hellman (ECDH) key exchange algorithm that uses the P-521 curve.</summary>
		/// <returns>An object that specifies an ECDH algorithm that uses the P-521 curve.</returns>
		public static CngAlgorithm ECDiffieHellmanP521
		{
			get
			{
				if (s_ecdhp521 == null)
				{
					s_ecdhp521 = new CngAlgorithm("ECDH_P521");
				}
				return s_ecdhp521;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) whose curve is described via a key property.</summary>
		/// <returns>An object that specifies an ECDSA whose curve is described via a key property.</returns>
		public static CngAlgorithm ECDsa
		{
			get
			{
				if (s_ecdsa == null)
				{
					s_ecdsa = new CngAlgorithm("ECDSA");
				}
				return s_ecdsa;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) that uses the P-256 curve.</summary>
		/// <returns>An object that specifies an ECDSA algorithm that uses the P-256 curve.</returns>
		public static CngAlgorithm ECDsaP256
		{
			get
			{
				if (s_ecdsap256 == null)
				{
					s_ecdsap256 = new CngAlgorithm("ECDSA_P256");
				}
				return s_ecdsap256;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) that uses the P-384 curve.</summary>
		/// <returns>An object that specifies an ECDSA algorithm that uses the P-384 curve.</returns>
		public static CngAlgorithm ECDsaP384
		{
			get
			{
				if (s_ecdsap384 == null)
				{
					s_ecdsap384 = new CngAlgorithm("ECDSA_P384");
				}
				return s_ecdsap384;
			}
		}

		/// <summary>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies an Elliptic Curve Digital Signature Algorithm (ECDSA) that uses the P-521 curve.</summary>
		/// <returns>An object that specifies an ECDSA algorithm that uses the P-521 curve.</returns>
		public static CngAlgorithm ECDsaP521
		{
			get
			{
				if (s_ecdsap521 == null)
				{
					s_ecdsap521 = new CngAlgorithm("ECDSA_P521");
				}
				return s_ecdsap521;
			}
		}

		/// <summary>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies the Message Digest 5 (MD5) hash algorithm.</summary>
		/// <returns>An object that specifies the MD5 algorithm.</returns>
		public static CngAlgorithm MD5
		{
			get
			{
				if (s_md5 == null)
				{
					s_md5 = new CngAlgorithm("MD5");
				}
				return s_md5;
			}
		}

		/// <summary>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies the Secure Hash Algorithm 1 (SHA-1) algorithm.</summary>
		/// <returns>An object that specifies the SHA-1 algorithm.</returns>
		public static CngAlgorithm Sha1
		{
			get
			{
				if (s_sha1 == null)
				{
					s_sha1 = new CngAlgorithm("SHA1");
				}
				return s_sha1;
			}
		}

		/// <summary>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies the Secure Hash Algorithm 256 (SHA-256) algorithm.</summary>
		/// <returns>An object that specifies the SHA-256 algorithm.</returns>
		public static CngAlgorithm Sha256
		{
			get
			{
				if (s_sha256 == null)
				{
					s_sha256 = new CngAlgorithm("SHA256");
				}
				return s_sha256;
			}
		}

		/// <summary>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies the Secure Hash Algorithm 384 (SHA-384) algorithm.</summary>
		/// <returns>An object that specifies the SHA-384 algorithm.</returns>
		public static CngAlgorithm Sha384
		{
			get
			{
				if (s_sha384 == null)
				{
					s_sha384 = new CngAlgorithm("SHA384");
				}
				return s_sha384;
			}
		}

		/// <summary>Gets a new <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object that specifies the Secure Hash Algorithm 512 (SHA-512) algorithm.</summary>
		/// <returns>An object that specifies the SHA-512 algorithm.</returns>
		public static CngAlgorithm Sha512
		{
			get
			{
				if (s_sha512 == null)
				{
					s_sha512 = new CngAlgorithm("SHA512");
				}
				return s_sha512;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngAlgorithm" /> class.</summary>
		/// <param name="algorithm">The name of the algorithm to initialize.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="algorithm" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <paramref name="algorithm" /> parameter length is 0 (zero).</exception>
		public CngAlgorithm(string algorithm)
		{
			if (algorithm == null)
			{
				throw new ArgumentNullException("algorithm");
			}
			if (algorithm.Length == 0)
			{
				throw new ArgumentException(SR.GetString("The algorithm name '{0}' is invalid.", algorithm), "algorithm");
			}
			m_algorithm = algorithm;
		}

		/// <summary>Determines whether two <see cref="T:System.Security.Cryptography.CngAlgorithm" /> objects specify the same algorithm name.</summary>
		/// <param name="left">An object that specifies an algorithm name.</param>
		/// <param name="right">A second object, to be compared to the object that is identified by the <paramref name="left" /> parameter.</param>
		/// <returns>
		///     <see langword="true" /> if the two objects specify the same algorithm name; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(CngAlgorithm left, CngAlgorithm right)
		{
			return left?.Equals(right) ?? ((object)right == null);
		}

		/// <summary>Determines whether two <see cref="T:System.Security.Cryptography.CngAlgorithm" /> objects do not specify the same algorithm.</summary>
		/// <param name="left">An object that specifies an algorithm name.</param>
		/// <param name="right">A second object, to be compared to the object that is identified by the <paramref name="left" /> parameter.</param>
		/// <returns>
		///     <see langword="true" /> if the two objects do not specify the same algorithm name; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(CngAlgorithm left, CngAlgorithm right)
		{
			if ((object)left == null)
			{
				return (object)right != null;
			}
			return !left.Equals(right);
		}

		/// <summary>Compares the specified object to the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object.</summary>
		/// <param name="obj">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Security.Cryptography.CngAlgorithm" /> that specifies the same algorithm as the current object; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			return Equals(obj as CngAlgorithm);
		}

		/// <summary>Compares the specified <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object to the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object. </summary>
		/// <param name="other">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <paramref name="other" /> parameter specifies the same algorithm as the current object; otherwise, <see langword="false" />.</returns>
		public bool Equals(CngAlgorithm other)
		{
			if ((object)other == null)
			{
				return false;
			}
			return m_algorithm.Equals(other.Algorithm);
		}

		/// <summary>Generates a hash value for the algorithm name that is embedded in the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object.</summary>
		/// <returns>The hash value of the embedded algorithm name.</returns>
		public override int GetHashCode()
		{
			return m_algorithm.GetHashCode();
		}

		/// <summary>Gets the name of the algorithm that the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object specifies.</summary>
		/// <returns>The embedded algorithm name.</returns>
		public override string ToString()
		{
			return m_algorithm;
		}
	}
	/// <summary>Encapsulates the name of an encryption algorithm group. </summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngAlgorithmGroup : IEquatable<CngAlgorithmGroup>
	{
		private static volatile CngAlgorithmGroup s_dh;

		private static volatile CngAlgorithmGroup s_dsa;

		private static volatile CngAlgorithmGroup s_ecdh;

		private static volatile CngAlgorithmGroup s_ecdsa;

		private static volatile CngAlgorithmGroup s_rsa;

		private string m_algorithmGroup;

		/// <summary>Gets the name of the algorithm group that the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object specifies.</summary>
		/// <returns>The embedded algorithm group name.</returns>
		public string AlgorithmGroup => m_algorithmGroup;

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> object that specifies the Diffie-Hellman family of algorithms.</summary>
		/// <returns>An object that specifies the Diffie-Hellman family of algorithms.</returns>
		public static CngAlgorithmGroup DiffieHellman
		{
			get
			{
				if (s_dh == null)
				{
					s_dh = new CngAlgorithmGroup("DH");
				}
				return s_dh;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> object that specifies the Digital Signature Algorithm (DSA) family of algorithms.</summary>
		/// <returns>An object that specifies the DSA family of algorithms.</returns>
		public static CngAlgorithmGroup Dsa
		{
			get
			{
				if (s_dsa == null)
				{
					s_dsa = new CngAlgorithmGroup("DSA");
				}
				return s_dsa;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> object that specifies the Elliptic Curve Diffie-Hellman (ECDH) family of algorithms.</summary>
		/// <returns>An object that specifies the ECDH family of algorithms.</returns>
		public static CngAlgorithmGroup ECDiffieHellman
		{
			get
			{
				if (s_ecdh == null)
				{
					s_ecdh = new CngAlgorithmGroup("ECDH");
				}
				return s_ecdh;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> object that specifies the Elliptic Curve Digital Signature Algorithm (ECDSA) family of algorithms.</summary>
		/// <returns>An object that specifies the ECDSA family of algorithms.</returns>
		public static CngAlgorithmGroup ECDsa
		{
			get
			{
				if (s_ecdsa == null)
				{
					s_ecdsa = new CngAlgorithmGroup("ECDSA");
				}
				return s_ecdsa;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> object that specifies the Rivest-Shamir-Adleman (RSA) family of algorithms.</summary>
		/// <returns>An object that specifies the RSA family of algorithms.</returns>
		public static CngAlgorithmGroup Rsa
		{
			get
			{
				if (s_rsa == null)
				{
					s_rsa = new CngAlgorithmGroup("RSA");
				}
				return s_rsa;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> class.</summary>
		/// <param name="algorithmGroup">The name of the algorithm group to initialize.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="algorithmGroup" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <paramref name="algorithmGroup" /> parameter length is 0 (zero).</exception>
		public CngAlgorithmGroup(string algorithmGroup)
		{
			if (algorithmGroup == null)
			{
				throw new ArgumentNullException("algorithmGroup");
			}
			if (algorithmGroup.Length == 0)
			{
				throw new ArgumentException(SR.GetString("The algorithm group '{0}' is invalid.", algorithmGroup), "algorithmGroup");
			}
			m_algorithmGroup = algorithmGroup;
		}

		/// <summary>Determines whether two <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> objects specify the same algorithm group.</summary>
		/// <param name="left">An object that specifies an algorithm group.</param>
		/// <param name="right">A second object, to be compared to the object that is identified by the <paramref name="left" /> parameter.</param>
		/// <returns>
		///     <see langword="true" /> if the two objects specify the same algorithm group; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(CngAlgorithmGroup left, CngAlgorithmGroup right)
		{
			return left?.Equals(right) ?? ((object)right == null);
		}

		/// <summary>Determines whether two <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> objects do not specify the same algorithm group.</summary>
		/// <param name="left">An object that specifies an algorithm group.</param>
		/// <param name="right">A second object, to be compared to the object that is identified by the <paramref name="left" /> parameter.</param>
		/// <returns>
		///     <see langword="true" /> if the two objects do not specify the same algorithm group; otherwise, <see langword="false" />. </returns>
		public static bool operator !=(CngAlgorithmGroup left, CngAlgorithmGroup right)
		{
			if ((object)left == null)
			{
				return (object)right != null;
			}
			return !left.Equals(right);
		}

		/// <summary>Compares the specified object to the current <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> object.</summary>
		/// <param name="obj">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> that specifies the same algorithm group as the current object; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			return Equals(obj as CngAlgorithmGroup);
		}

		/// <summary>Compares the specified <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> object to the current <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> object.</summary>
		/// <param name="other">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <paramref name="other" /> parameter specifies the same algorithm group as the current object; otherwise, <see langword="false" />.</returns>
		public bool Equals(CngAlgorithmGroup other)
		{
			if ((object)other == null)
			{
				return false;
			}
			return m_algorithmGroup.Equals(other.AlgorithmGroup);
		}

		/// <summary>Generates a hash value for the algorithm group name that is embedded in the current <see cref="T:System.Security.Cryptography.CngAlgorithmGroup" /> object.</summary>
		/// <returns>The hash value of the embedded algorithm group name.</returns>
		public override int GetHashCode()
		{
			return m_algorithmGroup.GetHashCode();
		}

		/// <summary>Gets the name of the algorithm group that the current <see cref="T:System.Security.Cryptography.CngAlgorithm" /> object specifies.</summary>
		/// <returns>The embedded algorithm group name.</returns>
		public override string ToString()
		{
			return m_algorithmGroup;
		}
	}
	/// <summary>Specifies options for opening key handles.</summary>
	[Flags]
	public enum CngKeyHandleOpenOptions
	{
		/// <summary>The key handle being opened does not specify an ephemeral key.</summary>
		None = 0,
		/// <summary>The key handle being opened specifies an ephemeral key.</summary>
		EphemeralKey = 1
	}
	/// <summary>Defines the core functionality for keys that are used with Cryptography Next Generation (CNG) objects.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngKey : IDisposable
	{
		/// <summary>Gets the algorithm group that is used by the key.</summary>
		/// <returns>An object that specifies the name of an encryption algorithm group.</returns>
		public CngAlgorithmGroup AlgorithmGroup
		{
			[SecuritySafeCritical]
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets the algorithm that is used by the key.</summary>
		/// <returns>An object that specifies the name of an encryption algorithm.</returns>
		public CngAlgorithm Algorithm
		{
			[SecuritySafeCritical]
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets the export policy that is used by the key.</summary>
		/// <returns>An object that specifies the export policy for the key.</returns>
		public CngExportPolicies ExportPolicy
		{
			[SecuritySafeCritical]
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets a safe handle that represents a native key (NCRYPT_KEY_HANDLE). </summary>
		/// <returns>A safe handle that represents the key.</returns>
		public SafeNCryptKeyHandle Handle
		{
			[SecurityCritical]
			[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets the persistence state of the key.</summary>
		/// <returns>
		///     <see langword="true" /> if the key is ephemeral; otherwise, <see langword="false" />. </returns>
		public bool IsEphemeral
		{
			[SecuritySafeCritical]
			get
			{
				throw new NotImplementedException();
			}
			[SecurityCritical]
			private set
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets the scope (machine or user) of the key.</summary>
		/// <returns>
		///     <see langword="true" /> if the key is available on a machine-wide basis; <see langword="false" /> if the key is only for the current user.</returns>
		public bool IsMachineKey
		{
			[SecuritySafeCritical]
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets the name of the key.</summary>
		/// <returns>The name of the key. If the key is ephemeral, the value is <see langword="null" />.</returns>
		public string KeyName
		{
			[SecuritySafeCritical]
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets the key size in bits.</summary>
		/// <returns>The key size in bits.</returns>
		public int KeySize
		{
			[SecuritySafeCritical]
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets the cryptographic operations specified by the key.</summary>
		/// <returns>A bitwise combination of the enumeration values that specify the usages allowed for the key.</returns>
		public CngKeyUsages KeyUsage
		{
			[SecuritySafeCritical]
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets or sets the window handle (HWND) that should be used for user interface (UI) prompts caused by accessing the key.</summary>
		/// <returns>The parent window handle for the key.</returns>
		public IntPtr ParentWindowHandle
		{
			[SecuritySafeCritical]
			get
			{
				throw new NotImplementedException();
			}
			[SecuritySafeCritical]
			[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
			set
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets the key storage provider (KSP) that manages the key.</summary>
		/// <returns>The KSP that manages the key.</returns>
		public CngProvider Provider
		{
			[SecuritySafeCritical]
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets a native handle (an NCRYPT_PROV_HANDLE) to the key storage provider (KSP).</summary>
		/// <returns>A handle to the KSP.</returns>
		public SafeNCryptProviderHandle ProviderHandle
		{
			[SecurityCritical]
			[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets the unique name for the key.</summary>
		/// <returns>An alternate name for the key. If the key is ephemeral, the value is <see langword="null" />.</returns>
		public string UniqueName
		{
			[SecuritySafeCritical]
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets parameters that control the user interface (UI) for accessing the key.  </summary>
		/// <returns>An object that contains configuration parameters for displaying the UI.</returns>
		public CngUIPolicy UIPolicy
		{
			[SecuritySafeCritical]
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Creates a <see cref="T:System.Security.Cryptography.CngKey" /> object that can be used with the specified algorithm.</summary>
		/// <param name="algorithm">The algorithm that the key will be used with.</param>
		/// <returns>An ephemeral key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="algorithm" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		public static CngKey Create(CngAlgorithm algorithm)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a named <see cref="T:System.Security.Cryptography.CngKey" /> object that provides the specified algorithm.</summary>
		/// <param name="algorithm">The algorithm that the key will be used with.</param>
		/// <param name="keyName">The key name. If a name is not provided, the key will not be persisted.</param>
		/// <returns>A persisted or ephemeral key that provides the specified algorithm.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="algorithm" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		public static CngKey Create(CngAlgorithm algorithm, string keyName)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a named <see cref="T:System.Security.Cryptography.CngKey" /> object that provides the specified algorithm, using the supplied key creation parameters.</summary>
		/// <param name="algorithm">The algorithm that the key will be used with.</param>
		/// <param name="keyName">The key name. If a name is not provided, the key will not be persisted.</param>
		/// <param name="creationParameters">An object that specifies advanced parameters for the method, including the <see cref="T:System.Security.Cryptography.CngProvider" />.</param>
		/// <returns>A persisted or ephemeral key that provides the specified algorithm.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="algorithm" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		[SecuritySafeCritical]
		public static CngKey Create(CngAlgorithm algorithm, string keyName, CngKeyCreationParameters creationParameters)
		{
			throw new NotImplementedException();
		}

		/// <summary>Removes the key that is associated with the object.</summary>
		/// <exception cref="T:System.ObjectDisposedException">An attempt was made to access a deleted key.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		[SecuritySafeCritical]
		public void Delete()
		{
			throw new NotImplementedException();
		}

		/// <summary>Releases all resources used by the current instance of the <see cref="T:System.Security.Cryptography.CngKey" /> class.</summary>
		[SecuritySafeCritical]
		public void Dispose()
		{
			throw new NotImplementedException();
		}

		/// <summary>Checks to see whether a named key exists in the default key storage provider (KSP).</summary>
		/// <param name="keyName">The key name.</param>
		/// <returns>
		///     <see langword="true" /> if the named key exists in the default KSP; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		public static bool Exists(string keyName)
		{
			throw new NotImplementedException();
		}

		/// <summary>Checks to see whether a named key exists in the specified key storage provider (KSP).</summary>
		/// <param name="keyName">The key name.</param>
		/// <param name="provider">The KSP to check for the key.</param>
		/// <returns>
		///     <see langword="true" /> if the named key exists in the specified provider; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyName" /> or <paramref name="provider" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		public static bool Exists(string keyName, CngProvider provider)
		{
			throw new NotImplementedException();
		}

		/// <summary>Checks to see whether a named key exists in the specified key storage provider (KSP), according to the specified options.</summary>
		/// <param name="keyName">The key name.</param>
		/// <param name="provider">The KSP to search for the key.</param>
		/// <param name="options">A bitwise combination of the enumeration values that specify options for opening a key.</param>
		/// <returns>
		///     <see langword="true" /> if the named key exists in the specified provider; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyName" /> or <paramref name="provider" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		[SecuritySafeCritical]
		public static bool Exists(string keyName, CngProvider provider, CngKeyOpenOptions options)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a new key by importing the specified key material into the default key storage provider (KSP) and using the specified format.</summary>
		/// <param name="keyBlob">An array that contains the key information.</param>
		/// <param name="format">An object that specifies the format of the <paramref name="keyBlob" /> array.</param>
		/// <returns>A new key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyBlob" /> or <paramref name="format" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		public static CngKey Import(byte[] keyBlob, CngKeyBlobFormat format)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a new key by importing the specified key material into the specified key storage provider (KSP), using the specified format.</summary>
		/// <param name="keyBlob">An array that contains the key information.</param>
		/// <param name="format">An object that specifies the format of the <paramref name="keyBlob" /> array.</param>
		/// <param name="provider">The KSP.</param>
		/// <returns>A new key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyBlob" />, <paramref name="format" />, or <paramref name="provider" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		[SecuritySafeCritical]
		public static CngKey Import(byte[] keyBlob, CngKeyBlobFormat format, CngProvider provider)
		{
			throw new NotImplementedException();
		}

		/// <summary>Exports the key material into a BLOB, in the specified format.</summary>
		/// <param name="format">An object that specifies the format of the key BLOB.</param>
		/// <returns>A BLOB that contains the key material in the specified format.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="format" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors. Typically, the <see cref="P:System.Security.Cryptography.CngKey.ExportPolicy" /> does not allow the key to be exported. </exception>
		[SecuritySafeCritical]
		public byte[] Export(CngKeyBlobFormat format)
		{
			throw new NotImplementedException();
		}

		/// <summary>Gets a property, given a name and a set of property options.</summary>
		/// <param name="name">The name of the desired property.</param>
		/// <param name="options">A bitwise combination of the enumeration values that specify options for the named property.</param>
		/// <returns>An object that contains the raw value of the specified property.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="name" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		[SecuritySafeCritical]
		[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
		public CngProperty GetProperty(string name, CngPropertyOptions options)
		{
			throw new NotImplementedException();
		}

		/// <summary>Checks to see whether the specified property exists on the key.</summary>
		/// <param name="name">The property name to check.</param>
		/// <param name="options">A bitwise combination of the enumeration values that specify options for the named property.</param>
		/// <returns>
		///     <see langword="true" /> if the specified property is found; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="name" /> is <see langword="null" />.</exception>
		[SecuritySafeCritical]
		[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
		public bool HasProperty(string name, CngPropertyOptions options)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates an instance of an <see cref="T:System.Security.Cryptography.CngKey" /> object that represents an existing named key.</summary>
		/// <param name="keyName">The name of the key.</param>
		/// <returns>An existing key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		public static CngKey Open(string keyName)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates an instance of an <see cref="T:System.Security.Cryptography.CngKey" /> object that represents an existing named key, using the specified key storage provider (KSP).</summary>
		/// <param name="keyName">The name of the key.</param>
		/// <param name="provider">The KSP that contains the key.</param>
		/// <returns>An existing key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyName" /> or <paramref name="provider" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		public static CngKey Open(string keyName, CngProvider provider)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates an instance of an <see cref="T:System.Security.Cryptography.CngKey" /> object that represents an existing named key, using the specified key storage provider (KSP) and key open options.</summary>
		/// <param name="keyName">The name of the key.</param>
		/// <param name="provider">The KSP that contains the key.</param>
		/// <param name="openOptions">A bitwise combination of the enumeration values that specify options for opening the key, such as where the key is opened from (machine or user storage) and whether to suppress UI prompting.</param>
		/// <returns>An existing key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyName" /> or <paramref name="provider" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		[SecuritySafeCritical]
		public static CngKey Open(string keyName, CngProvider provider, CngKeyOpenOptions openOptions)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates an instance of an <see cref="T:System.Security.Cryptography.CngKey" /> object by using a handle to an existing key.</summary>
		/// <param name="keyHandle">A handle to an existing key.</param>
		/// <param name="keyHandleOpenOptions">One of the enumeration values that indicates whether <paramref name="keyHandle" /> represents an ephemeral key or a named key.</param>
		/// <returns>An existing key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyHandle" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="keyHandle" /> is invalid or malformed, or it is already closed. This exception is also thrown if the key is an ephemeral key that is created by the common language runtime (CLR), but the <see cref="F:System.Security.Cryptography.CngKeyHandleOpenOptions.EphemeralKey" /> value is not specified.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) is not supported on this system.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		[SecurityCritical]
		[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
		public static CngKey Open(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions)
		{
			throw new NotImplementedException();
		}

		/// <summary>Sets a named property on the key.</summary>
		/// <param name="property">The key property to set.</param>
		[SecuritySafeCritical]
		[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
		public void SetProperty(CngProperty property)
		{
			throw new NotImplementedException();
		}
	}
	/// <summary>Specifies a key BLOB format for use with Microsoft Cryptography Next Generation (CNG) objects. </summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngKeyBlobFormat : IEquatable<CngKeyBlobFormat>
	{
		private static volatile CngKeyBlobFormat s_eccPrivate;

		private static volatile CngKeyBlobFormat s_eccPublic;

		private static volatile CngKeyBlobFormat s_eccFullPrivate;

		private static volatile CngKeyBlobFormat s_eccFullPublic;

		private static volatile CngKeyBlobFormat s_genericPrivate;

		private static volatile CngKeyBlobFormat s_genericPublic;

		private static volatile CngKeyBlobFormat s_opaqueTransport;

		private static volatile CngKeyBlobFormat s_pkcs8Private;

		private string m_format;

		/// <summary>Gets the name of the key BLOB format that the current <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object specifies.</summary>
		/// <returns>The embedded key BLOB format name.</returns>
		public string Format => m_format;

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object that specifies a private key BLOB for an elliptic curve cryptography (ECC) key.</summary>
		/// <returns>An object that specifies an ECC private key BLOB.</returns>
		public static CngKeyBlobFormat EccPrivateBlob
		{
			get
			{
				if (s_eccPrivate == null)
				{
					s_eccPrivate = new CngKeyBlobFormat("ECCPRIVATEBLOB");
				}
				return s_eccPrivate;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object that specifies a public key BLOB for an elliptic curve cryptography (ECC) key.</summary>
		/// <returns>An object that specifies an ECC public key BLOB.</returns>
		public static CngKeyBlobFormat EccPublicBlob
		{
			get
			{
				if (s_eccPublic == null)
				{
					s_eccPublic = new CngKeyBlobFormat("ECCPUBLICBLOB");
				}
				return s_eccPublic;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object that specifies a private key BLOB for an elliptic curve cryptography (ECC) key which contains explicit curve parameters.</summary>
		/// <returns>An object describing a private key BLOB.</returns>
		public static CngKeyBlobFormat EccFullPrivateBlob
		{
			get
			{
				if (s_eccFullPrivate == null)
				{
					s_eccFullPrivate = new CngKeyBlobFormat("ECCFULLPRIVATEBLOB");
				}
				return s_eccFullPrivate;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object that specifies a public key BLOB for an elliptic curve cryptography (ECC) key which contains explicit curve parameters.</summary>
		/// <returns>An object describing a public key BLOB.</returns>
		public static CngKeyBlobFormat EccFullPublicBlob
		{
			get
			{
				if (s_eccFullPublic == null)
				{
					s_eccFullPublic = new CngKeyBlobFormat("ECCFULLPUBLICBLOB");
				}
				return s_eccFullPublic;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object that specifies a generic private key BLOB.</summary>
		/// <returns>An object that specifies a generic private key BLOB.</returns>
		public static CngKeyBlobFormat GenericPrivateBlob
		{
			get
			{
				if (s_genericPrivate == null)
				{
					s_genericPrivate = new CngKeyBlobFormat("PRIVATEBLOB");
				}
				return s_genericPrivate;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object that specifies a generic public key BLOB.</summary>
		/// <returns>An object that specifies a generic public key BLOB.</returns>
		public static CngKeyBlobFormat GenericPublicBlob
		{
			get
			{
				if (s_genericPublic == null)
				{
					s_genericPublic = new CngKeyBlobFormat("PUBLICBLOB");
				}
				return s_genericPublic;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object that specifies an opaque transport key BLOB.</summary>
		/// <returns>An object that specifies an opaque transport key BLOB.</returns>
		public static CngKeyBlobFormat OpaqueTransportBlob
		{
			get
			{
				if (s_opaqueTransport == null)
				{
					s_opaqueTransport = new CngKeyBlobFormat("OpaqueTransport");
				}
				return s_opaqueTransport;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object that specifies a Private Key Information Syntax Standard (PKCS #8) key BLOB.</summary>
		/// <returns>An object that specifies a PKCS #8 private key BLOB.</returns>
		public static CngKeyBlobFormat Pkcs8PrivateBlob
		{
			get
			{
				if (s_pkcs8Private == null)
				{
					s_pkcs8Private = new CngKeyBlobFormat("PKCS8_PRIVATEKEY");
				}
				return s_pkcs8Private;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> class by using the specified format.</summary>
		/// <param name="format">The key BLOB format to initialize.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="format" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <paramref name="format" /> parameter length is 0 (zero).</exception>
		public CngKeyBlobFormat(string format)
		{
			if (format == null)
			{
				throw new ArgumentNullException("format");
			}
			if (format.Length == 0)
			{
				throw new ArgumentException(SR.GetString("The key blob format '{0}' is invalid.", format), "format");
			}
			m_format = format;
		}

		/// <summary>Determines whether two <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> objects specify the same key BLOB format.</summary>
		/// <param name="left">An object that specifies a key BLOB format.</param>
		/// <param name="right">A second object, to be compared to the object identified by the <paramref name="left" /> parameter.</param>
		/// <returns>
		///     <see langword="true" /> if the two objects specify the same key BLOB format; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(CngKeyBlobFormat left, CngKeyBlobFormat right)
		{
			return left?.Equals(right) ?? ((object)right == null);
		}

		/// <summary>Determines whether two <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> objects do not specify the same key BLOB format.</summary>
		/// <param name="left">An object that specifies a key BLOB format.</param>
		/// <param name="right">A second object, to be compared to the object identified by the <paramref name="left" /> parameter.</param>
		/// <returns>
		///     <see langword="true" /> if the two objects do not specify the same key BLOB format; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(CngKeyBlobFormat left, CngKeyBlobFormat right)
		{
			if ((object)left == null)
			{
				return (object)right != null;
			}
			return !left.Equals(right);
		}

		/// <summary>Compares the specified object to the current <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object.</summary>
		/// <param name="obj">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object that specifies the same key BLOB format as the current object; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			return Equals(obj as CngKeyBlobFormat);
		}

		/// <summary>Compares the specified <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object to the current <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object.</summary>
		/// <param name="other">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <paramref name="other" /> parameter specifies the same key BLOB format as the current object; otherwise, <see langword="false" />.</returns>
		public bool Equals(CngKeyBlobFormat other)
		{
			if ((object)other == null)
			{
				return false;
			}
			return m_format.Equals(other.Format);
		}

		/// <summary>Generates a hash value for the embedded key BLOB format in the current <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object.</summary>
		/// <returns>The hash value of the embedded key BLOB format. </returns>
		public override int GetHashCode()
		{
			return m_format.GetHashCode();
		}

		/// <summary>Gets the name of the key BLOB format that the current <see cref="T:System.Security.Cryptography.CngKeyBlobFormat" /> object specifies.</summary>
		/// <returns>The embedded key BLOB format name.</returns>
		public override string ToString()
		{
			return m_format;
		}
	}
	/// <summary>Contains advanced properties for key creation.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngKeyCreationParameters
	{
		private CngExportPolicies? m_exportPolicy;

		private CngKeyCreationOptions m_keyCreationOptions;

		private CngKeyUsages? m_keyUsage;

		private CngPropertyCollection m_parameters = new CngPropertyCollection();

		private IntPtr m_parentWindowHandle;

		private CngProvider m_provider = CngProvider.MicrosoftSoftwareKeyStorageProvider;

		private CngUIPolicy m_uiPolicy;

		/// <summary>Gets or sets the key export policy.</summary>
		/// <returns>An object that specifies a key export policy. The default value is <see langword="null" />, which indicates that the key storage provider's default export policy is set.</returns>
		public CngExportPolicies? ExportPolicy
		{
			get
			{
				return m_exportPolicy;
			}
			set
			{
				m_exportPolicy = value;
			}
		}

		/// <summary>Gets or sets the key creation options.</summary>
		/// <returns>An object that specifies options for creating keys. The default value is <see langword="null" />, which indicates that the key storage provider's default key creation options are set.</returns>
		public CngKeyCreationOptions KeyCreationOptions
		{
			get
			{
				return m_keyCreationOptions;
			}
			set
			{
				m_keyCreationOptions = value;
			}
		}

		/// <summary>Gets or sets the cryptographic operations that apply to the current key. </summary>
		/// <returns>A bitwise combination of one or more enumeration values that specify key usage. The default value is <see langword="null" />, which indicates that the key storage provider's default key usage is set.</returns>
		public CngKeyUsages? KeyUsage
		{
			get
			{
				return m_keyUsage;
			}
			set
			{
				m_keyUsage = value;
			}
		}

		/// <summary>Gets or sets the window handle that should be used as the parent window for dialog boxes that are created by Cryptography Next Generation (CNG) classes.</summary>
		/// <returns>The HWND of the parent window that is used for CNG dialog boxes.</returns>
		public IntPtr ParentWindowHandle
		{
			get
			{
				return m_parentWindowHandle;
			}
			[SecuritySafeCritical]
			[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
			set
			{
				m_parentWindowHandle = value;
			}
		}

		/// <summary>Enables a <see cref="T:System.Security.Cryptography.CngKey" /> object to be created with additional properties that are set before the key is finalized.</summary>
		/// <returns>A collection object that contains any additional parameters that you must set on a <see cref="T:System.Security.Cryptography.CngKey" /> object during key creation.</returns>
		public CngPropertyCollection Parameters
		{
			[SecuritySafeCritical]
			[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
			get
			{
				return m_parameters;
			}
		}

		internal CngPropertyCollection ParametersNoDemand => m_parameters;

		/// <summary>Gets or sets the key storage provider (KSP) to create a key in.</summary>
		/// <returns>An object that specifies the KSP that a new key will be created in.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Security.Cryptography.CngKeyCreationParameters.Provider" /> property is set to a <see langword="null" /> value.</exception>
		public CngProvider Provider
		{
			get
			{
				return m_provider;
			}
			set
			{
				if (value == null)
				{
					throw new ArgumentNullException("value");
				}
				m_provider = value;
			}
		}

		/// <summary>Gets or sets information about the user interface to display when a key is created or accessed.</summary>
		/// <returns>An object that contains details about the user interface shown by Cryptography Next Generation (CNG) classes when a key is created or accessed. A <see langword="null" /> value indicates that the key storage provider's default user interface policy is set.</returns>
		public CngUIPolicy UIPolicy
		{
			get
			{
				return m_uiPolicy;
			}
			[SecuritySafeCritical]
			[HostProtection(SecurityAction.LinkDemand, UI = true)]
			[UIPermission(SecurityAction.Demand, Window = UIPermissionWindow.SafeSubWindows)]
			set
			{
				m_uiPolicy = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngKeyCreationParameters" /> class.</summary>
		public CngKeyCreationParameters()
		{
		}
	}
	/// <summary>Encapsulates a property of a Cryptography Next Generation (CNG) key or provider.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public struct CngProperty : IEquatable<CngProperty>
	{
		private string m_name;

		private CngPropertyOptions m_propertyOptions;

		private byte[] m_value;

		private int? m_hashCode;

		/// <summary>Gets the property name that the current <see cref="T:System.Security.Cryptography.CngProperty" /> object specifies.</summary>
		/// <returns>The property name that is set in the current <see cref="T:System.Security.Cryptography.CngProperty" /> object.</returns>
		public string Name => m_name;

		/// <summary>Gets the property options that the current <see cref="T:System.Security.Cryptography.CngProperty" /> object specifies.</summary>
		/// <returns>An object that specifies the options that are set in the current <see cref="T:System.Security.Cryptography.CngProperty" /> object.</returns>
		public CngPropertyOptions Options => m_propertyOptions;

		internal byte[] Value => m_value;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngProperty" /> class.</summary>
		/// <param name="name">The property name to initialize.</param>
		/// <param name="value">The property value to initialize.</param>
		/// <param name="options">A bitwise combination of the enumeration values that specify how the property is stored.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="name" /> is <see langword="null" />.</exception>
		public CngProperty(string name, byte[] value, CngPropertyOptions options)
		{
			if (name == null)
			{
				throw new ArgumentNullException("name");
			}
			m_name = name;
			m_propertyOptions = options;
			m_hashCode = null;
			if (value != null)
			{
				m_value = value.Clone() as byte[];
			}
			else
			{
				m_value = null;
			}
		}

		/// <summary>Gets the property value that the current <see cref="T:System.Security.Cryptography.CngProperty" /> object specifies.</summary>
		/// <returns>An array that represents the value stored in the property.</returns>
		public byte[] GetValue()
		{
			byte[] result = null;
			if (m_value != null)
			{
				result = m_value.Clone() as byte[];
			}
			return result;
		}

		/// <summary>Determines whether two <see cref="T:System.Security.Cryptography.CngProperty" /> objects specify the same property name, value, and options.</summary>
		/// <param name="left">An object that specifies a property of a Cryptography Next Generation (CNG) key or provider.</param>
		/// <param name="right">A second object, to be compared to the object that is identified by the <paramref name="left" /> parameter.</param>
		/// <returns>
		///     <see langword="true" /> if the two objects specify the same property; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(CngProperty left, CngProperty right)
		{
			return left.Equals(right);
		}

		/// <summary>Determines whether two <see cref="T:System.Security.Cryptography.CngProperty" /> objects do not specify the same property name, value, and options.</summary>
		/// <param name="left">An object that specifies a property of a Cryptography Next Generation (CNG) key or provider.</param>
		/// <param name="right">A second object, to be compared to the object that is identified by the <paramref name="left" /> parameter.</param>
		/// <returns>
		///     <see langword="true" /> if the two objects do not specify the same property; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(CngProperty left, CngProperty right)
		{
			return !left.Equals(right);
		}

		/// <summary>Compares the specified object to the current <see cref="T:System.Security.Cryptography.CngProperty" /> object.</summary>
		/// <param name="obj">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngProperty" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Security.Cryptography.CngProperty" /> object that specifies the same property as the current object; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			if (obj == null || !(obj is CngProperty))
			{
				return false;
			}
			return Equals((CngProperty)obj);
		}

		/// <summary>Compares the specified <see cref="T:System.Security.Cryptography.CngProperty" /> object to the current <see cref="T:System.Security.Cryptography.CngProperty" /> object.</summary>
		/// <param name="other">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngProperty" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <paramref name="other" /> parameter represents the same property as the current object; otherwise, <see langword="false" />.</returns>
		public bool Equals(CngProperty other)
		{
			if (!string.Equals(Name, other.Name, StringComparison.Ordinal))
			{
				return false;
			}
			if (Options != other.Options)
			{
				return false;
			}
			if (m_value == null)
			{
				return other.m_value == null;
			}
			if (other.m_value == null)
			{
				return false;
			}
			if (m_value.Length != other.m_value.Length)
			{
				return false;
			}
			for (int i = 0; i < m_value.Length; i++)
			{
				if (m_value[i] != other.m_value[i])
				{
					return false;
				}
			}
			return true;
		}

		/// <summary>Generates a hash value for the current <see cref="T:System.Security.Cryptography.CngProperty" /> object.</summary>
		/// <returns>The hash value of the current <see cref="T:System.Security.Cryptography.CngProperty" /> object.</returns>
		public override int GetHashCode()
		{
			if (!m_hashCode.HasValue)
			{
				int num = Name.GetHashCode() ^ Options.GetHashCode();
				if (m_value != null)
				{
					for (int i = 0; i < m_value.Length; i++)
					{
						int num2 = m_value[i] << i % 4 * 8;
						num ^= num2;
					}
				}
				m_hashCode = num;
			}
			return m_hashCode.Value;
		}
	}
	/// <summary>Provides a strongly typed collection of Cryptography Next Generation (CNG) properties.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngPropertyCollection : Collection<CngProperty>
	{
		/// <summary>Initializes a new <see cref="T:System.Security.Cryptography.CngPropertyCollection" /> object.</summary>
		public CngPropertyCollection()
		{
		}
	}
	/// <summary>Encapsulates the name of a key storage provider (KSP) for use with Cryptography Next Generation (CNG) objects.</summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngProvider : IEquatable<CngProvider>
	{
		private static volatile CngProvider s_msSmartCardKsp;

		private static volatile CngProvider s_msSoftwareKsp;

		private string m_provider;

		/// <summary>Gets the name of the key storage provider (KSP) that the current <see cref="T:System.Security.Cryptography.CngProvider" /> object specifies.</summary>
		/// <returns>The embedded KSP name.</returns>
		public string Provider => m_provider;

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngProvider" /> object that specifies the Microsoft Smart Card Key Storage Provider.</summary>
		/// <returns>An object that specifies the Microsoft Smart Card Key Storage Provider.</returns>
		public static CngProvider MicrosoftSmartCardKeyStorageProvider
		{
			get
			{
				if (s_msSmartCardKsp == null)
				{
					s_msSmartCardKsp = new CngProvider("Microsoft Smart Card Key Storage Provider");
				}
				return s_msSmartCardKsp;
			}
		}

		/// <summary>Gets a <see cref="T:System.Security.Cryptography.CngProvider" /> object that specifies the Microsoft Software Key Storage Provider.</summary>
		/// <returns>An object that specifies the Microsoft Software Key Storage Provider.</returns>
		public static CngProvider MicrosoftSoftwareKeyStorageProvider
		{
			get
			{
				if (s_msSoftwareKsp == null)
				{
					s_msSoftwareKsp = new CngProvider("Microsoft Software Key Storage Provider");
				}
				return s_msSoftwareKsp;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngProvider" /> class.</summary>
		/// <param name="provider">The name of the key storage provider (KSP) to initialize.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="provider" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <paramref name="provider" /> parameter length is 0 (zero).</exception>
		public CngProvider(string provider)
		{
			if (provider == null)
			{
				throw new ArgumentNullException("provider");
			}
			if (provider.Length == 0)
			{
				throw new ArgumentException(SR.GetString("The provider name '{0}' is invalid.", provider), "provider");
			}
			m_provider = provider;
		}

		/// <summary>Determines whether two <see cref="T:System.Security.Cryptography.CngProvider" /> objects specify the same key storage provider (KSP).</summary>
		/// <param name="left">An object that specifies a KSP.</param>
		/// <param name="right">A second object, to be compared to the object that is identified by the <paramref name="left" /> parameter.</param>
		/// <returns>
		///     <see langword="true" /> if the two objects represent the same KSP; otherwise, <see langword="false" />.</returns>
		public static bool operator ==(CngProvider left, CngProvider right)
		{
			return left?.Equals(right) ?? ((object)right == null);
		}

		/// <summary>Determines whether two <see cref="T:System.Security.Cryptography.CngProvider" /> objects do not represent the same key storage provider (KSP).</summary>
		/// <param name="left">An object that specifies a KSP.</param>
		/// <param name="right">A second object, to be compared to the object that is identified by the <paramref name="left" /> parameter.</param>
		/// <returns>
		///     <see langword="true" /> if the two objects do not represent the same KSP; otherwise, <see langword="false" />.</returns>
		public static bool operator !=(CngProvider left, CngProvider right)
		{
			if ((object)left == null)
			{
				return (object)right != null;
			}
			return !left.Equals(right);
		}

		/// <summary>Compares the specified object to the current <see cref="T:System.Security.Cryptography.CngProvider" /> object.</summary>
		/// <param name="obj">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngProvider" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Security.Cryptography.CngProvider" /> that specifies the same key storage provider(KSP) as the current object; otherwise, <see langword="false" />.</returns>
		public override bool Equals(object obj)
		{
			return Equals(obj as CngProvider);
		}

		/// <summary>Compares the specified <see cref="T:System.Security.Cryptography.CngProvider" /> object to the current <see cref="T:System.Security.Cryptography.CngProvider" /> object.</summary>
		/// <param name="other">An object to be compared to the current <see cref="T:System.Security.Cryptography.CngProvider" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <paramref name="other" /> parameter specifies the same key storage provider (KSP) as the current object; otherwise, <see langword="false" />.</returns>
		public bool Equals(CngProvider other)
		{
			if ((object)other == null)
			{
				return false;
			}
			return m_provider.Equals(other.Provider);
		}

		/// <summary>Generates a hash value for the name of the key storage provider (KSP) that is embedded in the current <see cref="T:System.Security.Cryptography.CngProvider" /> object.</summary>
		/// <returns>The hash value of the embedded KSP name.</returns>
		public override int GetHashCode()
		{
			return m_provider.GetHashCode();
		}

		/// <summary>Gets the name of the key storage provider (KSP) that the current <see cref="T:System.Security.Cryptography.CngProvider" /> object specifies.</summary>
		/// <returns>The embedded KSP name.</returns>
		public override string ToString()
		{
			return m_provider.ToString();
		}
	}
	/// <summary>Encapsulates optional configuration parameters for the user interface (UI) that Cryptography Next Generation (CNG) displays when you access a protected key.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CngUIPolicy
	{
		private string m_creationTitle;

		private string m_description;

		private string m_friendlyName;

		private CngUIProtectionLevels m_protectionLevel;

		private string m_useContext;

		/// <summary>Gets the title that is displayed by the UI prompt.</summary>
		/// <returns>The title of the dialog box that appears when the key is accessed.</returns>
		public string CreationTitle => m_creationTitle;

		/// <summary>Gets the description string that is displayed by the UI prompt.</summary>
		/// <returns>The description text for the dialog box that appears when the key is accessed.</returns>
		public string Description => m_description;

		/// <summary>Gets the friendly name that is displayed by the UI prompt.</summary>
		/// <returns>The friendly name that is used to describe the key in the dialog box that appears when the key is accessed.</returns>
		public string FriendlyName => m_friendlyName;

		/// <summary>Gets the UI protection level for the key.</summary>
		/// <returns>An object that describes the level of UI protection to apply to the key.</returns>
		public CngUIProtectionLevels ProtectionLevel => m_protectionLevel;

		/// <summary>Gets the description of how the key will be used.</summary>
		/// <returns>The description of how the key will be used.</returns>
		public string UseContext => m_useContext;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngUIPolicy" /> class by using the specified protection level.</summary>
		/// <param name="protectionLevel">A bitwise combination of the enumeration values that specify the protection level.</param>
		public CngUIPolicy(CngUIProtectionLevels protectionLevel)
			: this(protectionLevel, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngUIPolicy" /> class by using the specified protection level and friendly name.</summary>
		/// <param name="protectionLevel">A bitwise combination of the enumeration values that specify the protection level.  </param>
		/// <param name="friendlyName">A friendly name for the key to be used in the UI prompt. Specify a null string to use the default name.</param>
		public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName)
			: this(protectionLevel, friendlyName, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngUIPolicy" /> class by using the specified protection level, friendly name, and description.</summary>
		/// <param name="protectionLevel">A bitwise combination of the enumeration values that specify the protection level.  </param>
		/// <param name="friendlyName">A friendly name for the key to be used in the UI prompt. Specify a null string to use the default name.</param>
		/// <param name="description">The full-text description of the key. Specify a null string to use the default description.</param>
		public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description)
			: this(protectionLevel, friendlyName, description, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngUIPolicy" /> class by using the specified protection level, friendly name, description string, and use context.</summary>
		/// <param name="protectionLevel">A bitwise combination of the enumeration values that specify the protection level.  </param>
		/// <param name="friendlyName">A friendly name for the key to be used in the UI prompt. Specify a null string to use the default name.</param>
		/// <param name="description">The full-text description of the key. Specify a null string to use the default description.</param>
		/// <param name="useContext">A description of how the key will be used. Specify a null string to use the default description.</param>
		public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext)
			: this(protectionLevel, friendlyName, description, useContext, null)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.CngUIPolicy" /> class by using the specified protection level, friendly name, description string, use context, and title.</summary>
		/// <param name="protectionLevel">A bitwise combination of the enumeration values that specify the protection level.  </param>
		/// <param name="friendlyName">A friendly name for the key to be used in the UI prompt. Specify a null string to use the default name.</param>
		/// <param name="description">The full-text description of the key. Specify a null string to use the default description.</param>
		/// <param name="useContext">A description of how the key will be used. Specify a null string to use the default description.</param>
		/// <param name="creationTitle">The title for the dialog box that provides the UI prompt. Specify a null string to use the default title.</param>
		public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext, string creationTitle)
		{
			m_creationTitle = creationTitle;
			m_description = description;
			m_friendlyName = friendlyName;
			m_protectionLevel = protectionLevel;
			m_useContext = useContext;
		}
	}
	/// <summary>Provides an abstract base class that Elliptic Curve Diffie-Hellman (ECDH) algorithm implementations can derive from. This class provides the basic set of operations that all ECDH implementations must support.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class ECDiffieHellman : AsymmetricAlgorithm
	{
		/// <summary>Gets the name of the key exchange algorithm.</summary>
		/// <returns>The name of the key exchange algorithm. </returns>
		public override string KeyExchangeAlgorithm => "ECDiffieHellman";

		/// <summary>Gets the name of the signature algorithm.</summary>
		/// <returns>Always <see langword="null" />.</returns>
		public override string SignatureAlgorithm => null;

		/// <summary>Gets the public key that is being used by the current Elliptic Curve Diffie-Hellman (ECDH) instance.</summary>
		/// <returns>The public part of the ECDH key pair that is being used by this <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> instance.</returns>
		public abstract ECDiffieHellmanPublicKey PublicKey { get; }

		/// <summary>Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</summary>
		/// <returns>A new instance of the default implementation of this class.</returns>
		public new static ECDiffieHellman Create()
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a new instance of the specified implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</summary>
		/// <param name="algorithm">The name of an implementation of the ECDH algorithm.</param>
		/// <returns>A new instance of the specified implementation of this class. If the specified algorithm name does not map to an ECDH implementation, this method returns <see langword="null" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="algorithm" /> parameter is <see langword="null" />. </exception>
		public new static ECDiffieHellman Create(string algorithm)
		{
			if (algorithm == null)
			{
				throw new ArgumentNullException("algorithm");
			}
			return CryptoConfig.CreateFromName(algorithm) as ECDiffieHellman;
		}

		/// <summary>Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with a new public/private key-pair generated over the specified curve. </summary>
		/// <param name="curve">The curve to use to generate a new public/private key-pair. </param>
		/// <returns>A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm. </returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///         <paramref name="curve" /> does not validate. </exception>
		public static ECDiffieHellman Create(ECCurve curve)
		{
			ECDiffieHellman eCDiffieHellman = Create();
			if (eCDiffieHellman != null)
			{
				try
				{
					eCDiffieHellman.GenerateKey(curve);
				}
				catch
				{
					eCDiffieHellman.Dispose();
					throw;
				}
			}
			return eCDiffieHellman;
		}

		/// <summary>Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with the key described by the specified  <see cref="T:System.Security.Cryptography.ECParameters" /> object. </summary>
		/// <param name="parameters">The parameters  for the elliptic curve cryptography (ECC) algorithm. </param>
		/// <returns>A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm. </returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///         <paramref name="parameters" /> does not validate. </exception>
		public static ECDiffieHellman Create(ECParameters parameters)
		{
			ECDiffieHellman eCDiffieHellman = Create();
			if (eCDiffieHellman != null)
			{
				try
				{
					eCDiffieHellman.ImportParameters(parameters);
				}
				catch
				{
					eCDiffieHellman.Dispose();
					throw;
				}
			}
			return eCDiffieHellman;
		}

		/// <summary>Derives bytes that can be used as a key, given another party's public key.</summary>
		/// <param name="otherPartyPublicKey">The other party's public key.</param>
		/// <returns>The key material from the key exchange with the other partys public key.</returns>
		public virtual byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey)
		{
			throw DerivedClassMustOverride();
		}

		/// <summary>Derives bytes that can be used as a key using a hash function, given another party's public key and hash algorithm's name.</summary>
		/// <param name="otherPartyPublicKey">The other party's public key.</param>
		/// <param name="hashAlgorithm">The hash algorithm  to use to derive the key material.</param>
		/// <returns>The key material from the key exchange with the other partys public key.</returns>
		public byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm)
		{
			return DeriveKeyFromHash(otherPartyPublicKey, hashAlgorithm, null, null);
		}

		/// <summary>When implemented in a derived class, derives bytes that can be used as a key using a hash function, given another party's public key, hash algorithm's name, a prepend value and an append value.</summary>
		/// <param name="otherPartyPublicKey">The other party's public key.</param>
		/// <param name="hashAlgorithm">The hash algorithm  to use to derive the key material.</param>
		/// <param name="secretPrepend">A value to prepend to the derived secret before hashing.</param>
		/// <param name="secretAppend">A value to append to the derived secret before hashing.</param>
		/// <returns>The key material from the key exchange with the other partys public key.</returns>
		/// <exception cref="T:System.NotImplementedException">A derived class must override this method.</exception>
		public virtual byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, byte[] secretPrepend, byte[] secretAppend)
		{
			throw DerivedClassMustOverride();
		}

		/// <summary>Derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</summary>
		/// <param name="otherPartyPublicKey">The other party's public key.</param>
		/// <param name="hashAlgorithm">The hash algorithm to use to derive the key material.</param>
		/// <param name="hmacKey">The key for the HMAC.</param>
		/// <returns>The key material from the key exchange with the other partys public key.</returns>
		public byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, byte[] hmacKey)
		{
			return DeriveKeyFromHmac(otherPartyPublicKey, hashAlgorithm, hmacKey, null, null);
		}

		/// <summary>When implemented in a derived class, derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</summary>
		/// <param name="otherPartyPublicKey">The other party's public key.</param>
		/// <param name="hashAlgorithm">The hash algorithm to use to derive the key material.</param>
		/// <param name="hmacKey">The key for the HMAC.</param>
		/// <param name="secretPrepend">A value to prepend to the derived secret before hashing.</param>
		/// <param name="secretAppend">A value to append to the derived secret before hashing.</param>
		/// <returns>The key material from the key exchange with the other partys public key.</returns>
		/// <exception cref="T:System.NotImplementedException">A derived class must override this method.</exception>
		public virtual byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend)
		{
			throw DerivedClassMustOverride();
		}

		/// <summary>When implemented in a derived class, derives bytes that can be used as a key using a Transport Layer Security (TLS) Pseudo-Random Function (PRF) derivation algorithm.</summary>
		/// <param name="otherPartyPublicKey">The other party's public key.</param>
		/// <param name="prfLabel">The ASCII-encoded PRF label.</param>
		/// <param name="prfSeed">The 64-byte PRF seed.</param>
		/// <returns>The key material from the key exchange with the other partys public key.</returns>
		/// <exception cref="T:System.NotImplementedException">A derived class must override this method.</exception>
		public virtual byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed)
		{
			throw DerivedClassMustOverride();
		}

		private static Exception DerivedClassMustOverride()
		{
			return new NotImplementedException(SR.GetString("Method not supported. Derived class must override."));
		}

		/// <summary>When overridden in a derived class, exports either the public or the public and private key information from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key to an <see cref="T:System.Security.Cryptography.ECParameters" /> structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />   method. </summary>
		/// <param name="includePrivateParameters">
		///       <see langword="true" /> to include private parameters; otehrwise,  <see langword="false" /> to include public parameters only.</param>
		/// <returns>An object that represents the point on the curve for this key. It can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method. </returns>
		/// <exception cref="T:System.NotImplementedException">A derived class must override this method. </exception>
		public virtual ECParameters ExportParameters(bool includePrivateParameters)
		{
			throw DerivedClassMustOverride();
		}

		/// <summary>When overridden in a derived class, exports either the public or the public and private key information using the explicit curve form from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key to an <see cref="T:System.Security.Cryptography.ECParameters" /> structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />   method. </summary>
		/// <param name="includePrivateParameters">
		///       <see langword="true" /> to include private parameters; otherwise, <see langword="false" />. </param>
		/// <returns>An object that represents the point on the curve for this key, using the explicit curve format. </returns>
		/// <exception cref="T:System.NotImplementedException">A derived class must override this method. </exception>
		public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters)
		{
			throw DerivedClassMustOverride();
		}

		/// <summary>When overridden in a derived class, imports the specified parameters for an <see cref="T:System.Security.Cryptography.ECCurve" /> as an ephemeral key into the current <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> object. </summary>
		/// <param name="parameters">The curve's parameters to import. </param>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///         <paramref name="parameters" /> does not validate. </exception>
		/// <exception cref="T:System.NotImplementedException">A derived class must override this method. </exception>
		public virtual void ImportParameters(ECParameters parameters)
		{
			throw DerivedClassMustOverride();
		}

		/// <summary>When overridden in a derived class, generates a new ephemeral public/private key pair for the specified curve. </summary>
		/// <param name="curve">The curve used to generate an ephemeral public/private key pair. </param>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///         <paramref name="curve" /> does not validate. </exception>
		/// <exception cref="T:System.NotImplementedException">A derived class must override this method. </exception>
		public virtual void GenerateKey(ECCurve curve)
		{
			throw new NotSupportedException(SR.GetString("Method not supported. Derived class must override."));
		}

		public virtual byte[] ExportECPrivateKey()
		{
			throw new PlatformNotSupportedException();
		}

		public virtual bool TryExportECPrivateKey(Span<byte> destination, out int bytesWritten)
		{
			throw new PlatformNotSupportedException();
		}

		public virtual void ImportECPrivateKey(ReadOnlySpan<byte> source, out int bytesRead)
		{
			throw new PlatformNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> class.</summary>
		protected ECDiffieHellman()
		{
		}
	}
	/// <summary>Provides an abstract base class from which all <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" /> implementations must inherit.</summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class ECDiffieHellmanPublicKey : IDisposable
	{
		private byte[] m_keyBlob;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> class.</summary>
		protected ECDiffieHellmanPublicKey()
		{
			m_keyBlob = new byte[0];
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> class.</summary>
		/// <param name="keyBlob">A byte array that represents an <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyBlob" /> is <see langword="null" />.</exception>
		protected ECDiffieHellmanPublicKey(byte[] keyBlob)
		{
			if (keyBlob == null)
			{
				throw new ArgumentNullException("keyBlob");
			}
			m_keyBlob = keyBlob.Clone() as byte[];
		}

		/// <summary>Releases all resources used by the current instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> class.</summary>
		public void Dispose()
		{
			Dispose(disposing: true);
		}

		/// <summary>Releases the unmanaged resources used by the <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> class and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///       <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		protected virtual void Dispose(bool disposing)
		{
		}

		/// <summary>Serializes the <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> key BLOB to a byte array.</summary>
		/// <returns>A byte array that contains the serialized Elliptic Curve Diffie-Hellman (ECDH) public key.</returns>
		public virtual byte[] ToByteArray()
		{
			return m_keyBlob.Clone() as byte[];
		}

		/// <summary>Serializes the <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> public key to an XML string.</summary>
		/// <returns>An XML string that contains the serialized Elliptic Curve Diffie-Hellman (ECDH) public key.</returns>
		public virtual string ToXmlString()
		{
			throw new NotImplementedException(SR.GetString("Method not supported. Derived class must override."));
		}

		/// <summary>When overridden in a derived class, exports the named or explicit <see cref="T:System.Security.Cryptography.ECParameters" /> for an <see cref="T:System.Security.Cryptography.ECCurve" /> object.  </summary>
		/// <returns>An object that represents the point on the curve for this key.</returns>
		/// <exception cref="T:System.NotSupportedException">A derived class must override this method.</exception>
		public virtual ECParameters ExportParameters()
		{
			throw new NotSupportedException(SR.GetString("Method not supported. Derived class must override."));
		}

		/// <summary>When overridden in a derived class, exports the explicit <see cref="T:System.Security.Cryptography.ECParameters" /> for an <see cref="T:System.Security.Cryptography.ECCurve" /> object.  </summary>
		/// <returns>An object that represents the point on the curve for this key, using the explicit curve format. </returns>
		/// <exception cref="T:System.NotSupportedException">A derived class must override this method.</exception>
		public virtual ECParameters ExportExplicitParameters()
		{
			throw new NotSupportedException(SR.GetString("Method not supported. Derived class must override."));
		}
	}
	/// <summary>Provides an abstract base class that encapsulates the Elliptic Curve Digital Signature Algorithm (ECDSA).</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class ECDsa : AsymmetricAlgorithm
	{
		/// <summary>Gets the name of the key exchange algorithm.</summary>
		/// <returns>Always <see langword="null" />.</returns>
		public override string KeyExchangeAlgorithm => null;

		/// <summary>Gets the name of the signature algorithm.</summary>
		/// <returns>The string "ECDsa".</returns>
		public override string SignatureAlgorithm => "ECDsa";

		/// <summary>Creates a new instance of the default implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA).</summary>
		/// <returns>A new instance of the default implementation (<see cref="T:System.Security.Cryptography.ECDsaCng" />) of this class.</returns>
		public new static ECDsa Create()
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a new instance of the specified implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA).</summary>
		/// <param name="algorithm">The name of an ECDSA implementation. The following strings all refer to the same implementation, which is the only implementation currently supported in the .NET Framework:- "ECDsa"- "ECDsaCng"- "System.Security.Cryptography.ECDsaCng"You can also provide the name of a custom ECDSA implementation.</param>
		/// <returns>A new instance of the specified implementation of this class. If the specified algorithm name does not map to an ECDSA implementation, this method returns <see langword="null" />. </returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="algorithm" /> parameter is <see langword="null" />.</exception>
		public new static ECDsa Create(string algorithm)
		{
			if (algorithm == null)
			{
				throw new ArgumentNullException("algorithm");
			}
			return CryptoConfig.CreateFromName(algorithm) as ECDsa;
		}

		/// <summary>Creates a new instance of the default implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA) with a newly generated key over the specified curve.</summary>
		/// <param name="curve">The curve to use for key generation.</param>
		/// <returns>A new instance of the default implementation (<see cref="T:System.Security.Cryptography.ECDsaCng" />) of this class.</returns>
		public static ECDsa Create(ECCurve curve)
		{
			ECDsa eCDsa = Create();
			if (eCDsa != null)
			{
				try
				{
					eCDsa.GenerateKey(curve);
				}
				catch
				{
					eCDsa.Dispose();
					throw;
				}
			}
			return eCDsa;
		}

		/// <summary>Creates a new instance of the default implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA) using the specified parameters as the key.</summary>
		/// <param name="parameters">The parameters representing the key to use.</param>
		/// <returns>A new instance of the default implementation (<see cref="T:System.Security.Cryptography.ECDsaCng" />) of this class.</returns>
		public static ECDsa Create(ECParameters parameters)
		{
			ECDsa eCDsa = Create();
			if (eCDsa != null)
			{
				try
				{
					eCDsa.ImportParameters(parameters);
				}
				catch
				{
					eCDsa.Dispose();
					throw;
				}
			}
			return eCDsa;
		}

		/// <summary>Generates a digital signature for the specified hash value. </summary>
		/// <param name="hash">The hash value of the data that is being signed.</param>
		/// <returns>A digital signature that consists of the given hash value encrypted with the private key.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="hash" /> parameter is <see langword="null" />.</exception>
		public abstract byte[] SignHash(byte[] hash);

		/// <summary>Verifies a digital signature against the specified hash value.</summary>
		/// <param name="hash">The hash value of a block of data.</param>
		/// <param name="signature">The digital signature to be verified.</param>
		/// <returns>
		///     <see langword="true" /> if the hash value equals the decrypted signature; otherwise, <see langword="false" />.</returns>
		public abstract bool VerifyHash(byte[] hash, byte[] signature);

		/// <summary>When overridden in a derived class, computes the hash value of the specified portion of a byte array by using the specified hashing algorithm. </summary>
		/// <param name="data">The data to be hashed. </param>
		/// <param name="offset">The index of the first byte in <paramref name="data" /> to be hashed.  </param>
		/// <param name="count">The number of bytes to hash. </param>
		/// <param name="hashAlgorithm">The algorithm to use to hash the data. </param>
		/// <returns>The hashed data. </returns>
		/// <exception cref="T:System.NotImplementedException">A derived class must override this method. </exception>
		protected virtual byte[] HashData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm)
		{
			throw DerivedClassMustOverride();
		}

		/// <summary>When overridden in a derived class, computes the hash value of the specified binary stream by using the specified hashing algorithm.</summary>
		/// <param name="data">The binary stream to hash. </param>
		/// <param name="hashAlgorithm">The algorithm to use to hash the data.</param>
		/// <returns>The hashed data.</returns>
		/// <exception cref="T:System.NotImplementedException">A derived class must override this method. </exception>
		protected virtual byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm)
		{
			throw DerivedClassMustOverride();
		}

		/// <summary>Computes the hash value of the specified byte array using the specified hash algorithm and signs the resulting hash value. </summary>
		/// <param name="data">The input data for which to compute the hash. </param>
		/// <param name="hashAlgorithm">The hash algorithm to use to create the hash value. </param>
		/// <returns>The ECDSA signature for the specified data. </returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="data" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> is <see langword="null" /> or <see cref="F:System.String.Empty" />. </exception>
		public virtual byte[] SignData(byte[] data, HashAlgorithmName hashAlgorithm)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			return SignData(data, 0, data.Length, hashAlgorithm);
		}

		/// <summary>Computes the hash value of a portion of the specified byte array using the specified hash algorithm and signs the resulting hash value. </summary>
		/// <param name="data">The input data for which to compute the hash. </param>
		/// <param name="offset">The offset into the array at which to begin using data. </param>
		/// <param name="count">The number of bytes in the array to use as data. </param>
		/// <param name="hashAlgorithm">The hash algorithm to use to create the hash value. </param>
		/// <returns>The ECDSA signature for the specified data. </returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="data" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> is <see langword="null" /> or <see cref="F:System.String.Empty" />. </exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="offset" /> is less than zero. -or-
		///         <paramref name="count" /> is less than zero. -or-
		///         <paramref name="offset" /> + <paramref name="count" />  1 results in an index that is beyond the upper bound of <paramref name="data" />.  </exception>
		public virtual byte[] SignData(byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (offset < 0 || offset > data.Length)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (count < 0 || count > data.Length - offset)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (string.IsNullOrEmpty(hashAlgorithm.Name))
			{
				throw HashAlgorithmNameNullOrEmpty();
			}
			byte[] hash = HashData(data, offset, count, hashAlgorithm);
			return SignHash(hash);
		}

		/// <summary>Computes the hash value of the specified stream using the specified hash algorithm and signs the resulting hash value.</summary>
		/// <param name="data">The input stream for which to compute the hash. </param>
		/// <param name="hashAlgorithm">The hash algorithm to use to create the hash value. </param>
		/// <returns>The ECDSA signature for the specified data. </returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="data" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> is <see langword="null" /> or <see cref="F:System.String.Empty" />. </exception>
		public virtual byte[] SignData(Stream data, HashAlgorithmName hashAlgorithm)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (string.IsNullOrEmpty(hashAlgorithm.Name))
			{
				throw HashAlgorithmNameNullOrEmpty();
			}
			byte[] hash = HashData(data, hashAlgorithm);
			return SignHash(hash);
		}

		/// <summary>Verifies that a digital signature is valid by calculating the hash value of the specified data using the specified hash algorithm and comparing it to the provided signature. </summary>
		/// <param name="data">The signed data. </param>
		/// <param name="signature">The signature data to be verified. </param>
		/// <param name="hashAlgorithm">The hash algorithm used to create the hash value of the data. </param>
		/// <returns>
		///     <see langword="true" /> if the signature is valid; otherwise, <see langword="false" />. </returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="data" /> is <see langword="null" />. -or-
		///         <paramref name="signature" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> is <see langword="null" /> or <see cref="F:System.String.Empty" />. </exception>
		public bool VerifyData(byte[] data, byte[] signature, HashAlgorithmName hashAlgorithm)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			return VerifyData(data, 0, data.Length, signature, hashAlgorithm);
		}

		/// <summary>Verifies that a digital signature is valid by calculating the hash value of the data in a portion of a byte array using the specified hash algorithm and comparing it to the provided signature. </summary>
		/// <param name="data">The signed data. </param>
		/// <param name="offset">The starting index at which to compute the hash. </param>
		/// <param name="count">The number of bytes to hash. </param>
		/// <param name="signature">The signature data to be verified. </param>
		/// <param name="hashAlgorithm">The hash algorithm used to create the hash value of the data. </param>
		/// <returns>
		///     <see langword="true" /> if the signature is valid; otherwise, <see langword="false" />. </returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="data" /> is <see langword="null" />. -or-
		///         <paramref name="signature" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> is <see langword="null" /> or <see cref="F:System.String.Empty" />. </exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="offset" /> is less than zero. -or-
		///         <paramref name="count" /> is less than zero.-or-
		///         <paramref name="offset" /> + <paramref name="count" />  1 results in an index that is beyond the upper bound of <paramref name="data" />.  </exception>
		public virtual bool VerifyData(byte[] data, int offset, int count, byte[] signature, HashAlgorithmName hashAlgorithm)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (offset < 0 || offset > data.Length)
			{
				throw new ArgumentOutOfRangeException("offset");
			}
			if (count < 0 || count > data.Length - offset)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			if (signature == null)
			{
				throw new ArgumentNullException("signature");
			}
			if (string.IsNullOrEmpty(hashAlgorithm.Name))
			{
				throw HashAlgorithmNameNullOrEmpty();
			}
			byte[] hash = HashData(data, offset, count, hashAlgorithm);
			return VerifyHash(hash, signature);
		}

		/// <summary>Verifies that a digital signature is valid by calculating the hash value of the specified stream using the specified hash algorithm and comparing it to the provided signature. </summary>
		/// <param name="data">The signed data. </param>
		/// <param name="signature">The signature data to be verified. </param>
		/// <param name="hashAlgorithm">The hash algorithm used to create the hash value of the data. </param>
		/// <returns>
		///     <see langword="true" /> if the signature is valid; otherwise, <see langword="false" />. </returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="data" /> is <see langword="null" />. -or-
		///         <paramref name="signature" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="hashAlgorithm" />.<see cref="P:System.Security.Cryptography.HashAlgorithmName.Name" /> is <see langword="null" /> or <see cref="F:System.String.Empty" />. </exception>
		public bool VerifyData(Stream data, byte[] signature, HashAlgorithmName hashAlgorithm)
		{
			if (data == null)
			{
				throw new ArgumentNullException("data");
			}
			if (signature == null)
			{
				throw new ArgumentNullException("signature");
			}
			if (string.IsNullOrEmpty(hashAlgorithm.Name))
			{
				throw HashAlgorithmNameNullOrEmpty();
			}
			byte[] hash = HashData(data, hashAlgorithm);
			return VerifyHash(hash, signature);
		}

		/// <summary>When overridden in a derived class, exports the named or explicit parameters for an elliptic curve. If the curve has a name, the <see cref="F:System.Security.Cryptography.ECParameters.Curve" /> field contains named curve parameters, otherwise it
		///   contains explicit parameters.</summary>
		/// <param name="includePrivateParameters">
		///       <see langword="true" />  to include private parameters; otherwise, <see langword="false" />.</param>
		/// <returns>The parameters representing the point on the curve for this key.</returns>
		/// <exception cref="T:System.NotSupportedException">A derived class must override this method.</exception>
		public virtual ECParameters ExportParameters(bool includePrivateParameters)
		{
			throw new NotSupportedException(SR.GetString("Method not supported. Derived class must override."));
		}

		/// <summary>When overridden in a derived class, exports the explicit parameters for an elliptic curve.</summary>
		/// <param name="includePrivateParameters">
		///       <see langword="true" />  to include private parameters; otherwise, <see langword="false" />.</param>
		/// <returns>The parameters representing the point on the curve for this key, using the explicit curve format.</returns>
		/// <exception cref="T:System.NotSupportedException">A derived class must override this method.</exception>
		public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters)
		{
			throw new NotSupportedException(SR.GetString("Method not supported. Derived class must override."));
		}

		/// <summary>When overridden in a derived class, imports the specified parameters.</summary>
		/// <param name="parameters">The curve parameters.</param>
		/// <exception cref="T:System.NotSupportedException">A derived class must override this method.</exception>
		public virtual void ImportParameters(ECParameters parameters)
		{
			throw new NotSupportedException(SR.GetString("Method not supported. Derived class must override."));
		}

		/// <summary>When overridden in a derived class, generates a new public/private key pair for the specified curve.</summary>
		/// <param name="curve">The curve to use.</param>
		/// <exception cref="T:System.NotSupportedException">A derived class must override this method.</exception>
		public virtual void GenerateKey(ECCurve curve)
		{
			throw new NotSupportedException(SR.GetString("Method not supported. Derived class must override."));
		}

		private static Exception DerivedClassMustOverride()
		{
			return new NotImplementedException(SR.GetString("Method not supported. Derived class must override."));
		}

		internal static Exception HashAlgorithmNameNullOrEmpty()
		{
			return new ArgumentException(SR.GetString("The hash algorithm name cannot be null or empty."), "hashAlgorithm");
		}

		protected virtual bool TryHashData(ReadOnlySpan<byte> data, Span<byte> destination, HashAlgorithmName hashAlgorithm, out int bytesWritten)
		{
			byte[] array = ArrayPool<byte>.Shared.Rent(data.Length);
			try
			{
				data.CopyTo(array);
				byte[] array2 = HashData(array, 0, data.Length, hashAlgorithm);
				if (array2.Length <= destination.Length)
				{
					new ReadOnlySpan<byte>(array2).CopyTo(destination);
					bytesWritten = array2.Length;
					return true;
				}
				bytesWritten = 0;
				return false;
			}
			finally
			{
				Array.Clear(array, 0, data.Length);
				ArrayPool<byte>.Shared.Return(array);
			}
		}

		public virtual bool TrySignHash(ReadOnlySpan<byte> hash, Span<byte> destination, out int bytesWritten)
		{
			byte[] array = SignHash(hash.ToArray());
			if (array.Length <= destination.Length)
			{
				new ReadOnlySpan<byte>(array).CopyTo(destination);
				bytesWritten = array.Length;
				return true;
			}
			bytesWritten = 0;
			return false;
		}

		public virtual bool VerifyHash(ReadOnlySpan<byte> hash, ReadOnlySpan<byte> signature)
		{
			return VerifyHash(hash.ToArray(), signature.ToArray());
		}

		public virtual bool TrySignData(ReadOnlySpan<byte> data, Span<byte> destination, HashAlgorithmName hashAlgorithm, out int bytesWritten)
		{
			if (string.IsNullOrEmpty(hashAlgorithm.Name))
			{
				throw new ArgumentException("The hash algorithm name cannot be null or empty.", "hashAlgorithm");
			}
			if (TryHashData(data, destination, hashAlgorithm, out var bytesWritten2) && TrySignHash(destination.Slice(0, bytesWritten2), destination, out bytesWritten))
			{
				return true;
			}
			bytesWritten = 0;
			return false;
		}

		public virtual bool VerifyData(ReadOnlySpan<byte> data, ReadOnlySpan<byte> signature, HashAlgorithmName hashAlgorithm)
		{
			if (string.IsNullOrEmpty(hashAlgorithm.Name))
			{
				throw new ArgumentException("The hash algorithm name cannot be null or empty.", "hashAlgorithm");
			}
			int num = 256;
			while (true)
			{
				int bytesWritten = 0;
				byte[] array = ArrayPool<byte>.Shared.Rent(num);
				try
				{
					if (TryHashData(data, array, hashAlgorithm, out bytesWritten))
					{
						return VerifyHash(new ReadOnlySpan<byte>(array, 0, bytesWritten), signature);
					}
				}
				finally
				{
					Array.Clear(array, 0, bytesWritten);
					ArrayPool<byte>.Shared.Return(array);
				}
				num = checked(num * 2);
			}
		}

		public virtual byte[] ExportECPrivateKey()
		{
			throw new PlatformNotSupportedException();
		}

		public virtual bool TryExportECPrivateKey(Span<byte> destination, out int bytesWritten)
		{
			throw new PlatformNotSupportedException();
		}

		public virtual void ImportECPrivateKey(ReadOnlySpan<byte> source, out int bytesRead)
		{
			throw new PlatformNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDsa" /> class.</summary>
		protected ECDsa()
		{
		}
	}
	/// <summary>Provides a Cryptography Next Generation (CNG) implementation of the Elliptic Curve Digital Signature Algorithm (ECDSA). </summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ECDsaCng : ECDsa
	{
		/// <summary>Gets or sets the hash algorithm to use when signing and verifying data.</summary>
		/// <returns>An object that specifies the hash algorithm.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value is <see langword="null" />.</exception>
		public CngAlgorithm HashAlgorithm { get; set; }

		/// <summary>Gets or sets the key to use when signing and verifying data.</summary>
		/// <returns>An object that specifies the key.</returns>
		public CngKey Key
		{
			get
			{
				throw new NotImplementedException();
			}
			private set
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDsaCng" /> class with a random key pair.</summary>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) classes are not supported on this system.</exception>
		public ECDsaCng()
			: this(521)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDsaCng" /> class with a random key pair, using the specified key size.</summary>
		/// <param name="keySize">The size of the key. Valid key sizes are 256, 384, and 521 bits.</param>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) classes are not supported on this system.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///         <paramref name="keySize" /> specifies an invalid length. </exception>
		public ECDsaCng(int keySize)
		{
			throw new NotImplementedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDsaCng" /> class by using the specified <see cref="T:System.Security.Cryptography.CngKey" /> object.</summary>
		/// <param name="key">The key that will be used as input to the cryptographic operations performed by the current object.</param>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="key" /> does not specify an Elliptic Curve Digital Signature Algorithm (ECDSA) group.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="key" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) classes are not supported on this system.</exception>
		[SecuritySafeCritical]
		public ECDsaCng(CngKey key)
		{
			throw new NotImplementedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDsaCng" /> class whose public/private key pair is generated over the specified curve.</summary>
		/// <param name="curve">The curve used to generate the public/private key pair. </param>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///         <paramref name="curve" /> does not validate.</exception>
		public ECDsaCng(ECCurve curve)
		{
			throw new NotImplementedException();
		}

		/// <summary>Generates a signature for the specified hash value.</summary>
		/// <param name="hash">The hash value of the data to be signed.</param>
		/// <returns>A digital signature for the specified hash value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="hash" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The key information that is associated with the instance does not have a private key.</exception>
		public override byte[] SignHash(byte[] hash)
		{
			throw new NotImplementedException();
		}

		/// <summary>Verifies the specified digital signature against a specified hash value.</summary>
		/// <param name="hash">The hash value of the data to be verified.</param>
		/// <param name="signature">The digital signature of the data to be verified against the hash value.</param>
		/// <returns>
		///     <see langword="true" /> if the signature is valid; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="hash" /> or <paramref name="signature" /> is <see langword="null" />.</exception>
		public override bool VerifyHash(byte[] hash, byte[] signature)
		{
			throw new NotImplementedException();
		}

		/// <summary>Deserializes the key information from an XML string by using the specified format.</summary>
		/// <param name="xml">The XML-based key information to be deserialized.</param>
		/// <param name="format">One of the enumeration values that specifies the format of the XML string. The only currently accepted format is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="xml" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="format" /> specifies an invalid format. The only accepted value is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		public void FromXmlString(string xml, ECKeyXmlFormat format)
		{
			throw new NotImplementedException();
		}

		/// <summary>Generates a signature for the specified data.</summary>
		/// <param name="data">The message data to be signed.</param>
		/// <returns>A digital signature for the specified data.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="data" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The key information that is associated with the instance does not have a private key.</exception>
		public byte[] SignData(byte[] data)
		{
			throw new NotImplementedException();
		}

		/// <summary>Generates a signature for the specified data stream, reading to the end of the stream.</summary>
		/// <param name="data">The data stream to be signed.</param>
		/// <returns>A digital signature for the specified data stream.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="data" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The key information that is associated with the instance does not have a private key.</exception>
		public byte[] SignData(Stream data)
		{
			throw new NotImplementedException();
		}

		/// <summary>Generates a digital signature for the specified length of data, beginning at the specified offset. </summary>
		/// <param name="data">The message data to be signed.</param>
		/// <param name="offset">The location in the string at which to start signing.</param>
		/// <param name="count">The length of the string, in characters, following <paramref name="offset" /> that will be signed.</param>
		/// <returns>A digital signature for the specified length of data.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="data" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="count" /> or <paramref name="offset" /> caused reading outside the bounds of the data string. </exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The key information that is associated with the instance does not have a private key.</exception>
		public byte[] SignData(byte[] data, int offset, int count)
		{
			throw new NotImplementedException();
		}

		/// <summary>Serializes the key information to an XML string by using the specified format.</summary>
		/// <param name="format">One of the enumeration values that specifies the format of the XML string. The only currently accepted format is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</param>
		/// <returns>A string object that contains the key information, serialized to an XML string according to the requested format.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="format" /> specifies an invalid format. The only accepted value is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		public string ToXmlString(ECKeyXmlFormat format)
		{
			throw new NotImplementedException();
		}

		/// <summary>Verifies the digital signature of the specified data. </summary>
		/// <param name="data">The data that was signed.</param>
		/// <param name="signature">The signature to be verified.</param>
		/// <returns>
		///     <see langword="true" /> if the signature is valid; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="data" /> or <paramref name="signature" /> is <see langword="null" />.</exception>
		public bool VerifyData(byte[] data, byte[] signature)
		{
			throw new NotImplementedException();
		}

		/// <summary>Verifies the digital signature of the specified data stream, reading to the end of the stream.</summary>
		/// <param name="data">The data stream that was signed.</param>
		/// <param name="signature">The signature to be verified.</param>
		/// <returns>
		///     <see langword="true" /> if the signature is valid; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="data" /> or <paramref name="signature" /> is <see langword="null" />.</exception>
		public bool VerifyData(Stream data, byte[] signature)
		{
			throw new NotImplementedException();
		}

		/// <summary>Verifies a signature for the specified length of data, beginning at the specified offset.</summary>
		/// <param name="data">The data that was signed.</param>
		/// <param name="offset">The location in the data at which the signed data begins.</param>
		/// <param name="count">The length of the data, in characters, following <paramref name="offset" /> that will be signed.</param>
		/// <param name="signature">The signature to be verified.</param>
		/// <returns>
		///     <see langword="true" /> if the signature is valid; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="offset" /> or <paramref name="count" /> is less then zero. -or-
		///         <paramref name="offset" /> or <paramref name="count" /> is larger than the length of the byte array passed in the <paramref name="data" /> parameter.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="data" /> or <paramref name="signature" /> is <see langword="null" />.</exception>
		public bool VerifyData(byte[] data, int offset, int count, byte[] signature)
		{
			throw new NotImplementedException();
		}
	}
	/// <summary>Defines XML serialization formats for elliptic curve keys.</summary>
	public enum ECKeyXmlFormat
	{
		/// <summary>An XML serialization format described in RFC 4050, "Using the Elliptic Curve Signature Algorithm (ECDSA) for XML Digital Signatures."</summary>
		Rfc4050
	}
	/// <summary>Specifies the key export policies for a key. </summary>
	[Flags]
	public enum CngExportPolicies
	{
		/// <summary>No export policies are established. Key export is allowed without restriction.</summary>
		None = 0,
		/// <summary>The private key can be exported multiple times.</summary>
		AllowExport = 1,
		/// <summary>The private key can be exported multiple times as plaintext.</summary>
		AllowPlaintextExport = 2,
		/// <summary>The private key can be exported one time for archiving purposes.</summary>
		AllowArchiving = 4,
		/// <summary>The private key can be exported one time as plaintext.</summary>
		AllowPlaintextArchiving = 8
	}
	/// <summary>Specifies options used for key creation.</summary>
	[Flags]
	public enum CngKeyCreationOptions
	{
		/// <summary>No key creation options are used.</summary>
		None = 0,
		/// <summary>A machine-wide key is created.</summary>
		MachineKey = 0x20,
		/// <summary>The existing key is overwritten during key creation.</summary>
		OverwriteExistingKey = 0x80
	}
	/// <summary>Specifies options for opening a key.</summary>
	[Flags]
	public enum CngKeyOpenOptions
	{
		/// <summary>No key open options are specified.</summary>
		None = 0,
		/// <summary>If the <see cref="F:System.Security.Cryptography.CngKeyOpenOptions.MachineKey" /> value is not specified, a user key is opened instead.</summary>
		UserKey = 0,
		/// <summary>A machine-wide key is opened.</summary>
		MachineKey = 0x20,
		/// <summary>UI prompting is suppressed.</summary>
		Silent = 0x40
	}
	[Flags]
	internal enum CngKeyTypes
	{
		None = 0,
		MachineKey = 0x20
	}
	/// <summary>Specifies the cryptographic operations that a Cryptography Next Generation (CNG) key may be used with. </summary>
	[Flags]
	public enum CngKeyUsages
	{
		/// <summary>No usage values are assigned to the key.</summary>
		None = 0,
		/// <summary>The key can be used for encryption and decryption.</summary>
		Decryption = 1,
		/// <summary>The key can be used for signing and verification.</summary>
		Signing = 2,
		/// <summary>The key can be used for secret agreement generation and key exchange.</summary>
		KeyAgreement = 4,
		/// <summary>The key can be used for all purposes.</summary>
		AllUsages = 0xFFFFFF
	}
	/// <summary>Specifies Cryptography Next Generation (CNG) key property options.</summary>
	[Flags]
	public enum CngPropertyOptions
	{
		/// <summary>The referenced property has no options.</summary>
		None = 0,
		/// <summary>The property is not specified by CNG. Use this option to avoid future name conflicts with CNG properties.</summary>
		CustomProperty = 0x40000000,
		/// <summary>The property should be persisted.</summary>
		Persist = int.MinValue
	}
	/// <summary>Specifies the protection level for the key in user interface (UI) prompting scenarios.</summary>
	[Flags]
	public enum CngUIProtectionLevels
	{
		/// <summary>No UI prompt is displayed when the key is accessed.</summary>
		None = 0,
		/// <summary>A UI prompt is displayed the first time the key is accessed in a process.</summary>
		ProtectKey = 1,
		/// <summary>A UI prompt is displayed every time the key is accessed.</summary>
		ForceHighProtection = 2
	}
	/// <summary>Provides a Cryptography Next Generation (CNG) implementation of the RSA algorithm. </summary>
	public sealed class RSACng : RSA
	{
		/// <summary>Gets the key that will be used by the <see cref="T:System.Security.Cryptography.RSACng" /> object for any cryptographic operation that it performs. </summary>
		/// <returns>The key used by the <see cref="T:System.Security.Cryptography.RSACng" /> object. </returns>
		public CngKey Key
		{
			[SecuritySafeCritical]
			get
			{
				throw new NotImplementedException();
			}
			private set
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.RSACng" /> class with a random 2,048-bit key pair. </summary>
		public RSACng()
			: this(2048)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.RSACng" /> class with a randomly generated key of the specified size. </summary>
		/// <param name="keySize">The size of the key to generate in bits. </param>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///         <paramref name="keySize" /> is not valid. </exception>
		public RSACng(int keySize)
		{
			throw new NotImplementedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.RSACng" /> class with the specified key. </summary>
		/// <param name="key">The key to use for RSA operations. </param>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="key" /> is not a valid RSA key. </exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="key" /> is <see langword="null" />. </exception>
		public RSACng(CngKey key)
		{
			throw new NotImplementedException();
		}

		/// <summary>Exports the key used by the RSA object into a <see cref="T:System.Security.Cryptography.RSAParameters" /> object. </summary>
		/// <param name="includePrivateParameters">
		///       <see langword="true" /> to include private parameters; otherwise, <see langword="false" />. </param>
		/// <returns>The key used by the RSA object. </returns>
		public override RSAParameters ExportParameters(bool includePrivateParameters)
		{
			throw new NotImplementedException();
		}

		/// <summary>Replaces the existing key that the current instance is working with by creating a new <see cref="T:System.Security.Cryptography.CngKey" /> for the parameters structure. </summary>
		/// <param name="parameters">The RSA parameters. </param>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="parameters" /> contains neither an exponent nor a modulus. </exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///         <paramref name="parameters" /> is not a valid RSA key. -or-
		///         <paramref name="parameters" /> is a full key pair and the default KSP is used. </exception>
		public override void ImportParameters(RSAParameters parameters)
		{
			throw new NotImplementedException();
		}
	}
	/// <summary>Provides a Cryptography Next Generation (CNG) implementation of the Advanced Encryption Standard (AES) algorithm.</summary>
	public sealed class AesCng : Aes
	{
		/// <summary>Gets or sets the key for the <see cref="T:System.Security.Cryptography.AesCng" /> algorithm.</summary>
		/// <returns>The key for the <see cref="T:System.Security.Cryptography.AesCng" /> algorithm.</returns>
		public override byte[] Key
		{
			get
			{
				throw new NotImplementedException();
			}
			set
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets or sets the size, in bits, of the secret key used by the <see cref="T:System.Security.Cryptography.AesCng" /> algorithm.</summary>
		/// <returns>The size, in bits, of the secret key used by the <see cref="T:System.Security.Cryptography.AesCng" /> algorithm.</returns>
		public override int KeySize
		{
			get
			{
				throw new NotImplementedException();
			}
			set
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.AesCng" /> class with an ephemeral key.</summary>
		public AesCng()
		{
			throw new NotImplementedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.AesCng" /> class with the specified key name, which represents an existing persisted AES key. </summary>
		/// <param name="keyName">The name of the key.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyName" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.PlatformNotSupportedException">
		///         Cryptography Next Generation (CNG) is not supported on this system.
		///  </exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.
		/// </exception>
		public AesCng(string keyName)
		{
			throw new NotImplementedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.AesCng" /> class with the specified key name, which represents an existing persisted AES key, and the specified key storage provider (KSP).</summary>
		/// <param name="keyName">The name of the key.</param>
		/// <param name="provider">The KSP that contains the key.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyName" /> is <see langword="null" />. -or-
		///         <paramref name="provider" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.PlatformNotSupportedException">
		///         Cryptography Next Generation (CNG) is not supported on this system.
		///  </exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.
		/// </exception>
		public AesCng(string keyName, CngProvider provider)
		{
			throw new NotImplementedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.AesCng" /> class with the specified key name, which represents an existing persisted AES key,  the specified key storage provider (KSP) and key open options.</summary>
		/// <param name="keyName">The name of the key.</param>
		/// <param name="provider">The KSP that contains the key.</param>
		/// <param name="openOptions">A bitwise combination of the enumeration values that specify options for opening the key, such as where the key is opened from (machine or user storage) and whether to suppress UI prompting.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyName" /> is <see langword="null" />. -or-
		///         <paramref name="provider" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.PlatformNotSupportedException">
		///         Cryptography Next Generation (CNG) is not supported on this system.
		///  </exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.
		/// </exception>
		public AesCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a symmetric AES decryptor object with the current key and initialization vector (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
		/// <returns>A symmetric AES decryptor object.</returns>
		public override ICryptoTransform CreateDecryptor()
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a symmetric AES decryptor object with the specified key and initialization vector (IV).</summary>
		/// <param name="rgbKey">The secret key to use for the AES algorithm. The key size must be 128, 192, or 256 bits.</param>
		/// <param name="rgbIV">The initialization vector to use for the AES algorithm.</param>
		/// <returns>A symmetric AES decryptor object.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="rgbKey" />  is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="rgbKey" />  is not a valid size for this algorithm.-or-<paramref name="rgbIV" /> size does not match the block size for this algorithm.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///   <paramref name="rgbKey" /> is a known weak key for this algorithm and cannot be used.-or-
		///         <paramref name="rgbIV" />  is <see langword="null" />.</exception>
		public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a symmetric AES encryptor object using the current key and initialization vector (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
		/// <returns>A symmetric AES encryptor object.</returns>
		public override ICryptoTransform CreateEncryptor()
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a symmetric AES encryptor object with the specified key and initialization vector (IV).</summary>
		/// <param name="rgbKey">The secret key to use for the AES algorithm. The key size must be 128, 192, or 256 bits.</param>
		/// <param name="rgbIV">The initialization vector to use for the AES algorithm.</param>
		/// <returns>A symmetric AES encryptor object.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="rgbKey" />  is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="rgbKey" />  is not a valid size for this algorithm.-or-<paramref name="rgbIV" /> size does not match the block size for this algorithm.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///   <paramref name="rgbKey" /> is a known weak key for this algorithm and cannot be used.-or-
		///         <paramref name="rgbIV" />  is <see langword="null" />.</exception>
		public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV)
		{
			return null;
		}

		protected override void Dispose(bool disposing)
		{
			throw new NotImplementedException();
		}

		/// <summary>Generates a random initialization vector (IV) to use for the AES algorithm.</summary>
		public override void GenerateIV()
		{
			throw new NotImplementedException();
		}

		/// <summary>Generates a random key to use for the AES algorithm.</summary>
		public override void GenerateKey()
		{
			throw new NotImplementedException();
		}
	}
	/// <summary>Performs symmetric encryption and decryption using the Cryptographic Application Programming Interfaces (CAPI) implementation of the Advanced Encryption Standard (AES) algorithm. </summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class AesCryptoServiceProvider : Aes
	{
		public override byte[] IV
		{
			get
			{
				return base.IV;
			}
			set
			{
				base.IV = value;
			}
		}

		/// <summary>Gets or sets the symmetric key that is used for encryption and decryption.</summary>
		/// <returns>The symmetric key that is used for encryption and decryption.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value for the key is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The size of the key is invalid.</exception>
		public override byte[] Key
		{
			get
			{
				return base.Key;
			}
			set
			{
				base.Key = value;
			}
		}

		/// <summary>Gets or sets the size, in bits, of the secret key. </summary>
		/// <returns>The size, in bits, of the key.</returns>
		public override int KeySize
		{
			get
			{
				return base.KeySize;
			}
			set
			{
				base.KeySize = value;
			}
		}

		public override int FeedbackSize
		{
			get
			{
				return base.FeedbackSize;
			}
			set
			{
				base.FeedbackSize = value;
			}
		}

		public override CipherMode Mode
		{
			get
			{
				return base.Mode;
			}
			set
			{
				if (value == CipherMode.CTS)
				{
					throw new CryptographicException("CTS is not supported");
				}
				base.Mode = value;
			}
		}

		public override PaddingMode Padding
		{
			get
			{
				return base.Padding;
			}
			set
			{
				base.Padding = value;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.AesCryptoServiceProvider" /> class. </summary>
		/// <exception cref="T:System.PlatformNotSupportedException">There is no supported key size for the current platform.</exception>
		public AesCryptoServiceProvider()
		{
			FeedbackSizeValue = 8;
		}

		/// <summary>Generates a random initialization vector (IV) to use for the algorithm.</summary>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The initialization vector (IV) could not be generated. </exception>
		public override void GenerateIV()
		{
			IVValue = KeyBuilder.IV(BlockSizeValue >> 3);
		}

		/// <summary>Generates a random key to use for the algorithm. </summary>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The key could not be generated.</exception>
		public override void GenerateKey()
		{
			KeyValue = KeyBuilder.Key(KeySizeValue >> 3);
		}

		/// <summary>Creates a symmetric AES decryptor object using the specified key and initialization vector (IV).</summary>
		/// <param name="key">The secret key to use for the symmetric algorithm.</param>
		/// <param name="iv">The initialization vector to use for the symmetric algorithm.</param>
		/// <returns>A symmetric AES decryptor object.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="key" /> or <paramref name="iv" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="key" /> is invalid.</exception>
		public override ICryptoTransform CreateDecryptor(byte[] key, byte[] iv)
		{
			if (Mode == CipherMode.CFB && FeedbackSize > 64)
			{
				throw new CryptographicException("CFB with Feedbaack > 64 bits");
			}
			return new AesTransform(this, encryption: false, key, iv);
		}

		/// <summary>Creates a symmetric encryptor object using the specified key and initialization vector (IV).</summary>
		/// <param name="key">The secret key to use for the symmetric algorithm.</param>
		/// <param name="iv">The initialization vector to use for the symmetric algorithm.</param>
		/// <returns>A symmetric AES encryptor object.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="key" /> or <paramref name="iv" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="key" /> is invalid.</exception>
		public override ICryptoTransform CreateEncryptor(byte[] key, byte[] iv)
		{
			if (Mode == CipherMode.CFB && FeedbackSize > 64)
			{
				throw new CryptographicException("CFB with Feedbaack > 64 bits");
			}
			return new AesTransform(this, encryption: true, key, iv);
		}

		/// <summary>Creates a symmetric AES decryptor object using the current key and initialization vector (IV).</summary>
		/// <returns>A symmetric AES decryptor object.</returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The current key is invalid or missing.</exception>
		public override ICryptoTransform CreateDecryptor()
		{
			return CreateDecryptor(Key, IV);
		}

		/// <summary>Creates a symmetric AES encryptor object using the current key and initialization vector (IV).</summary>
		/// <returns>A symmetric AES encryptor object.</returns>
		public override ICryptoTransform CreateEncryptor()
		{
			return CreateEncryptor(Key, IV);
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
		}
	}
	internal class AesTransform : SymmetricTransform
	{
		private uint[] expandedKey;

		private const int Nb = 4;

		private int Nk;

		private int Nr;

		private static readonly uint[] Rcon = new uint[30]
		{
			0u, 16777216u, 33554432u, 67108864u, 134217728u, 268435456u, 536870912u, 1073741824u, 2147483648u, 452984832u,
			905969664u, 1811939328u, 3623878656u, 2868903936u, 1291845632u, 2583691264u, 788529152u, 1577058304u, 3154116608u, 1660944384u,
			3321888768u, 2533359616u, 889192448u, 1778384896u, 3556769792u, 3003121664u, 2097152000u, 4194304000u, 4009754624u, 3305111552u
		};

		private static readonly byte[] SBox = new byte[256]
		{
			99, 124, 119, 123, 242, 107, 111, 197, 48, 1,
			103, 43, 254, 215, 171, 118, 202, 130, 201, 125,
			250, 89, 71, 240, 173, 212, 162, 175, 156, 164,
			114, 192, 183, 253, 147, 38, 54, 63, 247, 204,
			52, 165, 229, 241, 113, 216, 49, 21, 4, 199,
			35, 195, 24, 150, 5, 154, 7, 18, 128, 226,
			235, 39, 178, 117, 9, 131, 44, 26, 27, 110,
			90, 160, 82, 59, 214, 179, 41, 227, 47, 132,
			83, 209, 0, 237, 32, 252, 177, 91, 106, 203,
			190, 57, 74, 76, 88, 207, 208, 239, 170, 251,
			67, 77, 51, 133, 69, 249, 2, 127, 80, 60,
			159, 168, 81, 163, 64, 143, 146, 157, 56, 245,
			188, 182, 218, 33, 16, 255, 243, 210, 205, 12,
			19, 236, 95, 151, 68, 23, 196, 167, 126, 61,
			100, 93, 25, 115, 96, 129, 79, 220, 34, 42,
			144, 136, 70, 238, 184, 20, 222, 94, 11, 219,
			224, 50, 58, 10, 73, 6, 36, 92, 194, 211,
			172, 98, 145, 149, 228, 121, 231, 200, 55, 109,
			141, 213, 78, 169, 108, 86, 244, 234, 101, 122,
			174, 8, 186, 120, 37, 46, 28, 166, 180, 198,
			232, 221, 116, 31, 75, 189, 139, 138, 112, 62,
			181, 102, 72, 3, 246, 14, 97, 53, 87, 185,
			134, 193, 29, 158, 225, 248, 152, 17, 105, 217,
			142, 148, 155, 30, 135, 233, 206, 85, 40, 223,
			140, 161, 137, 13, 191, 230, 66, 104, 65, 153,
			45, 15, 176, 84, 187, 22
		};

		private static readonly byte[] iSBox = new byte[256]
		{
			82, 9, 106, 213, 48, 54, 165, 56, 191, 64,
			163, 158, 129, 243, 215, 251, 124, 227, 57, 130,
			155, 47, 255, 135, 52, 142, 67, 68, 196, 222,
			233, 203, 84, 123, 148, 50, 166, 194, 35, 61,
			238, 76, 149, 11, 66, 250, 195, 78, 8, 46,
			161, 102, 40, 217, 36, 178, 118, 91, 162, 73,
			109, 139, 209, 37, 114, 248, 246, 100, 134, 104,
			152, 22, 212, 164, 92, 204, 93, 101, 182, 146,
			108, 112, 72, 80, 253, 237, 185, 218, 94, 21,
			70, 87, 167, 141, 157, 132, 144, 216, 171, 0,
			140, 188, 211, 10, 247, 228, 88, 5, 184, 179,
			69, 6, 208, 44, 30, 143, 202, 63, 15, 2,
			193, 175, 189, 3, 1, 19, 138, 107, 58, 145,
			17, 65, 79, 103, 220, 234, 151, 242, 207, 206,
			240, 180, 230, 115, 150, 172, 116, 34, 231, 173,
			53, 133, 226, 249, 55, 232, 28, 117, 223, 110,
			71, 241, 26, 113, 29, 41, 197, 137, 111, 183,
			98, 14, 170, 24, 190, 27, 252, 86, 62, 75,
			198, 210, 121, 32, 154, 219, 192, 254, 120, 205,
			90, 244, 31, 221, 168, 51, 136, 7, 199, 49,
			177, 18, 16, 89, 39, 128, 236, 95, 96, 81,
			127, 169, 25, 181, 74, 13, 45, 229, 122, 159,
			147, 201, 156, 239, 160, 224, 59, 77, 174, 42,
			245, 176, 200, 235, 187, 60, 131, 83, 153, 97,
			23, 43, 4, 126, 186, 119, 214, 38, 225, 105,
			20, 99, 85, 33, 12, 125
		};

		private static readonly uint[] T0 = new uint[256]
		{
			3328402341u, 4168907908u, 4000806809u, 4135287693u, 4294111757u, 3597364157u, 3731845041u, 2445657428u, 1613770832u, 33620227u,
			3462883241u, 1445669757u, 3892248089u, 3050821474u, 1303096294u, 3967186586u, 2412431941u, 528646813u, 2311702848u, 4202528135u,
			4026202645u, 2992200171u, 2387036105u, 4226871307u, 1101901292u, 3017069671u, 1604494077u, 1169141738u, 597466303u, 1403299063u,
			3832705686u, 2613100635u, 1974974402u, 3791519004u, 1033081774u, 1277568618u, 1815492186u, 2118074177u, 4126668546u, 2211236943u,
			1748251740u, 1369810420u, 3521504564u, 4193382664u, 3799085459u, 2883115123u, 1647391059u, 706024767u, 134480908u, 2512897874u,
			1176707941u, 2646852446u, 806885416u, 932615841u, 168101135u, 798661301u, 235341577u, 605164086u, 461406363u, 3756188221u,
			3454790438u, 1311188841u, 2142417613u, 3933566367u, 302582043u, 495158174u, 1479289972u, 874125870u, 907746093u, 3698224818u,
			3025820398u, 1537253627u, 2756858614u, 1983593293u, 3084310113u, 2108928974u, 1378429307u, 3722699582u, 1580150641u, 327451799u,
			2790478837u, 3117535592u, 0u, 3253595436u, 1075847264u, 3825007647u, 2041688520u, 3059440621u, 3563743934u, 2378943302u,
			1740553945u, 1916352843u, 2487896798u, 2555137236u, 2958579944u, 2244988746u, 3151024235u, 3320835882u, 1336584933u, 3992714006u,
			2252555205u, 2588757463u, 1714631509u, 293963156u, 2319795663u, 3925473552u, 67240454u, 4269768577u, 2689618160u, 2017213508u,
			631218106u, 1269344483u, 2723238387u, 1571005438u, 2151694528u, 93294474u, 1066570413u, 563977660u, 1882732616u, 4059428100u,
			1673313503u, 2008463041u, 2950355573u, 1109467491u, 537923632u, 3858759450u, 4260623118u, 3218264685u, 2177748300u, 403442708u,
			638784309u, 3287084079u, 3193921505u, 899127202u, 2286175436u, 773265209u, 2479146071u, 1437050866u, 4236148354u, 2050833735u,
			3362022572u, 3126681063u, 840505643u, 3866325909u, 3227541664u, 427917720u, 2655997905u, 2749160575u, 1143087718u, 1412049534u,
			999329963u, 193497219u, 2353415882u, 3354324521u, 1807268051u, 672404540u, 2816401017u, 3160301282u, 369822493u, 2916866934u,
			3688947771u, 1681011286u, 1949973070u, 336202270u, 2454276571u, 201721354u, 1210328172u, 3093060836u, 2680341085u, 3184776046u,
			1135389935u, 3294782118u, 965841320u, 831886756u, 3554993207u, 4068047243u, 3588745010u, 2345191491u, 1849112409u, 3664604599u,
			26054028u, 2983581028u, 2622377682u, 1235855840u, 3630984372u, 2891339514u, 4092916743u, 3488279077u, 3395642799u, 4101667470u,
			1202630377u, 268961816u, 1874508501u, 4034427016u, 1243948399u, 1546530418u, 941366308u, 1470539505u, 1941222599u, 2546386513u,
			3421038627u, 2715671932u, 3899946140u, 1042226977u, 2521517021u, 1639824860u, 227249030u, 260737669u, 3765465232u, 2084453954u,
			1907733956u, 3429263018u, 2420656344u, 100860677u, 4160157185u, 470683154u, 3261161891u, 1781871967u, 2924959737u, 1773779408u,
			394692241u, 2579611992u, 974986535u, 664706745u, 3655459128u, 3958962195u, 731420851u, 571543859u, 3530123707u, 2849626480u,
			126783113u, 865375399u, 765172662u, 1008606754u, 361203602u, 3387549984u, 2278477385u, 2857719295u, 1344809080u, 2782912378u,
			59542671u, 1503764984u, 160008576u, 437062935u, 1707065306u, 3622233649u, 2218934982u, 3496503480u, 2185314755u, 697932208u,
			1512910199u, 504303377u, 2075177163u, 2824099068u, 1841019862u, 739644986u
		};

		private static readonly uint[] T1 = new uint[256]
		{
			2781242211u, 2230877308u, 2582542199u, 2381740923u, 234877682u, 3184946027u, 2984144751u, 1418839493u, 1348481072u, 50462977u,
			2848876391u, 2102799147u, 434634494u, 1656084439u, 3863849899u, 2599188086u, 1167051466u, 2636087938u, 1082771913u, 2281340285u,
			368048890u, 3954334041u, 3381544775u, 201060592u, 3963727277u, 1739838676u, 4250903202u, 3930435503u, 3206782108u, 4149453988u,
			2531553906u, 1536934080u, 3262494647u, 484572669u, 2923271059u, 1783375398u, 1517041206u, 1098792767u, 49674231u, 1334037708u,
			1550332980u, 4098991525u, 886171109u, 150598129u, 2481090929u, 1940642008u, 1398944049u, 1059722517u, 201851908u, 1385547719u,
			1699095331u, 1587397571u, 674240536u, 2704774806u, 252314885u, 3039795866u, 151914247u, 908333586u, 2602270848u, 1038082786u,
			651029483u, 1766729511u, 3447698098u, 2682942837u, 454166793u, 2652734339u, 1951935532u, 775166490u, 758520603u, 3000790638u,
			4004797018u, 4217086112u, 4137964114u, 1299594043u, 1639438038u, 3464344499u, 2068982057u, 1054729187u, 1901997871u, 2534638724u,
			4121318227u, 1757008337u, 0u, 750906861u, 1614815264u, 535035132u, 3363418545u, 3988151131u, 3201591914u, 1183697867u,
			3647454910u, 1265776953u, 3734260298u, 3566750796u, 3903871064u, 1250283471u, 1807470800u, 717615087u, 3847203498u, 384695291u,
			3313910595u, 3617213773u, 1432761139u, 2484176261u, 3481945413u, 283769337u, 100925954u, 2180939647u, 4037038160u, 1148730428u,
			3123027871u, 3813386408u, 4087501137u, 4267549603u, 3229630528u, 2315620239u, 2906624658u, 3156319645u, 1215313976u, 82966005u,
			3747855548u, 3245848246u, 1974459098u, 1665278241u, 807407632u, 451280895u, 251524083u, 1841287890u, 1283575245u, 337120268u,
			891687699u, 801369324u, 3787349855u, 2721421207u, 3431482436u, 959321879u, 1469301956u, 4065699751u, 2197585534u, 1199193405u,
			2898814052u, 3887750493u, 724703513u, 2514908019u, 2696962144u, 2551808385u, 3516813135u, 2141445340u, 1715741218u, 2119445034u,
			2872807568u, 2198571144u, 3398190662u, 700968686u, 3547052216u, 1009259540u, 2041044702u, 3803995742u, 487983883u, 1991105499u,
			1004265696u, 1449407026u, 1316239930u, 504629770u, 3683797321u, 168560134u, 1816667172u, 3837287516u, 1570751170u, 1857934291u,
			4014189740u, 2797888098u, 2822345105u, 2754712981u, 936633572u, 2347923833u, 852879335u, 1133234376u, 1500395319u, 3084545389u,
			2348912013u, 1689376213u, 3533459022u, 3762923945u, 3034082412u, 4205598294u, 133428468u, 634383082u, 2949277029u, 2398386810u,
			3913789102u, 403703816u, 3580869306u, 2297460856u, 1867130149u, 1918643758u, 607656988u, 4049053350u, 3346248884u, 1368901318u,
			600565992u, 2090982877u, 2632479860u, 557719327u, 3717614411u, 3697393085u, 2249034635u, 2232388234u, 2430627952u, 1115438654u,
			3295786421u, 2865522278u, 3633334344u, 84280067u, 33027830u, 303828494u, 2747425121u, 1600795957u, 4188952407u, 3496589753u,
			2434238086u, 1486471617u, 658119965u, 3106381470u, 953803233u, 334231800u, 3005978776u, 857870609u, 3151128937u, 1890179545u,
			2298973838u, 2805175444u, 3056442267u, 574365214u, 2450884487u, 550103529u, 1233637070u, 4289353045u, 2018519080u, 2057691103u,
			2399374476u, 4166623649u, 2148108681u, 387583245u, 3664101311u, 836232934u, 3330556482u, 3100665960u, 3280093505u, 2955516313u,
			2002398509u, 287182607u, 3413881008u, 4238890068u, 3597515707u, 975967766u
		};

		private static readonly uint[] T2 = new uint[256]
		{
			1671808611u, 2089089148u, 2006576759u, 2072901243u, 4061003762u, 1807603307u, 1873927791u, 3310653893u, 810573872u, 16974337u,
			1739181671u, 729634347u, 4263110654u, 3613570519u, 2883997099u, 1989864566u, 3393556426u, 2191335298u, 3376449993u, 2106063485u,
			4195741690u, 1508618841u, 1204391495u, 4027317232u, 2917941677u, 3563566036u, 2734514082u, 2951366063u, 2629772188u, 2767672228u,
			1922491506u, 3227229120u, 3082974647u, 4246528509u, 2477669779u, 644500518u, 911895606u, 1061256767u, 4144166391u, 3427763148u,
			878471220u, 2784252325u, 3845444069u, 4043897329u, 1905517169u, 3631459288u, 827548209u, 356461077u, 67897348u, 3344078279u,
			593839651u, 3277757891u, 405286936u, 2527147926u, 84871685u, 2595565466u, 118033927u, 305538066u, 2157648768u, 3795705826u,
			3945188843u, 661212711u, 2999812018u, 1973414517u, 152769033u, 2208177539u, 745822252u, 439235610u, 455947803u, 1857215598u,
			1525593178u, 2700827552u, 1391895634u, 994932283u, 3596728278u, 3016654259u, 695947817u, 3812548067u, 795958831u, 2224493444u,
			1408607827u, 3513301457u, 0u, 3979133421u, 543178784u, 4229948412u, 2982705585u, 1542305371u, 1790891114u, 3410398667u,
			3201918910u, 961245753u, 1256100938u, 1289001036u, 1491644504u, 3477767631u, 3496721360u, 4012557807u, 2867154858u, 4212583931u,
			1137018435u, 1305975373u, 861234739u, 2241073541u, 1171229253u, 4178635257u, 33948674u, 2139225727u, 1357946960u, 1011120188u,
			2679776671u, 2833468328u, 1374921297u, 2751356323u, 1086357568u, 2408187279u, 2460827538u, 2646352285u, 944271416u, 4110742005u,
			3168756668u, 3066132406u, 3665145818u, 560153121u, 271589392u, 4279952895u, 4077846003u, 3530407890u, 3444343245u, 202643468u,
			322250259u, 3962553324u, 1608629855u, 2543990167u, 1154254916u, 389623319u, 3294073796u, 2817676711u, 2122513534u, 1028094525u,
			1689045092u, 1575467613u, 422261273u, 1939203699u, 1621147744u, 2174228865u, 1339137615u, 3699352540u, 577127458u, 712922154u,
			2427141008u, 2290289544u, 1187679302u, 3995715566u, 3100863416u, 339486740u, 3732514782u, 1591917662u, 186455563u, 3681988059u,
			3762019296u, 844522546u, 978220090u, 169743370u, 1239126601u, 101321734u, 611076132u, 1558493276u, 3260915650u, 3547250131u,
			2901361580u, 1655096418u, 2443721105u, 2510565781u, 3828863972u, 2039214713u, 3878868455u, 3359869896u, 928607799u, 1840765549u,
			2374762893u, 3580146133u, 1322425422u, 2850048425u, 1823791212u, 1459268694u, 4094161908u, 3928346602u, 1706019429u, 2056189050u,
			2934523822u, 135794696u, 3134549946u, 2022240376u, 628050469u, 779246638u, 472135708u, 2800834470u, 3032970164u, 3327236038u,
			3894660072u, 3715932637u, 1956440180u, 522272287u, 1272813131u, 3185336765u, 2340818315u, 2323976074u, 1888542832u, 1044544574u,
			3049550261u, 1722469478u, 1222152264u, 50660867u, 4127324150u, 236067854u, 1638122081u, 895445557u, 1475980887u, 3117443513u,
			2257655686u, 3243809217u, 489110045u, 2662934430u, 3778599393u, 4162055160u, 2561878936u, 288563729u, 1773916777u, 3648039385u,
			2391345038u, 2493985684u, 2612407707u, 505560094u, 2274497927u, 3911240169u, 3460925390u, 1442818645u, 678973480u, 3749357023u,
			2358182796u, 2717407649u, 2306869641u, 219617805u, 3218761151u, 3862026214u, 1120306242u, 1756942440u, 1103331905u, 2578459033u,
			762796589u, 252780047u, 2966125488u, 1425844308u, 3151392187u, 372911126u
		};

		private static readonly uint[] T3 = new uint[256]
		{
			1667474886u, 2088535288u, 2004326894u, 2071694838u, 4075949567u, 1802223062u, 1869591006u, 3318043793u, 808472672u, 16843522u,
			1734846926u, 724270422u, 4278065639u, 3621216949u, 2880169549u, 1987484396u, 3402253711u, 2189597983u, 3385409673u, 2105378810u,
			4210693615u, 1499065266u, 1195886990u, 4042263547u, 2913856577u, 3570689971u, 2728590687u, 2947541573u, 2627518243u, 2762274643u,
			1920112356u, 3233831835u, 3082273397u, 4261223649u, 2475929149u, 640051788u, 909531756u, 1061110142u, 4160160501u, 3435941763u,
			875846760u, 2779116625u, 3857003729u, 4059105529u, 1903268834u, 3638064043u, 825316194u, 353713962u, 67374088u, 3351728789u,
			589522246u, 3284360861u, 404236336u, 2526454071u, 84217610u, 2593830191u, 117901582u, 303183396u, 2155911963u, 3806477791u,
			3958056653u, 656894286u, 2998062463u, 1970642922u, 151591698u, 2206440989u, 741110872u, 437923380u, 454765878u, 1852748508u,
			1515908788u, 2694904667u, 1381168804u, 993742198u, 3604373943u, 3014905469u, 690584402u, 3823320797u, 791638366u, 2223281939u,
			1398011302u, 3520161977u, 0u, 3991743681u, 538992704u, 4244381667u, 2981218425u, 1532751286u, 1785380564u, 3419096717u,
			3200178535u, 960056178u, 1246420628u, 1280103576u, 1482221744u, 3486468741u, 3503319995u, 4025428677u, 2863326543u, 4227536621u,
			1128514950u, 1296947098u, 859002214u, 2240123921u, 1162203018u, 4193849577u, 33687044u, 2139062782u, 1347481760u, 1010582648u,
			2678045221u, 2829640523u, 1364325282u, 2745433693u, 1077985408u, 2408548869u, 2459086143u, 2644360225u, 943212656u, 4126475505u,
			3166494563u, 3065430391u, 3671750063u, 555836226u, 269496352u, 4294908645u, 4092792573u, 3537006015u, 3452783745u, 202118168u,
			320025894u, 3974901699u, 1600119230u, 2543297077u, 1145359496u, 387397934u, 3301201811u, 2812801621u, 2122220284u, 1027426170u,
			1684319432u, 1566435258u, 421079858u, 1936954854u, 1616945344u, 2172753945u, 1330631070u, 3705438115u, 572679748u, 707427924u,
			2425400123u, 2290647819u, 1179044492u, 4008585671u, 3099120491u, 336870440u, 3739122087u, 1583276732u, 185277718u, 3688593069u,
			3772791771u, 842159716u, 976899700u, 168435220u, 1229577106u, 101059084u, 606366792u, 1549591736u, 3267517855u, 3553849021u,
			2897014595u, 1650632388u, 2442242105u, 2509612081u, 3840161747u, 2038008818u, 3890688725u, 3368567691u, 926374254u, 1835907034u,
			2374863873u, 3587531953u, 1313788572u, 2846482505u, 1819063512u, 1448540844u, 4109633523u, 3941213647u, 1701162954u, 2054852340u,
			2930698567u, 134748176u, 3132806511u, 2021165296u, 623210314u, 774795868u, 471606328u, 2795958615u, 3031746419u, 3334885783u,
			3907527627u, 3722280097u, 1953799400u, 522133822u, 1263263126u, 3183336545u, 2341176845u, 2324333839u, 1886425312u, 1044267644u,
			3048588401u, 1718004428u, 1212733584u, 50529542u, 4143317495u, 235803164u, 1633788866u, 892690282u, 1465383342u, 3115962473u,
			2256965911u, 3250673817u, 488449850u, 2661202215u, 3789633753u, 4177007595u, 2560144171u, 286339874u, 1768537042u, 3654906025u,
			2391705863u, 2492770099u, 2610673197u, 505291324u, 2273808917u, 3924369609u, 3469625735u, 1431699370u, 673740880u, 3755965093u,
			2358021891u, 2711746649u, 2307489801u, 218961690u, 3217021541u, 3873845719u, 1111672452u, 1751693520u, 1094828930u, 2576986153u,
			757954394u, 252645662u, 2964376443u, 1414855848u, 3149649517u, 370555436u
		};

		private static readonly uint[] iT0 = new uint[256]
		{
			1374988112u, 2118214995u, 437757123u, 975658646u, 1001089995u, 530400753u, 2902087851u, 1273168787u, 540080725u, 2910219766u,
			2295101073u, 4110568485u, 1340463100u, 3307916247u, 641025152u, 3043140495u, 3736164937u, 632953703u, 1172967064u, 1576976609u,
			3274667266u, 2169303058u, 2370213795u, 1809054150u, 59727847u, 361929877u, 3211623147u, 2505202138u, 3569255213u, 1484005843u,
			1239443753u, 2395588676u, 1975683434u, 4102977912u, 2572697195u, 666464733u, 3202437046u, 4035489047u, 3374361702u, 2110667444u,
			1675577880u, 3843699074u, 2538681184u, 1649639237u, 2976151520u, 3144396420u, 4269907996u, 4178062228u, 1883793496u, 2403728665u,
			2497604743u, 1383856311u, 2876494627u, 1917518562u, 3810496343u, 1716890410u, 3001755655u, 800440835u, 2261089178u, 3543599269u,
			807962610u, 599762354u, 33778362u, 3977675356u, 2328828971u, 2809771154u, 4077384432u, 1315562145u, 1708848333u, 101039829u,
			3509871135u, 3299278474u, 875451293u, 2733856160u, 92987698u, 2767645557u, 193195065u, 1080094634u, 1584504582u, 3178106961u,
			1042385657u, 2531067453u, 3711829422u, 1306967366u, 2438237621u, 1908694277u, 67556463u, 1615861247u, 429456164u, 3602770327u,
			2302690252u, 1742315127u, 2968011453u, 126454664u, 3877198648u, 2043211483u, 2709260871u, 2084704233u, 4169408201u, 0u,
			159417987u, 841739592u, 504459436u, 1817866830u, 4245618683u, 260388950u, 1034867998u, 908933415u, 168810852u, 1750902305u,
			2606453969u, 607530554u, 202008497u, 2472011535u, 3035535058u, 463180190u, 2160117071u, 1641816226u, 1517767529u, 470948374u,
			3801332234u, 3231722213u, 1008918595u, 303765277u, 235474187u, 4069246893u, 766945465u, 337553864u, 1475418501u, 2943682380u,
			4003061179u, 2743034109u, 4144047775u, 1551037884u, 1147550661u, 1543208500u, 2336434550u, 3408119516u, 3069049960u, 3102011747u,
			3610369226u, 1113818384u, 328671808u, 2227573024u, 2236228733u, 3535486456u, 2935566865u, 3341394285u, 496906059u, 3702665459u,
			226906860u, 2009195472u, 733156972u, 2842737049u, 294930682u, 1206477858u, 2835123396u, 2700099354u, 1451044056u, 573804783u,
			2269728455u, 3644379585u, 2362090238u, 2564033334u, 2801107407u, 2776292904u, 3669462566u, 1068351396u, 742039012u, 1350078989u,
			1784663195u, 1417561698u, 4136440770u, 2430122216u, 775550814u, 2193862645u, 2673705150u, 1775276924u, 1876241833u, 3475313331u,
			3366754619u, 270040487u, 3902563182u, 3678124923u, 3441850377u, 1851332852u, 3969562369u, 2203032232u, 3868552805u, 2868897406u,
			566021896u, 4011190502u, 3135740889u, 1248802510u, 3936291284u, 699432150u, 832877231u, 708780849u, 3332740144u, 899835584u,
			1951317047u, 4236429990u, 3767586992u, 866637845u, 4043610186u, 1106041591u, 2144161806u, 395441711u, 1984812685u, 1139781709u,
			3433712980u, 3835036895u, 2664543715u, 1282050075u, 3240894392u, 1181045119u, 2640243204u, 25965917u, 4203181171u, 4211818798u,
			3009879386u, 2463879762u, 3910161971u, 1842759443u, 2597806476u, 933301370u, 1509430414u, 3943906441u, 3467192302u, 3076639029u,
			3776767469u, 2051518780u, 2631065433u, 1441952575u, 404016761u, 1942435775u, 1408749034u, 1610459739u, 3745345300u, 2017778566u,
			3400528769u, 3110650942u, 941896748u, 3265478751u, 371049330u, 3168937228u, 675039627u, 4279080257u, 967311729u, 135050206u,
			3635733660u, 1683407248u, 2076935265u, 3576870512u, 1215061108u, 3501741890u
		};

		private static readonly uint[] iT1 = new uint[256]
		{
			1347548327u, 1400783205u, 3273267108u, 2520393566u, 3409685355u, 4045380933u, 2880240216u, 2471224067u, 1428173050u, 4138563181u,
			2441661558u, 636813900u, 4233094615u, 3620022987u, 2149987652u, 2411029155u, 1239331162u, 1730525723u, 2554718734u, 3781033664u,
			46346101u, 310463728u, 2743944855u, 3328955385u, 3875770207u, 2501218972u, 3955191162u, 3667219033u, 768917123u, 3545789473u,
			692707433u, 1150208456u, 1786102409u, 2029293177u, 1805211710u, 3710368113u, 3065962831u, 401639597u, 1724457132u, 3028143674u,
			409198410u, 2196052529u, 1620529459u, 1164071807u, 3769721975u, 2226875310u, 486441376u, 2499348523u, 1483753576u, 428819965u,
			2274680428u, 3075636216u, 598438867u, 3799141122u, 1474502543u, 711349675u, 129166120u, 53458370u, 2592523643u, 2782082824u,
			4063242375u, 2988687269u, 3120694122u, 1559041666u, 730517276u, 2460449204u, 4042459122u, 2706270690u, 3446004468u, 3573941694u,
			533804130u, 2328143614u, 2637442643u, 2695033685u, 839224033u, 1973745387u, 957055980u, 2856345839u, 106852767u, 1371368976u,
			4181598602u, 1033297158u, 2933734917u, 1179510461u, 3046200461u, 91341917u, 1862534868u, 4284502037u, 605657339u, 2547432937u,
			3431546947u, 2003294622u, 3182487618u, 2282195339u, 954669403u, 3682191598u, 1201765386u, 3917234703u, 3388507166u, 0u,
			2198438022u, 1211247597u, 2887651696u, 1315723890u, 4227665663u, 1443857720u, 507358933u, 657861945u, 1678381017u, 560487590u,
			3516619604u, 975451694u, 2970356327u, 261314535u, 3535072918u, 2652609425u, 1333838021u, 2724322336u, 1767536459u, 370938394u,
			182621114u, 3854606378u, 1128014560u, 487725847u, 185469197u, 2918353863u, 3106780840u, 3356761769u, 2237133081u, 1286567175u,
			3152976349u, 4255350624u, 2683765030u, 3160175349u, 3309594171u, 878443390u, 1988838185u, 3704300486u, 1756818940u, 1673061617u,
			3403100636u, 272786309u, 1075025698u, 545572369u, 2105887268u, 4174560061u, 296679730u, 1841768865u, 1260232239u, 4091327024u,
			3960309330u, 3497509347u, 1814803222u, 2578018489u, 4195456072u, 575138148u, 3299409036u, 446754879u, 3629546796u, 4011996048u,
			3347532110u, 3252238545u, 4270639778u, 915985419u, 3483825537u, 681933534u, 651868046u, 2755636671u, 3828103837u, 223377554u,
			2607439820u, 1649704518u, 3270937875u, 3901806776u, 1580087799u, 4118987695u, 3198115200u, 2087309459u, 2842678573u, 3016697106u,
			1003007129u, 2802849917u, 1860738147u, 2077965243u, 164439672u, 4100872472u, 32283319u, 2827177882u, 1709610350u, 2125135846u,
			136428751u, 3874428392u, 3652904859u, 3460984630u, 3572145929u, 3593056380u, 2939266226u, 824852259u, 818324884u, 3224740454u,
			930369212u, 2801566410u, 2967507152u, 355706840u, 1257309336u, 4148292826u, 243256656u, 790073846u, 2373340630u, 1296297904u,
			1422699085u, 3756299780u, 3818836405u, 457992840u, 3099667487u, 2135319889u, 77422314u, 1560382517u, 1945798516u, 788204353u,
			1521706781u, 1385356242u, 870912086u, 325965383u, 2358957921u, 2050466060u, 2388260884u, 2313884476u, 4006521127u, 901210569u,
			3990953189u, 1014646705u, 1503449823u, 1062597235u, 2031621326u, 3212035895u, 3931371469u, 1533017514u, 350174575u, 2256028891u,
			2177544179u, 1052338372u, 741876788u, 1606591296u, 1914052035u, 213705253u, 2334669897u, 1107234197u, 1899603969u, 3725069491u,
			2631447780u, 2422494913u, 1635502980u, 1893020342u, 1950903388u, 1120974935u
		};

		private static readonly uint[] iT2 = new uint[256]
		{
			2807058932u, 1699970625u, 2764249623u, 1586903591u, 1808481195u, 1173430173u, 1487645946u, 59984867u, 4199882800u, 1844882806u,
			1989249228u, 1277555970u, 3623636965u, 3419915562u, 1149249077u, 2744104290u, 1514790577u, 459744698u, 244860394u, 3235995134u,
			1963115311u, 4027744588u, 2544078150u, 4190530515u, 1608975247u, 2627016082u, 2062270317u, 1507497298u, 2200818878u, 567498868u,
			1764313568u, 3359936201u, 2305455554u, 2037970062u, 1047239000u, 1910319033u, 1337376481u, 2904027272u, 2892417312u, 984907214u,
			1243112415u, 830661914u, 861968209u, 2135253587u, 2011214180u, 2927934315u, 2686254721u, 731183368u, 1750626376u, 4246310725u,
			1820824798u, 4172763771u, 3542330227u, 48394827u, 2404901663u, 2871682645u, 671593195u, 3254988725u, 2073724613u, 145085239u,
			2280796200u, 2779915199u, 1790575107u, 2187128086u, 472615631u, 3029510009u, 4075877127u, 3802222185u, 4107101658u, 3201631749u,
			1646252340u, 4270507174u, 1402811438u, 1436590835u, 3778151818u, 3950355702u, 3963161475u, 4020912224u, 2667994737u, 273792366u,
			2331590177u, 104699613u, 95345982u, 3175501286u, 2377486676u, 1560637892u, 3564045318u, 369057872u, 4213447064u, 3919042237u,
			1137477952u, 2658625497u, 1119727848u, 2340947849u, 1530455833u, 4007360968u, 172466556u, 266959938u, 516552836u, 0u,
			2256734592u, 3980931627u, 1890328081u, 1917742170u, 4294704398u, 945164165u, 3575528878u, 958871085u, 3647212047u, 2787207260u,
			1423022939u, 775562294u, 1739656202u, 3876557655u, 2530391278u, 2443058075u, 3310321856u, 547512796u, 1265195639u, 437656594u,
			3121275539u, 719700128u, 3762502690u, 387781147u, 218828297u, 3350065803u, 2830708150u, 2848461854u, 428169201u, 122466165u,
			3720081049u, 1627235199u, 648017665u, 4122762354u, 1002783846u, 2117360635u, 695634755u, 3336358691u, 4234721005u, 4049844452u,
			3704280881u, 2232435299u, 574624663u, 287343814u, 612205898u, 1039717051u, 840019705u, 2708326185u, 793451934u, 821288114u,
			1391201670u, 3822090177u, 376187827u, 3113855344u, 1224348052u, 1679968233u, 2361698556u, 1058709744u, 752375421u, 2431590963u,
			1321699145u, 3519142200u, 2734591178u, 188127444u, 2177869557u, 3727205754u, 2384911031u, 3215212461u, 2648976442u, 2450346104u,
			3432737375u, 1180849278u, 331544205u, 3102249176u, 4150144569u, 2952102595u, 2159976285u, 2474404304u, 766078933u, 313773861u,
			2570832044u, 2108100632u, 1668212892u, 3145456443u, 2013908262u, 418672217u, 3070356634u, 2594734927u, 1852171925u, 3867060991u,
			3473416636u, 3907448597u, 2614737639u, 919489135u, 164948639u, 2094410160u, 2997825956u, 590424639u, 2486224549u, 1723872674u,
			3157750862u, 3399941250u, 3501252752u, 3625268135u, 2555048196u, 3673637356u, 1343127501u, 4130281361u, 3599595085u, 2957853679u,
			1297403050u, 81781910u, 3051593425u, 2283490410u, 532201772u, 1367295589u, 3926170974u, 895287692u, 1953757831u, 1093597963u,
			492483431u, 3528626907u, 1446242576u, 1192455638u, 1636604631u, 209336225u, 344873464u, 1015671571u, 669961897u, 3375740769u,
			3857572124u, 2973530695u, 3747192018u, 1933530610u, 3464042516u, 935293895u, 3454686199u, 2858115069u, 1863638845u, 3683022916u,
			4085369519u, 3292445032u, 875313188u, 1080017571u, 3279033885u, 621591778u, 1233856572u, 2504130317u, 24197544u, 3017672716u,
			3835484340u, 3247465558u, 2220981195u, 3060847922u, 1551124588u, 1463996600u
		};

		private static readonly uint[] iT3 = new uint[256]
		{
			4104605777u, 1097159550u, 396673818u, 660510266u, 2875968315u, 2638606623u, 4200115116u, 3808662347u, 821712160u, 1986918061u,
			3430322568u, 38544885u, 3856137295u, 718002117u, 893681702u, 1654886325u, 2975484382u, 3122358053u, 3926825029u, 4274053469u,
			796197571u, 1290801793u, 1184342925u, 3556361835u, 2405426947u, 2459735317u, 1836772287u, 1381620373u, 3196267988u, 1948373848u,
			3764988233u, 3385345166u, 3263785589u, 2390325492u, 1480485785u, 3111247143u, 3780097726u, 2293045232u, 548169417u, 3459953789u,
			3746175075u, 439452389u, 1362321559u, 1400849762u, 1685577905u, 1806599355u, 2174754046u, 137073913u, 1214797936u, 1174215055u,
			3731654548u, 2079897426u, 1943217067u, 1258480242u, 529487843u, 1437280870u, 3945269170u, 3049390895u, 3313212038u, 923313619u,
			679998000u, 3215307299u, 57326082u, 377642221u, 3474729866u, 2041877159u, 133361907u, 1776460110u, 3673476453u, 96392454u,
			878845905u, 2801699524u, 777231668u, 4082475170u, 2330014213u, 4142626212u, 2213296395u, 1626319424u, 1906247262u, 1846563261u,
			562755902u, 3708173718u, 1040559837u, 3871163981u, 1418573201u, 3294430577u, 114585348u, 1343618912u, 2566595609u, 3186202582u,
			1078185097u, 3651041127u, 3896688048u, 2307622919u, 425408743u, 3371096953u, 2081048481u, 1108339068u, 2216610296u, 0u,
			2156299017u, 736970802u, 292596766u, 1517440620u, 251657213u, 2235061775u, 2933202493u, 758720310u, 265905162u, 1554391400u,
			1532285339u, 908999204u, 174567692u, 1474760595u, 4002861748u, 2610011675u, 3234156416u, 3693126241u, 2001430874u, 303699484u,
			2478443234u, 2687165888u, 585122620u, 454499602u, 151849742u, 2345119218u, 3064510765u, 514443284u, 4044981591u, 1963412655u,
			2581445614u, 2137062819u, 19308535u, 1928707164u, 1715193156u, 4219352155u, 1126790795u, 600235211u, 3992742070u, 3841024952u,
			836553431u, 1669664834u, 2535604243u, 3323011204u, 1243905413u, 3141400786u, 4180808110u, 698445255u, 2653899549u, 2989552604u,
			2253581325u, 3252932727u, 3004591147u, 1891211689u, 2487810577u, 3915653703u, 4237083816u, 4030667424u, 2100090966u, 865136418u,
			1229899655u, 953270745u, 3399679628u, 3557504664u, 4118925222u, 2061379749u, 3079546586u, 2915017791u, 983426092u, 2022837584u,
			1607244650u, 2118541908u, 2366882550u, 3635996816u, 972512814u, 3283088770u, 1568718495u, 3499326569u, 3576539503u, 621982671u,
			2895723464u, 410887952u, 2623762152u, 1002142683u, 645401037u, 1494807662u, 2595684844u, 1335535747u, 2507040230u, 4293295786u,
			3167684641u, 367585007u, 3885750714u, 1865862730u, 2668221674u, 2960971305u, 2763173681u, 1059270954u, 2777952454u, 2724642869u,
			1320957812u, 2194319100u, 2429595872u, 2815956275u, 77089521u, 3973773121u, 3444575871u, 2448830231u, 1305906550u, 4021308739u,
			2857194700u, 2516901860u, 3518358430u, 1787304780u, 740276417u, 1699839814u, 1592394909u, 2352307457u, 2272556026u, 188821243u,
			1729977011u, 3687994002u, 274084841u, 3594982253u, 3613494426u, 2701949495u, 4162096729u, 322734571u, 2837966542u, 1640576439u,
			484830689u, 1202797690u, 3537852828u, 4067639125u, 349075736u, 3342319475u, 4157467219u, 4255800159u, 1030690015u, 1155237496u,
			2951971274u, 1757691577u, 607398968u, 2738905026u, 499347990u, 3794078908u, 1011452712u, 227885567u, 2818666809u, 213114376u,
			3034881240u, 1455525988u, 3414450555u, 850817237u, 1817998408u, 3092726480u
		};

		public AesTransform(Aes algo, bool encryption, byte[] key, byte[] iv)
			: base(algo, encryption, iv)
		{
			if (key == null)
			{
				throw new CryptographicException("key is null");
			}
			if (iv != null && iv.Length != algo.BlockSize >> 3)
			{
				throw new CryptographicException(Locale.GetText("IV length is invalid ({0} bytes), it should be {1} bytes long.", iv.Length, algo.BlockSize >> 3));
			}
			int num = key.Length;
			if (num != 16 && num != 24 && num != 32)
			{
				throw new CryptographicException(Locale.GetText("Key is too small ({0} bytes), it should be {1}, {2} or {3} bytes long.", num, 16, 24, 32));
			}
			num <<= 3;
			Nk = num >> 5;
			if (Nk == 8)
			{
				Nr = 14;
			}
			else if (Nk == 6)
			{
				Nr = 12;
			}
			else
			{
				Nr = 10;
			}
			int num2 = 4 * (Nr + 1);
			uint[] array = new uint[num2];
			int num3 = 0;
			for (int i = 0; i < Nk; i++)
			{
				uint num4 = (uint)(key[num3++] << 24);
				num4 |= (uint)(key[num3++] << 16);
				num4 |= (uint)(key[num3++] << 8);
				num4 |= key[num3++];
				array[i] = num4;
			}
			for (int j = Nk; j < num2; j++)
			{
				uint num5 = array[j - 1];
				if (j % Nk == 0)
				{
					uint a = (num5 << 8) | ((num5 >> 24) & 0xFF);
					num5 = SubByte(a) ^ Rcon[j / Nk];
				}
				else if (Nk > 6 && j % Nk == 4)
				{
					num5 = SubByte(num5);
				}
				array[j] = array[j - Nk] ^ num5;
			}
			if (!encryption && (algo.Mode == CipherMode.ECB || algo.Mode == CipherMode.CBC))
			{
				int num6 = 0;
				int num7 = num2 - 4;
				while (num6 < num7)
				{
					for (int k = 0; k < 4; k++)
					{
						uint num8 = array[num6 + k];
						array[num6 + k] = array[num7 + k];
						array[num7 + k] = num8;
					}
					num6 += 4;
					num7 -= 4;
				}
				for (int l = 4; l < array.Length - 4; l++)
				{
					array[l] = iT0[SBox[array[l] >> 24]] ^ iT1[SBox[(byte)(array[l] >> 16)]] ^ iT2[SBox[(byte)(array[l] >> 8)]] ^ iT3[SBox[(byte)array[l]]];
				}
			}
			expandedKey = array;
		}

		public void Clear()
		{
			Dispose(disposing: true);
		}

		protected override void ECB(byte[] input, byte[] output)
		{
			if (encrypt)
			{
				Encrypt128(input, output, expandedKey);
			}
			else
			{
				Decrypt128(input, output, expandedKey);
			}
		}

		private uint SubByte(uint a)
		{
			uint num = 0xFF & a;
			byte num2 = SBox[num];
			num = 0xFF & (a >> 8);
			int num3 = num2 | (SBox[num] << 8);
			num = 0xFF & (a >> 16);
			int num4 = num3 | (SBox[num] << 16);
			num = 0xFF & (a >> 24);
			return (uint)(num4 | (SBox[num] << 24));
		}

		private void Encrypt128(byte[] indata, byte[] outdata, uint[] ekey)
		{
			int num = 40;
			uint num2 = (uint)((indata[0] << 24) | (indata[1] << 16) | (indata[2] << 8) | indata[3]) ^ ekey[0];
			uint num3 = (uint)((indata[4] << 24) | (indata[5] << 16) | (indata[6] << 8) | indata[7]) ^ ekey[1];
			uint num4 = (uint)((indata[8] << 24) | (indata[9] << 16) | (indata[10] << 8) | indata[11]) ^ ekey[2];
			uint num5 = (uint)((indata[12] << 24) | (indata[13] << 16) | (indata[14] << 8) | indata[15]) ^ ekey[3];
			uint num6 = T0[num2 >> 24] ^ T1[(byte)(num3 >> 16)] ^ T2[(byte)(num4 >> 8)] ^ T3[(byte)num5] ^ ekey[4];
			uint num7 = T0[num3 >> 24] ^ T1[(byte)(num4 >> 16)] ^ T2[(byte)(num5 >> 8)] ^ T3[(byte)num2] ^ ekey[5];
			uint num8 = T0[num4 >> 24] ^ T1[(byte)(num5 >> 16)] ^ T2[(byte)(num2 >> 8)] ^ T3[(byte)num3] ^ ekey[6];
			uint num9 = T0[num5 >> 24] ^ T1[(byte)(num2 >> 16)] ^ T2[(byte)(num3 >> 8)] ^ T3[(byte)num4] ^ ekey[7];
			num2 = T0[num6 >> 24] ^ T1[(byte)(num7 >> 16)] ^ T2[(byte)(num8 >> 8)] ^ T3[(byte)num9] ^ ekey[8];
			num3 = T0[num7 >> 24] ^ T1[(byte)(num8 >> 16)] ^ T2[(byte)(num9 >> 8)] ^ T3[(byte)num6] ^ ekey[9];
			num4 = T0[num8 >> 24] ^ T1[(byte)(num9 >> 16)] ^ T2[(byte)(num6 >> 8)] ^ T3[(byte)num7] ^ ekey[10];
			num5 = T0[num9 >> 24] ^ T1[(byte)(num6 >> 16)] ^ T2[(byte)(num7 >> 8)] ^ T3[(byte)num8] ^ ekey[11];
			num6 = T0[num2 >> 24] ^ T1[(byte)(num3 >> 16)] ^ T2[(byte)(num4 >> 8)] ^ T3[(byte)num5] ^ ekey[12];
			num7 = T0[num3 >> 24] ^ T1[(byte)(num4 >> 16)] ^ T2[(byte)(num5 >> 8)] ^ T3[(byte)num2] ^ ekey[13];
			num8 = T0[num4 >> 24] ^ T1[(byte)(num5 >> 16)] ^ T2[(byte)(num2 >> 8)] ^ T3[(byte)num3] ^ ekey[14];
			num9 = T0[num5 >> 24] ^ T1[(byte)(num2 >> 16)] ^ T2[(byte)(num3 >> 8)] ^ T3[(byte)num4] ^ ekey[15];
			num2 = T0[num6 >> 24] ^ T1[(byte)(num7 >> 16)] ^ T2[(byte)(num8 >> 8)] ^ T3[(byte)num9] ^ ekey[16];
			num3 = T0[num7 >> 24] ^ T1[(byte)(num8 >> 16)] ^ T2[(byte)(num9 >> 8)] ^ T3[(byte)num6] ^ ekey[17];
			num4 = T0[num8 >> 24] ^ T1[(byte)(num9 >> 16)] ^ T2[(byte)(num6 >> 8)] ^ T3[(byte)num7] ^ ekey[18];
			num5 = T0[num9 >> 24] ^ T1[(byte)(num6 >> 16)] ^ T2[(byte)(num7 >> 8)] ^ T3[(byte)num8] ^ ekey[19];
			num6 = T0[num2 >> 24] ^ T1[(byte)(num3 >> 16)] ^ T2[(byte)(num4 >> 8)] ^ T3[(byte)num5] ^ ekey[20];
			num7 = T0[num3 >> 24] ^ T1[(byte)(num4 >> 16)] ^ T2[(byte)(num5 >> 8)] ^ T3[(byte)num2] ^ ekey[21];
			num8 = T0[num4 >> 24] ^ T1[(byte)(num5 >> 16)] ^ T2[(byte)(num2 >> 8)] ^ T3[(byte)num3] ^ ekey[22];
			num9 = T0[num5 >> 24] ^ T1[(byte)(num2 >> 16)] ^ T2[(byte)(num3 >> 8)] ^ T3[(byte)num4] ^ ekey[23];
			num2 = T0[num6 >> 24] ^ T1[(byte)(num7 >> 16)] ^ T2[(byte)(num8 >> 8)] ^ T3[(byte)num9] ^ ekey[24];
			num3 = T0[num7 >> 24] ^ T1[(byte)(num8 >> 16)] ^ T2[(byte)(num9 >> 8)] ^ T3[(byte)num6] ^ ekey[25];
			num4 = T0[num8 >> 24] ^ T1[(byte)(num9 >> 16)] ^ T2[(byte)(num6 >> 8)] ^ T3[(byte)num7] ^ ekey[26];
			num5 = T0[num9 >> 24] ^ T1[(byte)(num6 >> 16)] ^ T2[(byte)(num7 >> 8)] ^ T3[(byte)num8] ^ ekey[27];
			num6 = T0[num2 >> 24] ^ T1[(byte)(num3 >> 16)] ^ T2[(byte)(num4 >> 8)] ^ T3[(byte)num5] ^ ekey[28];
			num7 = T0[num3 >> 24] ^ T1[(byte)(num4 >> 16)] ^ T2[(byte)(num5 >> 8)] ^ T3[(byte)num2] ^ ekey[29];
			num8 = T0[num4 >> 24] ^ T1[(byte)(num5 >> 16)] ^ T2[(byte)(num2 >> 8)] ^ T3[(byte)num3] ^ ekey[30];
			num9 = T0[num5 >> 24] ^ T1[(byte)(num2 >> 16)] ^ T2[(byte)(num3 >> 8)] ^ T3[(byte)num4] ^ ekey[31];
			num2 = T0[num6 >> 24] ^ T1[(byte)(num7 >> 16)] ^ T2[(byte)(num8 >> 8)] ^ T3[(byte)num9] ^ ekey[32];
			num3 = T0[num7 >> 24] ^ T1[(byte)(num8 >> 16)] ^ T2[(byte)(num9 >> 8)] ^ T3[(byte)num6] ^ ekey[33];
			num4 = T0[num8 >> 24] ^ T1[(byte)(num9 >> 16)] ^ T2[(byte)(num6 >> 8)] ^ T3[(byte)num7] ^ ekey[34];
			num5 = T0[num9 >> 24] ^ T1[(byte)(num6 >> 16)] ^ T2[(byte)(num7 >> 8)] ^ T3[(byte)num8] ^ ekey[35];
			num6 = T0[num2 >> 24] ^ T1[(byte)(num3 >> 16)] ^ T2[(byte)(num4 >> 8)] ^ T3[(byte)num5] ^ ekey[36];
			num7 = T0[num3 >> 24] ^ T1[(byte)(num4 >> 16)] ^ T2[(byte)(num5 >> 8)] ^ T3[(byte)num2] ^ ekey[37];
			num8 = T0[num4 >> 24] ^ T1[(byte)(num5 >> 16)] ^ T2[(byte)(num2 >> 8)] ^ T3[(byte)num3] ^ ekey[38];
			num9 = T0[num5 >> 24] ^ T1[(byte)(num2 >> 16)] ^ T2[(byte)(num3 >> 8)] ^ T3[(byte)num4] ^ ekey[39];
			if (Nr > 10)
			{
				num2 = T0[num6 >> 24] ^ T1[(byte)(num7 >> 16)] ^ T2[(byte)(num8 >> 8)] ^ T3[(byte)num9] ^ ekey[40];
				num3 = T0[num7 >> 24] ^ T1[(byte)(num8 >> 16)] ^ T2[(byte)(num9 >> 8)] ^ T3[(byte)num6] ^ ekey[41];
				num4 = T0[num8 >> 24] ^ T1[(byte)(num9 >> 16)] ^ T2[(byte)(num6 >> 8)] ^ T3[(byte)num7] ^ ekey[42];
				num5 = T0[num9 >> 24] ^ T1[(byte)(num6 >> 16)] ^ T2[(byte)(num7 >> 8)] ^ T3[(byte)num8] ^ ekey[43];
				num6 = T0[num2 >> 24] ^ T1[(byte)(num3 >> 16)] ^ T2[(byte)(num4 >> 8)] ^ T3[(byte)num5] ^ ekey[44];
				num7 = T0[num3 >> 24] ^ T1[(byte)(num4 >> 16)] ^ T2[(byte)(num5 >> 8)] ^ T3[(byte)num2] ^ ekey[45];
				num8 = T0[num4 >> 24] ^ T1[(byte)(num5 >> 16)] ^ T2[(byte)(num2 >> 8)] ^ T3[(byte)num3] ^ ekey[46];
				num9 = T0[num5 >> 24] ^ T1[(byte)(num2 >> 16)] ^ T2[(byte)(num3 >> 8)] ^ T3[(byte)num4] ^ ekey[47];
				num = 48;
				if (Nr > 12)
				{
					num2 = T0[num6 >> 24] ^ T1[(byte)(num7 >> 16)] ^ T2[(byte)(num8 >> 8)] ^ T3[(byte)num9] ^ ekey[48];
					num3 = T0[num7 >> 24] ^ T1[(byte)(num8 >> 16)] ^ T2[(byte)(num9 >> 8)] ^ T3[(byte)num6] ^ ekey[49];
					num4 = T0[num8 >> 24] ^ T1[(byte)(num9 >> 16)] ^ T2[(byte)(num6 >> 8)] ^ T3[(byte)num7] ^ ekey[50];
					num5 = T0[num9 >> 24] ^ T1[(byte)(num6 >> 16)] ^ T2[(byte)(num7 >> 8)] ^ T3[(byte)num8] ^ ekey[51];
					num6 = T0[num2 >> 24] ^ T1[(byte)(num3 >> 16)] ^ T2[(byte)(num4 >> 8)] ^ T3[(byte)num5] ^ ekey[52];
					num7 = T0[num3 >> 24] ^ T1[(byte)(num4 >> 16)] ^ T2[(byte)(num5 >> 8)] ^ T3[(byte)num2] ^ ekey[53];
					num8 = T0[num4 >> 24] ^ T1[(byte)(num5 >> 16)] ^ T2[(byte)(num2 >> 8)] ^ T3[(byte)num3] ^ ekey[54];
					num9 = T0[num5 >> 24] ^ T1[(byte)(num2 >> 16)] ^ T2[(byte)(num3 >> 8)] ^ T3[(byte)num4] ^ ekey[55];
					num = 56;
				}
			}
			outdata[0] = (byte)(SBox[num6 >> 24] ^ (byte)(ekey[num] >> 24));
			outdata[1] = (byte)(SBox[(byte)(num7 >> 16)] ^ (byte)(ekey[num] >> 16));
			outdata[2] = (byte)(SBox[(byte)(num8 >> 8)] ^ (byte)(ekey[num] >> 8));
			outdata[3] = (byte)(SBox[(byte)num9] ^ (byte)ekey[num++]);
			outdata[4] = (byte)(SBox[num7 >> 24] ^ (byte)(ekey[num] >> 24));
			outdata[5] = (byte)(SBox[(byte)(num8 >> 16)] ^ (byte)(ekey[num] >> 16));
			outdata[6] = (byte)(SBox[(byte)(num9 >> 8)] ^ (byte)(ekey[num] >> 8));
			outdata[7] = (byte)(SBox[(byte)num6] ^ (byte)ekey[num++]);
			outdata[8] = (byte)(SBox[num8 >> 24] ^ (byte)(ekey[num] >> 24));
			outdata[9] = (byte)(SBox[(byte)(num9 >> 16)] ^ (byte)(ekey[num] >> 16));
			outdata[10] = (byte)(SBox[(byte)(num6 >> 8)] ^ (byte)(ekey[num] >> 8));
			outdata[11] = (byte)(SBox[(byte)num7] ^ (byte)ekey[num++]);
			outdata[12] = (byte)(SBox[num9 >> 24] ^ (byte)(ekey[num] >> 24));
			outdata[13] = (byte)(SBox[(byte)(num6 >> 16)] ^ (byte)(ekey[num] >> 16));
			outdata[14] = (byte)(SBox[(byte)(num7 >> 8)] ^ (byte)(ekey[num] >> 8));
			outdata[15] = (byte)(SBox[(byte)num8] ^ (byte)ekey[num++]);
		}

		private void Decrypt128(byte[] indata, byte[] outdata, uint[] ekey)
		{
			int num = 40;
			uint num2 = (uint)((indata[0] << 24) | (indata[1] << 16) | (indata[2] << 8) | indata[3]) ^ ekey[0];
			uint num3 = (uint)((indata[4] << 24) | (indata[5] << 16) | (indata[6] << 8) | indata[7]) ^ ekey[1];
			uint num4 = (uint)((indata[8] << 24) | (indata[9] << 16) | (indata[10] << 8) | indata[11]) ^ ekey[2];
			uint num5 = (uint)((indata[12] << 24) | (indata[13] << 16) | (indata[14] << 8) | indata[15]) ^ ekey[3];
			uint num6 = iT0[num2 >> 24] ^ iT1[(byte)(num5 >> 16)] ^ iT2[(byte)(num4 >> 8)] ^ iT3[(byte)num3] ^ ekey[4];
			uint num7 = iT0[num3 >> 24] ^ iT1[(byte)(num2 >> 16)] ^ iT2[(byte)(num5 >> 8)] ^ iT3[(byte)num4] ^ ekey[5];
			uint num8 = iT0[num4 >> 24] ^ iT1[(byte)(num3 >> 16)] ^ iT2[(byte)(num2 >> 8)] ^ iT3[(byte)num5] ^ ekey[6];
			uint num9 = iT0[num5 >> 24] ^ iT1[(byte)(num4 >> 16)] ^ iT2[(byte)(num3 >> 8)] ^ iT3[(byte)num2] ^ ekey[7];
			num2 = iT0[num6 >> 24] ^ iT1[(byte)(num9 >> 16)] ^ iT2[(byte)(num8 >> 8)] ^ iT3[(byte)num7] ^ ekey[8];
			num3 = iT0[num7 >> 24] ^ iT1[(byte)(num6 >> 16)] ^ iT2[(byte)(num9 >> 8)] ^ iT3[(byte)num8] ^ ekey[9];
			num4 = iT0[num8 >> 24] ^ iT1[(byte)(num7 >> 16)] ^ iT2[(byte)(num6 >> 8)] ^ iT3[(byte)num9] ^ ekey[10];
			num5 = iT0[num9 >> 24] ^ iT1[(byte)(num8 >> 16)] ^ iT2[(byte)(num7 >> 8)] ^ iT3[(byte)num6] ^ ekey[11];
			num6 = iT0[num2 >> 24] ^ iT1[(byte)(num5 >> 16)] ^ iT2[(byte)(num4 >> 8)] ^ iT3[(byte)num3] ^ ekey[12];
			num7 = iT0[num3 >> 24] ^ iT1[(byte)(num2 >> 16)] ^ iT2[(byte)(num5 >> 8)] ^ iT3[(byte)num4] ^ ekey[13];
			num8 = iT0[num4 >> 24] ^ iT1[(byte)(num3 >> 16)] ^ iT2[(byte)(num2 >> 8)] ^ iT3[(byte)num5] ^ ekey[14];
			num9 = iT0[num5 >> 24] ^ iT1[(byte)(num4 >> 16)] ^ iT2[(byte)(num3 >> 8)] ^ iT3[(byte)num2] ^ ekey[15];
			num2 = iT0[num6 >> 24] ^ iT1[(byte)(num9 >> 16)] ^ iT2[(byte)(num8 >> 8)] ^ iT3[(byte)num7] ^ ekey[16];
			num3 = iT0[num7 >> 24] ^ iT1[(byte)(num6 >> 16)] ^ iT2[(byte)(num9 >> 8)] ^ iT3[(byte)num8] ^ ekey[17];
			num4 = iT0[num8 >> 24] ^ iT1[(byte)(num7 >> 16)] ^ iT2[(byte)(num6 >> 8)] ^ iT3[(byte)num9] ^ ekey[18];
			num5 = iT0[num9 >> 24] ^ iT1[(byte)(num8 >> 16)] ^ iT2[(byte)(num7 >> 8)] ^ iT3[(byte)num6] ^ ekey[19];
			num6 = iT0[num2 >> 24] ^ iT1[(byte)(num5 >> 16)] ^ iT2[(byte)(num4 >> 8)] ^ iT3[(byte)num3] ^ ekey[20];
			num7 = iT0[num3 >> 24] ^ iT1[(byte)(num2 >> 16)] ^ iT2[(byte)(num5 >> 8)] ^ iT3[(byte)num4] ^ ekey[21];
			num8 = iT0[num4 >> 24] ^ iT1[(byte)(num3 >> 16)] ^ iT2[(byte)(num2 >> 8)] ^ iT3[(byte)num5] ^ ekey[22];
			num9 = iT0[num5 >> 24] ^ iT1[(byte)(num4 >> 16)] ^ iT2[(byte)(num3 >> 8)] ^ iT3[(byte)num2] ^ ekey[23];
			num2 = iT0[num6 >> 24] ^ iT1[(byte)(num9 >> 16)] ^ iT2[(byte)(num8 >> 8)] ^ iT3[(byte)num7] ^ ekey[24];
			num3 = iT0[num7 >> 24] ^ iT1[(byte)(num6 >> 16)] ^ iT2[(byte)(num9 >> 8)] ^ iT3[(byte)num8] ^ ekey[25];
			num4 = iT0[num8 >> 24] ^ iT1[(byte)(num7 >> 16)] ^ iT2[(byte)(num6 >> 8)] ^ iT3[(byte)num9] ^ ekey[26];
			num5 = iT0[num9 >> 24] ^ iT1[(byte)(num8 >> 16)] ^ iT2[(byte)(num7 >> 8)] ^ iT3[(byte)num6] ^ ekey[27];
			num6 = iT0[num2 >> 24] ^ iT1[(byte)(num5 >> 16)] ^ iT2[(byte)(num4 >> 8)] ^ iT3[(byte)num3] ^ ekey[28];
			num7 = iT0[num3 >> 24] ^ iT1[(byte)(num2 >> 16)] ^ iT2[(byte)(num5 >> 8)] ^ iT3[(byte)num4] ^ ekey[29];
			num8 = iT0[num4 >> 24] ^ iT1[(byte)(num3 >> 16)] ^ iT2[(byte)(num2 >> 8)] ^ iT3[(byte)num5] ^ ekey[30];
			num9 = iT0[num5 >> 24] ^ iT1[(byte)(num4 >> 16)] ^ iT2[(byte)(num3 >> 8)] ^ iT3[(byte)num2] ^ ekey[31];
			num2 = iT0[num6 >> 24] ^ iT1[(byte)(num9 >> 16)] ^ iT2[(byte)(num8 >> 8)] ^ iT3[(byte)num7] ^ ekey[32];
			num3 = iT0[num7 >> 24] ^ iT1[(byte)(num6 >> 16)] ^ iT2[(byte)(num9 >> 8)] ^ iT3[(byte)num8] ^ ekey[33];
			num4 = iT0[num8 >> 24] ^ iT1[(byte)(num7 >> 16)] ^ iT2[(byte)(num6 >> 8)] ^ iT3[(byte)num9] ^ ekey[34];
			num5 = iT0[num9 >> 24] ^ iT1[(byte)(num8 >> 16)] ^ iT2[(byte)(num7 >> 8)] ^ iT3[(byte)num6] ^ ekey[35];
			num6 = iT0[num2 >> 24] ^ iT1[(byte)(num5 >> 16)] ^ iT2[(byte)(num4 >> 8)] ^ iT3[(byte)num3] ^ ekey[36];
			num7 = iT0[num3 >> 24] ^ iT1[(byte)(num2 >> 16)] ^ iT2[(byte)(num5 >> 8)] ^ iT3[(byte)num4] ^ ekey[37];
			num8 = iT0[num4 >> 24] ^ iT1[(byte)(num3 >> 16)] ^ iT2[(byte)(num2 >> 8)] ^ iT3[(byte)num5] ^ ekey[38];
			num9 = iT0[num5 >> 24] ^ iT1[(byte)(num4 >> 16)] ^ iT2[(byte)(num3 >> 8)] ^ iT3[(byte)num2] ^ ekey[39];
			if (Nr > 10)
			{
				num2 = iT0[num6 >> 24] ^ iT1[(byte)(num9 >> 16)] ^ iT2[(byte)(num8 >> 8)] ^ iT3[(byte)num7] ^ ekey[40];
				num3 = iT0[num7 >> 24] ^ iT1[(byte)(num6 >> 16)] ^ iT2[(byte)(num9 >> 8)] ^ iT3[(byte)num8] ^ ekey[41];
				num4 = iT0[num8 >> 24] ^ iT1[(byte)(num7 >> 16)] ^ iT2[(byte)(num6 >> 8)] ^ iT3[(byte)num9] ^ ekey[42];
				num5 = iT0[num9 >> 24] ^ iT1[(byte)(num8 >> 16)] ^ iT2[(byte)(num7 >> 8)] ^ iT3[(byte)num6] ^ ekey[43];
				num6 = iT0[num2 >> 24] ^ iT1[(byte)(num5 >> 16)] ^ iT2[(byte)(num4 >> 8)] ^ iT3[(byte)num3] ^ ekey[44];
				num7 = iT0[num3 >> 24] ^ iT1[(byte)(num2 >> 16)] ^ iT2[(byte)(num5 >> 8)] ^ iT3[(byte)num4] ^ ekey[45];
				num8 = iT0[num4 >> 24] ^ iT1[(byte)(num3 >> 16)] ^ iT2[(byte)(num2 >> 8)] ^ iT3[(byte)num5] ^ ekey[46];
				num9 = iT0[num5 >> 24] ^ iT1[(byte)(num4 >> 16)] ^ iT2[(byte)(num3 >> 8)] ^ iT3[(byte)num2] ^ ekey[47];
				num = 48;
				if (Nr > 12)
				{
					num2 = iT0[num6 >> 24] ^ iT1[(byte)(num9 >> 16)] ^ iT2[(byte)(num8 >> 8)] ^ iT3[(byte)num7] ^ ekey[48];
					num3 = iT0[num7 >> 24] ^ iT1[(byte)(num6 >> 16)] ^ iT2[(byte)(num9 >> 8)] ^ iT3[(byte)num8] ^ ekey[49];
					num4 = iT0[num8 >> 24] ^ iT1[(byte)(num7 >> 16)] ^ iT2[(byte)(num6 >> 8)] ^ iT3[(byte)num9] ^ ekey[50];
					num5 = iT0[num9 >> 24] ^ iT1[(byte)(num8 >> 16)] ^ iT2[(byte)(num7 >> 8)] ^ iT3[(byte)num6] ^ ekey[51];
					num6 = iT0[num2 >> 24] ^ iT1[(byte)(num5 >> 16)] ^ iT2[(byte)(num4 >> 8)] ^ iT3[(byte)num3] ^ ekey[52];
					num7 = iT0[num3 >> 24] ^ iT1[(byte)(num2 >> 16)] ^ iT2[(byte)(num5 >> 8)] ^ iT3[(byte)num4] ^ ekey[53];
					num8 = iT0[num4 >> 24] ^ iT1[(byte)(num3 >> 16)] ^ iT2[(byte)(num2 >> 8)] ^ iT3[(byte)num5] ^ ekey[54];
					num9 = iT0[num5 >> 24] ^ iT1[(byte)(num4 >> 16)] ^ iT2[(byte)(num3 >> 8)] ^ iT3[(byte)num2] ^ ekey[55];
					num = 56;
				}
			}
			outdata[0] = (byte)(iSBox[num6 >> 24] ^ (byte)(ekey[num] >> 24));
			outdata[1] = (byte)(iSBox[(byte)(num9 >> 16)] ^ (byte)(ekey[num] >> 16));
			outdata[2] = (byte)(iSBox[(byte)(num8 >> 8)] ^ (byte)(ekey[num] >> 8));
			outdata[3] = (byte)(iSBox[(byte)num7] ^ (byte)ekey[num++]);
			outdata[4] = (byte)(iSBox[num7 >> 24] ^ (byte)(ekey[num] >> 24));
			outdata[5] = (byte)(iSBox[(byte)(num6 >> 16)] ^ (byte)(ekey[num] >> 16));
			outdata[6] = (byte)(iSBox[(byte)(num9 >> 8)] ^ (byte)(ekey[num] >> 8));
			outdata[7] = (byte)(iSBox[(byte)num8] ^ (byte)ekey[num++]);
			outdata[8] = (byte)(iSBox[num8 >> 24] ^ (byte)(ekey[num] >> 24));
			outdata[9] = (byte)(iSBox[(byte)(num7 >> 16)] ^ (byte)(ekey[num] >> 16));
			outdata[10] = (byte)(iSBox[(byte)(num6 >> 8)] ^ (byte)(ekey[num] >> 8));
			outdata[11] = (byte)(iSBox[(byte)num9] ^ (byte)ekey[num++]);
			outdata[12] = (byte)(iSBox[num9 >> 24] ^ (byte)(ekey[num] >> 24));
			outdata[13] = (byte)(iSBox[(byte)(num8 >> 16)] ^ (byte)(ekey[num] >> 16));
			outdata[14] = (byte)(iSBox[(byte)(num7 >> 8)] ^ (byte)(ekey[num] >> 8));
			outdata[15] = (byte)(iSBox[(byte)num6] ^ (byte)ekey[num++]);
		}
	}
	/// <summary>Provides a CNG (Cryptography Next Generation) implementation of the MD5 (Message Digest 5) 128-bit hashing algorithm.</summary>
	public sealed class MD5Cng : MD5
	{
		private static byte[] Empty = new byte[0];

		private MD5 hash;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.MD5Cng" /> class. </summary>
		/// <exception cref="T:System.InvalidOperationException">This implementation is not part of the Windows Platform FIPS-validated cryptographic algorithms.</exception>
		[SecurityCritical]
		public MD5Cng()
		{
			hash = new MD5CryptoServiceProvider();
		}

		/// <summary>Initializes, or re-initializes, the instance of the hash algorithm. </summary>
		[SecurityCritical]
		public override void Initialize()
		{
			hash.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			hash.TransformBlock(array, ibStart, cbSize, null, 0);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			hash.TransformFinalBlock(Empty, 0, 0);
			HashValue = hash.Hash;
			return HashValue;
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			((IDisposable)hash).Dispose();
			base.Dispose(disposing);
		}
	}
	/// <summary>Provides a Cryptography Next Generation (CNG) implementation of the Secure Hash Algorithm (SHA).</summary>
	public sealed class SHA1Cng : SHA1
	{
		private static byte[] Empty = new byte[0];

		private SHA1 hash;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.SHA1Cng" /> class. </summary>
		[SecurityCritical]
		public SHA1Cng()
		{
			hash = new SHA1Managed();
		}

		/// <summary>Initializes, or re-initializes, the instance of the hash algorithm. </summary>
		[SecurityCritical]
		public override void Initialize()
		{
			hash.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			hash.TransformBlock(array, ibStart, cbSize, null, 0);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			hash.TransformFinalBlock(Empty, 0, 0);
			HashValue = hash.Hash;
			return HashValue;
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			((IDisposable)hash).Dispose();
			base.Dispose(disposing);
		}
	}
	/// <summary>Provides a Cryptography Next Generation (CNG) implementation of the Secure Hash Algorithm (SHA) for 256-bit hash values.</summary>
	public sealed class SHA256Cng : SHA256
	{
		private static byte[] Empty = new byte[0];

		private SHA256 hash;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.SHA256Cng" /> class. </summary>
		[SecurityCritical]
		public SHA256Cng()
		{
			hash = new SHA256Managed();
		}

		/// <summary>Initializes, or re-initializes, the instance of the hash algorithm. </summary>
		[SecurityCritical]
		public override void Initialize()
		{
			hash.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			hash.TransformBlock(array, ibStart, cbSize, null, 0);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			hash.TransformFinalBlock(Empty, 0, 0);
			HashValue = hash.Hash;
			return HashValue;
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			((IDisposable)hash).Dispose();
			base.Dispose(disposing);
		}
	}
	/// <summary>Defines a wrapper object to access the cryptographic service provider (CSP) implementation of the <see cref="T:System.Security.Cryptography.SHA256" /> algorithm. </summary>
	public sealed class SHA256CryptoServiceProvider : SHA256
	{
		private static byte[] Empty = new byte[0];

		private SHA256 hash;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.SHA256CryptoServiceProvider" /> class. </summary>
		[SecurityCritical]
		public SHA256CryptoServiceProvider()
		{
			hash = new SHA256Managed();
		}

		/// <summary>Initializes, or reinitializes, an instance of a hash algorithm.</summary>
		[SecurityCritical]
		public override void Initialize()
		{
			hash.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			hash.TransformBlock(array, ibStart, cbSize, null, 0);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			hash.TransformFinalBlock(Empty, 0, 0);
			HashValue = hash.Hash;
			return HashValue;
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			((IDisposable)hash).Dispose();
			base.Dispose(disposing);
		}
	}
	/// <summary>Provides a Cryptography Next Generation (CNG) implementation of the Secure Hash Algorithm (SHA) for 384-bit hash values.</summary>
	public sealed class SHA384Cng : SHA384
	{
		private static byte[] Empty = new byte[0];

		private SHA384 hash;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.SHA384Cng" /> class. </summary>
		[SecurityCritical]
		public SHA384Cng()
		{
			hash = new SHA384Managed();
		}

		/// <summary>Initializes, or re-initializes, the instance of the hash algorithm. </summary>
		[SecurityCritical]
		public override void Initialize()
		{
			hash.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			hash.TransformBlock(array, ibStart, cbSize, null, 0);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			hash.TransformFinalBlock(Empty, 0, 0);
			HashValue = hash.Hash;
			return HashValue;
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			((IDisposable)hash).Dispose();
			base.Dispose(disposing);
		}
	}
	/// <summary>Defines a wrapper object to access the cryptographic service provider (CSP) implementation of the <see cref="T:System.Security.Cryptography.SHA384" /> algorithm. </summary>
	public sealed class SHA384CryptoServiceProvider : SHA384
	{
		private static byte[] Empty = new byte[0];

		private SHA384 hash;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.SHA384CryptoServiceProvider" /> class. </summary>
		[SecurityCritical]
		public SHA384CryptoServiceProvider()
		{
			hash = new SHA384Managed();
		}

		/// <summary>Initializes, or reinitializes, an instance of a hash algorithm.</summary>
		[SecurityCritical]
		public override void Initialize()
		{
			hash.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			hash.TransformBlock(array, ibStart, cbSize, null, 0);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			hash.TransformFinalBlock(Empty, 0, 0);
			HashValue = hash.Hash;
			return HashValue;
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			((IDisposable)hash).Dispose();
			base.Dispose(disposing);
		}
	}
	/// <summary>Provides a Cryptography Next Generation (CNG) implementation of the Secure Hash Algorithm (SHA) for 512-bit hash values.</summary>
	public sealed class SHA512Cng : SHA512
	{
		private static byte[] Empty = new byte[0];

		private SHA512 hash;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.SHA512Cng" /> class. </summary>
		[SecurityCritical]
		public SHA512Cng()
		{
			hash = new SHA512Managed();
		}

		/// <summary>Initializes, or re-initializes, the instance of the hash algorithm. </summary>
		[SecurityCritical]
		public override void Initialize()
		{
			hash.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			hash.TransformBlock(array, ibStart, cbSize, null, 0);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			hash.TransformFinalBlock(Empty, 0, 0);
			HashValue = hash.Hash;
			return HashValue;
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			((IDisposable)hash).Dispose();
			base.Dispose(disposing);
		}
	}
	/// <summary>Defines a wrapper object to access the cryptographic service provider (CSP) implementation of the <see cref="T:System.Security.Cryptography.SHA512" /> algorithm. </summary>
	public sealed class SHA512CryptoServiceProvider : SHA512
	{
		private static byte[] Empty = new byte[0];

		private SHA512 hash;

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.SHA512CryptoServiceProvider" /> class. </summary>
		[SecurityCritical]
		public SHA512CryptoServiceProvider()
		{
			hash = new SHA512Managed();
		}

		/// <summary>Initializes, or reinitializes, an instance of a hash algorithm.</summary>
		[SecurityCritical]
		public override void Initialize()
		{
			hash.Initialize();
		}

		[SecurityCritical]
		protected override void HashCore(byte[] array, int ibStart, int cbSize)
		{
			hash.TransformBlock(array, ibStart, cbSize, null, 0);
		}

		[SecurityCritical]
		protected override byte[] HashFinal()
		{
			hash.TransformFinalBlock(Empty, 0, 0);
			HashValue = hash.Hash;
			return HashValue;
		}

		[SecurityCritical]
		protected override void Dispose(bool disposing)
		{
			((IDisposable)hash).Dispose();
			base.Dispose(disposing);
		}
	}
	/// <summary>Provides a Cryptography Next Generation (CNG) implementation of the Triple Data Encryption Standard (3DES) algorithm.</summary>
	public sealed class TripleDESCng : TripleDES
	{
		/// <summary>Gets or sets the key for the <see cref="T:System.Security.Cryptography.TripleDESCng" /> algorithm.</summary>
		/// <returns>The key for the <see cref="T:System.Security.Cryptography.TripleDESCng" /> algorithm.</returns>
		public override byte[] Key
		{
			get
			{
				throw new NotImplementedException();
			}
			set
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets or sets the size, in bits, of the secret key used by the <see cref="T:System.Security.Cryptography.TripleDESCng" /> algorithm.</summary>
		/// <returns>The size, in bits, of the secret key used by the <see cref="T:System.Security.Cryptography.TripleDESCng" /> algorithm.</returns>
		public override int KeySize
		{
			get
			{
				throw new NotImplementedException();
			}
			set
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.TripleDESCng" /> class with an ephemeral key.</summary>
		public TripleDESCng()
		{
			throw new NotImplementedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.TripleDESCng" /> class with the specified key name, which represents an existing persisted 3DES key.</summary>
		/// <param name="keyName">The name of the key.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyName" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.PlatformNotSupportedException">
		///         Cryptography Next Generation (CNG) is not supported on this system.
		///  </exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.
		/// </exception>
		public TripleDESCng(string keyName)
		{
			throw new NotImplementedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.TripleDESCng" /> class with the specified key name, which represents an existing persisted 3DES key, and the specified key storage provider (KSP).</summary>
		/// <param name="keyName">The name of the key.</param>
		/// <param name="provider">The KSP that contains the key.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyName" /> is <see langword="null" />. -or-
		///         <paramref name="provider" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.PlatformNotSupportedException">
		///         Cryptography Next Generation (CNG) is not supported on this system.
		///  </exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.
		/// </exception>
		public TripleDESCng(string keyName, CngProvider provider)
		{
			throw new NotImplementedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.TripleDESCng" /> class with the specified key name, which represents an existing persisted 3DES key,  the specified key storage provider (KSP) and key open options.</summary>
		/// <param name="keyName">The name of the key.</param>
		/// <param name="provider">The KSP that contains the key.</param>
		/// <param name="openOptions">A bitwise combination of the enumeration values that specify options for opening the key, such as where the key is opened from (machine or user storage) and whether to suppress UI prompting.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="keyName" /> is <see langword="null" />. -or-
		///         <paramref name="provider" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.PlatformNotSupportedException">
		///         Cryptography Next Generation (CNG) is not supported on this system.
		///  </exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.
		/// </exception>
		public TripleDESCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a symmetric 3DES decryptor object with the current key and initialization vector (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
		/// <returns>A symmetric 3DES decryptor object.</returns>
		public override ICryptoTransform CreateDecryptor()
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a symmetric 3DES decryptor object with the specified key and initialization vector (IV).</summary>
		/// <param name="rgbKey">The secret key to use for the 3DES algorithm. The key size must be 192 bits.</param>
		/// <param name="rgbIV">The initialization vector to use for the 3DES algorithm.</param>
		/// <returns>A symmetric 3DES decryptor object.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="rgbKey" />  is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="rgbKey" />  is not a valid size for this algorithm.-or-<paramref name="rgbIV" /> size does not match the block size for this algorithm.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///   <paramref name="rgbKey" /> is a known weak key for this algorithm and cannot be used.-or-
		///         <paramref name="rgbIV" />  is <see langword="null" />.</exception>
		public override ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV)
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a symmetric 3DES encryptor object using the current key and initialization vector (<see cref="P:System.Security.Cryptography.SymmetricAlgorithm.IV" />).</summary>
		/// <returns>A symmetric 3DES encryptor object.</returns>
		public override ICryptoTransform CreateEncryptor()
		{
			throw new NotImplementedException();
		}

		/// <summary>Creates a symmetric 3DES encryptor object with the specified key and initialization vector (IV).</summary>
		/// <param name="rgbKey">The secret key to use for the 3DES algorithm. The key size must be 192 bits.</param>
		/// <param name="rgbIV">The initialization vector to use for the 3DES algorithm.</param>
		/// <returns>A symmetric 3DES encryptor object.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="rgbKey" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="rgbKey" /> is not a valid size for this algorithm.-or-<paramref name="rgbIV" /> size does not match the block size for this algorithm.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///   <paramref name="rgbKey" /> is a known weak key for this algorithm and cannot be used.-or-
		///         <paramref name="rgbIV" />  is <see langword="null" />.</exception>
		public override ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV)
		{
			return null;
		}

		protected override void Dispose(bool disposing)
		{
			throw new NotImplementedException();
		}

		/// <summary>Generates a random initialization vector (IV) to use for the 3DES algorithm.</summary>
		public override void GenerateIV()
		{
			throw new NotImplementedException();
		}

		/// <summary>Generates a random key to use for the 3DES algorithm.</summary>
		public override void GenerateKey()
		{
			throw new NotImplementedException();
		}
	}
}
namespace System.Security.Cryptography.X509Certificates
{
	/// <summary>Identifies the level of trustworthiness that is assigned to the signature for a manifest.</summary>
	public enum TrustStatus
	{
		/// <summary>The signature was created by an explicitly distrusted publisher.</summary>
		Untrusted,
		/// <summary>The identity is not known and the signature is invalid. Because there is no verified signature, an identity cannot be determined.</summary>
		UnknownIdentity,
		/// <summary>The identity is known and the signature is valid. A valid Authenticode signature provides an identity.</summary>
		KnownIdentity,
		/// <summary>The signature is valid and was created by an explicitly trusted publisher.</summary>
		Trusted
	}
	/// <summary>Provides extension methods for retrieving <see cref="T:System.Security.Cryptography.DSA" /> implementations for the public and private keys of an <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />. </summary>
	public static class DSACertificateExtensions
	{
		/// <summary>Gets the <see cref="T:System.Security.Cryptography.DSA" /> public key from the <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />.</summary>
		/// <param name="certificate">The certificate. </param>
		/// <returns>The public key, or <see langword="null" /> if the certificate does not have a DSA public key. </returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="certificate" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">Windows reports an error. See the <see cref="P:System.Exception.Message" /> property for more information. </exception>
		public static DSA GetDSAPublicKey(this X509Certificate2 certificate)
		{
			if (certificate == null)
			{
				throw new ArgumentNullException("certificate");
			}
			return certificate.PrivateKey as DSA;
		}

		/// <summary>Gets the <see cref="T:System.Security.Cryptography.DSA" /> private key from the <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />.</summary>
		/// <param name="certificate">The certificate. </param>
		/// <returns>The private key, or <see langword="null" /> if the certificate does not have a DSA private key. </returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="certificate" /> is <see langword="null" />. </exception>
		public static DSA GetDSAPrivateKey(this X509Certificate2 certificate)
		{
			if (certificate == null)
			{
				throw new ArgumentNullException("certificate");
			}
			return certificate.PublicKey.Key as DSA;
		}

		/// <summary>Combines a private key with the public key of a <see cref="T:System.Security.Cryptography.DSA" /> certificate to generate a new DSA certificate.</summary>
		/// <param name="certificate">The DSA certificate.</param>
		/// <param name="privateKey">The private DSA key.</param>
		/// <returns>A new DSA certificate with the <see cref="P:System.Security.Cryptography.X509Certificates.X509Certificate2.HasPrivateKey" /> property set to <see langword="true" />. The input DSA certificate object isn't modified.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="certificate" /> or <paramref name="privateKey" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The certificate already has an associated private key.</exception>
		/// <exception cref="T:System.ArgumentException">The certificate doesn't have a public key.-or-The specified private key doesn't match the public key for the specified certificate.</exception>
		[MonoTODO]
		public static X509Certificate2 CopyWithPrivateKey(this X509Certificate2 certificate, DSA privateKey)
		{
			if (certificate == null)
			{
				throw new ArgumentNullException("certificate");
			}
			if (privateKey == null)
			{
				throw new ArgumentNullException("privateKey");
			}
			throw new NotImplementedException();
		}
	}
	/// <summary>Provides extension methods for retrieving <see cref="T:System.Security.Cryptography.ECDsa" /> implementations for the
	///     public and private keys of a <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> certificate.</summary>
	public static class ECDsaCertificateExtensions
	{
		/// <summary>Gets the <see cref="T:System.Security.Cryptography.ECDsa" /> private key from the <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> certificate.</summary>
		/// <param name="certificate">The certificate. </param>
		/// <returns>The private key, or <see langword="null" /> if the certificate does not have an ECDsa private key. </returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="certificate" /> is <see langword="null" />. </exception>
		[MonoTODO]
		public static ECDsa GetECDsaPrivateKey(this X509Certificate2 certificate)
		{
			throw new NotImplementedException();
		}

		/// <summary>Gets the <see cref="T:System.Security.Cryptography.ECDsa" /> public key from the <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> certificate.</summary>
		/// <param name="certificate">The certificate. </param>
		/// <returns>The public key, or <see langword="null" /> if the certificate does not have an ECDsa public key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="certificate" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">The handle is invalid. </exception>
		[MonoTODO]
		public static ECDsa GetECDsaPublicKey(this X509Certificate2 certificate)
		{
			throw new NotImplementedException();
		}

		/// <summary>Combines a private key with the public key of an <see cref="T:System.Security.Cryptography.ECDsa" /> certificate to generate a new ECDSA certificate.</summary>
		/// <param name="certificate">The ECDSA certificate.</param>
		/// <param name="privateKey">The private ECDSA key.</param>
		/// <returns>A new ECDSA certificate with the <see cref="P:System.Security.Cryptography.X509Certificates.X509Certificate2.HasPrivateKey" /> property set to <see langword="true" />. The input ECDSA certificate object isn't modified.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="certificate" /> or <paramref name="privateKey" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The certificate already has an associated private key.</exception>
		/// <exception cref="T:System.ArgumentException">The certificate doesn't have a public key.-or-The specified private key doesn't match the public key for the specified certificate.</exception>
		[MonoTODO]
		public static X509Certificate2 CopyWithPrivateKey(this X509Certificate2 certificate, ECDsa privateKey)
		{
			throw new NotImplementedException();
		}
	}
	/// <summary>Provides extension methods for retrieving <see cref="T:System.Security.Cryptography.RSA" /> implementations for the public and private keys of an <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />. </summary>
	public static class RSACertificateExtensions
	{
		/// <summary>Gets the <see cref="T:System.Security.Cryptography.RSA" /> private key from the <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />.</summary>
		/// <param name="certificate">The certificate. </param>
		/// <returns>The private key, or <see langword="null" /> if the certificate does not have an RSA private key. </returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="certificate" /> is <see langword="null" />. </exception>
		public static RSA GetRSAPrivateKey(this X509Certificate2 certificate)
		{
			if (certificate == null)
			{
				throw new ArgumentNullException("certificate");
			}
			if (!certificate.HasPrivateKey)
			{
				return null;
			}
			return certificate.Impl.GetRSAPrivateKey();
		}

		/// <summary>Gets the <see cref="T:System.Security.Cryptography.RSA" /> public key from the <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" />.</summary>
		/// <param name="certificate">The certificate. </param>
		/// <returns>The public key, or <see langword="null" /> if the certificate does not have an RSA public key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="certificate" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">Windows reports an error. See the <see cref="P:System.Exception.Message" /> property for more information. </exception>
		public static RSA GetRSAPublicKey(this X509Certificate2 certificate)
		{
			if (certificate == null)
			{
				throw new ArgumentNullException("certificate");
			}
			return certificate.PublicKey.Key as RSA;
		}

		/// <summary>Combines a private key with the public key of an <see cref="T:System.Security.Cryptography.RSA" /> certificate to generate a new RSA certificate.</summary>
		/// <param name="certificate">The RSA certificate.</param>
		/// <param name="privateKey">The private RSA key.</param>
		/// <returns>A new RSA certificate with the <see cref="P:System.Security.Cryptography.X509Certificates.X509Certificate2.HasPrivateKey" /> property set to <see langword="true" />. The input RSA certificate object isn't modified.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="certificate" /> or <paramref name="privateKey" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The certificate already has an associated private key.</exception>
		/// <exception cref="T:System.ArgumentException">The certificate doesn't have a public key.-or-The specified private key doesn't match the public key for the specified certificate.</exception>
		public static X509Certificate2 CopyWithPrivateKey(this X509Certificate2 certificate, RSA privateKey)
		{
			if (certificate == null)
			{
				throw new ArgumentNullException("certificate");
			}
			if (privateKey == null)
			{
				throw new ArgumentNullException("privateKey");
			}
			return (X509Certificate2)certificate.Impl.CopyWithPrivateKey(privateKey).CreateCertificate();
		}
	}
}
namespace System.Reflection
{
	public abstract class DispatchProxy
	{
		protected abstract object Invoke(MethodInfo targetMethod, object[] args);

		public static T Create<T, TProxy>() where TProxy : DispatchProxy
		{
			return (T)DispatchProxyGenerator.CreateProxyInstance(typeof(TProxy), typeof(T));
		}
	}
	internal static class DispatchProxyGenerator
	{
		private class PackedArgs
		{
			internal const int DispatchProxyPosition = 0;

			internal const int DeclaringTypePosition = 1;

			internal const int MethodTokenPosition = 2;

			internal const int ArgsPosition = 3;

			internal const int GenericTypesPosition = 4;

			internal const int ReturnValuePosition = 5;

			internal static readonly Type[] PackedTypes = new Type[6]
			{
				typeof(object),
				typeof(Type),
				typeof(int),
				typeof(object[]),
				typeof(Type[]),
				typeof(object)
			};

			private object[] _args;

			internal DispatchProxy DispatchProxy => (DispatchProxy)_args[0];

			internal Type DeclaringType => (Type)_args[1];

			internal int MethodToken => (int)_args[2];

			internal object[] Args => (object[])_args[3];

			internal Type[] GenericTypes => (Type[])_args[4];

			internal object ReturnValue
			{
				set
				{
					_args[5] = value;
				}
			}

			internal PackedArgs()
				: this(new object[PackedTypes.Length])
			{
			}

			internal PackedArgs(object[] args)
			{
				_args = args;
			}
		}

		private class ProxyAssembly
		{
			private AssemblyBuilder _ab;

			private ModuleBuilder _mb;

			private int _typeId;

			private Dictionary<MethodBase, int> _methodToToken = new Dictionary<MethodBase, int>();

			private List<MethodBase> _methodsByToken = new List<MethodBase>();

			private HashSet<string> _ignoresAccessAssemblyNames = new HashSet<string>();

			private ConstructorInfo _ignoresAccessChecksToAttributeConstructor;

			internal ConstructorInfo IgnoresAccessChecksAttributeConstructor
			{
				get
				{
					if (_ignoresAccessChecksToAttributeConstructor == null)
					{
						TypeInfo typeInfo = GenerateTypeInfoOfIgnoresAccessChecksToAttribute();
						_ignoresAccessChecksToAttributeConstructor = typeInfo.DeclaredConstructors.Single();
					}
					return _ignoresAccessChecksToAttributeConstructor;
				}
			}

			public ProxyAssembly()
			{
				_ab = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("ProxyBuilder"), AssemblyBuilderAccess.Run);
				_mb = _ab.DefineDynamicModule("testmod");
			}

			public ProxyBuilder CreateProxy(string name, Type proxyBaseType)
			{
				int num = Interlocked.Increment(ref _typeId);
				TypeBuilder tb = _mb.DefineType(name + "_" + num, TypeAttributes.Public, proxyBaseType);
				return new ProxyBuilder(this, tb, proxyBaseType);
			}

			private TypeInfo GenerateTypeInfoOfIgnoresAccessChecksToAttribute()
			{
				TypeBuilder typeBuilder = _mb.DefineType("System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute", TypeAttributes.Public, typeof(Attribute));
				FieldBuilder fieldBuilder = typeBuilder.DefineField("assemblyName", typeof(string), FieldAttributes.Private);
				ILGenerator iLGenerator = typeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.HasThis, new Type[1] { fieldBuilder.FieldType }).GetILGenerator();
				iLGenerator.Emit(OpCodes.Ldarg_0);
				iLGenerator.Emit(OpCodes.Ldarg, 1);
				iLGenerator.Emit(OpCodes.Stfld, fieldBuilder);
				iLGenerator.Emit(OpCodes.Ret);
				typeBuilder.DefineProperty("AssemblyName", PropertyAttributes.None, CallingConventions.HasThis, typeof(string), null);
				ILGenerator iLGenerator2 = typeBuilder.DefineMethod("get_AssemblyName", MethodAttributes.Public, CallingConventions.HasThis, typeof(string), null).GetILGenerator();
				iLGenerator2.Emit(OpCodes.Ldarg_0);
				iLGenerator2.Emit(OpCodes.Ldfld, fieldBuilder);
				iLGenerator2.Emit(OpCodes.Ret);
				TypeInfo typeInfo = typeof(AttributeUsageAttribute).GetTypeInfo();
				ConstructorInfo con = typeInfo.DeclaredConstructors.Single((ConstructorInfo c) => c.GetParameters().Count() == 1 && c.GetParameters()[0].ParameterType == typeof(AttributeTargets));
				PropertyInfo propertyInfo = typeInfo.DeclaredProperties.Single((PropertyInfo f) => string.Equals(f.Name, "AllowMultiple"));
				CustomAttributeBuilder customAttribute = new CustomAttributeBuilder(con, new object[1] { AttributeTargets.Assembly }, new PropertyInfo[1] { propertyInfo }, new object[1] { true });
				typeBuilder.SetCustomAttribute(customAttribute);
				return typeBuilder.CreateTypeInfo();
			}

			internal void GenerateInstanceOfIgnoresAccessChecksToAttribute(string assemblyName)
			{
				CustomAttributeBuilder customAttribute = new CustomAttributeBuilder(IgnoresAccessChecksAttributeConstructor, new object[1] { assemblyName });
				_ab.SetCustomAttribute(customAttribute);
			}

			internal void EnsureTypeIsVisible(Type type)
			{
				TypeInfo typeInfo = type.GetTypeInfo();
				if (!typeInfo.IsVisible)
				{
					string name = typeInfo.Assembly.GetName().Name;
					if (!_ignoresAccessAssemblyNames.Contains(name))
					{
						GenerateInstanceOfIgnoresAccessChecksToAttribute(name);
						_ignoresAccessAssemblyNames.Add(name);
					}
				}
			}

			internal void GetTokenForMethod(MethodBase method, out Type type, out int token)
			{
				type = method.DeclaringType;
				token = 0;
				if (!_methodToToken.TryGetValue(method, out token))
				{
					_methodsByToken.Add(method);
					token = _methodsByToken.Count - 1;
					_methodToToken[method] = token;
				}
			}

			internal MethodBase ResolveMethodToken(Type type, int token)
			{
				return _methodsByToken[token];
			}
		}

		private class ProxyBuilder
		{
			private class ParametersArray
			{
				private ILGenerator _il;

				private Type[] _paramTypes;

				internal ParametersArray(ILGenerator il, Type[] paramTypes)
				{
					_il = il;
					_paramTypes = paramTypes;
				}

				internal void Get(int i)
				{
					_il.Emit(OpCodes.Ldarg, i + 1);
				}

				internal void BeginSet(int i)
				{
					_il.Emit(OpCodes.Ldarg, i + 1);
				}

				internal void EndSet(int i, Type stackType)
				{
					Type elementType = _paramTypes[i].GetElementType();
					Convert(_il, stackType, elementType, isAddress: false);
					Stind(_il, elementType);
				}
			}

			private class GenericArray<T>
			{
				private ILGenerator _il;

				private LocalBuilder _lb;

				internal GenericArray(ILGenerator il, int len)
				{
					_il = il;
					_lb = il.DeclareLocal(typeof(T[]));
					il.Emit(OpCodes.Ldc_I4, len);
					il.Emit(OpCodes.Newarr, typeof(T));
					il.Emit(OpCodes.Stloc, _lb);
				}

				internal void Load()
				{
					_il.Emit(OpCodes.Ldloc, _lb);
				}

				internal void Get(int i)
				{
					_il.Emit(OpCodes.Ldloc, _lb);
					_il.Emit(OpCodes.Ldc_I4, i);
					_il.Emit(OpCodes.Ldelem_Ref);
				}

				internal void BeginSet(int i)
				{
					_il.Emit(OpCodes.Ldloc, _lb);
					_il.Emit(OpCodes.Ldc_I4, i);
				}

				internal void EndSet(Type stackType)
				{
					Convert(_il, stackType, typeof(T), isAddress: false);
					_il.Emit(OpCodes.Stelem_Ref);
				}
			}

			private sealed class PropertyAccessorInfo
			{
				public MethodInfo InterfaceGetMethod { get; }

				public MethodInfo InterfaceSetMethod { get; }

				public MethodBuilder GetMethodBuilder { get; set; }

				public MethodBuilder SetMethodBuilder { get; set; }

				public PropertyAccessorInfo(MethodInfo interfaceGetMethod, MethodInfo interfaceSetMethod)
				{
					InterfaceGetMethod = interfaceGetMethod;
					InterfaceSetMethod = interfaceSetMethod;
				}
			}

			private sealed class EventAccessorInfo
			{
				public MethodInfo InterfaceAddMethod { get; }

				public MethodInfo InterfaceRemoveMethod { get; }

				public MethodInfo InterfaceRaiseMethod { get; }

				public MethodBuilder AddMethodBuilder { get; set; }

				public MethodBuilder RemoveMethodBuilder { get; set; }

				public MethodBuilder RaiseMethodBuilder { get; set; }

				public EventAccessorInfo(MethodInfo interfaceAddMethod, MethodInfo interfaceRemoveMethod, MethodInfo interfaceRaiseMethod)
				{
					InterfaceAddMethod = interfaceAddMethod;
					InterfaceRemoveMethod = interfaceRemoveMethod;
					InterfaceRaiseMethod = interfaceRaiseMethod;
				}
			}

			private sealed class MethodInfoEqualityComparer : EqualityComparer<MethodInfo>
			{
				public static readonly MethodInfoEqualityComparer Instance = new MethodInfoEqualityComparer();

				private MethodInfoEqualityComparer()
				{
				}

				public sealed override bool Equals(MethodInfo left, MethodInfo right)
				{
					if ((object)left == right)
					{
						return true;
					}
					if (left == null)
					{
						return right == null;
					}
					if (right == null)
					{
						return false;
					}
					if (!object.Equals(left.DeclaringType, right.DeclaringType))
					{
						return false;
					}
					if (!object.Equals(left.ReturnType, right.ReturnType))
					{
						return false;
					}
					if (left.CallingConvention != right.CallingConvention)
					{
						return false;
					}
					if (left.IsStatic != right.IsStatic)
					{
						return false;
					}
					if (left.Name != right.Name)
					{
						return false;
					}
					Type[] genericArguments = left.GetGenericArguments();
					Type[] genericArguments2 = right.GetGenericArguments();
					if (genericArguments.Length != genericArguments2.Length)
					{
						return false;
					}
					for (int i = 0; i < genericArguments.Length; i++)
					{
						if (!object.Equals(genericArguments[i], genericArguments2[i]))
						{
							return false;
						}
					}
					ParameterInfo[] parameters = left.GetParameters();
					ParameterInfo[] parameters2 = right.GetParameters();
					if (parameters.Length != parameters2.Length)
					{
						return false;
					}
					for (int j = 0; j < parameters.Length; j++)
					{
						if (!object.Equals(parameters[j].ParameterType, parameters2[j].ParameterType))
						{
							return false;
						}
					}
					return true;
				}

				public sealed override int GetHashCode(MethodInfo obj)
				{
					if (obj == null)
					{
						return 0;
					}
					int hashCode = obj.DeclaringType.GetHashCode();
					hashCode ^= obj.Name.GetHashCode();
					ParameterInfo[] parameters = obj.GetParameters();
					foreach (ParameterInfo parameterInfo in parameters)
					{
						hashCode ^= parameterInfo.ParameterType.GetHashCode();
					}
					return hashCode;
				}
			}

			private static readonly MethodInfo s_delegateInvoke = typeof(Action<object[]>).GetTypeInfo().GetDeclaredMethod("Invoke");

			private ProxyAssembly _assembly;

			private TypeBuilder _tb;

			private Type _proxyBaseType;

			private List<FieldBuilder> _fields;

			private static OpCode[] s_convOpCodes = new OpCode[19]
			{
				OpCodes.Nop,
				OpCodes.Nop,
				OpCodes.Nop,
				OpCodes.Conv_I1,
				OpCodes.Conv_I2,
				OpCodes.Conv_I1,
				OpCodes.Conv_U1,
				OpCodes.Conv_I2,
				OpCodes.Conv_U2,
				OpCodes.Conv_I4,
				OpCodes.Conv_U4,
				OpCodes.Conv_I8,
				OpCodes.Conv_U8,
				OpCodes.Conv_R4,
				OpCodes.Conv_R8,
				OpCodes.Nop,
				OpCodes.Nop,
				OpCodes.Nop,
				OpCodes.Nop
			};

			private static OpCode[] s_ldindOpCodes = new OpCode[19]
			{
				OpCodes.Nop,
				OpCodes.Nop,
				OpCodes.Nop,
				OpCodes.Ldind_I1,
				OpCodes.Ldind_I2,
				OpCodes.Ldind_I1,
				OpCodes.Ldind_U1,
				OpCodes.Ldind_I2,
				OpCodes.Ldind_U2,
				OpCodes.Ldind_I4,
				OpCodes.Ldind_U4,
				OpCodes.Ldind_I8,
				OpCodes.Ldind_I8,
				OpCodes.Ldind_R4,
				OpCodes.Ldind_R8,
				OpCodes.Nop,
				OpCodes.Nop,
				OpCodes.Nop,
				OpCodes.Ldind_Ref
			};

			private static OpCode[] s_stindOpCodes = new OpCode[19]
			{
				OpCodes.Nop,
				OpCodes.Nop,
				OpCodes.Nop,
				OpCodes.Stind_I1,
				OpCodes.Stind_I2,
				OpCodes.Stind_I1,
				OpCodes.Stind_I1,
				OpCodes.Stind_I2,
				OpCodes.Stind_I2,
				OpCodes.Stind_I4,
				OpCodes.Stind_I4,
				OpCodes.Stind_I8,
				OpCodes.Stind_I8,
				OpCodes.Stind_R4,
				OpCodes.Stind_R8,
				OpCodes.Nop,
				OpCodes.Nop,
				OpCodes.Nop,
				OpCodes.Stind_Ref
			};

			internal ProxyBuilder(ProxyAssembly assembly, TypeBuilder tb, Type proxyBaseType)
			{
				_assembly = assembly;
				_tb = tb;
				_proxyBaseType = proxyBaseType;
				_fields = new List<FieldBuilder>();
				_fields.Add(tb.DefineField("invoke", typeof(Action<object[]>), FieldAttributes.Private));
			}

			private void Complete()
			{
				Type[] array = new Type[_fields.Count];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = _fields[i].FieldType;
				}
				ILGenerator iLGenerator = _tb.DefineConstructor(MethodAttributes.Public, CallingConventions.HasThis, array).GetILGenerator();
				ConstructorInfo con = _proxyBaseType.GetTypeInfo().DeclaredConstructors.SingleOrDefault((ConstructorInfo c) => c.IsPublic && c.GetParameters().Length == 0);
				iLGenerator.Emit(OpCodes.Ldarg_0);
				iLGenerator.Emit(OpCodes.Call, con);
				for (int num = 0; num < array.Length; num++)
				{
					iLGenerator.Emit(OpCodes.Ldarg_0);
					iLGenerator.Emit(OpCodes.Ldarg, num + 1);
					iLGenerator.Emit(OpCodes.Stfld, _fields[num]);
				}
				iLGenerator.Emit(OpCodes.Ret);
			}

			internal Type CreateType()
			{
				Complete();
				return _tb.CreateTypeInfo().AsType();
			}

			internal void AddInterfaceImpl(Type iface)
			{
				_assembly.EnsureTypeIsVisible(iface);
				_tb.AddInterfaceImplementation(iface);
				Dictionary<MethodInfo, PropertyAccessorInfo> dictionary = new Dictionary<MethodInfo, PropertyAccessorInfo>(MethodInfoEqualityComparer.Instance);
				foreach (PropertyInfo runtimeProperty in iface.GetRuntimeProperties())
				{
					PropertyAccessorInfo value = new PropertyAccessorInfo(runtimeProperty.GetMethod, runtimeProperty.SetMethod);
					if (runtimeProperty.GetMethod != null)
					{
						dictionary[runtimeProperty.GetMethod] = value;
					}
					if (runtimeProperty.SetMethod != null)
					{
						dictionary[runtimeProperty.SetMethod] = value;
					}
				}
				Dictionary<MethodInfo, EventAccessorInfo> dictionary2 = new Dictionary<MethodInfo, EventAccessorInfo>(MethodInfoEqualityComparer.Instance);
				foreach (EventInfo runtimeEvent in iface.GetRuntimeEvents())
				{
					EventAccessorInfo value2 = new EventAccessorInfo(runtimeEvent.AddMethod, runtimeEvent.RemoveMethod, runtimeEvent.RaiseMethod);
					if (runtimeEvent.AddMethod != null)
					{
						dictionary2[runtimeEvent.AddMethod] = value2;
					}
					if (runtimeEvent.RemoveMethod != null)
					{
						dictionary2[runtimeEvent.RemoveMethod] = value2;
					}
					if (runtimeEvent.RaiseMethod != null)
					{
						dictionary2[runtimeEvent.RaiseMethod] = value2;
					}
				}
				foreach (MethodInfo runtimeMethod in iface.GetRuntimeMethods())
				{
					MethodBuilder methodBuilder = AddMethodImpl(runtimeMethod);
					if (dictionary.TryGetValue(runtimeMethod, out var value3))
					{
						if (MethodInfoEqualityComparer.Instance.Equals(value3.InterfaceGetMethod, runtimeMethod))
						{
							value3.GetMethodBuilder = methodBuilder;
						}
						else
						{
							value3.SetMethodBuilder = methodBuilder;
						}
					}
					if (dictionary2.TryGetValue(runtimeMethod, out var value4))
					{
						if (MethodInfoEqualityComparer.Instance.Equals(value4.InterfaceAddMethod, runtimeMethod))
						{
							value4.AddMethodBuilder = methodBuilder;
						}
						else if (MethodInfoEqualityComparer.Instance.Equals(value4.InterfaceRemoveMethod, runtimeMethod))
						{
							value4.RemoveMethodBuilder = methodBuilder;
						}
						else
						{
							value4.RaiseMethodBuilder = methodBuilder;
						}
					}
				}
				foreach (PropertyInfo runtimeProperty2 in iface.GetRuntimeProperties())
				{
					PropertyAccessorInfo propertyAccessorInfo = dictionary[runtimeProperty2.GetMethod ?? runtimeProperty2.SetMethod];
					PropertyBuilder propertyBuilder = _tb.DefineProperty(runtimeProperty2.Name, runtimeProperty2.Attributes, runtimeProperty2.PropertyType, Enumerable.ToArray(from p in runtimeProperty2.GetIndexParameters()
						select p.ParameterType));
					if (propertyAccessorInfo.GetMethodBuilder != null)
					{
						propertyBuilder.SetGetMethod(propertyAccessorInfo.GetMethodBuilder);
					}
					if (propertyAccessorInfo.SetMethodBuilder != null)
					{
						propertyBuilder.SetSetMethod(propertyAccessorInfo.SetMethodBuilder);
					}
				}
				foreach (EventInfo runtimeEvent2 in iface.GetRuntimeEvents())
				{
					EventAccessorInfo eventAccessorInfo = dictionary2[runtimeEvent2.AddMethod ?? runtimeEvent2.RemoveMethod];
					EventBuilder eventBuilder = _tb.DefineEvent(runtimeEvent2.Name, runtimeEvent2.Attributes, runtimeEvent2.EventHandlerType);
					if (eventAccessorInfo.AddMethodBuilder != null)
					{
						eventBuilder.SetAddOnMethod(eventAccessorInfo.AddMethodBuilder);
					}
					if (eventAccessorInfo.RemoveMethodBuilder != null)
					{
						eventBuilder.SetRemoveOnMethod(eventAccessorInfo.RemoveMethodBuilder);
					}
					if (eventAccessorInfo.RaiseMethodBuilder != null)
					{
						eventBuilder.SetRaiseMethod(eventAccessorInfo.RaiseMethodBuilder);
					}
				}
			}

			private MethodBuilder AddMethodImpl(MethodInfo mi)
			{
				ParameterInfo[] parameters = mi.GetParameters();
				Type[] array = ParamTypes(parameters, noByRef: false);
				MethodBuilder methodBuilder = _tb.DefineMethod(mi.Name, MethodAttributes.Public | MethodAttributes.Virtual, mi.ReturnType, array);
				if (mi.ContainsGenericParameters)
				{
					Type[] genericArguments = mi.GetGenericArguments();
					string[] array2 = new string[genericArguments.Length];
					for (int i = 0; i < genericArguments.Length; i++)
					{
						array2[i] = genericArguments[i].Name;
					}
					GenericTypeParameterBuilder[] array3 = methodBuilder.DefineGenericParameters(array2);
					for (int j = 0; j < array3.Length; j++)
					{
						array3[j].SetGenericParameterAttributes(genericArguments[j].GetTypeInfo().GenericParameterAttributes);
					}
				}
				ILGenerator iLGenerator = methodBuilder.GetILGenerator();
				ParametersArray parametersArray = new ParametersArray(iLGenerator, array);
				iLGenerator.Emit(OpCodes.Nop);
				GenericArray<object> genericArray = new GenericArray<object>(iLGenerator, ParamTypes(parameters, noByRef: true).Length);
				for (int k = 0; k < parameters.Length; k++)
				{
					if (!parameters[k].IsOut)
					{
						genericArray.BeginSet(k);
						parametersArray.Get(k);
						genericArray.EndSet(parameters[k].ParameterType);
					}
				}
				GenericArray<object> genericArray2 = new GenericArray<object>(iLGenerator, PackedArgs.PackedTypes.Length);
				genericArray2.BeginSet(0);
				iLGenerator.Emit(OpCodes.Ldarg_0);
				genericArray2.EndSet(typeof(DispatchProxy));
				MethodInfo runtimeMethod = typeof(Type).GetRuntimeMethod("GetTypeFromHandle", new Type[1] { typeof(RuntimeTypeHandle) });
				_assembly.GetTokenForMethod(mi, out var type, out var token);
				genericArray2.BeginSet(1);
				iLGenerator.Emit(OpCodes.Ldtoken, type);
				iLGenerator.Emit(OpCodes.Call, runtimeMethod);
				genericArray2.EndSet(typeof(object));
				genericArray2.BeginSet(2);
				iLGenerator.Emit(OpCodes.Ldc_I4, token);
				genericArray2.EndSet(typeof(int));
				genericArray2.BeginSet(3);
				genericArray.Load();
				genericArray2.EndSet(typeof(object[]));
				if (mi.ContainsGenericParameters)
				{
					genericArray2.BeginSet(4);
					Type[] genericArguments2 = mi.GetGenericArguments();
					GenericArray<Type> genericArray3 = new GenericArray<Type>(iLGenerator, genericArguments2.Length);
					for (int l = 0; l < genericArguments2.Length; l++)
					{
						genericArray3.BeginSet(l);
						iLGenerator.Emit(OpCodes.Ldtoken, genericArguments2[l]);
						iLGenerator.Emit(OpCodes.Call, runtimeMethod);
						genericArray3.EndSet(typeof(Type));
					}
					genericArray3.Load();
					genericArray2.EndSet(typeof(Type[]));
				}
				iLGenerator.Emit(OpCodes.Ldarg_0);
				iLGenerator.Emit(OpCodes.Ldfld, _fields[0]);
				genericArray2.Load();
				iLGenerator.Emit(OpCodes.Call, s_delegateInvoke);
				for (int m = 0; m < parameters.Length; m++)
				{
					if (parameters[m].ParameterType.IsByRef)
					{
						parametersArray.BeginSet(m);
						genericArray.Get(m);
						parametersArray.EndSet(m, typeof(object));
					}
				}
				if (mi.ReturnType != typeof(void))
				{
					genericArray2.Get(5);
					Convert(iLGenerator, typeof(object), mi.ReturnType, isAddress: false);
				}
				iLGenerator.Emit(OpCodes.Ret);
				_tb.DefineMethodOverride(methodBuilder, mi);
				return methodBuilder;
			}

			private static Type[] ParamTypes(ParameterInfo[] parms, bool noByRef)
			{
				Type[] array = new Type[parms.Length];
				for (int i = 0; i < parms.Length; i++)
				{
					array[i] = parms[i].ParameterType;
					if (noByRef && array[i].IsByRef)
					{
						array[i] = array[i].GetElementType();
					}
				}
				return array;
			}

			private static int GetTypeCode(Type type)
			{
				if (type == null)
				{
					return 0;
				}
				if (type == typeof(bool))
				{
					return 3;
				}
				if (type == typeof(char))
				{
					return 4;
				}
				if (type == typeof(sbyte))
				{
					return 5;
				}
				if (type == typeof(byte))
				{
					return 6;
				}
				if (type == typeof(short))
				{
					return 7;
				}
				if (type == typeof(ushort))
				{
					return 8;
				}
				if (type == typeof(int))
				{
					return 9;
				}
				if (type == typeof(uint))
				{
					return 10;
				}
				if (type == typeof(long))
				{
					return 11;
				}
				if (type == typeof(ulong))
				{
					return 12;
				}
				if (type == typeof(float))
				{
					return 13;
				}
				if (type == typeof(double))
				{
					return 14;
				}
				if (type == typeof(decimal))
				{
					return 15;
				}
				if (type == typeof(DateTime))
				{
					return 16;
				}
				if (type == typeof(string))
				{
					return 18;
				}
				if (type.GetTypeInfo().IsEnum)
				{
					return GetTypeCode(Enum.GetUnderlyingType(type));
				}
				return 1;
			}

			private static void Convert(ILGenerator il, Type source, Type target, bool isAddress)
			{
				if (target == source)
				{
					return;
				}
				TypeInfo typeInfo = source.GetTypeInfo();
				TypeInfo typeInfo2 = target.GetTypeInfo();
				if (source.IsByRef)
				{
					Type elementType = source.GetElementType();
					Ldind(il, elementType);
					Convert(il, elementType, target, isAddress);
				}
				else if (typeInfo2.IsValueType)
				{
					if (typeInfo.IsValueType)
					{
						OpCode opcode = s_convOpCodes[GetTypeCode(target)];
						il.Emit(opcode);
						return;
					}
					il.Emit(OpCodes.Unbox, target);
					if (!isAddress)
					{
						Ldind(il, target);
					}
				}
				else if (typeInfo2.IsAssignableFrom(typeInfo))
				{
					if (typeInfo.IsValueType || source.IsGenericParameter)
					{
						if (isAddress)
						{
							Ldind(il, source);
						}
						il.Emit(OpCodes.Box, source);
					}
				}
				else if (target.IsGenericParameter)
				{
					il.Emit(OpCodes.Unbox_Any, target);
				}
				else
				{
					il.Emit(OpCodes.Castclass, target);
				}
			}

			private static void Ldind(ILGenerator il, Type type)
			{
				OpCode opcode = s_ldindOpCodes[GetTypeCode(type)];
				if (!opcode.Equals(OpCodes.Nop))
				{
					il.Emit(opcode);
				}
				else
				{
					il.Emit(OpCodes.Ldobj, type);
				}
			}

			private static void Stind(ILGenerator il, Type type)
			{
				OpCode opcode = s_stindOpCodes[GetTypeCode(type)];
				if (!opcode.Equals(OpCodes.Nop))
				{
					il.Emit(opcode);
				}
				else
				{
					il.Emit(OpCodes.Stobj, type);
				}
			}
		}

		private const int InvokeActionFieldAndCtorParameterIndex = 0;

		private static readonly Dictionary<Type, Dictionary<Type, Type>> s_baseTypeAndInterfaceToGeneratedProxyType = new Dictionary<Type, Dictionary<Type, Type>>();

		private static readonly ProxyAssembly s_proxyAssembly = new ProxyAssembly();

		private static readonly MethodInfo s_dispatchProxyInvokeMethod = typeof(DispatchProxy).GetTypeInfo().GetDeclaredMethod("Invoke");

		internal static object CreateProxyInstance(Type baseType, Type interfaceType)
		{
			return Activator.CreateInstance(GetProxyType(baseType, interfaceType), new Action<object[]>(Invoke));
		}

		private static Type GetProxyType(Type baseType, Type interfaceType)
		{
			lock (s_baseTypeAndInterfaceToGeneratedProxyType)
			{
				Dictionary<Type, Type> value = null;
				if (!s_baseTypeAndInterfaceToGeneratedProxyType.TryGetValue(baseType, out value))
				{
					value = new Dictionary<Type, Type>();
					s_baseTypeAndInterfaceToGeneratedProxyType[baseType] = value;
				}
				Type value2 = null;
				if (!value.TryGetValue(interfaceType, out value2))
				{
					value2 = (value[interfaceType] = GenerateProxyType(baseType, interfaceType));
				}
				return value2;
			}
		}

		private static Type GenerateProxyType(Type baseType, Type interfaceType)
		{
			TypeInfo typeInfo = baseType.GetTypeInfo();
			if (!interfaceType.GetTypeInfo().IsInterface)
			{
				throw new ArgumentException(SR.Format("The type '{0}' must be an interface, not a class.", interfaceType.FullName), "T");
			}
			if (typeInfo.IsSealed)
			{
				throw new ArgumentException(SR.Format("The base type '{0}' cannot be sealed.", typeInfo.FullName), "TProxy");
			}
			if (typeInfo.IsAbstract)
			{
				throw new ArgumentException(SR.Format("The base type '{0}' cannot be abstract.", baseType.FullName), "TProxy");
			}
			if (!typeInfo.DeclaredConstructors.Any((ConstructorInfo c) => c.IsPublic && c.GetParameters().Length == 0))
			{
				throw new ArgumentException(SR.Format("The base type '{0}' must have a public parameterless constructor.", baseType.FullName), "TProxy");
			}
			ProxyBuilder proxyBuilder = s_proxyAssembly.CreateProxy("generatedProxy", baseType);
			foreach (Type implementedInterface in interfaceType.GetTypeInfo().ImplementedInterfaces)
			{
				proxyBuilder.AddInterfaceImpl(implementedInterface);
			}
			proxyBuilder.AddInterfaceImpl(interfaceType);
			return proxyBuilder.CreateType();
		}

		private static void Invoke(object[] args)
		{
			PackedArgs packedArgs = new PackedArgs(args);
			MethodBase methodBase = s_proxyAssembly.ResolveMethodToken(packedArgs.DeclaringType, packedArgs.MethodToken);
			if (methodBase.IsGenericMethodDefinition)
			{
				methodBase = ((MethodInfo)methodBase).MakeGenericMethod(packedArgs.GenericTypes);
			}
			try
			{
				object returnValue = s_dispatchProxyInvokeMethod.Invoke(packedArgs.DispatchProxy, new object[2] { methodBase, packedArgs.Args });
				packedArgs.ReturnValue = returnValue;
			}
			catch (TargetInvocationException ex)
			{
				ExceptionDispatchInfo.Capture(ex.InnerException).Throw();
			}
		}
	}
}
namespace System.Net.Sockets
{
	public sealed class UnixDomainSocketEndPoint : EndPoint
	{
		private static readonly int s_nativePathOffset = 2;

		private static readonly int s_nativePathLength = 108;

		private static readonly int s_nativeAddressSize = s_nativePathOffset + s_nativePathLength;

		private const AddressFamily EndPointAddressFamily = AddressFamily.Unix;

		private static readonly Encoding s_pathEncoding = Encoding.UTF8;

		private static readonly Lazy<bool> s_udsSupported = new Lazy<bool>(delegate
		{
			try
			{
				new Socket(AddressFamily.Unix, SocketType.Stream, ProtocolType.IP).Dispose();
				return true;
			}
			catch
			{
				return false;
			}
		});

		private readonly string _path;

		private readonly byte[] _encodedPath;

		public override AddressFamily AddressFamily => AddressFamily.Unix;

		private SocketAddress CreateSocketAddressForSerialize()
		{
			return new SocketAddress(AddressFamily.Unix, s_nativeAddressSize);
		}

		public UnixDomainSocketEndPoint(string path)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			bool num = IsAbstract(path);
			int num2 = s_pathEncoding.GetByteCount(path);
			if (!num)
			{
				num2++;
			}
			if (path.Length == 0 || num2 > s_nativePathLength)
			{
				throw new ArgumentOutOfRangeException("path", path, SR.Format("The path '{0}' is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and {1} characters, inclusive.", path, s_nativePathLength));
			}
			_path = path;
			_encodedPath = new byte[num2];
			s_pathEncoding.GetBytes(path, 0, path.Length, _encodedPath, 0);
			if (!s_udsSupported.Value)
			{
				throw new PlatformNotSupportedException();
			}
		}

		internal UnixDomainSocketEndPoint(SocketAddress socketAddress)
		{
			if (socketAddress == null)
			{
				throw new ArgumentNullException("socketAddress");
			}
			if (socketAddress.Family != AddressFamily.Unix || socketAddress.Size > s_nativeAddressSize)
			{
				throw new ArgumentOutOfRangeException("socketAddress");
			}
			if (socketAddress.Size > s_nativePathOffset)
			{
				_encodedPath = new byte[socketAddress.Size - s_nativePathOffset];
				for (int i = 0; i < _encodedPath.Length; i++)
				{
					_encodedPath[i] = socketAddress[s_nativePathOffset + i];
				}
				int num = _encodedPath.Length;
				if (!IsAbstract(_encodedPath))
				{
					while (_encodedPath[num - 1] == 0)
					{
						num--;
					}
				}
				_path = s_pathEncoding.GetString(_encodedPath, 0, num);
			}
			else
			{
				_encodedPath = Array.Empty<byte>();
				_path = string.Empty;
			}
		}

		public override SocketAddress Serialize()
		{
			SocketAddress socketAddress = CreateSocketAddressForSerialize();
			for (int i = 0; i < _encodedPath.Length; i++)
			{
				socketAddress[s_nativePathOffset + i] = _encodedPath[i];
			}
			return socketAddress;
		}

		public override EndPoint Create(SocketAddress socketAddress)
		{
			return new UnixDomainSocketEndPoint(socketAddress);
		}

		public override string ToString()
		{
			if (IsAbstract(_path))
			{
				return "@" + _path.Substring(1);
			}
			return _path;
		}

		private static bool IsAbstract(string path)
		{
			if (path.Length > 0)
			{
				return path[0] == '\0';
			}
			return false;
		}

		private static bool IsAbstract(byte[] encodedPath)
		{
			if (encodedPath.Length != 0)
			{
				return encodedPath[0] == 0;
			}
			return false;
		}
	}
}
namespace System.Linq
{
	/// <summary>Provides functionality to evaluate queries against a specific data source wherein the type of the data is not specified.</summary>
	public interface IQueryable : IEnumerable
	{
		/// <summary>Gets the expression tree that is associated with the instance of <see cref="T:System.Linq.IQueryable" />.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.Expression" /> that is associated with this instance of <see cref="T:System.Linq.IQueryable" />.</returns>
		Expression Expression { get; }

		/// <summary>Gets the type of the element(s) that are returned when the expression tree associated with this instance of <see cref="T:System.Linq.IQueryable" /> is executed.</summary>
		/// <returns>A <see cref="T:System.Type" /> that represents the type of the element(s) that are returned when the expression tree associated with this object is executed.</returns>
		Type ElementType { get; }

		/// <summary>Gets the query provider that is associated with this data source.</summary>
		/// <returns>The <see cref="T:System.Linq.IQueryProvider" /> that is associated with this data source.</returns>
		IQueryProvider Provider { get; }
	}
	/// <summary>Provides functionality to evaluate queries against a specific data source wherein the type of the data is known.</summary>
	/// <typeparam name="T">The type of the data in the data source.</typeparam>
	public interface IQueryable<out T> : IEnumerable<T>, IEnumerable, IQueryable
	{
	}
	/// <summary>Defines methods to create and execute queries that are described by an <see cref="T:System.Linq.IQueryable" /> object.</summary>
	public interface IQueryProvider
	{
		/// <summary>Constructs an <see cref="T:System.Linq.IQueryable" /> object that can evaluate the query represented by a specified expression tree.</summary>
		/// <param name="expression">An expression tree that represents a LINQ query.</param>
		/// <returns>An <see cref="T:System.Linq.IQueryable" /> that can evaluate the query represented by the specified expression tree.</returns>
		IQueryable CreateQuery(Expression expression);

		/// <summary>Constructs an <see cref="T:System.Linq.IQueryable`1" /> object that can evaluate the query represented by a specified expression tree.</summary>
		/// <param name="expression">An expression tree that represents a LINQ query.</param>
		/// <typeparam name="TElement">The type of the elements of the <see cref="T:System.Linq.IQueryable`1" /> that is returned.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that can evaluate the query represented by the specified expression tree.</returns>
		IQueryable<TElement> CreateQuery<TElement>(Expression expression);

		/// <summary>Executes the query represented by a specified expression tree.</summary>
		/// <param name="expression">An expression tree that represents a LINQ query.</param>
		/// <returns>The value that results from executing the specified query.</returns>
		object Execute(Expression expression);

		/// <summary>Executes the strongly-typed query represented by a specified expression tree.</summary>
		/// <param name="expression">An expression tree that represents a LINQ query.</param>
		/// <typeparam name="TResult">The type of the value that results from executing the query.</typeparam>
		/// <returns>The value that results from executing the specified query.</returns>
		TResult Execute<TResult>(Expression expression);
	}
	/// <summary>Represents the result of a sorting operation.</summary>
	public interface IOrderedQueryable : IQueryable, IEnumerable
	{
	}
	/// <summary>Represents the result of a sorting operation.</summary>
	/// <typeparam name="T">The type of the content of the data source.</typeparam>
	public interface IOrderedQueryable<out T> : IQueryable<T>, IEnumerable<T>, IEnumerable, IQueryable, IOrderedQueryable
	{
	}
	internal static class AggregationMinMaxHelpers<T>
	{
		private static T Reduce(IEnumerable<T> source, int sign)
		{
			Func<Pair<bool, T>, T, Pair<bool, T>> intermediateReduce = MakeIntermediateReduceFunction(sign);
			Func<Pair<bool, T>, Pair<bool, T>, Pair<bool, T>> finalReduce = MakeFinalReduceFunction(sign);
			Func<Pair<bool, T>, T> resultSelector = MakeResultSelectorFunction();
			return new AssociativeAggregationOperator<T, Pair<bool, T>, T>(source, new Pair<bool, T>(first: false, default(T)), null, seedIsSpecified: true, intermediateReduce, finalReduce, resultSelector, default(T) != null, QueryAggregationOptions.AssociativeCommutative).Aggregate();
		}

		internal static T ReduceMin(IEnumerable<T> source)
		{
			return Reduce(source, -1);
		}

		internal static T ReduceMax(IEnumerable<T> source)
		{
			return Reduce(source, 1);
		}

		private static Func<Pair<bool, T>, T, Pair<bool, T>> MakeIntermediateReduceFunction(int sign)
		{
			Comparer<T> comparer = Util.GetDefaultComparer<T>();
			return (Pair<bool, T> accumulator, T element) => ((default(T) != null || element != null) && (!accumulator.First || Util.Sign(comparer.Compare(element, accumulator.Second)) == sign)) ? new Pair<bool, T>(first: true, element) : accumulator;
		}

		private static Func<Pair<bool, T>, Pair<bool, T>, Pair<bool, T>> MakeFinalReduceFunction(int sign)
		{
			Comparer<T> comparer = Util.GetDefaultComparer<T>();
			return (Pair<bool, T> accumulator, Pair<bool, T> element) => (element.First && (!accumulator.First || Util.Sign(comparer.Compare(element.Second, accumulator.Second)) == sign)) ? new Pair<bool, T>(first: true, element.Second) : accumulator;
		}

		private static Func<Pair<bool, T>, T> MakeResultSelectorFunction()
		{
			return (Pair<bool, T> accumulator) => accumulator.Second;
		}
	}
	/// <summary>Represents a sorted, parallel sequence.</summary>
	/// <typeparam name="TSource">The type of elements in the source collection.</typeparam>
	public class OrderedParallelQuery<TSource> : ParallelQuery<TSource>
	{
		private QueryOperator<TSource> _sortOp;

		internal QueryOperator<TSource> SortOperator => _sortOp;

		internal IOrderedEnumerable<TSource> OrderedEnumerable => (IOrderedEnumerable<TSource>)_sortOp;

		internal OrderedParallelQuery(QueryOperator<TSource> sortOp)
			: base(sortOp.SpecifiedQuerySettings)
		{
			_sortOp = sortOp;
		}

		/// <summary>Returns an enumerator that iterates through the sequence.</summary>
		/// <returns>An enumerator that iterates through the sequence.</returns>
		public override IEnumerator<TSource> GetEnumerator()
		{
			return _sortOp.GetEnumerator();
		}

		internal OrderedParallelQuery()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents a parallel sequence.</summary>
	public class ParallelQuery : IEnumerable
	{
		private QuerySettings _specifiedSettings;

		internal QuerySettings SpecifiedQuerySettings => _specifiedSettings;

		internal ParallelQuery(QuerySettings specifiedSettings)
		{
			_specifiedSettings = specifiedSettings;
		}

		[ExcludeFromCodeCoverage]
		internal virtual ParallelQuery<TCastTo> Cast<TCastTo>()
		{
			throw new NotSupportedException();
		}

		[ExcludeFromCodeCoverage]
		internal virtual ParallelQuery<TCastTo> OfType<TCastTo>()
		{
			throw new NotSupportedException();
		}

		[ExcludeFromCodeCoverage]
		internal virtual IEnumerator GetEnumeratorUntyped()
		{
			throw new NotSupportedException();
		}

		/// <summary>Returns an enumerator that iterates through the sequence.</summary>
		/// <returns>An enumerator that iterates through the sequence.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumeratorUntyped();
		}

		internal ParallelQuery()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents a parallel sequence.</summary>
	/// <typeparam name="TSource">The type of element in the source sequence.</typeparam>
	public class ParallelQuery<TSource> : ParallelQuery, IEnumerable<TSource>, IEnumerable
	{
		internal ParallelQuery(QuerySettings settings)
			: base(settings)
		{
		}

		internal sealed override ParallelQuery<TCastTo> Cast<TCastTo>()
		{
			return this.Select((TSource elem) => (TCastTo)(object)elem);
		}

		internal sealed override ParallelQuery<TCastTo> OfType<TCastTo>()
		{
			return from elem in this
				where elem is TCastTo
				select (TCastTo)(object)elem;
		}

		internal override IEnumerator GetEnumeratorUntyped()
		{
			return ((IEnumerable<TSource>)this).GetEnumerator();
		}

		/// <summary>Returns an enumerator that iterates through the sequence.</summary>
		/// <returns>An enumerator that iterates through the sequence.</returns>
		public virtual IEnumerator<TSource> GetEnumerator()
		{
			throw new NotSupportedException();
		}

		internal ParallelQuery()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Provides a set of methods for querying objects that implement ParallelQuery{TSource}. This is the parallel equivalent of <see cref="T:System.Linq.Enumerable" />.</summary>
	public static class ParallelEnumerable
	{
		private const string RIGHT_SOURCE_NOT_PARALLEL_STR = "The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.";

		/// <summary>Enables parallelization of a query.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to convert to a <see cref="T:System.Linq.ParallelQuery`1" />.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The source as a <see cref="T:System.Linq.ParallelQuery`1" /> to bind to ParallelEnumerable extension methods.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		public static ParallelQuery<TSource> AsParallel<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new ParallelEnumerableWrapper<TSource>(source);
		}

		/// <summary>Enables parallelization of a query, as sourced by a custom partitioner that is responsible for splitting the input sequence into partitions.</summary>
		/// <param name="source">A partitioner over the input sequence.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The <paramref name="source" /> as a ParallelQuery to bind to ParallelEnumerable extension methods.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		public static ParallelQuery<TSource> AsParallel<TSource>(this Partitioner<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new PartitionerQueryOperator<TSource>(source);
		}

		/// <summary>Enables treatment of a data source as if it were ordered, overriding the default of unordered. AsOrdered may only be invoked on generic sequences returned by AsParallel, ParallelEnumerable.Range, and ParallelEnumerable.Repeat.</summary>
		/// <param name="source">The input sequence.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The source sequence which will maintain the original ordering in the subsequent query operators.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.InvalidOperationException">Thrown if <paramref name="source" /> contains no elements-or-if <paramref name="source" /> is not one of AsParallel, ParallelEnumerable.Range, or ParallelEnumerable.Repeat.</exception>
		public static ParallelQuery<TSource> AsOrdered<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (!(source is ParallelEnumerableWrapper<TSource>) && !(source is IParallelPartitionable<TSource>))
			{
				if (!(source is PartitionerQueryOperator<TSource> partitionerQueryOperator))
				{
					throw new InvalidOperationException("AsOrdered may only be called on the result of AsParallel, ParallelEnumerable.Range, or ParallelEnumerable.Repeat.");
				}
				if (!partitionerQueryOperator.Orderable)
				{
					throw new InvalidOperationException("AsOrdered may not be used with a partitioner that is not orderable.");
				}
			}
			return new OrderingQueryOperator<TSource>(QueryOperator<TSource>.AsQueryOperator(source), orderOn: true);
		}

		/// <summary>Enables treatment of a data source as if it were ordered, overriding the default of unordered. AsOrdered may only be invoked on non-generic sequences returned by AsParallel, ParallelEnumerable.Range, and ParallelEnumerable.Repeat.</summary>
		/// <param name="source">The input sequence.</param>
		/// <returns>The source sequence which will maintain the original ordering in the subsequent query operators.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.InvalidOperationException">thrown if <paramref name="source" /> contains no elements-or- if AsOrdered is called midway through a query. It is allowed to be called immediately after <see cref="M:System.Linq.ParallelEnumerable.AsParallel(System.Collections.IEnumerable)" />, <see cref="M:System.Linq.ParallelEnumerable.Range(System.Int32,System.Int32)" /> or <see cref="M:System.Linq.ParallelEnumerable.Repeat``1(``0,System.Int32)" />.</exception>
		public static ParallelQuery AsOrdered(this ParallelQuery source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new OrderingQueryOperator<object>(QueryOperator<object>.AsQueryOperator((source as ParallelEnumerableWrapper) ?? throw new InvalidOperationException("Non-generic AsOrdered may only be called on the result of the non-generic AsParallel.")), orderOn: true);
		}

		/// <summary>Allows an intermediate query to be treated as if no ordering is implied among the elements.</summary>
		/// <param name="source">The input sequence.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The source sequence with arbitrary order.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		public static ParallelQuery<TSource> AsUnordered<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new OrderingQueryOperator<TSource>(QueryOperator<TSource>.AsQueryOperator(source), orderOn: false);
		}

		/// <summary>Enables parallelization of a query.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to convert to a <see cref="T:System.Linq.ParallelQuery" />.</param>
		/// <returns>The source as a ParallelQuery to bind to ParallelEnumerable extension methods.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		public static ParallelQuery AsParallel(this IEnumerable source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new ParallelEnumerableWrapper(source);
		}

		/// <summary>Converts a <see cref="T:System.Linq.ParallelQuery`1" /> into an <see cref="T:System.Collections.Generic.IEnumerable`1" /> to force sequential evaluation of the query.</summary>
		/// <param name="source">A <see cref="T:System.Linq.ParallelQuery`1" /> to convert to an <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The source as an <see cref="T:System.Collections.Generic.IEnumerable`1" /> to bind to sequential extension methods.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		public static IEnumerable<TSource> AsSequential<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (source is ParallelEnumerableWrapper<TSource> parallelEnumerableWrapper)
			{
				return parallelEnumerableWrapper.WrappedEnumerable;
			}
			return source;
		}

		/// <summary>Sets the degree of parallelism to use in a query. Degree of parallelism is the maximum number of concurrently executing tasks that will be used to process the query.</summary>
		/// <param name="source">A ParallelQuery on which to set the limit on the degrees of parallelism.</param>
		/// <param name="degreeOfParallelism">The degree of parallelism for the query. The default value is Math.Min(<see cref="P:System.Environment.ProcessorCount" />, <see langword="MAX_SUPPORTED_DOP" />) where <see langword="MAX_SUPPORTED_DOP" /> is 512. </param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>ParallelQuery representing the same query as source, with the limit on the degrees of parallelism set.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="degreeOfParallelism" /> is less than 1 or greater than 511. </exception>
		/// <exception cref="T:System.InvalidOperationException">WithDegreeOfParallelism is used multiple times in the query.</exception>
		public static ParallelQuery<TSource> WithDegreeOfParallelism<TSource>(this ParallelQuery<TSource> source, int degreeOfParallelism)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (degreeOfParallelism < 1 || degreeOfParallelism > 512)
			{
				throw new ArgumentOutOfRangeException("degreeOfParallelism");
			}
			QuerySettings empty = QuerySettings.Empty;
			empty.DegreeOfParallelism = degreeOfParallelism;
			return new QueryExecutionOption<TSource>(QueryOperator<TSource>.AsQueryOperator(source), empty);
		}

		/// <summary>Sets the <see cref="T:System.Threading.CancellationToken" /> to associate with the query.</summary>
		/// <param name="source">A ParallelQuery on which to set the option.</param>
		/// <param name="cancellationToken">A cancellation token.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>ParallelQuery representing the same query as source, but with the registered cancellation token.</returns>
		/// <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <paramref name="cancellationToken" /> has been disposed.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="WithCancellation" /> is used multiple times in the query.</exception>
		public static ParallelQuery<TSource> WithCancellation<TSource>(this ParallelQuery<TSource> source, CancellationToken cancellationToken)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			QuerySettings empty = QuerySettings.Empty;
			empty.CancellationState = new CancellationState(cancellationToken);
			return new QueryExecutionOption<TSource>(QueryOperator<TSource>.AsQueryOperator(source), empty);
		}

		/// <summary>Sets the execution mode of the query.</summary>
		/// <param name="source">A ParallelQuery on which to set the option.</param>
		/// <param name="executionMode">The mode in which to execute the query.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>ParallelQuery representing the same query as source, but with the registered execution mode.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="executionMode" /> is not a valid <see cref="T:System.Linq.ParallelExecutionMode" /> value.</exception>
		/// <exception cref="T:System.InvalidOperationException">WithExecutionMode is used multiple times in the query.</exception>
		public static ParallelQuery<TSource> WithExecutionMode<TSource>(this ParallelQuery<TSource> source, ParallelExecutionMode executionMode)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (executionMode != ParallelExecutionMode.Default && executionMode != ParallelExecutionMode.ForceParallelism)
			{
				throw new ArgumentException("The executionMode argument contains an invalid value.");
			}
			QuerySettings empty = QuerySettings.Empty;
			empty.ExecutionMode = executionMode;
			return new QueryExecutionOption<TSource>(QueryOperator<TSource>.AsQueryOperator(source), empty);
		}

		/// <summary>Sets the merge options for this query, which specify how the query will buffer output.</summary>
		/// <param name="source">A ParallelQuery on which to set the option.</param>
		/// <param name="mergeOptions">The merge options to set for this query.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>ParallelQuery representing the same query as source, but with the registered merge options.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mergeOptions" /> is not a valid <see cref="T:System.Linq.ParallelMergeOptions" /> value.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="WithMergeOptions" /> is used multiple times in the query.</exception>
		public static ParallelQuery<TSource> WithMergeOptions<TSource>(this ParallelQuery<TSource> source, ParallelMergeOptions mergeOptions)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (mergeOptions != ParallelMergeOptions.Default && mergeOptions != ParallelMergeOptions.AutoBuffered && mergeOptions != ParallelMergeOptions.NotBuffered && mergeOptions != ParallelMergeOptions.FullyBuffered)
			{
				throw new ArgumentException("The mergeOptions argument contains an invalid value.");
			}
			QuerySettings empty = QuerySettings.Empty;
			empty.MergeOptions = mergeOptions;
			return new QueryExecutionOption<TSource>(QueryOperator<TSource>.AsQueryOperator(source), empty);
		}

		/// <summary>Generates a parallel sequence of integral numbers within a specified range.</summary>
		/// <param name="start">The value of the first integer in the sequence.</param>
		/// <param name="count">The number of sequential integers to generate.</param>
		/// <returns>An IEnumerable&lt;Int32&gt; in C# or IEnumerable(Of Int32) in Visual Basic that contains a range of sequential integral numbers.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="count" /> is less than 0 -or- <paramref name="start" /> + <paramref name="count" /> - 1 is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
		public static ParallelQuery<int> Range(int start, int count)
		{
			if (count < 0 || (count > 0 && int.MaxValue - (count - 1) < start))
			{
				throw new ArgumentOutOfRangeException("count");
			}
			return new RangeEnumerable(start, count);
		}

		/// <summary>Generates a parallel sequence that contains one repeated value.</summary>
		/// <param name="element">The value to be repeated.</param>
		/// <param name="count">The number of times to repeat the value in the generated sequence.</param>
		/// <typeparam name="TResult">The type of the value to be repeated in the result sequence.</typeparam>
		/// <returns>A sequence that contains a repeated value.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="count" /> is less than 0.</exception>
		public static ParallelQuery<TResult> Repeat<TResult>(TResult element, int count)
		{
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			return new RepeatEnumerable<TResult>(element, count);
		}

		/// <summary>Returns an empty ParallelQuery{TResult} that has the specified type argument.</summary>
		/// <typeparam name="TResult">The type to assign to the type parameter of the returned generic sequence.</typeparam>
		/// <returns>An empty sequence whose type argument is <paramref name="TResult" />.</returns>
		public static ParallelQuery<TResult> Empty<TResult>()
		{
			return EmptyEnumerable<TResult>.Instance;
		}

		/// <summary>Invokes in parallel the specified action for each element in the <paramref name="source" />.</summary>
		/// <param name="source">The <see cref="T:System.Linq.ParallelQuery`1" /> whose elements will be processed by <paramref name="action" />.</param>
		/// <param name="action">An Action to invoke on each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static void ForAll<TSource>(this ParallelQuery<TSource> source, Action<TSource> action)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (action == null)
			{
				throw new ArgumentNullException("action");
			}
			new ForAllOperator<TSource>(source, action).RunSynchronously();
		}

		/// <summary>Filters in parallel a sequence of values based on a predicate.</summary>
		/// <param name="source">A sequence to filter.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of source.</typeparam>
		/// <returns>A sequence that contains elements from the input sequence that satisfy the condition.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> Where<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			return new WhereQueryOperator<TSource>(source, predicate);
		}

		/// <summary>Filters in parallel a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.</summary>
		/// <param name="source">A sequence to filter.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of source.</typeparam>
		/// <returns>A sequence that contains elements from the input sequence that satisfy the condition.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.OverflowException">More than <see cref="F:System.Int32.MaxValue" /> elements are enumerated by the query.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> Where<TSource>(this ParallelQuery<TSource> source, Func<TSource, int, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			return new IndexedWhereQueryOperator<TSource>(source, predicate);
		}

		/// <summary>Projects in parallel each element of a sequence into a new form.</summary>
		/// <param name="source">A sequence of values to invoke a transform function on.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of elements resturned by selector.</typeparam>
		/// <returns>A sequence whose elements are the result of invoking the transform function on each element of <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> Select<TSource, TResult>(this ParallelQuery<TSource> source, Func<TSource, TResult> selector)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (selector == null)
			{
				throw new ArgumentNullException("selector");
			}
			return new SelectQueryOperator<TSource, TResult>(source, selector);
		}

		/// <summary>Projects in parallel each element of a sequence into a new form by incorporating the element's index.</summary>
		/// <param name="source">A sequence of values to invoke a transform function on.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of elements resturned by selector.</typeparam>
		/// <returns>A sequence whose elements are the result of invoking the transform function on each element of <paramref name="source" />, based on the index supplied to <paramref name="selector" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.OverflowException">More than <see cref="F:System.Int32.MaxValue" /> elements are enumerated by the query. This condition might occur in streaming scenarios.</exception>
		public static ParallelQuery<TResult> Select<TSource, TResult>(this ParallelQuery<TSource> source, Func<TSource, int, TResult> selector)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (selector == null)
			{
				throw new ArgumentNullException("selector");
			}
			return new IndexedSelectQueryOperator<TSource, TResult>(source, selector);
		}

		/// <summary>Merges in parallel two sequences by using the specified predicate function.</summary>
		/// <param name="first">The first sequence to zip.</param>
		/// <param name="second">The second sequence to zip.</param>
		/// <param name="resultSelector">A function to create a result element from two matching elements.</param>
		/// <typeparam name="TFirst">The type of the elements of the first sequence.</typeparam>
		/// <typeparam name="TSecond">The type of the elements of the second sequence.</typeparam>
		/// <typeparam name="TResult">The type of the return elements.</typeparam>
		/// <returns>A sequence that has elements of type <paramref name="TResult" /> that are obtained by performing <paramref name="resultSelector" /> pairwise on two sequences. If the sequence lengths are unequal, this truncates to the length of the shorter sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> or <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> Zip<TFirst, TSecond, TResult>(this ParallelQuery<TFirst> first, ParallelQuery<TSecond> second, Func<TFirst, TSecond, TResult> resultSelector)
		{
			if (first == null)
			{
				throw new ArgumentNullException("first");
			}
			if (second == null)
			{
				throw new ArgumentNullException("second");
			}
			if (resultSelector == null)
			{
				throw new ArgumentNullException("resultSelector");
			}
			return new ZipQueryOperator<TFirst, TSecond, TResult>(first, second, resultSelector);
		}

		/// <summary>This Zip overload should never be called. This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when invoked.</summary>
		/// <param name="first">This parameter is not used.</param>
		/// <param name="second">This parameter is not used.</param>
		/// <param name="resultSelector">This parameter is not used.</param>
		/// <typeparam name="TFirst">This type parameter is not used.</typeparam>
		/// <typeparam name="TSecond">This type parameter is not used.</typeparam>
		/// <typeparam name="TResult">This type parameter is not used.</typeparam>
		/// <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
		/// <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
		[Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
		public static ParallelQuery<TResult> Zip<TFirst, TSecond, TResult>(this ParallelQuery<TFirst> first, IEnumerable<TSecond> second, Func<TFirst, TSecond, TResult> resultSelector)
		{
			throw new NotSupportedException("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.");
		}

		/// <summary>Correlates in parallel the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.</summary>
		/// <param name="outer">The first sequence to join.</param>
		/// <param name="inner">The sequence to join to the first sequence.</param>
		/// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
		/// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
		/// <param name="resultSelector">A function to create a result element from two matching elements.</param>
		/// <typeparam name="TOuter">The type of the elements of the second sequence.</typeparam>
		/// <typeparam name="TInner">The type of the elements of the first sequence.</typeparam>
		/// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
		/// <typeparam name="TResult">The type of the result elements.</typeparam>
		/// <returns>A sequence that has elements of type <paramref name="TResult" /> that are obtained by performing an inner join on two sequences.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> Join<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, ParallelQuery<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector)
		{
			return outer.Join(inner, outerKeySelector, innerKeySelector, resultSelector, null);
		}

		/// <summary>This Join overload should never be called. This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when invoked.</summary>
		/// <param name="outer">This parameter is not used.</param>
		/// <param name="inner">This parameter is not used.</param>
		/// <param name="outerKeySelector">This parameter is not used.</param>
		/// <param name="innerKeySelector">This parameter is not used.</param>
		/// <param name="resultSelector">This parameter is not used.</param>
		/// <typeparam name="TOuter">This type parameter is not used.</typeparam>
		/// <typeparam name="TInner">This type parameter is not used.</typeparam>
		/// <typeparam name="TKey">This type parameter is not used.</typeparam>
		/// <typeparam name="TResult">This type parameter is not used.</typeparam>
		/// <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		[Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
		public static ParallelQuery<TResult> Join<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector)
		{
			throw new NotSupportedException("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.");
		}

		/// <summary>Correlates in parallel the elements of two sequences based on matching keys. A specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> is used to compare keys.</summary>
		/// <param name="outer">The first sequence to join.</param>
		/// <param name="inner">The sequence to join to the first sequence.</param>
		/// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
		/// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
		/// <param name="resultSelector">A function to create a result element from two matching elements.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to hash and compare keys.</param>
		/// <typeparam name="TOuter">The type of the elements of the second sequence.</typeparam>
		/// <typeparam name="TInner">The type of the elements of the first sequence.</typeparam>
		/// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
		/// <typeparam name="TResult">The type of the result elements.</typeparam>
		/// <returns>A sequence that has elements of type <paramref name="TResult" /> that are obtained by performing an inner join on two sequences.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> Join<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, ParallelQuery<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (outer == null)
			{
				throw new ArgumentNullException("outer");
			}
			if (inner == null)
			{
				throw new ArgumentNullException("inner");
			}
			if (outerKeySelector == null)
			{
				throw new ArgumentNullException("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw new ArgumentNullException("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw new ArgumentNullException("resultSelector");
			}
			return new JoinQueryOperator<TOuter, TInner, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
		}

		/// <summary>This Join overload should never be called. This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when invoked.</summary>
		/// <param name="outer">This parameter is not used.</param>
		/// <param name="inner">This parameter is not used.</param>
		/// <param name="outerKeySelector">This parameter is not used.</param>
		/// <param name="innerKeySelector">This parameter is not used.</param>
		/// <param name="resultSelector">This parameter is not used.</param>
		/// <param name="comparer">This parameter is not used.</param>
		/// <typeparam name="TOuter">This type parameter is not used.</typeparam>
		/// <typeparam name="TInner">This type parameter is not used.</typeparam>
		/// <typeparam name="TKey">This type parameter is not used.</typeparam>
		/// <typeparam name="TResult">This type parameter is not used.</typeparam>
		/// <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
		/// <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
		[Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
		public static ParallelQuery<TResult> Join<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			throw new NotSupportedException("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.");
		}

		/// <summary>Correlates in parallel the elements of two sequences based on equality of keys and groups the results. The default equality comparer is used to compare keys.</summary>
		/// <param name="outer">The first sequence to join.</param>
		/// <param name="inner">The sequence to join to the first sequence.</param>
		/// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
		/// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
		/// <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
		/// <typeparam name="TOuter">The type of the elements of the second sequence.</typeparam>
		/// <typeparam name="TInner">The type of the elements of the first sequence.</typeparam>
		/// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
		/// <typeparam name="TResult">The type of the result elements.</typeparam>
		/// <returns>A sequence that has elements of type <paramref name="TResult" /> that are obtained by performing a grouped join on two sequences.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, ParallelQuery<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector)
		{
			return outer.GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector, null);
		}

		/// <summary>This GroupJoin overload should never be called. This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.</summary>
		/// <param name="outer">This parameter is not used.</param>
		/// <param name="inner">This parameter is not used.</param>
		/// <param name="outerKeySelector">This parameter is not used.</param>
		/// <param name="innerKeySelector">This parameter is not used.</param>
		/// <param name="resultSelector">This parameter is not used.</param>
		/// <typeparam name="TOuter">This type parameter is not used.</typeparam>
		/// <typeparam name="TInner">This type parameter is not used.</typeparam>
		/// <typeparam name="TKey">This type parameter is not used.</typeparam>
		/// <typeparam name="TResult">This type parameter is not used.</typeparam>
		/// <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		[Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
		public static ParallelQuery<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector)
		{
			throw new NotSupportedException("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.");
		}

		/// <summary>Correlates in parallel the elements of two sequences based on key equality and groups the results. A specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> is used to compare keys.</summary>
		/// <param name="outer">The first sequence to join.</param>
		/// <param name="inner">The sequence to join to the first sequence.</param>
		/// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
		/// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
		/// <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to hash and compare keys.</param>
		/// <typeparam name="TOuter">The type of the elements of the second sequence.</typeparam>
		/// <typeparam name="TInner">The type of the elements of the first sequence.</typeparam>
		/// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
		/// <typeparam name="TResult">The type of the result elements.</typeparam>
		/// <returns>A sequence that has elements of type <paramref name="TResult" /> that are obtained by performing a grouped join on two sequences.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, ParallelQuery<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (outer == null)
			{
				throw new ArgumentNullException("outer");
			}
			if (inner == null)
			{
				throw new ArgumentNullException("inner");
			}
			if (outerKeySelector == null)
			{
				throw new ArgumentNullException("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw new ArgumentNullException("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw new ArgumentNullException("resultSelector");
			}
			return new GroupJoinQueryOperator<TOuter, TInner, TKey, TResult>(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
		}

		/// <summary>This GroupJoin overload should never be called. This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.</summary>
		/// <param name="outer">This parameter is not used.</param>
		/// <param name="inner">This parameter is not used.</param>
		/// <param name="outerKeySelector">This parameter is not used.</param>
		/// <param name="innerKeySelector">This parameter is not used.</param>
		/// <param name="resultSelector">This parameter is not used.</param>
		/// <param name="comparer">This parameter is not used.</param>
		/// <typeparam name="TOuter">This type parameter is not used.</typeparam>
		/// <typeparam name="TInner">This type parameter is not used.</typeparam>
		/// <typeparam name="TKey">This type parameter is not used.</typeparam>
		/// <typeparam name="TResult">This type parameter is not used.</typeparam>
		/// <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
		/// <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
		[Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
		public static ParallelQuery<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this ParallelQuery<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			throw new NotSupportedException("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.");
		}

		/// <summary>Projects in parallel each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" /> and flattens the resulting sequences into one sequence.</summary>
		/// <param name="source">A sequence of values to project.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the sequence returned by selector.</typeparam>
		/// <returns>A sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> SelectMany<TSource, TResult>(this ParallelQuery<TSource> source, Func<TSource, IEnumerable<TResult>> selector)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (selector == null)
			{
				throw new ArgumentNullException("selector");
			}
			return new SelectManyQueryOperator<TSource, TResult, TResult>(source, selector, null, null);
		}

		/// <summary>Projects in parallel each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" />, and flattens the resulting sequences into one sequence. The index of each source element is used in the projected form of that element.</summary>
		/// <param name="source">A sequence of values to project.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the sequence returned by selector.</typeparam>
		/// <returns>A sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.OverflowException">More than <see cref="F:System.Int32.MaxValue" /> elements are enumerated by the query.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> SelectMany<TSource, TResult>(this ParallelQuery<TSource> source, Func<TSource, int, IEnumerable<TResult>> selector)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (selector == null)
			{
				throw new ArgumentNullException("selector");
			}
			return new SelectManyQueryOperator<TSource, TResult, TResult>(source, null, selector, null);
		}

		/// <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" />, flattens the resulting sequences into one sequence, and invokes a result selector function on each element therein.</summary>
		/// <param name="source">A sequence of values to project.</param>
		/// <param name="collectionSelector">A transform function to apply to each source element; the second parameter of the function represents the index of the source element.</param>
		/// <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
		/// <typeparam name="TSource">The type of the intermediate elements collected by <paramref name="collectionSelector" />.</typeparam>
		/// <typeparam name="TCollection">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of elements in the result sequence.</typeparam>
		/// <returns>A sequence whose elements are the result of invoking the one-to-many transform function <paramref name="collectionSelector" /> on each element of <paramref name="source" /> based on the index supplied to <paramref name="collectionSelector" />, and then mapping each of those sequence elements and their corresponding source element to a result element. </returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.OverflowException">More than <see cref="F:System.Int32.MaxValue" /> elements are enumerated by the query.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> SelectMany<TSource, TCollection, TResult>(this ParallelQuery<TSource> source, Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (collectionSelector == null)
			{
				throw new ArgumentNullException("collectionSelector");
			}
			if (resultSelector == null)
			{
				throw new ArgumentNullException("resultSelector");
			}
			return new SelectManyQueryOperator<TSource, TCollection, TResult>(source, collectionSelector, null, resultSelector);
		}

		/// <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" />, flattens the resulting sequences into one sequence, and invokes a result selector function on each element therein. The index of each source element is used in the intermediate projected form of that element.</summary>
		/// <param name="source">A sequence of values to project.</param>
		/// <param name="collectionSelector">A transform function to apply to each source element; the second parameter of the function represents the index of the source element.</param>
		/// <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
		/// <typeparam name="TSource">The type of the intermediate elements collected by <paramref name="collectionSelector" />.</typeparam>
		/// <typeparam name="TCollection">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of elements to return.</typeparam>
		/// <returns>A sequence whose elements are the result of invoking the one-to-many transform function <paramref name="collectionSelector" /> on each element of <paramref name="source" /> based on the index supplied to <paramref name="collectionSelector" />, and then mapping each of those sequence elements and their corresponding source element to a result element.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.OverflowException">More than <see cref="F:System.Int32.MaxValue" /> elements are enumerated by the query.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> SelectMany<TSource, TCollection, TResult>(this ParallelQuery<TSource> source, Func<TSource, int, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (collectionSelector == null)
			{
				throw new ArgumentNullException("collectionSelector");
			}
			if (resultSelector == null)
			{
				throw new ArgumentNullException("resultSelector");
			}
			return new SelectManyQueryOperator<TSource, TCollection, TResult>(source, null, collectionSelector, resultSelector);
		}

		/// <summary>Sorts in parallel the elements of a sequence in ascending order according to a key.</summary>
		/// <param name="source">A sequence of values to order.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An OrderedParallelQuery{TSource} whose elements are sorted according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static OrderedParallelQuery<TSource> OrderBy<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			return new OrderedParallelQuery<TSource>(new SortQueryOperator<TSource, TKey>(source, keySelector, null, descending: false));
		}

		/// <summary>Sorts in parallel the elements of a sequence in ascending order by using a specified comparer.</summary>
		/// <param name="source">A sequence of values to order.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <param name="comparer">An IComparer{TKey} to compare keys.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An OrderedParallelQuery{TSource} whose elements are sorted according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static OrderedParallelQuery<TSource> OrderBy<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			return new OrderedParallelQuery<TSource>(new SortQueryOperator<TSource, TKey>(source, keySelector, comparer, descending: false));
		}

		/// <summary>Sorts in parallel the elements of a sequence in descending order according to a key.</summary>
		/// <param name="source">A sequence of values to order.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An OrderedParallelQuery{TSource} whose elements are sorted descending according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static OrderedParallelQuery<TSource> OrderByDescending<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			return new OrderedParallelQuery<TSource>(new SortQueryOperator<TSource, TKey>(source, keySelector, null, descending: true));
		}

		/// <summary>Sorts the elements of a sequence in descending order by using a specified comparer.</summary>
		/// <param name="source">A sequence of values to order.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <param name="comparer">An IComparer{TKey} to compare keys.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An OrderedParallelQuery{TSource} whose elements are sorted descending according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="KeySelector" /> is a null reference (Nothing in Visual Basic)..</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static OrderedParallelQuery<TSource> OrderByDescending<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			return new OrderedParallelQuery<TSource>(new SortQueryOperator<TSource, TKey>(source, keySelector, comparer, descending: true));
		}

		/// <summary>Performs in parallel a subsequent ordering of the elements in a sequence in ascending order according to a key.</summary>
		/// <param name="source">An OrderedParallelQuery{TSource} that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An OrderedParallelQuery{TSource} whose elements are sorted according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static OrderedParallelQuery<TSource> ThenBy<TSource, TKey>(this OrderedParallelQuery<TSource> source, Func<TSource, TKey> keySelector)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			return new OrderedParallelQuery<TSource>((QueryOperator<TSource>)source.OrderedEnumerable.CreateOrderedEnumerable(keySelector, null, descending: false));
		}

		/// <summary>Performs in parallel a subsequent ordering of the elements in a sequence in ascending order by using a specified comparer.</summary>
		/// <param name="source">An OrderedParallelQuery{TSource} that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <param name="comparer">An IComparer{TKey} to compare keys.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An OrderedParallelQuery{TSource} whose elements are sorted according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static OrderedParallelQuery<TSource> ThenBy<TSource, TKey>(this OrderedParallelQuery<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			return new OrderedParallelQuery<TSource>((QueryOperator<TSource>)source.OrderedEnumerable.CreateOrderedEnumerable(keySelector, comparer, descending: false));
		}

		/// <summary>Performs in parallel a subsequent ordering of the elements in a sequence in descending order, according to a key.</summary>
		/// <param name="source">An OrderedParallelQuery{TSource} that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>A sequence whose elements are sorted descending according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static OrderedParallelQuery<TSource> ThenByDescending<TSource, TKey>(this OrderedParallelQuery<TSource> source, Func<TSource, TKey> keySelector)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			return new OrderedParallelQuery<TSource>((QueryOperator<TSource>)source.OrderedEnumerable.CreateOrderedEnumerable(keySelector, null, descending: true));
		}

		/// <summary>Performs in parallel a subsequent ordering of the elements in a sequence in descending order by using a specified comparer.</summary>
		/// <param name="source">An OrderedParallelQuery{TSource} that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <param name="comparer">An IComparer{TKey} to compare keys.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>A sequence whose elements are sorted descending according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static OrderedParallelQuery<TSource> ThenByDescending<TSource, TKey>(this OrderedParallelQuery<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			return new OrderedParallelQuery<TSource>((QueryOperator<TSource>)source.OrderedEnumerable.CreateOrderedEnumerable(keySelector, comparer, descending: true));
		}

		/// <summary>Groups in parallel the elements of a sequence according to a specified key selector function.</summary>
		/// <param name="source">An OrderedParallelQuery{TSource}that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>A sequence of groups that are sorted descending according to <paramref name="TKey" />.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector)
		{
			return source.GroupBy(keySelector, null);
		}

		/// <summary>Groups in parallel the elements of a sequence according to a specified key selector function and compares the keys by using a specified <see cref="T:System.Collections.Generic.IComparer`1" />.</summary>
		/// <param name="source">An <see cref="T:System.Linq.OrderedParallelQuery`1" /> that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />&gt;.</typeparam>
		/// <returns>A sequence of groups that are sorted descending according to <paramref name="TKey" />.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			return new GroupByQueryOperator<TSource, TKey, TSource>(source, keySelector, null, comparer);
		}

		/// <summary>Groups in parallel the elements of a sequence according to a specified key selector function and projects the elements for each group by using a specified function.</summary>
		/// <param name="source">An <see cref="T:System.Linq.OrderedParallelQuery`1" /> that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <param name="elementSelector">A function to map each source element to an element in an <see cref="T:System.Linq.IGrouping`2" />.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
		/// <returns>A sequence of groups that are sorted descending according to <paramref name="TKey" />.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)
		{
			return source.GroupBy(keySelector, elementSelector, null);
		}

		/// <summary>Groups in parallel the elements of a sequence according to a key selector function. The keys are compared by using a comparer and each group's elements are projected by using a specified function.</summary>
		/// <param name="source">An OrderedParallelQuery{TSource}that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <param name="elementSelector">A function to map each source element to an element in an IGrouping.</param>
		/// <param name="comparer">An IComparer{TSource} to compare keys.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the elements in the IGrouping</typeparam>
		/// <returns>A sequence of groups that are sorted descending according to <paramref name="TKey" />.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			if (elementSelector == null)
			{
				throw new ArgumentNullException("elementSelector");
			}
			return new GroupByQueryOperator<TSource, TKey, TElement>(source, keySelector, elementSelector, comparer);
		}

		/// <summary>Groups in parallel the elements of a sequence according to a specified key selector function and creates a result value from each group and its key.</summary>
		/// <param name="source">A sequence whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="resultSelector">A function to create a result value from each group.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
		/// <returns>A sequence of elements of type <paramref name="TResult" /> where each element represents a projection over a group and its key.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> GroupBy<TSource, TKey, TResult>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector)
		{
			if (resultSelector == null)
			{
				throw new ArgumentNullException("resultSelector");
			}
			return from grouping in source.GroupBy(keySelector)
				select resultSelector(grouping.Key, grouping);
		}

		/// <summary>Groups in parallel the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. The keys are compared by using a specified comparer.</summary>
		/// <param name="source">A sequence whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="resultSelector">A function to create a result value from each group.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
		/// <returns>A sequence of groups.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> GroupBy<TSource, TKey, TResult>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (resultSelector == null)
			{
				throw new ArgumentNullException("resultSelector");
			}
			return from grouping in source.GroupBy(keySelector, comparer)
				select resultSelector(grouping.Key, grouping);
		}

		/// <summary>Groups in parallel the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. The elements of each group are projected by using a specified function.</summary>
		/// <param name="source">A sequence whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="elementSelector">A function to map each source element to an element in an IGrouping&lt;TKey, TElement&gt;.</param>
		/// <param name="resultSelector">A function to create a result value from each group.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the elements in each IGrouping{TKey, TElement}.</typeparam>
		/// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
		/// <returns>A sequence of elements of type <paramref name="TResult" /> where each element represents a projection over a group and its key.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> GroupBy<TSource, TKey, TElement, TResult>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector)
		{
			if (resultSelector == null)
			{
				throw new ArgumentNullException("resultSelector");
			}
			return from grouping in source.GroupBy(keySelector, elementSelector)
				select resultSelector(grouping.Key, grouping);
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. Key values are compared by using a specified comparer, and the elements of each group are projected by using a specified function.</summary>
		/// <param name="source">A sequence whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="elementSelector">A function to map each source element to an element in an IGrouping{Key, TElement}.</param>
		/// <param name="resultSelector">A function to create a result value from each group.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the elements in each IGrouping{TKey, TElement}.</typeparam>
		/// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
		/// <returns>A sequence of elements of type <paramref name="TResult" /> where each element represents a projection over a group and its key.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> GroupBy<TSource, TKey, TElement, TResult>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (resultSelector == null)
			{
				throw new ArgumentNullException("resultSelector");
			}
			return from grouping in source.GroupBy(keySelector, elementSelector, comparer)
				select resultSelector(grouping.Key, grouping);
		}

		private static T PerformAggregation<T>(this ParallelQuery<T> source, Func<T, T, T> reduce, T seed, bool seedIsSpecified, bool throwIfEmpty, QueryAggregationOptions options)
		{
			return new AssociativeAggregationOperator<T, T, T>(source, seed, null, seedIsSpecified, reduce, reduce, (T obj) => obj, throwIfEmpty, options).Aggregate();
		}

		private static TAccumulate PerformSequentialAggregation<TSource, TAccumulate>(this ParallelQuery<TSource> source, TAccumulate seed, bool seedIsSpecified, Func<TAccumulate, TSource, TAccumulate> func)
		{
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			TAccumulate val;
			if (seedIsSpecified)
			{
				val = seed;
			}
			else
			{
				if (!enumerator.MoveNext())
				{
					throw new InvalidOperationException("Sequence contains no elements");
				}
				val = (TAccumulate)(object)enumerator.Current;
			}
			while (enumerator.MoveNext())
			{
				TSource current = enumerator.Current;
				try
				{
					val = func(val, current);
				}
				catch (Exception ex)
				{
					throw new AggregateException(ex);
				}
			}
			return val;
		}

		/// <summary>Applies in parallel an accumulator function over a sequence.</summary>
		/// <param name="source">A sequence to aggregate over.</param>
		/// <param name="func">An accumulator function to be invoked on each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The final accumulator value.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="func" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static TSource Aggregate<TSource>(this ParallelQuery<TSource> source, Func<TSource, TSource, TSource> func)
		{
			return source.Aggregate(func, QueryAggregationOptions.AssociativeCommutative);
		}

		internal static TSource Aggregate<TSource>(this ParallelQuery<TSource> source, Func<TSource, TSource, TSource> func, QueryAggregationOptions options)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (func == null)
			{
				throw new ArgumentNullException("func");
			}
			if ((~QueryAggregationOptions.AssociativeCommutative & options) != QueryAggregationOptions.None)
			{
				throw new ArgumentOutOfRangeException("options");
			}
			if ((options & QueryAggregationOptions.Associative) != QueryAggregationOptions.Associative)
			{
				return source.PerformSequentialAggregation(default(TSource), seedIsSpecified: false, func);
			}
			return source.PerformAggregation(func, default(TSource), seedIsSpecified: false, throwIfEmpty: true, options);
		}

		/// <summary>Applies in parallel an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.</summary>
		/// <param name="source">A sequence to aggregate over.</param>
		/// <param name="seed">The initial accumulator value.</param>
		/// <param name="func">An accumulator function to be invoked on each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
		/// <returns>The final accumulator value.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="func" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static TAccumulate Aggregate<TSource, TAccumulate>(this ParallelQuery<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func)
		{
			return source.Aggregate(seed, func, QueryAggregationOptions.AssociativeCommutative);
		}

		internal static TAccumulate Aggregate<TSource, TAccumulate>(this ParallelQuery<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func, QueryAggregationOptions options)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (func == null)
			{
				throw new ArgumentNullException("func");
			}
			if ((~QueryAggregationOptions.AssociativeCommutative & options) != QueryAggregationOptions.None)
			{
				throw new ArgumentOutOfRangeException("options");
			}
			return source.PerformSequentialAggregation(seed, seedIsSpecified: true, func);
		}

		/// <summary>Applies in parallel an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.</summary>
		/// <param name="source">A sequence to aggregate over.</param>
		/// <param name="seed">The initial accumulator value.</param>
		/// <param name="func">An accumulator function to be invoked on each element.</param>
		/// <param name="resultSelector">A function to transform the final accumulator value into the result value.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
		/// <typeparam name="TResult">The type of the resulting value.</typeparam>
		/// <returns>The transformed final accumulator value.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="func" /> or <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static TResult Aggregate<TSource, TAccumulate, TResult>(this ParallelQuery<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func, Func<TAccumulate, TResult> resultSelector)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (func == null)
			{
				throw new ArgumentNullException("func");
			}
			if (resultSelector == null)
			{
				throw new ArgumentNullException("resultSelector");
			}
			TAccumulate arg = source.PerformSequentialAggregation(seed, seedIsSpecified: true, func);
			try
			{
				return resultSelector(arg);
			}
			catch (Exception ex)
			{
				throw new AggregateException(ex);
			}
		}

		/// <summary>Applies in parallel an accumulator function over a sequence. This overload is not available in the sequential implementation.</summary>
		/// <param name="source">A sequence to aggregate over.</param>
		/// <param name="seed">The initial accumulator value.</param>
		/// <param name="updateAccumulatorFunc">An accumulator function to be invoked on each element in a partition. </param>
		/// <param name="combineAccumulatorsFunc">An accumulator function to be invoked on the yielded accumulator result from each partition. </param>
		/// <param name="resultSelector">A function to transform the final accumulator value into the result value. </param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
		/// <typeparam name="TResult">The type of the resulting value.</typeparam>
		/// <returns>The transformed final accumulator value.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="updateAccumulatorFunc" /> or <paramref name="combineAccumulatorsFunc" /> or <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static TResult Aggregate<TSource, TAccumulate, TResult>(this ParallelQuery<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func<TAccumulate, TResult> resultSelector)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (updateAccumulatorFunc == null)
			{
				throw new ArgumentNullException("updateAccumulatorFunc");
			}
			if (combineAccumulatorsFunc == null)
			{
				throw new ArgumentNullException("combineAccumulatorsFunc");
			}
			if (resultSelector == null)
			{
				throw new ArgumentNullException("resultSelector");
			}
			return new AssociativeAggregationOperator<TSource, TAccumulate, TResult>(source, seed, null, seedIsSpecified: true, updateAccumulatorFunc, combineAccumulatorsFunc, resultSelector, throwIfEmpty: false, QueryAggregationOptions.AssociativeCommutative).Aggregate();
		}

		/// <summary>Applies in parallel an accumulator function over a sequence. This overload is not available in the sequential implementation.</summary>
		/// <param name="source">A sequence to aggregate over.</param>
		/// <param name="seedFactory">A function that returns the initial accumulator value. </param>
		/// <param name="updateAccumulatorFunc">An accumulator function to be invoked on each element in a partition. </param>
		/// <param name="combineAccumulatorsFunc">An accumulator function to be invoked on the yielded accumulator result from each partition.</param>
		/// <param name="resultSelector">A function to transform the final accumulator value into the result value. </param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
		/// <typeparam name="TResult">The type of the resulting value.</typeparam>
		/// <returns>The transformed final accumulator value.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="seedFactory" /> or <paramref name="updateAccumulatorFunc" /> or <paramref name="combineAccumulatorsFunc" /> or <paramref name="resultSelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static TResult Aggregate<TSource, TAccumulate, TResult>(this ParallelQuery<TSource> source, Func<TAccumulate> seedFactory, Func<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func<TAccumulate, TResult> resultSelector)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (seedFactory == null)
			{
				throw new ArgumentNullException("seedFactory");
			}
			if (updateAccumulatorFunc == null)
			{
				throw new ArgumentNullException("updateAccumulatorFunc");
			}
			if (combineAccumulatorsFunc == null)
			{
				throw new ArgumentNullException("combineAccumulatorsFunc");
			}
			if (resultSelector == null)
			{
				throw new ArgumentNullException("resultSelector");
			}
			return new AssociativeAggregationOperator<TSource, TAccumulate, TResult>(source, default(TAccumulate), seedFactory, seedIsSpecified: true, updateAccumulatorFunc, combineAccumulatorsFunc, resultSelector, throwIfEmpty: false, QueryAggregationOptions.AssociativeCommutative).Aggregate();
		}

		/// <summary>Returns the number of elements in a parallel sequence.</summary>
		/// <param name="source">A sequence that contains elements to be counted.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The number of elements in the input sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The number of elements in source is larger than <see cref="F:System.Int32.MaxValue" />. (In this case the InnerException is <see cref="T:System.OverflowException" />) -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static int Count<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (source is ParallelEnumerableWrapper<TSource> { WrappedEnumerable: ICollection<TSource> wrappedEnumerable })
			{
				return wrappedEnumerable.Count;
			}
			return new CountAggregationOperator<TSource>(source).Aggregate();
		}

		/// <summary>Returns a number that represents how many elements in the specified parallel sequence satisfy a condition.</summary>
		/// <param name="source">A sequence that contains elements to be counted.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>A number that represents how many elements in the sequence satisfy the condition in the predicate function.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The number of elements in source is larger than <see cref="F:System.Int32.MaxValue" />. (In this case the InnerException is <see cref="T:System.OverflowException" />) -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static int Count<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			return new CountAggregationOperator<TSource>(source.Where(predicate)).Aggregate();
		}

		/// <summary>Returns an Int64 that represents the total number of elements in a parallel sequence.</summary>
		/// <param name="source">A sequence that contains elements to be counted.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The number of elements in the input sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The number of elements in source is larger than <see cref="F:System.Int64.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.OverflowException">The computed result is greater than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static long LongCount<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (source is ParallelEnumerableWrapper<TSource> { WrappedEnumerable: ICollection<TSource> wrappedEnumerable })
			{
				return wrappedEnumerable.Count;
			}
			return new LongCountAggregationOperator<TSource>(source).Aggregate();
		}

		/// <summary>Returns an Int64 that represents how many elements in a parallel sequence satisfy a condition.</summary>
		/// <param name="source">A sequence that contains elements to be counted.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>A number that represents how many elements in the sequence satisfy the condition in the predicate function.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The number of elements in source is larger than <see cref="F:System.Int64.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.OverflowException">The computed result is greater than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static long LongCount<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			return new LongCountAggregationOperator<TSource>(source.Where(predicate)).Aggregate();
		}

		/// <summary>Computes in parallel the sum of a sequence of values.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Int32.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static int Sum(this ParallelQuery<int> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new IntSumAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the sum of a sequence of values.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Int32.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static int? Sum(this ParallelQuery<int?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableIntSumAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the sum of a sequence of values.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Int64.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static long Sum(this ParallelQuery<long> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new LongSumAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the sum of a sequence of values.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Int64.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static long? Sum(this ParallelQuery<long?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableLongSumAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the sum of a sequence of values.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Single.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static float Sum(this ParallelQuery<float> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new FloatSumAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the sum of a sequence of values.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Single.MaxValue" />. -or-  One or more exceptions occurred during the evaluation of the query.</exception>
		public static float? Sum(this ParallelQuery<float?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableFloatSumAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the sum of a sequence of values.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Double.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static double Sum(this ParallelQuery<double> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new DoubleSumAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the sum of a sequence of values.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Double.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static double? Sum(this ParallelQuery<double?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableDoubleSumAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the sum of a sequence of values.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static decimal Sum(this ParallelQuery<decimal> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new DecimalSumAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the sum of a sequence of values.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static decimal? Sum(this ParallelQuery<decimal?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableDecimalSumAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the sum of the sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements in the source sequence.</typeparam>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Int32.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static int Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, int> selector)
		{
			return source.Select(selector).Sum();
		}

		/// <summary>Computes in parallel the sum of the sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Int32.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static int? Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, int?> selector)
		{
			return source.Select(selector).Sum();
		}

		/// <summary>Computes in parallel the sum of the sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Int64.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static long Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, long> selector)
		{
			return source.Select(selector).Sum();
		}

		/// <summary>Computes in parallel the sum of the sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Int64.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static long? Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, long?> selector)
		{
			return source.Select(selector).Sum();
		}

		/// <summary>Computes in parallel the sum of the sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Single.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static float Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, float> selector)
		{
			return source.Select(selector).Sum();
		}

		/// <summary>Computes in parallel the sum of the sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Single.MaxValue" />. -or-  One or more exceptions occurred during the evaluation of the query.</exception>
		public static float? Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, float?> selector)
		{
			return source.Select(selector).Sum();
		}

		/// <summary>Computes in parallel the sum of the sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Double.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static double Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, double> selector)
		{
			return source.Select(selector).Sum();
		}

		/// <summary>Computes in parallel the sum of the sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Double.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static double? Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, double?> selector)
		{
			return source.Select(selector).Sum();
		}

		/// <summary>Computes in parallel the sum of the sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static decimal Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, decimal> selector)
		{
			return source.Select(selector).Sum();
		}

		/// <summary>Computes in parallel the sum of the sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the sum of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static decimal? Sum<TSource>(this ParallelQuery<TSource> source, Func<TSource, decimal?> selector)
		{
			return source.Select(selector).Sum();
		}

		/// <summary>Returns the minimum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static int Min(this ParallelQuery<int> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new IntMinMaxAggregationOperator(source, -1).Aggregate();
		}

		/// <summary>Returns the minimum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static int? Min(this ParallelQuery<int?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableIntMinMaxAggregationOperator(source, -1).Aggregate();
		}

		/// <summary>Returns the minimum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static long Min(this ParallelQuery<long> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new LongMinMaxAggregationOperator(source, -1).Aggregate();
		}

		/// <summary>Returns the minimum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static long? Min(this ParallelQuery<long?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableLongMinMaxAggregationOperator(source, -1).Aggregate();
		}

		/// <summary>Returns the minimum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static float Min(this ParallelQuery<float> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new FloatMinMaxAggregationOperator(source, -1).Aggregate();
		}

		/// <summary>Returns the minimum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float? Min(this ParallelQuery<float?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableFloatMinMaxAggregationOperator(source, -1).Aggregate();
		}

		/// <summary>Returns the minimum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static double Min(this ParallelQuery<double> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new DoubleMinMaxAggregationOperator(source, -1).Aggregate();
		}

		/// <summary>Returns the minimum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double? Min(this ParallelQuery<double?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableDoubleMinMaxAggregationOperator(source, -1).Aggregate();
		}

		/// <summary>Returns the minimum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static decimal Min(this ParallelQuery<decimal> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new DecimalMinMaxAggregationOperator(source, -1).Aggregate();
		}

		/// <summary>Returns the minimum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static decimal? Min(this ParallelQuery<decimal?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableDecimalMinMaxAggregationOperator(source, -1).Aggregate();
		}

		/// <summary>Returns the minimum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static TSource Min<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return AggregationMinMaxHelpers<TSource>.ReduceMin(source);
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the minimum value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static int Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, int> selector)
		{
			return source.Select(selector).Min<int>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the minimum value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static int? Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, int?> selector)
		{
			return source.Select(selector).Min<int?>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the minimum value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static long Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, long> selector)
		{
			return source.Select(selector).Min<long>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the minimum value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static long? Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, long?> selector)
		{
			return source.Select(selector).Min<long?>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the minimum value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static float Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, float> selector)
		{
			return source.Select(selector).Min<float>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the minimum value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float? Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, float?> selector)
		{
			return source.Select(selector).Min<float?>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the minimum value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static double Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, double> selector)
		{
			return source.Select(selector).Min<double>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the minimum value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double? Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, double?> selector)
		{
			return source.Select(selector).Min<double?>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the minimum value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static decimal Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, decimal> selector)
		{
			return source.Select(selector).Min<decimal>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the minimum value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static decimal? Min<TSource>(this ParallelQuery<TSource> source, Func<TSource, decimal?> selector)
		{
			return source.Select(selector).Min<decimal?>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the minimum value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the value returned by <paramref name="selector" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static TResult Min<TSource, TResult>(this ParallelQuery<TSource> source, Func<TSource, TResult> selector)
		{
			return source.Select(selector).Min();
		}

		/// <summary>Returns the maximum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static int Max(this ParallelQuery<int> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new IntMinMaxAggregationOperator(source, 1).Aggregate();
		}

		/// <summary>Returns the maximum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static int? Max(this ParallelQuery<int?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableIntMinMaxAggregationOperator(source, 1).Aggregate();
		}

		/// <summary>Returns the maximum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static long Max(this ParallelQuery<long> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new LongMinMaxAggregationOperator(source, 1).Aggregate();
		}

		/// <summary>Returns the maximum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static long? Max(this ParallelQuery<long?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableLongMinMaxAggregationOperator(source, 1).Aggregate();
		}

		/// <summary>Returns the maximum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float Max(this ParallelQuery<float> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new FloatMinMaxAggregationOperator(source, 1).Aggregate();
		}

		/// <summary>Returns the maximum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float? Max(this ParallelQuery<float?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableFloatMinMaxAggregationOperator(source, 1).Aggregate();
		}

		/// <summary>Returns the maximum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Max(this ParallelQuery<double> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new DoubleMinMaxAggregationOperator(source, 1).Aggregate();
		}

		/// <summary>Returns the maximum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double? Max(this ParallelQuery<double?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableDoubleMinMaxAggregationOperator(source, 1).Aggregate();
		}

		/// <summary>Returns the maximum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static decimal Max(this ParallelQuery<decimal> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new DecimalMinMaxAggregationOperator(source, 1).Aggregate();
		}

		/// <summary>Returns the maximum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static decimal? Max(this ParallelQuery<decimal?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableDecimalMinMaxAggregationOperator(source, 1).Aggregate();
		}

		/// <summary>Returns the maximum value in a parallel sequence of values.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <typeparam name="TSource">The type of elements in the source sequence.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static TSource Max<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return AggregationMinMaxHelpers<TSource>.ReduceMax(source);
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the maximum value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static int Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, int> selector)
		{
			return source.Select(selector).Max<int>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the maximum value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static int? Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, int?> selector)
		{
			return source.Select(selector).Max<int?>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the maximum value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static long Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, long> selector)
		{
			return source.Select(selector).Max<long>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the maximum value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static long? Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, long?> selector)
		{
			return source.Select(selector).Max<long?>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the maximum value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static float Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, float> selector)
		{
			return source.Select(selector).Max<float>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the maximum value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float? Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, float?> selector)
		{
			return source.Select(selector).Max<float?>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the maximum value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static double Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, double> selector)
		{
			return source.Select(selector).Max<double>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the maximum value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double? Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, double?> selector)
		{
			return source.Select(selector).Max<double?>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the maximum value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static decimal Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, decimal> selector)
		{
			return source.Select(selector).Max<decimal>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the maximum value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static decimal? Max<TSource>(this ParallelQuery<TSource> source, Func<TSource, decimal?> selector)
		{
			return source.Select(selector).Max<decimal?>();
		}

		/// <summary>Invokes in parallel a transform function on each element of a sequence and returns the maximum value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the value returned by <paramref name="selector" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements and <paramref name="TSource" /> is a non-nullable value type.</exception>
		public static TResult Max<TSource, TResult>(this ParallelQuery<TSource> source, Func<TSource, TResult> selector)
		{
			return source.Select(selector).Max();
		}

		/// <summary>Computes in parallel the average of a sequence of values.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum or count of the elements in the sequence is larger than <see cref="F:System.Int32.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Average(this ParallelQuery<int> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new IntAverageAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the average of a sequence of values.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum or count of the elements in the sequence is larger than <see cref="F:System.Int32.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double? Average(this ParallelQuery<int?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableIntAverageAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the average of a sequence of values.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum or count of the elements in the sequence is larger than <see cref="F:System.Int32.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Average(this ParallelQuery<long> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new LongAverageAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the average of a sequence of values.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum or count of the elements in the sequence is larger than <see cref="F:System.Int32.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double? Average(this ParallelQuery<long?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableLongAverageAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the average of a sequence of values.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float Average(this ParallelQuery<float> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new FloatAverageAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the average of a sequence of values.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float? Average(this ParallelQuery<float?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableFloatAverageAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the average of a sequence of values.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Average(this ParallelQuery<double> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new DoubleAverageAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the average of a sequence of values.</summary>
		/// <param name="source">The source sequence.</param>
		/// <returns>Returns the average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">A sequence of values that are used to calculate an average.The average of the sequence of values.<paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double? Average(this ParallelQuery<double?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableDoubleAverageAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the average of a sequence of values.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static decimal Average(this ParallelQuery<decimal> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new DecimalAverageAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the average of a sequence of values.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static decimal? Average(this ParallelQuery<decimal?> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new NullableDecimalAverageAggregationOperator(source).Aggregate();
		}

		/// <summary>Computes in parallel the average of a sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum or count of the elements in the sequence is larger than <see cref="F:System.Int32.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		/// <exception cref="T:System.OverflowException"> (Thrown as inner exception in an <see cref="T:System.AggregateException" />). The <paramref name="selector" /> function returns a value greater than MaxValue for the element type.</exception>
		public static double Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, int> selector)
		{
			return source.Select(selector).Average();
		}

		/// <summary>Computes in parallel the average of a sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum or count of the elements in the sequence is larger than <see cref="F:System.Int32.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		/// <exception cref="T:System.OverflowException"> (Thrown as inner exception in an <see cref="T:System.AggregateException" />). The <paramref name="selector" /> function returns a value greater than MaxValue for the element type.</exception>
		public static double? Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, int?> selector)
		{
			return source.Select(selector).Average();
		}

		/// <summary>Computes in parallel the average of a sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum or count of the elements in the sequence is larger than <see cref="F:System.Int32.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		/// <exception cref="T:System.OverflowException"> (Thrown as inner exception in an <see cref="T:System.AggregateException" />). The <paramref name="selector" /> function returns a value greater than MaxValue for the element type.</exception>
		public static double Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, long> selector)
		{
			return source.Select(selector).Average();
		}

		/// <summary>Computes in parallel the average of a sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">The sum or count of the elements in the sequence is larger than <see cref="F:System.Int64.MaxValue" />. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		/// <exception cref="T:System.OverflowException"> (Thrown as inner exception in an <see cref="T:System.AggregateException" />). The <paramref name="selector" /> function returns a value greater than MaxValue for the element type.</exception>
		public static double? Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, long?> selector)
		{
			return source.Select(selector).Average();
		}

		/// <summary>Computes in parallel the average of a sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		/// <exception cref="T:System.OverflowException"> (Thrown as inner exception in an <see cref="T:System.AggregateException" />). The <paramref name="selector" /> function returns a value greater than MaxValue for the element type.</exception>
		public static float Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, float> selector)
		{
			return source.Select(selector).Average();
		}

		/// <summary>Computes in parallel the average of a sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		/// <exception cref="T:System.OverflowException"> (Thrown as inner exception in an <see cref="T:System.AggregateException" />). The <paramref name="selector" /> function returns a value greater than MaxValue for the element type.</exception>
		public static float? Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, float?> selector)
		{
			return source.Select(selector).Average();
		}

		/// <summary>Computes in parallel the average of a sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		/// <exception cref="T:System.OverflowException"> (Thrown as inner exception in an <see cref="T:System.AggregateException" />). The <paramref name="selector" /> function returns a value greater than MaxValue for the element type.</exception>
		public static double Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, double> selector)
		{
			return source.Select(selector).Average();
		}

		/// <summary>Computes in parallel the average of a sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		/// <exception cref="T:System.OverflowException"> (Thrown as inner exception in an <see cref="T:System.AggregateException" />). The <paramref name="selector" /> function returns a value greater than MaxValue for the element type.</exception>
		public static double? Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, double?> selector)
		{
			return source.Select(selector).Average();
		}

		/// <summary>Computes in parallel the average of a sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		/// <exception cref="T:System.OverflowException">(Thrown as inner exception in an <see cref="T:System.AggregateException" />). The <paramref name="selector" /> function returns a value greater than MaxValue for the element type.</exception>
		public static decimal Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, decimal> selector)
		{
			return source.Select(selector).Average();
		}

		/// <summary>Computes in parallel the average of a sequence of values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		/// <exception cref="T:System.OverflowException"> (Thrown as inner exception in an <see cref="T:System.AggregateException" />). The <paramref name="selector" /> function returns a value greater than MaxValue for the element type.</exception>
		public static decimal? Average<TSource>(this ParallelQuery<TSource> source, Func<TSource, decimal?> selector)
		{
			return source.Select(selector).Average();
		}

		/// <summary>Determines in parallel whether any element of a sequence satisfies a condition.</summary>
		/// <param name="source">A sequence to whose elements the predicate will be applied.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>true if any elements in the source sequence pass the test in the specified predicate; otherwise, false.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static bool Any<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			return new AnyAllSearchOperator<TSource>(source, qualification: true, predicate).Aggregate();
		}

		/// <summary>Determines whether a parallel sequence contains any elements.</summary>
		/// <param name="source">The sequence to check for emptiness.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>true if the source sequence contains any elements; otherwise, false.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static bool Any<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return source.Any((TSource x) => true);
		}

		/// <summary>Determines in parallel whether all elements of a sequence satisfy a condition.</summary>
		/// <param name="source">A sequence whose elements to apply the predicate to.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>true if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, false..</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static bool All<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			return new AnyAllSearchOperator<TSource>(source, qualification: false, predicate).Aggregate();
		}

		/// <summary>Determines in parallel whether a sequence contains a specified element by using the default equality comparer.</summary>
		/// <param name="source">A sequence in which to locate a value.</param>
		/// <param name="value">The value to locate in the sequence.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>true if the source sequence contains an element that has the specified value; otherwise, false.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static bool Contains<TSource>(this ParallelQuery<TSource> source, TSource value)
		{
			return source.Contains(value, null);
		}

		/// <summary>Determines in parallel whether a sequence contains a specified element by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
		/// <param name="source">A sequence in which to locate a value.</param>
		/// <param name="value">The value to locate in the sequence.</param>
		/// <param name="comparer">An equality comparer to compare values.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>true if the source sequence contains an element that has the specified value; otherwise, false.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static bool Contains<TSource>(this ParallelQuery<TSource> source, TSource value, IEqualityComparer<TSource> comparer)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new ContainsSearchOperator<TSource>(source, value, comparer).Aggregate();
		}

		/// <summary>Returns a specified number of contiguous elements from the start of a parallel sequence.</summary>
		/// <param name="source">The sequence to return elements from.</param>
		/// <param name="count">The number of elements to return.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>A sequence that contains the specified number of elements from the start of the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> Take<TSource>(this ParallelQuery<TSource> source, int count)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (count > 0)
			{
				return new TakeOrSkipQueryOperator<TSource>(source, count, take: true);
			}
			return Empty<TSource>();
		}

		/// <summary>Returns elements from a parallel sequence as long as a specified condition is true.</summary>
		/// <param name="source">The sequence to return elements from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>A sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> TakeWhile<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			return new TakeOrSkipWhileQueryOperator<TSource>(source, predicate, null, take: true);
		}

		/// <summary>Returns elements from a parallel sequence as long as a specified condition is true. The element's index is used in the logic of the predicate function.</summary>
		/// <param name="source">The sequence to return elements from.</param>
		/// <param name="predicate">A function to test each source element for a condition; the second parameter of the function represents the index of the source element. </param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>A sequence that contains elements from the input sequence that occur before the element at which the test no longer passes.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.OverflowException">More than <see cref="F:System.Int32.MaxValue" /> elements are enumerated by this query.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> TakeWhile<TSource>(this ParallelQuery<TSource> source, Func<TSource, int, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			return new TakeOrSkipWhileQueryOperator<TSource>(source, null, predicate, take: true);
		}

		/// <summary>Bypasses a specified number of elements in a parallel sequence and then returns the remaining elements.</summary>
		/// <param name="source">The sequence to return elements from.</param>
		/// <param name="count">The number of elements to skip before returning the remaining elements.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>A sequence that contains the elements that occur after the specified index in the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.OverflowException">Count is greater than <see cref="F:System.Int32.MaxValue" /></exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> Skip<TSource>(this ParallelQuery<TSource> source, int count)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (count <= 0)
			{
				return source;
			}
			return new TakeOrSkipQueryOperator<TSource>(source, count, take: false);
		}

		/// <summary>Bypasses elements in a parallel sequence as long as a specified condition is true and then returns the remaining elements.</summary>
		/// <param name="source">The sequence to return elements from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>A sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> SkipWhile<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			return new TakeOrSkipWhileQueryOperator<TSource>(source, predicate, null, take: false);
		}

		/// <summary>Bypasses elements in a parallel sequence as long as a specified condition is true and then returns the remaining elements. The element's index is used in the logic of the predicate function.</summary>
		/// <param name="source">The sequence to return elements from.</param>
		/// <param name="predicate">A function to test each source element for a condition; the second parameter of the function represents the index of the source element. </param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <returns>A sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.OverflowException">More than <see cref="F:System.Int32.MaxValue" /> elements are enumerated by the query.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> SkipWhile<TSource>(this ParallelQuery<TSource> source, Func<TSource, int, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			return new TakeOrSkipWhileQueryOperator<TSource>(source, null, predicate, take: false);
		}

		/// <summary>Concatenates two parallel sequences.</summary>
		/// <param name="first">The first sequence to concatenate.</param>
		/// <param name="second">The sequence to concatenate to the first sequence.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>A sequence that contains the concatenated elements of the two input sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).</exception>
		public static ParallelQuery<TSource> Concat<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second)
		{
			if (first == null)
			{
				throw new ArgumentNullException("first");
			}
			if (second == null)
			{
				throw new ArgumentNullException("second");
			}
			return new ConcatQueryOperator<TSource>(first, second);
		}

		/// <summary>This Concat overload should never be called. This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.</summary>
		/// <param name="first">This parameter is not used.</param>
		/// <param name="second">This parameter is not used.</param>
		/// <typeparam name="TSource">This type parameter is not used.</typeparam>
		/// <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
		/// <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
		[Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
		public static ParallelQuery<TSource> Concat<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second)
		{
			throw new NotSupportedException("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.");
		}

		/// <summary>Determines whether two parallel sequences are equal by comparing the elements by using the default equality comparer for their type.</summary>
		/// <param name="first">A sequence to compare to second.</param>
		/// <param name="second">A sequence to compare to the first input sequence.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>true if the two source sequences are of equal length and their corresponding elements are equal according to the default equality comparer for their type; otherwise, false.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static bool SequenceEqual<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second)
		{
			if (first == null)
			{
				throw new ArgumentNullException("first");
			}
			if (second == null)
			{
				throw new ArgumentNullException("second");
			}
			return first.SequenceEqual(second, null);
		}

		/// <summary>This SequenceEqual overload should never be called. This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.</summary>
		/// <param name="first">This parameter is not used.</param>
		/// <param name="second">This parameter is not used.</param>
		/// <typeparam name="TSource">This type parameter is not used.</typeparam>
		/// <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
		/// <exception cref="T:System.NotSupportedException">Thrown every time this method is called.</exception>
		[Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
		public static bool SequenceEqual<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second)
		{
			throw new NotSupportedException("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.");
		}

		/// <summary>Determines whether two parallel sequences are equal by comparing their elements by using a specified IEqualityComparer{T}.</summary>
		/// <param name="first">A sequence to compare to <paramref name="second" />.</param>
		/// <param name="second">A sequence to compare to the first input sequence.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to use to compare elements.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>true if the two source sequences are of equal length and their corresponding elements are equal according to the default equality comparer for their type; otherwise, false.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static bool SequenceEqual<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second, IEqualityComparer<TSource> comparer)
		{
			if (first == null)
			{
				throw new ArgumentNullException("first");
			}
			if (second == null)
			{
				throw new ArgumentNullException("second");
			}
			comparer = comparer ?? EqualityComparer<TSource>.Default;
			QueryOperator<TSource> queryOperator = QueryOperator<TSource>.AsQueryOperator(first);
			QueryOperator<TSource> queryOperator2 = QueryOperator<TSource>.AsQueryOperator(second);
			QuerySettings querySettings = queryOperator.SpecifiedQuerySettings.Merge(queryOperator2.SpecifiedQuerySettings).WithDefaults().WithPerExecutionSettings(new CancellationTokenSource(), new Shared<bool>(value: false));
			IEnumerator<TSource> enumerator = first.GetEnumerator();
			try
			{
				IEnumerator<TSource> enumerator2 = second.GetEnumerator();
				try
				{
					while (enumerator.MoveNext())
					{
						if (!enumerator2.MoveNext() || !comparer.Equals(enumerator.Current, enumerator2.Current))
						{
							return false;
						}
					}
					if (enumerator2.MoveNext())
					{
						return false;
					}
				}
				catch (Exception ex)
				{
					ExceptionAggregator.ThrowOCEorAggregateException(ex, querySettings.CancellationState);
				}
				finally
				{
					DisposeEnumerator(enumerator2, querySettings.CancellationState);
				}
			}
			finally
			{
				DisposeEnumerator(enumerator, querySettings.CancellationState);
			}
			return true;
		}

		private static void DisposeEnumerator<TSource>(IEnumerator<TSource> e, CancellationState cancelState)
		{
			try
			{
				e.Dispose();
			}
			catch (Exception ex)
			{
				ExceptionAggregator.ThrowOCEorAggregateException(ex, cancelState);
			}
		}

		/// <summary>This SequenceEqual overload should never be called. This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.</summary>
		/// <param name="first">This parameter is not used.</param>
		/// <param name="second">This parameter is not used.</param>
		/// <param name="comparer">This parameter is not used.</param>
		/// <typeparam name="TSource">This type parameter is not used.</typeparam>
		/// <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
		/// <exception cref="T:System.NotSupportedException">Thrown every time this method is called.</exception>
		[Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
		public static bool SequenceEqual<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			throw new NotSupportedException("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.");
		}

		/// <summary>Returns distinct elements from a parallel sequence by using the default equality comparer to compare values.</summary>
		/// <param name="source">The sequence to remove duplicate elements from.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>A sequence that contains distinct elements from the source sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> Distinct<TSource>(this ParallelQuery<TSource> source)
		{
			return source.Distinct(null);
		}

		/// <summary>Returns distinct elements from a parallel sequence by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</summary>
		/// <param name="source">The sequence to remove duplicate elements from.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" />  to compare values.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>A sequence that contains distinct elements from the source sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> Distinct<TSource>(this ParallelQuery<TSource> source, IEqualityComparer<TSource> comparer)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new DistinctQueryOperator<TSource>(source, comparer);
		}

		/// <summary>Produces the set union of two parallel sequences by using the default equality comparer.</summary>
		/// <param name="first">A sequence whose distinct elements form the first set for the union.</param>
		/// <param name="second">A sequence whose distinct elements form the second set for the union.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>A sequence that contains the elements from both input sequences, excluding duplicates.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> Union<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second)
		{
			return first.Union(second, null);
		}

		/// <summary>This Union overload should never be called. This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.</summary>
		/// <param name="first">This parameter is not used.</param>
		/// <param name="second">This parameter is not used.</param>
		/// <typeparam name="TSource">This type parameter is not used.</typeparam>
		/// <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
		/// <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		[Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
		public static ParallelQuery<TSource> Union<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second)
		{
			throw new NotSupportedException("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.");
		}

		/// <summary>Produces the set union of two parallel sequences by using a specified IEqualityComparer{T}.</summary>
		/// <param name="first">A sequence whose distinct elements form the first set for the union.</param>
		/// <param name="second">A sequence whose distinct elements form the second set for the union.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>A sequence that contains the elements from both input sequences, excluding duplicates.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> Union<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second, IEqualityComparer<TSource> comparer)
		{
			if (first == null)
			{
				throw new ArgumentNullException("first");
			}
			if (second == null)
			{
				throw new ArgumentNullException("second");
			}
			return new UnionQueryOperator<TSource>(first, second, comparer);
		}

		/// <summary>This Union overload should never be called. This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.</summary>
		/// <param name="first">This parameter is not used.</param>
		/// <param name="second">This parameter is not used.</param>
		/// <param name="comparer">This parameter is not used.</param>
		/// <typeparam name="TSource">This type parameter is not used.</typeparam>
		/// <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
		/// <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		[Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
		public static ParallelQuery<TSource> Union<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			throw new NotSupportedException("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.");
		}

		/// <summary>Produces the set intersection of two parallel sequences by using the default equality comparer to compare values.</summary>
		/// <param name="first">A sequence whose distinct elements that also appear in <paramref name="second" /> will be returned.</param>
		/// <param name="second">A sequence whose distinct elements that also appear in the first sequence will be returned.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>A sequence that contains the elements that form the set intersection of two sequences.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> Intersect<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second)
		{
			return first.Intersect(second, null);
		}

		/// <summary>This Intersect overload should never be called. This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.</summary>
		/// <param name="first">This parameter is not used.</param>
		/// <param name="second">This parameter is not used.</param>
		/// <typeparam name="TSource">This type parameter is not used.</typeparam>
		/// <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
		/// <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
		[Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
		public static ParallelQuery<TSource> Intersect<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second)
		{
			throw new NotSupportedException("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.");
		}

		/// <summary>Produces the set intersection of two parallel sequences by using the specified IEqualityComparer{T} to compare values.</summary>
		/// <param name="first">A sequence whose distinct elements that also appear in <paramref name="second" /> will be returned.</param>
		/// <param name="second">A sequence whose distinct elements that also appear in the first sequence will be returned.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>A sequence that contains the elements that form the set intersection of two sequences.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="action" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> Intersect<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second, IEqualityComparer<TSource> comparer)
		{
			if (first == null)
			{
				throw new ArgumentNullException("first");
			}
			if (second == null)
			{
				throw new ArgumentNullException("second");
			}
			return new IntersectQueryOperator<TSource>(first, second, comparer);
		}

		/// <summary>This Intersect overload should never be called. This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.</summary>
		/// <param name="first">This parameter is not used.</param>
		/// <param name="second">This parameter is not used.</param>
		/// <param name="comparer">This parameter is not used.</param>
		/// <typeparam name="TSource">This type parameter is not used.</typeparam>
		/// <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
		/// <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
		[Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
		public static ParallelQuery<TSource> Intersect<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			throw new NotSupportedException("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.");
		}

		/// <summary>Produces the set difference of two parallel sequences by using the default equality comparer to compare values.</summary>
		/// <param name="first">A sequence whose elements that are not also in <paramref name="second" /> will be returned.</param>
		/// <param name="second">A sequence whose elements that also occur in the first sequence will cause those elements to be removed from the returned sequence.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> Except<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second)
		{
			return first.Except(second, null);
		}

		/// <summary>This Except overload should never be called. This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.</summary>
		/// <param name="first">This parameter is not used.</param>
		/// <param name="second">This parameter is not used.</param>
		/// <typeparam name="TSource">This type parameter is not used.</typeparam>
		/// <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
		/// <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
		[Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
		public static ParallelQuery<TSource> Except<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second)
		{
			throw new NotSupportedException("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.");
		}

		/// <summary>Produces the set difference of two parallel sequences by using the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</summary>
		/// <param name="first">A sequence whose elements that are not also in <paramref name="second" /> will be returned.</param>
		/// <param name="second">A sequence whose elements that also occur in the first sequence will cause those elements to be removed from the returned sequence. </param>
		/// <param name="comparer">
		///       <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> Except<TSource>(this ParallelQuery<TSource> first, ParallelQuery<TSource> second, IEqualityComparer<TSource> comparer)
		{
			if (first == null)
			{
				throw new ArgumentNullException("first");
			}
			if (second == null)
			{
				throw new ArgumentNullException("second");
			}
			return new ExceptQueryOperator<TSource>(first, second, comparer);
		}

		/// <summary>This Except overload should never be called. This method is marked as obsolete and always throws <see cref="T:System.NotSupportedException" /> when called.</summary>
		/// <param name="first">This parameter is not used.</param>
		/// <param name="second">This parameter is not used.</param>
		/// <param name="comparer">This parameter is not used.</param>
		/// <typeparam name="TSource">This type parameter is not used.</typeparam>
		/// <returns>This overload always throws a <see cref="T:System.NotSupportedException" />.</returns>
		/// <exception cref="T:System.NotSupportedException">The exception that occurs when this method is called.</exception>
		[Obsolete("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
		public static ParallelQuery<TSource> Except<TSource>(this ParallelQuery<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			throw new NotSupportedException("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.");
		}

		/// <summary>Converts a <see cref="T:System.Linq.ParallelQuery`1" /> into an <see cref="T:System.Collections.Generic.IEnumerable`1" /> to force sequential evaluation of the query.</summary>
		/// <param name="source">The sequence to cast as <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The input sequence typed as <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		public static IEnumerable<TSource> AsEnumerable<TSource>(this ParallelQuery<TSource> source)
		{
			return source.AsSequential();
		}

		/// <summary>Creates an array from a <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
		/// <param name="source">A sequence to create an array from.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An array that contains the elements from the input sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static TSource[] ToArray<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (source is QueryOperator<TSource> queryOperator)
			{
				return queryOperator.ExecuteAndGetResultsAsArray();
			}
			return Enumerable.ToArray(source.ToList());
		}

		/// <summary>Creates a <see cref="T:System.Collections.Generic.List`1" /> from an <see cref="T:System.Linq.ParallelQuery`1" />.</summary>
		/// <param name="source">A sequence to create a <see cref="T:System.Collections.Generic.List`1" /> from.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>A <see cref="T:System.Collections.Generic.List`1" />  that contains elements from the input sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static List<TSource> ToList<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			List<TSource> list = new List<TSource>();
			IEnumerator<TSource> enumerator;
			if (source is QueryOperator<TSource> queryOperator)
			{
				if (queryOperator.OrdinalIndexState == OrdinalIndexState.Indexable && queryOperator.OutputOrdered)
				{
					return new List<TSource>(source.ToArray());
				}
				enumerator = queryOperator.GetEnumerator(ParallelMergeOptions.FullyBuffered);
			}
			else
			{
				enumerator = source.GetEnumerator();
			}
			using (enumerator)
			{
				while (enumerator.MoveNext())
				{
					list.Add(enumerator.Current);
				}
				return list;
			}
		}

		/// <summary>Creates a <see cref="T:System.Collections.Generic.Dictionary`2" /> from a <see cref="T:System.Linq.ParallelQuery`1" /> according to a specified key selector function.</summary>
		/// <param name="source">A sequence to create a <see cref="T:System.Collections.Generic.Dictionary`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Collections.Generic.Dictionary`2" /> that contains keys and values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">
		///         <paramref name="keySelector" /> produces a key that is a null reference (Nothing in Visual Basic). -or- <paramref name="keySelector" /> produces duplicate keys for two elements. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector)
		{
			return source.ToDictionary(keySelector, EqualityComparer<TKey>.Default);
		}

		/// <summary>Creates a <see cref="T:System.Collections.Generic.Dictionary`2" />  from a <see cref="T:System.Linq.ParallelQuery`1" /> according to a specified key selector function and key comparer.</summary>
		/// <param name="source">A sequence to create a <see cref="T:System.Collections.Generic.Dictionary`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Collections.Generic.Dictionary`2" /> that contains keys and values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">
		///         <paramref name="keySelector" /> produces a key that is a null reference (Nothing in Visual Basic). -or- <paramref name="keySelector" /> produces duplicate keys for two elements. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			Dictionary<TKey, TSource> dictionary = new Dictionary<TKey, TSource>(comparer);
			IEnumerator<TSource> enumerator = ((!(source is QueryOperator<TSource> queryOperator)) ? source.GetEnumerator() : queryOperator.GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true));
			using (enumerator)
			{
				while (enumerator.MoveNext())
				{
					TSource current = enumerator.Current;
					try
					{
						TKey key = keySelector(current);
						dictionary.Add(key, current);
					}
					catch (Exception ex)
					{
						throw new AggregateException(ex);
					}
				}
				return dictionary;
			}
		}

		/// <summary>Creates a <see cref="T:System.Collections.Generic.Dictionary`2" /> from a <see cref="T:System.Linq.ParallelQuery`1" /> according to specified key selector and element selector functions.</summary>
		/// <param name="source">A sequence to create a <see cref="T:System.Collections.Generic.Dictionary`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="elementSelector">A transform function to produce a result element value from each element. </param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Collections.Generic.Dictionary`2" /> that contains values of type <paramref name="TElement" /> selected from the input sequence</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">
		///         <paramref name="keySelector" /> produces a key that is a null reference (Nothing in Visual Basic). -or- <paramref name="keySelector" /> produces duplicate keys for two elements. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)
		{
			return source.ToDictionary(keySelector, elementSelector, EqualityComparer<TKey>.Default);
		}

		/// <summary>Creates a <see cref="T:System.Collections.Generic.Dictionary`2" /> from a <see cref="T:System.Linq.ParallelQuery`1" /> according to a specified key selector function, a comparer, and an element selector function.</summary>
		/// <param name="source">A sequence to create a <see cref="T:System.Collections.Generic.Dictionary`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="elementSelector">A transform function to produce a result element value from each element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Collections.Generic.Dictionary`2" /> that contains values of type <paramref name="TElement" /> selected from the input sequence</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">
		///         <paramref name="keySelector" /> produces a key that is a null reference (Nothing in Visual Basic). -or- <paramref name="keySelector" /> produces duplicate keys for two elements. -or- One or more exceptions occurred during the evaluation of the query.</exception>
		public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			if (elementSelector == null)
			{
				throw new ArgumentNullException("elementSelector");
			}
			Dictionary<TKey, TElement> dictionary = new Dictionary<TKey, TElement>(comparer);
			IEnumerator<TSource> enumerator = ((!(source is QueryOperator<TSource> queryOperator)) ? source.GetEnumerator() : queryOperator.GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true));
			using (enumerator)
			{
				while (enumerator.MoveNext())
				{
					TSource current = enumerator.Current;
					try
					{
						dictionary.Add(keySelector(current), elementSelector(current));
					}
					catch (Exception ex)
					{
						throw new AggregateException(ex);
					}
				}
				return dictionary;
			}
		}

		/// <summary>Creates an <see cref="T:System.Linq.ILookup`2" /> from a <see cref="T:System.Linq.ParallelQuery`1" /> according to a specified key selector function.</summary>
		/// <param name="source">The sequence to create a <see cref="T:System.Linq.ILookup`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Linq.ILookup`2" /> that contains keys and values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector)
		{
			return source.ToLookup(keySelector, EqualityComparer<TKey>.Default);
		}

		/// <summary>Creates an <see cref="T:System.Linq.ILookup`2" /> from a <see cref="T:System.Linq.ParallelQuery`1" /> according to a specified key selector function and key comparer.</summary>
		/// <param name="source">The sequence to create a <see cref="T:System.Linq.ILookup`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Linq.ILookup`2" /> that contains keys and values.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			comparer = comparer ?? EqualityComparer<TKey>.Default;
			ParallelQuery<IGrouping<TKey, TSource>> parallelQuery = source.GroupBy(keySelector, comparer);
			System.Linq.Parallel.Lookup<TKey, TSource> lookup = new System.Linq.Parallel.Lookup<TKey, TSource>(comparer);
			IEnumerator<IGrouping<TKey, TSource>> enumerator = ((!(parallelQuery is QueryOperator<IGrouping<TKey, TSource>> queryOperator)) ? parallelQuery.GetEnumerator() : queryOperator.GetEnumerator(ParallelMergeOptions.FullyBuffered));
			using (enumerator)
			{
				while (enumerator.MoveNext())
				{
					lookup.Add(enumerator.Current);
				}
				return lookup;
			}
		}

		/// <summary>Creates an <see cref="T:System.Linq.ILookup`2" /> from a <see cref="T:System.Linq.ParallelQuery`1" /> according to specified key selector and element selector functions.</summary>
		/// <param name="source">The sequence to create a <see cref="T:System.Linq.ILookup`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="elementSelector">A transform function to produce a result element value from each element. </param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Linq.ILookup`2" /> that contains values of type <paramref name="TElement" /> selected from the input sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)
		{
			return source.ToLookup(keySelector, elementSelector, EqualityComparer<TKey>.Default);
		}

		/// <summary>Creates an <see cref="T:System.Linq.ILookup`2" /> from a <see cref="T:System.Linq.ParallelQuery`1" /> according to a specified key selector function, a comparer and an element selector function.</summary>
		/// <param name="source">The sequence to create a <see cref="T:System.Linq.ILookup`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="elementSelector">A transform function to produce a result element value from each element. </param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector" />.</typeparam>
		/// <returns>A Lookup&lt;(Of &lt;(TKey, TElement&gt;)&gt;) that contains values of type TElement selected from the input sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(this ParallelQuery<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (keySelector == null)
			{
				throw new ArgumentNullException("keySelector");
			}
			if (elementSelector == null)
			{
				throw new ArgumentNullException("elementSelector");
			}
			comparer = comparer ?? EqualityComparer<TKey>.Default;
			ParallelQuery<IGrouping<TKey, TElement>> parallelQuery = source.GroupBy(keySelector, elementSelector, comparer);
			System.Linq.Parallel.Lookup<TKey, TElement> lookup = new System.Linq.Parallel.Lookup<TKey, TElement>(comparer);
			IEnumerator<IGrouping<TKey, TElement>> enumerator = ((!(parallelQuery is QueryOperator<IGrouping<TKey, TElement>> queryOperator)) ? parallelQuery.GetEnumerator() : queryOperator.GetEnumerator(ParallelMergeOptions.FullyBuffered));
			using (enumerator)
			{
				while (enumerator.MoveNext())
				{
					lookup.Add(enumerator.Current);
				}
				return lookup;
			}
		}

		/// <summary>Inverts the order of the elements in a parallel sequence.</summary>
		/// <param name="source">A sequence of values to reverse.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>A sequence whose elements correspond to those of the input sequence in reverse order.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> Reverse<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new ReverseQueryOperator<TSource>(source);
		}

		/// <summary>Filters the elements of a ParallelQuery based on a specified type.</summary>
		/// <param name="source">The sequence whose elements to filter.</param>
		/// <typeparam name="TResult">The type to filter the elements of the sequence on.</typeparam>
		/// <returns>A sequence that contains elements from the input sequence of type .</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TResult> OfType<TResult>(this ParallelQuery source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return source.OfType<TResult>();
		}

		/// <summary>Converts the elements of a ParallelQuery to the specified type.</summary>
		/// <param name="source">The sequence that contains the elements to be converted.</param>
		/// <typeparam name="TResult">The type to convert the elements of <paramref name="source" /> to.</typeparam>
		/// <returns>A sequence that contains each element of the source sequence converted to the specified type.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.InvalidCastException">The type of the source sequence could not be converted to <paramref name="TResult" />.</exception>
		public static ParallelQuery<TResult> Cast<TResult>(this ParallelQuery source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return source.Cast<TResult>();
		}

		private static TSource GetOneWithPossibleDefault<TSource>(QueryOperator<TSource> queryOp, bool throwIfTwo, bool defaultIfEmpty)
		{
			using (IEnumerator<TSource> enumerator = queryOp.GetEnumerator(ParallelMergeOptions.FullyBuffered))
			{
				if (enumerator.MoveNext())
				{
					TSource current = enumerator.Current;
					if (throwIfTwo && enumerator.MoveNext())
					{
						throw new InvalidOperationException("Sequence contains more than one matching element");
					}
					return current;
				}
			}
			if (defaultIfEmpty)
			{
				return default(TSource);
			}
			throw new InvalidOperationException("Sequence contains no elements");
		}

		/// <summary>Returns the first element of a parallel sequence.</summary>
		/// <param name="source">The sequence to return the first element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The first element in the specified sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static TSource First<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			FirstQueryOperator<TSource> firstQueryOperator = new FirstQueryOperator<TSource>(source, null);
			QuerySettings querySettings = firstQueryOperator.SpecifiedQuerySettings.WithDefaults();
			if (firstQueryOperator.LimitsParallelism && querySettings.ExecutionMode != ParallelExecutionMode.ForceParallelism)
			{
				return ExceptionAggregator.WrapEnumerable(CancellableEnumerable.Wrap(firstQueryOperator.Child.AsSequentialQuery(querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState).First();
			}
			return GetOneWithPossibleDefault(firstQueryOperator, throwIfTwo: false, defaultIfEmpty: false);
		}

		/// <summary>Returns the first element in a parallel sequence that satisfies a specified condition.</summary>
		/// <param name="source">The sequence to return an element from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The first element in the sequence that passes the test in the specified predicate function.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">No element in <paramref name="source" /> satisfies the condition in <paramref name="predicate" />.</exception>
		public static TSource First<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			FirstQueryOperator<TSource> firstQueryOperator = new FirstQueryOperator<TSource>(source, predicate);
			QuerySettings querySettings = firstQueryOperator.SpecifiedQuerySettings.WithDefaults();
			if (firstQueryOperator.LimitsParallelism && querySettings.ExecutionMode != ParallelExecutionMode.ForceParallelism)
			{
				return ExceptionAggregator.WrapEnumerable(CancellableEnumerable.Wrap(firstQueryOperator.Child.AsSequentialQuery(querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState).First(ExceptionAggregator.WrapFunc(predicate, querySettings.CancellationState));
			}
			return GetOneWithPossibleDefault(firstQueryOperator, throwIfTwo: false, defaultIfEmpty: false);
		}

		/// <summary>Returns the first element of a parallel sequence, or a default value if the sequence contains no elements.</summary>
		/// <param name="source">The sequence to return the first element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>default(TSource) if <paramref name="source" /> is empty; otherwise, the first element in <paramref name="source" />.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static TSource FirstOrDefault<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			FirstQueryOperator<TSource> firstQueryOperator = new FirstQueryOperator<TSource>(source, null);
			QuerySettings querySettings = firstQueryOperator.SpecifiedQuerySettings.WithDefaults();
			if (firstQueryOperator.LimitsParallelism && querySettings.ExecutionMode != ParallelExecutionMode.ForceParallelism)
			{
				return ExceptionAggregator.WrapEnumerable(CancellableEnumerable.Wrap(firstQueryOperator.Child.AsSequentialQuery(querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState).FirstOrDefault();
			}
			return GetOneWithPossibleDefault(firstQueryOperator, throwIfTwo: false, defaultIfEmpty: true);
		}

		/// <summary>Returns the first element of the parallel sequence that satisfies a condition or a default value if no such element is found.</summary>
		/// <param name="source">The sequence to return an element from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>default(TSource) if <paramref name="source" /> is empty or if no element passes the test specified by predicate; otherwise, the first element in <paramref name="source" /> that passes the test specified by predicate.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static TSource FirstOrDefault<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			FirstQueryOperator<TSource> firstQueryOperator = new FirstQueryOperator<TSource>(source, predicate);
			QuerySettings querySettings = firstQueryOperator.SpecifiedQuerySettings.WithDefaults();
			if (firstQueryOperator.LimitsParallelism && querySettings.ExecutionMode != ParallelExecutionMode.ForceParallelism)
			{
				return ExceptionAggregator.WrapEnumerable(CancellableEnumerable.Wrap(firstQueryOperator.Child.AsSequentialQuery(querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState).FirstOrDefault(ExceptionAggregator.WrapFunc(predicate, querySettings.CancellationState));
			}
			return GetOneWithPossibleDefault(firstQueryOperator, throwIfTwo: false, defaultIfEmpty: true);
		}

		/// <summary>Returns the last element of a parallel sequence.</summary>
		/// <param name="source">The sequence to return the last element from.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The value at the last position in the source sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static TSource Last<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			LastQueryOperator<TSource> lastQueryOperator = new LastQueryOperator<TSource>(source, null);
			QuerySettings querySettings = lastQueryOperator.SpecifiedQuerySettings.WithDefaults();
			if (lastQueryOperator.LimitsParallelism && querySettings.ExecutionMode != ParallelExecutionMode.ForceParallelism)
			{
				return ExceptionAggregator.WrapEnumerable(CancellableEnumerable.Wrap(lastQueryOperator.Child.AsSequentialQuery(querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState).Last();
			}
			return GetOneWithPossibleDefault(lastQueryOperator, throwIfTwo: false, defaultIfEmpty: false);
		}

		/// <summary>Returns the last element of a parallel sequence that satisfies a specified condition.</summary>
		/// <param name="source">The sequence to return an element from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The last element in the sequence that passes the test in the specified predicate function.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">No element in <paramref name="source" /> satisfies the condition in <paramref name="predicate" />.</exception>
		public static TSource Last<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			LastQueryOperator<TSource> lastQueryOperator = new LastQueryOperator<TSource>(source, predicate);
			QuerySettings querySettings = lastQueryOperator.SpecifiedQuerySettings.WithDefaults();
			if (lastQueryOperator.LimitsParallelism && querySettings.ExecutionMode != ParallelExecutionMode.ForceParallelism)
			{
				return ExceptionAggregator.WrapEnumerable(CancellableEnumerable.Wrap(lastQueryOperator.Child.AsSequentialQuery(querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState).Last(ExceptionAggregator.WrapFunc(predicate, querySettings.CancellationState));
			}
			return GetOneWithPossibleDefault(lastQueryOperator, throwIfTwo: false, defaultIfEmpty: false);
		}

		/// <summary>Returns the last element of a parallel sequence, or a default value if the sequence contains no elements.</summary>
		/// <param name="source">The sequence to return an element from.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>default() if the source sequence is empty; otherwise, the last element in the sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static TSource LastOrDefault<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			LastQueryOperator<TSource> lastQueryOperator = new LastQueryOperator<TSource>(source, null);
			QuerySettings querySettings = lastQueryOperator.SpecifiedQuerySettings.WithDefaults();
			if (lastQueryOperator.LimitsParallelism && querySettings.ExecutionMode != ParallelExecutionMode.ForceParallelism)
			{
				return ExceptionAggregator.WrapEnumerable(CancellableEnumerable.Wrap(lastQueryOperator.Child.AsSequentialQuery(querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState).LastOrDefault();
			}
			return GetOneWithPossibleDefault(lastQueryOperator, throwIfTwo: false, defaultIfEmpty: true);
		}

		/// <summary>Returns the last element of a parallel sequence that satisfies a condition, or a default value if no such element is found.</summary>
		/// <param name="source">The sequence to return an element from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>default() if the sequence is empty or if no elements pass the test in the predicate function; otherwise, the last element that passes the test in the predicate function.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static TSource LastOrDefault<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			LastQueryOperator<TSource> lastQueryOperator = new LastQueryOperator<TSource>(source, predicate);
			QuerySettings querySettings = lastQueryOperator.SpecifiedQuerySettings.WithDefaults();
			if (lastQueryOperator.LimitsParallelism && querySettings.ExecutionMode != ParallelExecutionMode.ForceParallelism)
			{
				return ExceptionAggregator.WrapEnumerable(CancellableEnumerable.Wrap(lastQueryOperator.Child.AsSequentialQuery(querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState).LastOrDefault(ExceptionAggregator.WrapFunc(predicate, querySettings.CancellationState));
			}
			return GetOneWithPossibleDefault(lastQueryOperator, throwIfTwo: false, defaultIfEmpty: true);
		}

		/// <summary>Returns the only element of a parallel sequence, and throws an exception if there is not exactly one element in the sequence.</summary>
		/// <param name="source">The sequence to return the single element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The single element of the input sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">The input sequence contains more than one element. -or- The input sequence is empty.</exception>
		public static TSource Single<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return GetOneWithPossibleDefault(new SingleQueryOperator<TSource>(source, null), throwIfTwo: true, defaultIfEmpty: false);
		}

		/// <summary>Returns the only element of a parallel sequence that satisfies a specified condition, and throws an exception if more than one such element exists.</summary>
		/// <param name="source">The sequence to return the single element of.</param>
		/// <param name="predicate">A function to test an element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The single element of the input sequence that satisfies a condition.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">No element satisfies the condition in <paramref name="predicate" />. -or- More than one element satisfies the condition in <paramref name="predicate" />.</exception>
		public static TSource Single<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			return GetOneWithPossibleDefault(new SingleQueryOperator<TSource>(source, predicate), throwIfTwo: true, defaultIfEmpty: false);
		}

		/// <summary>Returns the only element of a parallel sequence, or a default value if the sequence is empty; this method throws an exception if there is more than one element in the sequence.</summary>
		/// <param name="source">The sequence to return the single element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The single element of the input sequence, or default() if the sequence contains no elements.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static TSource SingleOrDefault<TSource>(this ParallelQuery<TSource> source)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return GetOneWithPossibleDefault(new SingleQueryOperator<TSource>(source, null), throwIfTwo: true, defaultIfEmpty: true);
		}

		/// <summary>Returns the only element of a parallel sequence that satisfies a specified condition or a default value if no such element exists; this method throws an exception if more than one element satisfies the condition.</summary>
		/// <param name="source">The sequence to return the single element of.</param>
		/// <param name="predicate">A function to test an element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The single element of the input sequence that satisfies the condition, or default() if no such element is found.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> is empty or multiple elements are returned.</exception>
		public static TSource SingleOrDefault<TSource>(this ParallelQuery<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (predicate == null)
			{
				throw new ArgumentNullException("predicate");
			}
			return GetOneWithPossibleDefault(new SingleQueryOperator<TSource>(source, predicate), throwIfTwo: true, defaultIfEmpty: true);
		}

		/// <summary>Returns the elements of the specified parallel sequence or the type parameter's default value in a singleton collection if the sequence is empty.</summary>
		/// <param name="source">The sequence to return a default value for if it is empty.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>A sequence that contains default(TSource) if <paramref name="source" /> is empty; otherwise, <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> DefaultIfEmpty<TSource>(this ParallelQuery<TSource> source)
		{
			return source.DefaultIfEmpty(default(TSource));
		}

		/// <summary>Returns the elements of the specified parallel sequence or the specified value in a singleton collection if the sequence is empty.</summary>
		/// <param name="source">The sequence to return the specified value for if it is empty.</param>
		/// <param name="defaultValue">The value to return if the sequence is empty.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>A sequence that contains defaultValue if <paramref name="source" /> is empty; otherwise, <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static ParallelQuery<TSource> DefaultIfEmpty<TSource>(this ParallelQuery<TSource> source, TSource defaultValue)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			return new DefaultIfEmptyQueryOperator<TSource>(source, defaultValue);
		}

		/// <summary>Returns the element at a specified index in a parallel sequence.</summary>
		/// <param name="source">A sequence to return an element from.</param>
		/// <param name="index">The zero-based index of the element to retrieve.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The element at the specified position in the source sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="index" /> is less than 0 or greater than or equal to the number of elements in <paramref name="source" />.</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static TSource ElementAt<TSource>(this ParallelQuery<TSource> source, int index)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (new ElementAtQueryOperator<TSource>(source, index).Aggregate(out var result, withDefaultValue: false))
			{
				return result;
			}
			throw new ArgumentOutOfRangeException("index");
		}

		/// <summary>Returns the element at a specified index in a parallel sequence or a default value if the index is out of range.</summary>
		/// <param name="source">A sequence to return an element from.</param>
		/// <param name="index">The zero-based index of the element to retrieve.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>default(TSource) if the index is outside the bounds of the source sequence; otherwise, the element at the specified position in the source sequence.</returns>
		/// <exception cref="T:System.OperationCanceledException">The query was canceled with the token passed in through <paramref name="WithCancellation" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is a null reference (Nothing in Visual Basic).</exception>
		/// <exception cref="T:System.AggregateException">One or more exceptions occurred during the evaluation of the query.</exception>
		public static TSource ElementAtOrDefault<TSource>(this ParallelQuery<TSource> source, int index)
		{
			if (source == null)
			{
				throw new ArgumentNullException("source");
			}
			if (index >= 0 && new ElementAtQueryOperator<TSource>(source, index).Aggregate(out var result, withDefaultValue: true))
			{
				return result;
			}
			return default(TSource);
		}
	}
	/// <summary>The query execution mode is a hint that specifies how the system should handle performance trade-offs when parallelizing queries.</summary>
	public enum ParallelExecutionMode
	{
		/// <summary>This is the default setting. PLINQ will examine the query's structure and will only parallelize the query if will likely result in speedup. If the query structure indicates that speedup is not likely to be obtained, then PLINQ will execute the query as an ordinary LINQ to Objects query.</summary>
		Default,
		/// <summary>Parallelize the entire query, even if that means using high-overhead algorithms. Use this flag in cases where you know that parallel execution of the query will result in speedup, but PLINQ in the Default mode would execute it as sequential.</summary>
		ForceParallelism
	}
	/// <summary>Specifies the preferred type of output merge to use in a query. In other words, it indicates how PLINQ should merge the results from the various partitions back into a single result sequence. This is a hint only, and may not be respected by the system when parallelizing all queries.</summary>
	public enum ParallelMergeOptions
	{
		/// <summary>Use the default merge type, which is AutoBuffered.</summary>
		Default,
		/// <summary>Use a merge without output buffers. As soon as result elements have been computed, make that element available to the consumer of the query.</summary>
		NotBuffered,
		/// <summary>Use a merge with output buffers of a size chosen by the system. Results will accumulate into an output buffer before they are available to the consumer of the query.</summary>
		AutoBuffered,
		/// <summary>Use a merge with full output buffers. The system will accumulate all of the results before making any of them available to the consumer of the query.</summary>
		FullyBuffered
	}
	internal static class CachedReflectionInfo
	{
		private static MethodInfo s_Aggregate_TSource_2;

		private static MethodInfo s_Aggregate_TSource_TAccumulate_3;

		private static MethodInfo s_Aggregate_TSource_TAccumulate_TResult_4;

		private static MethodInfo s_All_TSource_2;

		private static MethodInfo s_Any_TSource_1;

		private static MethodInfo s_Any_TSource_2;

		private static MethodInfo s_Average_Int32_1;

		private static MethodInfo s_Average_NullableInt32_1;

		private static MethodInfo s_Average_Int64_1;

		private static MethodInfo s_Average_NullableInt64_1;

		private static MethodInfo s_Average_Single_1;

		private static MethodInfo s_Average_NullableSingle_1;

		private static MethodInfo s_Average_Double_1;

		private static MethodInfo s_Average_NullableDouble_1;

		private static MethodInfo s_Average_Decimal_1;

		private static MethodInfo s_Average_NullableDecimal_1;

		private static MethodInfo s_Average_Int32_TSource_2;

		private static MethodInfo s_Average_NullableInt32_TSource_2;

		private static MethodInfo s_Average_Single_TSource_2;

		private static MethodInfo s_Average_NullableSingle_TSource_2;

		private static MethodInfo s_Average_Int64_TSource_2;

		private static MethodInfo s_Average_NullableInt64_TSource_2;

		private static MethodInfo s_Average_Double_TSource_2;

		private static MethodInfo s_Average_NullableDouble_TSource_2;

		private static MethodInfo s_Average_Decimal_TSource_2;

		private static MethodInfo s_Average_NullableDecimal_TSource_2;

		private static MethodInfo s_Cast_TResult_1;

		private static MethodInfo s_Concat_TSource_2;

		private static MethodInfo s_Contains_TSource_2;

		private static MethodInfo s_Contains_TSource_3;

		private static MethodInfo s_Count_TSource_1;

		private static MethodInfo s_Count_TSource_2;

		private static MethodInfo s_DefaultIfEmpty_TSource_1;

		private static MethodInfo s_DefaultIfEmpty_TSource_2;

		private static MethodInfo s_Distinct_TSource_1;

		private static MethodInfo s_Distinct_TSource_2;

		private static MethodInfo s_ElementAt_TSource_2;

		private static MethodInfo s_ElementAtOrDefault_TSource_2;

		private static MethodInfo s_Except_TSource_2;

		private static MethodInfo s_Except_TSource_3;

		private static MethodInfo s_First_TSource_1;

		private static MethodInfo s_First_TSource_2;

		private static MethodInfo s_FirstOrDefault_TSource_1;

		private static MethodInfo s_FirstOrDefault_TSource_2;

		private static MethodInfo s_GroupBy_TSource_TKey_2;

		private static MethodInfo s_GroupBy_TSource_TKey_3;

		private static MethodInfo s_GroupBy_TSource_TKey_TElement_3;

		private static MethodInfo s_GroupBy_TSource_TKey_TElement_4;

		private static MethodInfo s_GroupBy_TSource_TKey_TResult_3;

		private static MethodInfo s_GroupBy_TSource_TKey_TResult_4;

		private static MethodInfo s_GroupBy_TSource_TKey_TElement_TResult_4;

		private static MethodInfo s_GroupBy_TSource_TKey_TElement_TResult_5;

		private static MethodInfo s_GroupJoin_TOuter_TInner_TKey_TResult_5;

		private static MethodInfo s_GroupJoin_TOuter_TInner_TKey_TResult_6;

		private static MethodInfo s_Intersect_TSource_2;

		private static MethodInfo s_Intersect_TSource_3;

		private static MethodInfo s_Join_TOuter_TInner_TKey_TResult_5;

		private static MethodInfo s_Join_TOuter_TInner_TKey_TResult_6;

		private static MethodInfo s_Last_TSource_1;

		private static MethodInfo s_Last_TSource_2;

		private static MethodInfo s_LastOrDefault_TSource_1;

		private static MethodInfo s_LastOrDefault_TSource_2;

		private static MethodInfo s_LongCount_TSource_1;

		private static MethodInfo s_LongCount_TSource_2;

		private static MethodInfo s_Max_TSource_1;

		private static MethodInfo s_Max_TSource_TResult_2;

		private static MethodInfo s_Min_TSource_1;

		private static MethodInfo s_Min_TSource_TResult_2;

		private static MethodInfo s_OfType_TResult_1;

		private static MethodInfo s_OrderBy_TSource_TKey_2;

		private static MethodInfo s_OrderBy_TSource_TKey_3;

		private static MethodInfo s_OrderByDescending_TSource_TKey_2;

		private static MethodInfo s_OrderByDescending_TSource_TKey_3;

		private static MethodInfo s_Reverse_TSource_1;

		private static MethodInfo s_Select_TSource_TResult_2;

		private static MethodInfo s_Select_Index_TSource_TResult_2;

		private static MethodInfo s_SelectMany_TSource_TResult_2;

		private static MethodInfo s_SelectMany_Index_TSource_TResult_2;

		private static MethodInfo s_SelectMany_Index_TSource_TCollection_TResult_3;

		private static MethodInfo s_SelectMany_TSource_TCollection_TResult_3;

		private static MethodInfo s_SequenceEqual_TSource_2;

		private static MethodInfo s_SequenceEqual_TSource_3;

		private static MethodInfo s_Single_TSource_1;

		private static MethodInfo s_Single_TSource_2;

		private static MethodInfo s_SingleOrDefault_TSource_1;

		private static MethodInfo s_SingleOrDefault_TSource_2;

		private static MethodInfo s_Skip_TSource_2;

		private static MethodInfo s_SkipWhile_TSource_2;

		private static MethodInfo s_SkipWhile_Index_TSource_2;

		private static MethodInfo s_Sum_Int32_1;

		private static MethodInfo s_Sum_NullableInt32_1;

		private static MethodInfo s_Sum_Int64_1;

		private static MethodInfo s_Sum_NullableInt64_1;

		private static MethodInfo s_Sum_Single_1;

		private static MethodInfo s_Sum_NullableSingle_1;

		private static MethodInfo s_Sum_Double_1;

		private static MethodInfo s_Sum_NullableDouble_1;

		private static MethodInfo s_Sum_Decimal_1;

		private static MethodInfo s_Sum_NullableDecimal_1;

		private static MethodInfo s_Sum_NullableDecimal_TSource_2;

		private static MethodInfo s_Sum_Int32_TSource_2;

		private static MethodInfo s_Sum_NullableInt32_TSource_2;

		private static MethodInfo s_Sum_Int64_TSource_2;

		private static MethodInfo s_Sum_NullableInt64_TSource_2;

		private static MethodInfo s_Sum_Single_TSource_2;

		private static MethodInfo s_Sum_NullableSingle_TSource_2;

		private static MethodInfo s_Sum_Double_TSource_2;

		private static MethodInfo s_Sum_NullableDouble_TSource_2;

		private static MethodInfo s_Sum_Decimal_TSource_2;

		private static MethodInfo s_Take_TSource_2;

		private static MethodInfo s_TakeWhile_TSource_2;

		private static MethodInfo s_TakeWhile_Index_TSource_2;

		private static MethodInfo s_ThenBy_TSource_TKey_2;

		private static MethodInfo s_ThenBy_TSource_TKey_3;

		private static MethodInfo s_ThenByDescending_TSource_TKey_2;

		private static MethodInfo s_ThenByDescending_TSource_TKey_3;

		private static MethodInfo s_Union_TSource_2;

		private static MethodInfo s_Union_TSource_3;

		private static MethodInfo s_Where_TSource_2;

		private static MethodInfo s_Where_Index_TSource_2;

		private static MethodInfo s_Zip_TFirst_TSecond_TResult_3;

		private static MethodInfo s_SkipLast_TSource_2;

		private static MethodInfo s_TakeLast_TSource_2;

		private static MethodInfo s_Append_TSource_2;

		private static MethodInfo s_Prepend_TSource_2;

		public static MethodInfo Average_Int32_1 => s_Average_Int32_1 ?? (s_Average_Int32_1 = new Func<IQueryable<int>, double>(Queryable.Average).GetMethodInfo());

		public static MethodInfo Average_NullableInt32_1 => s_Average_NullableInt32_1 ?? (s_Average_NullableInt32_1 = new Func<IQueryable<int?>, double?>(Queryable.Average).GetMethodInfo());

		public static MethodInfo Average_Int64_1 => s_Average_Int64_1 ?? (s_Average_Int64_1 = new Func<IQueryable<long>, double>(Queryable.Average).GetMethodInfo());

		public static MethodInfo Average_NullableInt64_1 => s_Average_NullableInt64_1 ?? (s_Average_NullableInt64_1 = new Func<IQueryable<long?>, double?>(Queryable.Average).GetMethodInfo());

		public static MethodInfo Average_Single_1 => s_Average_Single_1 ?? (s_Average_Single_1 = new Func<IQueryable<float>, float>(Queryable.Average).GetMethodInfo());

		public static MethodInfo Average_NullableSingle_1 => s_Average_NullableSingle_1 ?? (s_Average_NullableSingle_1 = new Func<IQueryable<float?>, float?>(Queryable.Average).GetMethodInfo());

		public static MethodInfo Average_Double_1 => s_Average_Double_1 ?? (s_Average_Double_1 = new Func<IQueryable<double>, double>(Queryable.Average).GetMethodInfo());

		public static MethodInfo Average_NullableDouble_1 => s_Average_NullableDouble_1 ?? (s_Average_NullableDouble_1 = new Func<IQueryable<double?>, double?>(Queryable.Average).GetMethodInfo());

		public static MethodInfo Average_Decimal_1 => s_Average_Decimal_1 ?? (s_Average_Decimal_1 = new Func<IQueryable<decimal>, decimal>(Queryable.Average).GetMethodInfo());

		public static MethodInfo Average_NullableDecimal_1 => s_Average_NullableDecimal_1 ?? (s_Average_NullableDecimal_1 = new Func<IQueryable<decimal?>, decimal?>(Queryable.Average).GetMethodInfo());

		public static MethodInfo Sum_Int32_1 => s_Sum_Int32_1 ?? (s_Sum_Int32_1 = new Func<IQueryable<int>, int>(Queryable.Sum).GetMethodInfo());

		public static MethodInfo Sum_NullableInt32_1 => s_Sum_NullableInt32_1 ?? (s_Sum_NullableInt32_1 = new Func<IQueryable<int?>, int?>(Queryable.Sum).GetMethodInfo());

		public static MethodInfo Sum_Int64_1 => s_Sum_Int64_1 ?? (s_Sum_Int64_1 = new Func<IQueryable<long>, long>(Queryable.Sum).GetMethodInfo());

		public static MethodInfo Sum_NullableInt64_1 => s_Sum_NullableInt64_1 ?? (s_Sum_NullableInt64_1 = new Func<IQueryable<long?>, long?>(Queryable.Sum).GetMethodInfo());

		public static MethodInfo Sum_Single_1 => s_Sum_Single_1 ?? (s_Sum_Single_1 = new Func<IQueryable<float>, float>(Queryable.Sum).GetMethodInfo());

		public static MethodInfo Sum_NullableSingle_1 => s_Sum_NullableSingle_1 ?? (s_Sum_NullableSingle_1 = new Func<IQueryable<float?>, float?>(Queryable.Sum).GetMethodInfo());

		public static MethodInfo Sum_Double_1 => s_Sum_Double_1 ?? (s_Sum_Double_1 = new Func<IQueryable<double>, double>(Queryable.Sum).GetMethodInfo());

		public static MethodInfo Sum_NullableDouble_1 => s_Sum_NullableDouble_1 ?? (s_Sum_NullableDouble_1 = new Func<IQueryable<double?>, double?>(Queryable.Sum).GetMethodInfo());

		public static MethodInfo Sum_Decimal_1 => s_Sum_Decimal_1 ?? (s_Sum_Decimal_1 = new Func<IQueryable<decimal>, decimal>(Queryable.Sum).GetMethodInfo());

		public static MethodInfo Sum_NullableDecimal_1 => s_Sum_NullableDecimal_1 ?? (s_Sum_NullableDecimal_1 = new Func<IQueryable<decimal?>, decimal?>(Queryable.Sum).GetMethodInfo());

		public static MethodInfo Aggregate_TSource_2(Type TSource)
		{
			return (s_Aggregate_TSource_2 ?? (s_Aggregate_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, object, object>>, object>(Queryable.Aggregate).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Aggregate_TSource_TAccumulate_3(Type TSource, Type TAccumulate)
		{
			return (s_Aggregate_TSource_TAccumulate_3 ?? (s_Aggregate_TSource_TAccumulate_3 = new Func<IQueryable<object>, object, Expression<Func<object, object, object>>, object>(Queryable.Aggregate).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TAccumulate);
		}

		public static MethodInfo Aggregate_TSource_TAccumulate_TResult_4(Type TSource, Type TAccumulate, Type TResult)
		{
			return (s_Aggregate_TSource_TAccumulate_TResult_4 ?? (s_Aggregate_TSource_TAccumulate_TResult_4 = new Func<IQueryable<object>, object, Expression<Func<object, object, object>>, Expression<Func<object, object>>, object>(Queryable.Aggregate).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TAccumulate, TResult);
		}

		public static MethodInfo All_TSource_2(Type TSource)
		{
			return (s_All_TSource_2 ?? (s_All_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, bool>>, bool>(Queryable.All).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Any_TSource_1(Type TSource)
		{
			return (s_Any_TSource_1 ?? (s_Any_TSource_1 = new Func<IQueryable<object>, bool>(Queryable.Any).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Any_TSource_2(Type TSource)
		{
			return (s_Any_TSource_2 ?? (s_Any_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, bool>>, bool>(Queryable.Any).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Average_Int32_TSource_2(Type TSource)
		{
			return (s_Average_Int32_TSource_2 ?? (s_Average_Int32_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, int>>, double>(Queryable.Average).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Average_NullableInt32_TSource_2(Type TSource)
		{
			return (s_Average_NullableInt32_TSource_2 ?? (s_Average_NullableInt32_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, int?>>, double?>(Queryable.Average).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Average_Single_TSource_2(Type TSource)
		{
			return (s_Average_Single_TSource_2 ?? (s_Average_Single_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, float>>, float>(Queryable.Average).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Average_NullableSingle_TSource_2(Type TSource)
		{
			return (s_Average_NullableSingle_TSource_2 ?? (s_Average_NullableSingle_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, float?>>, float?>(Queryable.Average).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Average_Int64_TSource_2(Type TSource)
		{
			return (s_Average_Int64_TSource_2 ?? (s_Average_Int64_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, long>>, double>(Queryable.Average).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Average_NullableInt64_TSource_2(Type TSource)
		{
			return (s_Average_NullableInt64_TSource_2 ?? (s_Average_NullableInt64_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, long?>>, double?>(Queryable.Average).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Average_Double_TSource_2(Type TSource)
		{
			return (s_Average_Double_TSource_2 ?? (s_Average_Double_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, double>>, double>(Queryable.Average).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Average_NullableDouble_TSource_2(Type TSource)
		{
			return (s_Average_NullableDouble_TSource_2 ?? (s_Average_NullableDouble_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, double?>>, double?>(Queryable.Average).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Average_Decimal_TSource_2(Type TSource)
		{
			return (s_Average_Decimal_TSource_2 ?? (s_Average_Decimal_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, decimal>>, decimal>(Queryable.Average).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Average_NullableDecimal_TSource_2(Type TSource)
		{
			return (s_Average_NullableDecimal_TSource_2 ?? (s_Average_NullableDecimal_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, decimal?>>, decimal?>(Queryable.Average).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Cast_TResult_1(Type TResult)
		{
			return (s_Cast_TResult_1 ?? (s_Cast_TResult_1 = new Func<IQueryable, IQueryable<object>>(Queryable.Cast<object>).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TResult);
		}

		public static MethodInfo Concat_TSource_2(Type TSource)
		{
			return (s_Concat_TSource_2 ?? (s_Concat_TSource_2 = new Func<IQueryable<object>, IEnumerable<object>, IQueryable<object>>(Queryable.Concat).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Contains_TSource_2(Type TSource)
		{
			return (s_Contains_TSource_2 ?? (s_Contains_TSource_2 = new Func<IQueryable<object>, object, bool>(Queryable.Contains).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Contains_TSource_3(Type TSource)
		{
			return (s_Contains_TSource_3 ?? (s_Contains_TSource_3 = new Func<IQueryable<object>, object, IEqualityComparer<object>, bool>(Queryable.Contains).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Count_TSource_1(Type TSource)
		{
			return (s_Count_TSource_1 ?? (s_Count_TSource_1 = new Func<IQueryable<object>, int>(Queryable.Count).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Count_TSource_2(Type TSource)
		{
			return (s_Count_TSource_2 ?? (s_Count_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, bool>>, int>(Queryable.Count).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo DefaultIfEmpty_TSource_1(Type TSource)
		{
			return (s_DefaultIfEmpty_TSource_1 ?? (s_DefaultIfEmpty_TSource_1 = new Func<IQueryable<object>, IQueryable<object>>(Queryable.DefaultIfEmpty).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo DefaultIfEmpty_TSource_2(Type TSource)
		{
			return (s_DefaultIfEmpty_TSource_2 ?? (s_DefaultIfEmpty_TSource_2 = new Func<IQueryable<object>, object, IQueryable<object>>(Queryable.DefaultIfEmpty).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Distinct_TSource_1(Type TSource)
		{
			return (s_Distinct_TSource_1 ?? (s_Distinct_TSource_1 = new Func<IQueryable<object>, IQueryable<object>>(Queryable.Distinct).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Distinct_TSource_2(Type TSource)
		{
			return (s_Distinct_TSource_2 ?? (s_Distinct_TSource_2 = new Func<IQueryable<object>, IEqualityComparer<object>, IQueryable<object>>(Queryable.Distinct).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo ElementAt_TSource_2(Type TSource)
		{
			return (s_ElementAt_TSource_2 ?? (s_ElementAt_TSource_2 = new Func<IQueryable<object>, int, object>(Queryable.ElementAt).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo ElementAtOrDefault_TSource_2(Type TSource)
		{
			return (s_ElementAtOrDefault_TSource_2 ?? (s_ElementAtOrDefault_TSource_2 = new Func<IQueryable<object>, int, object>(Queryable.ElementAtOrDefault).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Except_TSource_2(Type TSource)
		{
			return (s_Except_TSource_2 ?? (s_Except_TSource_2 = new Func<IQueryable<object>, IEnumerable<object>, IQueryable<object>>(Queryable.Except).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Except_TSource_3(Type TSource)
		{
			return (s_Except_TSource_3 ?? (s_Except_TSource_3 = new Func<IQueryable<object>, IEnumerable<object>, IEqualityComparer<object>, IQueryable<object>>(Queryable.Except).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo First_TSource_1(Type TSource)
		{
			return (s_First_TSource_1 ?? (s_First_TSource_1 = new Func<IQueryable<object>, object>(Queryable.First).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo First_TSource_2(Type TSource)
		{
			return (s_First_TSource_2 ?? (s_First_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, bool>>, object>(Queryable.First).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo FirstOrDefault_TSource_1(Type TSource)
		{
			return (s_FirstOrDefault_TSource_1 ?? (s_FirstOrDefault_TSource_1 = new Func<IQueryable<object>, object>(Queryable.FirstOrDefault).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo FirstOrDefault_TSource_2(Type TSource)
		{
			return (s_FirstOrDefault_TSource_2 ?? (s_FirstOrDefault_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, bool>>, object>(Queryable.FirstOrDefault).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo GroupBy_TSource_TKey_2(Type TSource, Type TKey)
		{
			return (s_GroupBy_TSource_TKey_2 ?? (s_GroupBy_TSource_TKey_2 = new Func<IQueryable<object>, Expression<Func<object, object>>, IQueryable<IGrouping<object, object>>>(Queryable.GroupBy).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey);
		}

		public static MethodInfo GroupBy_TSource_TKey_3(Type TSource, Type TKey)
		{
			return (s_GroupBy_TSource_TKey_3 ?? (s_GroupBy_TSource_TKey_3 = new Func<IQueryable<object>, Expression<Func<object, object>>, IEqualityComparer<object>, IQueryable<IGrouping<object, object>>>(Queryable.GroupBy).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey);
		}

		public static MethodInfo GroupBy_TSource_TKey_TElement_3(Type TSource, Type TKey, Type TElement)
		{
			return (s_GroupBy_TSource_TKey_TElement_3 ?? (s_GroupBy_TSource_TKey_TElement_3 = new Func<IQueryable<object>, Expression<Func<object, object>>, Expression<Func<object, object>>, IQueryable<IGrouping<object, object>>>(Queryable.GroupBy).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey, TElement);
		}

		public static MethodInfo GroupBy_TSource_TKey_TElement_4(Type TSource, Type TKey, Type TElement)
		{
			return (s_GroupBy_TSource_TKey_TElement_4 ?? (s_GroupBy_TSource_TKey_TElement_4 = new Func<IQueryable<object>, Expression<Func<object, object>>, Expression<Func<object, object>>, IEqualityComparer<object>, IQueryable<IGrouping<object, object>>>(Queryable.GroupBy).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey, TElement);
		}

		public static MethodInfo GroupBy_TSource_TKey_TResult_3(Type TSource, Type TKey, Type TResult)
		{
			return (s_GroupBy_TSource_TKey_TResult_3 ?? (s_GroupBy_TSource_TKey_TResult_3 = new Func<IQueryable<object>, Expression<Func<object, object>>, Expression<Func<object, IEnumerable<object>, object>>, IQueryable<object>>(Queryable.GroupBy).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey, TResult);
		}

		public static MethodInfo GroupBy_TSource_TKey_TResult_4(Type TSource, Type TKey, Type TResult)
		{
			return (s_GroupBy_TSource_TKey_TResult_4 ?? (s_GroupBy_TSource_TKey_TResult_4 = new Func<IQueryable<object>, Expression<Func<object, object>>, Expression<Func<object, IEnumerable<object>, object>>, IEqualityComparer<object>, IQueryable<object>>(Queryable.GroupBy).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey, TResult);
		}

		public static MethodInfo GroupBy_TSource_TKey_TElement_TResult_4(Type TSource, Type TKey, Type TElement, Type TResult)
		{
			return (s_GroupBy_TSource_TKey_TElement_TResult_4 ?? (s_GroupBy_TSource_TKey_TElement_TResult_4 = new Func<IQueryable<object>, Expression<Func<object, object>>, Expression<Func<object, object>>, Expression<Func<object, IEnumerable<object>, object>>, IQueryable<object>>(Queryable.GroupBy).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey, TElement, TResult);
		}

		public static MethodInfo GroupBy_TSource_TKey_TElement_TResult_5(Type TSource, Type TKey, Type TElement, Type TResult)
		{
			return (s_GroupBy_TSource_TKey_TElement_TResult_5 ?? (s_GroupBy_TSource_TKey_TElement_TResult_5 = new Func<IQueryable<object>, Expression<Func<object, object>>, Expression<Func<object, object>>, Expression<Func<object, IEnumerable<object>, object>>, IEqualityComparer<object>, IQueryable<object>>(Queryable.GroupBy).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey, TElement, TResult);
		}

		public static MethodInfo GroupJoin_TOuter_TInner_TKey_TResult_5(Type TOuter, Type TInner, Type TKey, Type TResult)
		{
			return (s_GroupJoin_TOuter_TInner_TKey_TResult_5 ?? (s_GroupJoin_TOuter_TInner_TKey_TResult_5 = new Func<IQueryable<object>, IEnumerable<object>, Expression<Func<object, object>>, Expression<Func<object, object>>, Expression<Func<object, IEnumerable<object>, object>>, IQueryable<object>>(Queryable.GroupJoin).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TOuter, TInner, TKey, TResult);
		}

		public static MethodInfo GroupJoin_TOuter_TInner_TKey_TResult_6(Type TOuter, Type TInner, Type TKey, Type TResult)
		{
			return (s_GroupJoin_TOuter_TInner_TKey_TResult_6 ?? (s_GroupJoin_TOuter_TInner_TKey_TResult_6 = new Func<IQueryable<object>, IEnumerable<object>, Expression<Func<object, object>>, Expression<Func<object, object>>, Expression<Func<object, IEnumerable<object>, object>>, IEqualityComparer<object>, IQueryable<object>>(Queryable.GroupJoin).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TOuter, TInner, TKey, TResult);
		}

		public static MethodInfo Intersect_TSource_2(Type TSource)
		{
			return (s_Intersect_TSource_2 ?? (s_Intersect_TSource_2 = new Func<IQueryable<object>, IEnumerable<object>, IQueryable<object>>(Queryable.Intersect).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Intersect_TSource_3(Type TSource)
		{
			return (s_Intersect_TSource_3 ?? (s_Intersect_TSource_3 = new Func<IQueryable<object>, IEnumerable<object>, IEqualityComparer<object>, IQueryable<object>>(Queryable.Intersect).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Join_TOuter_TInner_TKey_TResult_5(Type TOuter, Type TInner, Type TKey, Type TResult)
		{
			return (s_Join_TOuter_TInner_TKey_TResult_5 ?? (s_Join_TOuter_TInner_TKey_TResult_5 = new Func<IQueryable<object>, IEnumerable<object>, Expression<Func<object, object>>, Expression<Func<object, object>>, Expression<Func<object, object, object>>, IQueryable<object>>(Queryable.Join).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TOuter, TInner, TKey, TResult);
		}

		public static MethodInfo Join_TOuter_TInner_TKey_TResult_6(Type TOuter, Type TInner, Type TKey, Type TResult)
		{
			return (s_Join_TOuter_TInner_TKey_TResult_6 ?? (s_Join_TOuter_TInner_TKey_TResult_6 = new Func<IQueryable<object>, IEnumerable<object>, Expression<Func<object, object>>, Expression<Func<object, object>>, Expression<Func<object, object, object>>, IEqualityComparer<object>, IQueryable<object>>(Queryable.Join).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TOuter, TInner, TKey, TResult);
		}

		public static MethodInfo Last_TSource_1(Type TSource)
		{
			return (s_Last_TSource_1 ?? (s_Last_TSource_1 = new Func<IQueryable<object>, object>(Queryable.Last).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Last_TSource_2(Type TSource)
		{
			return (s_Last_TSource_2 ?? (s_Last_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, bool>>, object>(Queryable.Last).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo LastOrDefault_TSource_1(Type TSource)
		{
			return (s_LastOrDefault_TSource_1 ?? (s_LastOrDefault_TSource_1 = new Func<IQueryable<object>, object>(Queryable.LastOrDefault).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo LastOrDefault_TSource_2(Type TSource)
		{
			return (s_LastOrDefault_TSource_2 ?? (s_LastOrDefault_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, bool>>, object>(Queryable.LastOrDefault).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo LongCount_TSource_1(Type TSource)
		{
			return (s_LongCount_TSource_1 ?? (s_LongCount_TSource_1 = new Func<IQueryable<object>, long>(Queryable.LongCount).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo LongCount_TSource_2(Type TSource)
		{
			return (s_LongCount_TSource_2 ?? (s_LongCount_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, bool>>, long>(Queryable.LongCount).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Max_TSource_1(Type TSource)
		{
			return (s_Max_TSource_1 ?? (s_Max_TSource_1 = new Func<IQueryable<object>, object>(Queryable.Max).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Max_TSource_TResult_2(Type TSource, Type TResult)
		{
			return (s_Max_TSource_TResult_2 ?? (s_Max_TSource_TResult_2 = new Func<IQueryable<object>, Expression<Func<object, object>>, object>(Queryable.Max).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TResult);
		}

		public static MethodInfo Min_TSource_1(Type TSource)
		{
			return (s_Min_TSource_1 ?? (s_Min_TSource_1 = new Func<IQueryable<object>, object>(Queryable.Min).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Min_TSource_TResult_2(Type TSource, Type TResult)
		{
			return (s_Min_TSource_TResult_2 ?? (s_Min_TSource_TResult_2 = new Func<IQueryable<object>, Expression<Func<object, object>>, object>(Queryable.Min).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TResult);
		}

		public static MethodInfo OfType_TResult_1(Type TResult)
		{
			return (s_OfType_TResult_1 ?? (s_OfType_TResult_1 = new Func<IQueryable, IQueryable<object>>(Queryable.OfType<object>).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TResult);
		}

		public static MethodInfo OrderBy_TSource_TKey_2(Type TSource, Type TKey)
		{
			return (s_OrderBy_TSource_TKey_2 ?? (s_OrderBy_TSource_TKey_2 = new Func<IQueryable<object>, Expression<Func<object, object>>, IOrderedQueryable<object>>(Queryable.OrderBy).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey);
		}

		public static MethodInfo OrderBy_TSource_TKey_3(Type TSource, Type TKey)
		{
			return (s_OrderBy_TSource_TKey_3 ?? (s_OrderBy_TSource_TKey_3 = new Func<IQueryable<object>, Expression<Func<object, object>>, IComparer<object>, IOrderedQueryable<object>>(Queryable.OrderBy).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey);
		}

		public static MethodInfo OrderByDescending_TSource_TKey_2(Type TSource, Type TKey)
		{
			return (s_OrderByDescending_TSource_TKey_2 ?? (s_OrderByDescending_TSource_TKey_2 = new Func<IQueryable<object>, Expression<Func<object, object>>, IOrderedQueryable<object>>(Queryable.OrderByDescending).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey);
		}

		public static MethodInfo OrderByDescending_TSource_TKey_3(Type TSource, Type TKey)
		{
			return (s_OrderByDescending_TSource_TKey_3 ?? (s_OrderByDescending_TSource_TKey_3 = new Func<IQueryable<object>, Expression<Func<object, object>>, IComparer<object>, IOrderedQueryable<object>>(Queryable.OrderByDescending).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey);
		}

		public static MethodInfo Reverse_TSource_1(Type TSource)
		{
			return (s_Reverse_TSource_1 ?? (s_Reverse_TSource_1 = new Func<IQueryable<object>, IQueryable<object>>(Queryable.Reverse).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Select_TSource_TResult_2(Type TSource, Type TResult)
		{
			return (s_Select_TSource_TResult_2 ?? (s_Select_TSource_TResult_2 = new Func<IQueryable<object>, Expression<Func<object, object>>, IQueryable<object>>(Queryable.Select).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TResult);
		}

		public static MethodInfo Select_Index_TSource_TResult_2(Type TSource, Type TResult)
		{
			return (s_Select_Index_TSource_TResult_2 ?? (s_Select_Index_TSource_TResult_2 = new Func<IQueryable<object>, Expression<Func<object, int, object>>, IQueryable<object>>(Queryable.Select).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TResult);
		}

		public static MethodInfo SelectMany_TSource_TResult_2(Type TSource, Type TResult)
		{
			return (s_SelectMany_TSource_TResult_2 ?? (s_SelectMany_TSource_TResult_2 = new Func<IQueryable<object>, Expression<Func<object, IEnumerable<object>>>, IQueryable<object>>(Queryable.SelectMany).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TResult);
		}

		public static MethodInfo SelectMany_Index_TSource_TResult_2(Type TSource, Type TResult)
		{
			return (s_SelectMany_Index_TSource_TResult_2 ?? (s_SelectMany_Index_TSource_TResult_2 = new Func<IQueryable<object>, Expression<Func<object, int, IEnumerable<object>>>, IQueryable<object>>(Queryable.SelectMany).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TResult);
		}

		public static MethodInfo SelectMany_Index_TSource_TCollection_TResult_3(Type TSource, Type TCollection, Type TResult)
		{
			return (s_SelectMany_Index_TSource_TCollection_TResult_3 ?? (s_SelectMany_Index_TSource_TCollection_TResult_3 = new Func<IQueryable<object>, Expression<Func<object, int, IEnumerable<object>>>, Expression<Func<object, object, object>>, IQueryable<object>>(Queryable.SelectMany).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TCollection, TResult);
		}

		public static MethodInfo SelectMany_TSource_TCollection_TResult_3(Type TSource, Type TCollection, Type TResult)
		{
			return (s_SelectMany_TSource_TCollection_TResult_3 ?? (s_SelectMany_TSource_TCollection_TResult_3 = new Func<IQueryable<object>, Expression<Func<object, IEnumerable<object>>>, Expression<Func<object, object, object>>, IQueryable<object>>(Queryable.SelectMany).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TCollection, TResult);
		}

		public static MethodInfo SequenceEqual_TSource_2(Type TSource)
		{
			return (s_SequenceEqual_TSource_2 ?? (s_SequenceEqual_TSource_2 = new Func<IQueryable<object>, IEnumerable<object>, bool>(Queryable.SequenceEqual).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo SequenceEqual_TSource_3(Type TSource)
		{
			return (s_SequenceEqual_TSource_3 ?? (s_SequenceEqual_TSource_3 = new Func<IQueryable<object>, IEnumerable<object>, IEqualityComparer<object>, bool>(Queryable.SequenceEqual).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Single_TSource_1(Type TSource)
		{
			return (s_Single_TSource_1 ?? (s_Single_TSource_1 = new Func<IQueryable<object>, object>(Queryable.Single).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Single_TSource_2(Type TSource)
		{
			return (s_Single_TSource_2 ?? (s_Single_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, bool>>, object>(Queryable.Single).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo SingleOrDefault_TSource_1(Type TSource)
		{
			return (s_SingleOrDefault_TSource_1 ?? (s_SingleOrDefault_TSource_1 = new Func<IQueryable<object>, object>(Queryable.SingleOrDefault).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo SingleOrDefault_TSource_2(Type TSource)
		{
			return (s_SingleOrDefault_TSource_2 ?? (s_SingleOrDefault_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, bool>>, object>(Queryable.SingleOrDefault).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Skip_TSource_2(Type TSource)
		{
			return (s_Skip_TSource_2 ?? (s_Skip_TSource_2 = new Func<IQueryable<object>, int, IQueryable<object>>(Queryable.Skip).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo SkipWhile_TSource_2(Type TSource)
		{
			return (s_SkipWhile_TSource_2 ?? (s_SkipWhile_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, bool>>, IQueryable<object>>(Queryable.SkipWhile).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo SkipWhile_Index_TSource_2(Type TSource)
		{
			return (s_SkipWhile_Index_TSource_2 ?? (s_SkipWhile_Index_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, int, bool>>, IQueryable<object>>(Queryable.SkipWhile).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Sum_NullableDecimal_TSource_2(Type TSource)
		{
			return (s_Sum_NullableDecimal_TSource_2 ?? (s_Sum_NullableDecimal_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, decimal?>>, decimal?>(Queryable.Sum).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Sum_Int32_TSource_2(Type TSource)
		{
			return (s_Sum_Int32_TSource_2 ?? (s_Sum_Int32_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, int>>, int>(Queryable.Sum).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Sum_NullableInt32_TSource_2(Type TSource)
		{
			return (s_Sum_NullableInt32_TSource_2 ?? (s_Sum_NullableInt32_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, int?>>, int?>(Queryable.Sum).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Sum_Int64_TSource_2(Type TSource)
		{
			return (s_Sum_Int64_TSource_2 ?? (s_Sum_Int64_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, long>>, long>(Queryable.Sum).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Sum_NullableInt64_TSource_2(Type TSource)
		{
			return (s_Sum_NullableInt64_TSource_2 ?? (s_Sum_NullableInt64_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, long?>>, long?>(Queryable.Sum).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Sum_Single_TSource_2(Type TSource)
		{
			return (s_Sum_Single_TSource_2 ?? (s_Sum_Single_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, float>>, float>(Queryable.Sum).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Sum_NullableSingle_TSource_2(Type TSource)
		{
			return (s_Sum_NullableSingle_TSource_2 ?? (s_Sum_NullableSingle_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, float?>>, float?>(Queryable.Sum).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Sum_Double_TSource_2(Type TSource)
		{
			return (s_Sum_Double_TSource_2 ?? (s_Sum_Double_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, double>>, double>(Queryable.Sum).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Sum_NullableDouble_TSource_2(Type TSource)
		{
			return (s_Sum_NullableDouble_TSource_2 ?? (s_Sum_NullableDouble_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, double?>>, double?>(Queryable.Sum).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Sum_Decimal_TSource_2(Type TSource)
		{
			return (s_Sum_Decimal_TSource_2 ?? (s_Sum_Decimal_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, decimal>>, decimal>(Queryable.Sum).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Take_TSource_2(Type TSource)
		{
			return (s_Take_TSource_2 ?? (s_Take_TSource_2 = new Func<IQueryable<object>, int, IQueryable<object>>(Queryable.Take).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo TakeWhile_TSource_2(Type TSource)
		{
			return (s_TakeWhile_TSource_2 ?? (s_TakeWhile_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, bool>>, IQueryable<object>>(Queryable.TakeWhile).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo TakeWhile_Index_TSource_2(Type TSource)
		{
			return (s_TakeWhile_Index_TSource_2 ?? (s_TakeWhile_Index_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, int, bool>>, IQueryable<object>>(Queryable.TakeWhile).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo ThenBy_TSource_TKey_2(Type TSource, Type TKey)
		{
			return (s_ThenBy_TSource_TKey_2 ?? (s_ThenBy_TSource_TKey_2 = new Func<IOrderedQueryable<object>, Expression<Func<object, object>>, IOrderedQueryable<object>>(Queryable.ThenBy).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey);
		}

		public static MethodInfo ThenBy_TSource_TKey_3(Type TSource, Type TKey)
		{
			return (s_ThenBy_TSource_TKey_3 ?? (s_ThenBy_TSource_TKey_3 = new Func<IOrderedQueryable<object>, Expression<Func<object, object>>, IComparer<object>, IOrderedQueryable<object>>(Queryable.ThenBy).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey);
		}

		public static MethodInfo ThenByDescending_TSource_TKey_2(Type TSource, Type TKey)
		{
			return (s_ThenByDescending_TSource_TKey_2 ?? (s_ThenByDescending_TSource_TKey_2 = new Func<IOrderedQueryable<object>, Expression<Func<object, object>>, IOrderedQueryable<object>>(Queryable.ThenByDescending).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey);
		}

		public static MethodInfo ThenByDescending_TSource_TKey_3(Type TSource, Type TKey)
		{
			return (s_ThenByDescending_TSource_TKey_3 ?? (s_ThenByDescending_TSource_TKey_3 = new Func<IOrderedQueryable<object>, Expression<Func<object, object>>, IComparer<object>, IOrderedQueryable<object>>(Queryable.ThenByDescending).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource, TKey);
		}

		public static MethodInfo Union_TSource_2(Type TSource)
		{
			return (s_Union_TSource_2 ?? (s_Union_TSource_2 = new Func<IQueryable<object>, IEnumerable<object>, IQueryable<object>>(Queryable.Union).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Union_TSource_3(Type TSource)
		{
			return (s_Union_TSource_3 ?? (s_Union_TSource_3 = new Func<IQueryable<object>, IEnumerable<object>, IEqualityComparer<object>, IQueryable<object>>(Queryable.Union).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Where_TSource_2(Type TSource)
		{
			return (s_Where_TSource_2 ?? (s_Where_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, bool>>, IQueryable<object>>(Queryable.Where).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Where_Index_TSource_2(Type TSource)
		{
			return (s_Where_Index_TSource_2 ?? (s_Where_Index_TSource_2 = new Func<IQueryable<object>, Expression<Func<object, int, bool>>, IQueryable<object>>(Queryable.Where).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Zip_TFirst_TSecond_TResult_3(Type TFirst, Type TSecond, Type TResult)
		{
			return (s_Zip_TFirst_TSecond_TResult_3 ?? (s_Zip_TFirst_TSecond_TResult_3 = new Func<IQueryable<object>, IEnumerable<object>, Expression<Func<object, object, object>>, IQueryable<object>>(Queryable.Zip).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TFirst, TSecond, TResult);
		}

		public static MethodInfo SkipLast_TSource_2(Type TSource)
		{
			return (s_SkipLast_TSource_2 ?? (s_SkipLast_TSource_2 = new Func<IQueryable<object>, int, IQueryable<object>>(Queryable.SkipLast).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo TakeLast_TSource_2(Type TSource)
		{
			return (s_TakeLast_TSource_2 ?? (s_TakeLast_TSource_2 = new Func<IQueryable<object>, int, IQueryable<object>>(Queryable.TakeLast).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Append_TSource_2(Type TSource)
		{
			return (s_Append_TSource_2 ?? (s_Append_TSource_2 = new Func<IQueryable<object>, object, IQueryable<object>>(Queryable.Append).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}

		public static MethodInfo Prepend_TSource_2(Type TSource)
		{
			return (s_Prepend_TSource_2 ?? (s_Prepend_TSource_2 = new Func<IQueryable<object>, object, IQueryable<object>>(Queryable.Prepend).GetMethodInfo().GetGenericMethodDefinition())).MakeGenericMethod(TSource);
		}
	}
	/// <summary>Represents an expression tree and provides functionality to execute the expression tree after rewriting it.</summary>
	public abstract class EnumerableExecutor
	{
		internal abstract object ExecuteBoxed();

		internal static EnumerableExecutor Create(Expression expression)
		{
			return (EnumerableExecutor)Activator.CreateInstance(typeof(EnumerableExecutor<>).MakeGenericType(expression.Type), expression);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Linq.EnumerableExecutor" /> class.</summary>
		protected EnumerableExecutor()
		{
		}
	}
	/// <summary>Represents an expression tree and provides functionality to execute the expression tree after rewriting it.</summary>
	/// <typeparam name="T">The data type of the value that results from executing the expression tree.</typeparam>
	public class EnumerableExecutor<T> : EnumerableExecutor
	{
		private readonly Expression _expression;

		/// <summary>Initializes a new instance of the <see cref="T:System.Linq.EnumerableExecutor`1" /> class.</summary>
		/// <param name="expression">An expression tree to associate with the new instance.</param>
		public EnumerableExecutor(Expression expression)
		{
			_expression = expression;
		}

		internal override object ExecuteBoxed()
		{
			return Execute();
		}

		internal T Execute()
		{
			return Expression.Lambda<Func<T>>(new EnumerableRewriter().Visit(_expression), (IEnumerable<ParameterExpression>)null).Compile()();
		}
	}
	/// <summary>Represents an <see cref="T:System.Collections.IEnumerable" /> as an <see cref="T:System.Linq.EnumerableQuery" /> data source. </summary>
	public abstract class EnumerableQuery
	{
		internal abstract Expression Expression { get; }

		internal abstract IEnumerable Enumerable { get; }

		internal static IQueryable Create(Type elementType, IEnumerable sequence)
		{
			return (IQueryable)Activator.CreateInstance(typeof(EnumerableQuery<>).MakeGenericType(elementType), sequence);
		}

		internal static IQueryable Create(Type elementType, Expression expression)
		{
			return (IQueryable)Activator.CreateInstance(typeof(EnumerableQuery<>).MakeGenericType(elementType), expression);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Linq.EnumerableQuery" /> class.</summary>
		protected EnumerableQuery()
		{
		}
	}
	/// <summary>Represents an <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection as an <see cref="T:System.Linq.IQueryable`1" /> data source.</summary>
	/// <typeparam name="T">The type of the data in the collection.</typeparam>
	public class EnumerableQuery<T> : EnumerableQuery, IOrderedQueryable<T>, IQueryable<T>, IEnumerable<T>, IEnumerable, IQueryable, IOrderedQueryable, IQueryProvider
	{
		private readonly Expression _expression;

		private IEnumerable<T> _enumerable;

		/// <summary>Gets the query provider that is associated with this instance.</summary>
		/// <returns>The query provider that is associated with this instance.</returns>
		IQueryProvider IQueryable.Provider => this;

		internal override Expression Expression => _expression;

		internal override IEnumerable Enumerable => _enumerable;

		/// <summary>Gets the expression tree that is associated with or that represents this instance.</summary>
		/// <returns>The expression tree that is associated with or that represents this instance.</returns>
		Expression IQueryable.Expression => _expression;

		/// <summary>Gets the type of the data in the collection that this instance represents.</summary>
		/// <returns>The type of the data in the collection that this instance represents.</returns>
		Type IQueryable.ElementType => typeof(T);

		/// <summary>Initializes a new instance of the <see cref="T:System.Linq.EnumerableQuery`1" /> class and associates it with an <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection.</summary>
		/// <param name="enumerable">A collection to associate with the new instance.</param>
		public EnumerableQuery(IEnumerable<T> enumerable)
		{
			_enumerable = enumerable;
			_expression = Expression.Constant(this);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Linq.EnumerableQuery`1" /> class and associates the instance with an expression tree.</summary>
		/// <param name="expression">An expression tree to associate with the new instance.</param>
		public EnumerableQuery(Expression expression)
		{
			_expression = expression;
		}

		/// <summary>Constructs a new <see cref="T:System.Linq.EnumerableQuery`1" /> object and associates it with a specified expression tree that represents an <see cref="T:System.Linq.IQueryable" /> collection of data.</summary>
		/// <param name="expression">An expression tree that represents an <see cref="T:System.Linq.IQueryable" /> collection of data.</param>
		/// <returns>An <see cref="T:System.Linq.EnumerableQuery`1" /> object that is associated with <paramref name="expression" />.</returns>
		IQueryable IQueryProvider.CreateQuery(Expression expression)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			Type type = TypeHelper.FindGenericType(typeof(IQueryable<>), expression.Type);
			if (type == null)
			{
				throw Error.ArgumentNotValid("expression");
			}
			return EnumerableQuery.Create(type.GetGenericArguments()[0], expression);
		}

		/// <summary>Constructs a new <see cref="T:System.Linq.EnumerableQuery`1" /> object and associates it with a specified expression tree that represents an <see cref="T:System.Linq.IQueryable`1" /> collection of data.</summary>
		/// <param name="expression">An expression tree to execute.</param>
		/// <typeparam name="S">The type of the data in the collection that <paramref name="expression" /> represents.</typeparam>
		/// <returns>An EnumerableQuery object that is associated with <paramref name="expression" />.</returns>
		IQueryable<TElement> IQueryProvider.CreateQuery<TElement>(Expression expression)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (!typeof(IQueryable<TElement>).IsAssignableFrom(expression.Type))
			{
				throw Error.ArgumentNotValid("expression");
			}
			return new EnumerableQuery<TElement>(expression);
		}

		/// <summary>Executes an expression after rewriting it to call <see cref="T:System.Linq.Enumerable" /> methods instead of <see cref="T:System.Linq.Queryable" /> methods on any enumerable data sources that cannot be queried by <see cref="T:System.Linq.Queryable" /> methods.</summary>
		/// <param name="expression">An expression tree to execute.</param>
		/// <returns>The value that results from executing <paramref name="expression" />.</returns>
		object IQueryProvider.Execute(Expression expression)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			return EnumerableExecutor.Create(expression).ExecuteBoxed();
		}

		/// <summary>Executes an expression after rewriting it to call <see cref="T:System.Linq.Enumerable" /> methods instead of <see cref="T:System.Linq.Queryable" /> methods on any enumerable data sources that cannot be queried by <see cref="T:System.Linq.Queryable" /> methods.</summary>
		/// <param name="expression">An expression tree to execute.</param>
		/// <typeparam name="S">The type of the data in the collection that <paramref name="expression" /> represents.</typeparam>
		/// <returns>The value that results from executing <paramref name="expression" />.</returns>
		TElement IQueryProvider.Execute<TElement>(Expression expression)
		{
			if (expression == null)
			{
				throw Error.ArgumentNull("expression");
			}
			if (!typeof(TElement).IsAssignableFrom(expression.Type))
			{
				throw Error.ArgumentNotValid("expression");
			}
			return new EnumerableExecutor<TElement>(expression).Execute();
		}

		/// <summary>Returns an enumerator that can iterate through the associated <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection, or, if it is null, through the collection that results from rewriting the associated expression tree as a query on an <see cref="T:System.Collections.Generic.IEnumerable`1" /> data source and executing it.</summary>
		/// <returns>An enumerator that can be used to iterate through the associated data source.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		/// <summary>Returns an enumerator that can iterate through the associated <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection, or, if it is null, through the collection that results from rewriting the associated expression tree as a query on an <see cref="T:System.Collections.Generic.IEnumerable`1" /> data source and executing it.</summary>
		/// <returns>An enumerator that can be used to iterate through the associated data source.</returns>
		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			return GetEnumerator();
		}

		private IEnumerator<T> GetEnumerator()
		{
			if (_enumerable == null)
			{
				IEnumerable<T> enumerable = Expression.Lambda<Func<IEnumerable<T>>>(new EnumerableRewriter().Visit(_expression), (IEnumerable<ParameterExpression>)null).Compile()();
				if (enumerable == this)
				{
					throw Error.EnumeratingNullEnumerableExpression();
				}
				_enumerable = enumerable;
			}
			return _enumerable.GetEnumerator();
		}

		/// <summary>Returns a textual representation of the enumerable collection or, if it is null, of the expression tree that is associated with this instance.</summary>
		/// <returns>A textual representation of the enumerable collection or, if it is null, of the expression tree that is associated with this instance.</returns>
		public override string ToString()
		{
			if (_expression is ConstantExpression constantExpression && constantExpression.Value == this)
			{
				if (_enumerable != null)
				{
					return _enumerable.ToString();
				}
				return "null";
			}
			return _expression.ToString();
		}
	}
	internal class EnumerableRewriter : ExpressionVisitor
	{
		private Dictionary<LabelTarget, LabelTarget> _targetCache;

		private Dictionary<Type, Type> _equivalentTypeCache;

		private static ILookup<string, MethodInfo> s_seqMethods;

		protected internal override Expression VisitMethodCall(MethodCallExpression m)
		{
			Expression expression = Visit(m.Object);
			ReadOnlyCollection<Expression> readOnlyCollection = Visit(m.Arguments);
			if (expression != m.Object || readOnlyCollection != m.Arguments)
			{
				MethodInfo method = m.Method;
				Type[] typeArgs = (method.IsGenericMethod ? method.GetGenericArguments() : null);
				if ((method.IsStatic || method.DeclaringType.IsAssignableFrom(expression.Type)) && ArgsMatch(method, readOnlyCollection, typeArgs))
				{
					return Expression.Call(expression, method, readOnlyCollection);
				}
				if (method.DeclaringType == typeof(Queryable))
				{
					MethodInfo methodInfo = FindEnumerableMethod(method.Name, readOnlyCollection, typeArgs);
					readOnlyCollection = FixupQuotedArgs(methodInfo, readOnlyCollection);
					return Expression.Call(expression, methodInfo, readOnlyCollection);
				}
				MethodInfo methodInfo2 = FindMethod(method.DeclaringType, method.Name, readOnlyCollection, typeArgs);
				readOnlyCollection = FixupQuotedArgs(methodInfo2, readOnlyCollection);
				return Expression.Call(expression, methodInfo2, readOnlyCollection);
			}
			return m;
		}

		private ReadOnlyCollection<Expression> FixupQuotedArgs(MethodInfo mi, ReadOnlyCollection<Expression> argList)
		{
			ParameterInfo[] parameters = mi.GetParameters();
			if (parameters.Length != 0)
			{
				List<Expression> list = null;
				int i = 0;
				for (int num = parameters.Length; i < num; i++)
				{
					Expression expression = argList[i];
					ParameterInfo parameterInfo = parameters[i];
					expression = FixupQuotedExpression(parameterInfo.ParameterType, expression);
					if (list == null && expression != argList[i])
					{
						list = new List<Expression>(argList.Count);
						for (int j = 0; j < i; j++)
						{
							list.Add(argList[j]);
						}
					}
					list?.Add(expression);
				}
				if (list != null)
				{
					argList = list.AsReadOnly();
				}
			}
			return argList;
		}

		private Expression FixupQuotedExpression(Type type, Expression expression)
		{
			Expression expression2 = expression;
			while (true)
			{
				if (type.IsAssignableFrom(expression2.Type))
				{
					return expression2;
				}
				if (expression2.NodeType != ExpressionType.Quote)
				{
					break;
				}
				expression2 = ((UnaryExpression)expression2).Operand;
			}
			if (!type.IsAssignableFrom(expression2.Type) && type.IsArray && expression2.NodeType == ExpressionType.NewArrayInit)
			{
				Type c = StripExpression(expression2.Type);
				if (type.IsAssignableFrom(c))
				{
					Type elementType = type.GetElementType();
					NewArrayExpression newArrayExpression = (NewArrayExpression)expression2;
					List<Expression> list = new List<Expression>(newArrayExpression.Expressions.Count);
					int i = 0;
					for (int count = newArrayExpression.Expressions.Count; i < count; i++)
					{
						list.Add(FixupQuotedExpression(elementType, newArrayExpression.Expressions[i]));
					}
					expression = Expression.NewArrayInit(elementType, list);
				}
			}
			return expression;
		}

		protected internal override Expression VisitLambda<T>(Expression<T> node)
		{
			return node;
		}

		private static Type GetPublicType(Type t)
		{
			if (t.IsGenericType && t.GetGenericTypeDefinition().GetInterfaces().Contains(typeof(IGrouping<, >)))
			{
				return typeof(IGrouping<, >).MakeGenericType(t.GetGenericArguments());
			}
			if (!t.IsNestedPrivate)
			{
				return t;
			}
			Type[] interfaces = t.GetInterfaces();
			foreach (Type type in interfaces)
			{
				if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(IEnumerable<>))
				{
					return type;
				}
			}
			if (typeof(IEnumerable).IsAssignableFrom(t))
			{
				return typeof(IEnumerable);
			}
			return t;
		}

		private Type GetEquivalentType(Type type)
		{
			if (_equivalentTypeCache == null)
			{
				_equivalentTypeCache = new Dictionary<Type, Type>
				{
					{
						typeof(IQueryable),
						typeof(IEnumerable)
					},
					{
						typeof(IEnumerable),
						typeof(IEnumerable)
					}
				};
			}
			if (!_equivalentTypeCache.TryGetValue(type, out var value))
			{
				Type publicType = GetPublicType(type);
				if (publicType.IsInterface && publicType.IsGenericType)
				{
					Type genericTypeDefinition = publicType.GetGenericTypeDefinition();
					if (genericTypeDefinition == typeof(IOrderedEnumerable<>))
					{
						value = publicType;
					}
					else if (genericTypeDefinition == typeof(IOrderedQueryable<>))
					{
						value = typeof(IOrderedEnumerable<>).MakeGenericType(publicType.GenericTypeArguments[0]);
					}
					else if (genericTypeDefinition == typeof(IEnumerable<>))
					{
						value = publicType;
					}
					else if (genericTypeDefinition == typeof(IQueryable<>))
					{
						value = typeof(IEnumerable<>).MakeGenericType(publicType.GenericTypeArguments[0]);
					}
				}
				if (value == null)
				{
					var source = (from i in publicType.GetInterfaces().Select(IntrospectionExtensions.GetTypeInfo).ToArray()
						where i.IsGenericType && i.GenericTypeArguments.Length == 1
						select new
						{
							Info = i,
							GenType = i.GetGenericTypeDefinition()
						}).ToArray();
					Type type2 = (from i in source
						where i.GenType == typeof(IOrderedQueryable<>) || i.GenType == typeof(IOrderedEnumerable<>)
						select i.Info.GenericTypeArguments[0]).Distinct().SingleOrDefault();
					if (type2 != null)
					{
						value = typeof(IOrderedEnumerable<>).MakeGenericType(type2);
					}
					else
					{
						type2 = (from i in source
							where i.GenType == typeof(IQueryable<>) || i.GenType == typeof(IEnumerable<>)
							select i.Info.GenericTypeArguments[0]).Distinct().Single();
						value = typeof(IEnumerable<>).MakeGenericType(type2);
					}
				}
				_equivalentTypeCache.Add(type, value);
			}
			return value;
		}

		protected internal override Expression VisitConstant(ConstantExpression c)
		{
			if (c.Value is EnumerableQuery enumerableQuery)
			{
				if (enumerableQuery.Enumerable != null)
				{
					Type publicType = GetPublicType(enumerableQuery.Enumerable.GetType());
					return Expression.Constant(enumerableQuery.Enumerable, publicType);
				}
				Expression expression = enumerableQuery.Expression;
				if (expression != c)
				{
					return Visit(expression);
				}
			}
			return c;
		}

		[PreserveDependency("DefaultIfEmpty`1", "System.Linq.Enumerable")]
		[PreserveDependency("Count`1", "System.Linq.Enumerable")]
		[PreserveDependency("Contains`1", "System.Linq.Enumerable")]
		[PreserveDependency("Concat`1", "System.Linq.Enumerable")]
		[PreserveDependency("Cast`1", "System.Linq.Enumerable")]
		[PreserveDependency("Average`1", "System.Linq.Enumerable")]
		[PreserveDependency("Aggregate`1", "System.Linq.Enumerable")]
		[PreserveDependency("Append`1", "System.Linq.Enumerable")]
		[PreserveDependency("Any`1", "System.Linq.Enumerable")]
		[PreserveDependency("All`1", "System.Linq.Enumerable")]
		[PreserveDependency("Aggregate`3", "System.Linq.Enumerable")]
		[PreserveDependency("Aggregate`2", "System.Linq.Enumerable")]
		[PreserveDependency("GroupJoin`4", "System.Linq.Enumerable")]
		[PreserveDependency("Average", "System.Linq.Enumerable")]
		[PreserveDependency("Distinct`1", "System.Linq.Enumerable")]
		[PreserveDependency("Intersect`1", "System.Linq.Enumerable")]
		[PreserveDependency("Sum", "System.Linq.Enumerable")]
		[PreserveDependency("SkipWhile`1", "System.Linq.Enumerable")]
		[PreserveDependency("Except`1", "System.Linq.Enumerable")]
		[PreserveDependency("Sum`1", "System.Linq.Enumerable")]
		[PreserveDependency("Take`1", "System.Linq.Enumerable")]
		[PreserveDependency("TakeLast`1", "System.Linq.Enumerable")]
		[PreserveDependency("TakeWhile`1", "System.Linq.Enumerable")]
		[PreserveDependency("ThenBy`2", "System.Linq.Enumerable")]
		[PreserveDependency("ThenByDescending`2", "System.Linq.Enumerable")]
		[PreserveDependency("Union`1", "System.Linq.Enumerable")]
		[PreserveDependency("Where`1", "System.Linq.Enumerable")]
		[PreserveDependency("Zip`3", "System.Linq.Enumerable")]
		[PreserveDependency("GroupBy`4", "System.Linq.Enumerable")]
		[PreserveDependency("GroupBy`3", "System.Linq.Enumerable")]
		[PreserveDependency("GroupBy`2", "System.Linq.Enumerable")]
		[PreserveDependency("FirstOrDefault`1", "System.Linq.Enumerable")]
		[PreserveDependency("ElementAt`1", "System.Linq.Enumerable")]
		[PreserveDependency("First`1", "System.Linq.Enumerable")]
		[PreserveDependency("SkipLast`1", "System.Linq.Enumerable")]
		[PreserveDependency("Skip`1", "System.Linq.Enumerable")]
		[PreserveDependency("ElementAtOrDefault`1", "System.Linq.Enumerable")]
		[PreserveDependency("Single`1", "System.Linq.Enumerable")]
		[PreserveDependency("Join`4", "System.Linq.Enumerable")]
		[PreserveDependency("Last`1", "System.Linq.Enumerable")]
		[PreserveDependency("LastOrDefault`1", "System.Linq.Enumerable")]
		[PreserveDependency("LongCount`1", "System.Linq.Enumerable")]
		[PreserveDependency("SingleOrDefault`1", "System.Linq.Enumerable")]
		[PreserveDependency("Max`2", "System.Linq.Enumerable")]
		[PreserveDependency("Min`1", "System.Linq.Enumerable")]
		[PreserveDependency("Min`2", "System.Linq.Enumerable")]
		[PreserveDependency("Max`1", "System.Linq.Enumerable")]
		[PreserveDependency("OrderBy`2", "System.Linq.Enumerable")]
		[PreserveDependency("OrderByDescending`2", "System.Linq.Enumerable")]
		[PreserveDependency("Prepend`1", "System.Linq.Enumerable")]
		[PreserveDependency("Reverse`1", "System.Linq.Enumerable")]
		[PreserveDependency("Select`2", "System.Linq.Enumerable")]
		[PreserveDependency("SequenceEqual`1", "System.Linq.Enumerable")]
		[PreserveDependency("SelectMany`3", "System.Linq.Enumerable")]
		[PreserveDependency("SelectMany`2", "System.Linq.Enumerable")]
		[PreserveDependency("OfType`1", "System.Linq.Enumerable")]
		private static MethodInfo FindEnumerableMethod(string name, ReadOnlyCollection<Expression> args, params Type[] typeArgs)
		{
			if (s_seqMethods == null)
			{
				s_seqMethods = typeof(Enumerable).GetStaticMethods().ToLookup((MethodInfo m) => m.Name);
			}
			MethodInfo methodInfo = s_seqMethods[name].FirstOrDefault((MethodInfo m) => ArgsMatch(m, args, typeArgs));
			if (typeArgs != null)
			{
				return methodInfo.MakeGenericMethod(typeArgs);
			}
			return methodInfo;
		}

		private static MethodInfo FindMethod(Type type, string name, ReadOnlyCollection<Expression> args, Type[] typeArgs)
		{
			using (IEnumerator<MethodInfo> enumerator = (from m in type.GetStaticMethods()
				where m.Name == name
				select m).GetEnumerator())
			{
				if (!enumerator.MoveNext())
				{
					throw Error.NoMethodOnType(name, type);
				}
				do
				{
					MethodInfo current = enumerator.Current;
					if (ArgsMatch(current, args, typeArgs))
					{
						return (typeArgs != null) ? current.MakeGenericMethod(typeArgs) : current;
					}
				}
				while (enumerator.MoveNext());
			}
			throw Error.NoMethodOnTypeMatchingArguments(name, type);
		}

		private static bool ArgsMatch(MethodInfo m, ReadOnlyCollection<Expression> args, Type[] typeArgs)
		{
			ParameterInfo[] parameters = m.GetParameters();
			if (parameters.Length != args.Count)
			{
				return false;
			}
			if (!m.IsGenericMethod && typeArgs != null && typeArgs.Length != 0)
			{
				return false;
			}
			if (!m.IsGenericMethodDefinition && m.IsGenericMethod && m.ContainsGenericParameters)
			{
				m = m.GetGenericMethodDefinition();
			}
			if (m.IsGenericMethodDefinition)
			{
				if (typeArgs == null || typeArgs.Length == 0)
				{
					return false;
				}
				if (m.GetGenericArguments().Length != typeArgs.Length)
				{
					return false;
				}
				m = m.MakeGenericMethod(typeArgs);
				parameters = m.GetParameters();
			}
			int i = 0;
			for (int count = args.Count; i < count; i++)
			{
				Type type = parameters[i].ParameterType;
				if (type == null)
				{
					return false;
				}
				if (type.IsByRef)
				{
					type = type.GetElementType();
				}
				Expression expression = args[i];
				if (!type.IsAssignableFrom(expression.Type))
				{
					if (expression.NodeType == ExpressionType.Quote)
					{
						expression = ((UnaryExpression)expression).Operand;
					}
					if (!type.IsAssignableFrom(expression.Type) && !type.IsAssignableFrom(StripExpression(expression.Type)))
					{
						return false;
					}
				}
			}
			return true;
		}

		private static Type StripExpression(Type type)
		{
			bool isArray = type.IsArray;
			Type type2 = (isArray ? type.GetElementType() : type);
			Type type3 = TypeHelper.FindGenericType(typeof(Expression<>), type2);
			if (type3 != null)
			{
				type2 = type3.GetGenericArguments()[0];
			}
			if (isArray)
			{
				int arrayRank = type.GetArrayRank();
				if (arrayRank != 1)
				{
					return type2.MakeArrayType(arrayRank);
				}
				return type2.MakeArrayType();
			}
			return type;
		}

		protected internal override Expression VisitConditional(ConditionalExpression c)
		{
			Type type = c.Type;
			if (!typeof(IQueryable).IsAssignableFrom(type))
			{
				return base.VisitConditional(c);
			}
			Expression test = Visit(c.Test);
			Expression expression = Visit(c.IfTrue);
			Expression expression2 = Visit(c.IfFalse);
			Type type2 = expression.Type;
			Type type3 = expression2.Type;
			if (type2.IsAssignableFrom(type3))
			{
				return Expression.Condition(test, expression, expression2, type2);
			}
			if (type3.IsAssignableFrom(type2))
			{
				return Expression.Condition(test, expression, expression2, type3);
			}
			return Expression.Condition(test, expression, expression2, GetEquivalentType(type));
		}

		protected internal override Expression VisitBlock(BlockExpression node)
		{
			Type type = node.Type;
			if (!typeof(IQueryable).IsAssignableFrom(type))
			{
				return base.VisitBlock(node);
			}
			ReadOnlyCollection<Expression> expressions = Visit(node.Expressions);
			ReadOnlyCollection<ParameterExpression> variables = VisitAndConvert(node.Variables, "EnumerableRewriter.VisitBlock");
			if (type == node.Expressions.Last().Type)
			{
				return Expression.Block(variables, expressions);
			}
			return Expression.Block(GetEquivalentType(type), variables, expressions);
		}

		protected internal override Expression VisitGoto(GotoExpression node)
		{
			Type type = node.Value.Type;
			if (!typeof(IQueryable).IsAssignableFrom(type))
			{
				return base.VisitGoto(node);
			}
			LabelTarget target = VisitLabelTarget(node.Target);
			Expression expression = Visit(node.Value);
			return Expression.MakeGoto(node.Kind, target, expression, GetEquivalentType(typeof(EnumerableQuery).IsAssignableFrom(type) ? expression.Type : type));
		}

		protected override LabelTarget VisitLabelTarget(LabelTarget node)
		{
			LabelTarget value;
			if (_targetCache == null)
			{
				_targetCache = new Dictionary<LabelTarget, LabelTarget>();
			}
			else if (_targetCache.TryGetValue(node, out value))
			{
				return value;
			}
			Type type = node.Type;
			value = (typeof(IQueryable).IsAssignableFrom(type) ? Expression.Label(GetEquivalentType(type), node.Name) : base.VisitLabelTarget(node));
			_targetCache.Add(node, value);
			return value;
		}
	}
	internal static class Error
	{
		internal static Exception ArgumentNotIEnumerableGeneric(string message)
		{
			return new ArgumentException(Strings.ArgumentNotIEnumerableGeneric(message));
		}

		internal static Exception ArgumentNotValid(string message)
		{
			return new ArgumentException(Strings.ArgumentNotValid(message));
		}

		internal static Exception NoMethodOnType(string name, object type)
		{
			return new InvalidOperationException(Strings.NoMethodOnType(name, type));
		}

		internal static Exception NoMethodOnTypeMatchingArguments(string name, object type)
		{
			return new InvalidOperationException(Strings.NoMethodOnTypeMatchingArguments(name, type));
		}

		internal static Exception EnumeratingNullEnumerableExpression()
		{
			return new InvalidOperationException(Strings.EnumeratingNullEnumerableExpression());
		}

		internal static Exception ArgumentNull(string s)
		{
			return new ArgumentNullException(s);
		}

		internal static Exception ArgumentOutOfRange(string s)
		{
			return new ArgumentOutOfRangeException(s);
		}

		internal static Exception MoreThanOneElement()
		{
			return new InvalidOperationException("Sequence contains more than one element");
		}

		internal static Exception MoreThanOneMatch()
		{
			return new InvalidOperationException("Sequence contains more than one matching element");
		}

		internal static Exception NoElements()
		{
			return new InvalidOperationException("Sequence contains no elements");
		}

		internal static Exception NoMatch()
		{
			return new InvalidOperationException("Sequence contains no matching element");
		}

		internal static Exception NotSupported()
		{
			return new NotSupportedException();
		}
	}
	/// <summary>Provides a set of <see langword="static" /> (<see langword="Shared" /> in Visual Basic) methods for querying data structures that implement <see cref="T:System.Linq.IQueryable`1" />.</summary>
	public static class Queryable
	{
		/// <summary>Converts a generic <see cref="T:System.Collections.Generic.IEnumerable`1" /> to a generic <see cref="T:System.Linq.IQueryable`1" />.</summary>
		/// <param name="source">A sequence to convert.</param>
		/// <typeparam name="TElement">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that represents the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IQueryable<TElement> AsQueryable<TElement>(this IEnumerable<TElement> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return (source as IQueryable<TElement>) ?? new EnumerableQuery<TElement>(source);
		}

		/// <summary>Converts an <see cref="T:System.Collections.IEnumerable" /> to an <see cref="T:System.Linq.IQueryable" />.</summary>
		/// <param name="source">A sequence to convert.</param>
		/// <returns>An <see cref="T:System.Linq.IQueryable" /> that represents the input sequence.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="source" /> does not implement <see cref="T:System.Collections.Generic.IEnumerable`1" /> for some <paramref name="T" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IQueryable AsQueryable(this IEnumerable source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IQueryable result)
			{
				return result;
			}
			Type type = TypeHelper.FindGenericType(typeof(IEnumerable<>), source.GetType());
			if (type == null)
			{
				throw Error.ArgumentNotIEnumerableGeneric("source");
			}
			return EnumerableQuery.Create(type.GenericTypeArguments[0], source);
		}

		/// <summary>Filters a sequence of values based on a predicate.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to filter.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements from the input sequence that satisfy the condition specified by <paramref name="predicate" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> Where<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Where_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to filter.</param>
		/// <param name="predicate">A function to test each element for a condition; the second parameter of the function represents the index of the element in the source sequence.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements from the input sequence that satisfy the condition specified by <paramref name="predicate" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> Where<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Where_Index_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Filters the elements of an <see cref="T:System.Linq.IQueryable" /> based on a specified type.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable" /> whose elements to filter.</param>
		/// <typeparam name="TResult">The type to filter the elements of the sequence on.</typeparam>
		/// <returns>A collection that contains the elements from <paramref name="source" /> that have type <paramref name="TResult" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> OfType<TResult>(this IQueryable source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.OfType_TResult_1(typeof(TResult)), source.Expression));
		}

		/// <summary>Converts the elements of an <see cref="T:System.Linq.IQueryable" /> to the specified type.</summary>
		/// <param name="source">The <see cref="T:System.Linq.IQueryable" /> that contains the elements to be converted.</param>
		/// <typeparam name="TResult">The type to convert the elements of <paramref name="source" /> to.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains each element of the source sequence converted to the specified type.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidCastException">An element in the sequence cannot be cast to type <paramref name="TResult" />.</exception>
		public static IQueryable<TResult> Cast<TResult>(this IQueryable source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.Cast_TResult_1(typeof(TResult)), source.Expression));
		}

		/// <summary>Projects each element of a sequence into a new form.</summary>
		/// <param name="source">A sequence of values to project.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the value returned by the function represented by <paramref name="selector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> whose elements are the result of invoking a projection function on each element of <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> Select<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.Select_TSource_TResult_2(typeof(TSource), typeof(TResult)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Projects each element of a sequence into a new form by incorporating the element's index.</summary>
		/// <param name="source">A sequence of values to project.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the value returned by the function represented by <paramref name="selector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> whose elements are the result of invoking a projection function on each element of <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> Select<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, TResult>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.Select_Index_TSource_TResult_2(typeof(TSource), typeof(TResult)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" /> and combines the resulting sequences into one sequence.</summary>
		/// <param name="source">A sequence of values to project.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the sequence returned by the function represented by <paramref name="selector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> whose elements are the result of invoking a one-to-many projection function on each element of the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> SelectMany<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TResult>>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.SelectMany_TSource_TResult_2(typeof(TSource), typeof(TResult)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" /> and combines the resulting sequences into one sequence. The index of each source element is used in the projected form of that element.</summary>
		/// <param name="source">A sequence of values to project.</param>
		/// <param name="selector">A projection function to apply to each element; the second parameter of this function represents the index of the source element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the sequence returned by the function represented by <paramref name="selector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> whose elements are the result of invoking a one-to-many projection function on each element of the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> SelectMany<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, IEnumerable<TResult>>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.SelectMany_Index_TSource_TResult_2(typeof(TSource), typeof(TResult)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" /> that incorporates the index of the source element that produced it. A result selector function is invoked on each element of each intermediate sequence, and the resulting values are combined into a single, one-dimensional sequence and returned.</summary>
		/// <param name="source">A sequence of values to project.</param>
		/// <param name="collectionSelector">A projection function to apply to each element of the input sequence; the second parameter of this function represents the index of the source element.</param>
		/// <param name="resultSelector">A projection function to apply to each element of each intermediate sequence.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TCollection">The type of the intermediate elements collected by the function represented by <paramref name="collectionSelector" />.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> whose elements are the result of invoking the one-to-many projection function <paramref name="collectionSelector" /> on each element of <paramref name="source" /> and then mapping each of those sequence elements and their corresponding <paramref name="source" /> element to a result element.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="collectionSelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, int, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (collectionSelector == null)
			{
				throw Error.ArgumentNull("collectionSelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.SelectMany_Index_TSource_TCollection_TResult_3(typeof(TSource), typeof(TCollection), typeof(TResult)), source.Expression, Expression.Quote(collectionSelector), Expression.Quote(resultSelector)));
		}

		/// <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" /> and invokes a result selector function on each element therein. The resulting values from each intermediate sequence are combined into a single, one-dimensional sequence and returned.</summary>
		/// <param name="source">A sequence of values to project.</param>
		/// <param name="collectionSelector">A projection function to apply to each element of the input sequence.</param>
		/// <param name="resultSelector">A projection function to apply to each element of each intermediate sequence.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TCollection">The type of the intermediate elements collected by the function represented by <paramref name="collectionSelector" />.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> whose elements are the result of invoking the one-to-many projection function <paramref name="collectionSelector" /> on each element of <paramref name="source" /> and then mapping each of those sequence elements and their corresponding <paramref name="source" /> element to a result element.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="collectionSelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> SelectMany<TSource, TCollection, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, IEnumerable<TCollection>>> collectionSelector, Expression<Func<TSource, TCollection, TResult>> resultSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (collectionSelector == null)
			{
				throw Error.ArgumentNull("collectionSelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.SelectMany_TSource_TCollection_TResult_3(typeof(TSource), typeof(TCollection), typeof(TResult)), source.Expression, Expression.Quote(collectionSelector), Expression.Quote(resultSelector)));
		}

		private static Expression GetSourceExpression<TSource>(IEnumerable<TSource> source)
		{
			if (!(source is IQueryable<TSource> queryable))
			{
				return Expression.Constant(source, typeof(IEnumerable<TSource>));
			}
			return queryable.Expression;
		}

		/// <summary>Correlates the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.</summary>
		/// <param name="outer">The first sequence to join.</param>
		/// <param name="inner">The sequence to join to the first sequence.</param>
		/// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
		/// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
		/// <param name="resultSelector">A function to create a result element from two matching elements.</param>
		/// <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
		/// <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
		/// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
		/// <typeparam name="TResult">The type of the result elements.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that has elements of type <paramref name="TResult" /> obtained by performing an inner join on two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return outer.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.Join_TOuter_TInner_TKey_TResult_5(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult)), outer.Expression, GetSourceExpression(inner), Expression.Quote(outerKeySelector), Expression.Quote(innerKeySelector), Expression.Quote(resultSelector)));
		}

		/// <summary>Correlates the elements of two sequences based on matching keys. A specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> is used to compare keys.</summary>
		/// <param name="outer">The first sequence to join.</param>
		/// <param name="inner">The sequence to join to the first sequence.</param>
		/// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
		/// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
		/// <param name="resultSelector">A function to create a result element from two matching elements.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to hash and compare keys.</param>
		/// <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
		/// <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
		/// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
		/// <typeparam name="TResult">The type of the result elements.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that has elements of type <paramref name="TResult" /> obtained by performing an inner join on two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> Join<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, TInner, TResult>> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return outer.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.Join_TOuter_TInner_TKey_TResult_6(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult)), outer.Expression, GetSourceExpression(inner), Expression.Quote(outerKeySelector), Expression.Quote(innerKeySelector), Expression.Quote(resultSelector), Expression.Constant(comparer, typeof(IEqualityComparer<TKey>))));
		}

		/// <summary>Correlates the elements of two sequences based on key equality and groups the results. The default equality comparer is used to compare keys.</summary>
		/// <param name="outer">The first sequence to join.</param>
		/// <param name="inner">The sequence to join to the first sequence.</param>
		/// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
		/// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
		/// <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
		/// <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
		/// <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
		/// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
		/// <typeparam name="TResult">The type of the result elements.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements of type <paramref name="TResult" /> obtained by performing a grouped join on two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return outer.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.GroupJoin_TOuter_TInner_TKey_TResult_5(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult)), outer.Expression, GetSourceExpression(inner), Expression.Quote(outerKeySelector), Expression.Quote(innerKeySelector), Expression.Quote(resultSelector)));
		}

		/// <summary>Correlates the elements of two sequences based on key equality and groups the results. A specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> is used to compare keys.</summary>
		/// <param name="outer">The first sequence to join.</param>
		/// <param name="inner">The sequence to join to the first sequence.</param>
		/// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
		/// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
		/// <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
		/// <param name="comparer">A comparer to hash and compare keys.</param>
		/// <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
		/// <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
		/// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
		/// <typeparam name="TResult">The type of the result elements.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements of type <paramref name="TResult" /> obtained by performing a grouped join on two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IQueryable<TOuter> outer, IEnumerable<TInner> inner, Expression<Func<TOuter, TKey>> outerKeySelector, Expression<Func<TInner, TKey>> innerKeySelector, Expression<Func<TOuter, IEnumerable<TInner>, TResult>> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return outer.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.GroupJoin_TOuter_TInner_TKey_TResult_6(typeof(TOuter), typeof(TInner), typeof(TKey), typeof(TResult)), outer.Expression, GetSourceExpression(inner), Expression.Quote(outerKeySelector), Expression.Quote(innerKeySelector), Expression.Quote(resultSelector), Expression.Constant(comparer, typeof(IEqualityComparer<TKey>))));
		}

		/// <summary>Sorts the elements of a sequence in ascending order according to a key.</summary>
		/// <param name="source">A sequence of values to order.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function that is represented by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedQueryable`1" /> whose elements are sorted according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IOrderedQueryable<TSource> OrderBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.OrderBy_TSource_TKey_2(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector)));
		}

		/// <summary>Sorts the elements of a sequence in ascending order by using a specified comparer.</summary>
		/// <param name="source">A sequence of values to order.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function that is represented by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedQueryable`1" /> whose elements are sorted according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
		public static IOrderedQueryable<TSource> OrderBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.OrderBy_TSource_TKey_3(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector), Expression.Constant(comparer, typeof(IComparer<TKey>))));
		}

		/// <summary>Sorts the elements of a sequence in descending order according to a key.</summary>
		/// <param name="source">A sequence of values to order.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function that is represented by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedQueryable`1" /> whose elements are sorted in descending order according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IOrderedQueryable<TSource> OrderByDescending<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.OrderByDescending_TSource_TKey_2(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector)));
		}

		/// <summary>Sorts the elements of a sequence in descending order by using a specified comparer.</summary>
		/// <param name="source">A sequence of values to order.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function that is represented by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedQueryable`1" /> whose elements are sorted in descending order according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
		public static IOrderedQueryable<TSource> OrderByDescending<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.OrderByDescending_TSource_TKey_3(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector), Expression.Constant(comparer, typeof(IComparer<TKey>))));
		}

		/// <summary>Performs a subsequent ordering of the elements in a sequence in ascending order according to a key.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IOrderedQueryable`1" /> that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function represented by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedQueryable`1" /> whose elements are sorted according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IOrderedQueryable<TSource> ThenBy<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.ThenBy_TSource_TKey_2(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector)));
		}

		/// <summary>Performs a subsequent ordering of the elements in a sequence in ascending order by using a specified comparer.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IOrderedQueryable`1" /> that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function represented by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedQueryable`1" /> whose elements are sorted according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
		public static IOrderedQueryable<TSource> ThenBy<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.ThenBy_TSource_TKey_3(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector), Expression.Constant(comparer, typeof(IComparer<TKey>))));
		}

		/// <summary>Performs a subsequent ordering of the elements in a sequence in descending order, according to a key.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IOrderedQueryable`1" /> that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function represented by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedQueryable`1" /> whose elements are sorted in descending order according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IOrderedQueryable<TSource> ThenByDescending<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.ThenByDescending_TSource_TKey_2(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector)));
		}

		/// <summary>Performs a subsequent ordering of the elements in a sequence in descending order by using a specified comparer.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IOrderedQueryable`1" /> that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key that is returned by the <paramref name="keySelector" /> function.</typeparam>
		/// <returns>A collection whose elements are sorted in descending order according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
		public static IOrderedQueryable<TSource> ThenByDescending<TSource, TKey>(this IOrderedQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return (IOrderedQueryable<TSource>)source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.ThenByDescending_TSource_TKey_3(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector), Expression.Constant(comparer, typeof(IComparer<TKey>))));
		}

		/// <summary>Returns a specified number of contiguous elements from the start of a sequence.</summary>
		/// <param name="source">The sequence to return elements from.</param>
		/// <param name="count">The number of elements to return.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains the specified number of elements from the start of <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> Take<TSource>(this IQueryable<TSource> source, int count)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Take_TSource_2(typeof(TSource)), source.Expression, Expression.Constant(count)));
		}

		/// <summary>Returns elements from a sequence as long as a specified condition is true.</summary>
		/// <param name="source">The sequence to return elements from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements from the input sequence occurring before the element at which the test specified by <paramref name="predicate" /> no longer passes.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> TakeWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.TakeWhile_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Returns elements from a sequence as long as a specified condition is true. The element's index is used in the logic of the predicate function.</summary>
		/// <param name="source">The sequence to return elements from.</param>
		/// <param name="predicate">A function to test each element for a condition; the second parameter of the function represents the index of the element in the source sequence.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements from the input sequence occurring before the element at which the test specified by <paramref name="predicate" /> no longer passes.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> TakeWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.TakeWhile_Index_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Bypasses a specified number of elements in a sequence and then returns the remaining elements.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return elements from.</param>
		/// <param name="count">The number of elements to skip before returning the remaining elements.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements that occur after the specified index in the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> Skip<TSource>(this IQueryable<TSource> source, int count)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Skip_TSource_2(typeof(TSource)), source.Expression, Expression.Constant(count)));
		}

		/// <summary>Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return elements from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements from <paramref name="source" /> starting at the first element in the linear series that does not pass the test specified by <paramref name="predicate" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> SkipWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.SkipWhile_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements. The element's index is used in the logic of the predicate function.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return elements from.</param>
		/// <param name="predicate">A function to test each element for a condition; the second parameter of this function represents the index of the source element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains elements from <paramref name="source" /> starting at the first element in the linear series that does not pass the test specified by <paramref name="predicate" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> SkipWhile<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.SkipWhile_Index_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector" />.</typeparam>
		/// <returns>An IQueryable&lt;IGrouping&lt;TKey, TSource&gt;&gt; in C# or IQueryable(Of IGrouping(Of TKey, TSource)) in Visual Basic where each <see cref="T:System.Linq.IGrouping`2" /> object contains a sequence of objects and a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return source.Provider.CreateQuery<IGrouping<TKey, TSource>>(Expression.Call(null, CachedReflectionInfo.GroupBy_TSource_TKey_2(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector)));
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function and projects the elements for each group by using a specified function.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="elementSelector">A function to map each source element to an element in an <see cref="T:System.Linq.IGrouping`2" />.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the elements in each <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
		/// <returns>An IQueryable&lt;IGrouping&lt;TKey, TElement&gt;&gt; in C# or IQueryable(Of IGrouping(Of TKey, TElement)) in Visual Basic where each <see cref="T:System.Linq.IGrouping`2" /> contains a sequence of objects of type <paramref name="TElement" /> and a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is <see langword="null" />.</exception>
		public static IQueryable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (elementSelector == null)
			{
				throw Error.ArgumentNull("elementSelector");
			}
			return source.Provider.CreateQuery<IGrouping<TKey, TElement>>(Expression.Call(null, CachedReflectionInfo.GroupBy_TSource_TKey_TElement_3(typeof(TSource), typeof(TKey), typeof(TElement)), source.Expression, Expression.Quote(keySelector), Expression.Quote(elementSelector)));
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function and compares the keys by using a specified comparer.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector" />.</typeparam>
		/// <returns>An IQueryable&lt;IGrouping&lt;TKey, TSource&gt;&gt; in C# or IQueryable(Of IGrouping(Of TKey, TSource)) in Visual Basic where each <see cref="T:System.Linq.IGrouping`2" /> contains a sequence of objects and a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
		public static IQueryable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return source.Provider.CreateQuery<IGrouping<TKey, TSource>>(Expression.Call(null, CachedReflectionInfo.GroupBy_TSource_TKey_3(typeof(TSource), typeof(TKey)), source.Expression, Expression.Quote(keySelector), Expression.Constant(comparer, typeof(IEqualityComparer<TKey>))));
		}

		/// <summary>Groups the elements of a sequence and projects the elements for each group by using a specified function. Key values are compared by using a specified comparer.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="elementSelector">A function to map each source element to an element in an <see cref="T:System.Linq.IGrouping`2" />.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the elements in each <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
		/// <returns>An IQueryable&lt;IGrouping&lt;TKey, TElement&gt;&gt; in C# or IQueryable(Of IGrouping(Of TKey, TElement)) in Visual Basic where each <see cref="T:System.Linq.IGrouping`2" /> contains a sequence of objects of type <paramref name="TElement" /> and a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
		public static IQueryable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (elementSelector == null)
			{
				throw Error.ArgumentNull("elementSelector");
			}
			return source.Provider.CreateQuery<IGrouping<TKey, TElement>>(Expression.Call(null, CachedReflectionInfo.GroupBy_TSource_TKey_TElement_4(typeof(TSource), typeof(TKey), typeof(TElement)), source.Expression, Expression.Quote(keySelector), Expression.Quote(elementSelector), Expression.Constant(comparer, typeof(IEqualityComparer<TKey>))));
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. The elements of each group are projected by using a specified function.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="elementSelector">A function to map each source element to an element in an <see cref="T:System.Linq.IGrouping`2" />.</param>
		/// <param name="resultSelector">A function to create a result value from each group.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the elements in each <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
		/// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
		/// <returns>An T:System.Linq.IQueryable`1 that has a type argument of <paramref name="TResult" /> and where each element represents a projection over a group and its key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (elementSelector == null)
			{
				throw Error.ArgumentNull("elementSelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.GroupBy_TSource_TKey_TElement_TResult_4(typeof(TSource), typeof(TKey), typeof(TElement), typeof(TResult)), source.Expression, Expression.Quote(keySelector), Expression.Quote(elementSelector), Expression.Quote(resultSelector)));
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="resultSelector">A function to create a result value from each group.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
		/// <returns>An T:System.Linq.IQueryable`1 that has a type argument of <paramref name="TResult" /> and where each element represents a projection over a group and its key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> GroupBy<TSource, TKey, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.GroupBy_TSource_TKey_TResult_3(typeof(TSource), typeof(TKey), typeof(TResult)), source.Expression, Expression.Quote(keySelector), Expression.Quote(resultSelector)));
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. Keys are compared by using a specified comparer.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="resultSelector">A function to create a result value from each group.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
		/// <returns>An T:System.Linq.IQueryable`1 that has a type argument of <paramref name="TResult" /> and where each element represents a projection over a group and its key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="resultSelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> GroupBy<TSource, TKey, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TKey, IEnumerable<TSource>, TResult>> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.GroupBy_TSource_TKey_TResult_4(typeof(TSource), typeof(TKey), typeof(TResult)), source.Expression, Expression.Quote(keySelector), Expression.Quote(resultSelector), Expression.Constant(comparer, typeof(IEqualityComparer<TKey>))));
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. Keys are compared by using a specified comparer and the elements of each group are projected by using a specified function.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="elementSelector">A function to map each source element to an element in an <see cref="T:System.Linq.IGrouping`2" />.</param>
		/// <param name="resultSelector">A function to create a result value from each group.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by the function represented in <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the elements in each <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
		/// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
		/// <returns>An T:System.Linq.IQueryable`1 that has a type argument of <paramref name="TResult" /> and where each element represents a projection over a group and its key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> or <paramref name="resultSelector" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
		public static IQueryable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TKey>> keySelector, Expression<Func<TSource, TElement>> elementSelector, Expression<Func<TKey, IEnumerable<TElement>, TResult>> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (elementSelector == null)
			{
				throw Error.ArgumentNull("elementSelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return source.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.GroupBy_TSource_TKey_TElement_TResult_5(typeof(TSource), typeof(TKey), typeof(TElement), typeof(TResult)), source.Expression, Expression.Quote(keySelector), Expression.Quote(elementSelector), Expression.Quote(resultSelector), Expression.Constant(comparer, typeof(IEqualityComparer<TKey>))));
		}

		/// <summary>Returns distinct elements from a sequence by using the default equality comparer to compare values.</summary>
		/// <param name="source">The <see cref="T:System.Linq.IQueryable`1" /> to remove duplicates from.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains distinct elements from <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> Distinct<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Distinct_TSource_1(typeof(TSource)), source.Expression));
		}

		/// <summary>Returns distinct elements from a sequence by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</summary>
		/// <param name="source">The <see cref="T:System.Linq.IQueryable`1" /> to remove duplicates from.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains distinct elements from <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="comparer" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> Distinct<TSource>(this IQueryable<TSource> source, IEqualityComparer<TSource> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Distinct_TSource_2(typeof(TSource)), source.Expression, Expression.Constant(comparer, typeof(IEqualityComparer<TSource>))));
		}

		/// <summary>Concatenates two sequences.</summary>
		/// <param name="source1">The first sequence to concatenate.</param>
		/// <param name="source2">The sequence to concatenate to the first sequence.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains the concatenated elements of the two input sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> Concat<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Concat_TSource_2(typeof(TSource)), source1.Expression, GetSourceExpression(source2)));
		}

		/// <summary>Merges two sequences by using the specified predicate function.</summary>
		/// <param name="source1">The first sequence to merge.</param>
		/// <param name="source2">The second sequence to merge.</param>
		/// <param name="resultSelector">A function that specifies how to merge the elements from the two sequences.</param>
		/// <typeparam name="TFirst">The type of the elements of the first input sequence.</typeparam>
		/// <typeparam name="TSecond">The type of the elements of the second input sequence.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the result sequence.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains merged elements of two input sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source1" />or <paramref name="source2 " />is <see langword="null" />.</exception>
		public static IQueryable<TResult> Zip<TFirst, TSecond, TResult>(this IQueryable<TFirst> source1, IEnumerable<TSecond> source2, Expression<Func<TFirst, TSecond, TResult>> resultSelector)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return source1.Provider.CreateQuery<TResult>(Expression.Call(null, CachedReflectionInfo.Zip_TFirst_TSecond_TResult_3(typeof(TFirst), typeof(TSecond), typeof(TResult)), source1.Expression, GetSourceExpression(source2), Expression.Quote(resultSelector)));
		}

		/// <summary>Produces the set union of two sequences by using the default equality comparer.</summary>
		/// <param name="source1">A sequence whose distinct elements form the first set for the union operation.</param>
		/// <param name="source2">A sequence whose distinct elements form the second set for the union operation.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains the elements from both input sequences, excluding duplicates.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> Union<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Union_TSource_2(typeof(TSource)), source1.Expression, GetSourceExpression(source2)));
		}

		/// <summary>Produces the set union of two sequences by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
		/// <param name="source1">A sequence whose distinct elements form the first set for the union operation.</param>
		/// <param name="source2">A sequence whose distinct elements form the second set for the union operation.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains the elements from both input sequences, excluding duplicates.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> Union<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Union_TSource_3(typeof(TSource)), source1.Expression, GetSourceExpression(source2), Expression.Constant(comparer, typeof(IEqualityComparer<TSource>))));
		}

		/// <summary>Produces the set intersection of two sequences by using the default equality comparer to compare values.</summary>
		/// <param name="source1">A sequence whose distinct elements that also appear in <paramref name="source2" /> are returned.</param>
		/// <param name="source2">A sequence whose distinct elements that also appear in the first sequence are returned.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>A sequence that contains the set intersection of the two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> Intersect<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Intersect_TSource_2(typeof(TSource)), source1.Expression, GetSourceExpression(source2)));
		}

		/// <summary>Produces the set intersection of two sequences by using the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</summary>
		/// <param name="source1">An <see cref="T:System.Linq.IQueryable`1" /> whose distinct elements that also appear in <paramref name="source2" /> are returned.</param>
		/// <param name="source2">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose distinct elements that also appear in the first sequence are returned.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains the set intersection of the two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> Intersect<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Intersect_TSource_3(typeof(TSource)), source1.Expression, GetSourceExpression(source2), Expression.Constant(comparer, typeof(IEqualityComparer<TSource>))));
		}

		/// <summary>Produces the set difference of two sequences by using the default equality comparer to compare values.</summary>
		/// <param name="source1">An <see cref="T:System.Linq.IQueryable`1" /> whose elements that are not also in <paramref name="source2" /> will be returned.</param>
		/// <param name="source2">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements that also occur in the first sequence will not appear in the returned sequence.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains the set difference of the two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> Except<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Except_TSource_2(typeof(TSource)), source1.Expression, GetSourceExpression(source2)));
		}

		/// <summary>Produces the set difference of two sequences by using the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</summary>
		/// <param name="source1">An <see cref="T:System.Linq.IQueryable`1" /> whose elements that are not also in <paramref name="source2" /> will be returned.</param>
		/// <param name="source2">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements that also occur in the first sequence will not appear in the returned sequence.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains the set difference of the two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> Except<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Except_TSource_3(typeof(TSource)), source1.Expression, GetSourceExpression(source2), Expression.Constant(comparer, typeof(IEqualityComparer<TSource>))));
		}

		/// <summary>Returns the first element of a sequence.</summary>
		/// <param name="source">The <see cref="T:System.Linq.IQueryable`1" /> to return the first element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The first element in <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The source sequence is empty.</exception>
		public static TSource First<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.First_TSource_1(typeof(TSource)), source.Expression));
		}

		/// <summary>Returns the first element of a sequence that satisfies a specified condition.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return an element from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The first element in <paramref name="source" /> that passes the test in <paramref name="predicate" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">No element satisfies the condition in <paramref name="predicate" />.-or-The source sequence is empty.</exception>
		public static TSource First<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.First_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Returns the first element of a sequence, or a default value if the sequence contains no elements.</summary>
		/// <param name="source">The <see cref="T:System.Linq.IQueryable`1" /> to return the first element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     default(<paramref name="TSource" />) if <paramref name="source" /> is empty; otherwise, the first element in <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static TSource FirstOrDefault<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.FirstOrDefault_TSource_1(typeof(TSource)), source.Expression));
		}

		/// <summary>Returns the first element of a sequence that satisfies a specified condition or a default value if no such element is found.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return an element from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     default(<paramref name="TSource" />) if <paramref name="source" /> is empty or if no element passes the test specified by <paramref name="predicate" />; otherwise, the first element in <paramref name="source" /> that passes the test specified by <paramref name="predicate" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static TSource FirstOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.FirstOrDefault_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Returns the last element in a sequence.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return the last element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The value at the last position in <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The source sequence is empty.</exception>
		public static TSource Last<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.Last_TSource_1(typeof(TSource)), source.Expression));
		}

		/// <summary>Returns the last element of a sequence that satisfies a specified condition.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return an element from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The last element in <paramref name="source" /> that passes the test specified by <paramref name="predicate" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">No element satisfies the condition in <paramref name="predicate" />.-or-The source sequence is empty.</exception>
		public static TSource Last<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.Last_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Returns the last element in a sequence, or a default value if the sequence contains no elements.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return the last element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     default(<paramref name="TSource" />) if <paramref name="source" /> is empty; otherwise, the last element in <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static TSource LastOrDefault<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.LastOrDefault_TSource_1(typeof(TSource)), source.Expression));
		}

		/// <summary>Returns the last element of a sequence that satisfies a condition or a default value if no such element is found.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return an element from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     default(<paramref name="TSource" />) if <paramref name="source" /> is empty or if no elements pass the test in the predicate function; otherwise, the last element of <paramref name="source" /> that passes the test in the predicate function.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static TSource LastOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.LastOrDefault_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Returns the only element of a sequence, and throws an exception if there is not exactly one element in the sequence.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return the single element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The single element of the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> has more than one element.</exception>
		public static TSource Single<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.Single_TSource_1(typeof(TSource)), source.Expression));
		}

		/// <summary>Returns the only element of a sequence that satisfies a specified condition, and throws an exception if more than one such element exists.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return a single element from.</param>
		/// <param name="predicate">A function to test an element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The single element of the input sequence that satisfies the condition in <paramref name="predicate" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">No element satisfies the condition in <paramref name="predicate" />.-or-More than one element satisfies the condition in <paramref name="predicate" />.-or-The source sequence is empty.</exception>
		public static TSource Single<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.Single_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Returns the only element of a sequence, or a default value if the sequence is empty; this method throws an exception if there is more than one element in the sequence.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return the single element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The single element of the input sequence, or default(<paramref name="TSource" />) if the sequence contains no elements.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> has more than one element.</exception>
		public static TSource SingleOrDefault<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.SingleOrDefault_TSource_1(typeof(TSource)), source.Expression));
		}

		/// <summary>Returns the only element of a sequence that satisfies a specified condition or a default value if no such element exists; this method throws an exception if more than one element satisfies the condition.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return a single element from.</param>
		/// <param name="predicate">A function to test an element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The single element of the input sequence that satisfies the condition in <paramref name="predicate" />, or default(<paramref name="TSource" />) if no such element is found.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">More than one element satisfies the condition in <paramref name="predicate" />.</exception>
		public static TSource SingleOrDefault<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.SingleOrDefault_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Returns the element at a specified index in a sequence.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return an element from.</param>
		/// <param name="index">The zero-based index of the element to retrieve.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The element at the specified position in <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="index" /> is less than zero.</exception>
		public static TSource ElementAt<TSource>(this IQueryable<TSource> source, int index)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (index < 0)
			{
				throw Error.ArgumentOutOfRange("index");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.ElementAt_TSource_2(typeof(TSource)), source.Expression, Expression.Constant(index)));
		}

		/// <summary>Returns the element at a specified index in a sequence or a default value if the index is out of range.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> to return an element from.</param>
		/// <param name="index">The zero-based index of the element to retrieve.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     default(<paramref name="TSource" />) if <paramref name="index" /> is outside the bounds of <paramref name="source" />; otherwise, the element at the specified position in <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static TSource ElementAtOrDefault<TSource>(this IQueryable<TSource> source, int index)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.ElementAtOrDefault_TSource_2(typeof(TSource)), source.Expression, Expression.Constant(index)));
		}

		/// <summary>Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the sequence is empty.</summary>
		/// <param name="source">The <see cref="T:System.Linq.IQueryable`1" /> to return a default value for if empty.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains <see langword="default" />(<paramref name="TSource" />) if <paramref name="source" /> is empty; otherwise, <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> DefaultIfEmpty<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.DefaultIfEmpty_TSource_1(typeof(TSource)), source.Expression));
		}

		/// <summary>Returns the elements of the specified sequence or the specified value in a singleton collection if the sequence is empty.</summary>
		/// <param name="source">The <see cref="T:System.Linq.IQueryable`1" /> to return the specified value for if empty.</param>
		/// <param name="defaultValue">The value to return if the sequence is empty.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> that contains <paramref name="defaultValue" /> if <paramref name="source" /> is empty; otherwise, <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> DefaultIfEmpty<TSource>(this IQueryable<TSource> source, TSource defaultValue)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.DefaultIfEmpty_TSource_2(typeof(TSource)), source.Expression, Expression.Constant(defaultValue, typeof(TSource))));
		}

		/// <summary>Determines whether a sequence contains a specified element by using the default equality comparer.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> in which to locate <paramref name="item" />.</param>
		/// <param name="item">The object to locate in the sequence.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="true" /> if the input sequence contains an element that has the specified value; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static bool Contains<TSource>(this IQueryable<TSource> source, TSource item)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<bool>(Expression.Call(null, CachedReflectionInfo.Contains_TSource_2(typeof(TSource)), source.Expression, Expression.Constant(item, typeof(TSource))));
		}

		/// <summary>Determines whether a sequence contains a specified element by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> in which to locate <paramref name="item" />.</param>
		/// <param name="item">The object to locate in the sequence.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="true" /> if the input sequence contains an element that has the specified value; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static bool Contains<TSource>(this IQueryable<TSource> source, TSource item, IEqualityComparer<TSource> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<bool>(Expression.Call(null, CachedReflectionInfo.Contains_TSource_3(typeof(TSource)), source.Expression, Expression.Constant(item, typeof(TSource)), Expression.Constant(comparer, typeof(IEqualityComparer<TSource>))));
		}

		/// <summary>Inverts the order of the elements in a sequence.</summary>
		/// <param name="source">A sequence of values to reverse.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IQueryable`1" /> whose elements correspond to those of the input sequence in reverse order.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IQueryable<TSource> Reverse<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Reverse_TSource_1(typeof(TSource)), source.Expression));
		}

		/// <summary>Determines whether two sequences are equal by using the default equality comparer to compare elements.</summary>
		/// <param name="source1">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to compare to those of <paramref name="source2" />.</param>
		/// <param name="source2">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements to compare to those of the first sequence.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>
		///     <see langword="true" /> if the two source sequences are of equal length and their corresponding elements compare equal; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
		public static bool SequenceEqual<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.Execute<bool>(Expression.Call(null, CachedReflectionInfo.SequenceEqual_TSource_2(typeof(TSource)), source1.Expression, GetSourceExpression(source2)));
		}

		/// <summary>Determines whether two sequences are equal by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare elements.</summary>
		/// <param name="source1">An <see cref="T:System.Linq.IQueryable`1" /> whose elements to compare to those of <paramref name="source2" />.</param>
		/// <param name="source2">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements to compare to those of the first sequence.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to use to compare elements.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>
		///     <see langword="true" /> if the two source sequences are of equal length and their corresponding elements compare equal; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source1" /> or <paramref name="source2" /> is <see langword="null" />.</exception>
		public static bool SequenceEqual<TSource>(this IQueryable<TSource> source1, IEnumerable<TSource> source2, IEqualityComparer<TSource> comparer)
		{
			if (source1 == null)
			{
				throw Error.ArgumentNull("source1");
			}
			if (source2 == null)
			{
				throw Error.ArgumentNull("source2");
			}
			return source1.Provider.Execute<bool>(Expression.Call(null, CachedReflectionInfo.SequenceEqual_TSource_3(typeof(TSource)), source1.Expression, GetSourceExpression(source2), Expression.Constant(comparer, typeof(IEqualityComparer<TSource>))));
		}

		/// <summary>Determines whether a sequence contains any elements.</summary>
		/// <param name="source">A sequence to check for being empty.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="true" /> if the source sequence contains any elements; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static bool Any<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<bool>(Expression.Call(null, CachedReflectionInfo.Any_TSource_1(typeof(TSource)), source.Expression));
		}

		/// <summary>Determines whether any element of a sequence satisfies a condition.</summary>
		/// <param name="source">A sequence whose elements to test for a condition.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="true" /> if any elements in the source sequence pass the test in the specified predicate; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static bool Any<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<bool>(Expression.Call(null, CachedReflectionInfo.Any_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Determines whether all the elements of a sequence satisfy a condition.</summary>
		/// <param name="source">A sequence whose elements to test for a condition.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="true" /> if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static bool All<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<bool>(Expression.Call(null, CachedReflectionInfo.All_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Returns the number of elements in a sequence.</summary>
		/// <param name="source">The <see cref="T:System.Linq.IQueryable`1" /> that contains the elements to be counted.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The number of elements in the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The number of elements in <paramref name="source" /> is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
		public static int Count<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<int>(Expression.Call(null, CachedReflectionInfo.Count_TSource_1(typeof(TSource)), source.Expression));
		}

		/// <summary>Returns the number of elements in the specified sequence that satisfies a condition.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> that contains the elements to be counted.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The number of elements in the sequence that satisfies the condition in the predicate function.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The number of elements in <paramref name="source" /> is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
		public static int Count<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<int>(Expression.Call(null, CachedReflectionInfo.Count_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Returns an <see cref="T:System.Int64" /> that represents the total number of elements in a sequence.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> that contains the elements to be counted.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The number of elements in <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The number of elements exceeds <see cref="F:System.Int64.MaxValue" />.</exception>
		public static long LongCount<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<long>(Expression.Call(null, CachedReflectionInfo.LongCount_TSource_1(typeof(TSource)), source.Expression));
		}

		/// <summary>Returns an <see cref="T:System.Int64" /> that represents the number of elements in a sequence that satisfy a condition.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IQueryable`1" /> that contains the elements to be counted.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The number of elements in <paramref name="source" /> that satisfy the condition in the predicate function.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The number of matching elements exceeds <see cref="F:System.Int64.MaxValue" />.</exception>
		public static long LongCount<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, bool>> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return source.Provider.Execute<long>(Expression.Call(null, CachedReflectionInfo.LongCount_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(predicate)));
		}

		/// <summary>Returns the minimum value of a generic <see cref="T:System.Linq.IQueryable`1" />.</summary>
		/// <param name="source">A sequence of values to determine the minimum of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static TSource Min<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.Min_TSource_1(typeof(TSource)), source.Expression));
		}

		/// <summary>Invokes a projection function on each element of a generic <see cref="T:System.Linq.IQueryable`1" /> and returns the minimum resulting value.</summary>
		/// <param name="source">A sequence of values to determine the minimum of.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the value returned by the function represented by <paramref name="selector" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static TResult Min<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<TResult>(Expression.Call(null, CachedReflectionInfo.Min_TSource_TResult_2(typeof(TSource), typeof(TResult)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Returns the maximum value in a generic <see cref="T:System.Linq.IQueryable`1" />.</summary>
		/// <param name="source">A sequence of values to determine the maximum of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static TSource Max<TSource>(this IQueryable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.Max_TSource_1(typeof(TSource)), source.Expression));
		}

		/// <summary>Invokes a projection function on each element of a generic <see cref="T:System.Linq.IQueryable`1" /> and returns the maximum resulting value.</summary>
		/// <param name="source">A sequence of values to determine the maximum of.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the value returned by the function represented by <paramref name="selector" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static TResult Max<TSource, TResult>(this IQueryable<TSource> source, Expression<Func<TSource, TResult>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<TResult>(Expression.Call(null, CachedReflectionInfo.Max_TSource_TResult_2(typeof(TSource), typeof(TResult)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the sum of a sequence of <see cref="T:System.Int32" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Int32" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
		public static int Sum(this IQueryable<int> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<int>(Expression.Call(null, CachedReflectionInfo.Sum_Int32_1, source.Expression));
		}

		/// <summary>Computes the sum of a sequence of nullable <see cref="T:System.Int32" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Int32" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
		public static int? Sum(this IQueryable<int?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<int?>(Expression.Call(null, CachedReflectionInfo.Sum_NullableInt32_1, source.Expression));
		}

		/// <summary>Computes the sum of a sequence of <see cref="T:System.Int64" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Int64" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static long Sum(this IQueryable<long> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<long>(Expression.Call(null, CachedReflectionInfo.Sum_Int64_1, source.Expression));
		}

		/// <summary>Computes the sum of a sequence of nullable <see cref="T:System.Int64" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Int64" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static long? Sum(this IQueryable<long?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<long?>(Expression.Call(null, CachedReflectionInfo.Sum_NullableInt64_1, source.Expression));
		}

		/// <summary>Computes the sum of a sequence of <see cref="T:System.Single" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Single" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static float Sum(this IQueryable<float> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<float>(Expression.Call(null, CachedReflectionInfo.Sum_Single_1, source.Expression));
		}

		/// <summary>Computes the sum of a sequence of nullable <see cref="T:System.Single" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Single" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static float? Sum(this IQueryable<float?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<float?>(Expression.Call(null, CachedReflectionInfo.Sum_NullableSingle_1, source.Expression));
		}

		/// <summary>Computes the sum of a sequence of <see cref="T:System.Double" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Double" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static double Sum(this IQueryable<double> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double>(Expression.Call(null, CachedReflectionInfo.Sum_Double_1, source.Expression));
		}

		/// <summary>Computes the sum of a sequence of nullable <see cref="T:System.Double" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Double" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static double? Sum(this IQueryable<double?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, CachedReflectionInfo.Sum_NullableDouble_1, source.Expression));
		}

		/// <summary>Computes the sum of a sequence of <see cref="T:System.Decimal" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Decimal" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
		public static decimal Sum(this IQueryable<decimal> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<decimal>(Expression.Call(null, CachedReflectionInfo.Sum_Decimal_1, source.Expression));
		}

		/// <summary>Computes the sum of a sequence of nullable <see cref="T:System.Decimal" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Decimal" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
		public static decimal? Sum(this IQueryable<decimal?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<decimal?>(Expression.Call(null, CachedReflectionInfo.Sum_NullableDecimal_1, source.Expression));
		}

		/// <summary>Computes the sum of the sequence of <see cref="T:System.Int32" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values of type <paramref name="TSource" />.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
		public static int Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<int>(Expression.Call(null, CachedReflectionInfo.Sum_Int32_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the sum of the sequence of nullable <see cref="T:System.Int32" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values of type <paramref name="TSource" />.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
		public static int? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<int?>(Expression.Call(null, CachedReflectionInfo.Sum_NullableInt32_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the sum of the sequence of <see cref="T:System.Int64" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values of type <paramref name="TSource" />.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static long Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<long>(Expression.Call(null, CachedReflectionInfo.Sum_Int64_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the sum of the sequence of nullable <see cref="T:System.Int64" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values of type <paramref name="TSource" />.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static long? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<long?>(Expression.Call(null, CachedReflectionInfo.Sum_NullableInt64_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the sum of the sequence of <see cref="T:System.Single" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values of type <paramref name="TSource" />.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static float Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<float>(Expression.Call(null, CachedReflectionInfo.Sum_Single_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the sum of the sequence of nullable <see cref="T:System.Single" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values of type <paramref name="TSource" />.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static float? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<float?>(Expression.Call(null, CachedReflectionInfo.Sum_NullableSingle_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the sum of the sequence of <see cref="T:System.Double" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values of type <paramref name="TSource" />.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static double Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double>(Expression.Call(null, CachedReflectionInfo.Sum_Double_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the sum of the sequence of nullable <see cref="T:System.Double" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values of type <paramref name="TSource" />.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static double? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, CachedReflectionInfo.Sum_NullableDouble_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the sum of the sequence of <see cref="T:System.Decimal" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values of type <paramref name="TSource" />.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
		public static decimal Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<decimal>(Expression.Call(null, CachedReflectionInfo.Sum_Decimal_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the sum of the sequence of nullable <see cref="T:System.Decimal" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values of type <paramref name="TSource" />.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
		public static decimal? Sum<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<decimal?>(Expression.Call(null, CachedReflectionInfo.Sum_NullableDecimal_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Int32" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Int32" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Average(this IQueryable<int> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double>(Expression.Call(null, CachedReflectionInfo.Average_Int32_1, source.Expression));
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Int32" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Int32" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only <see langword="null" /> values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static double? Average(this IQueryable<int?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, CachedReflectionInfo.Average_NullableInt32_1, source.Expression));
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Int64" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Int64" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Average(this IQueryable<long> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double>(Expression.Call(null, CachedReflectionInfo.Average_Int64_1, source.Expression));
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Int64" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Int64" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only <see langword="null" /> values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static double? Average(this IQueryable<long?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, CachedReflectionInfo.Average_NullableInt64_1, source.Expression));
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Single" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Single" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float Average(this IQueryable<float> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<float>(Expression.Call(null, CachedReflectionInfo.Average_Single_1, source.Expression));
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Single" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Single" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only <see langword="null" /> values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static float? Average(this IQueryable<float?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<float?>(Expression.Call(null, CachedReflectionInfo.Average_NullableSingle_1, source.Expression));
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Double" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Double" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Average(this IQueryable<double> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double>(Expression.Call(null, CachedReflectionInfo.Average_Double_1, source.Expression));
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Double" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Double" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only <see langword="null" /> values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static double? Average(this IQueryable<double?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, CachedReflectionInfo.Average_NullableDouble_1, source.Expression));
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Decimal" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Decimal" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static decimal Average(this IQueryable<decimal> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<decimal>(Expression.Call(null, CachedReflectionInfo.Average_Decimal_1, source.Expression));
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Decimal" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Decimal" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only <see langword="null" /> values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static decimal? Average(this IQueryable<decimal?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.Execute<decimal?>(Expression.Call(null, CachedReflectionInfo.Average_NullableDecimal_1, source.Expression));
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Int32" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double>(Expression.Call(null, CachedReflectionInfo.Average_Int32_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Int32" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the <paramref name="source" /> sequence is empty or contains only <see langword="null" /> values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static double? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, int?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, CachedReflectionInfo.Average_NullableInt32_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Single" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<float>(Expression.Call(null, CachedReflectionInfo.Average_Single_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Single" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the <paramref name="source" /> sequence is empty or contains only <see langword="null" /> values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static float? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, float?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<float?>(Expression.Call(null, CachedReflectionInfo.Average_NullableSingle_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Int64" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double>(Expression.Call(null, CachedReflectionInfo.Average_Int64_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Int64" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the <paramref name="source" /> sequence is empty or contains only <see langword="null" /> values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static double? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, long?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, CachedReflectionInfo.Average_NullableInt64_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Double" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double>(Expression.Call(null, CachedReflectionInfo.Average_Double_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Double" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the <paramref name="source" /> sequence is empty or contains only <see langword="null" /> values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static double? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, double?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<double?>(Expression.Call(null, CachedReflectionInfo.Average_NullableDouble_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Decimal" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static decimal Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<decimal>(Expression.Call(null, CachedReflectionInfo.Average_Decimal_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Decimal" /> values that is obtained by invoking a projection function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A projection function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the <paramref name="source" /> sequence is empty or contains only <see langword="null" /> values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static decimal? Average<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, decimal?>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<decimal?>(Expression.Call(null, CachedReflectionInfo.Average_NullableDecimal_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(selector)));
		}

		/// <summary>Applies an accumulator function over a sequence.</summary>
		/// <param name="source">A sequence to aggregate over.</param>
		/// <param name="func">An accumulator function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The final accumulator value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="func" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static TSource Aggregate<TSource>(this IQueryable<TSource> source, Expression<Func<TSource, TSource, TSource>> func)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (func == null)
			{
				throw Error.ArgumentNull("func");
			}
			return source.Provider.Execute<TSource>(Expression.Call(null, CachedReflectionInfo.Aggregate_TSource_2(typeof(TSource)), source.Expression, Expression.Quote(func)));
		}

		/// <summary>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.</summary>
		/// <param name="source">A sequence to aggregate over.</param>
		/// <param name="seed">The initial accumulator value.</param>
		/// <param name="func">An accumulator function to invoke on each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
		/// <returns>The final accumulator value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="func" /> is <see langword="null" />.</exception>
		public static TAccumulate Aggregate<TSource, TAccumulate>(this IQueryable<TSource> source, TAccumulate seed, Expression<Func<TAccumulate, TSource, TAccumulate>> func)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (func == null)
			{
				throw Error.ArgumentNull("func");
			}
			return source.Provider.Execute<TAccumulate>(Expression.Call(null, CachedReflectionInfo.Aggregate_TSource_TAccumulate_3(typeof(TSource), typeof(TAccumulate)), source.Expression, Expression.Constant(seed), Expression.Quote(func)));
		}

		/// <summary>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.</summary>
		/// <param name="source">A sequence to aggregate over.</param>
		/// <param name="seed">The initial accumulator value.</param>
		/// <param name="func">An accumulator function to invoke on each element.</param>
		/// <param name="selector">A function to transform the final accumulator value into the result value.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
		/// <typeparam name="TResult">The type of the resulting value.</typeparam>
		/// <returns>The transformed final accumulator value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="func" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static TResult Aggregate<TSource, TAccumulate, TResult>(this IQueryable<TSource> source, TAccumulate seed, Expression<Func<TAccumulate, TSource, TAccumulate>> func, Expression<Func<TAccumulate, TResult>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (func == null)
			{
				throw Error.ArgumentNull("func");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return source.Provider.Execute<TResult>(Expression.Call(null, CachedReflectionInfo.Aggregate_TSource_TAccumulate_TResult_4(typeof(TSource), typeof(TAccumulate), typeof(TResult)), source.Expression, Expression.Constant(seed), Expression.Quote(func), Expression.Quote(selector)));
		}

		public static IQueryable<TSource> SkipLast<TSource>(this IQueryable<TSource> source, int count)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.SkipLast_TSource_2(typeof(TSource)), source.Expression, Expression.Constant(count)));
		}

		public static IQueryable<TSource> TakeLast<TSource>(this IQueryable<TSource> source, int count)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.TakeLast_TSource_2(typeof(TSource)), source.Expression, Expression.Constant(count)));
		}

		public static IQueryable<TSource> Append<TSource>(this IQueryable<TSource> source, TSource element)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Append_TSource_2(typeof(TSource)), source.Expression, Expression.Constant(element)));
		}

		public static IQueryable<TSource> Prepend<TSource>(this IQueryable<TSource> source, TSource element)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.Provider.CreateQuery<TSource>(Expression.Call(null, CachedReflectionInfo.Prepend_TSource_2(typeof(TSource)), source.Expression, Expression.Constant(element)));
		}
	}
	internal static class Strings
	{
		internal static string ArgumentNotIEnumerableGeneric(string message)
		{
			return SR.Format("{0} is not IEnumerable<>", message);
		}

		internal static string ArgumentNotValid(string message)
		{
			return SR.Format("Argument {0} is not valid", message);
		}

		internal static string NoMethodOnType(string name, object type)
		{
			return SR.Format("There is no method '{0}' on type '{1}'", name, type);
		}

		internal static string NoMethodOnTypeMatchingArguments(string name, object type)
		{
			return SR.Format("There is no method '{0}' on type '{1}' that matches the specified arguments", name, type);
		}

		internal static string EnumeratingNullEnumerableExpression()
		{
			return "Cannot enumerate a query created from a null IEnumerable<>";
		}
	}
	internal static class TypeHelper
	{
		internal static Type FindGenericType(Type definition, Type type)
		{
			bool? flag = null;
			while (type != null && type != typeof(object))
			{
				if (type.IsGenericType && type.GetGenericTypeDefinition() == definition)
				{
					return type;
				}
				if (!flag.HasValue)
				{
					flag = definition.IsInterface;
				}
				if (flag == true)
				{
					Type[] interfaces = type.GetInterfaces();
					foreach (Type type2 in interfaces)
					{
						Type type3 = FindGenericType(definition, type2);
						if (type3 != null)
						{
							return type3;
						}
					}
				}
				type = type.BaseType;
			}
			return null;
		}

		internal static IEnumerable<MethodInfo> GetStaticMethods(this Type type)
		{
			return from m in type.GetRuntimeMethods()
				where m.IsStatic
				select m;
		}
	}
	/// <summary>Provides a set of <see langword="static" /> (<see langword="Shared" /> in Visual Basic) methods for querying objects that implement <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
	public static class Enumerable
	{
		private abstract class AppendPrependIterator<TSource> : Iterator<TSource>, IIListProvider<TSource>, IEnumerable<TSource>, IEnumerable
		{
			protected readonly IEnumerable<TSource> _source;

			protected IEnumerator<TSource> _enumerator;

			protected AppendPrependIterator(IEnumerable<TSource> source)
			{
				_source = source;
			}

			protected void GetSourceEnumerator()
			{
				_enumerator = _source.GetEnumerator();
			}

			public abstract AppendPrependIterator<TSource> Append(TSource item);

			public abstract AppendPrependIterator<TSource> Prepend(TSource item);

			protected bool LoadFromEnumerator()
			{
				if (_enumerator.MoveNext())
				{
					_current = _enumerator.Current;
					return true;
				}
				Dispose();
				return false;
			}

			public override void Dispose()
			{
				if (_enumerator != null)
				{
					_enumerator.Dispose();
					_enumerator = null;
				}
				base.Dispose();
			}

			public abstract TSource[] ToArray();

			public abstract List<TSource> ToList();

			public abstract int GetCount(bool onlyIfCheap);
		}

		private class AppendPrepend1Iterator<TSource> : AppendPrependIterator<TSource>
		{
			private readonly TSource _item;

			private readonly bool _appending;

			public AppendPrepend1Iterator(IEnumerable<TSource> source, TSource item, bool appending)
				: base(source)
			{
				_item = item;
				_appending = appending;
			}

			public override Iterator<TSource> Clone()
			{
				return new AppendPrepend1Iterator<TSource>(_source, _item, _appending);
			}

			public override bool MoveNext()
			{
				switch (_state)
				{
				case 1:
					_state = 2;
					if (!_appending)
					{
						_current = _item;
						return true;
					}
					goto case 2;
				case 2:
					GetSourceEnumerator();
					_state = 3;
					goto case 3;
				case 3:
					if (LoadFromEnumerator())
					{
						return true;
					}
					if (_appending)
					{
						_current = _item;
						return true;
					}
					break;
				}
				Dispose();
				return false;
			}

			public override AppendPrependIterator<TSource> Append(TSource item)
			{
				if (_appending)
				{
					return new AppendPrependN<TSource>(_source, null, new SingleLinkedNode<TSource>(_item).Add(item), 0, 2);
				}
				return new AppendPrependN<TSource>(_source, new SingleLinkedNode<TSource>(_item), new SingleLinkedNode<TSource>(item), 1, 1);
			}

			public override AppendPrependIterator<TSource> Prepend(TSource item)
			{
				if (_appending)
				{
					return new AppendPrependN<TSource>(_source, new SingleLinkedNode<TSource>(item), new SingleLinkedNode<TSource>(_item), 1, 1);
				}
				return new AppendPrependN<TSource>(_source, new SingleLinkedNode<TSource>(_item).Add(item), null, 2, 0);
			}

			private TSource[] LazyToArray()
			{
				LargeArrayBuilder<TSource> largeArrayBuilder = new LargeArrayBuilder<TSource>(initialize: true);
				if (!_appending)
				{
					largeArrayBuilder.SlowAdd(_item);
				}
				largeArrayBuilder.AddRange(_source);
				if (_appending)
				{
					largeArrayBuilder.SlowAdd(_item);
				}
				return largeArrayBuilder.ToArray();
			}

			public override TSource[] ToArray()
			{
				int count = GetCount(onlyIfCheap: true);
				if (count == -1)
				{
					return LazyToArray();
				}
				TSource[] array = new TSource[count];
				int arrayIndex;
				if (_appending)
				{
					arrayIndex = 0;
				}
				else
				{
					array[0] = _item;
					arrayIndex = 1;
				}
				EnumerableHelpers.Copy(_source, array, arrayIndex, count - 1);
				if (_appending)
				{
					array[^1] = _item;
				}
				return array;
			}

			public override List<TSource> ToList()
			{
				int count = GetCount(onlyIfCheap: true);
				List<TSource> list = ((count == -1) ? new List<TSource>() : new List<TSource>(count));
				if (!_appending)
				{
					list.Add(_item);
				}
				list.AddRange(_source);
				if (_appending)
				{
					list.Add(_item);
				}
				return list;
			}

			public override int GetCount(bool onlyIfCheap)
			{
				if (_source is IIListProvider<TSource> iIListProvider)
				{
					int count = iIListProvider.GetCount(onlyIfCheap);
					if (count != -1)
					{
						return count + 1;
					}
					return -1;
				}
				if (onlyIfCheap && !(_source is ICollection<TSource>))
				{
					return -1;
				}
				return _source.Count() + 1;
			}
		}

		private class AppendPrependN<TSource> : AppendPrependIterator<TSource>
		{
			private readonly SingleLinkedNode<TSource> _prepended;

			private readonly SingleLinkedNode<TSource> _appended;

			private readonly int _prependCount;

			private readonly int _appendCount;

			private SingleLinkedNode<TSource> _node;

			public AppendPrependN(IEnumerable<TSource> source, SingleLinkedNode<TSource> prepended, SingleLinkedNode<TSource> appended, int prependCount, int appendCount)
				: base(source)
			{
				_prepended = prepended;
				_appended = appended;
				_prependCount = prependCount;
				_appendCount = appendCount;
			}

			public override Iterator<TSource> Clone()
			{
				return new AppendPrependN<TSource>(_source, _prepended, _appended, _prependCount, _appendCount);
			}

			public override bool MoveNext()
			{
				switch (_state)
				{
				case 1:
					_node = _prepended;
					_state = 2;
					goto case 2;
				case 2:
					if (_node != null)
					{
						_current = _node.Item;
						_node = _node.Linked;
						return true;
					}
					GetSourceEnumerator();
					_state = 3;
					goto case 3;
				case 3:
					if (LoadFromEnumerator())
					{
						return true;
					}
					if (_appended == null)
					{
						return false;
					}
					_enumerator = _appended.GetEnumerator(_appendCount);
					_state = 4;
					goto case 4;
				case 4:
					return LoadFromEnumerator();
				default:
					Dispose();
					return false;
				}
			}

			public override AppendPrependIterator<TSource> Append(TSource item)
			{
				SingleLinkedNode<TSource> appended = ((_appended != null) ? _appended.Add(item) : new SingleLinkedNode<TSource>(item));
				return new AppendPrependN<TSource>(_source, _prepended, appended, _prependCount, _appendCount + 1);
			}

			public override AppendPrependIterator<TSource> Prepend(TSource item)
			{
				SingleLinkedNode<TSource> prepended = ((_prepended != null) ? _prepended.Add(item) : new SingleLinkedNode<TSource>(item));
				return new AppendPrependN<TSource>(_source, prepended, _appended, _prependCount + 1, _appendCount);
			}

			private TSource[] LazyToArray()
			{
				SparseArrayBuilder<TSource> sparseArrayBuilder = new SparseArrayBuilder<TSource>(initialize: true);
				if (_prepended != null)
				{
					sparseArrayBuilder.Reserve(_prependCount);
				}
				sparseArrayBuilder.AddRange(_source);
				if (_appended != null)
				{
					sparseArrayBuilder.Reserve(_appendCount);
				}
				TSource[] array = sparseArrayBuilder.ToArray();
				int num = 0;
				for (SingleLinkedNode<TSource> singleLinkedNode = _prepended; singleLinkedNode != null; singleLinkedNode = singleLinkedNode.Linked)
				{
					array[num++] = singleLinkedNode.Item;
				}
				num = array.Length - 1;
				for (SingleLinkedNode<TSource> singleLinkedNode2 = _appended; singleLinkedNode2 != null; singleLinkedNode2 = singleLinkedNode2.Linked)
				{
					array[num--] = singleLinkedNode2.Item;
				}
				return array;
			}

			public override TSource[] ToArray()
			{
				int count = GetCount(onlyIfCheap: true);
				if (count == -1)
				{
					return LazyToArray();
				}
				TSource[] array = new TSource[count];
				int num = 0;
				for (SingleLinkedNode<TSource> singleLinkedNode = _prepended; singleLinkedNode != null; singleLinkedNode = singleLinkedNode.Linked)
				{
					array[num] = singleLinkedNode.Item;
					num++;
				}
				if (_source is ICollection<TSource> collection)
				{
					collection.CopyTo(array, num);
				}
				else
				{
					foreach (TSource item in _source)
					{
						array[num] = item;
						num++;
					}
				}
				num = array.Length;
				for (SingleLinkedNode<TSource> singleLinkedNode2 = _appended; singleLinkedNode2 != null; singleLinkedNode2 = singleLinkedNode2.Linked)
				{
					num--;
					array[num] = singleLinkedNode2.Item;
				}
				return array;
			}

			public override List<TSource> ToList()
			{
				int count = GetCount(onlyIfCheap: true);
				List<TSource> list = ((count == -1) ? new List<TSource>() : new List<TSource>(count));
				for (SingleLinkedNode<TSource> singleLinkedNode = _prepended; singleLinkedNode != null; singleLinkedNode = singleLinkedNode.Linked)
				{
					list.Add(singleLinkedNode.Item);
				}
				list.AddRange(_source);
				if (_appended != null)
				{
					IEnumerator<TSource> enumerator = _appended.GetEnumerator(_appendCount);
					while (enumerator.MoveNext())
					{
						list.Add(enumerator.Current);
					}
				}
				return list;
			}

			public override int GetCount(bool onlyIfCheap)
			{
				if (_source is IIListProvider<TSource> iIListProvider)
				{
					int count = iIListProvider.GetCount(onlyIfCheap);
					if (count != -1)
					{
						return count + _appendCount + _prependCount;
					}
					return -1;
				}
				if (onlyIfCheap && !(_source is ICollection<TSource>))
				{
					return -1;
				}
				return _source.Count() + _appendCount + _prependCount;
			}
		}

		private sealed class Concat2Iterator<TSource> : ConcatIterator<TSource>
		{
			internal readonly IEnumerable<TSource> _first;

			internal readonly IEnumerable<TSource> _second;

			internal Concat2Iterator(IEnumerable<TSource> first, IEnumerable<TSource> second)
			{
				_first = first;
				_second = second;
			}

			public override Iterator<TSource> Clone()
			{
				return new Concat2Iterator<TSource>(_first, _second);
			}

			internal override ConcatIterator<TSource> Concat(IEnumerable<TSource> next)
			{
				bool hasOnlyCollections = next is ICollection<TSource> && _first is ICollection<TSource> && _second is ICollection<TSource>;
				return new ConcatNIterator<TSource>(this, next, 2, hasOnlyCollections);
			}

			public override int GetCount(bool onlyIfCheap)
			{
				if (!EnumerableHelpers.TryGetCount(_first, out var count))
				{
					if (onlyIfCheap)
					{
						return -1;
					}
					count = _first.Count();
				}
				if (!EnumerableHelpers.TryGetCount(_second, out var count2))
				{
					if (onlyIfCheap)
					{
						return -1;
					}
					count2 = _second.Count();
				}
				return checked(count + count2);
			}

			internal override IEnumerable<TSource> GetEnumerable(int index)
			{
				return index switch
				{
					0 => _first, 
					1 => _second, 
					_ => null, 
				};
			}

			public override TSource[] ToArray()
			{
				SparseArrayBuilder<TSource> sparseArrayBuilder = new SparseArrayBuilder<TSource>(initialize: true);
				bool num = sparseArrayBuilder.ReserveOrAdd(_first);
				bool flag = sparseArrayBuilder.ReserveOrAdd(_second);
				TSource[] array = sparseArrayBuilder.ToArray();
				if (num)
				{
					Marker marker = sparseArrayBuilder.Markers.First();
					EnumerableHelpers.Copy(_first, array, 0, marker.Count);
				}
				if (flag)
				{
					Marker marker2 = sparseArrayBuilder.Markers.Last();
					EnumerableHelpers.Copy(_second, array, marker2.Index, marker2.Count);
				}
				return array;
			}
		}

		private sealed class ConcatNIterator<TSource> : ConcatIterator<TSource>
		{
			private readonly ConcatIterator<TSource> _tail;

			private readonly IEnumerable<TSource> _head;

			private readonly int _headIndex;

			private readonly bool _hasOnlyCollections;

			private ConcatNIterator<TSource> PreviousN => _tail as ConcatNIterator<TSource>;

			internal ConcatNIterator(ConcatIterator<TSource> tail, IEnumerable<TSource> head, int headIndex, bool hasOnlyCollections)
			{
				_tail = tail;
				_head = head;
				_headIndex = headIndex;
				_hasOnlyCollections = hasOnlyCollections;
			}

			public override Iterator<TSource> Clone()
			{
				return new ConcatNIterator<TSource>(_tail, _head, _headIndex, _hasOnlyCollections);
			}

			internal override ConcatIterator<TSource> Concat(IEnumerable<TSource> next)
			{
				if (_headIndex == 2147483645)
				{
					return new Concat2Iterator<TSource>(this, next);
				}
				bool hasOnlyCollections = _hasOnlyCollections && next is ICollection<TSource>;
				return new ConcatNIterator<TSource>(this, next, _headIndex + 1, hasOnlyCollections);
			}

			public override int GetCount(bool onlyIfCheap)
			{
				if (onlyIfCheap && !_hasOnlyCollections)
				{
					return -1;
				}
				int num = 0;
				ConcatNIterator<TSource> concatNIterator = this;
				checked
				{
					ConcatNIterator<TSource> concatNIterator2;
					do
					{
						concatNIterator2 = concatNIterator;
						IEnumerable<TSource> head = concatNIterator2._head;
						int num2 = (head as ICollection<TSource>)?.Count ?? head.Count();
						num += num2;
					}
					while ((concatNIterator = concatNIterator2.PreviousN) != null);
					return num + concatNIterator2._tail.GetCount(onlyIfCheap);
				}
			}

			internal override IEnumerable<TSource> GetEnumerable(int index)
			{
				if (index > _headIndex)
				{
					return null;
				}
				ConcatNIterator<TSource> concatNIterator = this;
				ConcatNIterator<TSource> concatNIterator2;
				do
				{
					concatNIterator2 = concatNIterator;
					if (index == concatNIterator2._headIndex)
					{
						return concatNIterator2._head;
					}
				}
				while ((concatNIterator = concatNIterator2.PreviousN) != null);
				return concatNIterator2._tail.GetEnumerable(index);
			}

			public override TSource[] ToArray()
			{
				if (!_hasOnlyCollections)
				{
					return LazyToArray();
				}
				return PreallocatingToArray();
			}

			private TSource[] LazyToArray()
			{
				SparseArrayBuilder<TSource> sparseArrayBuilder = new SparseArrayBuilder<TSource>(initialize: true);
				ArrayBuilder<int> arrayBuilder = default(ArrayBuilder<int>);
				int num = 0;
				while (true)
				{
					IEnumerable<TSource> enumerable = GetEnumerable(num);
					if (enumerable == null)
					{
						break;
					}
					if (sparseArrayBuilder.ReserveOrAdd(enumerable))
					{
						arrayBuilder.Add(num);
					}
					num++;
				}
				TSource[] array = sparseArrayBuilder.ToArray();
				ArrayBuilder<Marker> markers = sparseArrayBuilder.Markers;
				for (int i = 0; i < markers.Count; i++)
				{
					Marker marker = markers[i];
					EnumerableHelpers.Copy(GetEnumerable(arrayBuilder[i]), array, marker.Index, marker.Count);
				}
				return array;
			}

			private TSource[] PreallocatingToArray()
			{
				int count = GetCount(onlyIfCheap: true);
				if (count == 0)
				{
					return Array.Empty<TSource>();
				}
				TSource[] array = new TSource[count];
				int num = array.Length;
				ConcatNIterator<TSource> concatNIterator = this;
				checked
				{
					ConcatNIterator<TSource> concatNIterator2;
					do
					{
						concatNIterator2 = concatNIterator;
						ICollection<TSource> collection = (ICollection<TSource>)concatNIterator2._head;
						int count2 = collection.Count;
						if (count2 > 0)
						{
							num -= count2;
							collection.CopyTo(array, num);
						}
					}
					while ((concatNIterator = concatNIterator2.PreviousN) != null);
					Concat2Iterator<TSource> concat2Iterator = (Concat2Iterator<TSource>)concatNIterator2._tail;
					ICollection<TSource> collection2 = (ICollection<TSource>)concat2Iterator._second;
					int count3 = collection2.Count;
					if (count3 > 0)
					{
						collection2.CopyTo(array, num - count3);
					}
					if (num > count3)
					{
						((ICollection<TSource>)concat2Iterator._first).CopyTo(array, 0);
					}
					return array;
				}
			}
		}

		private abstract class ConcatIterator<TSource> : Iterator<TSource>, IIListProvider<TSource>, IEnumerable<TSource>, IEnumerable
		{
			private IEnumerator<TSource> _enumerator;

			public override void Dispose()
			{
				if (_enumerator != null)
				{
					_enumerator.Dispose();
					_enumerator = null;
				}
				base.Dispose();
			}

			internal abstract IEnumerable<TSource> GetEnumerable(int index);

			internal abstract ConcatIterator<TSource> Concat(IEnumerable<TSource> next);

			public override bool MoveNext()
			{
				if (_state == 1)
				{
					_enumerator = GetEnumerable(0).GetEnumerator();
					_state = 2;
				}
				if (_state > 1)
				{
					while (true)
					{
						if (_enumerator.MoveNext())
						{
							_current = _enumerator.Current;
							return true;
						}
						IEnumerable<TSource> enumerable = GetEnumerable(_state++ - 1);
						if (enumerable == null)
						{
							break;
						}
						_enumerator.Dispose();
						_enumerator = enumerable.GetEnumerator();
					}
					Dispose();
				}
				return false;
			}

			public abstract int GetCount(bool onlyIfCheap);

			public abstract TSource[] ToArray();

			public List<TSource> ToList()
			{
				int count = GetCount(onlyIfCheap: true);
				List<TSource> list = ((count != -1) ? new List<TSource>(count) : new List<TSource>());
				int num = 0;
				while (true)
				{
					IEnumerable<TSource> enumerable = GetEnumerable(num);
					if (enumerable == null)
					{
						break;
					}
					list.AddRange(enumerable);
					num++;
				}
				return list;
			}
		}

		private sealed class DefaultIfEmptyIterator<TSource> : Iterator<TSource>, IIListProvider<TSource>, IEnumerable<TSource>, IEnumerable
		{
			private readonly IEnumerable<TSource> _source;

			private readonly TSource _default;

			private IEnumerator<TSource> _enumerator;

			public DefaultIfEmptyIterator(IEnumerable<TSource> source, TSource defaultValue)
			{
				_source = source;
				_default = defaultValue;
			}

			public override Iterator<TSource> Clone()
			{
				return new DefaultIfEmptyIterator<TSource>(_source, _default);
			}

			public override bool MoveNext()
			{
				switch (_state)
				{
				case 1:
					_enumerator = _source.GetEnumerator();
					if (_enumerator.MoveNext())
					{
						_current = _enumerator.Current;
						_state = 2;
					}
					else
					{
						_current = _default;
						_state = -1;
					}
					return true;
				case 2:
					if (_enumerator.MoveNext())
					{
						_current = _enumerator.Current;
						return true;
					}
					break;
				}
				Dispose();
				return false;
			}

			public override void Dispose()
			{
				if (_enumerator != null)
				{
					_enumerator.Dispose();
					_enumerator = null;
				}
				base.Dispose();
			}

			public TSource[] ToArray()
			{
				TSource[] array = _source.ToArray();
				if (array.Length != 0)
				{
					return array;
				}
				return new TSource[1] { _default };
			}

			public List<TSource> ToList()
			{
				List<TSource> list = _source.ToList();
				if (list.Count == 0)
				{
					list.Add(_default);
				}
				return list;
			}

			public int GetCount(bool onlyIfCheap)
			{
				int num = ((onlyIfCheap && !(_source is ICollection<TSource>) && !(_source is ICollection)) ? ((_source is IIListProvider<TSource> iIListProvider) ? iIListProvider.GetCount(onlyIfCheap: true) : (-1)) : _source.Count());
				if (num != 0)
				{
					return num;
				}
				return 1;
			}
		}

		private sealed class DistinctIterator<TSource> : Iterator<TSource>, IIListProvider<TSource>, IEnumerable<TSource>, IEnumerable
		{
			private readonly IEnumerable<TSource> _source;

			private readonly IEqualityComparer<TSource> _comparer;

			private Set<TSource> _set;

			private IEnumerator<TSource> _enumerator;

			public DistinctIterator(IEnumerable<TSource> source, IEqualityComparer<TSource> comparer)
			{
				_source = source;
				_comparer = comparer;
			}

			public override Iterator<TSource> Clone()
			{
				return new DistinctIterator<TSource>(_source, _comparer);
			}

			public override bool MoveNext()
			{
				int state = _state;
				TSource current;
				if (state != 1)
				{
					if (state == 2)
					{
						while (_enumerator.MoveNext())
						{
							current = _enumerator.Current;
							if (_set.Add(current))
							{
								_current = current;
								return true;
							}
						}
					}
					Dispose();
					return false;
				}
				_enumerator = _source.GetEnumerator();
				if (!_enumerator.MoveNext())
				{
					Dispose();
					return false;
				}
				current = _enumerator.Current;
				_set = new Set<TSource>(_comparer);
				_set.Add(current);
				_current = current;
				_state = 2;
				return true;
			}

			public override void Dispose()
			{
				if (_enumerator != null)
				{
					_enumerator.Dispose();
					_enumerator = null;
					_set = null;
				}
				base.Dispose();
			}

			private Set<TSource> FillSet()
			{
				Set<TSource> set = new Set<TSource>(_comparer);
				set.UnionWith(_source);
				return set;
			}

			public TSource[] ToArray()
			{
				return FillSet().ToArray();
			}

			public List<TSource> ToList()
			{
				return FillSet().ToList();
			}

			public int GetCount(bool onlyIfCheap)
			{
				if (!onlyIfCheap)
				{
					return FillSet().Count;
				}
				return -1;
			}
		}

		internal abstract class Iterator<TSource> : IEnumerable<TSource>, IEnumerable, IEnumerator<TSource>, IDisposable, IEnumerator
		{
			private readonly int _threadId;

			internal int _state;

			internal TSource _current;

			public TSource Current => _current;

			object IEnumerator.Current => Current;

			protected Iterator()
			{
				_threadId = Environment.CurrentManagedThreadId;
			}

			public abstract Iterator<TSource> Clone();

			public virtual void Dispose()
			{
				_current = default(TSource);
				_state = -1;
			}

			public IEnumerator<TSource> GetEnumerator()
			{
				Iterator<TSource> obj = ((_state == 0 && _threadId == Environment.CurrentManagedThreadId) ? this : Clone());
				obj._state = 1;
				return obj;
			}

			public abstract bool MoveNext();

			public virtual IEnumerable<TResult> Select<TResult>(Func<TSource, TResult> selector)
			{
				return new SelectEnumerableIterator<TSource, TResult>(this, selector);
			}

			public virtual IEnumerable<TSource> Where(Func<TSource, bool> predicate)
			{
				return new WhereEnumerableIterator<TSource>(this, predicate);
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			void IEnumerator.Reset()
			{
				throw Error.NotSupported();
			}
		}

		private sealed class ListPartition<TSource> : Iterator<TSource>, IPartition<TSource>, IIListProvider<TSource>, IEnumerable<TSource>, IEnumerable
		{
			private readonly IList<TSource> _source;

			private readonly int _minIndexInclusive;

			private readonly int _maxIndexInclusive;

			private int Count
			{
				get
				{
					int count = _source.Count;
					if (count <= _minIndexInclusive)
					{
						return 0;
					}
					return Math.Min(count - 1, _maxIndexInclusive) - _minIndexInclusive + 1;
				}
			}

			public ListPartition(IList<TSource> source, int minIndexInclusive, int maxIndexInclusive)
			{
				_source = source;
				_minIndexInclusive = minIndexInclusive;
				_maxIndexInclusive = maxIndexInclusive;
			}

			public override Iterator<TSource> Clone()
			{
				return new ListPartition<TSource>(_source, _minIndexInclusive, _maxIndexInclusive);
			}

			public override bool MoveNext()
			{
				int num = _state - 1;
				if ((uint)num <= (uint)(_maxIndexInclusive - _minIndexInclusive) && num < _source.Count - _minIndexInclusive)
				{
					_current = _source[_minIndexInclusive + num];
					_state++;
					return true;
				}
				Dispose();
				return false;
			}

			public override IEnumerable<TResult> Select<TResult>(Func<TSource, TResult> selector)
			{
				return new SelectListPartitionIterator<TSource, TResult>(_source, selector, _minIndexInclusive, _maxIndexInclusive);
			}

			public IPartition<TSource> Skip(int count)
			{
				int num = _minIndexInclusive + count;
				if ((uint)num <= (uint)_maxIndexInclusive)
				{
					return new ListPartition<TSource>(_source, num, _maxIndexInclusive);
				}
				return EmptyPartition<TSource>.Instance;
			}

			public IPartition<TSource> Take(int count)
			{
				int num = _minIndexInclusive + count - 1;
				if ((uint)num < (uint)_maxIndexInclusive)
				{
					return new ListPartition<TSource>(_source, _minIndexInclusive, num);
				}
				return this;
			}

			public TSource TryGetElementAt(int index, out bool found)
			{
				if ((uint)index <= (uint)(_maxIndexInclusive - _minIndexInclusive) && index < _source.Count - _minIndexInclusive)
				{
					found = true;
					return _source[_minIndexInclusive + index];
				}
				found = false;
				return default(TSource);
			}

			public TSource TryGetFirst(out bool found)
			{
				if (_source.Count > _minIndexInclusive)
				{
					found = true;
					return _source[_minIndexInclusive];
				}
				found = false;
				return default(TSource);
			}

			public TSource TryGetLast(out bool found)
			{
				int num = _source.Count - 1;
				if (num >= _minIndexInclusive)
				{
					found = true;
					return _source[Math.Min(num, _maxIndexInclusive)];
				}
				found = false;
				return default(TSource);
			}

			public TSource[] ToArray()
			{
				int count = Count;
				if (count == 0)
				{
					return Array.Empty<TSource>();
				}
				TSource[] array = new TSource[count];
				int num = 0;
				int num2 = _minIndexInclusive;
				while (num != array.Length)
				{
					array[num] = _source[num2];
					num++;
					num2++;
				}
				return array;
			}

			public List<TSource> ToList()
			{
				int count = Count;
				if (count == 0)
				{
					return new List<TSource>();
				}
				List<TSource> list = new List<TSource>(count);
				int num = _minIndexInclusive + count;
				for (int i = _minIndexInclusive; i != num; i++)
				{
					list.Add(_source[i]);
				}
				return list;
			}

			public int GetCount(bool onlyIfCheap)
			{
				return Count;
			}
		}

		private sealed class EnumerablePartition<TSource> : Iterator<TSource>, IPartition<TSource>, IIListProvider<TSource>, IEnumerable<TSource>, IEnumerable
		{
			private readonly IEnumerable<TSource> _source;

			private readonly int _minIndexInclusive;

			private readonly int _maxIndexInclusive;

			private IEnumerator<TSource> _enumerator;

			private bool HasLimit => _maxIndexInclusive != -1;

			private int Limit => _maxIndexInclusive + 1 - _minIndexInclusive;

			internal EnumerablePartition(IEnumerable<TSource> source, int minIndexInclusive, int maxIndexInclusive)
			{
				_source = source;
				_minIndexInclusive = minIndexInclusive;
				_maxIndexInclusive = maxIndexInclusive;
			}

			public override Iterator<TSource> Clone()
			{
				return new EnumerablePartition<TSource>(_source, _minIndexInclusive, _maxIndexInclusive);
			}

			public override void Dispose()
			{
				if (_enumerator != null)
				{
					_enumerator.Dispose();
					_enumerator = null;
				}
				base.Dispose();
			}

			public int GetCount(bool onlyIfCheap)
			{
				if (onlyIfCheap)
				{
					return -1;
				}
				if (!HasLimit)
				{
					return Math.Max(_source.Count() - _minIndexInclusive, 0);
				}
				using IEnumerator<TSource> en = _source.GetEnumerator();
				return Math.Max((int)SkipAndCount((uint)(_maxIndexInclusive + 1), en) - _minIndexInclusive, 0);
			}

			public override bool MoveNext()
			{
				int num = _state - 3;
				if (num < -2)
				{
					Dispose();
					return false;
				}
				int state = _state;
				if (state != 1)
				{
					if (state != 2)
					{
						goto IL_0054;
					}
				}
				else
				{
					_enumerator = _source.GetEnumerator();
					_state = 2;
				}
				if (SkipBeforeFirst(_enumerator))
				{
					_state = 3;
					goto IL_0054;
				}
				goto IL_009b;
				IL_009b:
				Dispose();
				return false;
				IL_0054:
				if ((!HasLimit || num < Limit) && _enumerator.MoveNext())
				{
					if (HasLimit)
					{
						_state++;
					}
					_current = _enumerator.Current;
					return true;
				}
				goto IL_009b;
			}

			public override IEnumerable<TResult> Select<TResult>(Func<TSource, TResult> selector)
			{
				return new SelectIPartitionIterator<TSource, TResult>(this, selector);
			}

			public IPartition<TSource> Skip(int count)
			{
				int num = _minIndexInclusive + count;
				if (!HasLimit)
				{
					if (num < 0)
					{
						return new EnumerablePartition<TSource>(this, count, -1);
					}
				}
				else if ((uint)num > (uint)_maxIndexInclusive)
				{
					return EmptyPartition<TSource>.Instance;
				}
				return new EnumerablePartition<TSource>(_source, num, _maxIndexInclusive);
			}

			public IPartition<TSource> Take(int count)
			{
				int num = _minIndexInclusive + count - 1;
				if (!HasLimit)
				{
					if (num < 0)
					{
						return new EnumerablePartition<TSource>(this, 0, count - 1);
					}
				}
				else if ((uint)num >= (uint)_maxIndexInclusive)
				{
					return this;
				}
				return new EnumerablePartition<TSource>(_source, _minIndexInclusive, num);
			}

			public TSource TryGetElementAt(int index, out bool found)
			{
				if (index >= 0 && (!HasLimit || index < Limit))
				{
					using IEnumerator<TSource> enumerator = _source.GetEnumerator();
					if (SkipBefore(_minIndexInclusive + index, enumerator) && enumerator.MoveNext())
					{
						found = true;
						return enumerator.Current;
					}
				}
				found = false;
				return default(TSource);
			}

			public TSource TryGetFirst(out bool found)
			{
				using (IEnumerator<TSource> enumerator = _source.GetEnumerator())
				{
					if (SkipBeforeFirst(enumerator) && enumerator.MoveNext())
					{
						found = true;
						return enumerator.Current;
					}
				}
				found = false;
				return default(TSource);
			}

			public TSource TryGetLast(out bool found)
			{
				using (IEnumerator<TSource> enumerator = _source.GetEnumerator())
				{
					if (SkipBeforeFirst(enumerator) && enumerator.MoveNext())
					{
						int num = Limit - 1;
						int num2 = ((!HasLimit) ? int.MinValue : 0);
						TSource current;
						do
						{
							num--;
							current = enumerator.Current;
						}
						while (num >= num2 && enumerator.MoveNext());
						found = true;
						return current;
					}
				}
				found = false;
				return default(TSource);
			}

			public TSource[] ToArray()
			{
				using (IEnumerator<TSource> enumerator = _source.GetEnumerator())
				{
					if (SkipBeforeFirst(enumerator) && enumerator.MoveNext())
					{
						int num = Limit - 1;
						int num2 = ((!HasLimit) ? int.MinValue : 0);
						int maxCapacity = (HasLimit ? Limit : int.MaxValue);
						LargeArrayBuilder<TSource> largeArrayBuilder = new LargeArrayBuilder<TSource>(maxCapacity);
						do
						{
							num--;
							largeArrayBuilder.Add(enumerator.Current);
						}
						while (num >= num2 && enumerator.MoveNext());
						return largeArrayBuilder.ToArray();
					}
				}
				return Array.Empty<TSource>();
			}

			public List<TSource> ToList()
			{
				List<TSource> list = new List<TSource>();
				using (IEnumerator<TSource> enumerator = _source.GetEnumerator())
				{
					if (SkipBeforeFirst(enumerator) && enumerator.MoveNext())
					{
						int num = Limit - 1;
						int num2 = ((!HasLimit) ? int.MinValue : 0);
						do
						{
							num--;
							list.Add(enumerator.Current);
						}
						while (num >= num2 && enumerator.MoveNext());
					}
				}
				return list;
			}

			private bool SkipBeforeFirst(IEnumerator<TSource> en)
			{
				return SkipBefore(_minIndexInclusive, en);
			}

			private static bool SkipBefore(int index, IEnumerator<TSource> en)
			{
				return SkipAndCount(index, en) == index;
			}

			private static int SkipAndCount(int index, IEnumerator<TSource> en)
			{
				return (int)SkipAndCount((uint)index, en);
			}

			private static uint SkipAndCount(uint index, IEnumerator<TSource> en)
			{
				for (uint num = 0u; num < index; num++)
				{
					if (!en.MoveNext())
					{
						return num;
					}
				}
				return index;
			}
		}

		private sealed class RangeIterator : Iterator<int>, IPartition<int>, IIListProvider<int>, IEnumerable<int>, IEnumerable
		{
			private readonly int _start;

			private readonly int _end;

			public RangeIterator(int start, int count)
			{
				_start = start;
				_end = start + count;
			}

			public override Iterator<int> Clone()
			{
				return new RangeIterator(_start, _end - _start);
			}

			public override bool MoveNext()
			{
				switch (_state)
				{
				case 1:
					_current = _start;
					_state = 2;
					return true;
				case 2:
					if (++_current != _end)
					{
						return true;
					}
					break;
				}
				_state = -1;
				return false;
			}

			public override void Dispose()
			{
				_state = -1;
			}

			public override IEnumerable<TResult> Select<TResult>(Func<int, TResult> selector)
			{
				return new SelectIPartitionIterator<int, TResult>(this, selector);
			}

			public int[] ToArray()
			{
				int[] array = new int[_end - _start];
				int num = _start;
				for (int i = 0; i != array.Length; i++)
				{
					array[i] = num;
					num++;
				}
				return array;
			}

			public List<int> ToList()
			{
				List<int> list = new List<int>(_end - _start);
				for (int i = _start; i != _end; i++)
				{
					list.Add(i);
				}
				return list;
			}

			public int GetCount(bool onlyIfCheap)
			{
				return _end - _start;
			}

			public IPartition<int> Skip(int count)
			{
				if (count >= _end - _start)
				{
					return EmptyPartition<int>.Instance;
				}
				return new RangeIterator(_start + count, _end - _start - count);
			}

			public IPartition<int> Take(int count)
			{
				int num = _end - _start;
				if (count >= num)
				{
					return this;
				}
				return new RangeIterator(_start, count);
			}

			public int TryGetElementAt(int index, out bool found)
			{
				if ((uint)index < (uint)(_end - _start))
				{
					found = true;
					return _start + index;
				}
				found = false;
				return 0;
			}

			public int TryGetFirst(out bool found)
			{
				found = true;
				return _start;
			}

			public int TryGetLast(out bool found)
			{
				found = true;
				return _end - 1;
			}
		}

		private sealed class RepeatIterator<TResult> : Iterator<TResult>, IPartition<TResult>, IIListProvider<TResult>, IEnumerable<TResult>, IEnumerable
		{
			private readonly int _count;

			public RepeatIterator(TResult element, int count)
			{
				_current = element;
				_count = count;
			}

			public override Iterator<TResult> Clone()
			{
				return new RepeatIterator<TResult>(_current, _count);
			}

			public override void Dispose()
			{
				_state = -1;
			}

			public override bool MoveNext()
			{
				int num = _state - 1;
				if (num >= 0 && num != _count)
				{
					_state++;
					return true;
				}
				Dispose();
				return false;
			}

			public override IEnumerable<TResult2> Select<TResult2>(Func<TResult, TResult2> selector)
			{
				return new SelectIPartitionIterator<TResult, TResult2>(this, selector);
			}

			public TResult[] ToArray()
			{
				TResult[] array = new TResult[_count];
				if (_current != null)
				{
					Array.Fill(array, _current);
				}
				return array;
			}

			public List<TResult> ToList()
			{
				List<TResult> list = new List<TResult>(_count);
				for (int i = 0; i != _count; i++)
				{
					list.Add(_current);
				}
				return list;
			}

			public int GetCount(bool onlyIfCheap)
			{
				return _count;
			}

			public IPartition<TResult> Skip(int count)
			{
				if (count >= _count)
				{
					return EmptyPartition<TResult>.Instance;
				}
				return new RepeatIterator<TResult>(_current, _count - count);
			}

			public IPartition<TResult> Take(int count)
			{
				if (count >= _count)
				{
					return this;
				}
				return new RepeatIterator<TResult>(_current, count);
			}

			public TResult TryGetElementAt(int index, out bool found)
			{
				if ((uint)index < (uint)_count)
				{
					found = true;
					return _current;
				}
				found = false;
				return default(TResult);
			}

			public TResult TryGetFirst(out bool found)
			{
				found = true;
				return _current;
			}

			public TResult TryGetLast(out bool found)
			{
				found = true;
				return _current;
			}
		}

		private sealed class ReverseIterator<TSource> : Iterator<TSource>, IIListProvider<TSource>, IEnumerable<TSource>, IEnumerable
		{
			private readonly IEnumerable<TSource> _source;

			private TSource[] _buffer;

			public ReverseIterator(IEnumerable<TSource> source)
			{
				_source = source;
			}

			public override Iterator<TSource> Clone()
			{
				return new ReverseIterator<TSource>(_source);
			}

			public override bool MoveNext()
			{
				if (_state - 2 <= -2)
				{
					Dispose();
					return false;
				}
				if (_state == 1)
				{
					Buffer<TSource> buffer = new Buffer<TSource>(_source);
					_buffer = buffer._items;
					_state = buffer._count + 2;
				}
				int num = _state - 3;
				if (num != -1)
				{
					_current = _buffer[num];
					_state--;
					return true;
				}
				Dispose();
				return false;
			}

			public override void Dispose()
			{
				_buffer = null;
				base.Dispose();
			}

			public TSource[] ToArray()
			{
				TSource[] array = _source.ToArray();
				Array.Reverse(array);
				return array;
			}

			public List<TSource> ToList()
			{
				List<TSource> list = _source.ToList();
				list.Reverse();
				return list;
			}

			public int GetCount(bool onlyIfCheap)
			{
				if (onlyIfCheap)
				{
					IEnumerable<TSource> source = _source;
					if (!(source is IIListProvider<TSource> iIListProvider))
					{
						if (!(source is ICollection<TSource> collection))
						{
							if (source is ICollection collection2)
							{
								return collection2.Count;
							}
							return -1;
						}
						return collection.Count;
					}
					return iIListProvider.GetCount(onlyIfCheap: true);
				}
				return _source.Count();
			}
		}

		private sealed class SelectEnumerableIterator<TSource, TResult> : Iterator<TResult>, IIListProvider<TResult>, IEnumerable<TResult>, IEnumerable
		{
			private readonly IEnumerable<TSource> _source;

			private readonly Func<TSource, TResult> _selector;

			private IEnumerator<TSource> _enumerator;

			public SelectEnumerableIterator(IEnumerable<TSource> source, Func<TSource, TResult> selector)
			{
				_source = source;
				_selector = selector;
			}

			public override Iterator<TResult> Clone()
			{
				return new SelectEnumerableIterator<TSource, TResult>(_source, _selector);
			}

			public override void Dispose()
			{
				if (_enumerator != null)
				{
					_enumerator.Dispose();
					_enumerator = null;
				}
				base.Dispose();
			}

			public override bool MoveNext()
			{
				int state = _state;
				if (state != 1)
				{
					if (state != 2)
					{
						goto IL_005a;
					}
				}
				else
				{
					_enumerator = _source.GetEnumerator();
					_state = 2;
				}
				if (_enumerator.MoveNext())
				{
					_current = _selector(_enumerator.Current);
					return true;
				}
				Dispose();
				goto IL_005a;
				IL_005a:
				return false;
			}

			public override IEnumerable<TResult2> Select<TResult2>(Func<TResult, TResult2> selector)
			{
				return new SelectEnumerableIterator<TSource, TResult2>(_source, Utilities.CombineSelectors(_selector, selector));
			}

			public TResult[] ToArray()
			{
				LargeArrayBuilder<TResult> largeArrayBuilder = new LargeArrayBuilder<TResult>(initialize: true);
				foreach (TSource item in _source)
				{
					largeArrayBuilder.Add(_selector(item));
				}
				return largeArrayBuilder.ToArray();
			}

			public List<TResult> ToList()
			{
				List<TResult> list = new List<TResult>();
				foreach (TSource item in _source)
				{
					list.Add(_selector(item));
				}
				return list;
			}

			public int GetCount(bool onlyIfCheap)
			{
				if (onlyIfCheap)
				{
					return -1;
				}
				int num = 0;
				foreach (TSource item in _source)
				{
					_selector(item);
					num = checked(num + 1);
				}
				return num;
			}
		}

		private sealed class SelectArrayIterator<TSource, TResult> : Iterator<TResult>, IPartition<TResult>, IIListProvider<TResult>, IEnumerable<TResult>, IEnumerable
		{
			private readonly TSource[] _source;

			private readonly Func<TSource, TResult> _selector;

			public SelectArrayIterator(TSource[] source, Func<TSource, TResult> selector)
			{
				_source = source;
				_selector = selector;
			}

			public override Iterator<TResult> Clone()
			{
				return new SelectArrayIterator<TSource, TResult>(_source, _selector);
			}

			public override bool MoveNext()
			{
				if ((_state < 1) | (_state == _source.Length + 1))
				{
					Dispose();
					return false;
				}
				int num = _state++ - 1;
				_current = _selector(_source[num]);
				return true;
			}

			public override IEnumerable<TResult2> Select<TResult2>(Func<TResult, TResult2> selector)
			{
				return new SelectArrayIterator<TSource, TResult2>(_source, Utilities.CombineSelectors(_selector, selector));
			}

			public TResult[] ToArray()
			{
				TResult[] array = new TResult[_source.Length];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = _selector(_source[i]);
				}
				return array;
			}

			public List<TResult> ToList()
			{
				TSource[] source = _source;
				List<TResult> list = new List<TResult>(source.Length);
				for (int i = 0; i < source.Length; i++)
				{
					list.Add(_selector(source[i]));
				}
				return list;
			}

			public int GetCount(bool onlyIfCheap)
			{
				if (!onlyIfCheap)
				{
					TSource[] source = _source;
					foreach (TSource arg in source)
					{
						_selector(arg);
					}
				}
				return _source.Length;
			}

			public IPartition<TResult> Skip(int count)
			{
				if (count >= _source.Length)
				{
					return EmptyPartition<TResult>.Instance;
				}
				return new SelectListPartitionIterator<TSource, TResult>(_source, _selector, count, int.MaxValue);
			}

			public IPartition<TResult> Take(int count)
			{
				if (count < _source.Length)
				{
					return new SelectListPartitionIterator<TSource, TResult>(_source, _selector, 0, count - 1);
				}
				return this;
			}

			public TResult TryGetElementAt(int index, out bool found)
			{
				if ((uint)index < (uint)_source.Length)
				{
					found = true;
					return _selector(_source[index]);
				}
				found = false;
				return default(TResult);
			}

			public TResult TryGetFirst(out bool found)
			{
				found = true;
				return _selector(_source[0]);
			}

			public TResult TryGetLast(out bool found)
			{
				found = true;
				return _selector(_source[_source.Length - 1]);
			}
		}

		private sealed class SelectListIterator<TSource, TResult> : Iterator<TResult>, IPartition<TResult>, IIListProvider<TResult>, IEnumerable<TResult>, IEnumerable
		{
			private readonly List<TSource> _source;

			private readonly Func<TSource, TResult> _selector;

			private List<TSource>.Enumerator _enumerator;

			public SelectListIterator(List<TSource> source, Func<TSource, TResult> selector)
			{
				_source = source;
				_selector = selector;
			}

			public override Iterator<TResult> Clone()
			{
				return new SelectListIterator<TSource, TResult>(_source, _selector);
			}

			public override bool MoveNext()
			{
				int state = _state;
				if (state != 1)
				{
					if (state != 2)
					{
						goto IL_005a;
					}
				}
				else
				{
					_enumerator = _source.GetEnumerator();
					_state = 2;
				}
				if (_enumerator.MoveNext())
				{
					_current = _selector(_enumerator.Current);
					return true;
				}
				Dispose();
				goto IL_005a;
				IL_005a:
				return false;
			}

			public override IEnumerable<TResult2> Select<TResult2>(Func<TResult, TResult2> selector)
			{
				return new SelectListIterator<TSource, TResult2>(_source, Utilities.CombineSelectors(_selector, selector));
			}

			public TResult[] ToArray()
			{
				int count = _source.Count;
				if (count == 0)
				{
					return Array.Empty<TResult>();
				}
				TResult[] array = new TResult[count];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = _selector(_source[i]);
				}
				return array;
			}

			public List<TResult> ToList()
			{
				int count = _source.Count;
				List<TResult> list = new List<TResult>(count);
				for (int i = 0; i < count; i++)
				{
					list.Add(_selector(_source[i]));
				}
				return list;
			}

			public int GetCount(bool onlyIfCheap)
			{
				int count = _source.Count;
				if (!onlyIfCheap)
				{
					for (int i = 0; i < count; i++)
					{
						_selector(_source[i]);
					}
				}
				return count;
			}

			public IPartition<TResult> Skip(int count)
			{
				return new SelectListPartitionIterator<TSource, TResult>(_source, _selector, count, int.MaxValue);
			}

			public IPartition<TResult> Take(int count)
			{
				return new SelectListPartitionIterator<TSource, TResult>(_source, _selector, 0, count - 1);
			}

			public TResult TryGetElementAt(int index, out bool found)
			{
				if ((uint)index < (uint)_source.Count)
				{
					found = true;
					return _selector(_source[index]);
				}
				found = false;
				return default(TResult);
			}

			public TResult TryGetFirst(out bool found)
			{
				if (_source.Count != 0)
				{
					found = true;
					return _selector(_source[0]);
				}
				found = false;
				return default(TResult);
			}

			public TResult TryGetLast(out bool found)
			{
				int count = _source.Count;
				if (count != 0)
				{
					found = true;
					return _selector(_source[count - 1]);
				}
				found = false;
				return default(TResult);
			}
		}

		private sealed class SelectIListIterator<TSource, TResult> : Iterator<TResult>, IPartition<TResult>, IIListProvider<TResult>, IEnumerable<TResult>, IEnumerable
		{
			private readonly IList<TSource> _source;

			private readonly Func<TSource, TResult> _selector;

			private IEnumerator<TSource> _enumerator;

			public SelectIListIterator(IList<TSource> source, Func<TSource, TResult> selector)
			{
				_source = source;
				_selector = selector;
			}

			public override Iterator<TResult> Clone()
			{
				return new SelectIListIterator<TSource, TResult>(_source, _selector);
			}

			public override bool MoveNext()
			{
				int state = _state;
				if (state != 1)
				{
					if (state != 2)
					{
						goto IL_005a;
					}
				}
				else
				{
					_enumerator = _source.GetEnumerator();
					_state = 2;
				}
				if (_enumerator.MoveNext())
				{
					_current = _selector(_enumerator.Current);
					return true;
				}
				Dispose();
				goto IL_005a;
				IL_005a:
				return false;
			}

			public override void Dispose()
			{
				if (_enumerator != null)
				{
					_enumerator.Dispose();
					_enumerator = null;
				}
				base.Dispose();
			}

			public override IEnumerable<TResult2> Select<TResult2>(Func<TResult, TResult2> selector)
			{
				return new SelectIListIterator<TSource, TResult2>(_source, Utilities.CombineSelectors(_selector, selector));
			}

			public TResult[] ToArray()
			{
				int count = _source.Count;
				if (count == 0)
				{
					return Array.Empty<TResult>();
				}
				TResult[] array = new TResult[count];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = _selector(_source[i]);
				}
				return array;
			}

			public List<TResult> ToList()
			{
				int count = _source.Count;
				List<TResult> list = new List<TResult>(count);
				for (int i = 0; i < count; i++)
				{
					list.Add(_selector(_source[i]));
				}
				return list;
			}

			public int GetCount(bool onlyIfCheap)
			{
				int count = _source.Count;
				if (!onlyIfCheap)
				{
					for (int i = 0; i < count; i++)
					{
						_selector(_source[i]);
					}
				}
				return count;
			}

			public IPartition<TResult> Skip(int count)
			{
				return new SelectListPartitionIterator<TSource, TResult>(_source, _selector, count, int.MaxValue);
			}

			public IPartition<TResult> Take(int count)
			{
				return new SelectListPartitionIterator<TSource, TResult>(_source, _selector, 0, count - 1);
			}

			public TResult TryGetElementAt(int index, out bool found)
			{
				if ((uint)index < (uint)_source.Count)
				{
					found = true;
					return _selector(_source[index]);
				}
				found = false;
				return default(TResult);
			}

			public TResult TryGetFirst(out bool found)
			{
				if (_source.Count != 0)
				{
					found = true;
					return _selector(_source[0]);
				}
				found = false;
				return default(TResult);
			}

			public TResult TryGetLast(out bool found)
			{
				int count = _source.Count;
				if (count != 0)
				{
					found = true;
					return _selector(_source[count - 1]);
				}
				found = false;
				return default(TResult);
			}
		}

		private sealed class SelectIPartitionIterator<TSource, TResult> : Iterator<TResult>, IPartition<TResult>, IIListProvider<TResult>, IEnumerable<TResult>, IEnumerable
		{
			private readonly IPartition<TSource> _source;

			private readonly Func<TSource, TResult> _selector;

			private IEnumerator<TSource> _enumerator;

			public SelectIPartitionIterator(IPartition<TSource> source, Func<TSource, TResult> selector)
			{
				_source = source;
				_selector = selector;
			}

			public override Iterator<TResult> Clone()
			{
				return new SelectIPartitionIterator<TSource, TResult>(_source, _selector);
			}

			public override bool MoveNext()
			{
				int state = _state;
				if (state != 1)
				{
					if (state != 2)
					{
						goto IL_005a;
					}
				}
				else
				{
					_enumerator = _source.GetEnumerator();
					_state = 2;
				}
				if (_enumerator.MoveNext())
				{
					_current = _selector(_enumerator.Current);
					return true;
				}
				Dispose();
				goto IL_005a;
				IL_005a:
				return false;
			}

			public override void Dispose()
			{
				if (_enumerator != null)
				{
					_enumerator.Dispose();
					_enumerator = null;
				}
				base.Dispose();
			}

			public override IEnumerable<TResult2> Select<TResult2>(Func<TResult, TResult2> selector)
			{
				return new SelectIPartitionIterator<TSource, TResult2>(_source, Utilities.CombineSelectors(_selector, selector));
			}

			public IPartition<TResult> Skip(int count)
			{
				return new SelectIPartitionIterator<TSource, TResult>(_source.Skip(count), _selector);
			}

			public IPartition<TResult> Take(int count)
			{
				return new SelectIPartitionIterator<TSource, TResult>(_source.Take(count), _selector);
			}

			public TResult TryGetElementAt(int index, out bool found)
			{
				bool found2;
				TSource arg = _source.TryGetElementAt(index, out found2);
				found = found2;
				if (!found2)
				{
					return default(TResult);
				}
				return _selector(arg);
			}

			public TResult TryGetFirst(out bool found)
			{
				bool found2;
				TSource arg = _source.TryGetFirst(out found2);
				found = found2;
				if (!found2)
				{
					return default(TResult);
				}
				return _selector(arg);
			}

			public TResult TryGetLast(out bool found)
			{
				bool found2;
				TSource arg = _source.TryGetLast(out found2);
				found = found2;
				if (!found2)
				{
					return default(TResult);
				}
				return _selector(arg);
			}

			private TResult[] LazyToArray()
			{
				LargeArrayBuilder<TResult> largeArrayBuilder = new LargeArrayBuilder<TResult>(initialize: true);
				foreach (TSource item in _source)
				{
					largeArrayBuilder.Add(_selector(item));
				}
				return largeArrayBuilder.ToArray();
			}

			private TResult[] PreallocatingToArray(int count)
			{
				TResult[] array = new TResult[count];
				int num = 0;
				foreach (TSource item in _source)
				{
					array[num] = _selector(item);
					num++;
				}
				return array;
			}

			public TResult[] ToArray()
			{
				int count = _source.GetCount(onlyIfCheap: true);
				return count switch
				{
					-1 => LazyToArray(), 
					0 => Array.Empty<TResult>(), 
					_ => PreallocatingToArray(count), 
				};
			}

			public List<TResult> ToList()
			{
				int count = _source.GetCount(onlyIfCheap: true);
				List<TResult> list;
				switch (count)
				{
				case -1:
					list = new List<TResult>();
					break;
				case 0:
					return new List<TResult>();
				default:
					list = new List<TResult>(count);
					break;
				}
				foreach (TSource item in _source)
				{
					list.Add(_selector(item));
				}
				return list;
			}

			public int GetCount(bool onlyIfCheap)
			{
				if (!onlyIfCheap)
				{
					foreach (TSource item in _source)
					{
						_selector(item);
					}
				}
				return _source.GetCount(onlyIfCheap);
			}
		}

		private sealed class SelectListPartitionIterator<TSource, TResult> : Iterator<TResult>, IPartition<TResult>, IIListProvider<TResult>, IEnumerable<TResult>, IEnumerable
		{
			private readonly IList<TSource> _source;

			private readonly Func<TSource, TResult> _selector;

			private readonly int _minIndexInclusive;

			private readonly int _maxIndexInclusive;

			private int Count
			{
				get
				{
					int count = _source.Count;
					if (count <= _minIndexInclusive)
					{
						return 0;
					}
					return Math.Min(count - 1, _maxIndexInclusive) - _minIndexInclusive + 1;
				}
			}

			public SelectListPartitionIterator(IList<TSource> source, Func<TSource, TResult> selector, int minIndexInclusive, int maxIndexInclusive)
			{
				_source = source;
				_selector = selector;
				_minIndexInclusive = minIndexInclusive;
				_maxIndexInclusive = maxIndexInclusive;
			}

			public override Iterator<TResult> Clone()
			{
				return new SelectListPartitionIterator<TSource, TResult>(_source, _selector, _minIndexInclusive, _maxIndexInclusive);
			}

			public override bool MoveNext()
			{
				int num = _state - 1;
				if ((uint)num <= (uint)(_maxIndexInclusive - _minIndexInclusive) && num < _source.Count - _minIndexInclusive)
				{
					_current = _selector(_source[_minIndexInclusive + num]);
					_state++;
					return true;
				}
				Dispose();
				return false;
			}

			public override IEnumerable<TResult2> Select<TResult2>(Func<TResult, TResult2> selector)
			{
				return new SelectListPartitionIterator<TSource, TResult2>(_source, Utilities.CombineSelectors(_selector, selector), _minIndexInclusive, _maxIndexInclusive);
			}

			public IPartition<TResult> Skip(int count)
			{
				int num = _minIndexInclusive + count;
				if ((uint)num <= (uint)_maxIndexInclusive)
				{
					return new SelectListPartitionIterator<TSource, TResult>(_source, _selector, num, _maxIndexInclusive);
				}
				return EmptyPartition<TResult>.Instance;
			}

			public IPartition<TResult> Take(int count)
			{
				int num = _minIndexInclusive + count - 1;
				if ((uint)num < (uint)_maxIndexInclusive)
				{
					return new SelectListPartitionIterator<TSource, TResult>(_source, _selector, _minIndexInclusive, num);
				}
				return this;
			}

			public TResult TryGetElementAt(int index, out bool found)
			{
				if ((uint)index <= (uint)(_maxIndexInclusive - _minIndexInclusive) && index < _source.Count - _minIndexInclusive)
				{
					found = true;
					return _selector(_source[_minIndexInclusive + index]);
				}
				found = false;
				return default(TResult);
			}

			public TResult TryGetFirst(out bool found)
			{
				if (_source.Count > _minIndexInclusive)
				{
					found = true;
					return _selector(_source[_minIndexInclusive]);
				}
				found = false;
				return default(TResult);
			}

			public TResult TryGetLast(out bool found)
			{
				int num = _source.Count - 1;
				if (num >= _minIndexInclusive)
				{
					found = true;
					return _selector(_source[Math.Min(num, _maxIndexInclusive)]);
				}
				found = false;
				return default(TResult);
			}

			public TResult[] ToArray()
			{
				int count = Count;
				if (count == 0)
				{
					return Array.Empty<TResult>();
				}
				TResult[] array = new TResult[count];
				int num = 0;
				int num2 = _minIndexInclusive;
				while (num != array.Length)
				{
					array[num] = _selector(_source[num2]);
					num++;
					num2++;
				}
				return array;
			}

			public List<TResult> ToList()
			{
				int count = Count;
				if (count == 0)
				{
					return new List<TResult>();
				}
				List<TResult> list = new List<TResult>(count);
				int num = _minIndexInclusive + count;
				for (int i = _minIndexInclusive; i != num; i++)
				{
					list.Add(_selector(_source[i]));
				}
				return list;
			}

			public int GetCount(bool onlyIfCheap)
			{
				int count = Count;
				if (!onlyIfCheap)
				{
					int num = _minIndexInclusive + count;
					for (int i = _minIndexInclusive; i != num; i++)
					{
						_selector(_source[i]);
					}
				}
				return count;
			}
		}

		private sealed class SelectManySingleSelectorIterator<TSource, TResult> : Iterator<TResult>, IIListProvider<TResult>, IEnumerable<TResult>, IEnumerable
		{
			private readonly IEnumerable<TSource> _source;

			private readonly Func<TSource, IEnumerable<TResult>> _selector;

			private IEnumerator<TSource> _sourceEnumerator;

			private IEnumerator<TResult> _subEnumerator;

			internal SelectManySingleSelectorIterator(IEnumerable<TSource> source, Func<TSource, IEnumerable<TResult>> selector)
			{
				_source = source;
				_selector = selector;
			}

			public override Iterator<TResult> Clone()
			{
				return new SelectManySingleSelectorIterator<TSource, TResult>(_source, _selector);
			}

			public override void Dispose()
			{
				if (_subEnumerator != null)
				{
					_subEnumerator.Dispose();
					_subEnumerator = null;
				}
				if (_sourceEnumerator != null)
				{
					_sourceEnumerator.Dispose();
					_sourceEnumerator = null;
				}
				base.Dispose();
			}

			public int GetCount(bool onlyIfCheap)
			{
				if (onlyIfCheap)
				{
					return -1;
				}
				int num = 0;
				foreach (TSource item in _source)
				{
					num = checked(num + _selector(item).Count());
				}
				return num;
			}

			public override bool MoveNext()
			{
				switch (_state)
				{
				case 1:
					_sourceEnumerator = _source.GetEnumerator();
					_state = 2;
					goto case 2;
				case 2:
				{
					if (!_sourceEnumerator.MoveNext())
					{
						break;
					}
					TSource current = _sourceEnumerator.Current;
					_subEnumerator = _selector(current).GetEnumerator();
					_state = 3;
					goto case 3;
				}
				case 3:
					if (!_subEnumerator.MoveNext())
					{
						_subEnumerator.Dispose();
						_subEnumerator = null;
						_state = 2;
						goto case 2;
					}
					_current = _subEnumerator.Current;
					return true;
				}
				Dispose();
				return false;
			}

			public TResult[] ToArray()
			{
				SparseArrayBuilder<TResult> sparseArrayBuilder = new SparseArrayBuilder<TResult>(initialize: true);
				ArrayBuilder<IEnumerable<TResult>> arrayBuilder = default(ArrayBuilder<IEnumerable<TResult>>);
				foreach (TSource item in _source)
				{
					IEnumerable<TResult> enumerable = _selector(item);
					if (sparseArrayBuilder.ReserveOrAdd(enumerable))
					{
						arrayBuilder.Add(enumerable);
					}
				}
				TResult[] array = sparseArrayBuilder.ToArray();
				ArrayBuilder<Marker> markers = sparseArrayBuilder.Markers;
				for (int i = 0; i < markers.Count; i++)
				{
					Marker marker = markers[i];
					EnumerableHelpers.Copy(arrayBuilder[i], array, marker.Index, marker.Count);
				}
				return array;
			}

			public List<TResult> ToList()
			{
				List<TResult> list = new List<TResult>();
				foreach (TSource item in _source)
				{
					list.AddRange(_selector(item));
				}
				return list;
			}
		}

		private abstract class UnionIterator<TSource> : Iterator<TSource>, IIListProvider<TSource>, IEnumerable<TSource>, IEnumerable
		{
			internal readonly IEqualityComparer<TSource> _comparer;

			private IEnumerator<TSource> _enumerator;

			private Set<TSource> _set;

			protected UnionIterator(IEqualityComparer<TSource> comparer)
			{
				_comparer = comparer;
			}

			public sealed override void Dispose()
			{
				if (_enumerator != null)
				{
					_enumerator.Dispose();
					_enumerator = null;
					_set = null;
				}
				base.Dispose();
			}

			internal abstract IEnumerable<TSource> GetEnumerable(int index);

			internal abstract UnionIterator<TSource> Union(IEnumerable<TSource> next);

			private void SetEnumerator(IEnumerator<TSource> enumerator)
			{
				_enumerator?.Dispose();
				_enumerator = enumerator;
			}

			private void StoreFirst()
			{
				Set<TSource> set = new Set<TSource>(_comparer);
				TSource current = _enumerator.Current;
				set.Add(current);
				_current = current;
				_set = set;
			}

			private bool GetNext()
			{
				Set<TSource> set = _set;
				while (_enumerator.MoveNext())
				{
					TSource current = _enumerator.Current;
					if (set.Add(current))
					{
						_current = current;
						return true;
					}
				}
				return false;
			}

			public sealed override bool MoveNext()
			{
				if (_state == 1)
				{
					for (IEnumerable<TSource> enumerable = GetEnumerable(0); enumerable != null; enumerable = GetEnumerable(_state - 1))
					{
						IEnumerator<TSource> enumerator = enumerable.GetEnumerator();
						_state++;
						if (enumerator.MoveNext())
						{
							SetEnumerator(enumerator);
							StoreFirst();
							return true;
						}
					}
				}
				else if (_state > 0)
				{
					while (true)
					{
						if (GetNext())
						{
							return true;
						}
						IEnumerable<TSource> enumerable2 = GetEnumerable(_state - 1);
						if (enumerable2 == null)
						{
							break;
						}
						SetEnumerator(enumerable2.GetEnumerator());
						_state++;
					}
				}
				Dispose();
				return false;
			}

			private Set<TSource> FillSet()
			{
				Set<TSource> set = new Set<TSource>(_comparer);
				int num = 0;
				while (true)
				{
					IEnumerable<TSource> enumerable = GetEnumerable(num);
					if (enumerable == null)
					{
						break;
					}
					set.UnionWith(enumerable);
					num++;
				}
				return set;
			}

			public TSource[] ToArray()
			{
				return FillSet().ToArray();
			}

			public List<TSource> ToList()
			{
				return FillSet().ToList();
			}

			public int GetCount(bool onlyIfCheap)
			{
				if (!onlyIfCheap)
				{
					return FillSet().Count;
				}
				return -1;
			}
		}

		private sealed class UnionIterator2<TSource> : UnionIterator<TSource>
		{
			private readonly IEnumerable<TSource> _first;

			private readonly IEnumerable<TSource> _second;

			public UnionIterator2(IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
				: base(comparer)
			{
				_first = first;
				_second = second;
			}

			public override Iterator<TSource> Clone()
			{
				return new UnionIterator2<TSource>(_first, _second, _comparer);
			}

			internal override IEnumerable<TSource> GetEnumerable(int index)
			{
				return index switch
				{
					0 => _first, 
					1 => _second, 
					_ => null, 
				};
			}

			internal override UnionIterator<TSource> Union(IEnumerable<TSource> next)
			{
				return new UnionIteratorN<TSource>(new SingleLinkedNode<IEnumerable<TSource>>(_first).Add(_second).Add(next), 2, _comparer);
			}
		}

		private sealed class UnionIteratorN<TSource> : UnionIterator<TSource>
		{
			private readonly SingleLinkedNode<IEnumerable<TSource>> _sources;

			private readonly int _headIndex;

			public UnionIteratorN(SingleLinkedNode<IEnumerable<TSource>> sources, int headIndex, IEqualityComparer<TSource> comparer)
				: base(comparer)
			{
				_sources = sources;
				_headIndex = headIndex;
			}

			public override Iterator<TSource> Clone()
			{
				return new UnionIteratorN<TSource>(_sources, _headIndex, _comparer);
			}

			internal override IEnumerable<TSource> GetEnumerable(int index)
			{
				if (index <= _headIndex)
				{
					return _sources.GetNode(_headIndex - index).Item;
				}
				return null;
			}

			internal override UnionIterator<TSource> Union(IEnumerable<TSource> next)
			{
				if (_headIndex == 2147483645)
				{
					return new UnionIterator2<TSource>(this, next, _comparer);
				}
				return new UnionIteratorN<TSource>(_sources.Add(next), _headIndex + 1, _comparer);
			}
		}

		private sealed class WhereEnumerableIterator<TSource> : Iterator<TSource>, IIListProvider<TSource>, IEnumerable<TSource>, IEnumerable
		{
			private readonly IEnumerable<TSource> _source;

			private readonly Func<TSource, bool> _predicate;

			private IEnumerator<TSource> _enumerator;

			public WhereEnumerableIterator(IEnumerable<TSource> source, Func<TSource, bool> predicate)
			{
				_source = source;
				_predicate = predicate;
			}

			public override Iterator<TSource> Clone()
			{
				return new WhereEnumerableIterator<TSource>(_source, _predicate);
			}

			public override void Dispose()
			{
				if (_enumerator != null)
				{
					_enumerator.Dispose();
					_enumerator = null;
				}
				base.Dispose();
			}

			public int GetCount(bool onlyIfCheap)
			{
				if (onlyIfCheap)
				{
					return -1;
				}
				int num = 0;
				foreach (TSource item in _source)
				{
					if (_predicate(item))
					{
						num = checked(num + 1);
					}
				}
				return num;
			}

			public override bool MoveNext()
			{
				int state = _state;
				if (state != 1)
				{
					if (state != 2)
					{
						goto IL_0061;
					}
				}
				else
				{
					_enumerator = _source.GetEnumerator();
					_state = 2;
				}
				while (_enumerator.MoveNext())
				{
					TSource current = _enumerator.Current;
					if (_predicate(current))
					{
						_current = current;
						return true;
					}
				}
				Dispose();
				goto IL_0061;
				IL_0061:
				return false;
			}

			public override IEnumerable<TResult> Select<TResult>(Func<TSource, TResult> selector)
			{
				return new WhereSelectEnumerableIterator<TSource, TResult>(_source, _predicate, selector);
			}

			public TSource[] ToArray()
			{
				LargeArrayBuilder<TSource> largeArrayBuilder = new LargeArrayBuilder<TSource>(initialize: true);
				foreach (TSource item in _source)
				{
					if (_predicate(item))
					{
						largeArrayBuilder.Add(item);
					}
				}
				return largeArrayBuilder.ToArray();
			}

			public List<TSource> ToList()
			{
				List<TSource> list = new List<TSource>();
				foreach (TSource item in _source)
				{
					if (_predicate(item))
					{
						list.Add(item);
					}
				}
				return list;
			}

			public override IEnumerable<TSource> Where(Func<TSource, bool> predicate)
			{
				return new WhereEnumerableIterator<TSource>(_source, Utilities.CombinePredicates(_predicate, predicate));
			}
		}

		internal sealed class WhereArrayIterator<TSource> : Iterator<TSource>, IIListProvider<TSource>, IEnumerable<TSource>, IEnumerable
		{
			private readonly TSource[] _source;

			private readonly Func<TSource, bool> _predicate;

			public WhereArrayIterator(TSource[] source, Func<TSource, bool> predicate)
			{
				_source = source;
				_predicate = predicate;
			}

			public override Iterator<TSource> Clone()
			{
				return new WhereArrayIterator<TSource>(_source, _predicate);
			}

			public int GetCount(bool onlyIfCheap)
			{
				if (onlyIfCheap)
				{
					return -1;
				}
				int num = 0;
				TSource[] source = _source;
				foreach (TSource arg in source)
				{
					if (_predicate(arg))
					{
						num = checked(num + 1);
					}
				}
				return num;
			}

			public override bool MoveNext()
			{
				int num = _state - 1;
				TSource[] source = _source;
				while ((uint)num < (uint)source.Length)
				{
					TSource val = source[num];
					num = _state++;
					if (_predicate(val))
					{
						_current = val;
						return true;
					}
				}
				Dispose();
				return false;
			}

			public override IEnumerable<TResult> Select<TResult>(Func<TSource, TResult> selector)
			{
				return new WhereSelectArrayIterator<TSource, TResult>(_source, _predicate, selector);
			}

			public TSource[] ToArray()
			{
				LargeArrayBuilder<TSource> largeArrayBuilder = new LargeArrayBuilder<TSource>(_source.Length);
				TSource[] source = _source;
				foreach (TSource val in source)
				{
					if (_predicate(val))
					{
						largeArrayBuilder.Add(val);
					}
				}
				return largeArrayBuilder.ToArray();
			}

			public List<TSource> ToList()
			{
				List<TSource> list = new List<TSource>();
				TSource[] source = _source;
				foreach (TSource val in source)
				{
					if (_predicate(val))
					{
						list.Add(val);
					}
				}
				return list;
			}

			public override IEnumerable<TSource> Where(Func<TSource, bool> predicate)
			{
				return new WhereArrayIterator<TSource>(_source, Utilities.CombinePredicates(_predicate, predicate));
			}
		}

		private sealed class WhereListIterator<TSource> : Iterator<TSource>, IIListProvider<TSource>, IEnumerable<TSource>, IEnumerable
		{
			private readonly List<TSource> _source;

			private readonly Func<TSource, bool> _predicate;

			private List<TSource>.Enumerator _enumerator;

			public WhereListIterator(List<TSource> source, Func<TSource, bool> predicate)
			{
				_source = source;
				_predicate = predicate;
			}

			public override Iterator<TSource> Clone()
			{
				return new WhereListIterator<TSource>(_source, _predicate);
			}

			public int GetCount(bool onlyIfCheap)
			{
				if (onlyIfCheap)
				{
					return -1;
				}
				int num = 0;
				for (int i = 0; i < _source.Count; i++)
				{
					TSource arg = _source[i];
					if (_predicate(arg))
					{
						num = checked(num + 1);
					}
				}
				return num;
			}

			public override bool MoveNext()
			{
				int state = _state;
				if (state != 1)
				{
					if (state != 2)
					{
						goto IL_0061;
					}
				}
				else
				{
					_enumerator = _source.GetEnumerator();
					_state = 2;
				}
				while (_enumerator.MoveNext())
				{
					TSource current = _enumerator.Current;
					if (_predicate(current))
					{
						_current = current;
						return true;
					}
				}
				Dispose();
				goto IL_0061;
				IL_0061:
				return false;
			}

			public override IEnumerable<TResult> Select<TResult>(Func<TSource, TResult> selector)
			{
				return new WhereSelectListIterator<TSource, TResult>(_source, _predicate, selector);
			}

			public TSource[] ToArray()
			{
				LargeArrayBuilder<TSource> largeArrayBuilder = new LargeArrayBuilder<TSource>(_source.Count);
				for (int i = 0; i < _source.Count; i++)
				{
					TSource val = _source[i];
					if (_predicate(val))
					{
						largeArrayBuilder.Add(val);
					}
				}
				return largeArrayBuilder.ToArray();
			}

			public List<TSource> ToList()
			{
				List<TSource> list = new List<TSource>();
				for (int i = 0; i < _source.Count; i++)
				{
					TSource val = _source[i];
					if (_predicate(val))
					{
						list.Add(val);
					}
				}
				return list;
			}

			public override IEnumerable<TSource> Where(Func<TSource, bool> predicate)
			{
				return new WhereListIterator<TSource>(_source, Utilities.CombinePredicates(_predicate, predicate));
			}
		}

		private sealed class WhereSelectArrayIterator<TSource, TResult> : Iterator<TResult>, IIListProvider<TResult>, IEnumerable<TResult>, IEnumerable
		{
			private readonly TSource[] _source;

			private readonly Func<TSource, bool> _predicate;

			private readonly Func<TSource, TResult> _selector;

			public WhereSelectArrayIterator(TSource[] source, Func<TSource, bool> predicate, Func<TSource, TResult> selector)
			{
				_source = source;
				_predicate = predicate;
				_selector = selector;
			}

			public override Iterator<TResult> Clone()
			{
				return new WhereSelectArrayIterator<TSource, TResult>(_source, _predicate, _selector);
			}

			public int GetCount(bool onlyIfCheap)
			{
				if (onlyIfCheap)
				{
					return -1;
				}
				int num = 0;
				TSource[] source = _source;
				foreach (TSource arg in source)
				{
					if (_predicate(arg))
					{
						_selector(arg);
						num = checked(num + 1);
					}
				}
				return num;
			}

			public override bool MoveNext()
			{
				int num = _state - 1;
				TSource[] source = _source;
				while ((uint)num < (uint)source.Length)
				{
					TSource arg = source[num];
					num = _state++;
					if (_predicate(arg))
					{
						_current = _selector(arg);
						return true;
					}
				}
				Dispose();
				return false;
			}

			public override IEnumerable<TResult2> Select<TResult2>(Func<TResult, TResult2> selector)
			{
				return new WhereSelectArrayIterator<TSource, TResult2>(_source, _predicate, Utilities.CombineSelectors(_selector, selector));
			}

			public TResult[] ToArray()
			{
				LargeArrayBuilder<TResult> largeArrayBuilder = new LargeArrayBuilder<TResult>(_source.Length);
				TSource[] source = _source;
				foreach (TSource arg in source)
				{
					if (_predicate(arg))
					{
						largeArrayBuilder.Add(_selector(arg));
					}
				}
				return largeArrayBuilder.ToArray();
			}

			public List<TResult> ToList()
			{
				List<TResult> list = new List<TResult>();
				TSource[] source = _source;
				foreach (TSource arg in source)
				{
					if (_predicate(arg))
					{
						list.Add(_selector(arg));
					}
				}
				return list;
			}
		}

		private sealed class WhereSelectListIterator<TSource, TResult> : Iterator<TResult>, IIListProvider<TResult>, IEnumerable<TResult>, IEnumerable
		{
			private readonly List<TSource> _source;

			private readonly Func<TSource, bool> _predicate;

			private readonly Func<TSource, TResult> _selector;

			private List<TSource>.Enumerator _enumerator;

			public WhereSelectListIterator(List<TSource> source, Func<TSource, bool> predicate, Func<TSource, TResult> selector)
			{
				_source = source;
				_predicate = predicate;
				_selector = selector;
			}

			public override Iterator<TResult> Clone()
			{
				return new WhereSelectListIterator<TSource, TResult>(_source, _predicate, _selector);
			}

			public int GetCount(bool onlyIfCheap)
			{
				if (onlyIfCheap)
				{
					return -1;
				}
				int num = 0;
				for (int i = 0; i < _source.Count; i++)
				{
					TSource arg = _source[i];
					if (_predicate(arg))
					{
						_selector(arg);
						num = checked(num + 1);
					}
				}
				return num;
			}

			public override bool MoveNext()
			{
				int state = _state;
				if (state != 1)
				{
					if (state != 2)
					{
						goto IL_006c;
					}
				}
				else
				{
					_enumerator = _source.GetEnumerator();
					_state = 2;
				}
				while (_enumerator.MoveNext())
				{
					TSource current = _enumerator.Current;
					if (_predicate(current))
					{
						_current = _selector(current);
						return true;
					}
				}
				Dispose();
				goto IL_006c;
				IL_006c:
				return false;
			}

			public override IEnumerable<TResult2> Select<TResult2>(Func<TResult, TResult2> selector)
			{
				return new WhereSelectListIterator<TSource, TResult2>(_source, _predicate, Utilities.CombineSelectors(_selector, selector));
			}

			public TResult[] ToArray()
			{
				LargeArrayBuilder<TResult> largeArrayBuilder = new LargeArrayBuilder<TResult>(_source.Count);
				for (int i = 0; i < _source.Count; i++)
				{
					TSource arg = _source[i];
					if (_predicate(arg))
					{
						largeArrayBuilder.Add(_selector(arg));
					}
				}
				return largeArrayBuilder.ToArray();
			}

			public List<TResult> ToList()
			{
				List<TResult> list = new List<TResult>();
				for (int i = 0; i < _source.Count; i++)
				{
					TSource arg = _source[i];
					if (_predicate(arg))
					{
						list.Add(_selector(arg));
					}
				}
				return list;
			}
		}

		private sealed class WhereSelectEnumerableIterator<TSource, TResult> : Iterator<TResult>, IIListProvider<TResult>, IEnumerable<TResult>, IEnumerable
		{
			private readonly IEnumerable<TSource> _source;

			private readonly Func<TSource, bool> _predicate;

			private readonly Func<TSource, TResult> _selector;

			private IEnumerator<TSource> _enumerator;

			public WhereSelectEnumerableIterator(IEnumerable<TSource> source, Func<TSource, bool> predicate, Func<TSource, TResult> selector)
			{
				_source = source;
				_predicate = predicate;
				_selector = selector;
			}

			public override Iterator<TResult> Clone()
			{
				return new WhereSelectEnumerableIterator<TSource, TResult>(_source, _predicate, _selector);
			}

			public override void Dispose()
			{
				if (_enumerator != null)
				{
					_enumerator.Dispose();
					_enumerator = null;
				}
				base.Dispose();
			}

			public int GetCount(bool onlyIfCheap)
			{
				if (onlyIfCheap)
				{
					return -1;
				}
				int num = 0;
				foreach (TSource item in _source)
				{
					if (_predicate(item))
					{
						_selector(item);
						num = checked(num + 1);
					}
				}
				return num;
			}

			public override bool MoveNext()
			{
				int state = _state;
				if (state != 1)
				{
					if (state != 2)
					{
						goto IL_006c;
					}
				}
				else
				{
					_enumerator = _source.GetEnumerator();
					_state = 2;
				}
				while (_enumerator.MoveNext())
				{
					TSource current = _enumerator.Current;
					if (_predicate(current))
					{
						_current = _selector(current);
						return true;
					}
				}
				Dispose();
				goto IL_006c;
				IL_006c:
				return false;
			}

			public override IEnumerable<TResult2> Select<TResult2>(Func<TResult, TResult2> selector)
			{
				return new WhereSelectEnumerableIterator<TSource, TResult2>(_source, _predicate, Utilities.CombineSelectors(_selector, selector));
			}

			public TResult[] ToArray()
			{
				LargeArrayBuilder<TResult> largeArrayBuilder = new LargeArrayBuilder<TResult>(initialize: true);
				foreach (TSource item in _source)
				{
					if (_predicate(item))
					{
						largeArrayBuilder.Add(_selector(item));
					}
				}
				return largeArrayBuilder.ToArray();
			}

			public List<TResult> ToList()
			{
				List<TResult> list = new List<TResult>();
				foreach (TSource item in _source)
				{
					if (_predicate(item))
					{
						list.Add(_selector(item));
					}
				}
				return list;
			}
		}

		/// <summary>Applies an accumulator function over a sequence.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to aggregate over.</param>
		/// <param name="func">An accumulator function to be invoked on each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The final accumulator value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="func" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static TSource Aggregate<TSource>(this IEnumerable<TSource> source, Func<TSource, TSource, TSource> func)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (func == null)
			{
				throw Error.ArgumentNull("func");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			TSource val = enumerator.Current;
			while (enumerator.MoveNext())
			{
				val = func(val, enumerator.Current);
			}
			return val;
		}

		/// <summary>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to aggregate over.</param>
		/// <param name="seed">The initial accumulator value.</param>
		/// <param name="func">An accumulator function to be invoked on each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
		/// <returns>The final accumulator value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="func" /> is <see langword="null" />.</exception>
		public static TAccumulate Aggregate<TSource, TAccumulate>(this IEnumerable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (func == null)
			{
				throw Error.ArgumentNull("func");
			}
			TAccumulate val = seed;
			foreach (TSource item in source)
			{
				val = func(val, item);
			}
			return val;
		}

		/// <summary>Applies an accumulator function over a sequence. The specified seed value is used as the initial accumulator value, and the specified function is used to select the result value.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to aggregate over.</param>
		/// <param name="seed">The initial accumulator value.</param>
		/// <param name="func">An accumulator function to be invoked on each element.</param>
		/// <param name="resultSelector">A function to transform the final accumulator value into the result value.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TAccumulate">The type of the accumulator value.</typeparam>
		/// <typeparam name="TResult">The type of the resulting value.</typeparam>
		/// <returns>The transformed final accumulator value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="func" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static TResult Aggregate<TSource, TAccumulate, TResult>(this IEnumerable<TSource> source, TAccumulate seed, Func<TAccumulate, TSource, TAccumulate> func, Func<TAccumulate, TResult> resultSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (func == null)
			{
				throw Error.ArgumentNull("func");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			TAccumulate val = seed;
			foreach (TSource item in source)
			{
				val = func(val, item);
			}
			return resultSelector(val);
		}

		/// <summary>Determines whether a sequence contains any elements.</summary>
		/// <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to check for emptiness.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="true" /> if the source sequence contains any elements; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static bool Any<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			return enumerator.MoveNext();
		}

		/// <summary>Determines whether any element of a sequence satisfies a condition.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements to apply the predicate to.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="true" /> if any elements in the source sequence pass the test in the specified predicate; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static bool Any<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			foreach (TSource item in source)
			{
				if (predicate(item))
				{
					return true;
				}
			}
			return false;
		}

		/// <summary>Determines whether all elements of a sequence satisfy a condition.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the elements to apply the predicate to.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="true" /> if every element of the source sequence passes the test in the specified predicate, or if the sequence is empty; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static bool All<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			foreach (TSource item in source)
			{
				if (!predicate(item))
				{
					return false;
				}
			}
			return true;
		}

		/// <summary>Appends a value to the end of the sequence.</summary>
		/// <param name="source">A sequence of values. </param>
		/// <param name="element">The value to append to <paramref name="source" />.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />. </typeparam>
		/// <returns>A new sequence that ends with <paramref name="element" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="source" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Append<TSource>(this IEnumerable<TSource> source, TSource element)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (!(source is AppendPrependIterator<TSource> appendPrependIterator))
			{
				return new AppendPrepend1Iterator<TSource>(source, element, appending: true);
			}
			return appendPrependIterator.Append(element);
		}

		/// <summary>Adds a value to the beginning of the sequence.</summary>
		/// <param name="source">A sequence of values. </param>
		/// <param name="element">The value to prepend to <paramref name="source" />. </param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>A new sequence that begins with <paramref name="element" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///   <paramref name="source" /> is <see langword="null" />. </exception>
		public static IEnumerable<TSource> Prepend<TSource>(this IEnumerable<TSource> source, TSource element)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (!(source is AppendPrependIterator<TSource> appendPrependIterator))
			{
				return new AppendPrepend1Iterator<TSource>(source, element, appending: false);
			}
			return appendPrependIterator.Prepend(element);
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Int32" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Int32" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Average(this IEnumerable<int> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			checked
			{
				using IEnumerator<int> enumerator = source.GetEnumerator();
				if (!enumerator.MoveNext())
				{
					throw Error.NoElements();
				}
				long num = enumerator.Current;
				long num2 = 1L;
				while (enumerator.MoveNext())
				{
					num += enumerator.Current;
					num2++;
				}
				return (double)num / (double)num2;
			}
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Int32" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Int32" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only values that are <see langword="null" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum of the elements in the sequence is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static double? Average(this IEnumerable<int?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			checked
			{
				using (IEnumerator<int?> enumerator = source.GetEnumerator())
				{
					while (enumerator.MoveNext())
					{
						int? current = enumerator.Current;
						if (!current.HasValue)
						{
							continue;
						}
						long num = current.GetValueOrDefault();
						long num2 = 1L;
						while (enumerator.MoveNext())
						{
							current = enumerator.Current;
							if (current.HasValue)
							{
								num += current.GetValueOrDefault();
								num2++;
							}
						}
						return (double)num / (double)num2;
					}
				}
				return null;
			}
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Int64" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Int64" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Average(this IEnumerable<long> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			checked
			{
				using IEnumerator<long> enumerator = source.GetEnumerator();
				if (!enumerator.MoveNext())
				{
					throw Error.NoElements();
				}
				long num = enumerator.Current;
				long num2 = 1L;
				while (enumerator.MoveNext())
				{
					num += enumerator.Current;
					num2++;
				}
				return (double)num / (double)num2;
			}
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Int64" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Int64" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only values that are <see langword="null" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum of the elements in the sequence is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static double? Average(this IEnumerable<long?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			checked
			{
				using (IEnumerator<long?> enumerator = source.GetEnumerator())
				{
					while (enumerator.MoveNext())
					{
						long? current = enumerator.Current;
						if (!current.HasValue)
						{
							continue;
						}
						long num = current.GetValueOrDefault();
						long num2 = 1L;
						while (enumerator.MoveNext())
						{
							current = enumerator.Current;
							if (current.HasValue)
							{
								num += current.GetValueOrDefault();
								num2++;
							}
						}
						return (double)num / (double)num2;
					}
				}
				return null;
			}
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Single" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Single" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float Average(this IEnumerable<float> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using IEnumerator<float> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			double num = enumerator.Current;
			long num2 = 1L;
			while (enumerator.MoveNext())
			{
				num += (double)enumerator.Current;
				num2++;
			}
			return (float)(num / (double)num2);
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Single" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Single" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only values that are <see langword="null" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static float? Average(this IEnumerable<float?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using (IEnumerator<float?> enumerator = source.GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					float? current = enumerator.Current;
					if (!current.HasValue)
					{
						continue;
					}
					double num = current.GetValueOrDefault();
					long num2 = 1L;
					while (enumerator.MoveNext())
					{
						current = enumerator.Current;
						if (current.HasValue)
						{
							num += (double)current.GetValueOrDefault();
							num2 = checked(num2 + 1);
						}
					}
					return (float)(num / (double)num2);
				}
			}
			return null;
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Double" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Double" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Average(this IEnumerable<double> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using IEnumerator<double> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			double num = enumerator.Current;
			long num2 = 1L;
			while (enumerator.MoveNext())
			{
				num += enumerator.Current;
				num2++;
			}
			return num / (double)num2;
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Double" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Double" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only values that are <see langword="null" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static double? Average(this IEnumerable<double?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using (IEnumerator<double?> enumerator = source.GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					double? current = enumerator.Current;
					if (!current.HasValue)
					{
						continue;
					}
					double num = current.GetValueOrDefault();
					long num2 = 1L;
					while (enumerator.MoveNext())
					{
						current = enumerator.Current;
						if (current.HasValue)
						{
							num += current.GetValueOrDefault();
							num2 = checked(num2 + 1);
						}
					}
					return num / (double)num2;
				}
			}
			return null;
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Decimal" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Decimal" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static decimal Average(this IEnumerable<decimal> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using IEnumerator<decimal> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			decimal current = enumerator.Current;
			long num = 1L;
			while (enumerator.MoveNext())
			{
				current += enumerator.Current;
				num++;
			}
			return current / (decimal)num;
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Decimal" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Decimal" /> values to calculate the average of.</param>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only values that are <see langword="null" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum of the elements in the sequence is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
		public static decimal? Average(this IEnumerable<decimal?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using (IEnumerator<decimal?> enumerator = source.GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					decimal? current = enumerator.Current;
					if (!current.HasValue)
					{
						continue;
					}
					decimal valueOrDefault = current.GetValueOrDefault();
					long num = 1L;
					while (enumerator.MoveNext())
					{
						current = enumerator.Current;
						if (current.HasValue)
						{
							valueOrDefault += current.GetValueOrDefault();
							num++;
						}
					}
					return valueOrDefault / (decimal)num;
				}
			}
			return null;
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Int32" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		/// <exception cref="T:System.OverflowException">The sum of the elements in the sequence is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static double Average<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			checked
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				if (!enumerator.MoveNext())
				{
					throw Error.NoElements();
				}
				long num = selector(enumerator.Current);
				long num2 = 1L;
				while (enumerator.MoveNext())
				{
					num += selector(enumerator.Current);
					num2++;
				}
				return (double)num / (double)num2;
			}
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Int32" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only values that are <see langword="null" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum of the elements in the sequence is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static double? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, int?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			checked
			{
				using (IEnumerator<TSource> enumerator = source.GetEnumerator())
				{
					while (enumerator.MoveNext())
					{
						int? num = selector(enumerator.Current);
						if (!num.HasValue)
						{
							continue;
						}
						long num2 = num.GetValueOrDefault();
						long num3 = 1L;
						while (enumerator.MoveNext())
						{
							num = selector(enumerator.Current);
							if (num.HasValue)
							{
								num2 += num.GetValueOrDefault();
								num3++;
							}
						}
						return (double)num2 / (double)num3;
					}
				}
				return null;
			}
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Int64" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of source.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		/// <exception cref="T:System.OverflowException">The sum of the elements in the sequence is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static double Average<TSource>(this IEnumerable<TSource> source, Func<TSource, long> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			checked
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				if (!enumerator.MoveNext())
				{
					throw Error.NoElements();
				}
				long num = selector(enumerator.Current);
				long num2 = 1L;
				while (enumerator.MoveNext())
				{
					num += selector(enumerator.Current);
					num2++;
				}
				return (double)num / (double)num2;
			}
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Int64" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only values that are <see langword="null" />.</returns>
		public static double? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, long?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			checked
			{
				using (IEnumerator<TSource> enumerator = source.GetEnumerator())
				{
					while (enumerator.MoveNext())
					{
						long? num = selector(enumerator.Current);
						if (!num.HasValue)
						{
							continue;
						}
						long num2 = num.GetValueOrDefault();
						long num3 = 1L;
						while (enumerator.MoveNext())
						{
							num = selector(enumerator.Current);
							if (num.HasValue)
							{
								num2 += num.GetValueOrDefault();
								num3++;
							}
						}
						return (double)num2 / (double)num3;
					}
				}
				return null;
			}
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Single" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float Average<TSource>(this IEnumerable<TSource> source, Func<TSource, float> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			double num = selector(enumerator.Current);
			long num2 = 1L;
			while (enumerator.MoveNext())
			{
				num += (double)selector(enumerator.Current);
				num2++;
			}
			return (float)(num / (double)num2);
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Single" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only values that are <see langword="null" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static float? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, float?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using (IEnumerator<TSource> enumerator = source.GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					float? num = selector(enumerator.Current);
					if (!num.HasValue)
					{
						continue;
					}
					double num2 = num.GetValueOrDefault();
					long num3 = 1L;
					while (enumerator.MoveNext())
					{
						num = selector(enumerator.Current);
						if (num.HasValue)
						{
							num2 += (double)num.GetValueOrDefault();
							num3 = checked(num3 + 1);
						}
					}
					return (float)(num2 / (double)num3);
				}
			}
			return null;
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Double" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Average<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			double num = selector(enumerator.Current);
			long num2 = 1L;
			while (enumerator.MoveNext())
			{
				num += selector(enumerator.Current);
				num2++;
			}
			return num / (double)num2;
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Double" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only values that are <see langword="null" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static double? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, double?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using (IEnumerator<TSource> enumerator = source.GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					double? num = selector(enumerator.Current);
					if (!num.HasValue)
					{
						continue;
					}
					double num2 = num.GetValueOrDefault();
					long num3 = 1L;
					while (enumerator.MoveNext())
					{
						num = selector(enumerator.Current);
						if (num.HasValue)
						{
							num2 += num.GetValueOrDefault();
							num3 = checked(num3 + 1);
						}
					}
					return num2 / (double)num3;
				}
			}
			return null;
		}

		/// <summary>Computes the average of a sequence of <see cref="T:System.Decimal" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate an average.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		/// <exception cref="T:System.OverflowException">The sum of the elements in the sequence is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
		public static decimal Average<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			decimal num = selector(enumerator.Current);
			long num2 = 1L;
			while (enumerator.MoveNext())
			{
				num += selector(enumerator.Current);
				num2++;
			}
			return num / (decimal)num2;
		}

		/// <summary>Computes the average of a sequence of nullable <see cref="T:System.Decimal" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values to calculate the average of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The average of the sequence of values, or <see langword="null" /> if the source sequence is empty or contains only values that are <see langword="null" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum of the elements in the sequence is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
		public static decimal? Average<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using (IEnumerator<TSource> enumerator = source.GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					decimal? num = selector(enumerator.Current);
					if (!num.HasValue)
					{
						continue;
					}
					decimal valueOrDefault = num.GetValueOrDefault();
					long num2 = 1L;
					while (enumerator.MoveNext())
					{
						num = selector(enumerator.Current);
						if (num.HasValue)
						{
							valueOrDefault += num.GetValueOrDefault();
							num2++;
						}
					}
					return valueOrDefault / (decimal)num2;
				}
			}
			return null;
		}

		/// <summary>Filters the elements of an <see cref="T:System.Collections.IEnumerable" /> based on a specified type.</summary>
		/// <param name="source">The <see cref="T:System.Collections.IEnumerable" /> whose elements to filter.</param>
		/// <typeparam name="TResult">The type to filter the elements of the sequence on.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from the input sequence of type <paramref name="TResult" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IEnumerable<TResult> OfType<TResult>(this IEnumerable source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return OfTypeIterator<TResult>(source);
		}

		private static IEnumerable<TResult> OfTypeIterator<TResult>(IEnumerable source)
		{
			foreach (object item in source)
			{
				if (item is TResult)
				{
					yield return (TResult)item;
				}
			}
		}

		/// <summary>Casts the elements of an <see cref="T:System.Collections.IEnumerable" /> to the specified type.</summary>
		/// <param name="source">The <see cref="T:System.Collections.IEnumerable" /> that contains the elements to be cast to type <paramref name="TResult" />.</param>
		/// <typeparam name="TResult">The type to cast the elements of <paramref name="source" /> to.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains each element of the source sequence cast to the specified type.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidCastException">An element in the sequence cannot be cast to type <paramref name="TResult" />.</exception>
		public static IEnumerable<TResult> Cast<TResult>(this IEnumerable source)
		{
			if (source is IEnumerable<TResult> result)
			{
				return result;
			}
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return CastIterator<TResult>(source);
		}

		private static IEnumerable<TResult> CastIterator<TResult>(IEnumerable source)
		{
			foreach (object item in source)
			{
				yield return (TResult)item;
			}
		}

		/// <summary>Concatenates two sequences.</summary>
		/// <param name="first">The first sequence to concatenate.</param>
		/// <param name="second">The sequence to concatenate to the first sequence.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the concatenated elements of the two input sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Concat<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			if (!(first is ConcatIterator<TSource> concatIterator))
			{
				return new Concat2Iterator<TSource>(first, second);
			}
			return concatIterator.Concat(second);
		}

		/// <summary>Determines whether a sequence contains a specified element by using the default equality comparer.</summary>
		/// <param name="source">A sequence in which to locate a value.</param>
		/// <param name="value">The value to locate in the sequence.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="true" /> if the source sequence contains an element that has the specified value; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static bool Contains<TSource>(this IEnumerable<TSource> source, TSource value)
		{
			if (!(source is ICollection<TSource> collection))
			{
				return source.Contains(value, null);
			}
			return collection.Contains(value);
		}

		/// <summary>Determines whether a sequence contains a specified element by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
		/// <param name="source">A sequence in which to locate a value.</param>
		/// <param name="value">The value to locate in the sequence.</param>
		/// <param name="comparer">An equality comparer to compare values.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="true" /> if the source sequence contains an element that has the specified value; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static bool Contains<TSource>(this IEnumerable<TSource> source, TSource value, IEqualityComparer<TSource> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (comparer == null)
			{
				foreach (TSource item in source)
				{
					if (EqualityComparer<TSource>.Default.Equals(item, value))
					{
						return true;
					}
				}
			}
			else
			{
				foreach (TSource item2 in source)
				{
					if (comparer.Equals(item2, value))
					{
						return true;
					}
				}
			}
			return false;
		}

		/// <summary>Returns the number of elements in a sequence.</summary>
		/// <param name="source">A sequence that contains elements to be counted.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The number of elements in the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The number of elements in <paramref name="source" /> is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
		public static int Count<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is ICollection<TSource> collection)
			{
				return collection.Count;
			}
			if (source is IIListProvider<TSource> iIListProvider)
			{
				return iIListProvider.GetCount(onlyIfCheap: false);
			}
			if (source is ICollection collection2)
			{
				return collection2.Count;
			}
			int num = 0;
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				num = checked(num + 1);
			}
			return num;
		}

		/// <summary>Returns a number that represents how many elements in the specified sequence satisfy a condition.</summary>
		/// <param name="source">A sequence that contains elements to be tested and counted.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>A number that represents how many elements in the sequence satisfy the condition in the predicate function.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The number of elements in <paramref name="source" /> is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
		public static int Count<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			int num = 0;
			foreach (TSource item in source)
			{
				if (predicate(item))
				{
					num = checked(num + 1);
				}
			}
			return num;
		}

		/// <summary>Returns an <see cref="T:System.Int64" /> that represents the total number of elements in a sequence.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the elements to be counted.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The number of elements in the source sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The number of elements exceeds <see cref="F:System.Int64.MaxValue" />.</exception>
		public static long LongCount<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long num = 0L;
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				num = checked(num + 1);
			}
			return num;
		}

		/// <summary>Returns an <see cref="T:System.Int64" /> that represents how many elements in a sequence satisfy a condition.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the elements to be counted.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>A number that represents how many elements in the sequence satisfy the condition in the predicate function.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The number of matching elements exceeds <see cref="F:System.Int64.MaxValue" />.</exception>
		public static long LongCount<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			long num = 0L;
			foreach (TSource item in source)
			{
				if (predicate(item))
				{
					num = checked(num + 1);
				}
			}
			return num;
		}

		/// <summary>Returns the elements of the specified sequence or the type parameter's default value in a singleton collection if the sequence is empty.</summary>
		/// <param name="source">The sequence to return a default value for if it is empty.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> object that contains the default value for the <paramref name="TSource" /> type if <paramref name="source" /> is empty; otherwise, <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> DefaultIfEmpty<TSource>(this IEnumerable<TSource> source)
		{
			return source.DefaultIfEmpty(default(TSource));
		}

		/// <summary>Returns the elements of the specified sequence or the specified value in a singleton collection if the sequence is empty.</summary>
		/// <param name="source">The sequence to return the specified value for if it is empty.</param>
		/// <param name="defaultValue">The value to return if the sequence is empty.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <paramref name="defaultValue" /> if <paramref name="source" /> is empty; otherwise, <paramref name="source" />.</returns>
		public static IEnumerable<TSource> DefaultIfEmpty<TSource>(this IEnumerable<TSource> source, TSource defaultValue)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return new DefaultIfEmptyIterator<TSource>(source, defaultValue);
		}

		/// <summary>Returns distinct elements from a sequence by using the default equality comparer to compare values.</summary>
		/// <param name="source">The sequence to remove duplicate elements from.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains distinct elements from the source sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Distinct<TSource>(this IEnumerable<TSource> source)
		{
			return source.Distinct(null);
		}

		/// <summary>Returns distinct elements from a sequence by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</summary>
		/// <param name="source">The sequence to remove duplicate elements from.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains distinct elements from the source sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Distinct<TSource>(this IEnumerable<TSource> source, IEqualityComparer<TSource> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return new DistinctIterator<TSource>(source, comparer);
		}

		/// <summary>Returns the element at a specified index in a sequence.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return an element from.</param>
		/// <param name="index">The zero-based index of the element to retrieve.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The element at the specified position in the source sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="index" /> is less than 0 or greater than or equal to the number of elements in <paramref name="source" />.</exception>
		public static TSource ElementAt<TSource>(this IEnumerable<TSource> source, int index)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IPartition<TSource> partition)
			{
				bool found;
				TSource result = partition.TryGetElementAt(index, out found);
				if (found)
				{
					return result;
				}
			}
			else
			{
				if (source is IList<TSource> list)
				{
					return list[index];
				}
				if (index >= 0)
				{
					using IEnumerator<TSource> enumerator = source.GetEnumerator();
					while (enumerator.MoveNext())
					{
						if (index == 0)
						{
							return enumerator.Current;
						}
						index--;
					}
				}
			}
			throw Error.ArgumentOutOfRange("index");
		}

		/// <summary>Returns the element at a specified index in a sequence or a default value if the index is out of range.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return an element from.</param>
		/// <param name="index">The zero-based index of the element to retrieve.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="default" />(<paramref name="TSource" />) if the index is outside the bounds of the source sequence; otherwise, the element at the specified position in the source sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static TSource ElementAtOrDefault<TSource>(this IEnumerable<TSource> source, int index)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IPartition<TSource> partition)
			{
				bool found;
				return partition.TryGetElementAt(index, out found);
			}
			if (index >= 0)
			{
				if (source is IList<TSource> list)
				{
					if (index < list.Count)
					{
						return list[index];
					}
				}
				else
				{
					using IEnumerator<TSource> enumerator = source.GetEnumerator();
					while (enumerator.MoveNext())
					{
						if (index == 0)
						{
							return enumerator.Current;
						}
						index--;
					}
				}
			}
			return default(TSource);
		}

		/// <summary>Returns the input typed as <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
		/// <param name="source">The sequence to type as <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The input sequence typed as <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
		public static IEnumerable<TSource> AsEnumerable<TSource>(this IEnumerable<TSource> source)
		{
			return source;
		}

		/// <summary>Returns an empty <see cref="T:System.Collections.Generic.IEnumerable`1" /> that has the specified type argument.</summary>
		/// <typeparam name="TResult">The type to assign to the type parameter of the returned generic <see cref="T:System.Collections.Generic.IEnumerable`1" />.</typeparam>
		/// <returns>An empty <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose type argument is <paramref name="TResult" />.</returns>
		public static IEnumerable<TResult> Empty<TResult>()
		{
			return Array.Empty<TResult>();
		}

		/// <summary>Produces the set difference of two sequences by using the default equality comparer to compare values.</summary>
		/// <param name="first">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements that are not also in <paramref name="second" /> will be returned.</param>
		/// <param name="second">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements that also occur in the first sequence will cause those elements to be removed from the returned sequence.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			return ExceptIterator(first, second, null);
		}

		/// <summary>Produces the set difference of two sequences by using the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</summary>
		/// <param name="first">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements that are not also in <paramref name="second" /> will be returned.</param>
		/// <param name="second">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements that also occur in the first sequence will cause those elements to be removed from the returned sequence.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>A sequence that contains the set difference of the elements of two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Except<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			return ExceptIterator(first, second, comparer);
		}

		private static IEnumerable<TSource> ExceptIterator<TSource>(IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			Set<TSource> set = new Set<TSource>(comparer);
			foreach (TSource item in second)
			{
				set.Add(item);
			}
			foreach (TSource item2 in first)
			{
				if (set.Add(item2))
				{
					yield return item2;
				}
			}
		}

		/// <summary>Returns the first element of a sequence.</summary>
		/// <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return the first element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The first element in the specified sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The source sequence is empty.</exception>
		public static TSource First<TSource>(this IEnumerable<TSource> source)
		{
			bool found;
			TSource result = source.TryGetFirst(out found);
			if (!found)
			{
				throw Error.NoElements();
			}
			return result;
		}

		/// <summary>Returns the first element in a sequence that satisfies a specified condition.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return an element from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The first element in the sequence that passes the test in the specified predicate function.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">No element satisfies the condition in <paramref name="predicate" />.-or-The source sequence is empty.</exception>
		public static TSource First<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			bool found;
			TSource result = source.TryGetFirst(predicate, out found);
			if (!found)
			{
				throw Error.NoMatch();
			}
			return result;
		}

		/// <summary>Returns the first element of a sequence, or a default value if the sequence contains no elements.</summary>
		/// <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return the first element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="default" />(<paramref name="TSource" />) if <paramref name="source" /> is empty; otherwise, the first element in <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static TSource FirstOrDefault<TSource>(this IEnumerable<TSource> source)
		{
			bool found;
			return source.TryGetFirst(out found);
		}

		/// <summary>Returns the first element of the sequence that satisfies a condition or a default value if no such element is found.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return an element from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="default" />(<paramref name="TSource" />) if <paramref name="source" /> is empty or if no element passes the test specified by <paramref name="predicate" />; otherwise, the first element in <paramref name="source" /> that passes the test specified by <paramref name="predicate" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static TSource FirstOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			bool found;
			return source.TryGetFirst(predicate, out found);
		}

		private static TSource TryGetFirst<TSource>(this IEnumerable<TSource> source, out bool found)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IPartition<TSource> partition)
			{
				return partition.TryGetFirst(out found);
			}
			if (source is IList<TSource> list)
			{
				if (list.Count > 0)
				{
					found = true;
					return list[0];
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				if (enumerator.MoveNext())
				{
					found = true;
					return enumerator.Current;
				}
			}
			found = false;
			return default(TSource);
		}

		private static TSource TryGetFirst<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate, out bool found)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			if (source is OrderedEnumerable<TSource> orderedEnumerable)
			{
				return orderedEnumerable.TryGetFirst(predicate, out found);
			}
			foreach (TSource item in source)
			{
				if (predicate(item))
				{
					found = true;
					return item;
				}
			}
			found = false;
			return default(TSource);
		}

		/// <summary>Correlates the elements of two sequences based on equality of keys and groups the results. The default equality comparer is used to compare keys.</summary>
		/// <param name="outer">The first sequence to join.</param>
		/// <param name="inner">The sequence to join to the first sequence.</param>
		/// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
		/// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
		/// <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
		/// <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
		/// <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
		/// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
		/// <typeparam name="TResult">The type of the result elements.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements of type <paramref name="TResult" /> that are obtained by performing a grouped join on two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return GroupJoinIterator(outer, inner, outerKeySelector, innerKeySelector, resultSelector, null);
		}

		/// <summary>Correlates the elements of two sequences based on key equality and groups the results. A specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> is used to compare keys.</summary>
		/// <param name="outer">The first sequence to join.</param>
		/// <param name="inner">The sequence to join to the first sequence.</param>
		/// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
		/// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
		/// <param name="resultSelector">A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to hash and compare keys.</param>
		/// <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
		/// <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
		/// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
		/// <typeparam name="TResult">The type of the result elements.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements of type <paramref name="TResult" /> that are obtained by performing a grouped join on two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static IEnumerable<TResult> GroupJoin<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return GroupJoinIterator(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
		}

		private static IEnumerable<TResult> GroupJoinIterator<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, IEnumerable<TInner>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			using IEnumerator<TOuter> e = outer.GetEnumerator();
			if (e.MoveNext())
			{
				Lookup<TKey, TInner> lookup = Lookup<TKey, TInner>.CreateForJoin(inner, innerKeySelector, comparer);
				do
				{
					TOuter current = e.Current;
					yield return resultSelector(current, lookup[outerKeySelector(current)]);
				}
				while (e.MoveNext());
			}
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; in C# or IEnumerable(Of IGrouping(Of TKey, TSource)) in Visual Basic where each <see cref="T:System.Linq.IGrouping`2" /> object contains a sequence of objects and a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IEnumerable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return new GroupedEnumerable<TSource, TKey>(source, keySelector, null);
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function and compares the keys by using a specified comparer.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An IEnumerable&lt;IGrouping&lt;TKey, TSource&gt;&gt; in C# or IEnumerable(Of IGrouping(Of TKey, TSource)) in Visual Basic where each <see cref="T:System.Linq.IGrouping`2" /> object contains a collection of objects and a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IEnumerable<IGrouping<TKey, TSource>> GroupBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			return new GroupedEnumerable<TSource, TKey>(source, keySelector, comparer);
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function and projects the elements for each group by using a specified function.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="elementSelector">A function to map each source element to an element in the <see cref="T:System.Linq.IGrouping`2" />.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
		/// <returns>An IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; in C# or IEnumerable(Of IGrouping(Of TKey, TElement)) in Visual Basic where each <see cref="T:System.Linq.IGrouping`2" /> object contains a collection of objects of type <paramref name="TElement" /> and a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is <see langword="null" />.</exception>
		public static IEnumerable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)
		{
			return new GroupedEnumerable<TSource, TKey, TElement>(source, keySelector, elementSelector, null);
		}

		/// <summary>Groups the elements of a sequence according to a key selector function. The keys are compared by using a comparer and each group's elements are projected by using a specified function.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="elementSelector">A function to map each source element to an element in an <see cref="T:System.Linq.IGrouping`2" />.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the elements in the <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
		/// <returns>An IEnumerable&lt;IGrouping&lt;TKey, TElement&gt;&gt; in C# or IEnumerable(Of IGrouping(Of TKey, TElement)) in Visual Basic where each <see cref="T:System.Linq.IGrouping`2" /> object contains a collection of objects of type <paramref name="TElement" /> and a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is <see langword="null" />.</exception>
		public static IEnumerable<IGrouping<TKey, TElement>> GroupBy<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			return new GroupedEnumerable<TSource, TKey, TElement>(source, keySelector, elementSelector, comparer);
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="resultSelector">A function to create a result value from each group.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
		/// <returns>A collection of elements of type <paramref name="TResult" /> where each element represents a projection over a group and its key.</returns>
		public static IEnumerable<TResult> GroupBy<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector)
		{
			return new GroupedResultEnumerable<TSource, TKey, TResult>(source, keySelector, resultSelector, null);
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. The elements of each group are projected by using a specified function.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="elementSelector">A function to map each source element to an element in an <see cref="T:System.Linq.IGrouping`2" />.</param>
		/// <param name="resultSelector">A function to create a result value from each group.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the elements in each <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
		/// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
		/// <returns>A collection of elements of type <paramref name="TResult" /> where each element represents a projection over a group and its key.</returns>
		public static IEnumerable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector)
		{
			return new GroupedResultEnumerable<TSource, TKey, TElement, TResult>(source, keySelector, elementSelector, resultSelector, null);
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. The keys are compared by using a specified comparer.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="resultSelector">A function to create a result value from each group.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys with.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
		/// <returns>A collection of elements of type <paramref name="TResult" /> where each element represents a projection over a group and its key.</returns>
		public static IEnumerable<TResult> GroupBy<TSource, TKey, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			return new GroupedResultEnumerable<TSource, TKey, TResult>(source, keySelector, resultSelector, comparer);
		}

		/// <summary>Groups the elements of a sequence according to a specified key selector function and creates a result value from each group and its key. Key values are compared by using a specified comparer, and the elements of each group are projected by using a specified function.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements to group.</param>
		/// <param name="keySelector">A function to extract the key for each element.</param>
		/// <param name="elementSelector">A function to map each source element to an element in an <see cref="T:System.Linq.IGrouping`2" />.</param>
		/// <param name="resultSelector">A function to create a result value from each group.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys with.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the elements in each <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
		/// <typeparam name="TResult">The type of the result value returned by <paramref name="resultSelector" />.</typeparam>
		/// <returns>A collection of elements of type <paramref name="TResult" /> where each element represents a projection over a group and its key.</returns>
		public static IEnumerable<TResult> GroupBy<TSource, TKey, TElement, TResult>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			return new GroupedResultEnumerable<TSource, TKey, TElement, TResult>(source, keySelector, elementSelector, resultSelector, comparer);
		}

		/// <summary>Produces the set intersection of two sequences by using the default equality comparer to compare values.</summary>
		/// <param name="first">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose distinct elements that also appear in <paramref name="second" /> will be returned.</param>
		/// <param name="second">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose distinct elements that also appear in the first sequence will be returned.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>A sequence that contains the elements that form the set intersection of two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Intersect<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			return IntersectIterator(first, second, null);
		}

		/// <summary>Produces the set intersection of two sequences by using the specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</summary>
		/// <param name="first">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose distinct elements that also appear in <paramref name="second" /> will be returned.</param>
		/// <param name="second">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose distinct elements that also appear in the first sequence will be returned.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>A sequence that contains the elements that form the set intersection of two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Intersect<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			return IntersectIterator(first, second, comparer);
		}

		private static IEnumerable<TSource> IntersectIterator<TSource>(IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			Set<TSource> set = new Set<TSource>(comparer);
			foreach (TSource item in second)
			{
				set.Add(item);
			}
			foreach (TSource item2 in first)
			{
				if (set.Remove(item2))
				{
					yield return item2;
				}
			}
		}

		/// <summary>Correlates the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.</summary>
		/// <param name="outer">The first sequence to join.</param>
		/// <param name="inner">The sequence to join to the first sequence.</param>
		/// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
		/// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
		/// <param name="resultSelector">A function to create a result element from two matching elements.</param>
		/// <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
		/// <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
		/// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
		/// <typeparam name="TResult">The type of the result elements.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that has elements of type <paramref name="TResult" /> that are obtained by performing an inner join on two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return JoinIterator(outer, inner, outerKeySelector, innerKeySelector, resultSelector, null);
		}

		/// <summary>Correlates the elements of two sequences based on matching keys. A specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> is used to compare keys.</summary>
		/// <param name="outer">The first sequence to join.</param>
		/// <param name="inner">The sequence to join to the first sequence.</param>
		/// <param name="outerKeySelector">A function to extract the join key from each element of the first sequence.</param>
		/// <param name="innerKeySelector">A function to extract the join key from each element of the second sequence.</param>
		/// <param name="resultSelector">A function to create a result element from two matching elements.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to hash and compare keys.</param>
		/// <typeparam name="TOuter">The type of the elements of the first sequence.</typeparam>
		/// <typeparam name="TInner">The type of the elements of the second sequence.</typeparam>
		/// <typeparam name="TKey">The type of the keys returned by the key selector functions.</typeparam>
		/// <typeparam name="TResult">The type of the result elements.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that has elements of type <paramref name="TResult" /> that are obtained by performing an inner join on two sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="outer" /> or <paramref name="inner" /> or <paramref name="outerKeySelector" /> or <paramref name="innerKeySelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static IEnumerable<TResult> Join<TOuter, TInner, TKey, TResult>(this IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			if (outer == null)
			{
				throw Error.ArgumentNull("outer");
			}
			if (inner == null)
			{
				throw Error.ArgumentNull("inner");
			}
			if (outerKeySelector == null)
			{
				throw Error.ArgumentNull("outerKeySelector");
			}
			if (innerKeySelector == null)
			{
				throw Error.ArgumentNull("innerKeySelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return JoinIterator(outer, inner, outerKeySelector, innerKeySelector, resultSelector, comparer);
		}

		private static IEnumerable<TResult> JoinIterator<TOuter, TInner, TKey, TResult>(IEnumerable<TOuter> outer, IEnumerable<TInner> inner, Func<TOuter, TKey> outerKeySelector, Func<TInner, TKey> innerKeySelector, Func<TOuter, TInner, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			using IEnumerator<TOuter> e = outer.GetEnumerator();
			if (!e.MoveNext())
			{
				yield break;
			}
			Lookup<TKey, TInner> lookup = Lookup<TKey, TInner>.CreateForJoin(inner, innerKeySelector, comparer);
			if (lookup.Count == 0)
			{
				yield break;
			}
			do
			{
				TOuter item = e.Current;
				Grouping<TKey, TInner> grouping = lookup.GetGrouping(outerKeySelector(item), create: false);
				if (grouping != null)
				{
					int count = grouping._count;
					TInner[] elements = grouping._elements;
					int i = 0;
					while (i != count)
					{
						yield return resultSelector(item, elements[i]);
						int num = i + 1;
						i = num;
					}
				}
			}
			while (e.MoveNext());
		}

		/// <summary>Returns the last element of a sequence.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return the last element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The value at the last position in the source sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The source sequence is empty.</exception>
		public static TSource Last<TSource>(this IEnumerable<TSource> source)
		{
			bool found;
			TSource result = source.TryGetLast(out found);
			if (!found)
			{
				throw Error.NoElements();
			}
			return result;
		}

		/// <summary>Returns the last element of a sequence that satisfies a specified condition.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return an element from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The last element in the sequence that passes the test in the specified predicate function.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">No element satisfies the condition in <paramref name="predicate" />.-or-The source sequence is empty.</exception>
		public static TSource Last<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			bool found;
			TSource result = source.TryGetLast(predicate, out found);
			if (!found)
			{
				throw Error.NoMatch();
			}
			return result;
		}

		/// <summary>Returns the last element of a sequence, or a default value if the sequence contains no elements.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return the last element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="default" />(<paramref name="TSource" />) if the source sequence is empty; otherwise, the last element in the <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static TSource LastOrDefault<TSource>(this IEnumerable<TSource> source)
		{
			bool found;
			return source.TryGetLast(out found);
		}

		/// <summary>Returns the last element of a sequence that satisfies a condition or a default value if no such element is found.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return an element from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>
		///     <see langword="default" />(<paramref name="TSource" />) if the sequence is empty or if no elements pass the test in the predicate function; otherwise, the last element that passes the test in the predicate function.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static TSource LastOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			bool found;
			return source.TryGetLast(predicate, out found);
		}

		private static TSource TryGetLast<TSource>(this IEnumerable<TSource> source, out bool found)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IPartition<TSource> partition)
			{
				return partition.TryGetLast(out found);
			}
			if (source is IList<TSource> { Count: var count } list)
			{
				if (count > 0)
				{
					found = true;
					return list[count - 1];
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				if (enumerator.MoveNext())
				{
					TSource current;
					do
					{
						current = enumerator.Current;
					}
					while (enumerator.MoveNext());
					found = true;
					return current;
				}
			}
			found = false;
			return default(TSource);
		}

		private static TSource TryGetLast<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate, out bool found)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			if (source is OrderedEnumerable<TSource> orderedEnumerable)
			{
				return orderedEnumerable.TryGetLast(predicate, out found);
			}
			if (source is IList<TSource> list)
			{
				for (int num = list.Count - 1; num >= 0; num--)
				{
					TSource val = list[num];
					if (predicate(val))
					{
						found = true;
						return val;
					}
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				while (enumerator.MoveNext())
				{
					TSource val2 = enumerator.Current;
					if (!predicate(val2))
					{
						continue;
					}
					while (enumerator.MoveNext())
					{
						TSource current = enumerator.Current;
						if (predicate(current))
						{
							val2 = current;
						}
					}
					found = true;
					return val2;
				}
			}
			found = false;
			return default(TSource);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Lookup`2" /> from an <see cref="T:System.Collections.Generic.IEnumerable`1" /> according to a specified key selector function.</summary>
		/// <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to create a <see cref="T:System.Linq.Lookup`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Linq.Lookup`2" /> that contains keys and values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return source.ToLookup(keySelector, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Lookup`2" /> from an <see cref="T:System.Collections.Generic.IEnumerable`1" /> according to a specified key selector function and key comparer.</summary>
		/// <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to create a <see cref="T:System.Linq.Lookup`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Linq.Lookup`2" /> that contains keys and values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static ILookup<TKey, TSource> ToLookup<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			return Lookup<TKey, TSource>.Create(source, keySelector, comparer);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Lookup`2" /> from an <see cref="T:System.Collections.Generic.IEnumerable`1" /> according to specified key selector and element selector functions.</summary>
		/// <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to create a <see cref="T:System.Linq.Lookup`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="elementSelector">A transform function to produce a result element value from each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Linq.Lookup`2" /> that contains values of type <paramref name="TElement" /> selected from the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is <see langword="null" />.</exception>
		public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)
		{
			return source.ToLookup(keySelector, elementSelector, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Lookup`2" /> from an <see cref="T:System.Collections.Generic.IEnumerable`1" /> according to a specified key selector function, a comparer and an element selector function.</summary>
		/// <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to create a <see cref="T:System.Linq.Lookup`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="elementSelector">A transform function to produce a result element value from each element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Linq.Lookup`2" /> that contains values of type <paramref name="TElement" /> selected from the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is <see langword="null" />.</exception>
		public static ILookup<TKey, TElement> ToLookup<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (elementSelector == null)
			{
				throw Error.ArgumentNull("elementSelector");
			}
			return Lookup<TKey, TElement>.Create(source, keySelector, elementSelector, comparer);
		}

		/// <summary>Returns the maximum value in a sequence of <see cref="T:System.Int32" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Int32" /> values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static int Max(this IEnumerable<int> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using IEnumerator<int> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			int num = enumerator.Current;
			while (enumerator.MoveNext())
			{
				int current = enumerator.Current;
				if (current > num)
				{
					num = current;
				}
			}
			return num;
		}

		/// <summary>Returns the maximum value in a sequence of nullable <see cref="T:System.Int32" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Int32" /> values to determine the maximum value of.</param>
		/// <returns>A value of type Nullable&lt;Int32&gt; in C# or Nullable(Of Int32) in Visual Basic that corresponds to the maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static int? Max(this IEnumerable<int?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			int? result = null;
			using (IEnumerator<int?> enumerator = source.GetEnumerator())
			{
				do
				{
					if (!enumerator.MoveNext())
					{
						return result;
					}
					result = enumerator.Current;
				}
				while (!result.HasValue);
				int num = result.GetValueOrDefault();
				if (num >= 0)
				{
					while (enumerator.MoveNext())
					{
						int? current = enumerator.Current;
						int valueOrDefault = current.GetValueOrDefault();
						if (valueOrDefault > num)
						{
							num = valueOrDefault;
							result = current;
						}
					}
				}
				else
				{
					while (enumerator.MoveNext())
					{
						int? current2 = enumerator.Current;
						int valueOrDefault2 = current2.GetValueOrDefault();
						if (current2.HasValue && valueOrDefault2 > num)
						{
							num = valueOrDefault2;
							result = current2;
						}
					}
				}
			}
			return result;
		}

		/// <summary>Returns the maximum value in a sequence of <see cref="T:System.Int64" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Int64" /> values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static long Max(this IEnumerable<long> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using IEnumerator<long> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			long num = enumerator.Current;
			while (enumerator.MoveNext())
			{
				long current = enumerator.Current;
				if (current > num)
				{
					num = current;
				}
			}
			return num;
		}

		/// <summary>Returns the maximum value in a sequence of nullable <see cref="T:System.Int64" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Int64" /> values to determine the maximum value of.</param>
		/// <returns>A value of type Nullable&lt;Int64&gt; in C# or Nullable(Of Int64) in Visual Basic that corresponds to the maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static long? Max(this IEnumerable<long?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long? result = null;
			using (IEnumerator<long?> enumerator = source.GetEnumerator())
			{
				do
				{
					if (!enumerator.MoveNext())
					{
						return result;
					}
					result = enumerator.Current;
				}
				while (!result.HasValue);
				long num = result.GetValueOrDefault();
				if (num >= 0)
				{
					while (enumerator.MoveNext())
					{
						long? current = enumerator.Current;
						long valueOrDefault = current.GetValueOrDefault();
						if (valueOrDefault > num)
						{
							num = valueOrDefault;
							result = current;
						}
					}
				}
				else
				{
					while (enumerator.MoveNext())
					{
						long? current2 = enumerator.Current;
						long valueOrDefault2 = current2.GetValueOrDefault();
						if (current2.HasValue && valueOrDefault2 > num)
						{
							num = valueOrDefault2;
							result = current2;
						}
					}
				}
			}
			return result;
		}

		/// <summary>Returns the maximum value in a sequence of <see cref="T:System.Double" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Double" /> values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Max(this IEnumerable<double> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using IEnumerator<double> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			double num = enumerator.Current;
			while (double.IsNaN(num))
			{
				if (!enumerator.MoveNext())
				{
					return num;
				}
				num = enumerator.Current;
			}
			while (enumerator.MoveNext())
			{
				double current = enumerator.Current;
				if (current > num)
				{
					num = current;
				}
			}
			return num;
		}

		/// <summary>Returns the maximum value in a sequence of nullable <see cref="T:System.Double" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Double" /> values to determine the maximum value of.</param>
		/// <returns>A value of type Nullable&lt;Double&gt; in C# or Nullable(Of Double) in Visual Basic that corresponds to the maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static double? Max(this IEnumerable<double?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double? result = null;
			using IEnumerator<double?> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = enumerator.Current;
				if (!result.HasValue)
				{
					continue;
				}
				double num = result.GetValueOrDefault();
				while (double.IsNaN(num))
				{
					if (!enumerator.MoveNext())
					{
						return result;
					}
					double? current = enumerator.Current;
					if (current.HasValue)
					{
						double? num2 = (result = current);
						num = num2.GetValueOrDefault();
					}
				}
				while (enumerator.MoveNext())
				{
					double? current2 = enumerator.Current;
					double valueOrDefault = current2.GetValueOrDefault();
					if (current2.HasValue && valueOrDefault > num)
					{
						num = valueOrDefault;
						result = current2;
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Returns the maximum value in a sequence of <see cref="T:System.Single" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Single" /> values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float Max(this IEnumerable<float> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using IEnumerator<float> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			float num = enumerator.Current;
			while (float.IsNaN(num))
			{
				if (!enumerator.MoveNext())
				{
					return num;
				}
				num = enumerator.Current;
			}
			while (enumerator.MoveNext())
			{
				float current = enumerator.Current;
				if (current > num)
				{
					num = current;
				}
			}
			return num;
		}

		/// <summary>Returns the maximum value in a sequence of nullable <see cref="T:System.Single" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Single" /> values to determine the maximum value of.</param>
		/// <returns>A value of type Nullable&lt;Single&gt; in C# or Nullable(Of Single) in Visual Basic that corresponds to the maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static float? Max(this IEnumerable<float?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			float? result = null;
			using IEnumerator<float?> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = enumerator.Current;
				if (!result.HasValue)
				{
					continue;
				}
				float num = result.GetValueOrDefault();
				while (float.IsNaN(num))
				{
					if (!enumerator.MoveNext())
					{
						return result;
					}
					float? current = enumerator.Current;
					if (current.HasValue)
					{
						float? num2 = (result = current);
						num = num2.GetValueOrDefault();
					}
				}
				while (enumerator.MoveNext())
				{
					float? current2 = enumerator.Current;
					float valueOrDefault = current2.GetValueOrDefault();
					if (current2.HasValue && valueOrDefault > num)
					{
						num = valueOrDefault;
						result = current2;
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Returns the maximum value in a sequence of <see cref="T:System.Decimal" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Decimal" /> values to determine the maximum value of.</param>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static decimal Max(this IEnumerable<decimal> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using IEnumerator<decimal> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			decimal num = enumerator.Current;
			while (enumerator.MoveNext())
			{
				decimal current = enumerator.Current;
				if (current > num)
				{
					num = current;
				}
			}
			return num;
		}

		/// <summary>Returns the maximum value in a sequence of nullable <see cref="T:System.Decimal" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Decimal" /> values to determine the maximum value of.</param>
		/// <returns>A value of type Nullable&lt;Decimal&gt; in C# or Nullable(Of Decimal) in Visual Basic that corresponds to the maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static decimal? Max(this IEnumerable<decimal?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			decimal? result = null;
			using IEnumerator<decimal?> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = enumerator.Current;
				if (!result.HasValue)
				{
					continue;
				}
				decimal num = result.GetValueOrDefault();
				while (enumerator.MoveNext())
				{
					decimal? current = enumerator.Current;
					decimal valueOrDefault = current.GetValueOrDefault();
					if (current.HasValue && valueOrDefault > num)
					{
						num = valueOrDefault;
						result = current;
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Returns the maximum value in a generic sequence.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static TSource Max<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			Comparer<TSource> comparer = Comparer<TSource>.Default;
			TSource val = default(TSource);
			if (val == null)
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				do
				{
					if (!enumerator.MoveNext())
					{
						return val;
					}
					val = enumerator.Current;
				}
				while (val == null);
				while (enumerator.MoveNext())
				{
					TSource current = enumerator.Current;
					if (current != null && comparer.Compare(current, val) > 0)
					{
						val = current;
					}
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator2 = source.GetEnumerator();
				if (!enumerator2.MoveNext())
				{
					throw Error.NoElements();
				}
				val = enumerator2.Current;
				while (enumerator2.MoveNext())
				{
					TSource current2 = enumerator2.Current;
					if (comparer.Compare(current2, val) > 0)
					{
						val = current2;
					}
				}
			}
			return val;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the maximum <see cref="T:System.Int32" /> value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static int Max<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			int num = selector(enumerator.Current);
			while (enumerator.MoveNext())
			{
				int num2 = selector(enumerator.Current);
				if (num2 > num)
				{
					num = num2;
				}
			}
			return num;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Int32" /> value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The value of type Nullable&lt;Int32&gt; in C# or Nullable(Of Int32) in Visual Basic that corresponds to the maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static int? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, int?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			int? result = null;
			using (IEnumerator<TSource> enumerator = source.GetEnumerator())
			{
				do
				{
					if (!enumerator.MoveNext())
					{
						return result;
					}
					result = selector(enumerator.Current);
				}
				while (!result.HasValue);
				int num = result.GetValueOrDefault();
				if (num >= 0)
				{
					while (enumerator.MoveNext())
					{
						int? num2 = selector(enumerator.Current);
						int valueOrDefault = num2.GetValueOrDefault();
						if (valueOrDefault > num)
						{
							num = valueOrDefault;
							result = num2;
						}
					}
				}
				else
				{
					while (enumerator.MoveNext())
					{
						int? num3 = selector(enumerator.Current);
						int valueOrDefault2 = num3.GetValueOrDefault();
						if (num3.HasValue && valueOrDefault2 > num)
						{
							num = valueOrDefault2;
							result = num3;
						}
					}
				}
			}
			return result;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the maximum <see cref="T:System.Int64" /> value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static long Max<TSource>(this IEnumerable<TSource> source, Func<TSource, long> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			long num = selector(enumerator.Current);
			while (enumerator.MoveNext())
			{
				long num2 = selector(enumerator.Current);
				if (num2 > num)
				{
					num = num2;
				}
			}
			return num;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Int64" /> value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The value of type Nullable&lt;Int64&gt; in C# or Nullable(Of Int64) in Visual Basic that corresponds to the maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static long? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, long?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			long? result = null;
			using (IEnumerator<TSource> enumerator = source.GetEnumerator())
			{
				do
				{
					if (!enumerator.MoveNext())
					{
						return result;
					}
					result = selector(enumerator.Current);
				}
				while (!result.HasValue);
				long num = result.GetValueOrDefault();
				if (num >= 0)
				{
					while (enumerator.MoveNext())
					{
						long? num2 = selector(enumerator.Current);
						long valueOrDefault = num2.GetValueOrDefault();
						if (valueOrDefault > num)
						{
							num = valueOrDefault;
							result = num2;
						}
					}
				}
				else
				{
					while (enumerator.MoveNext())
					{
						long? num3 = selector(enumerator.Current);
						long valueOrDefault2 = num3.GetValueOrDefault();
						if (num3.HasValue && valueOrDefault2 > num)
						{
							num = valueOrDefault2;
							result = num3;
						}
					}
				}
			}
			return result;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the maximum <see cref="T:System.Single" /> value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float Max<TSource>(this IEnumerable<TSource> source, Func<TSource, float> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			float num = selector(enumerator.Current);
			while (float.IsNaN(num))
			{
				if (!enumerator.MoveNext())
				{
					return num;
				}
				num = selector(enumerator.Current);
			}
			while (enumerator.MoveNext())
			{
				float num2 = selector(enumerator.Current);
				if (num2 > num)
				{
					num = num2;
				}
			}
			return num;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Single" /> value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The value of type Nullable&lt;Single&gt; in C# or Nullable(Of Single) in Visual Basic that corresponds to the maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static float? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, float?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			float? result = null;
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = selector(enumerator.Current);
				if (!result.HasValue)
				{
					continue;
				}
				float num = result.GetValueOrDefault();
				while (float.IsNaN(num))
				{
					if (!enumerator.MoveNext())
					{
						return result;
					}
					float? num2 = selector(enumerator.Current);
					if (num2.HasValue)
					{
						float? num3 = (result = num2);
						num = num3.GetValueOrDefault();
					}
				}
				while (enumerator.MoveNext())
				{
					float? num4 = selector(enumerator.Current);
					float valueOrDefault = num4.GetValueOrDefault();
					if (num4.HasValue && valueOrDefault > num)
					{
						num = valueOrDefault;
						result = num4;
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the maximum <see cref="T:System.Double" /> value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Max<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			double num = selector(enumerator.Current);
			while (double.IsNaN(num))
			{
				if (!enumerator.MoveNext())
				{
					return num;
				}
				num = selector(enumerator.Current);
			}
			while (enumerator.MoveNext())
			{
				double num2 = selector(enumerator.Current);
				if (num2 > num)
				{
					num = num2;
				}
			}
			return num;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Double" /> value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The value of type Nullable&lt;Double&gt; in C# or Nullable(Of Double) in Visual Basic that corresponds to the maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static double? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, double?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			double? result = null;
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = selector(enumerator.Current);
				if (!result.HasValue)
				{
					continue;
				}
				double num = result.GetValueOrDefault();
				while (double.IsNaN(num))
				{
					if (!enumerator.MoveNext())
					{
						return result;
					}
					double? num2 = selector(enumerator.Current);
					if (num2.HasValue)
					{
						double? num3 = (result = num2);
						num = num3.GetValueOrDefault();
					}
				}
				while (enumerator.MoveNext())
				{
					double? num4 = selector(enumerator.Current);
					double valueOrDefault = num4.GetValueOrDefault();
					if (num4.HasValue && valueOrDefault > num)
					{
						num = valueOrDefault;
						result = num4;
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the maximum <see cref="T:System.Decimal" /> value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static decimal Max<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			decimal num = selector(enumerator.Current);
			while (enumerator.MoveNext())
			{
				decimal num2 = selector(enumerator.Current);
				if (num2 > num)
				{
					num = num2;
				}
			}
			return num;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the maximum nullable <see cref="T:System.Decimal" /> value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The value of type Nullable&lt;Decimal&gt; in C# or Nullable(Of Decimal) in Visual Basic that corresponds to the maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static decimal? Max<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			decimal? result = null;
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = selector(enumerator.Current);
				if (!result.HasValue)
				{
					continue;
				}
				decimal num = result.GetValueOrDefault();
				while (enumerator.MoveNext())
				{
					decimal? num2 = selector(enumerator.Current);
					decimal valueOrDefault = num2.GetValueOrDefault();
					if (num2.HasValue && valueOrDefault > num)
					{
						num = valueOrDefault;
						result = num2;
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Invokes a transform function on each element of a generic sequence and returns the maximum resulting value.</summary>
		/// <param name="source">A sequence of values to determine the maximum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the value returned by <paramref name="selector" />.</typeparam>
		/// <returns>The maximum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static TResult Max<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			Comparer<TResult> comparer = Comparer<TResult>.Default;
			TResult val = default(TResult);
			if (val == null)
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				do
				{
					if (!enumerator.MoveNext())
					{
						return val;
					}
					val = selector(enumerator.Current);
				}
				while (val == null);
				while (enumerator.MoveNext())
				{
					TResult val2 = selector(enumerator.Current);
					if (val2 != null && comparer.Compare(val2, val) > 0)
					{
						val = val2;
					}
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator2 = source.GetEnumerator();
				if (!enumerator2.MoveNext())
				{
					throw Error.NoElements();
				}
				val = selector(enumerator2.Current);
				while (enumerator2.MoveNext())
				{
					TResult val3 = selector(enumerator2.Current);
					if (comparer.Compare(val3, val) > 0)
					{
						val = val3;
					}
				}
			}
			return val;
		}

		/// <summary>Returns the minimum value in a sequence of <see cref="T:System.Int32" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Int32" /> values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static int Min(this IEnumerable<int> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using IEnumerator<int> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			int num = enumerator.Current;
			while (enumerator.MoveNext())
			{
				int current = enumerator.Current;
				if (current < num)
				{
					num = current;
				}
			}
			return num;
		}

		/// <summary>Returns the minimum value in a sequence of nullable <see cref="T:System.Int32" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Int32" /> values to determine the minimum value of.</param>
		/// <returns>A value of type Nullable&lt;Int32&gt; in C# or Nullable(Of Int32) in Visual Basic that corresponds to the minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static int? Min(this IEnumerable<int?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			int? result = null;
			using IEnumerator<int?> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = enumerator.Current;
				if (!result.HasValue)
				{
					continue;
				}
				int num = result.GetValueOrDefault();
				while (enumerator.MoveNext())
				{
					int? current = enumerator.Current;
					int valueOrDefault = current.GetValueOrDefault();
					if (current.HasValue && valueOrDefault < num)
					{
						num = valueOrDefault;
						result = current;
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Returns the minimum value in a sequence of <see cref="T:System.Int64" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Int64" /> values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static long Min(this IEnumerable<long> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using IEnumerator<long> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			long num = enumerator.Current;
			while (enumerator.MoveNext())
			{
				long current = enumerator.Current;
				if (current < num)
				{
					num = current;
				}
			}
			return num;
		}

		/// <summary>Returns the minimum value in a sequence of nullable <see cref="T:System.Int64" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Int64" /> values to determine the minimum value of.</param>
		/// <returns>A value of type Nullable&lt;Int64&gt; in C# or Nullable(Of Int64) in Visual Basic that corresponds to the minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static long? Min(this IEnumerable<long?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long? result = null;
			using IEnumerator<long?> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = enumerator.Current;
				if (!result.HasValue)
				{
					continue;
				}
				long num = result.GetValueOrDefault();
				while (enumerator.MoveNext())
				{
					long? current = enumerator.Current;
					long valueOrDefault = current.GetValueOrDefault();
					if (current.HasValue && valueOrDefault < num)
					{
						num = valueOrDefault;
						result = current;
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Returns the minimum value in a sequence of <see cref="T:System.Single" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Single" /> values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float Min(this IEnumerable<float> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using IEnumerator<float> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			float num = enumerator.Current;
			while (enumerator.MoveNext())
			{
				float current = enumerator.Current;
				if (current < num)
				{
					num = current;
				}
				else if (float.IsNaN(current))
				{
					return current;
				}
			}
			return num;
		}

		/// <summary>Returns the minimum value in a sequence of nullable <see cref="T:System.Single" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Single" /> values to determine the minimum value of.</param>
		/// <returns>A value of type Nullable&lt;Single&gt; in C# or Nullable(Of Single) in Visual Basic that corresponds to the minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static float? Min(this IEnumerable<float?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			float? result = null;
			using IEnumerator<float?> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = enumerator.Current;
				if (!result.HasValue)
				{
					continue;
				}
				float num = result.GetValueOrDefault();
				while (enumerator.MoveNext())
				{
					float? current = enumerator.Current;
					if (current.HasValue)
					{
						float valueOrDefault = current.GetValueOrDefault();
						if (valueOrDefault < num)
						{
							num = valueOrDefault;
							result = current;
						}
						else if (float.IsNaN(valueOrDefault))
						{
							return current;
						}
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Returns the minimum value in a sequence of <see cref="T:System.Double" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Double" /> values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Min(this IEnumerable<double> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using IEnumerator<double> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			double num = enumerator.Current;
			while (enumerator.MoveNext())
			{
				double current = enumerator.Current;
				if (current < num)
				{
					num = current;
				}
				else if (double.IsNaN(current))
				{
					return current;
				}
			}
			return num;
		}

		/// <summary>Returns the minimum value in a sequence of nullable <see cref="T:System.Double" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Double" /> values to determine the minimum value of.</param>
		/// <returns>A value of type Nullable&lt;Double&gt; in C# or Nullable(Of Double) in Visual Basic that corresponds to the minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static double? Min(this IEnumerable<double?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double? result = null;
			using IEnumerator<double?> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = enumerator.Current;
				if (!result.HasValue)
				{
					continue;
				}
				double num = result.GetValueOrDefault();
				while (enumerator.MoveNext())
				{
					double? current = enumerator.Current;
					if (current.HasValue)
					{
						double valueOrDefault = current.GetValueOrDefault();
						if (valueOrDefault < num)
						{
							num = valueOrDefault;
							result = current;
						}
						else if (double.IsNaN(valueOrDefault))
						{
							return current;
						}
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Returns the minimum value in a sequence of <see cref="T:System.Decimal" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Decimal" /> values to determine the minimum value of.</param>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static decimal Min(this IEnumerable<decimal> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			using IEnumerator<decimal> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			decimal num = enumerator.Current;
			while (enumerator.MoveNext())
			{
				decimal current = enumerator.Current;
				if (current < num)
				{
					num = current;
				}
			}
			return num;
		}

		/// <summary>Returns the minimum value in a sequence of nullable <see cref="T:System.Decimal" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Decimal" /> values to determine the minimum value of.</param>
		/// <returns>A value of type Nullable&lt;Decimal&gt; in C# or Nullable(Of Decimal) in Visual Basic that corresponds to the minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static decimal? Min(this IEnumerable<decimal?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			decimal? result = null;
			using IEnumerator<decimal?> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = enumerator.Current;
				if (!result.HasValue)
				{
					continue;
				}
				decimal num = result.GetValueOrDefault();
				while (enumerator.MoveNext())
				{
					decimal? current = enumerator.Current;
					decimal valueOrDefault = current.GetValueOrDefault();
					if (current.HasValue && valueOrDefault < num)
					{
						num = valueOrDefault;
						result = current;
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Returns the minimum value in a generic sequence.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static TSource Min<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			Comparer<TSource> comparer = Comparer<TSource>.Default;
			TSource val = default(TSource);
			if (val == null)
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				do
				{
					if (!enumerator.MoveNext())
					{
						return val;
					}
					val = enumerator.Current;
				}
				while (val == null);
				while (enumerator.MoveNext())
				{
					TSource current = enumerator.Current;
					if (current != null && comparer.Compare(current, val) < 0)
					{
						val = current;
					}
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator2 = source.GetEnumerator();
				if (!enumerator2.MoveNext())
				{
					throw Error.NoElements();
				}
				val = enumerator2.Current;
				while (enumerator2.MoveNext())
				{
					TSource current2 = enumerator2.Current;
					if (comparer.Compare(current2, val) < 0)
					{
						val = current2;
					}
				}
			}
			return val;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the minimum <see cref="T:System.Int32" /> value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static int Min<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			int num = selector(enumerator.Current);
			while (enumerator.MoveNext())
			{
				int num2 = selector(enumerator.Current);
				if (num2 < num)
				{
					num = num2;
				}
			}
			return num;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Int32" /> value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The value of type Nullable&lt;Int32&gt; in C# or Nullable(Of Int32) in Visual Basic that corresponds to the minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static int? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, int?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			int? result = null;
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = selector(enumerator.Current);
				if (!result.HasValue)
				{
					continue;
				}
				int num = result.GetValueOrDefault();
				while (enumerator.MoveNext())
				{
					int? num2 = selector(enumerator.Current);
					int valueOrDefault = num2.GetValueOrDefault();
					if (num2.HasValue && valueOrDefault < num)
					{
						num = valueOrDefault;
						result = num2;
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the minimum <see cref="T:System.Int64" /> value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static long Min<TSource>(this IEnumerable<TSource> source, Func<TSource, long> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			long num = selector(enumerator.Current);
			while (enumerator.MoveNext())
			{
				long num2 = selector(enumerator.Current);
				if (num2 < num)
				{
					num = num2;
				}
			}
			return num;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Int64" /> value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The value of type Nullable&lt;Int64&gt; in C# or Nullable(Of Int64) in Visual Basic that corresponds to the minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static long? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, long?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			long? result = null;
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = selector(enumerator.Current);
				if (!result.HasValue)
				{
					continue;
				}
				long num = result.GetValueOrDefault();
				while (enumerator.MoveNext())
				{
					long? num2 = selector(enumerator.Current);
					long valueOrDefault = num2.GetValueOrDefault();
					if (num2.HasValue && valueOrDefault < num)
					{
						num = valueOrDefault;
						result = num2;
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the minimum <see cref="T:System.Single" /> value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static float Min<TSource>(this IEnumerable<TSource> source, Func<TSource, float> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			float num = selector(enumerator.Current);
			while (enumerator.MoveNext())
			{
				float num2 = selector(enumerator.Current);
				if (num2 < num)
				{
					num = num2;
				}
				else if (float.IsNaN(num2))
				{
					return num2;
				}
			}
			return num;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Single" /> value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The value of type Nullable&lt;Single&gt; in C# or Nullable(Of Single) in Visual Basic that corresponds to the minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static float? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, float?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			float? result = null;
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = selector(enumerator.Current);
				if (!result.HasValue)
				{
					continue;
				}
				float num = result.GetValueOrDefault();
				while (enumerator.MoveNext())
				{
					float? num2 = selector(enumerator.Current);
					if (num2.HasValue)
					{
						float valueOrDefault = num2.GetValueOrDefault();
						if (valueOrDefault < num)
						{
							num = valueOrDefault;
							result = num2;
						}
						else if (float.IsNaN(valueOrDefault))
						{
							return num2;
						}
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the minimum <see cref="T:System.Double" /> value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static double Min<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			double num = selector(enumerator.Current);
			while (enumerator.MoveNext())
			{
				double num2 = selector(enumerator.Current);
				if (num2 < num)
				{
					num = num2;
				}
				else if (double.IsNaN(num2))
				{
					return num2;
				}
			}
			return num;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Double" /> value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The value of type Nullable&lt;Double&gt; in C# or Nullable(Of Double) in Visual Basic that corresponds to the minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static double? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, double?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			double? result = null;
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = selector(enumerator.Current);
				if (!result.HasValue)
				{
					continue;
				}
				double num = result.GetValueOrDefault();
				while (enumerator.MoveNext())
				{
					double? num2 = selector(enumerator.Current);
					if (num2.HasValue)
					{
						double valueOrDefault = num2.GetValueOrDefault();
						if (valueOrDefault < num)
						{
							num = valueOrDefault;
							result = num2;
						}
						else if (double.IsNaN(valueOrDefault))
						{
							return num2;
						}
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the minimum <see cref="T:System.Decimal" /> value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="source" /> contains no elements.</exception>
		public static decimal Min<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw Error.NoElements();
			}
			decimal num = selector(enumerator.Current);
			while (enumerator.MoveNext())
			{
				decimal num2 = selector(enumerator.Current);
				if (num2 < num)
				{
					num = num2;
				}
			}
			return num;
		}

		/// <summary>Invokes a transform function on each element of a sequence and returns the minimum nullable <see cref="T:System.Decimal" /> value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The value of type Nullable&lt;Decimal&gt; in C# or Nullable(Of Decimal) in Visual Basic that corresponds to the minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static decimal? Min<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			decimal? result = null;
			using IEnumerator<TSource> enumerator = source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				result = selector(enumerator.Current);
				if (!result.HasValue)
				{
					continue;
				}
				decimal num = result.GetValueOrDefault();
				while (enumerator.MoveNext())
				{
					decimal? num2 = selector(enumerator.Current);
					decimal valueOrDefault = num2.GetValueOrDefault();
					if (num2.HasValue && valueOrDefault < num)
					{
						num = valueOrDefault;
						result = num2;
					}
				}
				return result;
			}
			return result;
		}

		/// <summary>Invokes a transform function on each element of a generic sequence and returns the minimum resulting value.</summary>
		/// <param name="source">A sequence of values to determine the minimum value of.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the value returned by <paramref name="selector" />.</typeparam>
		/// <returns>The minimum value in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static TResult Min<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			Comparer<TResult> comparer = Comparer<TResult>.Default;
			TResult val = default(TResult);
			if (val == null)
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				do
				{
					if (!enumerator.MoveNext())
					{
						return val;
					}
					val = selector(enumerator.Current);
				}
				while (val == null);
				while (enumerator.MoveNext())
				{
					TResult val2 = selector(enumerator.Current);
					if (val2 != null && comparer.Compare(val2, val) < 0)
					{
						val = val2;
					}
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator2 = source.GetEnumerator();
				if (!enumerator2.MoveNext())
				{
					throw Error.NoElements();
				}
				val = selector(enumerator2.Current);
				while (enumerator2.MoveNext())
				{
					TResult val3 = selector(enumerator2.Current);
					if (comparer.Compare(val3, val) < 0)
					{
						val = val3;
					}
				}
			}
			return val;
		}

		/// <summary>Sorts the elements of a sequence in ascending order according to a key.</summary>
		/// <param name="source">A sequence of values to order.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1" /> whose elements are sorted according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IOrderedEnumerable<TSource> OrderBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return new OrderedEnumerable<TSource, TKey>(source, keySelector, null, descending: false, null);
		}

		/// <summary>Sorts the elements of a sequence in ascending order by using a specified comparer.</summary>
		/// <param name="source">A sequence of values to order.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1" /> whose elements are sorted according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IOrderedEnumerable<TSource> OrderBy<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			return new OrderedEnumerable<TSource, TKey>(source, keySelector, comparer, descending: false, null);
		}

		/// <summary>Sorts the elements of a sequence in descending order according to a key.</summary>
		/// <param name="source">A sequence of values to order.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1" /> whose elements are sorted in descending order according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IOrderedEnumerable<TSource> OrderByDescending<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return new OrderedEnumerable<TSource, TKey>(source, keySelector, null, descending: true, null);
		}

		/// <summary>Sorts the elements of a sequence in descending order by using a specified comparer.</summary>
		/// <param name="source">A sequence of values to order.</param>
		/// <param name="keySelector">A function to extract a key from an element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1" /> whose elements are sorted in descending order according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IOrderedEnumerable<TSource> OrderByDescending<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			return new OrderedEnumerable<TSource, TKey>(source, keySelector, comparer, descending: true, null);
		}

		/// <summary>Performs a subsequent ordering of the elements in a sequence in ascending order according to a key.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IOrderedEnumerable`1" /> that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1" /> whose elements are sorted according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IOrderedEnumerable<TSource> ThenBy<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.CreateOrderedEnumerable(keySelector, null, descending: false);
		}

		/// <summary>Performs a subsequent ordering of the elements in a sequence in ascending order by using a specified comparer.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IOrderedEnumerable`1" /> that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1" /> whose elements are sorted according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IOrderedEnumerable<TSource> ThenBy<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.CreateOrderedEnumerable(keySelector, comparer, descending: false);
		}

		/// <summary>Performs a subsequent ordering of the elements in a sequence in descending order, according to a key.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IOrderedEnumerable`1" /> that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1" /> whose elements are sorted in descending order according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IOrderedEnumerable<TSource> ThenByDescending<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.CreateOrderedEnumerable(keySelector, null, descending: true);
		}

		/// <summary>Performs a subsequent ordering of the elements in a sequence in descending order by using a specified comparer.</summary>
		/// <param name="source">An <see cref="T:System.Linq.IOrderedEnumerable`1" /> that contains elements to sort.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1" /> whose elements are sorted in descending order according to a key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.</exception>
		public static IOrderedEnumerable<TSource> ThenByDescending<TSource, TKey>(this IOrderedEnumerable<TSource> source, Func<TSource, TKey> keySelector, IComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return source.CreateOrderedEnumerable(keySelector, comparer, descending: true);
		}

		/// <summary>Generates a sequence of integral numbers within a specified range.</summary>
		/// <param name="start">The value of the first integer in the sequence.</param>
		/// <param name="count">The number of sequential integers to generate.</param>
		/// <returns>An IEnumerable&lt;Int32&gt; in C# or IEnumerable(Of Int32) in Visual Basic that contains a range of sequential integral numbers.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="count" /> is less than 0.-or-
		///         <paramref name="start" /> + <paramref name="count" /> -1 is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
		public static IEnumerable<int> Range(int start, int count)
		{
			long num = (long)start + (long)count - 1;
			if (count < 0 || num > int.MaxValue)
			{
				throw Error.ArgumentOutOfRange("count");
			}
			if (count == 0)
			{
				return EmptyPartition<int>.Instance;
			}
			return new RangeIterator(start, count);
		}

		/// <summary>Generates a sequence that contains one repeated value.</summary>
		/// <param name="element">The value to be repeated.</param>
		/// <param name="count">The number of times to repeat the value in the generated sequence.</param>
		/// <typeparam name="TResult">The type of the value to be repeated in the result sequence.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains a repeated value.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="count" /> is less than 0.</exception>
		public static IEnumerable<TResult> Repeat<TResult>(TResult element, int count)
		{
			if (count < 0)
			{
				throw Error.ArgumentOutOfRange("count");
			}
			if (count == 0)
			{
				return EmptyPartition<TResult>.Instance;
			}
			return new RepeatIterator<TResult>(element, count);
		}

		/// <summary>Inverts the order of the elements in a sequence.</summary>
		/// <param name="source">A sequence of values to reverse.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>A sequence whose elements correspond to those of the input sequence in reverse order.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Reverse<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return new ReverseIterator<TSource>(source);
		}

		/// <summary>Projects each element of a sequence into a new form.</summary>
		/// <param name="source">A sequence of values to invoke a transform function on.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the value returned by <paramref name="selector" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are the result of invoking the transform function on each element of <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static IEnumerable<TResult> Select<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			if (source is Iterator<TSource> iterator)
			{
				return iterator.Select(selector);
			}
			if (source is IList<TSource> source2)
			{
				if (source is TSource[] array)
				{
					if (array.Length != 0)
					{
						return new SelectArrayIterator<TSource, TResult>(array, selector);
					}
					return EmptyPartition<TResult>.Instance;
				}
				if (source is List<TSource> source3)
				{
					return new SelectListIterator<TSource, TResult>(source3, selector);
				}
				return new SelectIListIterator<TSource, TResult>(source2, selector);
			}
			if (source is IPartition<TSource> partition)
			{
				if (!(partition is EmptyPartition<TSource>))
				{
					return new SelectIPartitionIterator<TSource, TResult>(partition, selector);
				}
				return EmptyPartition<TResult>.Instance;
			}
			return new SelectEnumerableIterator<TSource, TResult>(source, selector);
		}

		/// <summary>Projects each element of a sequence into a new form by incorporating the element's index.</summary>
		/// <param name="source">A sequence of values to invoke a transform function on.</param>
		/// <param name="selector">A transform function to apply to each source element; the second parameter of the function represents the index of the source element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the value returned by <paramref name="selector" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are the result of invoking the transform function on each element of <paramref name="source" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static IEnumerable<TResult> Select<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, TResult> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return SelectIterator(source, selector);
		}

		private static IEnumerable<TResult> SelectIterator<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, TResult> selector)
		{
			int index = -1;
			foreach (TSource item in source)
			{
				index = checked(index + 1);
				yield return selector(item, index);
			}
		}

		/// <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" /> and flattens the resulting sequences into one sequence.</summary>
		/// <param name="source">A sequence of values to project.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the sequence returned by <paramref name="selector" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static IEnumerable<TResult> SelectMany<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, IEnumerable<TResult>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return new SelectManySingleSelectorIterator<TSource, TResult>(source, selector);
		}

		/// <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" />, and flattens the resulting sequences into one sequence. The index of each source element is used in the projected form of that element.</summary>
		/// <param name="source">A sequence of values to project.</param>
		/// <param name="selector">A transform function to apply to each source element; the second parameter of the function represents the index of the source element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the sequence returned by <paramref name="selector" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are the result of invoking the one-to-many transform function on each element of an input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static IEnumerable<TResult> SelectMany<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TResult>> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			return SelectManyIterator(source, selector);
		}

		private static IEnumerable<TResult> SelectManyIterator<TSource, TResult>(IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TResult>> selector)
		{
			int index = -1;
			foreach (TSource item in source)
			{
				index = checked(index + 1);
				foreach (TResult item2 in selector(item, index))
				{
					yield return item2;
				}
			}
		}

		/// <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" />, flattens the resulting sequences into one sequence, and invokes a result selector function on each element therein. The index of each source element is used in the intermediate projected form of that element.</summary>
		/// <param name="source">A sequence of values to project.</param>
		/// <param name="collectionSelector">A transform function to apply to each source element; the second parameter of the function represents the index of the source element.</param>
		/// <param name="resultSelector">A transform function to apply to each element of the intermediate sequence.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TCollection">The type of the intermediate elements collected by <paramref name="collectionSelector" />.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are the result of invoking the one-to-many transform function <paramref name="collectionSelector" /> on each element of <paramref name="source" /> and then mapping each of those sequence elements and their corresponding source element to a result element.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="collectionSelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static IEnumerable<TResult> SelectMany<TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (collectionSelector == null)
			{
				throw Error.ArgumentNull("collectionSelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return SelectManyIterator(source, collectionSelector, resultSelector);
		}

		private static IEnumerable<TResult> SelectManyIterator<TSource, TCollection, TResult>(IEnumerable<TSource> source, Func<TSource, int, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
		{
			int index = -1;
			foreach (TSource element in source)
			{
				index = checked(index + 1);
				foreach (TCollection item in collectionSelector(element, index))
				{
					yield return resultSelector(element, item);
				}
			}
		}

		/// <summary>Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1" />, flattens the resulting sequences into one sequence, and invokes a result selector function on each element therein.</summary>
		/// <param name="source">A sequence of values to project.</param>
		/// <param name="collectionSelector">A transform function to apply to each element of the input sequence.</param>
		/// <param name="resultSelector">A transform function to apply to each element of the intermediate sequence.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TCollection">The type of the intermediate elements collected by <paramref name="collectionSelector" />.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the resulting sequence.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are the result of invoking the one-to-many transform function <paramref name="collectionSelector" /> on each element of <paramref name="source" /> and then mapping each of those sequence elements and their corresponding source element to a result element.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="collectionSelector" /> or <paramref name="resultSelector" /> is <see langword="null" />.</exception>
		public static IEnumerable<TResult> SelectMany<TSource, TCollection, TResult>(this IEnumerable<TSource> source, Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (collectionSelector == null)
			{
				throw Error.ArgumentNull("collectionSelector");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return SelectManyIterator(source, collectionSelector, resultSelector);
		}

		private static IEnumerable<TResult> SelectManyIterator<TSource, TCollection, TResult>(IEnumerable<TSource> source, Func<TSource, IEnumerable<TCollection>> collectionSelector, Func<TSource, TCollection, TResult> resultSelector)
		{
			foreach (TSource element in source)
			{
				foreach (TCollection item in collectionSelector(element))
				{
					yield return resultSelector(element, item);
				}
			}
		}

		/// <summary>Determines whether two sequences are equal by comparing the elements by using the default equality comparer for their type.</summary>
		/// <param name="first">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to compare to <paramref name="second" />.</param>
		/// <param name="second">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to compare to the first sequence.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>
		///     <see langword="true" /> if the two source sequences are of equal length and their corresponding elements are equal according to the default equality comparer for their type; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is <see langword="null" />.</exception>
		public static bool SequenceEqual<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			return first.SequenceEqual(second, null);
		}

		/// <summary>Determines whether two sequences are equal by comparing their elements by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
		/// <param name="first">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to compare to <paramref name="second" />.</param>
		/// <param name="second">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to compare to the first sequence.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to use to compare elements.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>
		///     <see langword="true" /> if the two source sequences are of equal length and their corresponding elements compare equal according to <paramref name="comparer" />; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is <see langword="null" />.</exception>
		public static bool SequenceEqual<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			if (comparer == null)
			{
				comparer = EqualityComparer<TSource>.Default;
			}
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			if (first is ICollection<TSource> collection && second is ICollection<TSource> collection2)
			{
				if (collection.Count != collection2.Count)
				{
					return false;
				}
				if (collection is IList<TSource> list && collection2 is IList<TSource> list2)
				{
					int count = collection.Count;
					for (int i = 0; i < count; i++)
					{
						if (!comparer.Equals(list[i], list2[i]))
						{
							return false;
						}
					}
					return true;
				}
			}
			using IEnumerator<TSource> enumerator = first.GetEnumerator();
			using IEnumerator<TSource> enumerator2 = second.GetEnumerator();
			while (enumerator.MoveNext())
			{
				if (!enumerator2.MoveNext() || !comparer.Equals(enumerator.Current, enumerator2.Current))
				{
					return false;
				}
			}
			return !enumerator2.MoveNext();
		}

		/// <summary>Returns the only element of a sequence, and throws an exception if there is not exactly one element in the sequence.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return the single element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The single element of the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The input sequence contains more than one element.-or-The input sequence is empty.</exception>
		public static TSource Single<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IList<TSource> { Count: var count } list)
			{
				switch (count)
				{
				case 0:
					throw Error.NoElements();
				case 1:
					return list[0];
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				if (!enumerator.MoveNext())
				{
					throw Error.NoElements();
				}
				TSource current = enumerator.Current;
				if (!enumerator.MoveNext())
				{
					return current;
				}
			}
			throw Error.MoreThanOneElement();
		}

		/// <summary>Returns the only element of a sequence that satisfies a specified condition, and throws an exception if more than one such element exists.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return a single element from.</param>
		/// <param name="predicate">A function to test an element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The single element of the input sequence that satisfies a condition.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">No element satisfies the condition in <paramref name="predicate" />.-or-More than one element satisfies the condition in <paramref name="predicate" />.-or-The source sequence is empty.</exception>
		public static TSource Single<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			using (IEnumerator<TSource> enumerator = source.GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					TSource current = enumerator.Current;
					if (!predicate(current))
					{
						continue;
					}
					while (enumerator.MoveNext())
					{
						if (predicate(enumerator.Current))
						{
							throw Error.MoreThanOneMatch();
						}
					}
					return current;
				}
			}
			throw Error.NoMatch();
		}

		/// <summary>Returns the only element of a sequence, or a default value if the sequence is empty; this method throws an exception if there is more than one element in the sequence.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return the single element of.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The single element of the input sequence, or <see langword="default" />(<paramref name="TSource" />) if the sequence contains no elements.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The input sequence contains more than one element.</exception>
		public static TSource SingleOrDefault<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (source is IList<TSource> { Count: var count } list)
			{
				switch (count)
				{
				case 0:
					return default(TSource);
				case 1:
					return list[0];
				}
			}
			else
			{
				using IEnumerator<TSource> enumerator = source.GetEnumerator();
				if (!enumerator.MoveNext())
				{
					return default(TSource);
				}
				TSource current = enumerator.Current;
				if (!enumerator.MoveNext())
				{
					return current;
				}
			}
			throw Error.MoreThanOneElement();
		}

		/// <summary>Returns the only element of a sequence that satisfies a specified condition or a default value if no such element exists; this method throws an exception if more than one element satisfies the condition.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return a single element from.</param>
		/// <param name="predicate">A function to test an element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The single element of the input sequence that satisfies the condition, or <see langword="default" />(<paramref name="TSource" />) if no such element is found.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static TSource SingleOrDefault<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			using (IEnumerator<TSource> enumerator = source.GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					TSource current = enumerator.Current;
					if (!predicate(current))
					{
						continue;
					}
					while (enumerator.MoveNext())
					{
						if (predicate(enumerator.Current))
						{
							throw Error.MoreThanOneMatch();
						}
					}
					return current;
				}
			}
			return default(TSource);
		}

		/// <summary>Bypasses a specified number of elements in a sequence and then returns the remaining elements.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return elements from.</param>
		/// <param name="count">The number of elements to skip before returning the remaining elements.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the elements that occur after the specified index in the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Skip<TSource>(this IEnumerable<TSource> source, int count)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (count <= 0)
			{
				if (source is Iterator<TSource> || source is IPartition<TSource>)
				{
					return source;
				}
				count = 0;
			}
			else if (source is IPartition<TSource> partition)
			{
				return partition.Skip(count);
			}
			if (source is IList<TSource> source2)
			{
				return new ListPartition<TSource>(source2, count, int.MaxValue);
			}
			return new EnumerablePartition<TSource>(source, count, -1);
		}

		/// <summary>Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return elements from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by <paramref name="predicate" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> SkipWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return SkipWhileIterator(source, predicate);
		}

		private static IEnumerable<TSource> SkipWhileIterator<TSource>(IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			using IEnumerator<TSource> e = source.GetEnumerator();
			while (e.MoveNext())
			{
				TSource current = e.Current;
				if (!predicate(current))
				{
					yield return current;
					while (e.MoveNext())
					{
						yield return e.Current;
					}
					yield break;
				}
			}
		}

		/// <summary>Bypasses elements in a sequence as long as a specified condition is true and then returns the remaining elements. The element's index is used in the logic of the predicate function.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return elements from.</param>
		/// <param name="predicate">A function to test each source element for a condition; the second parameter of the function represents the index of the source element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by <paramref name="predicate" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> SkipWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return SkipWhileIterator(source, predicate);
		}

		private static IEnumerable<TSource> SkipWhileIterator<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			using IEnumerator<TSource> e = source.GetEnumerator();
			int num = -1;
			while (e.MoveNext())
			{
				num = checked(num + 1);
				TSource current = e.Current;
				if (!predicate(current, num))
				{
					yield return current;
					while (e.MoveNext())
					{
						yield return e.Current;
					}
					yield break;
				}
			}
		}

		public static IEnumerable<TSource> SkipLast<TSource>(this IEnumerable<TSource> source, int count)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (count <= 0)
			{
				return source.Skip(0);
			}
			return SkipLastIterator(source, count);
		}

		private static IEnumerable<TSource> SkipLastIterator<TSource>(IEnumerable<TSource> source, int count)
		{
			Queue<TSource> queue = new Queue<TSource>();
			using IEnumerator<TSource> e = source.GetEnumerator();
			while (e.MoveNext())
			{
				if (queue.Count == count)
				{
					do
					{
						yield return queue.Dequeue();
						queue.Enqueue(e.Current);
					}
					while (e.MoveNext());
					break;
				}
				queue.Enqueue(e.Current);
			}
		}

		/// <summary>Computes the sum of a sequence of <see cref="T:System.Int32" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Int32" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
		public static int Sum(this IEnumerable<int> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			int num = 0;
			foreach (int item in source)
			{
				num = checked(num + item);
			}
			return num;
		}

		/// <summary>Computes the sum of a sequence of nullable <see cref="T:System.Int32" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Int32" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
		public static int? Sum(this IEnumerable<int?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			int num = 0;
			foreach (int? item in source)
			{
				if (item.HasValue)
				{
					num = checked(num + item.GetValueOrDefault());
				}
			}
			return num;
		}

		/// <summary>Computes the sum of a sequence of <see cref="T:System.Int64" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Int64" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static long Sum(this IEnumerable<long> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long num = 0L;
			foreach (long item in source)
			{
				num = checked(num + item);
			}
			return num;
		}

		/// <summary>Computes the sum of a sequence of nullable <see cref="T:System.Int64" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Int64" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static long? Sum(this IEnumerable<long?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long num = 0L;
			foreach (long? item in source)
			{
				if (item.HasValue)
				{
					num = checked(num + item.GetValueOrDefault());
				}
			}
			return num;
		}

		/// <summary>Computes the sum of a sequence of <see cref="T:System.Single" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Single" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static float Sum(this IEnumerable<float> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double num = 0.0;
			foreach (float item in source)
			{
				num += (double)item;
			}
			return (float)num;
		}

		/// <summary>Computes the sum of a sequence of nullable <see cref="T:System.Single" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Single" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static float? Sum(this IEnumerable<float?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double num = 0.0;
			foreach (float? item in source)
			{
				if (item.HasValue)
				{
					num += (double)item.GetValueOrDefault();
				}
			}
			return (float)num;
		}

		/// <summary>Computes the sum of a sequence of <see cref="T:System.Double" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Double" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static double Sum(this IEnumerable<double> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double num = 0.0;
			foreach (double item in source)
			{
				num += item;
			}
			return num;
		}

		/// <summary>Computes the sum of a sequence of nullable <see cref="T:System.Double" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Double" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static double? Sum(this IEnumerable<double?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			double num = 0.0;
			foreach (double? item in source)
			{
				if (item.HasValue)
				{
					num += item.GetValueOrDefault();
				}
			}
			return num;
		}

		/// <summary>Computes the sum of a sequence of <see cref="T:System.Decimal" /> values.</summary>
		/// <param name="source">A sequence of <see cref="T:System.Decimal" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
		public static decimal Sum(this IEnumerable<decimal> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			decimal result = default(decimal);
			foreach (decimal item in source)
			{
				result += item;
			}
			return result;
		}

		/// <summary>Computes the sum of a sequence of nullable <see cref="T:System.Decimal" /> values.</summary>
		/// <param name="source">A sequence of nullable <see cref="T:System.Decimal" /> values to calculate the sum of.</param>
		/// <returns>The sum of the values in the sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
		public static decimal? Sum(this IEnumerable<decimal?> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			decimal value = default(decimal);
			foreach (decimal? item in source)
			{
				if (item.HasValue)
				{
					value += item.GetValueOrDefault();
				}
			}
			return value;
		}

		/// <summary>Computes the sum of the sequence of <see cref="T:System.Int32" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate a sum.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
		public static int Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			int num = 0;
			foreach (TSource item in source)
			{
				num = checked(num + selector(item));
			}
			return num;
		}

		/// <summary>Computes the sum of the sequence of nullable <see cref="T:System.Int32" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate a sum.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int32.MaxValue" />.</exception>
		public static int? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, int?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			int num = 0;
			foreach (TSource item in source)
			{
				int? num2 = selector(item);
				if (num2.HasValue)
				{
					num = checked(num + num2.GetValueOrDefault());
				}
			}
			return num;
		}

		/// <summary>Computes the sum of the sequence of <see cref="T:System.Int64" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate a sum.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static long Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, long> selector)
		{
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			long num = 0L;
			foreach (TSource item in source)
			{
				num = checked(num + selector(item));
			}
			return num;
		}

		/// <summary>Computes the sum of the sequence of nullable <see cref="T:System.Int64" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate a sum.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Int64.MaxValue" />.</exception>
		public static long? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, long?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			long num = 0L;
			foreach (TSource item in source)
			{
				long? num2 = selector(item);
				if (num2.HasValue)
				{
					num = checked(num + num2.GetValueOrDefault());
				}
			}
			return num;
		}

		/// <summary>Computes the sum of the sequence of <see cref="T:System.Single" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate a sum.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static float Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, float> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			double num = 0.0;
			foreach (TSource item in source)
			{
				num += (double)selector(item);
			}
			return (float)num;
		}

		/// <summary>Computes the sum of the sequence of nullable <see cref="T:System.Single" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate a sum.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static float? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, float?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			double num = 0.0;
			foreach (TSource item in source)
			{
				float? num2 = selector(item);
				if (num2.HasValue)
				{
					num += (double)num2.GetValueOrDefault();
				}
			}
			return (float)num;
		}

		/// <summary>Computes the sum of the sequence of <see cref="T:System.Double" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate a sum.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static double Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, double> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			double num = 0.0;
			foreach (TSource item in source)
			{
				num += selector(item);
			}
			return num;
		}

		/// <summary>Computes the sum of the sequence of nullable <see cref="T:System.Double" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate a sum.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		public static double? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, double?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			double num = 0.0;
			foreach (TSource item in source)
			{
				double? num2 = selector(item);
				if (num2.HasValue)
				{
					num += num2.GetValueOrDefault();
				}
			}
			return num;
		}

		/// <summary>Computes the sum of the sequence of <see cref="T:System.Decimal" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate a sum.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
		public static decimal Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			decimal result = default(decimal);
			foreach (TSource item in source)
			{
				result += selector(item);
			}
			return result;
		}

		/// <summary>Computes the sum of the sequence of nullable <see cref="T:System.Decimal" /> values that are obtained by invoking a transform function on each element of the input sequence.</summary>
		/// <param name="source">A sequence of values that are used to calculate a sum.</param>
		/// <param name="selector">A transform function to apply to each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>The sum of the projected values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="selector" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.OverflowException">The sum is larger than <see cref="F:System.Decimal.MaxValue" />.</exception>
		public static decimal? Sum<TSource>(this IEnumerable<TSource> source, Func<TSource, decimal?> selector)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (selector == null)
			{
				throw Error.ArgumentNull("selector");
			}
			decimal value = default(decimal);
			foreach (TSource item in source)
			{
				decimal? num = selector(item);
				if (num.HasValue)
				{
					value += num.GetValueOrDefault();
				}
			}
			return value;
		}

		/// <summary>Returns a specified number of contiguous elements from the start of a sequence.</summary>
		/// <param name="source">The sequence to return elements from.</param>
		/// <param name="count">The number of elements to return.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the specified number of elements from the start of the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Take<TSource>(this IEnumerable<TSource> source, int count)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (count <= 0)
			{
				return EmptyPartition<TSource>.Instance;
			}
			if (source is IPartition<TSource> partition)
			{
				return partition.Take(count);
			}
			if (source is IList<TSource> source2)
			{
				return new ListPartition<TSource>(source2, 0, count - 1);
			}
			return new EnumerablePartition<TSource>(source, 0, count - 1);
		}

		/// <summary>Returns elements from a sequence as long as a specified condition is true.</summary>
		/// <param name="source">A sequence to return elements from.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the elements from the input sequence that occur before the element at which the test no longer passes.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> TakeWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return TakeWhileIterator(source, predicate);
		}

		private static IEnumerable<TSource> TakeWhileIterator<TSource>(IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			foreach (TSource item in source)
			{
				if (!predicate(item))
				{
					break;
				}
				yield return item;
			}
		}

		/// <summary>Returns elements from a sequence as long as a specified condition is true. The element's index is used in the logic of the predicate function.</summary>
		/// <param name="source">The sequence to return elements from.</param>
		/// <param name="predicate">A function to test each source element for a condition; the second parameter of the function represents the index of the source element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from the input sequence that occur before the element at which the test no longer passes.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> TakeWhile<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return TakeWhileIterator(source, predicate);
		}

		private static IEnumerable<TSource> TakeWhileIterator<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			int index = -1;
			foreach (TSource item in source)
			{
				index = checked(index + 1);
				if (!predicate(item, index))
				{
					break;
				}
				yield return item;
			}
		}

		public static IEnumerable<TSource> TakeLast<TSource>(this IEnumerable<TSource> source, int count)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (count <= 0)
			{
				return EmptyPartition<TSource>.Instance;
			}
			return TakeLastIterator(source, count);
		}

		private static IEnumerable<TSource> TakeLastIterator<TSource>(IEnumerable<TSource> source, int count)
		{
			Queue<TSource> queue;
			using (IEnumerator<TSource> enumerator = source.GetEnumerator())
			{
				if (!enumerator.MoveNext())
				{
					yield break;
				}
				queue = new Queue<TSource>();
				queue.Enqueue(enumerator.Current);
				while (enumerator.MoveNext())
				{
					if (queue.Count < count)
					{
						queue.Enqueue(enumerator.Current);
						continue;
					}
					do
					{
						queue.Dequeue();
						queue.Enqueue(enumerator.Current);
					}
					while (enumerator.MoveNext());
					break;
				}
			}
			do
			{
				yield return queue.Dequeue();
			}
			while (queue.Count > 0);
		}

		/// <summary>Creates an array from a <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to create an array from.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An array that contains the elements from the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static TSource[] ToArray<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (!(source is IIListProvider<TSource> iIListProvider))
			{
				return EnumerableHelpers.ToArray(source);
			}
			return iIListProvider.ToArray();
		}

		/// <summary>Creates a <see cref="T:System.Collections.Generic.List`1" /> from an <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
		/// <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1" /> to create a <see cref="T:System.Collections.Generic.List`1" /> from.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>A <see cref="T:System.Collections.Generic.List`1" /> that contains elements from the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> is <see langword="null" />.</exception>
		public static List<TSource> ToList<TSource>(this IEnumerable<TSource> source)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (!(source is IIListProvider<TSource> iIListProvider))
			{
				return new List<TSource>(source);
			}
			return iIListProvider.ToList();
		}

		/// <summary>Creates a <see cref="T:System.Collections.Generic.Dictionary`2" /> from an <see cref="T:System.Collections.Generic.IEnumerable`1" /> according to a specified key selector function.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to create a <see cref="T:System.Collections.Generic.Dictionary`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Collections.Generic.Dictionary`2" /> that contains keys and values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.-or-
		///         <paramref name="keySelector" /> produces a key that is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="keySelector" /> produces duplicate keys for two elements.</exception>
		public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)
		{
			return source.ToDictionary(keySelector, null);
		}

		/// <summary>Creates a <see cref="T:System.Collections.Generic.Dictionary`2" /> from an <see cref="T:System.Collections.Generic.IEnumerable`1" /> according to a specified key selector function and key comparer.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to create a <see cref="T:System.Collections.Generic.Dictionary`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the keys returned by <paramref name="keySelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Collections.Generic.Dictionary`2" /> that contains keys and values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> is <see langword="null" />.-or-
		///         <paramref name="keySelector" /> produces a key that is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="keySelector" /> produces duplicate keys for two elements.</exception>
		public static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			int num = 0;
			if (source is ICollection<TSource> collection)
			{
				num = collection.Count;
				if (num == 0)
				{
					return new Dictionary<TKey, TSource>(comparer);
				}
				if (collection is TSource[] source2)
				{
					return ToDictionary(source2, keySelector, comparer);
				}
				if (collection is List<TSource> source3)
				{
					return ToDictionary(source3, keySelector, comparer);
				}
			}
			Dictionary<TKey, TSource> dictionary = new Dictionary<TKey, TSource>(num, comparer);
			foreach (TSource item in source)
			{
				dictionary.Add(keySelector(item), item);
			}
			return dictionary;
		}

		private static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(TSource[] source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			Dictionary<TKey, TSource> dictionary = new Dictionary<TKey, TSource>(source.Length, comparer);
			for (int i = 0; i < source.Length; i++)
			{
				dictionary.Add(keySelector(source[i]), source[i]);
			}
			return dictionary;
		}

		private static Dictionary<TKey, TSource> ToDictionary<TSource, TKey>(List<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			Dictionary<TKey, TSource> dictionary = new Dictionary<TKey, TSource>(source.Count, comparer);
			foreach (TSource item in source)
			{
				dictionary.Add(keySelector(item), item);
			}
			return dictionary;
		}

		/// <summary>Creates a <see cref="T:System.Collections.Generic.Dictionary`2" /> from an <see cref="T:System.Collections.Generic.IEnumerable`1" /> according to specified key selector and element selector functions.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to create a <see cref="T:System.Collections.Generic.Dictionary`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="elementSelector">A transform function to produce a result element value from each element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Collections.Generic.Dictionary`2" /> that contains values of type <paramref name="TElement" /> selected from the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is <see langword="null" />.-or-
		///         <paramref name="keySelector" /> produces a key that is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="keySelector" /> produces duplicate keys for two elements.</exception>
		public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector)
		{
			return source.ToDictionary(keySelector, elementSelector, null);
		}

		/// <summary>Creates a <see cref="T:System.Collections.Generic.Dictionary`2" /> from an <see cref="T:System.Collections.Generic.IEnumerable`1" /> according to a specified key selector function, a comparer, and an element selector function.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to create a <see cref="T:System.Collections.Generic.Dictionary`2" /> from.</param>
		/// <param name="keySelector">A function to extract a key from each element.</param>
		/// <param name="elementSelector">A transform function to produce a result element value from each element.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <typeparam name="TKey">The type of the key returned by <paramref name="keySelector" />.</typeparam>
		/// <typeparam name="TElement">The type of the value returned by <paramref name="elementSelector" />.</typeparam>
		/// <returns>A <see cref="T:System.Collections.Generic.Dictionary`2" /> that contains values of type <paramref name="TElement" /> selected from the input sequence.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="keySelector" /> or <paramref name="elementSelector" /> is <see langword="null" />.-or-
		///         <paramref name="keySelector" /> produces a key that is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="keySelector" /> produces duplicate keys for two elements.</exception>
		public static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (keySelector == null)
			{
				throw Error.ArgumentNull("keySelector");
			}
			if (elementSelector == null)
			{
				throw Error.ArgumentNull("elementSelector");
			}
			int num = 0;
			if (source is ICollection<TSource> collection)
			{
				num = collection.Count;
				if (num == 0)
				{
					return new Dictionary<TKey, TElement>(comparer);
				}
				if (collection is TSource[] source2)
				{
					return ToDictionary(source2, keySelector, elementSelector, comparer);
				}
				if (collection is List<TSource> source3)
				{
					return ToDictionary(source3, keySelector, elementSelector, comparer);
				}
			}
			Dictionary<TKey, TElement> dictionary = new Dictionary<TKey, TElement>(num, comparer);
			foreach (TSource item in source)
			{
				dictionary.Add(keySelector(item), elementSelector(item));
			}
			return dictionary;
		}

		private static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(TSource[] source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			Dictionary<TKey, TElement> dictionary = new Dictionary<TKey, TElement>(source.Length, comparer);
			for (int i = 0; i < source.Length; i++)
			{
				dictionary.Add(keySelector(source[i]), elementSelector(source[i]));
			}
			return dictionary;
		}

		private static Dictionary<TKey, TElement> ToDictionary<TSource, TKey, TElement>(List<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			Dictionary<TKey, TElement> dictionary = new Dictionary<TKey, TElement>(source.Count, comparer);
			foreach (TSource item in source)
			{
				dictionary.Add(keySelector(item), elementSelector(item));
			}
			return dictionary;
		}

		/// <summary>Creates a <see cref="T:System.Collections.Generic.HashSet`1" /> from an <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
		/// <param name="source">
		///       An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to create a <see cref="T:System.Collections.Generic.HashSet`1" /> from.
		///     </param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>A <see cref="T:System.Collections.Generic.HashSet`1" /> that contains values of type TSource selected from the input sequence.</returns>
		public static HashSet<TSource> ToHashSet<TSource>(this IEnumerable<TSource> source)
		{
			return source.ToHashSet(null);
		}

		/// <summary>Creates a <see cref="T:System.Collections.Generic.HashSet`1" /> from an <see cref="T:System.Collections.Generic.IEnumerable`1" /> using the <paramref name="comparer" /> to compare keys</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to create a <see cref="T:System.Collections.Generic.HashSet`1" /> from.</param>
		/// <param name="comparer">An <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare keys.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" /></typeparam>
		/// <returns>A <see cref="T:System.Collections.Generic.HashSet`1" /> that contains values of type <paramref name="TSource" /> selected from the input sequence.</returns>
		public static HashSet<TSource> ToHashSet<TSource>(this IEnumerable<TSource> source, IEqualityComparer<TSource> comparer)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			return new HashSet<TSource>(source, comparer);
		}

		/// <summary>Produces the set union of two sequences by using the default equality comparer.</summary>
		/// <param name="first">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose distinct elements form the first set for the union.</param>
		/// <param name="second">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose distinct elements form the second set for the union.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the elements from both input sequences, excluding duplicates.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Union<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second)
		{
			return first.Union(second, null);
		}

		/// <summary>Produces the set union of two sequences by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1" />.</summary>
		/// <param name="first">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose distinct elements form the first set for the union.</param>
		/// <param name="second">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose distinct elements form the second set for the union.</param>
		/// <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> to compare values.</param>
		/// <typeparam name="TSource">The type of the elements of the input sequences.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the elements from both input sequences, excluding duplicates.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Union<TSource>(this IEnumerable<TSource> first, IEnumerable<TSource> second, IEqualityComparer<TSource> comparer)
		{
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			if (!(first is UnionIterator<TSource> unionIterator) || !Utilities.AreEqualityComparersEqual(comparer, unionIterator._comparer))
			{
				return new UnionIterator2<TSource>(first, second, comparer);
			}
			return unionIterator.Union(second);
		}

		/// <summary>Filters a sequence of values based on a predicate.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to filter.</param>
		/// <param name="predicate">A function to test each element for a condition.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from the input sequence that satisfy the condition.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Where<TSource>(this IEnumerable<TSource> source, Func<TSource, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			if (source is Iterator<TSource> iterator)
			{
				return iterator.Where(predicate);
			}
			if (source is TSource[] array)
			{
				if (array.Length != 0)
				{
					return new WhereArrayIterator<TSource>(array, predicate);
				}
				return EmptyPartition<TSource>.Instance;
			}
			if (source is List<TSource> source2)
			{
				return new WhereListIterator<TSource>(source2, predicate);
			}
			return new WhereEnumerableIterator<TSource>(source, predicate);
		}

		/// <summary>Filters a sequence of values based on a predicate. Each element's index is used in the logic of the predicate function.</summary>
		/// <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to filter.</param>
		/// <param name="predicate">A function to test each source element for a condition; the second parameter of the function represents the index of the source element.</param>
		/// <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from the input sequence that satisfy the condition.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="source" /> or <paramref name="predicate" /> is <see langword="null" />.</exception>
		public static IEnumerable<TSource> Where<TSource>(this IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			if (source == null)
			{
				throw Error.ArgumentNull("source");
			}
			if (predicate == null)
			{
				throw Error.ArgumentNull("predicate");
			}
			return WhereIterator(source, predicate);
		}

		private static IEnumerable<TSource> WhereIterator<TSource>(IEnumerable<TSource> source, Func<TSource, int, bool> predicate)
		{
			int index = -1;
			foreach (TSource item in source)
			{
				index = checked(index + 1);
				if (predicate(item, index))
				{
					yield return item;
				}
			}
		}

		/// <summary>Applies a specified function to the corresponding elements of two sequences, producing a sequence of the results.</summary>
		/// <param name="first">The first sequence to merge.</param>
		/// <param name="second">The second sequence to merge.</param>
		/// <param name="resultSelector">A function that specifies how to merge the elements from the two sequences.</param>
		/// <typeparam name="TFirst">The type of the elements of the first input sequence.</typeparam>
		/// <typeparam name="TSecond">The type of the elements of the second input sequence.</typeparam>
		/// <typeparam name="TResult">The type of the elements of the result sequence.</typeparam>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains merged elements of two input sequences.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="first" /> or <paramref name="second" /> is <see langword="null" />.</exception>
		public static IEnumerable<TResult> Zip<TFirst, TSecond, TResult>(this IEnumerable<TFirst> first, IEnumerable<TSecond> second, Func<TFirst, TSecond, TResult> resultSelector)
		{
			if (first == null)
			{
				throw Error.ArgumentNull("first");
			}
			if (second == null)
			{
				throw Error.ArgumentNull("second");
			}
			if (resultSelector == null)
			{
				throw Error.ArgumentNull("resultSelector");
			}
			return ZipIterator(first, second, resultSelector);
		}

		private static IEnumerable<TResult> ZipIterator<TFirst, TSecond, TResult>(IEnumerable<TFirst> first, IEnumerable<TSecond> second, Func<TFirst, TSecond, TResult> resultSelector)
		{
			using IEnumerator<TFirst> e1 = first.GetEnumerator();
			using IEnumerator<TSecond> e2 = second.GetEnumerator();
			while (e1.MoveNext() && e2.MoveNext())
			{
				yield return resultSelector(e1.Current, e2.Current);
			}
		}
	}
	internal readonly struct Buffer<TElement>
	{
		internal readonly TElement[] _items;

		internal readonly int _count;

		internal Buffer(IEnumerable<TElement> source)
		{
			if (source is IIListProvider<TElement> iIListProvider)
			{
				_count = (_items = iIListProvider.ToArray()).Length;
			}
			else
			{
				_items = EnumerableHelpers.ToArray(source, out _count);
			}
		}
	}
	internal sealed class SystemCore_EnumerableDebugView<T>
	{
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private IEnumerable<T> _enumerable;

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		public T[] Items
		{
			get
			{
				T[] array = _enumerable.ToArray();
				if (array.Length == 0)
				{
					throw new SystemCore_EnumerableDebugViewEmptyException();
				}
				return array;
			}
		}

		public SystemCore_EnumerableDebugView(IEnumerable<T> enumerable)
		{
			_enumerable = enumerable ?? throw Error.ArgumentNull("enumerable");
		}
	}
	internal sealed class SystemCore_EnumerableDebugViewEmptyException : Exception
	{
		public string Empty => "Enumeration yielded no results";
	}
	internal sealed class SystemCore_EnumerableDebugView
	{
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private IEnumerable _enumerable;

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		public object[] Items
		{
			get
			{
				List<object> list = new List<object>();
				foreach (object item in _enumerable)
				{
					list.Add(item);
				}
				if (list.Count == 0)
				{
					throw new SystemCore_EnumerableDebugViewEmptyException();
				}
				return list.ToArray();
			}
		}

		public SystemCore_EnumerableDebugView(IEnumerable enumerable)
		{
			_enumerable = enumerable ?? throw Error.ArgumentNull("enumerable");
		}
	}
	internal sealed class SystemLinq_GroupingDebugView<TKey, TElement>
	{
		private readonly Grouping<TKey, TElement> _grouping;

		private TElement[] _cachedValues;

		public TKey Key => _grouping.Key;

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		public TElement[] Values => _cachedValues ?? (_cachedValues = _grouping.ToArray());

		public SystemLinq_GroupingDebugView(Grouping<TKey, TElement> grouping)
		{
			_grouping = grouping;
		}
	}
	internal sealed class SystemLinq_LookupDebugView<TKey, TElement>
	{
		private readonly Lookup<TKey, TElement> _lookup;

		private IGrouping<TKey, TElement>[] _cachedGroupings;

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		public IGrouping<TKey, TElement>[] Groupings => _cachedGroupings ?? (_cachedGroupings = _lookup.ToArray());

		public SystemLinq_LookupDebugView(Lookup<TKey, TElement> lookup)
		{
			_lookup = lookup;
		}
	}
	/// <summary>Represents a collection of objects that have a common key.</summary>
	/// <typeparam name="TKey">The type of the key of the <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
	/// <typeparam name="TElement">The type of the values in the <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
	public interface IGrouping<out TKey, out TElement> : IEnumerable<TElement>, IEnumerable
	{
		/// <summary>Gets the key of the <see cref="T:System.Linq.IGrouping`2" />.</summary>
		/// <returns>The key of the <see cref="T:System.Linq.IGrouping`2" />.</returns>
		TKey Key { get; }
	}
	[DebuggerDisplay("Key = {Key}")]
	[DebuggerTypeProxy(typeof(SystemLinq_GroupingDebugView<, >))]
	internal class Grouping<TKey, TElement> : IGrouping<TKey, TElement>, IEnumerable<TElement>, IEnumerable, IList<TElement>, ICollection<TElement>
	{
		internal TKey _key;

		internal int _hashCode;

		internal TElement[] _elements;

		internal int _count;

		internal Grouping<TKey, TElement> _hashNext;

		internal Grouping<TKey, TElement> _next;

		public TKey Key => _key;

		int ICollection<TElement>.Count => _count;

		bool ICollection<TElement>.IsReadOnly => true;

		TElement IList<TElement>.this[int index]
		{
			get
			{
				if (index < 0 || index >= _count)
				{
					throw Error.ArgumentOutOfRange("index");
				}
				return _elements[index];
			}
			set
			{
				throw Error.NotSupported();
			}
		}

		internal Grouping()
		{
		}

		internal void Add(TElement element)
		{
			if (_elements.Length == _count)
			{
				Array.Resize(ref _elements, checked(_count * 2));
			}
			_elements[_count] = element;
			_count++;
		}

		internal void Trim()
		{
			if (_elements.Length != _count)
			{
				Array.Resize(ref _elements, _count);
			}
		}

		public IEnumerator<TElement> GetEnumerator()
		{
			for (int i = 0; i < _count; i++)
			{
				yield return _elements[i];
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		void ICollection<TElement>.Add(TElement item)
		{
			throw Error.NotSupported();
		}

		void ICollection<TElement>.Clear()
		{
			throw Error.NotSupported();
		}

		bool ICollection<TElement>.Contains(TElement item)
		{
			return Array.IndexOf(_elements, item, 0, _count) >= 0;
		}

		void ICollection<TElement>.CopyTo(TElement[] array, int arrayIndex)
		{
			Array.Copy(_elements, 0, array, arrayIndex, _count);
		}

		bool ICollection<TElement>.Remove(TElement item)
		{
			throw Error.NotSupported();
		}

		int IList<TElement>.IndexOf(TElement item)
		{
			return Array.IndexOf(_elements, item, 0, _count);
		}

		void IList<TElement>.Insert(int index, TElement item)
		{
			throw Error.NotSupported();
		}

		void IList<TElement>.RemoveAt(int index)
		{
			throw Error.NotSupported();
		}
	}
	internal sealed class GroupedResultEnumerable<TSource, TKey, TElement, TResult> : IIListProvider<TResult>, IEnumerable<TResult>, IEnumerable
	{
		private readonly IEnumerable<TSource> _source;

		private readonly Func<TSource, TKey> _keySelector;

		private readonly Func<TSource, TElement> _elementSelector;

		private readonly IEqualityComparer<TKey> _comparer;

		private readonly Func<TKey, IEnumerable<TElement>, TResult> _resultSelector;

		public GroupedResultEnumerable(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, Func<TKey, IEnumerable<TElement>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			_source = source ?? throw Error.ArgumentNull("source");
			_keySelector = keySelector ?? throw Error.ArgumentNull("keySelector");
			_elementSelector = elementSelector ?? throw Error.ArgumentNull("elementSelector");
			_comparer = comparer;
			_resultSelector = resultSelector ?? throw Error.ArgumentNull("resultSelector");
		}

		public IEnumerator<TResult> GetEnumerator()
		{
			return Lookup<TKey, TElement>.Create(_source, _keySelector, _elementSelector, _comparer).ApplyResultSelector(_resultSelector).GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public TResult[] ToArray()
		{
			return Lookup<TKey, TElement>.Create(_source, _keySelector, _elementSelector, _comparer).ToArray(_resultSelector);
		}

		public List<TResult> ToList()
		{
			return Lookup<TKey, TElement>.Create(_source, _keySelector, _elementSelector, _comparer).ToList(_resultSelector);
		}

		public int GetCount(bool onlyIfCheap)
		{
			if (!onlyIfCheap)
			{
				return Lookup<TKey, TElement>.Create(_source, _keySelector, _elementSelector, _comparer).Count;
			}
			return -1;
		}
	}
	internal sealed class GroupedResultEnumerable<TSource, TKey, TResult> : IIListProvider<TResult>, IEnumerable<TResult>, IEnumerable
	{
		private readonly IEnumerable<TSource> _source;

		private readonly Func<TSource, TKey> _keySelector;

		private readonly IEqualityComparer<TKey> _comparer;

		private readonly Func<TKey, IEnumerable<TSource>, TResult> _resultSelector;

		public GroupedResultEnumerable(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TKey, IEnumerable<TSource>, TResult> resultSelector, IEqualityComparer<TKey> comparer)
		{
			_source = source ?? throw Error.ArgumentNull("source");
			_keySelector = keySelector ?? throw Error.ArgumentNull("keySelector");
			_resultSelector = resultSelector ?? throw Error.ArgumentNull("resultSelector");
			_comparer = comparer;
		}

		public IEnumerator<TResult> GetEnumerator()
		{
			return Lookup<TKey, TSource>.Create(_source, _keySelector, _comparer).ApplyResultSelector(_resultSelector).GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public TResult[] ToArray()
		{
			return Lookup<TKey, TSource>.Create(_source, _keySelector, _comparer).ToArray(_resultSelector);
		}

		public List<TResult> ToList()
		{
			return Lookup<TKey, TSource>.Create(_source, _keySelector, _comparer).ToList(_resultSelector);
		}

		public int GetCount(bool onlyIfCheap)
		{
			if (!onlyIfCheap)
			{
				return Lookup<TKey, TSource>.Create(_source, _keySelector, _comparer).Count;
			}
			return -1;
		}
	}
	internal sealed class GroupedEnumerable<TSource, TKey, TElement> : IIListProvider<IGrouping<TKey, TElement>>, IEnumerable<IGrouping<TKey, TElement>>, IEnumerable
	{
		private readonly IEnumerable<TSource> _source;

		private readonly Func<TSource, TKey> _keySelector;

		private readonly Func<TSource, TElement> _elementSelector;

		private readonly IEqualityComparer<TKey> _comparer;

		public GroupedEnumerable(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			_source = source ?? throw Error.ArgumentNull("source");
			_keySelector = keySelector ?? throw Error.ArgumentNull("keySelector");
			_elementSelector = elementSelector ?? throw Error.ArgumentNull("elementSelector");
			_comparer = comparer;
		}

		public IEnumerator<IGrouping<TKey, TElement>> GetEnumerator()
		{
			return Lookup<TKey, TElement>.Create(_source, _keySelector, _elementSelector, _comparer).GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public IGrouping<TKey, TElement>[] ToArray()
		{
			return ((IIListProvider<IGrouping<TKey, TElement>>)Lookup<TKey, TElement>.Create(_source, _keySelector, _elementSelector, _comparer)).ToArray();
		}

		public List<IGrouping<TKey, TElement>> ToList()
		{
			return ((IIListProvider<IGrouping<TKey, TElement>>)Lookup<TKey, TElement>.Create(_source, _keySelector, _elementSelector, _comparer)).ToList();
		}

		public int GetCount(bool onlyIfCheap)
		{
			if (!onlyIfCheap)
			{
				return Lookup<TKey, TElement>.Create(_source, _keySelector, _elementSelector, _comparer).Count;
			}
			return -1;
		}
	}
	internal sealed class GroupedEnumerable<TSource, TKey> : IIListProvider<IGrouping<TKey, TSource>>, IEnumerable<IGrouping<TKey, TSource>>, IEnumerable
	{
		private readonly IEnumerable<TSource> _source;

		private readonly Func<TSource, TKey> _keySelector;

		private readonly IEqualityComparer<TKey> _comparer;

		public GroupedEnumerable(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			_source = source ?? throw Error.ArgumentNull("source");
			_keySelector = keySelector ?? throw Error.ArgumentNull("keySelector");
			_comparer = comparer;
		}

		public IEnumerator<IGrouping<TKey, TSource>> GetEnumerator()
		{
			return Lookup<TKey, TSource>.Create(_source, _keySelector, _comparer).GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public IGrouping<TKey, TSource>[] ToArray()
		{
			return ((IIListProvider<IGrouping<TKey, TSource>>)Lookup<TKey, TSource>.Create(_source, _keySelector, _comparer)).ToArray();
		}

		public List<IGrouping<TKey, TSource>> ToList()
		{
			return ((IIListProvider<IGrouping<TKey, TSource>>)Lookup<TKey, TSource>.Create(_source, _keySelector, _comparer)).ToList();
		}

		public int GetCount(bool onlyIfCheap)
		{
			if (!onlyIfCheap)
			{
				return Lookup<TKey, TSource>.Create(_source, _keySelector, _comparer).Count;
			}
			return -1;
		}
	}
	/// <summary>Defines an indexer, size property, and Boolean search method for data structures that map keys to <see cref="T:System.Collections.Generic.IEnumerable`1" /> sequences of values.</summary>
	/// <typeparam name="TKey">The type of the keys in the <see cref="T:System.Linq.ILookup`2" />.</typeparam>
	/// <typeparam name="TElement">The type of the elements in the <see cref="T:System.Collections.Generic.IEnumerable`1" /> sequences that make up the values in the <see cref="T:System.Linq.ILookup`2" />.</typeparam>
	public interface ILookup<TKey, TElement> : IEnumerable<IGrouping<TKey, TElement>>, IEnumerable
	{
		/// <summary>Gets the number of key/value collection pairs in the <see cref="T:System.Linq.ILookup`2" />.</summary>
		/// <returns>The number of key/value collection pairs in the <see cref="T:System.Linq.ILookup`2" />.</returns>
		int Count { get; }

		/// <summary>Gets the <see cref="T:System.Collections.Generic.IEnumerable`1" /> sequence of values indexed by a specified key.</summary>
		/// <param name="key">The key of the desired sequence of values.</param>
		/// <returns>The <see cref="T:System.Collections.Generic.IEnumerable`1" /> sequence of values indexed by the specified key.</returns>
		IEnumerable<TElement> this[TKey key] { get; }

		/// <summary>Determines whether a specified key exists in the <see cref="T:System.Linq.ILookup`2" />.</summary>
		/// <param name="key">The key to search for in the <see cref="T:System.Linq.ILookup`2" />.</param>
		/// <returns>
		///     <see langword="true" /> if <paramref name="key" /> is in the <see cref="T:System.Linq.ILookup`2" />; otherwise, <see langword="false" />.</returns>
		bool Contains(TKey key);
	}
	/// <summary>Represents a collection of keys each mapped to one or more values.</summary>
	/// <typeparam name="TKey">The type of the keys in the <see cref="T:System.Linq.Lookup`2" />.</typeparam>
	/// <typeparam name="TElement">The type of the elements of each <see cref="T:System.Collections.Generic.IEnumerable`1" /> value in the <see cref="T:System.Linq.Lookup`2" />.</typeparam>
	[DebuggerDisplay("Count = {Count}")]
	[DebuggerTypeProxy(typeof(SystemLinq_LookupDebugView<, >))]
	public class Lookup<TKey, TElement> : ILookup<TKey, TElement>, IEnumerable<IGrouping<TKey, TElement>>, IEnumerable, IIListProvider<IGrouping<TKey, TElement>>
	{
		private readonly IEqualityComparer<TKey> _comparer;

		private Grouping<TKey, TElement>[] _groupings;

		private Grouping<TKey, TElement> _lastGrouping;

		private int _count;

		/// <summary>Gets the number of key/value collection pairs in the <see cref="T:System.Linq.Lookup`2" />.</summary>
		/// <returns>The number of key/value collection pairs in the <see cref="T:System.Linq.Lookup`2" />.</returns>
		public int Count => _count;

		/// <summary>Gets the collection of values indexed by the specified key.</summary>
		/// <param name="key">The key of the desired collection of values.</param>
		/// <returns>The collection of values indexed by the specified key.</returns>
		public IEnumerable<TElement> this[TKey key]
		{
			get
			{
				Grouping<TKey, TElement> grouping = GetGrouping(key, create: false);
				if (grouping != null)
				{
					return grouping;
				}
				return Array.Empty<TElement>();
			}
		}

		internal static Lookup<TKey, TElement> Create<TSource>(IEnumerable<TSource> source, Func<TSource, TKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TKey> comparer)
		{
			Lookup<TKey, TElement> lookup = new Lookup<TKey, TElement>(comparer);
			foreach (TSource item in source)
			{
				lookup.GetGrouping(keySelector(item), create: true).Add(elementSelector(item));
			}
			return lookup;
		}

		internal static Lookup<TKey, TElement> Create(IEnumerable<TElement> source, Func<TElement, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			Lookup<TKey, TElement> lookup = new Lookup<TKey, TElement>(comparer);
			foreach (TElement item in source)
			{
				lookup.GetGrouping(keySelector(item), create: true).Add(item);
			}
			return lookup;
		}

		internal static Lookup<TKey, TElement> CreateForJoin(IEnumerable<TElement> source, Func<TElement, TKey> keySelector, IEqualityComparer<TKey> comparer)
		{
			Lookup<TKey, TElement> lookup = new Lookup<TKey, TElement>(comparer);
			foreach (TElement item in source)
			{
				TKey val = keySelector(item);
				if (val != null)
				{
					lookup.GetGrouping(val, create: true).Add(item);
				}
			}
			return lookup;
		}

		private Lookup(IEqualityComparer<TKey> comparer)
		{
			_comparer = comparer ?? EqualityComparer<TKey>.Default;
			_groupings = new Grouping<TKey, TElement>[7];
		}

		/// <summary>Determines whether a specified key is in the <see cref="T:System.Linq.Lookup`2" />.</summary>
		/// <param name="key">The key to find in the <see cref="T:System.Linq.Lookup`2" />.</param>
		/// <returns>
		///     <see langword="true" /> if <paramref name="key" /> is in the <see cref="T:System.Linq.Lookup`2" />; otherwise, <see langword="false" />.</returns>
		public bool Contains(TKey key)
		{
			return GetGrouping(key, create: false) != null;
		}

		/// <summary>Returns a generic enumerator that iterates through the <see cref="T:System.Linq.Lookup`2" />.</summary>
		/// <returns>An enumerator for the <see cref="T:System.Linq.Lookup`2" />.</returns>
		public IEnumerator<IGrouping<TKey, TElement>> GetEnumerator()
		{
			Grouping<TKey, TElement> g = _lastGrouping;
			if (g != null)
			{
				do
				{
					g = g._next;
					yield return g;
				}
				while (g != _lastGrouping);
			}
		}

		IGrouping<TKey, TElement>[] IIListProvider<IGrouping<TKey, TElement>>.ToArray()
		{
			IGrouping<TKey, TElement>[] array = new IGrouping<TKey, TElement>[_count];
			int num = 0;
			Grouping<TKey, TElement> grouping = _lastGrouping;
			if (grouping != null)
			{
				do
				{
					grouping = (Grouping<TKey, TElement>)(array[num] = grouping._next);
					num++;
				}
				while (grouping != _lastGrouping);
			}
			return array;
		}

		internal TResult[] ToArray<TResult>(Func<TKey, IEnumerable<TElement>, TResult> resultSelector)
		{
			TResult[] array = new TResult[_count];
			int num = 0;
			Grouping<TKey, TElement> grouping = _lastGrouping;
			if (grouping != null)
			{
				do
				{
					grouping = grouping._next;
					grouping.Trim();
					array[num] = resultSelector(grouping._key, grouping._elements);
					num++;
				}
				while (grouping != _lastGrouping);
			}
			return array;
		}

		List<IGrouping<TKey, TElement>> IIListProvider<IGrouping<TKey, TElement>>.ToList()
		{
			List<IGrouping<TKey, TElement>> list = new List<IGrouping<TKey, TElement>>(_count);
			Grouping<TKey, TElement> grouping = _lastGrouping;
			if (grouping != null)
			{
				do
				{
					grouping = grouping._next;
					list.Add(grouping);
				}
				while (grouping != _lastGrouping);
			}
			return list;
		}

		internal List<TResult> ToList<TResult>(Func<TKey, IEnumerable<TElement>, TResult> resultSelector)
		{
			List<TResult> list = new List<TResult>(_count);
			Grouping<TKey, TElement> grouping = _lastGrouping;
			if (grouping != null)
			{
				do
				{
					grouping = grouping._next;
					grouping.Trim();
					list.Add(resultSelector(grouping._key, grouping._elements));
				}
				while (grouping != _lastGrouping);
			}
			return list;
		}

		int IIListProvider<IGrouping<TKey, TElement>>.GetCount(bool onlyIfCheap)
		{
			return _count;
		}

		/// <summary>Applies a transform function to each key and its associated values and returns the results.</summary>
		/// <param name="resultSelector">A function to project a result value from each key and its associated values.</param>
		/// <typeparam name="TResult">The type of the result values produced by <paramref name="resultSelector" />.</typeparam>
		/// <returns>A collection that contains one value for each key/value collection pair in the <see cref="T:System.Linq.Lookup`2" />.</returns>
		public IEnumerable<TResult> ApplyResultSelector<TResult>(Func<TKey, IEnumerable<TElement>, TResult> resultSelector)
		{
			Grouping<TKey, TElement> g = _lastGrouping;
			if (g != null)
			{
				do
				{
					g = g._next;
					g.Trim();
					yield return resultSelector(g._key, g._elements);
				}
				while (g != _lastGrouping);
			}
		}

		/// <summary>Returns an enumerator that iterates through the <see cref="T:System.Linq.Lookup`2" />. This class cannot be inherited.</summary>
		/// <returns>An enumerator for the <see cref="T:System.Linq.Lookup`2" />.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		private int InternalGetHashCode(TKey key)
		{
			if (key != null)
			{
				return _comparer.GetHashCode(key) & 0x7FFFFFFF;
			}
			return 0;
		}

		internal Grouping<TKey, TElement> GetGrouping(TKey key, bool create)
		{
			int num = InternalGetHashCode(key);
			for (Grouping<TKey, TElement> grouping = _groupings[num % _groupings.Length]; grouping != null; grouping = grouping._hashNext)
			{
				if (grouping._hashCode == num && _comparer.Equals(grouping._key, key))
				{
					return grouping;
				}
			}
			if (create)
			{
				if (_count == _groupings.Length)
				{
					Resize();
				}
				int num2 = num % _groupings.Length;
				Grouping<TKey, TElement> grouping2 = new Grouping<TKey, TElement>();
				grouping2._key = key;
				grouping2._hashCode = num;
				grouping2._elements = new TElement[1];
				grouping2._hashNext = _groupings[num2];
				_groupings[num2] = grouping2;
				if (_lastGrouping == null)
				{
					grouping2._next = grouping2;
				}
				else
				{
					grouping2._next = _lastGrouping._next;
					_lastGrouping._next = grouping2;
				}
				_lastGrouping = grouping2;
				_count++;
				return grouping2;
			}
			return null;
		}

		private void Resize()
		{
			int num = checked(_count * 2 + 1);
			Grouping<TKey, TElement>[] array = new Grouping<TKey, TElement>[num];
			Grouping<TKey, TElement> grouping = _lastGrouping;
			do
			{
				grouping = grouping._next;
				int num2 = grouping._hashCode % num;
				grouping._hashNext = array[num2];
				array[num2] = grouping;
			}
			while (grouping != _lastGrouping);
			_groupings = array;
		}

		internal Lookup()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents a sorted sequence.</summary>
	/// <typeparam name="TElement">The type of the elements of the sequence.</typeparam>
	public interface IOrderedEnumerable<out TElement> : IEnumerable<TElement>, IEnumerable
	{
		/// <summary>Performs a subsequent ordering on the elements of an <see cref="T:System.Linq.IOrderedEnumerable`1" /> according to a key.</summary>
		/// <param name="keySelector">The <see cref="T:System.Func`2" /> used to extract the key for each element.</param>
		/// <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1" /> used to compare keys for placement in the returned sequence.</param>
		/// <param name="descending">
		///       <see langword="true" /> to sort the elements in descending order; <see langword="false" /> to sort the elements in ascending order.</param>
		/// <typeparam name="TKey">The type of the key produced by <paramref name="keySelector" />.</typeparam>
		/// <returns>An <see cref="T:System.Linq.IOrderedEnumerable`1" /> whose elements are sorted according to a key.</returns>
		IOrderedEnumerable<TElement> CreateOrderedEnumerable<TKey>(Func<TElement, TKey> keySelector, IComparer<TKey> comparer, bool descending);
	}
	internal abstract class OrderedEnumerable<TElement> : IOrderedEnumerable<TElement>, IEnumerable<TElement>, IEnumerable, IPartition<TElement>, IIListProvider<TElement>
	{
		internal IEnumerable<TElement> _source;

		private int[] SortedMap(Buffer<TElement> buffer)
		{
			return GetEnumerableSorter().Sort(buffer._items, buffer._count);
		}

		private int[] SortedMap(Buffer<TElement> buffer, int minIdx, int maxIdx)
		{
			return GetEnumerableSorter().Sort(buffer._items, buffer._count, minIdx, maxIdx);
		}

		public IEnumerator<TElement> GetEnumerator()
		{
			Buffer<TElement> buffer = new Buffer<TElement>(_source);
			if (buffer._count > 0)
			{
				int[] map = SortedMap(buffer);
				for (int i = 0; i < buffer._count; i++)
				{
					yield return buffer._items[map[i]];
				}
			}
		}

		public TElement[] ToArray()
		{
			Buffer<TElement> buffer = new Buffer<TElement>(_source);
			int count = buffer._count;
			if (count == 0)
			{
				return buffer._items;
			}
			TElement[] array = new TElement[count];
			int[] array2 = SortedMap(buffer);
			for (int i = 0; i != array.Length; i++)
			{
				array[i] = buffer._items[array2[i]];
			}
			return array;
		}

		public List<TElement> ToList()
		{
			Buffer<TElement> buffer = new Buffer<TElement>(_source);
			int count = buffer._count;
			List<TElement> list = new List<TElement>(count);
			if (count > 0)
			{
				int[] array = SortedMap(buffer);
				for (int i = 0; i != count; i++)
				{
					list.Add(buffer._items[array[i]]);
				}
			}
			return list;
		}

		public int GetCount(bool onlyIfCheap)
		{
			if (_source is IIListProvider<TElement> iIListProvider)
			{
				return iIListProvider.GetCount(onlyIfCheap);
			}
			if (onlyIfCheap && !(_source is ICollection<TElement>) && !(_source is ICollection))
			{
				return -1;
			}
			return _source.Count();
		}

		internal IEnumerator<TElement> GetEnumerator(int minIdx, int maxIdx)
		{
			Buffer<TElement> buffer = new Buffer<TElement>(_source);
			int count = buffer._count;
			if (count <= minIdx)
			{
				yield break;
			}
			if (count <= maxIdx)
			{
				maxIdx = count - 1;
			}
			if (minIdx == maxIdx)
			{
				yield return GetEnumerableSorter().ElementAt(buffer._items, count, minIdx);
				yield break;
			}
			int[] map = SortedMap(buffer, minIdx, maxIdx);
			while (minIdx <= maxIdx)
			{
				yield return buffer._items[map[minIdx]];
				int num = minIdx + 1;
				minIdx = num;
			}
		}

		internal TElement[] ToArray(int minIdx, int maxIdx)
		{
			Buffer<TElement> buffer = new Buffer<TElement>(_source);
			int count = buffer._count;
			if (count <= minIdx)
			{
				return Array.Empty<TElement>();
			}
			if (count <= maxIdx)
			{
				maxIdx = count - 1;
			}
			if (minIdx == maxIdx)
			{
				return new TElement[1] { GetEnumerableSorter().ElementAt(buffer._items, count, minIdx) };
			}
			int[] array = SortedMap(buffer, minIdx, maxIdx);
			TElement[] array2 = new TElement[maxIdx - minIdx + 1];
			int num = 0;
			while (minIdx <= maxIdx)
			{
				array2[num] = buffer._items[array[minIdx]];
				num++;
				minIdx++;
			}
			return array2;
		}

		internal List<TElement> ToList(int minIdx, int maxIdx)
		{
			Buffer<TElement> buffer = new Buffer<TElement>(_source);
			int count = buffer._count;
			if (count <= minIdx)
			{
				return new List<TElement>();
			}
			if (count <= maxIdx)
			{
				maxIdx = count - 1;
			}
			if (minIdx == maxIdx)
			{
				return new List<TElement>(1) { GetEnumerableSorter().ElementAt(buffer._items, count, minIdx) };
			}
			int[] array = SortedMap(buffer, minIdx, maxIdx);
			List<TElement> list = new List<TElement>(maxIdx - minIdx + 1);
			while (minIdx <= maxIdx)
			{
				list.Add(buffer._items[array[minIdx]]);
				minIdx++;
			}
			return list;
		}

		internal int GetCount(int minIdx, int maxIdx, bool onlyIfCheap)
		{
			int count = GetCount(onlyIfCheap);
			if (count <= 0)
			{
				return count;
			}
			if (count <= minIdx)
			{
				return 0;
			}
			return ((count <= maxIdx) ? count : (maxIdx + 1)) - minIdx;
		}

		private EnumerableSorter<TElement> GetEnumerableSorter()
		{
			return GetEnumerableSorter(null);
		}

		internal abstract EnumerableSorter<TElement> GetEnumerableSorter(EnumerableSorter<TElement> next);

		private CachingComparer<TElement> GetComparer()
		{
			return GetComparer(null);
		}

		internal abstract CachingComparer<TElement> GetComparer(CachingComparer<TElement> childComparer);

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		IOrderedEnumerable<TElement> IOrderedEnumerable<TElement>.CreateOrderedEnumerable<TKey>(Func<TElement, TKey> keySelector, IComparer<TKey> comparer, bool descending)
		{
			return new OrderedEnumerable<TElement, TKey>(_source, keySelector, comparer, descending, this);
		}

		public IPartition<TElement> Skip(int count)
		{
			return new OrderedPartition<TElement>(this, count, int.MaxValue);
		}

		public IPartition<TElement> Take(int count)
		{
			return new OrderedPartition<TElement>(this, 0, count - 1);
		}

		public TElement TryGetElementAt(int index, out bool found)
		{
			if (index == 0)
			{
				return TryGetFirst(out found);
			}
			if (index > 0)
			{
				Buffer<TElement> buffer = new Buffer<TElement>(_source);
				int count = buffer._count;
				if (index < count)
				{
					found = true;
					return GetEnumerableSorter().ElementAt(buffer._items, count, index);
				}
			}
			found = false;
			return default(TElement);
		}

		public TElement TryGetFirst(out bool found)
		{
			CachingComparer<TElement> comparer = GetComparer();
			using IEnumerator<TElement> enumerator = _source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				found = false;
				return default(TElement);
			}
			TElement val = enumerator.Current;
			comparer.SetElement(val);
			while (enumerator.MoveNext())
			{
				TElement current = enumerator.Current;
				if (comparer.Compare(current, cacheLower: true) < 0)
				{
					val = current;
				}
			}
			found = true;
			return val;
		}

		public TElement TryGetFirst(Func<TElement, bool> predicate, out bool found)
		{
			CachingComparer<TElement> comparer = GetComparer();
			using IEnumerator<TElement> enumerator = _source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				TElement val = enumerator.Current;
				if (!predicate(val))
				{
					continue;
				}
				comparer.SetElement(val);
				while (enumerator.MoveNext())
				{
					TElement current = enumerator.Current;
					if (predicate(current) && comparer.Compare(current, cacheLower: true) < 0)
					{
						val = current;
					}
				}
				found = true;
				return val;
			}
			found = false;
			return default(TElement);
		}

		public TElement TryGetLast(out bool found)
		{
			using IEnumerator<TElement> enumerator = _source.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				found = false;
				return default(TElement);
			}
			CachingComparer<TElement> comparer = GetComparer();
			TElement val = enumerator.Current;
			comparer.SetElement(val);
			while (enumerator.MoveNext())
			{
				TElement current = enumerator.Current;
				if (comparer.Compare(current, cacheLower: false) >= 0)
				{
					val = current;
				}
			}
			found = true;
			return val;
		}

		public TElement TryGetLast(int minIdx, int maxIdx, out bool found)
		{
			Buffer<TElement> buffer = new Buffer<TElement>(_source);
			int count = buffer._count;
			if (minIdx >= count)
			{
				found = false;
				return default(TElement);
			}
			found = true;
			if (maxIdx >= count - 1)
			{
				return Last(buffer);
			}
			return GetEnumerableSorter().ElementAt(buffer._items, count, maxIdx);
		}

		private TElement Last(Buffer<TElement> buffer)
		{
			CachingComparer<TElement> comparer = GetComparer();
			TElement[] items = buffer._items;
			int count = buffer._count;
			TElement val = items[0];
			comparer.SetElement(val);
			for (int i = 1; i != count; i++)
			{
				TElement val2 = items[i];
				if (comparer.Compare(val2, cacheLower: false) >= 0)
				{
					val = val2;
				}
			}
			return val;
		}

		public TElement TryGetLast(Func<TElement, bool> predicate, out bool found)
		{
			CachingComparer<TElement> comparer = GetComparer();
			using IEnumerator<TElement> enumerator = _source.GetEnumerator();
			while (enumerator.MoveNext())
			{
				TElement val = enumerator.Current;
				if (!predicate(val))
				{
					continue;
				}
				comparer.SetElement(val);
				while (enumerator.MoveNext())
				{
					TElement current = enumerator.Current;
					if (predicate(current) && comparer.Compare(current, cacheLower: false) >= 0)
					{
						val = current;
					}
				}
				found = true;
				return val;
			}
			found = false;
			return default(TElement);
		}
	}
	internal sealed class OrderedEnumerable<TElement, TKey> : OrderedEnumerable<TElement>
	{
		private readonly OrderedEnumerable<TElement> _parent;

		private readonly Func<TElement, TKey> _keySelector;

		private readonly IComparer<TKey> _comparer;

		private readonly bool _descending;

		internal OrderedEnumerable(IEnumerable<TElement> source, Func<TElement, TKey> keySelector, IComparer<TKey> comparer, bool descending, OrderedEnumerable<TElement> parent)
		{
			_source = source ?? throw Error.ArgumentNull("source");
			_parent = parent;
			_keySelector = keySelector ?? throw Error.ArgumentNull("keySelector");
			_comparer = comparer ?? Comparer<TKey>.Default;
			_descending = descending;
		}

		internal override EnumerableSorter<TElement> GetEnumerableSorter(EnumerableSorter<TElement> next)
		{
			EnumerableSorter<TElement> enumerableSorter = new EnumerableSorter<TElement, TKey>(_keySelector, _comparer, _descending, next);
			if (_parent != null)
			{
				enumerableSorter = _parent.GetEnumerableSorter(enumerableSorter);
			}
			return enumerableSorter;
		}

		internal override CachingComparer<TElement> GetComparer(CachingComparer<TElement> childComparer)
		{
			CachingComparer<TElement> cachingComparer = ((childComparer == null) ? new CachingComparer<TElement, TKey>(_keySelector, _comparer, _descending) : new CachingComparerWithChild<TElement, TKey>(_keySelector, _comparer, _descending, childComparer));
			if (_parent == null)
			{
				return cachingComparer;
			}
			return _parent.GetComparer(cachingComparer);
		}
	}
	internal abstract class CachingComparer<TElement>
	{
		internal abstract int Compare(TElement element, bool cacheLower);

		internal abstract void SetElement(TElement element);
	}
	internal class CachingComparer<TElement, TKey> : CachingComparer<TElement>
	{
		protected readonly Func<TElement, TKey> _keySelector;

		protected readonly IComparer<TKey> _comparer;

		protected readonly bool _descending;

		protected TKey _lastKey;

		public CachingComparer(Func<TElement, TKey> keySelector, IComparer<TKey> comparer, bool descending)
		{
			_keySelector = keySelector;
			_comparer = comparer;
			_descending = descending;
		}

		internal override int Compare(TElement element, bool cacheLower)
		{
			TKey val = _keySelector(element);
			int num = (_descending ? _comparer.Compare(_lastKey, val) : _comparer.Compare(val, _lastKey));
			if (cacheLower == num < 0)
			{
				_lastKey = val;
			}
			return num;
		}

		internal override void SetElement(TElement element)
		{
			_lastKey = _keySelector(element);
		}
	}
	internal sealed class CachingComparerWithChild<TElement, TKey> : CachingComparer<TElement, TKey>
	{
		private readonly CachingComparer<TElement> _child;

		public CachingComparerWithChild(Func<TElement, TKey> keySelector, IComparer<TKey> comparer, bool descending, CachingComparer<TElement> child)
			: base(keySelector, comparer, descending)
		{
			_child = child;
		}

		internal override int Compare(TElement element, bool cacheLower)
		{
			TKey val = _keySelector(element);
			int num = (_descending ? _comparer.Compare(_lastKey, val) : _comparer.Compare(val, _lastKey));
			if (num == 0)
			{
				return _child.Compare(element, cacheLower);
			}
			if (cacheLower == num < 0)
			{
				_lastKey = val;
				_child.SetElement(element);
			}
			return num;
		}

		internal override void SetElement(TElement element)
		{
			base.SetElement(element);
			_child.SetElement(element);
		}
	}
	internal abstract class EnumerableSorter<TElement>
	{
		internal abstract void ComputeKeys(TElement[] elements, int count);

		internal abstract int CompareAnyKeys(int index1, int index2);

		private int[] ComputeMap(TElement[] elements, int count)
		{
			ComputeKeys(elements, count);
			int[] array = new int[count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = i;
			}
			return array;
		}

		internal int[] Sort(TElement[] elements, int count)
		{
			int[] array = ComputeMap(elements, count);
			QuickSort(array, 0, count - 1);
			return array;
		}

		internal int[] Sort(TElement[] elements, int count, int minIdx, int maxIdx)
		{
			int[] array = ComputeMap(elements, count);
			PartialQuickSort(array, 0, count - 1, minIdx, maxIdx);
			return array;
		}

		internal TElement ElementAt(TElement[] elements, int count, int idx)
		{
			return elements[QuickSelect(ComputeMap(elements, count), count - 1, idx)];
		}

		protected abstract void QuickSort(int[] map, int left, int right);

		protected abstract void PartialQuickSort(int[] map, int left, int right, int minIdx, int maxIdx);

		protected abstract int QuickSelect(int[] map, int right, int idx);
	}
	internal sealed class EnumerableSorter<TElement, TKey> : EnumerableSorter<TElement>
	{
		private readonly Func<TElement, TKey> _keySelector;

		private readonly IComparer<TKey> _comparer;

		private readonly bool _descending;

		private readonly EnumerableSorter<TElement> _next;

		private TKey[] _keys;

		internal EnumerableSorter(Func<TElement, TKey> keySelector, IComparer<TKey> comparer, bool descending, EnumerableSorter<TElement> next)
		{
			_keySelector = keySelector;
			_comparer = comparer;
			_descending = descending;
			_next = next;
		}

		internal override void ComputeKeys(TElement[] elements, int count)
		{
			_keys = new TKey[count];
			for (int i = 0; i < count; i++)
			{
				_keys[i] = _keySelector(elements[i]);
			}
			_next?.ComputeKeys(elements, count);
		}

		internal override int CompareAnyKeys(int index1, int index2)
		{
			int num = _comparer.Compare(_keys[index1], _keys[index2]);
			if (num == 0)
			{
				if (_next == null)
				{
					return index1 - index2;
				}
				return _next.CompareAnyKeys(index1, index2);
			}
			if (_descending == num > 0)
			{
				return -1;
			}
			return 1;
		}

		private int CompareKeys(int index1, int index2)
		{
			if (index1 != index2)
			{
				return CompareAnyKeys(index1, index2);
			}
			return 0;
		}

		protected override void QuickSort(int[] keys, int lo, int hi)
		{
			Array.Sort(keys, lo, hi - lo + 1, Comparer<int>.Create(CompareAnyKeys));
		}

		protected override void PartialQuickSort(int[] map, int left, int right, int minIdx, int maxIdx)
		{
			do
			{
				int num = left;
				int num2 = right;
				int index = map[num + (num2 - num >> 1)];
				while (true)
				{
					if (num < map.Length && CompareKeys(index, map[num]) > 0)
					{
						num++;
						continue;
					}
					while (num2 >= 0 && CompareKeys(index, map[num2]) < 0)
					{
						num2--;
					}
					if (num > num2)
					{
						break;
					}
					if (num < num2)
					{
						int num3 = map[num];
						map[num] = map[num2];
						map[num2] = num3;
					}
					num++;
					num2--;
					if (num > num2)
					{
						break;
					}
				}
				if (minIdx >= num)
				{
					left = num + 1;
				}
				else if (maxIdx <= num2)
				{
					right = num2 - 1;
				}
				if (num2 - left <= right - num)
				{
					if (left < num2)
					{
						PartialQuickSort(map, left, num2, minIdx, maxIdx);
					}
					left = num;
				}
				else
				{
					if (num < right)
					{
						PartialQuickSort(map, num, right, minIdx, maxIdx);
					}
					right = num2;
				}
			}
			while (left < right);
		}

		protected override int QuickSelect(int[] map, int right, int idx)
		{
			int num = 0;
			do
			{
				int num2 = num;
				int num3 = right;
				int index = map[num2 + (num3 - num2 >> 1)];
				while (true)
				{
					if (num2 < map.Length && CompareKeys(index, map[num2]) > 0)
					{
						num2++;
						continue;
					}
					while (num3 >= 0 && CompareKeys(index, map[num3]) < 0)
					{
						num3--;
					}
					if (num2 > num3)
					{
						break;
					}
					if (num2 < num3)
					{
						int num4 = map[num2];
						map[num2] = map[num3];
						map[num3] = num4;
					}
					num2++;
					num3--;
					if (num2 > num3)
					{
						break;
					}
				}
				if (num2 <= idx)
				{
					num = num2 + 1;
				}
				else
				{
					right = num3 - 1;
				}
				if (num3 - num <= right - num2)
				{
					if (num < num3)
					{
						right = num3;
					}
					num = num2;
				}
				else
				{
					if (num2 < right)
					{
						num = num2;
					}
					right = num3;
				}
			}
			while (num < right);
			return map[idx];
		}
	}
	internal interface IIListProvider<TElement> : IEnumerable<TElement>, IEnumerable
	{
		TElement[] ToArray();

		List<TElement> ToList();

		int GetCount(bool onlyIfCheap);
	}
	internal interface IPartition<TElement> : IIListProvider<TElement>, IEnumerable<TElement>, IEnumerable
	{
		IPartition<TElement> Skip(int count);

		IPartition<TElement> Take(int count);

		TElement TryGetElementAt(int index, out bool found);

		TElement TryGetFirst(out bool found);

		TElement TryGetLast(out bool found);
	}
	internal sealed class EmptyPartition<TElement> : IPartition<TElement>, IIListProvider<TElement>, IEnumerable<TElement>, IEnumerable, IEnumerator<TElement>, IDisposable, IEnumerator
	{
		public static readonly IPartition<TElement> Instance = new EmptyPartition<TElement>();

		[ExcludeFromCodeCoverage]
		public TElement Current => default(TElement);

		[ExcludeFromCodeCoverage]
		object IEnumerator.Current => default(TElement);

		private EmptyPartition()
		{
		}

		public IEnumerator<TElement> GetEnumerator()
		{
			return this;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return this;
		}

		public bool MoveNext()
		{
			return false;
		}

		void IEnumerator.Reset()
		{
			throw Error.NotSupported();
		}

		void IDisposable.Dispose()
		{
		}

		public IPartition<TElement> Skip(int count)
		{
			return this;
		}

		public IPartition<TElement> Take(int count)
		{
			return this;
		}

		public TElement TryGetElementAt(int index, out bool found)
		{
			found = false;
			return default(TElement);
		}

		public TElement TryGetFirst(out bool found)
		{
			found = false;
			return default(TElement);
		}

		public TElement TryGetLast(out bool found)
		{
			found = false;
			return default(TElement);
		}

		public TElement[] ToArray()
		{
			return Array.Empty<TElement>();
		}

		public List<TElement> ToList()
		{
			return new List<TElement>();
		}

		public int GetCount(bool onlyIfCheap)
		{
			return 0;
		}
	}
	internal sealed class OrderedPartition<TElement> : IPartition<TElement>, IIListProvider<TElement>, IEnumerable<TElement>, IEnumerable
	{
		private readonly OrderedEnumerable<TElement> _source;

		private readonly int _minIndexInclusive;

		private readonly int _maxIndexInclusive;

		public OrderedPartition(OrderedEnumerable<TElement> source, int minIdxInclusive, int maxIdxInclusive)
		{
			_source = source;
			_minIndexInclusive = minIdxInclusive;
			_maxIndexInclusive = maxIdxInclusive;
		}

		public IEnumerator<TElement> GetEnumerator()
		{
			return _source.GetEnumerator(_minIndexInclusive, _maxIndexInclusive);
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public IPartition<TElement> Skip(int count)
		{
			int num = _minIndexInclusive + count;
			if ((uint)num <= (uint)_maxIndexInclusive)
			{
				return new OrderedPartition<TElement>(_source, num, _maxIndexInclusive);
			}
			return EmptyPartition<TElement>.Instance;
		}

		public IPartition<TElement> Take(int count)
		{
			int num = _minIndexInclusive + count - 1;
			if ((uint)num >= (uint)_maxIndexInclusive)
			{
				return this;
			}
			return new OrderedPartition<TElement>(_source, _minIndexInclusive, num);
		}

		public TElement TryGetElementAt(int index, out bool found)
		{
			if ((uint)index <= (uint)(_maxIndexInclusive - _minIndexInclusive))
			{
				return _source.TryGetElementAt(index + _minIndexInclusive, out found);
			}
			found = false;
			return default(TElement);
		}

		public TElement TryGetFirst(out bool found)
		{
			return _source.TryGetElementAt(_minIndexInclusive, out found);
		}

		public TElement TryGetLast(out bool found)
		{
			return _source.TryGetLast(_minIndexInclusive, _maxIndexInclusive, out found);
		}

		public TElement[] ToArray()
		{
			return _source.ToArray(_minIndexInclusive, _maxIndexInclusive);
		}

		public List<TElement> ToList()
		{
			return _source.ToList(_minIndexInclusive, _maxIndexInclusive);
		}

		public int GetCount(bool onlyIfCheap)
		{
			return _source.GetCount(_minIndexInclusive, _maxIndexInclusive, onlyIfCheap);
		}
	}
	internal sealed class Set<TElement>
	{
		private struct Slot
		{
			internal int _hashCode;

			internal int _next;

			internal TElement _value;
		}

		private readonly IEqualityComparer<TElement> _comparer;

		private int[] _buckets;

		private Slot[] _slots;

		private int _count;

		public int Count => _count;

		public Set(IEqualityComparer<TElement> comparer)
		{
			_comparer = comparer ?? EqualityComparer<TElement>.Default;
			_buckets = new int[7];
			_slots = new Slot[7];
		}

		public bool Add(TElement value)
		{
			int num = InternalGetHashCode(value);
			for (int num2 = _buckets[num % _buckets.Length] - 1; num2 >= 0; num2 = _slots[num2]._next)
			{
				if (_slots[num2]._hashCode == num && _comparer.Equals(_slots[num2]._value, value))
				{
					return false;
				}
			}
			if (_count == _slots.Length)
			{
				Resize();
			}
			int count = _count;
			_count++;
			int num3 = num % _buckets.Length;
			_slots[count]._hashCode = num;
			_slots[count]._value = value;
			_slots[count]._next = _buckets[num3] - 1;
			_buckets[num3] = count + 1;
			return true;
		}

		public bool Remove(TElement value)
		{
			int num = InternalGetHashCode(value);
			int num2 = num % _buckets.Length;
			int num3 = -1;
			for (int num4 = _buckets[num2] - 1; num4 >= 0; num4 = _slots[num4]._next)
			{
				if (_slots[num4]._hashCode == num && _comparer.Equals(_slots[num4]._value, value))
				{
					if (num3 < 0)
					{
						_buckets[num2] = _slots[num4]._next + 1;
					}
					else
					{
						_slots[num3]._next = _slots[num4]._next;
					}
					_slots[num4]._hashCode = -1;
					_slots[num4]._value = default(TElement);
					_slots[num4]._next = -1;
					return true;
				}
				num3 = num4;
			}
			return false;
		}

		private void Resize()
		{
			int num = checked(_count * 2 + 1);
			int[] array = new int[num];
			Slot[] array2 = new Slot[num];
			Array.Copy(_slots, 0, array2, 0, _count);
			for (int i = 0; i < _count; i++)
			{
				int num2 = array2[i]._hashCode % num;
				array2[i]._next = array[num2] - 1;
				array[num2] = i + 1;
			}
			_buckets = array;
			_slots = array2;
		}

		public TElement[] ToArray()
		{
			TElement[] array = new TElement[_count];
			for (int i = 0; i != array.Length; i++)
			{
				array[i] = _slots[i]._value;
			}
			return array;
		}

		public List<TElement> ToList()
		{
			int count = _count;
			List<TElement> list = new List<TElement>(count);
			for (int i = 0; i != count; i++)
			{
				list.Add(_slots[i]._value);
			}
			return list;
		}

		public void UnionWith(IEnumerable<TElement> other)
		{
			foreach (TElement item in other)
			{
				Add(item);
			}
		}

		private int InternalGetHashCode(TElement value)
		{
			if (value != null)
			{
				return _comparer.GetHashCode(value) & 0x7FFFFFFF;
			}
			return 0;
		}
	}
	internal sealed class SingleLinkedNode<TSource>
	{
		public TSource Item { get; }

		public SingleLinkedNode<TSource> Linked { get; }

		public SingleLinkedNode(TSource item)
		{
			Item = item;
		}

		private SingleLinkedNode(SingleLinkedNode<TSource> linked, TSource item)
		{
			Linked = linked;
			Item = item;
		}

		public SingleLinkedNode<TSource> Add(TSource item)
		{
			return new SingleLinkedNode<TSource>(this, item);
		}

		public int GetCount()
		{
			int num = 0;
			for (SingleLinkedNode<TSource> singleLinkedNode = this; singleLinkedNode != null; singleLinkedNode = singleLinkedNode.Linked)
			{
				num++;
			}
			return num;
		}

		public IEnumerator<TSource> GetEnumerator(int count)
		{
			return ((IEnumerable<TSource>)ToArray(count)).GetEnumerator();
		}

		public SingleLinkedNode<TSource> GetNode(int index)
		{
			SingleLinkedNode<TSource> singleLinkedNode = this;
			while (index > 0)
			{
				singleLinkedNode = singleLinkedNode.Linked;
				index--;
			}
			return singleLinkedNode;
		}

		private TSource[] ToArray(int count)
		{
			TSource[] array = new TSource[count];
			int num = count;
			for (SingleLinkedNode<TSource> singleLinkedNode = this; singleLinkedNode != null; singleLinkedNode = singleLinkedNode.Linked)
			{
				num--;
				array[num] = singleLinkedNode.Item;
			}
			return array;
		}
	}
	internal static class Utilities
	{
		public static bool AreEqualityComparersEqual<TSource>(IEqualityComparer<TSource> left, IEqualityComparer<TSource> right)
		{
			if (left == right)
			{
				return true;
			}
			EqualityComparer<TSource> equalityComparer = EqualityComparer<TSource>.Default;
			if (left == null)
			{
				if (right != equalityComparer)
				{
					return right.Equals(equalityComparer);
				}
				return true;
			}
			if (right == null)
			{
				if (left != equalityComparer)
				{
					return left.Equals(equalityComparer);
				}
				return true;
			}
			return left.Equals(right);
		}

		public static Func<TSource, bool> CombinePredicates<TSource>(Func<TSource, bool> predicate1, Func<TSource, bool> predicate2)
		{
			return (TSource x) => predicate1(x) && predicate2(x);
		}

		public static Func<TSource, TResult> CombineSelectors<TSource, TMiddle, TResult>(Func<TSource, TMiddle> selector1, Func<TMiddle, TResult> selector2)
		{
			return (TSource x) => selector2(selector1(x));
		}
	}
}
namespace System.Linq.Parallel
{
	internal sealed class AsynchronousChannel<T> : IDisposable
	{
		private T[][] _buffer;

		private readonly int _index;

		private volatile int _producerBufferIndex;

		private volatile int _consumerBufferIndex;

		private volatile bool _done;

		private T[] _producerChunk;

		private int _producerChunkIndex;

		private T[] _consumerChunk;

		private int _consumerChunkIndex;

		private int _chunkSize;

		private ManualResetEventSlim _producerEvent;

		private IntValueEvent _consumerEvent;

		private volatile int _producerIsWaiting;

		private volatile int _consumerIsWaiting;

		private CancellationToken _cancellationToken;

		internal bool IsFull
		{
			get
			{
				int producerBufferIndex = _producerBufferIndex;
				int consumerBufferIndex = _consumerBufferIndex;
				if (producerBufferIndex != consumerBufferIndex - 1)
				{
					if (consumerBufferIndex == 0)
					{
						return producerBufferIndex == _buffer.Length - 1;
					}
					return false;
				}
				return true;
			}
		}

		internal bool IsChunkBufferEmpty => _producerBufferIndex == _consumerBufferIndex;

		internal bool IsDone => _done;

		internal AsynchronousChannel(int index, int chunkSize, CancellationToken cancellationToken, IntValueEvent consumerEvent)
			: this(index, 512, chunkSize, cancellationToken, consumerEvent)
		{
		}

		internal AsynchronousChannel(int index, int capacity, int chunkSize, CancellationToken cancellationToken, IntValueEvent consumerEvent)
		{
			if (chunkSize == 0)
			{
				chunkSize = Scheduling.GetDefaultChunkSize<T>();
			}
			_index = index;
			_buffer = new T[capacity + 1][];
			_producerBufferIndex = 0;
			_consumerBufferIndex = 0;
			_producerEvent = new ManualResetEventSlim();
			_consumerEvent = consumerEvent;
			_chunkSize = chunkSize;
			_producerChunk = new T[chunkSize];
			_producerChunkIndex = 0;
			_cancellationToken = cancellationToken;
		}

		internal void FlushBuffers()
		{
			FlushCachedChunk();
		}

		internal void SetDone()
		{
			_done = true;
			lock (this)
			{
				if (_consumerEvent != null)
				{
					_consumerEvent.Set(_index);
				}
			}
		}

		internal void Enqueue(T item)
		{
			int producerChunkIndex = _producerChunkIndex;
			_producerChunk[producerChunkIndex] = item;
			if (producerChunkIndex == _chunkSize - 1)
			{
				EnqueueChunk(_producerChunk);
				_producerChunk = new T[_chunkSize];
			}
			_producerChunkIndex = (producerChunkIndex + 1) % _chunkSize;
		}

		private void EnqueueChunk(T[] chunk)
		{
			if (IsFull)
			{
				WaitUntilNonFull();
			}
			int producerBufferIndex = _producerBufferIndex;
			_buffer[producerBufferIndex] = chunk;
			Interlocked.Exchange(ref _producerBufferIndex, (producerBufferIndex + 1) % _buffer.Length);
			if (_consumerIsWaiting == 1 && !IsChunkBufferEmpty)
			{
				_consumerIsWaiting = 0;
				_consumerEvent.Set(_index);
			}
		}

		private void WaitUntilNonFull()
		{
			do
			{
				_producerEvent.Reset();
				Interlocked.Exchange(ref _producerIsWaiting, 1);
				if (IsFull)
				{
					_producerEvent.Wait(_cancellationToken);
				}
				else
				{
					_producerIsWaiting = 0;
				}
			}
			while (IsFull);
		}

		private void FlushCachedChunk()
		{
			if (_producerChunk != null && _producerChunkIndex != 0)
			{
				T[] array = new T[_producerChunkIndex];
				Array.Copy(_producerChunk, 0, array, 0, _producerChunkIndex);
				EnqueueChunk(array);
				_producerChunk = null;
			}
		}

		internal bool TryDequeue(ref T item)
		{
			if (_consumerChunk == null)
			{
				if (!TryDequeueChunk(ref _consumerChunk))
				{
					return false;
				}
				_consumerChunkIndex = 0;
			}
			item = _consumerChunk[_consumerChunkIndex];
			_consumerChunkIndex++;
			if (_consumerChunkIndex == _consumerChunk.Length)
			{
				_consumerChunk = null;
			}
			return true;
		}

		private bool TryDequeueChunk(ref T[] chunk)
		{
			if (IsChunkBufferEmpty)
			{
				return false;
			}
			chunk = InternalDequeueChunk();
			return true;
		}

		internal bool TryDequeue(ref T item, ref bool isDone)
		{
			isDone = false;
			if (_consumerChunk == null)
			{
				if (!TryDequeueChunk(ref _consumerChunk, ref isDone))
				{
					return false;
				}
				_consumerChunkIndex = 0;
			}
			item = _consumerChunk[_consumerChunkIndex];
			_consumerChunkIndex++;
			if (_consumerChunkIndex == _consumerChunk.Length)
			{
				_consumerChunk = null;
			}
			return true;
		}

		private bool TryDequeueChunk(ref T[] chunk, ref bool isDone)
		{
			isDone = false;
			while (IsChunkBufferEmpty)
			{
				if (IsDone && IsChunkBufferEmpty)
				{
					isDone = true;
					return false;
				}
				Interlocked.Exchange(ref _consumerIsWaiting, 1);
				if (IsChunkBufferEmpty && !IsDone)
				{
					return false;
				}
				_consumerIsWaiting = 0;
			}
			chunk = InternalDequeueChunk();
			return true;
		}

		private T[] InternalDequeueChunk()
		{
			int consumerBufferIndex = _consumerBufferIndex;
			T[] result = _buffer[consumerBufferIndex];
			_buffer[consumerBufferIndex] = null;
			Interlocked.Exchange(ref _consumerBufferIndex, (consumerBufferIndex + 1) % _buffer.Length);
			if (_producerIsWaiting == 1 && !IsFull)
			{
				_producerIsWaiting = 0;
				_producerEvent.Set();
			}
			return result;
		}

		internal void DoneWithDequeueWait()
		{
			_consumerIsWaiting = 0;
		}

		public void Dispose()
		{
			lock (this)
			{
				_producerEvent.Dispose();
				_producerEvent = null;
				_consumerEvent = null;
			}
		}
	}
	internal sealed class SynchronousChannel<T>
	{
		private Queue<T> _queue;

		internal int Count => _queue.Count;

		internal SynchronousChannel()
		{
		}

		internal void Init()
		{
			_queue = new Queue<T>();
		}

		internal void Enqueue(T item)
		{
			_queue.Enqueue(item);
		}

		internal T Dequeue()
		{
			return _queue.Dequeue();
		}

		internal void SetDone()
		{
		}

		internal void CopyTo(T[] array, int arrayIndex)
		{
			_queue.CopyTo(array, arrayIndex);
		}
	}
	internal class EmptyEnumerable<T> : ParallelQuery<T>
	{
		private static volatile EmptyEnumerable<T> s_instance;

		private static volatile EmptyEnumerator<T> s_enumeratorInstance;

		internal static EmptyEnumerable<T> Instance
		{
			get
			{
				if (s_instance == null)
				{
					s_instance = new EmptyEnumerable<T>();
				}
				return s_instance;
			}
		}

		private EmptyEnumerable()
			: base(QuerySettings.Empty)
		{
		}

		public override IEnumerator<T> GetEnumerator()
		{
			if (s_enumeratorInstance == null)
			{
				s_enumeratorInstance = new EmptyEnumerator<T>();
			}
			return s_enumeratorInstance;
		}
	}
	internal class EmptyEnumerator<T> : QueryOperatorEnumerator<T, int>, IEnumerator<T>, IDisposable, IEnumerator
	{
		public T Current => default(T);

		object IEnumerator.Current => null;

		internal override bool MoveNext(ref T currentElement, ref int currentKey)
		{
			return false;
		}

		public bool MoveNext()
		{
			return false;
		}

		void IEnumerator.Reset()
		{
		}
	}
	internal class EnumerableWrapperWeakToStrong : IEnumerable<object>, IEnumerable
	{
		private class WrapperEnumeratorWeakToStrong : IEnumerator<object>, IDisposable, IEnumerator
		{
			private IEnumerator _wrappedEnumerator;

			object IEnumerator.Current => _wrappedEnumerator.Current;

			object IEnumerator<object>.Current => _wrappedEnumerator.Current;

			internal WrapperEnumeratorWeakToStrong(IEnumerator wrappedEnumerator)
			{
				_wrappedEnumerator = wrappedEnumerator;
			}

			void IDisposable.Dispose()
			{
				if (_wrappedEnumerator is IDisposable disposable)
				{
					disposable.Dispose();
				}
			}

			bool IEnumerator.MoveNext()
			{
				return _wrappedEnumerator.MoveNext();
			}

			void IEnumerator.Reset()
			{
				_wrappedEnumerator.Reset();
			}
		}

		private readonly IEnumerable _wrappedEnumerable;

		internal EnumerableWrapperWeakToStrong(IEnumerable wrappedEnumerable)
		{
			_wrappedEnumerable = wrappedEnumerable;
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<object>)this).GetEnumerator();
		}

		public IEnumerator<object> GetEnumerator()
		{
			return new WrapperEnumeratorWeakToStrong(_wrappedEnumerable.GetEnumerator());
		}
	}
	internal interface IParallelPartitionable<T>
	{
		QueryOperatorEnumerator<T, int>[] GetPartitions(int partitionCount);
	}
	internal class ParallelEnumerableWrapper : ParallelQuery<object>
	{
		private readonly IEnumerable _source;

		internal ParallelEnumerableWrapper(IEnumerable source)
			: base(QuerySettings.Empty)
		{
			_source = source;
		}

		internal override IEnumerator GetEnumeratorUntyped()
		{
			return _source.GetEnumerator();
		}

		public override IEnumerator<object> GetEnumerator()
		{
			return new EnumerableWrapperWeakToStrong(_source).GetEnumerator();
		}
	}
	internal class ParallelEnumerableWrapper<T> : ParallelQuery<T>
	{
		private readonly IEnumerable<T> _wrappedEnumerable;

		internal IEnumerable<T> WrappedEnumerable => _wrappedEnumerable;

		internal ParallelEnumerableWrapper(IEnumerable<T> wrappedEnumerable)
			: base(QuerySettings.Empty)
		{
			_wrappedEnumerable = wrappedEnumerable;
		}

		public override IEnumerator<T> GetEnumerator()
		{
			return _wrappedEnumerable.GetEnumerator();
		}
	}
	[Flags]
	internal enum QueryAggregationOptions
	{
		None = 0,
		Associative = 1,
		Commutative = 2,
		AssociativeCommutative = 3
	}
	internal static class QueryAggregationOptionsExtensions
	{
		public static bool IsValidQueryAggregationOption(this QueryAggregationOptions value)
		{
			if (value != QueryAggregationOptions.None && value != QueryAggregationOptions.Associative && value != QueryAggregationOptions.Commutative)
			{
				return value == QueryAggregationOptions.AssociativeCommutative;
			}
			return true;
		}
	}
	internal class RangeEnumerable : ParallelQuery<int>, IParallelPartitionable<int>
	{
		private class RangeEnumerator : QueryOperatorEnumerator<int, int>
		{
			private readonly int _from;

			private readonly int _count;

			private readonly int _initialIndex;

			private Shared<int> _currentCount;

			internal RangeEnumerator(int from, int count, int initialIndex)
			{
				_from = from;
				_count = count;
				_initialIndex = initialIndex;
			}

			internal override bool MoveNext(ref int currentElement, ref int currentKey)
			{
				if (_currentCount == null)
				{
					_currentCount = new Shared<int>(-1);
				}
				int num = _currentCount.Value + 1;
				if (num < _count)
				{
					_currentCount.Value = num;
					currentElement = num + _from;
					currentKey = num + _initialIndex;
					return true;
				}
				return false;
			}

			internal override void Reset()
			{
				_currentCount = null;
			}
		}

		private int _from;

		private int _count;

		internal RangeEnumerable(int from, int count)
			: base(QuerySettings.Empty)
		{
			_from = from;
			_count = count;
		}

		public QueryOperatorEnumerator<int, int>[] GetPartitions(int partitionCount)
		{
			int num = _count / partitionCount;
			int num2 = _count % partitionCount;
			int num3 = 0;
			QueryOperatorEnumerator<int, int>[] array = new QueryOperatorEnumerator<int, int>[partitionCount];
			for (int i = 0; i < partitionCount; i++)
			{
				int num4 = ((i < num2) ? (num + 1) : num);
				array[i] = new RangeEnumerator(_from + num3, num4, num3);
				num3 += num4;
			}
			return array;
		}

		public override IEnumerator<int> GetEnumerator()
		{
			return new RangeEnumerator(_from, _count, 0).AsClassicEnumerator();
		}
	}
	internal class RepeatEnumerable<TResult> : ParallelQuery<TResult>, IParallelPartitionable<TResult>
	{
		private class RepeatEnumerator : QueryOperatorEnumerator<TResult, int>
		{
			private readonly TResult _element;

			private readonly int _count;

			private readonly int _indexOffset;

			private Shared<int> _currentIndex;

			internal RepeatEnumerator(TResult element, int count, int indexOffset)
			{
				_element = element;
				_count = count;
				_indexOffset = indexOffset;
			}

			internal override bool MoveNext(ref TResult currentElement, ref int currentKey)
			{
				if (_currentIndex == null)
				{
					_currentIndex = new Shared<int>(-1);
				}
				if (_currentIndex.Value < _count - 1)
				{
					_currentIndex.Value++;
					currentElement = _element;
					currentKey = _currentIndex.Value + _indexOffset;
					return true;
				}
				return false;
			}

			internal override void Reset()
			{
				_currentIndex = null;
			}
		}

		private TResult _element;

		private int _count;

		internal RepeatEnumerable(TResult element, int count)
			: base(QuerySettings.Empty)
		{
			_element = element;
			_count = count;
		}

		public QueryOperatorEnumerator<TResult, int>[] GetPartitions(int partitionCount)
		{
			int num = (_count + partitionCount - 1) / partitionCount;
			QueryOperatorEnumerator<TResult, int>[] array = new QueryOperatorEnumerator<TResult, int>[partitionCount];
			int num2 = 0;
			int num3 = 0;
			while (num2 < partitionCount)
			{
				if (num3 + num > _count)
				{
					array[num2] = new RepeatEnumerator(_element, (num3 < _count) ? (_count - num3) : 0, num3);
				}
				else
				{
					array[num2] = new RepeatEnumerator(_element, num, num3);
				}
				num2++;
				num3 += num;
			}
			return array;
		}

		public override IEnumerator<TResult> GetEnumerator()
		{
			return new RepeatEnumerator(_element, _count, 0).AsClassicEnumerator();
		}
	}
	internal class JaggedArray<TElement>
	{
		public static TElement[][] Allocate(int size1, int size2)
		{
			TElement[][] array = new TElement[size1][];
			for (int i = 0; i < size1; i++)
			{
				array[i] = new TElement[size2];
			}
			return array;
		}
	}
	internal class Set<TElement>
	{
		internal struct Slot
		{
			internal int hashCode;

			internal int next;

			internal TElement value;
		}

		private int[] _buckets;

		private Slot[] _slots;

		private int _count;

		private readonly IEqualityComparer<TElement> _comparer;

		private const int InitialSize = 7;

		private const int HashCodeMask = int.MaxValue;

		public Set(IEqualityComparer<TElement> comparer)
		{
			if (comparer == null)
			{
				comparer = EqualityComparer<TElement>.Default;
			}
			_comparer = comparer;
			_buckets = new int[7];
			_slots = new Slot[7];
		}

		public bool Add(TElement value)
		{
			return !Find(value, add: true);
		}

		public bool Contains(TElement value)
		{
			return Find(value, add: false);
		}

		public bool Remove(TElement value)
		{
			int num = InternalGetHashCode(value);
			int num2 = num % _buckets.Length;
			int num3 = -1;
			for (int num4 = _buckets[num2] - 1; num4 >= 0; num4 = _slots[num4].next)
			{
				if (_slots[num4].hashCode == num && _comparer.Equals(_slots[num4].value, value))
				{
					if (num3 < 0)
					{
						_buckets[num2] = _slots[num4].next + 1;
					}
					else
					{
						_slots[num3].next = _slots[num4].next;
					}
					_slots[num4].hashCode = -1;
					_slots[num4].value = default(TElement);
					_slots[num4].next = -1;
					return true;
				}
				num3 = num4;
			}
			return false;
		}

		private bool Find(TElement value, bool add)
		{
			int num = InternalGetHashCode(value);
			for (int num2 = _buckets[num % _buckets.Length] - 1; num2 >= 0; num2 = _slots[num2].next)
			{
				if (_slots[num2].hashCode == num && _comparer.Equals(_slots[num2].value, value))
				{
					return true;
				}
			}
			if (add)
			{
				if (_count == _slots.Length)
				{
					Resize();
				}
				int count = _count;
				_count++;
				int num3 = num % _buckets.Length;
				_slots[count].hashCode = num;
				_slots[count].value = value;
				_slots[count].next = _buckets[num3] - 1;
				_buckets[num3] = count + 1;
			}
			return false;
		}

		private void Resize()
		{
			int num = checked(_count * 2 + 1);
			int[] array = new int[num];
			Slot[] array2 = new Slot[num];
			Array.Copy(_slots, 0, array2, 0, _count);
			for (int i = 0; i < _count; i++)
			{
				int num2 = array2[i].hashCode % num;
				array2[i].next = array[num2] - 1;
				array[num2] = i + 1;
			}
			_buckets = array;
			_slots = array2;
		}

		internal int InternalGetHashCode(TElement value)
		{
			if (value != null)
			{
				return _comparer.GetHashCode(value) & 0x7FFFFFFF;
			}
			return 0;
		}
	}
	internal class ArrayMergeHelper<TInputOutput> : IMergeHelper<TInputOutput>
	{
		private QueryResults<TInputOutput> _queryResults;

		private TInputOutput[] _outputArray;

		private QuerySettings _settings;

		public ArrayMergeHelper(QuerySettings settings, QueryResults<TInputOutput> queryResults)
		{
			_settings = settings;
			_queryResults = queryResults;
			int count = _queryResults.Count;
			_outputArray = new TInputOutput[count];
		}

		private void ToArrayElement(int index)
		{
			_outputArray[index] = _queryResults[index];
		}

		public void Execute()
		{
			new QueryExecutionOption<int>(QueryOperator<int>.AsQueryOperator(ParallelEnumerable.Range(0, _queryResults.Count)), _settings).ForAll(ToArrayElement);
		}

		[ExcludeFromCodeCoverage]
		public IEnumerator<TInputOutput> GetEnumerator()
		{
			return ((IEnumerable<TInputOutput>)GetResultsAsArray()).GetEnumerator();
		}

		public TInputOutput[] GetResultsAsArray()
		{
			return _outputArray;
		}
	}
	internal sealed class AsynchronousChannelMergeEnumerator<T> : MergeEnumerator<T>
	{
		private AsynchronousChannel<T>[] _channels;

		private IntValueEvent _consumerEvent;

		private bool[] _done;

		private int _channelIndex;

		private T _currentElement;

		public override T Current
		{
			get
			{
				if (_channelIndex == -1 || _channelIndex == _channels.Length)
				{
					throw new InvalidOperationException("Enumeration has not started. MoveNext must be called to initiate enumeration.");
				}
				return _currentElement;
			}
		}

		internal AsynchronousChannelMergeEnumerator(QueryTaskGroupState taskGroupState, AsynchronousChannel<T>[] channels, IntValueEvent consumerEvent)
			: base(taskGroupState)
		{
			_channels = channels;
			_channelIndex = -1;
			_done = new bool[_channels.Length];
			_consumerEvent = consumerEvent;
		}

		public override bool MoveNext()
		{
			int num = _channelIndex;
			if (num == -1)
			{
				num = (_channelIndex = 0);
			}
			if (num == _channels.Length)
			{
				return false;
			}
			if (!_done[num] && _channels[num].TryDequeue(ref _currentElement))
			{
				_channelIndex = (num + 1) % _channels.Length;
				return true;
			}
			return MoveNextSlowPath();
		}

		private bool MoveNextSlowPath()
		{
			int num = 0;
			int num2 = _channelIndex;
			int channelIndex;
			while ((channelIndex = _channelIndex) != _channels.Length)
			{
				AsynchronousChannel<T> asynchronousChannel = _channels[channelIndex];
				bool flag = _done[channelIndex];
				if (!flag && asynchronousChannel.TryDequeue(ref _currentElement))
				{
					_channelIndex = (channelIndex + 1) % _channels.Length;
					return true;
				}
				if (!flag && asynchronousChannel.IsDone)
				{
					if (!asynchronousChannel.IsChunkBufferEmpty)
					{
						asynchronousChannel.TryDequeue(ref _currentElement);
						return true;
					}
					_done[channelIndex] = true;
					flag = true;
					asynchronousChannel.Dispose();
				}
				if (flag && ++num == _channels.Length)
				{
					channelIndex = (_channelIndex = _channels.Length);
					break;
				}
				channelIndex = (_channelIndex = (channelIndex + 1) % _channels.Length);
				if (channelIndex != num2)
				{
					continue;
				}
				try
				{
					num = 0;
					for (int i = 0; i < _channels.Length; i++)
					{
						bool isDone = false;
						if (!_done[i] && _channels[i].TryDequeue(ref _currentElement, ref isDone))
						{
							return true;
						}
						if (isDone)
						{
							if (!_done[i])
							{
								_done[i] = true;
							}
							if (++num == _channels.Length)
							{
								channelIndex = (_channelIndex = _channels.Length);
								break;
							}
						}
					}
					if (channelIndex == _channels.Length)
					{
						break;
					}
					_consumerEvent.Wait();
					channelIndex = (_channelIndex = _consumerEvent.Value);
					_consumerEvent.Reset();
					num2 = channelIndex;
					num = 0;
					continue;
				}
				finally
				{
					for (int j = 0; j < _channels.Length; j++)
					{
						if (!_done[j])
						{
							_channels[j].DoneWithDequeueWait();
						}
					}
				}
			}
			_taskGroupState.QueryEnd(userInitiatedDispose: false);
			return false;
		}

		public override void Dispose()
		{
			if (_consumerEvent != null)
			{
				base.Dispose();
				_consumerEvent.Dispose();
				_consumerEvent = null;
			}
		}
	}
	internal class DefaultMergeHelper<TInputOutput, TIgnoreKey> : IMergeHelper<TInputOutput>
	{
		private QueryTaskGroupState _taskGroupState;

		private PartitionedStream<TInputOutput, TIgnoreKey> _partitions;

		private AsynchronousChannel<TInputOutput>[] _asyncChannels;

		private SynchronousChannel<TInputOutput>[] _syncChannels;

		private IEnumerator<TInputOutput> _channelEnumerator;

		private TaskScheduler _taskScheduler;

		private bool _ignoreOutput;

		internal DefaultMergeHelper(PartitionedStream<TInputOutput, TIgnoreKey> partitions, bool ignoreOutput, ParallelMergeOptions options, TaskScheduler taskScheduler, CancellationState cancellationState, int queryId)
		{
			_taskGroupState = new QueryTaskGroupState(cancellationState, queryId);
			_partitions = partitions;
			_taskScheduler = taskScheduler;
			_ignoreOutput = ignoreOutput;
			IntValueEvent consumerEvent = new IntValueEvent();
			if (ignoreOutput)
			{
				return;
			}
			if (options != ParallelMergeOptions.FullyBuffered)
			{
				if (partitions.PartitionCount > 1)
				{
					_asyncChannels = MergeExecutor<TInputOutput>.MakeAsynchronousChannels(partitions.PartitionCount, options, consumerEvent, cancellationState.MergedCancellationToken);
					_channelEnumerator = new AsynchronousChannelMergeEnumerator<TInputOutput>(_taskGroupState, _asyncChannels, consumerEvent);
				}
				else
				{
					_channelEnumerator = ExceptionAggregator.WrapQueryEnumerator(partitions[0], _taskGroupState.CancellationState).GetEnumerator();
				}
			}
			else
			{
				_syncChannels = MergeExecutor<TInputOutput>.MakeSynchronousChannels(partitions.PartitionCount);
				_channelEnumerator = new SynchronousChannelMergeEnumerator<TInputOutput>(_taskGroupState, _syncChannels);
			}
		}

		void IMergeHelper<TInputOutput>.Execute()
		{
			if (_asyncChannels != null)
			{
				SpoolingTask.SpoolPipeline(_taskGroupState, _partitions, _asyncChannels, _taskScheduler);
			}
			else if (_syncChannels != null)
			{
				SpoolingTask.SpoolStopAndGo(_taskGroupState, _partitions, _syncChannels, _taskScheduler);
			}
			else if (_ignoreOutput)
			{
				SpoolingTask.SpoolForAll(_taskGroupState, _partitions, _taskScheduler);
			}
		}

		IEnumerator<TInputOutput> IMergeHelper<TInputOutput>.GetEnumerator()
		{
			return _channelEnumerator;
		}

		public TInputOutput[] GetResultsAsArray()
		{
			if (_syncChannels != null)
			{
				int num = 0;
				for (int i = 0; i < _syncChannels.Length; i++)
				{
					num += _syncChannels[i].Count;
				}
				TInputOutput[] array = new TInputOutput[num];
				int num2 = 0;
				for (int j = 0; j < _syncChannels.Length; j++)
				{
					_syncChannels[j].CopyTo(array, num2);
					num2 += _syncChannels[j].Count;
				}
				return array;
			}
			List<TInputOutput> list = new List<TInputOutput>();
			foreach (TInputOutput item in (IMergeHelper<TInputOutput>)this)
			{
				list.Add(item);
			}
			return list.ToArray();
		}
	}
	internal interface IMergeHelper<TInputOutput>
	{
		void Execute();

		IEnumerator<TInputOutput> GetEnumerator();

		TInputOutput[] GetResultsAsArray();
	}
	internal abstract class MergeEnumerator<TInputOutput> : IEnumerator<TInputOutput>, IDisposable, IEnumerator
	{
		protected QueryTaskGroupState _taskGroupState;

		public abstract TInputOutput Current { get; }

		object IEnumerator.Current => ((IEnumerator<TInputOutput>)this).Current;

		protected MergeEnumerator(QueryTaskGroupState taskGroupState)
		{
			_taskGroupState = taskGroupState;
		}

		public abstract bool MoveNext();

		public virtual void Reset()
		{
		}

		public virtual void Dispose()
		{
			if (!_taskGroupState.IsAlreadyEnded)
			{
				_taskGroupState.QueryEnd(userInitiatedDispose: true);
			}
		}
	}
	internal class MergeExecutor<TInputOutput> : IEnumerable<TInputOutput>, IEnumerable
	{
		private IMergeHelper<TInputOutput> _mergeHelper;

		private MergeExecutor()
		{
		}

		internal static MergeExecutor<TInputOutput> Execute<TKey>(PartitionedStream<TInputOutput, TKey> partitions, bool ignoreOutput, ParallelMergeOptions options, TaskScheduler taskScheduler, bool isOrdered, CancellationState cancellationState, int queryId)
		{
			MergeExecutor<TInputOutput> mergeExecutor = new MergeExecutor<TInputOutput>();
			if (isOrdered && !ignoreOutput)
			{
				if (options != ParallelMergeOptions.FullyBuffered && !partitions.OrdinalIndexState.IsWorseThan(OrdinalIndexState.Increasing))
				{
					bool autoBuffered = options == ParallelMergeOptions.AutoBuffered;
					if (partitions.PartitionCount > 1)
					{
						mergeExecutor._mergeHelper = new OrderPreservingPipeliningMergeHelper<TInputOutput, TKey>(partitions, taskScheduler, cancellationState, autoBuffered, queryId, partitions.KeyComparer);
					}
					else
					{
						mergeExecutor._mergeHelper = new DefaultMergeHelper<TInputOutput, TKey>(partitions, ignoreOutput: false, options, taskScheduler, cancellationState, queryId);
					}
				}
				else
				{
					mergeExecutor._mergeHelper = new OrderPreservingMergeHelper<TInputOutput, TKey>(partitions, taskScheduler, cancellationState, queryId);
				}
			}
			else
			{
				mergeExecutor._mergeHelper = new DefaultMergeHelper<TInputOutput, TKey>(partitions, ignoreOutput, options, taskScheduler, cancellationState, queryId);
			}
			mergeExecutor.Execute();
			return mergeExecutor;
		}

		private void Execute()
		{
			_mergeHelper.Execute();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public IEnumerator<TInputOutput> GetEnumerator()
		{
			return _mergeHelper.GetEnumerator();
		}

		internal TInputOutput[] GetResultsAsArray()
		{
			return _mergeHelper.GetResultsAsArray();
		}

		internal static AsynchronousChannel<TInputOutput>[] MakeAsynchronousChannels(int partitionCount, ParallelMergeOptions options, IntValueEvent consumerEvent, CancellationToken cancellationToken)
		{
			AsynchronousChannel<TInputOutput>[] array = new AsynchronousChannel<TInputOutput>[partitionCount];
			int chunkSize = 0;
			if (options == ParallelMergeOptions.NotBuffered)
			{
				chunkSize = 1;
			}
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new AsynchronousChannel<TInputOutput>(i, chunkSize, cancellationToken, consumerEvent);
			}
			return array;
		}

		internal static SynchronousChannel<TInputOutput>[] MakeSynchronousChannels(int partitionCount)
		{
			SynchronousChannel<TInputOutput>[] array = new SynchronousChannel<TInputOutput>[partitionCount];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = new SynchronousChannel<TInputOutput>();
			}
			return array;
		}
	}
	internal class OrderPreservingMergeHelper<TInputOutput, TKey> : IMergeHelper<TInputOutput>
	{
		private QueryTaskGroupState _taskGroupState;

		private PartitionedStream<TInputOutput, TKey> _partitions;

		private Shared<TInputOutput[]> _results;

		private TaskScheduler _taskScheduler;

		internal OrderPreservingMergeHelper(PartitionedStream<TInputOutput, TKey> partitions, TaskScheduler taskScheduler, CancellationState cancellationState, int queryId)
		{
			_taskGroupState = new QueryTaskGroupState(cancellationState, queryId);
			_partitions = partitions;
			_results = new Shared<TInputOutput[]>(null);
			_taskScheduler = taskScheduler;
		}

		void IMergeHelper<TInputOutput>.Execute()
		{
			OrderPreservingSpoolingTask<TInputOutput, TKey>.Spool(_taskGroupState, _partitions, _results, _taskScheduler);
		}

		IEnumerator<TInputOutput> IMergeHelper<TInputOutput>.GetEnumerator()
		{
			return ((IEnumerable<TInputOutput>)_results.Value).GetEnumerator();
		}

		public TInputOutput[] GetResultsAsArray()
		{
			return _results.Value;
		}
	}
	internal class OrderPreservingPipeliningMergeHelper<TOutput, TKey> : IMergeHelper<TOutput>
	{
		private class ProducerComparer : IComparer<Producer<TKey>>
		{
			private IComparer<TKey> _keyComparer;

			internal ProducerComparer(IComparer<TKey> keyComparer)
			{
				_keyComparer = keyComparer;
			}

			public int Compare(Producer<TKey> x, Producer<TKey> y)
			{
				return _keyComparer.Compare(y.MaxKey, x.MaxKey);
			}
		}

		private class OrderedPipeliningMergeEnumerator : MergeEnumerator<TOutput>
		{
			private OrderPreservingPipeliningMergeHelper<TOutput, TKey> _mergeHelper;

			private readonly FixedMaxHeap<Producer<TKey>> _producerHeap;

			private readonly TOutput[] _producerNextElement;

			private readonly Queue<Pair<TKey, TOutput>>[] _privateBuffer;

			private bool _initialized;

			public override TOutput Current
			{
				get
				{
					int producerIndex = _producerHeap.MaxValue.ProducerIndex;
					return _producerNextElement[producerIndex];
				}
			}

			internal OrderedPipeliningMergeEnumerator(OrderPreservingPipeliningMergeHelper<TOutput, TKey> mergeHelper, IComparer<Producer<TKey>> producerComparer)
				: base(mergeHelper._taskGroupState)
			{
				int partitionCount = mergeHelper._partitions.PartitionCount;
				_mergeHelper = mergeHelper;
				_producerHeap = new FixedMaxHeap<Producer<TKey>>(partitionCount, producerComparer);
				_privateBuffer = new Queue<Pair<TKey, TOutput>>[partitionCount];
				_producerNextElement = new TOutput[partitionCount];
			}

			public override bool MoveNext()
			{
				if (!_initialized)
				{
					_initialized = true;
					for (int i = 0; i < _mergeHelper._partitions.PartitionCount; i++)
					{
						Pair<TKey, TOutput> element = default(Pair<TKey, TOutput>);
						if (TryWaitForElement(i, ref element))
						{
							_producerHeap.Insert(new Producer<TKey>(element.First, i));
							_producerNextElement[i] = element.Second;
						}
						else
						{
							ThrowIfInTearDown();
						}
					}
				}
				else
				{
					if (_producerHeap.Count == 0)
					{
						return false;
					}
					int producerIndex = _producerHeap.MaxValue.ProducerIndex;
					Pair<TKey, TOutput> element2 = default(Pair<TKey, TOutput>);
					if (TryGetPrivateElement(producerIndex, ref element2) || TryWaitForElement(producerIndex, ref element2))
					{
						_producerHeap.ReplaceMax(new Producer<TKey>(element2.First, producerIndex));
						_producerNextElement[producerIndex] = element2.Second;
					}
					else
					{
						ThrowIfInTearDown();
						_producerHeap.RemoveMax();
					}
				}
				return _producerHeap.Count > 0;
			}

			private void ThrowIfInTearDown()
			{
				if (!_mergeHelper._taskGroupState.CancellationState.MergedCancellationToken.IsCancellationRequested)
				{
					return;
				}
				try
				{
					object[] bufferLocks = _mergeHelper._bufferLocks;
					for (int i = 0; i < bufferLocks.Length; i++)
					{
						lock (bufferLocks[i])
						{
							Monitor.Pulse(bufferLocks[i]);
						}
					}
					_taskGroupState.QueryEnd(userInitiatedDispose: false);
				}
				finally
				{
					_producerHeap.Clear();
				}
			}

			private bool TryWaitForElement(int producer, ref Pair<TKey, TOutput> element)
			{
				Queue<Pair<TKey, TOutput>> queue = _mergeHelper._buffers[producer];
				object obj = _mergeHelper._bufferLocks[producer];
				lock (obj)
				{
					if (queue.Count == 0)
					{
						if (_mergeHelper._producerDone[producer])
						{
							element = default(Pair<TKey, TOutput>);
							return false;
						}
						_mergeHelper._consumerWaiting[producer] = true;
						Monitor.Wait(obj);
						if (queue.Count == 0)
						{
							element = default(Pair<TKey, TOutput>);
							return false;
						}
					}
					if (_mergeHelper._producerWaiting[producer])
					{
						Monitor.Pulse(obj);
						_mergeHelper._producerWaiting[producer] = false;
					}
					if (queue.Count < 1024)
					{
						element = queue.Dequeue();
						return true;
					}
					_privateBuffer[producer] = _mergeHelper._buffers[producer];
					_mergeHelper._buffers[producer] = new Queue<Pair<TKey, TOutput>>(128);
				}
				TryGetPrivateElement(producer, ref element);
				return true;
			}

			private bool TryGetPrivateElement(int producer, ref Pair<TKey, TOutput> element)
			{
				Queue<Pair<TKey, TOutput>> queue = _privateBuffer[producer];
				if (queue != null)
				{
					if (queue.Count > 0)
					{
						element = queue.Dequeue();
						return true;
					}
					_privateBuffer[producer] = null;
				}
				return false;
			}

			public override void Dispose()
			{
				int num = _mergeHelper._buffers.Length;
				for (int i = 0; i < num; i++)
				{
					object obj = _mergeHelper._bufferLocks[i];
					lock (obj)
					{
						if (_mergeHelper._producerWaiting[i])
						{
							Monitor.Pulse(obj);
						}
					}
				}
				base.Dispose();
			}
		}

		private readonly QueryTaskGroupState _taskGroupState;

		private readonly PartitionedStream<TOutput, TKey> _partitions;

		private readonly TaskScheduler _taskScheduler;

		private readonly bool _autoBuffered;

		private readonly Queue<Pair<TKey, TOutput>>[] _buffers;

		private readonly bool[] _producerDone;

		private readonly bool[] _producerWaiting;

		private readonly bool[] _consumerWaiting;

		private readonly object[] _bufferLocks;

		private IComparer<Producer<TKey>> _producerComparer;

		internal const int INITIAL_BUFFER_SIZE = 128;

		internal const int STEAL_BUFFER_SIZE = 1024;

		internal const int MAX_BUFFER_SIZE = 8192;

		internal OrderPreservingPipeliningMergeHelper(PartitionedStream<TOutput, TKey> partitions, TaskScheduler taskScheduler, CancellationState cancellationState, bool autoBuffered, int queryId, IComparer<TKey> keyComparer)
		{
			_taskGroupState = new QueryTaskGroupState(cancellationState, queryId);
			_partitions = partitions;
			_taskScheduler = taskScheduler;
			_autoBuffered = autoBuffered;
			int partitionCount = _partitions.PartitionCount;
			_buffers = new Queue<Pair<TKey, TOutput>>[partitionCount];
			_producerDone = new bool[partitionCount];
			_consumerWaiting = new bool[partitionCount];
			_producerWaiting = new bool[partitionCount];
			_bufferLocks = new object[partitionCount];
			if (keyComparer == Util.GetDefaultComparer<int>())
			{
				_producerComparer = (IComparer<Producer<TKey>>)new ProducerComparerInt();
			}
			else
			{
				_producerComparer = new ProducerComparer(keyComparer);
			}
		}

		void IMergeHelper<TOutput>.Execute()
		{
			OrderPreservingPipeliningSpoolingTask<TOutput, TKey>.Spool(_taskGroupState, _partitions, _consumerWaiting, _producerWaiting, _producerDone, _buffers, _bufferLocks, _taskScheduler, _autoBuffered);
		}

		IEnumerator<TOutput> IMergeHelper<TOutput>.GetEnumerator()
		{
			return new OrderedPipeliningMergeEnumerator(this, _producerComparer);
		}

		[ExcludeFromCodeCoverage]
		public TOutput[] GetResultsAsArray()
		{
			throw new InvalidOperationException();
		}
	}
	internal readonly struct Producer<TKey>
	{
		internal readonly TKey MaxKey;

		internal readonly int ProducerIndex;

		internal Producer(TKey maxKey, int producerIndex)
		{
			MaxKey = maxKey;
			ProducerIndex = producerIndex;
		}
	}
	internal class ProducerComparerInt : IComparer<Producer<int>>
	{
		public int Compare(Producer<int> x, Producer<int> y)
		{
			return y.MaxKey - x.MaxKey;
		}
	}
	internal sealed class SynchronousChannelMergeEnumerator<T> : MergeEnumerator<T>
	{
		private SynchronousChannel<T>[] _channels;

		private int _channelIndex;

		private T _currentElement;

		public override T Current
		{
			get
			{
				if (_channelIndex == -1 || _channelIndex == _channels.Length)
				{
					throw new InvalidOperationException("Enumeration has not started. MoveNext must be called to initiate enumeration.");
				}
				return _currentElement;
			}
		}

		internal SynchronousChannelMergeEnumerator(QueryTaskGroupState taskGroupState, SynchronousChannel<T>[] channels)
			: base(taskGroupState)
		{
			_channels = channels;
			_channelIndex = -1;
		}

		public override bool MoveNext()
		{
			if (_channelIndex == -1)
			{
				_channelIndex = 0;
			}
			while (_channelIndex != _channels.Length)
			{
				SynchronousChannel<T> synchronousChannel = _channels[_channelIndex];
				if (synchronousChannel.Count == 0)
				{
					_channelIndex++;
					continue;
				}
				_currentElement = synchronousChannel.Dequeue();
				return true;
			}
			return false;
		}
	}
	internal class HashRepartitionEnumerator<TInputOutput, THashKey, TIgnoreKey> : QueryOperatorEnumerator<Pair<TInputOutput, THashKey>, int>
	{
		private class Mutables
		{
			internal int _currentBufferIndex;

			internal ListChunk<Pair<TInputOutput, THashKey>> _currentBuffer;

			internal int _currentIndex;

			internal Mutables()
			{
				_currentBufferIndex = -1;
			}
		}

		private const int ENUMERATION_NOT_STARTED = -1;

		private readonly int _partitionCount;

		private readonly int _partitionIndex;

		private readonly Func<TInputOutput, THashKey> _keySelector;

		private readonly HashRepartitionStream<TInputOutput, THashKey, int> _repartitionStream;

		private readonly ListChunk<Pair<TInputOutput, THashKey>>[][] _valueExchangeMatrix;

		private readonly QueryOperatorEnumerator<TInputOutput, TIgnoreKey> _source;

		private CountdownEvent _barrier;

		private readonly CancellationToken _cancellationToken;

		private Mutables _mutables;

		internal HashRepartitionEnumerator(QueryOperatorEnumerator<TInputOutput, TIgnoreKey> source, int partitionCount, int partitionIndex, Func<TInputOutput, THashKey> keySelector, HashRepartitionStream<TInputOutput, THashKey, int> repartitionStream, CountdownEvent barrier, ListChunk<Pair<TInputOutput, THashKey>>[][] valueExchangeMatrix, CancellationToken cancellationToken)
		{
			_source = source;
			_partitionCount = partitionCount;
			_partitionIndex = partitionIndex;
			_keySelector = keySelector;
			_repartitionStream = repartitionStream;
			_barrier = barrier;
			_valueExchangeMatrix = valueExchangeMatrix;
			_cancellationToken = cancellationToken;
		}

		internal override bool MoveNext(ref Pair<TInputOutput, THashKey> currentElement, ref int currentKey)
		{
			if (_partitionCount == 1)
			{
				TIgnoreKey currentKey2 = default(TIgnoreKey);
				TInputOutput currentElement2 = default(TInputOutput);
				if (_source.MoveNext(ref currentElement2, ref currentKey2))
				{
					currentElement = new Pair<TInputOutput, THashKey>(currentElement2, (_keySelector == null) ? default(THashKey) : _keySelector(currentElement2));
					return true;
				}
				return false;
			}
			Mutables mutables = _mutables;
			if (mutables == null)
			{
				mutables = (_mutables = new Mutables());
			}
			if (mutables._currentBufferIndex == -1)
			{
				EnumerateAndRedistributeElements();
			}
			while (mutables._currentBufferIndex < _partitionCount)
			{
				if (mutables._currentBuffer != null)
				{
					if (++mutables._currentIndex < mutables._currentBuffer.Count)
					{
						currentElement = mutables._currentBuffer._chunk[mutables._currentIndex];
						return true;
					}
					mutables._currentIndex = -1;
					mutables._currentBuffer = mutables._currentBuffer.Next;
					continue;
				}
				if (mutables._currentBufferIndex == _partitionIndex)
				{
					_barrier.Wait(_cancellationToken);
					mutables._currentBufferIndex = -1;
				}
				mutables._currentBufferIndex++;
				mutables._currentIndex = -1;
				if (mutables._currentBufferIndex == _partitionIndex)
				{
					mutables._currentBufferIndex++;
				}
				if (mutables._currentBufferIndex < _partitionCount)
				{
					mutables._currentBuffer = _valueExchangeMatrix[mutables._currentBufferIndex][_partitionIndex];
				}
			}
			return false;
		}

		private void EnumerateAndRedistributeElements()
		{
			Mutables mutables = _mutables;
			ListChunk<Pair<TInputOutput, THashKey>>[] array = new ListChunk<Pair<TInputOutput, THashKey>>[_partitionCount];
			TInputOutput currentElement = default(TInputOutput);
			TIgnoreKey currentKey = default(TIgnoreKey);
			int num = 0;
			while (_source.MoveNext(ref currentElement, ref currentKey))
			{
				if ((num++ & 0x3F) == 0)
				{
					CancellationState.ThrowIfCanceled(_cancellationToken);
				}
				THashKey val = default(THashKey);
				int num2;
				if (_keySelector != null)
				{
					val = _keySelector(currentElement);
					num2 = _repartitionStream.GetHashCode(val) % _partitionCount;
				}
				else
				{
					num2 = _repartitionStream.GetHashCode(currentElement) % _partitionCount;
				}
				ListChunk<Pair<TInputOutput, THashKey>> listChunk = array[num2];
				if (listChunk == null)
				{
					listChunk = (array[num2] = new ListChunk<Pair<TInputOutput, THashKey>>(128));
				}
				listChunk.Add(new Pair<TInputOutput, THashKey>(currentElement, val));
			}
			for (int i = 0; i < _partitionCount; i++)
			{
				_valueExchangeMatrix[_partitionIndex][i] = array[i];
			}
			_barrier.Signal();
			mutables._currentBufferIndex = _partitionIndex;
			mutables._currentBuffer = array[_partitionIndex];
			mutables._currentIndex = -1;
		}

		protected override void Dispose(bool disposed)
		{
			if (_barrier != null)
			{
				if (_mutables == null || _mutables._currentBufferIndex == -1)
				{
					_barrier.Signal();
					_barrier = null;
				}
				_source.Dispose();
			}
		}
	}
	internal abstract class HashRepartitionStream<TInputOutput, THashKey, TOrderKey> : PartitionedStream<Pair<TInputOutput, THashKey>, TOrderKey>
	{
		private readonly IEqualityComparer<THashKey> _keyComparer;

		private readonly IEqualityComparer<TInputOutput> _elementComparer;

		private readonly int _distributionMod;

		private const int NULL_ELEMENT_HASH_CODE = 0;

		private const int HashCodeMask = int.MaxValue;

		internal HashRepartitionStream(int partitionsCount, IComparer<TOrderKey> orderKeyComparer, IEqualityComparer<THashKey> hashKeyComparer, IEqualityComparer<TInputOutput> elementComparer)
			: base(partitionsCount, orderKeyComparer, OrdinalIndexState.Shuffled)
		{
			_keyComparer = hashKeyComparer;
			_elementComparer = elementComparer;
			checked
			{
				for (_distributionMod = 503; _distributionMod < partitionsCount; _distributionMod *= 2)
				{
				}
			}
		}

		internal int GetHashCode(TInputOutput element)
		{
			return (0x7FFFFFFF & ((_elementComparer != null) ? _elementComparer.GetHashCode(element) : (element?.GetHashCode() ?? 0))) % _distributionMod;
		}

		internal int GetHashCode(THashKey key)
		{
			return (0x7FFFFFFF & ((_keyComparer != null) ? _keyComparer.GetHashCode(key) : (key?.GetHashCode() ?? 0))) % _distributionMod;
		}
	}
	internal interface IPartitionedStreamRecipient<TElement>
	{
		void Receive<TKey>(PartitionedStream<TElement, TKey> partitionedStream);
	}
	internal class OrderedHashRepartitionEnumerator<TInputOutput, THashKey, TOrderKey> : QueryOperatorEnumerator<Pair<TInputOutput, THashKey>, TOrderKey>
	{
		private class Mutables
		{
			internal int _currentBufferIndex;

			internal ListChunk<Pair<TInputOutput, THashKey>> _currentBuffer;

			internal ListChunk<TOrderKey> _currentKeyBuffer;

			internal int _currentIndex;

			internal Mutables()
			{
				_currentBufferIndex = -1;
			}
		}

		private const int ENUMERATION_NOT_STARTED = -1;

		private readonly int _partitionCount;

		private readonly int _partitionIndex;

		private readonly Func<TInputOutput, THashKey> _keySelector;

		private readonly HashRepartitionStream<TInputOutput, THashKey, TOrderKey> _repartitionStream;

		private readonly ListChunk<Pair<TInputOutput, THashKey>>[][] _valueExchangeMatrix;

		private readonly ListChunk<TOrderKey>[][] _keyExchangeMatrix;

		private readonly QueryOperatorEnumerator<TInputOutput, TOrderKey> _source;

		private CountdownEvent _barrier;

		private readonly CancellationToken _cancellationToken;

		private Mutables _mutables;

		internal OrderedHashRepartitionEnumerator(QueryOperatorEnumerator<TInputOutput, TOrderKey> source, int partitionCount, int partitionIndex, Func<TInputOutput, THashKey> keySelector, OrderedHashRepartitionStream<TInputOutput, THashKey, TOrderKey> repartitionStream, CountdownEvent barrier, ListChunk<Pair<TInputOutput, THashKey>>[][] valueExchangeMatrix, ListChunk<TOrderKey>[][] keyExchangeMatrix, CancellationToken cancellationToken)
		{
			_source = source;
			_partitionCount = partitionCount;
			_partitionIndex = partitionIndex;
			_keySelector = keySelector;
			_repartitionStream = repartitionStream;
			_barrier = barrier;
			_valueExchangeMatrix = valueExchangeMatrix;
			_keyExchangeMatrix = keyExchangeMatrix;
			_cancellationToken = cancellationToken;
		}

		internal override bool MoveNext(ref Pair<TInputOutput, THashKey> currentElement, ref TOrderKey currentKey)
		{
			if (_partitionCount == 1)
			{
				TInputOutput currentElement2 = default(TInputOutput);
				if (_source.MoveNext(ref currentElement2, ref currentKey))
				{
					currentElement = new Pair<TInputOutput, THashKey>(currentElement2, (_keySelector == null) ? default(THashKey) : _keySelector(currentElement2));
					return true;
				}
				return false;
			}
			Mutables mutables = _mutables;
			if (mutables == null)
			{
				mutables = (_mutables = new Mutables());
			}
			if (mutables._currentBufferIndex == -1)
			{
				EnumerateAndRedistributeElements();
			}
			while (mutables._currentBufferIndex < _partitionCount)
			{
				if (mutables._currentBuffer != null)
				{
					if (++mutables._currentIndex < mutables._currentBuffer.Count)
					{
						currentElement = mutables._currentBuffer._chunk[mutables._currentIndex];
						currentKey = mutables._currentKeyBuffer._chunk[mutables._currentIndex];
						return true;
					}
					mutables._currentIndex = -1;
					mutables._currentBuffer = mutables._currentBuffer.Next;
					mutables._currentKeyBuffer = mutables._currentKeyBuffer.Next;
					continue;
				}
				if (mutables._currentBufferIndex == _partitionIndex)
				{
					_barrier.Wait(_cancellationToken);
					mutables._currentBufferIndex = -1;
				}
				mutables._currentBufferIndex++;
				mutables._currentIndex = -1;
				if (mutables._currentBufferIndex == _partitionIndex)
				{
					mutables._currentBufferIndex++;
				}
				if (mutables._currentBufferIndex < _partitionCount)
				{
					mutables._currentBuffer = _valueExchangeMatrix[mutables._currentBufferIndex][_partitionIndex];
					mutables._currentKeyBuffer = _keyExchangeMatrix[mutables._currentBufferIndex][_partitionIndex];
				}
			}
			return false;
		}

		private void EnumerateAndRedistributeElements()
		{
			Mutables mutables = _mutables;
			ListChunk<Pair<TInputOutput, THashKey>>[] array = new ListChunk<Pair<TInputOutput, THashKey>>[_partitionCount];
			ListChunk<TOrderKey>[] array2 = new ListChunk<TOrderKey>[_partitionCount];
			TInputOutput currentElement = default(TInputOutput);
			TOrderKey currentKey = default(TOrderKey);
			int num = 0;
			while (_source.MoveNext(ref currentElement, ref currentKey))
			{
				if ((num++ & 0x3F) == 0)
				{
					CancellationState.ThrowIfCanceled(_cancellationToken);
				}
				THashKey val = default(THashKey);
				int num2;
				if (_keySelector != null)
				{
					val = _keySelector(currentElement);
					num2 = _repartitionStream.GetHashCode(val) % _partitionCount;
				}
				else
				{
					num2 = _repartitionStream.GetHashCode(currentElement) % _partitionCount;
				}
				ListChunk<Pair<TInputOutput, THashKey>> listChunk = array[num2];
				ListChunk<TOrderKey> listChunk2 = array2[num2];
				if (listChunk == null)
				{
					listChunk = (array[num2] = new ListChunk<Pair<TInputOutput, THashKey>>(128));
					listChunk2 = (array2[num2] = new ListChunk<TOrderKey>(128));
				}
				listChunk.Add(new Pair<TInputOutput, THashKey>(currentElement, val));
				listChunk2.Add(currentKey);
			}
			for (int i = 0; i < _partitionCount; i++)
			{
				_valueExchangeMatrix[_partitionIndex][i] = array[i];
				_keyExchangeMatrix[_partitionIndex][i] = array2[i];
			}
			_barrier.Signal();
			mutables._currentBufferIndex = _partitionIndex;
			mutables._currentBuffer = array[_partitionIndex];
			mutables._currentKeyBuffer = array2[_partitionIndex];
			mutables._currentIndex = -1;
		}

		protected override void Dispose(bool disposing)
		{
			if (_barrier != null)
			{
				if (_mutables == null || _mutables._currentBufferIndex == -1)
				{
					_barrier.Signal();
					_barrier = null;
				}
				_source.Dispose();
			}
		}
	}
	internal class OrderedHashRepartitionStream<TInputOutput, THashKey, TOrderKey> : HashRepartitionStream<TInputOutput, THashKey, TOrderKey>
	{
		internal OrderedHashRepartitionStream(PartitionedStream<TInputOutput, TOrderKey> inputStream, Func<TInputOutput, THashKey> hashKeySelector, IEqualityComparer<THashKey> hashKeyComparer, IEqualityComparer<TInputOutput> elementComparer, CancellationToken cancellationToken)
			: base(inputStream.PartitionCount, inputStream.KeyComparer, hashKeyComparer, elementComparer)
		{
			QueryOperatorEnumerator<Pair<TInputOutput, THashKey>, TOrderKey>[] partitions = new OrderedHashRepartitionEnumerator<TInputOutput, THashKey, TOrderKey>[inputStream.PartitionCount];
			_partitions = partitions;
			CountdownEvent barrier = new CountdownEvent(inputStream.PartitionCount);
			ListChunk<Pair<TInputOutput, THashKey>>[][] valueExchangeMatrix = JaggedArray<ListChunk<Pair<TInputOutput, THashKey>>>.Allocate(inputStream.PartitionCount, inputStream.PartitionCount);
			ListChunk<TOrderKey>[][] keyExchangeMatrix = JaggedArray<ListChunk<TOrderKey>>.Allocate(inputStream.PartitionCount, inputStream.PartitionCount);
			for (int i = 0; i < inputStream.PartitionCount; i++)
			{
				_partitions[i] = new OrderedHashRepartitionEnumerator<TInputOutput, THashKey, TOrderKey>(inputStream[i], inputStream.PartitionCount, i, hashKeySelector, this, barrier, valueExchangeMatrix, keyExchangeMatrix, cancellationToken);
			}
		}
	}
	internal class PartitionedDataSource<T> : PartitionedStream<T, int>
	{
		internal sealed class ArrayIndexRangeEnumerator : QueryOperatorEnumerator<T, int>
		{
			private class Mutables
			{
				internal int _currentSection;

				internal int _currentChunkSize;

				internal int _currentPositionInChunk;

				internal int _currentChunkOffset;

				internal Mutables()
				{
					_currentSection = -1;
				}
			}

			private readonly T[] _data;

			private readonly int _elementCount;

			private readonly int _partitionCount;

			private readonly int _partitionIndex;

			private readonly int _maxChunkSize;

			private readonly int _sectionCount;

			private Mutables _mutables;

			internal ArrayIndexRangeEnumerator(T[] data, int partitionCount, int partitionIndex, int maxChunkSize)
			{
				_data = data;
				_elementCount = data.Length;
				_partitionCount = partitionCount;
				_partitionIndex = partitionIndex;
				_maxChunkSize = maxChunkSize;
				int num = maxChunkSize * partitionCount;
				_sectionCount = _elementCount / num + ((_elementCount % num != 0) ? 1 : 0);
			}

			internal override bool MoveNext(ref T currentElement, ref int currentKey)
			{
				Mutables mutables = _mutables;
				if (mutables == null)
				{
					mutables = (_mutables = new Mutables());
				}
				if (++mutables._currentPositionInChunk < mutables._currentChunkSize || MoveNextSlowPath())
				{
					currentKey = mutables._currentChunkOffset + mutables._currentPositionInChunk;
					currentElement = _data[currentKey];
					return true;
				}
				return false;
			}

			private bool MoveNextSlowPath()
			{
				Mutables mutables = _mutables;
				int num = ++mutables._currentSection;
				int num2 = _sectionCount - num;
				if (num2 <= 0)
				{
					return false;
				}
				int num3 = num * _partitionCount * _maxChunkSize;
				mutables._currentPositionInChunk = 0;
				if (num2 > 1)
				{
					mutables._currentChunkSize = _maxChunkSize;
					mutables._currentChunkOffset = num3 + _partitionIndex * _maxChunkSize;
				}
				else
				{
					int num4 = _elementCount - num3;
					int num5 = num4 / _partitionCount;
					int num6 = num4 % _partitionCount;
					mutables._currentChunkSize = num5;
					if (_partitionIndex < num6)
					{
						mutables._currentChunkSize++;
					}
					if (mutables._currentChunkSize == 0)
					{
						return false;
					}
					mutables._currentChunkOffset = num3 + _partitionIndex * num5 + ((_partitionIndex < num6) ? _partitionIndex : num6);
				}
				return true;
			}
		}

		internal sealed class ArrayContiguousIndexRangeEnumerator : QueryOperatorEnumerator<T, int>
		{
			private readonly T[] _data;

			private readonly int _startIndex;

			private readonly int _maximumIndex;

			private Shared<int> _currentIndex;

			internal ArrayContiguousIndexRangeEnumerator(T[] data, int partitionCount, int partitionIndex)
			{
				_data = data;
				int num = data.Length / partitionCount;
				int num2 = data.Length % partitionCount;
				int num3 = partitionIndex * num + ((partitionIndex < num2) ? partitionIndex : num2);
				_startIndex = num3 - 1;
				_maximumIndex = num3 + num + ((partitionIndex < num2) ? 1 : 0);
			}

			internal override bool MoveNext(ref T currentElement, ref int currentKey)
			{
				if (_currentIndex == null)
				{
					_currentIndex = new Shared<int>(_startIndex);
				}
				int num = ++_currentIndex.Value;
				if (num < _maximumIndex)
				{
					currentKey = num;
					currentElement = _data[num];
					return true;
				}
				return false;
			}
		}

		internal sealed class ListIndexRangeEnumerator : QueryOperatorEnumerator<T, int>
		{
			private class Mutables
			{
				internal int _currentSection;

				internal int _currentChunkSize;

				internal int _currentPositionInChunk;

				internal int _currentChunkOffset;

				internal Mutables()
				{
					_currentSection = -1;
				}
			}

			private readonly IList<T> _data;

			private readonly int _elementCount;

			private readonly int _partitionCount;

			private readonly int _partitionIndex;

			private readonly int _maxChunkSize;

			private readonly int _sectionCount;

			private Mutables _mutables;

			internal ListIndexRangeEnumerator(IList<T> data, int partitionCount, int partitionIndex, int maxChunkSize)
			{
				_data = data;
				_elementCount = data.Count;
				_partitionCount = partitionCount;
				_partitionIndex = partitionIndex;
				_maxChunkSize = maxChunkSize;
				int num = maxChunkSize * partitionCount;
				_sectionCount = _elementCount / num + ((_elementCount % num != 0) ? 1 : 0);
			}

			internal override bool MoveNext(ref T currentElement, ref int currentKey)
			{
				Mutables mutables = _mutables;
				if (mutables == null)
				{
					mutables = (_mutables = new Mutables());
				}
				if (++mutables._currentPositionInChunk < mutables._currentChunkSize || MoveNextSlowPath())
				{
					currentKey = mutables._currentChunkOffset + mutables._currentPositionInChunk;
					currentElement = _data[currentKey];
					return true;
				}
				return false;
			}

			private bool MoveNextSlowPath()
			{
				Mutables mutables = _mutables;
				int num = ++mutables._currentSection;
				int num2 = _sectionCount - num;
				if (num2 <= 0)
				{
					return false;
				}
				int num3 = num * _partitionCount * _maxChunkSize;
				mutables._currentPositionInChunk = 0;
				if (num2 > 1)
				{
					mutables._currentChunkSize = _maxChunkSize;
					mutables._currentChunkOffset = num3 + _partitionIndex * _maxChunkSize;
				}
				else
				{
					int num4 = _elementCount - num3;
					int num5 = num4 / _partitionCount;
					int num6 = num4 % _partitionCount;
					mutables._currentChunkSize = num5;
					if (_partitionIndex < num6)
					{
						mutables._currentChunkSize++;
					}
					if (mutables._currentChunkSize == 0)
					{
						return false;
					}
					mutables._currentChunkOffset = num3 + _partitionIndex * num5 + ((_partitionIndex < num6) ? _partitionIndex : num6);
				}
				return true;
			}
		}

		internal sealed class ListContiguousIndexRangeEnumerator : QueryOperatorEnumerator<T, int>
		{
			private readonly IList<T> _data;

			private readonly int _startIndex;

			private readonly int _maximumIndex;

			private Shared<int> _currentIndex;

			internal ListContiguousIndexRangeEnumerator(IList<T> data, int partitionCount, int partitionIndex)
			{
				_data = data;
				int num = data.Count / partitionCount;
				int num2 = data.Count % partitionCount;
				int num3 = partitionIndex * num + ((partitionIndex < num2) ? partitionIndex : num2);
				_startIndex = num3 - 1;
				_maximumIndex = num3 + num + ((partitionIndex < num2) ? 1 : 0);
			}

			internal override bool MoveNext(ref T currentElement, ref int currentKey)
			{
				if (_currentIndex == null)
				{
					_currentIndex = new Shared<int>(_startIndex);
				}
				int num = ++_currentIndex.Value;
				if (num < _maximumIndex)
				{
					currentKey = num;
					currentElement = _data[num];
					return true;
				}
				return false;
			}
		}

		private class ContiguousChunkLazyEnumerator : QueryOperatorEnumerator<T, int>
		{
			private class Mutables
			{
				internal readonly T[] _chunkBuffer;

				internal int _nextChunkMaxSize;

				internal int _currentChunkSize;

				internal int _currentChunkIndex;

				internal int _chunkBaseIndex;

				internal int _chunkCounter;

				internal Mutables()
				{
					_nextChunkMaxSize = 1;
					_chunkBuffer = new T[Scheduling.GetDefaultChunkSize<T>()];
					_currentChunkSize = 0;
					_currentChunkIndex = -1;
					_chunkBaseIndex = 0;
					_chunkCounter = 0;
				}
			}

			private const int chunksPerChunkSize = 7;

			private readonly IEnumerator<T> _source;

			private readonly object _sourceSyncLock;

			private readonly Shared<int> _currentIndex;

			private readonly Shared<int> _activeEnumeratorsCount;

			private readonly Shared<bool> _exceptionTracker;

			private Mutables _mutables;

			internal ContiguousChunkLazyEnumerator(IEnumerator<T> source, Shared<bool> exceptionTracker, object sourceSyncLock, Shared<int> currentIndex, Shared<int> degreeOfParallelism)
			{
				_source = source;
				_sourceSyncLock = sourceSyncLock;
				_currentIndex = currentIndex;
				_activeEnumeratorsCount = degreeOfParallelism;
				_exceptionTracker = exceptionTracker;
			}

			internal override bool MoveNext(ref T currentElement, ref int currentKey)
			{
				Mutables mutables = _mutables;
				if (mutables == null)
				{
					mutables = (_mutables = new Mutables());
				}
				T[] chunkBuffer;
				int num;
				while (true)
				{
					chunkBuffer = mutables._chunkBuffer;
					num = ++mutables._currentChunkIndex;
					if (num < mutables._currentChunkSize)
					{
						break;
					}
					lock (_sourceSyncLock)
					{
						int i = 0;
						if (_exceptionTracker.Value)
						{
							return false;
						}
						try
						{
							for (; i < mutables._nextChunkMaxSize; i++)
							{
								if (!_source.MoveNext())
								{
									break;
								}
								chunkBuffer[i] = _source.Current;
							}
						}
						catch
						{
							_exceptionTracker.Value = true;
							throw;
						}
						mutables._currentChunkSize = i;
						if (i == 0)
						{
							return false;
						}
						mutables._chunkBaseIndex = _currentIndex.Value;
						checked
						{
							_currentIndex.Value += i;
						}
					}
					if (mutables._nextChunkMaxSize < chunkBuffer.Length && (mutables._chunkCounter++ & 7) == 7)
					{
						mutables._nextChunkMaxSize *= 2;
						if (mutables._nextChunkMaxSize > chunkBuffer.Length)
						{
							mutables._nextChunkMaxSize = chunkBuffer.Length;
						}
					}
					mutables._currentChunkIndex = -1;
				}
				currentElement = chunkBuffer[num];
				currentKey = mutables._chunkBaseIndex + num;
				return true;
			}

			protected override void Dispose(bool disposing)
			{
				if (Interlocked.Decrement(ref _activeEnumeratorsCount.Value) == 0)
				{
					_source.Dispose();
				}
			}
		}

		internal PartitionedDataSource(IEnumerable<T> source, int partitionCount, bool useStriping)
			: base(partitionCount, (IComparer<int>)Util.GetDefaultComparer<int>(), (!(source is IList<T>)) ? OrdinalIndexState.Correct : OrdinalIndexState.Indexable)
		{
			InitializePartitions(source, partitionCount, useStriping);
		}

		private void InitializePartitions(IEnumerable<T> source, int partitionCount, bool useStriping)
		{
			if (source is ParallelEnumerableWrapper<T> parallelEnumerableWrapper)
			{
				source = parallelEnumerableWrapper.WrappedEnumerable;
			}
			if (source is IList<T> data)
			{
				QueryOperatorEnumerator<T, int>[] array = new QueryOperatorEnumerator<T, int>[partitionCount];
				T[] array2 = source as T[];
				int num = -1;
				if (useStriping)
				{
					num = Scheduling.GetDefaultChunkSize<T>();
					if (num < 1)
					{
						num = 1;
					}
				}
				for (int i = 0; i < partitionCount; i++)
				{
					if (array2 != null)
					{
						if (useStriping)
						{
							array[i] = new ArrayIndexRangeEnumerator(array2, partitionCount, i, num);
						}
						else
						{
							array[i] = new ArrayContiguousIndexRangeEnumerator(array2, partitionCount, i);
						}
					}
					else if (useStriping)
					{
						array[i] = new ListIndexRangeEnumerator(data, partitionCount, i, num);
					}
					else
					{
						array[i] = new ListContiguousIndexRangeEnumerator(data, partitionCount, i);
					}
				}
				_partitions = array;
			}
			else
			{
				_partitions = MakePartitions(source.GetEnumerator(), partitionCount);
			}
		}

		private static QueryOperatorEnumerator<T, int>[] MakePartitions(IEnumerator<T> source, int partitionCount)
		{
			QueryOperatorEnumerator<T, int>[] array = new QueryOperatorEnumerator<T, int>[partitionCount];
			object sourceSyncLock = new object();
			Shared<int> currentIndex = new Shared<int>(0);
			Shared<int> degreeOfParallelism = new Shared<int>(partitionCount);
			Shared<bool> exceptionTracker = new Shared<bool>(value: false);
			for (int i = 0; i < partitionCount; i++)
			{
				array[i] = new ContiguousChunkLazyEnumerator(source, exceptionTracker, sourceSyncLock, currentIndex, degreeOfParallelism);
			}
			return array;
		}
	}
	internal class PartitionedStream<TElement, TKey>
	{
		protected QueryOperatorEnumerator<TElement, TKey>[] _partitions;

		private readonly IComparer<TKey> _keyComparer;

		private readonly OrdinalIndexState _indexState;

		internal QueryOperatorEnumerator<TElement, TKey> this[int index]
		{
			get
			{
				return _partitions[index];
			}
			set
			{
				_partitions[index] = value;
			}
		}

		public int PartitionCount => _partitions.Length;

		internal IComparer<TKey> KeyComparer => _keyComparer;

		internal OrdinalIndexState OrdinalIndexState => _indexState;

		internal PartitionedStream(int partitionCount, IComparer<TKey> keyComparer, OrdinalIndexState indexState)
		{
			_partitions = new QueryOperatorEnumerator<TElement, TKey>[partitionCount];
			_keyComparer = keyComparer;
			_indexState = indexState;
		}
	}
	internal class UnorderedHashRepartitionStream<TInputOutput, THashKey, TIgnoreKey> : HashRepartitionStream<TInputOutput, THashKey, int>
	{
		internal UnorderedHashRepartitionStream(PartitionedStream<TInputOutput, TIgnoreKey> inputStream, Func<TInputOutput, THashKey> keySelector, IEqualityComparer<THashKey> keyComparer, IEqualityComparer<TInputOutput> elementComparer, CancellationToken cancellationToken)
			: base(inputStream.PartitionCount, (IComparer<int>)Util.GetDefaultComparer<int>(), keyComparer, elementComparer)
		{
			QueryOperatorEnumerator<Pair<TInputOutput, THashKey>, int>[] partitions = new HashRepartitionEnumerator<TInputOutput, THashKey, TIgnoreKey>[inputStream.PartitionCount];
			_partitions = partitions;
			CountdownEvent barrier = new CountdownEvent(inputStream.PartitionCount);
			ListChunk<Pair<TInputOutput, THashKey>>[][] valueExchangeMatrix = JaggedArray<ListChunk<Pair<TInputOutput, THashKey>>>.Allocate(inputStream.PartitionCount, inputStream.PartitionCount);
			for (int i = 0; i < inputStream.PartitionCount; i++)
			{
				_partitions[i] = new HashRepartitionEnumerator<TInputOutput, THashKey, TIgnoreKey>(inputStream[i], inputStream.PartitionCount, i, keySelector, this, barrier, valueExchangeMatrix, cancellationToken);
			}
		}
	}
	internal sealed class AssociativeAggregationOperator<TInput, TIntermediate, TOutput> : UnaryQueryOperator<TInput, TIntermediate>
	{
		private class AssociativeAggregationOperatorEnumerator<TKey> : QueryOperatorEnumerator<TIntermediate, int>
		{
			private readonly QueryOperatorEnumerator<TInput, TKey> _source;

			private readonly AssociativeAggregationOperator<TInput, TIntermediate, TOutput> _reduceOperator;

			private readonly int _partitionIndex;

			private readonly CancellationToken _cancellationToken;

			private bool _accumulated;

			internal AssociativeAggregationOperatorEnumerator(QueryOperatorEnumerator<TInput, TKey> source, AssociativeAggregationOperator<TInput, TIntermediate, TOutput> reduceOperator, int partitionIndex, CancellationToken cancellationToken)
			{
				_source = source;
				_reduceOperator = reduceOperator;
				_partitionIndex = partitionIndex;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TIntermediate currentElement, ref int currentKey)
			{
				if (_accumulated)
				{
					return false;
				}
				_accumulated = true;
				bool flag = false;
				TIntermediate val = default(TIntermediate);
				if (_reduceOperator._seedIsSpecified)
				{
					val = ((_reduceOperator._seedFactory == null) ? _reduceOperator._seed : _reduceOperator._seedFactory());
				}
				else
				{
					TInput currentElement2 = default(TInput);
					TKey currentKey2 = default(TKey);
					if (!_source.MoveNext(ref currentElement2, ref currentKey2))
					{
						return false;
					}
					flag = true;
					val = (TIntermediate)(object)currentElement2;
				}
				TInput currentElement3 = default(TInput);
				TKey currentKey3 = default(TKey);
				int num = 0;
				while (_source.MoveNext(ref currentElement3, ref currentKey3))
				{
					if ((num++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					flag = true;
					val = _reduceOperator._intermediateReduce(val, currentElement3);
				}
				if (flag)
				{
					currentElement = val;
					currentKey = _partitionIndex;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly TIntermediate _seed;

		private readonly bool _seedIsSpecified;

		private readonly bool _throwIfEmpty;

		private Func<TIntermediate, TInput, TIntermediate> _intermediateReduce;

		private Func<TIntermediate, TIntermediate, TIntermediate> _finalReduce;

		private Func<TIntermediate, TOutput> _resultSelector;

		private Func<TIntermediate> _seedFactory;

		internal override bool LimitsParallelism => false;

		internal AssociativeAggregationOperator(IEnumerable<TInput> child, TIntermediate seed, Func<TIntermediate> seedFactory, bool seedIsSpecified, Func<TIntermediate, TInput, TIntermediate> intermediateReduce, Func<TIntermediate, TIntermediate, TIntermediate> finalReduce, Func<TIntermediate, TOutput> resultSelector, bool throwIfEmpty, QueryAggregationOptions options)
			: base(child)
		{
			_seed = seed;
			_seedFactory = seedFactory;
			_seedIsSpecified = seedIsSpecified;
			_intermediateReduce = intermediateReduce;
			_finalReduce = finalReduce;
			_resultSelector = resultSelector;
			_throwIfEmpty = throwIfEmpty;
		}

		internal TOutput Aggregate()
		{
			TIntermediate val = default(TIntermediate);
			bool flag = false;
			using (IEnumerator<TIntermediate> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true))
			{
				while (enumerator.MoveNext())
				{
					if (flag)
					{
						try
						{
							val = _finalReduce(val, enumerator.Current);
						}
						catch (Exception ex)
						{
							throw new AggregateException(ex);
						}
					}
					else
					{
						val = enumerator.Current;
						flag = true;
					}
				}
				if (!flag)
				{
					if (_throwIfEmpty)
					{
						throw new InvalidOperationException("Sequence contains no elements");
					}
					val = ((_seedFactory == null) ? _seed : _seedFactory());
				}
			}
			try
			{
				return _resultSelector(val);
			}
			catch (Exception ex2)
			{
				throw new AggregateException(ex2);
			}
		}

		internal override QueryResults<TIntermediate> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping), this, settings, preferStriping);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TInput, TKey> inputStream, IPartitionedStreamRecipient<TIntermediate> recipient, bool preferStriping, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			PartitionedStream<TIntermediate, int> partitionedStream = new PartitionedStream<TIntermediate, int>(partitionCount, Util.GetDefaultComparer<int>(), OrdinalIndexState.Correct);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream[i] = new AssociativeAggregationOperatorEnumerator<TKey>(inputStream[i], this, i, settings.CancellationState.MergedCancellationToken);
			}
			recipient.Receive(partitionedStream);
		}

		[ExcludeFromCodeCoverage]
		internal override IEnumerable<TIntermediate> AsSequentialQuery(CancellationToken token)
		{
			throw new NotSupportedException();
		}
	}
	internal sealed class ConcatQueryOperator<TSource> : BinaryQueryOperator<TSource, TSource, TSource>
	{
		private sealed class ConcatQueryOperatorEnumerator<TLeftKey, TRightKey> : QueryOperatorEnumerator<TSource, ConcatKey<TLeftKey, TRightKey>>
		{
			private QueryOperatorEnumerator<TSource, TLeftKey> _firstSource;

			private QueryOperatorEnumerator<TSource, TRightKey> _secondSource;

			private bool _begunSecond;

			internal ConcatQueryOperatorEnumerator(QueryOperatorEnumerator<TSource, TLeftKey> firstSource, QueryOperatorEnumerator<TSource, TRightKey> secondSource)
			{
				_firstSource = firstSource;
				_secondSource = secondSource;
			}

			internal override bool MoveNext(ref TSource currentElement, ref ConcatKey<TLeftKey, TRightKey> currentKey)
			{
				if (!_begunSecond)
				{
					TLeftKey currentKey2 = default(TLeftKey);
					if (_firstSource.MoveNext(ref currentElement, ref currentKey2))
					{
						currentKey = ConcatKey<TLeftKey, TRightKey>.MakeLeft(currentKey2);
						return true;
					}
					_begunSecond = true;
				}
				TRightKey currentKey3 = default(TRightKey);
				if (_secondSource.MoveNext(ref currentElement, ref currentKey3))
				{
					currentKey = ConcatKey<TLeftKey, TRightKey>.MakeRight(currentKey3);
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_firstSource.Dispose();
				_secondSource.Dispose();
			}
		}

		private class ConcatQueryOperatorResults : BinaryQueryOperatorResults
		{
			private int _leftChildCount;

			private int _rightChildCount;

			internal override bool IsIndexible => true;

			internal override int ElementsCount => _leftChildCount + _rightChildCount;

			public static QueryResults<TSource> NewResults(QueryResults<TSource> leftChildQueryResults, QueryResults<TSource> rightChildQueryResults, ConcatQueryOperator<TSource> op, QuerySettings settings, bool preferStriping)
			{
				if (leftChildQueryResults.IsIndexible && rightChildQueryResults.IsIndexible)
				{
					return new ConcatQueryOperatorResults(leftChildQueryResults, rightChildQueryResults, op, settings, preferStriping);
				}
				return new BinaryQueryOperatorResults(leftChildQueryResults, rightChildQueryResults, op, settings, preferStriping);
			}

			private ConcatQueryOperatorResults(QueryResults<TSource> leftChildQueryResults, QueryResults<TSource> rightChildQueryResults, ConcatQueryOperator<TSource> concatOp, QuerySettings settings, bool preferStriping)
				: base(leftChildQueryResults, rightChildQueryResults, (BinaryQueryOperator<TSource, TSource, TSource>)concatOp, settings, preferStriping)
			{
				_leftChildCount = leftChildQueryResults.ElementsCount;
				_rightChildCount = rightChildQueryResults.ElementsCount;
			}

			internal override TSource GetElement(int index)
			{
				if (index < _leftChildCount)
				{
					return _leftChildQueryResults.GetElement(index);
				}
				return _rightChildQueryResults.GetElement(index - _leftChildCount);
			}
		}

		private readonly bool _prematureMergeLeft;

		private readonly bool _prematureMergeRight;

		internal override bool LimitsParallelism => false;

		internal ConcatQueryOperator(ParallelQuery<TSource> firstChild, ParallelQuery<TSource> secondChild)
			: base(firstChild, secondChild)
		{
			_outputOrdered = base.LeftChild.OutputOrdered || base.RightChild.OutputOrdered;
			_prematureMergeLeft = base.LeftChild.OrdinalIndexState.IsWorseThan(OrdinalIndexState.Increasing);
			_prematureMergeRight = base.RightChild.OrdinalIndexState.IsWorseThan(OrdinalIndexState.Increasing);
			if (base.LeftChild.OrdinalIndexState == OrdinalIndexState.Indexable && base.RightChild.OrdinalIndexState == OrdinalIndexState.Indexable)
			{
				SetOrdinalIndex(OrdinalIndexState.Indexable);
			}
			else
			{
				SetOrdinalIndex(OrdinalIndexState.Increasing.Worse(base.LeftChild.OrdinalIndexState.Worse(base.RightChild.OrdinalIndexState)));
			}
		}

		internal override QueryResults<TSource> Open(QuerySettings settings, bool preferStriping)
		{
			QueryResults<TSource> leftChildQueryResults = base.LeftChild.Open(settings, preferStriping);
			QueryResults<TSource> rightChildQueryResults = base.RightChild.Open(settings, preferStriping);
			return ConcatQueryOperatorResults.NewResults(leftChildQueryResults, rightChildQueryResults, this, settings, preferStriping);
		}

		public override void WrapPartitionedStream<TLeftKey, TRightKey>(PartitionedStream<TSource, TLeftKey> leftStream, PartitionedStream<TSource, TRightKey> rightStream, IPartitionedStreamRecipient<TSource> outputRecipient, bool preferStriping, QuerySettings settings)
		{
			if (_prematureMergeLeft)
			{
				PartitionedStream<TSource, int> partitionedStream = QueryOperator<TSource>.ExecuteAndCollectResults(leftStream, leftStream.PartitionCount, base.LeftChild.OutputOrdered, preferStriping, settings).GetPartitionedStream();
				WrapHelper(partitionedStream, rightStream, outputRecipient, settings, preferStriping);
			}
			else
			{
				WrapHelper(leftStream, rightStream, outputRecipient, settings, preferStriping);
			}
		}

		private void WrapHelper<TLeftKey, TRightKey>(PartitionedStream<TSource, TLeftKey> leftStreamInc, PartitionedStream<TSource, TRightKey> rightStream, IPartitionedStreamRecipient<TSource> outputRecipient, QuerySettings settings, bool preferStriping)
		{
			if (_prematureMergeRight)
			{
				PartitionedStream<TSource, int> partitionedStream = QueryOperator<TSource>.ExecuteAndCollectResults(rightStream, leftStreamInc.PartitionCount, base.LeftChild.OutputOrdered, preferStriping, settings).GetPartitionedStream();
				WrapHelper2(leftStreamInc, partitionedStream, outputRecipient);
			}
			else
			{
				WrapHelper2(leftStreamInc, rightStream, outputRecipient);
			}
		}

		private void WrapHelper2<TLeftKey, TRightKey>(PartitionedStream<TSource, TLeftKey> leftStreamInc, PartitionedStream<TSource, TRightKey> rightStreamInc, IPartitionedStreamRecipient<TSource> outputRecipient)
		{
			int partitionCount = leftStreamInc.PartitionCount;
			IComparer<ConcatKey<TLeftKey, TRightKey>> keyComparer = ConcatKey<TLeftKey, TRightKey>.MakeComparer(leftStreamInc.KeyComparer, rightStreamInc.KeyComparer);
			PartitionedStream<TSource, ConcatKey<TLeftKey, TRightKey>> partitionedStream = new PartitionedStream<TSource, ConcatKey<TLeftKey, TRightKey>>(partitionCount, keyComparer, OrdinalIndexState);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream[i] = new ConcatQueryOperatorEnumerator<TLeftKey, TRightKey>(leftStreamInc[i], rightStreamInc[i]);
			}
			outputRecipient.Receive(partitionedStream);
		}

		internal override IEnumerable<TSource> AsSequentialQuery(CancellationToken token)
		{
			return base.LeftChild.AsSequentialQuery(token).Concat(base.RightChild.AsSequentialQuery(token));
		}
	}
	internal struct ConcatKey<TLeftKey, TRightKey>
	{
		private class ConcatKeyComparer : IComparer<ConcatKey<TLeftKey, TRightKey>>
		{
			private IComparer<TLeftKey> _leftComparer;

			private IComparer<TRightKey> _rightComparer;

			internal ConcatKeyComparer(IComparer<TLeftKey> leftComparer, IComparer<TRightKey> rightComparer)
			{
				_leftComparer = leftComparer;
				_rightComparer = rightComparer;
			}

			public int Compare(ConcatKey<TLeftKey, TRightKey> x, ConcatKey<TLeftKey, TRightKey> y)
			{
				if (x._isLeft != y._isLeft)
				{
					if (!x._isLeft)
					{
						return 1;
					}
					return -1;
				}
				if (x._isLeft)
				{
					return _leftComparer.Compare(x._leftKey, y._leftKey);
				}
				return _rightComparer.Compare(x._rightKey, y._rightKey);
			}
		}

		private readonly TLeftKey _leftKey;

		private readonly TRightKey _rightKey;

		private readonly bool _isLeft;

		private ConcatKey(TLeftKey leftKey, TRightKey rightKey, bool isLeft)
		{
			_leftKey = leftKey;
			_rightKey = rightKey;
			_isLeft = isLeft;
		}

		internal static ConcatKey<TLeftKey, TRightKey> MakeLeft(TLeftKey leftKey)
		{
			return new ConcatKey<TLeftKey, TRightKey>(leftKey, default(TRightKey), isLeft: true);
		}

		internal static ConcatKey<TLeftKey, TRightKey> MakeRight(TRightKey rightKey)
		{
			return new ConcatKey<TLeftKey, TRightKey>(default(TLeftKey), rightKey, isLeft: false);
		}

		internal static IComparer<ConcatKey<TLeftKey, TRightKey>> MakeComparer(IComparer<TLeftKey> leftComparer, IComparer<TRightKey> rightComparer)
		{
			return new ConcatKeyComparer(leftComparer, rightComparer);
		}
	}
	internal sealed class ExceptQueryOperator<TInputOutput> : BinaryQueryOperator<TInputOutput, TInputOutput, TInputOutput>
	{
		private class ExceptQueryOperatorEnumerator<TLeftKey> : QueryOperatorEnumerator<TInputOutput, int>
		{
			private QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> _leftSource;

			private QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, int> _rightSource;

			private IEqualityComparer<TInputOutput> _comparer;

			private Set<TInputOutput> _hashLookup;

			private CancellationToken _cancellationToken;

			private Shared<int> _outputLoopCount;

			internal ExceptQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftSource, QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, int> rightSource, IEqualityComparer<TInputOutput> comparer, CancellationToken cancellationToken)
			{
				_leftSource = leftSource;
				_rightSource = rightSource;
				_comparer = comparer;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TInputOutput currentElement, ref int currentKey)
			{
				if (_hashLookup == null)
				{
					_outputLoopCount = new Shared<int>(0);
					_hashLookup = new Set<TInputOutput>(_comparer);
					Pair<TInputOutput, NoKeyMemoizationRequired> currentElement2 = default(Pair<TInputOutput, NoKeyMemoizationRequired>);
					int currentKey2 = 0;
					int num = 0;
					while (_rightSource.MoveNext(ref currentElement2, ref currentKey2))
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						_hashLookup.Add(currentElement2.First);
					}
				}
				Pair<TInputOutput, NoKeyMemoizationRequired> currentElement3 = default(Pair<TInputOutput, NoKeyMemoizationRequired>);
				TLeftKey currentKey3 = default(TLeftKey);
				while (_leftSource.MoveNext(ref currentElement3, ref currentKey3))
				{
					if ((_outputLoopCount.Value++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					if (_hashLookup.Add(currentElement3.First))
					{
						currentElement = currentElement3.First;
						return true;
					}
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_leftSource.Dispose();
				_rightSource.Dispose();
			}
		}

		private class OrderedExceptQueryOperatorEnumerator<TLeftKey> : QueryOperatorEnumerator<TInputOutput, TLeftKey>
		{
			private QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> _leftSource;

			private QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, int> _rightSource;

			private IEqualityComparer<TInputOutput> _comparer;

			private IComparer<TLeftKey> _leftKeyComparer;

			private IEnumerator<KeyValuePair<Wrapper<TInputOutput>, Pair<TInputOutput, TLeftKey>>> _outputEnumerator;

			private CancellationToken _cancellationToken;

			internal OrderedExceptQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftSource, QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, int> rightSource, IEqualityComparer<TInputOutput> comparer, IComparer<TLeftKey> leftKeyComparer, CancellationToken cancellationToken)
			{
				_leftSource = leftSource;
				_rightSource = rightSource;
				_comparer = comparer;
				_leftKeyComparer = leftKeyComparer;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TInputOutput currentElement, ref TLeftKey currentKey)
			{
				if (_outputEnumerator == null)
				{
					Set<TInputOutput> set = new Set<TInputOutput>(_comparer);
					Pair<TInputOutput, NoKeyMemoizationRequired> currentElement2 = default(Pair<TInputOutput, NoKeyMemoizationRequired>);
					int currentKey2 = 0;
					int num = 0;
					while (_rightSource.MoveNext(ref currentElement2, ref currentKey2))
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						set.Add(currentElement2.First);
					}
					Dictionary<Wrapper<TInputOutput>, Pair<TInputOutput, TLeftKey>> dictionary = new Dictionary<Wrapper<TInputOutput>, Pair<TInputOutput, TLeftKey>>(new WrapperEqualityComparer<TInputOutput>(_comparer));
					Pair<TInputOutput, NoKeyMemoizationRequired> currentElement3 = default(Pair<TInputOutput, NoKeyMemoizationRequired>);
					TLeftKey currentKey3 = default(TLeftKey);
					while (_leftSource.MoveNext(ref currentElement3, ref currentKey3))
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						if (!set.Contains(currentElement3.First))
						{
							Wrapper<TInputOutput> key = new Wrapper<TInputOutput>(currentElement3.First);
							if (!dictionary.TryGetValue(key, out var value) || _leftKeyComparer.Compare(currentKey3, value.Second) < 0)
							{
								dictionary[key] = new Pair<TInputOutput, TLeftKey>(currentElement3.First, currentKey3);
							}
						}
					}
					_outputEnumerator = dictionary.GetEnumerator();
				}
				if (_outputEnumerator.MoveNext())
				{
					Pair<TInputOutput, TLeftKey> value2 = _outputEnumerator.Current.Value;
					currentElement = value2.First;
					currentKey = value2.Second;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_leftSource.Dispose();
				_rightSource.Dispose();
			}
		}

		private readonly IEqualityComparer<TInputOutput> _comparer;

		internal override bool LimitsParallelism => false;

		internal ExceptQueryOperator(ParallelQuery<TInputOutput> left, ParallelQuery<TInputOutput> right, IEqualityComparer<TInputOutput> comparer)
			: base(left, right)
		{
			_comparer = comparer;
			_outputOrdered = base.LeftChild.OutputOrdered;
			SetOrdinalIndex(OrdinalIndexState.Shuffled);
		}

		internal override QueryResults<TInputOutput> Open(QuerySettings settings, bool preferStriping)
		{
			QueryResults<TInputOutput> leftChildQueryResults = base.LeftChild.Open(settings, preferStriping: false);
			QueryResults<TInputOutput> rightChildQueryResults = base.RightChild.Open(settings, preferStriping: false);
			return new BinaryQueryOperatorResults(leftChildQueryResults, rightChildQueryResults, this, settings, preferStriping: false);
		}

		public override void WrapPartitionedStream<TLeftKey, TRightKey>(PartitionedStream<TInputOutput, TLeftKey> leftStream, PartitionedStream<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings)
		{
			if (base.OutputOrdered)
			{
				WrapPartitionedStreamHelper(ExchangeUtilities.HashRepartitionOrdered<TInputOutput, NoKeyMemoizationRequired, TLeftKey>(leftStream, null, null, _comparer, settings.CancellationState.MergedCancellationToken), rightStream, outputRecipient, settings.CancellationState.MergedCancellationToken);
			}
			else
			{
				WrapPartitionedStreamHelper(ExchangeUtilities.HashRepartition<TInputOutput, NoKeyMemoizationRequired, TLeftKey>(leftStream, null, null, _comparer, settings.CancellationState.MergedCancellationToken), rightStream, outputRecipient, settings.CancellationState.MergedCancellationToken);
			}
		}

		private void WrapPartitionedStreamHelper<TLeftKey, TRightKey>(PartitionedStream<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient<TInputOutput> outputRecipient, CancellationToken cancellationToken)
		{
			int partitionCount = leftHashStream.PartitionCount;
			PartitionedStream<Pair<TInputOutput, NoKeyMemoizationRequired>, int> partitionedStream = ExchangeUtilities.HashRepartition<TInputOutput, NoKeyMemoizationRequired, TRightKey>(rightPartitionedStream, null, null, _comparer, cancellationToken);
			PartitionedStream<TInputOutput, TLeftKey> partitionedStream2 = new PartitionedStream<TInputOutput, TLeftKey>(partitionCount, leftHashStream.KeyComparer, OrdinalIndexState.Shuffled);
			for (int i = 0; i < partitionCount; i++)
			{
				if (base.OutputOrdered)
				{
					partitionedStream2[i] = new OrderedExceptQueryOperatorEnumerator<TLeftKey>(leftHashStream[i], partitionedStream[i], _comparer, leftHashStream.KeyComparer, cancellationToken);
				}
				else
				{
					partitionedStream2[i] = (QueryOperatorEnumerator<TInputOutput, TLeftKey>)(object)new ExceptQueryOperatorEnumerator<TLeftKey>(leftHashStream[i], partitionedStream[i], _comparer, cancellationToken);
				}
			}
			outputRecipient.Receive(partitionedStream2);
		}

		internal override IEnumerable<TInputOutput> AsSequentialQuery(CancellationToken token)
		{
			IEnumerable<TInputOutput> first = CancellableEnumerable.Wrap(base.LeftChild.AsSequentialQuery(token), token);
			IEnumerable<TInputOutput> second = CancellableEnumerable.Wrap(base.RightChild.AsSequentialQuery(token), token);
			return first.Except(second, _comparer);
		}
	}
	internal sealed class GroupJoinQueryOperator<TLeftInput, TRightInput, TKey, TOutput> : BinaryQueryOperator<TLeftInput, TRightInput, TOutput>
	{
		private readonly Func<TLeftInput, TKey> _leftKeySelector;

		private readonly Func<TRightInput, TKey> _rightKeySelector;

		private readonly Func<TLeftInput, IEnumerable<TRightInput>, TOutput> _resultSelector;

		private readonly IEqualityComparer<TKey> _keyComparer;

		internal override bool LimitsParallelism => false;

		internal GroupJoinQueryOperator(ParallelQuery<TLeftInput> left, ParallelQuery<TRightInput> right, Func<TLeftInput, TKey> leftKeySelector, Func<TRightInput, TKey> rightKeySelector, Func<TLeftInput, IEnumerable<TRightInput>, TOutput> resultSelector, IEqualityComparer<TKey> keyComparer)
			: base(left, right)
		{
			_leftKeySelector = leftKeySelector;
			_rightKeySelector = rightKeySelector;
			_resultSelector = resultSelector;
			_keyComparer = keyComparer;
			_outputOrdered = base.LeftChild.OutputOrdered;
			SetOrdinalIndex(OrdinalIndexState.Shuffled);
		}

		internal override QueryResults<TOutput> Open(QuerySettings settings, bool preferStriping)
		{
			QueryResults<TLeftInput> leftChildQueryResults = base.LeftChild.Open(settings, preferStriping: false);
			QueryResults<TRightInput> rightChildQueryResults = base.RightChild.Open(settings, preferStriping: false);
			return new BinaryQueryOperatorResults(leftChildQueryResults, rightChildQueryResults, this, settings, preferStriping: false);
		}

		public override void WrapPartitionedStream<TLeftKey, TRightKey>(PartitionedStream<TLeftInput, TLeftKey> leftStream, PartitionedStream<TRightInput, TRightKey> rightStream, IPartitionedStreamRecipient<TOutput> outputRecipient, bool preferStriping, QuerySettings settings)
		{
			int partitionCount = leftStream.PartitionCount;
			if (base.LeftChild.OutputOrdered)
			{
				WrapPartitionedStreamHelper(ExchangeUtilities.HashRepartitionOrdered(leftStream, _leftKeySelector, _keyComparer, null, settings.CancellationState.MergedCancellationToken), rightStream, outputRecipient, partitionCount, settings.CancellationState.MergedCancellationToken);
			}
			else
			{
				WrapPartitionedStreamHelper(ExchangeUtilities.HashRepartition(leftStream, _leftKeySelector, _keyComparer, null, settings.CancellationState.MergedCancellationToken), rightStream, outputRecipient, partitionCount, settings.CancellationState.MergedCancellationToken);
			}
		}

		private void WrapPartitionedStreamHelper<TLeftKey, TRightKey>(PartitionedStream<Pair<TLeftInput, TKey>, TLeftKey> leftHashStream, PartitionedStream<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient<TOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken)
		{
			PartitionedStream<Pair<TRightInput, TKey>, int> partitionedStream = ExchangeUtilities.HashRepartition(rightPartitionedStream, _rightKeySelector, _keyComparer, null, cancellationToken);
			PartitionedStream<TOutput, TLeftKey> partitionedStream2 = new PartitionedStream<TOutput, TLeftKey>(partitionCount, leftHashStream.KeyComparer, OrdinalIndexState);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream2[i] = new HashJoinQueryOperatorEnumerator<TLeftInput, TLeftKey, TRightInput, TKey, TOutput>(leftHashStream[i], partitionedStream[i], null, _resultSelector, _keyComparer, cancellationToken);
			}
			outputRecipient.Receive(partitionedStream2);
		}

		internal override IEnumerable<TOutput> AsSequentialQuery(CancellationToken token)
		{
			IEnumerable<TLeftInput> outer = CancellableEnumerable.Wrap(base.LeftChild.AsSequentialQuery(token), token);
			IEnumerable<TRightInput> inner = CancellableEnumerable.Wrap(base.RightChild.AsSequentialQuery(token), token);
			return outer.GroupJoin(inner, _leftKeySelector, _rightKeySelector, _resultSelector, _keyComparer);
		}
	}
	internal class HashJoinQueryOperatorEnumerator<TLeftInput, TLeftKey, TRightInput, THashKey, TOutput> : QueryOperatorEnumerator<TOutput, TLeftKey>
	{
		private class Mutables
		{
			internal TLeftInput _currentLeft;

			internal TLeftKey _currentLeftKey;

			internal HashLookup<THashKey, Pair<TRightInput, ListChunk<TRightInput>>> _rightHashLookup;

			internal ListChunk<TRightInput> _currentRightMatches;

			internal int _currentRightMatchesIndex;

			internal int _outputLoopCount;
		}

		private readonly QueryOperatorEnumerator<Pair<TLeftInput, THashKey>, TLeftKey> _leftSource;

		private readonly QueryOperatorEnumerator<Pair<TRightInput, THashKey>, int> _rightSource;

		private readonly Func<TLeftInput, TRightInput, TOutput> _singleResultSelector;

		private readonly Func<TLeftInput, IEnumerable<TRightInput>, TOutput> _groupResultSelector;

		private readonly IEqualityComparer<THashKey> _keyComparer;

		private readonly CancellationToken _cancellationToken;

		private Mutables _mutables;

		internal HashJoinQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TLeftInput, THashKey>, TLeftKey> leftSource, QueryOperatorEnumerator<Pair<TRightInput, THashKey>, int> rightSource, Func<TLeftInput, TRightInput, TOutput> singleResultSelector, Func<TLeftInput, IEnumerable<TRightInput>, TOutput> groupResultSelector, IEqualityComparer<THashKey> keyComparer, CancellationToken cancellationToken)
		{
			_leftSource = leftSource;
			_rightSource = rightSource;
			_singleResultSelector = singleResultSelector;
			_groupResultSelector = groupResultSelector;
			_keyComparer = keyComparer;
			_cancellationToken = cancellationToken;
		}

		internal override bool MoveNext(ref TOutput currentElement, ref TLeftKey currentKey)
		{
			Mutables mutables = _mutables;
			if (mutables == null)
			{
				mutables = (_mutables = new Mutables());
				mutables._rightHashLookup = new HashLookup<THashKey, Pair<TRightInput, ListChunk<TRightInput>>>(_keyComparer);
				Pair<TRightInput, THashKey> currentElement2 = default(Pair<TRightInput, THashKey>);
				int currentKey2 = 0;
				int num = 0;
				while (_rightSource.MoveNext(ref currentElement2, ref currentKey2))
				{
					if ((num++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					TRightInput first = currentElement2.First;
					THashKey second = currentElement2.Second;
					if (second == null)
					{
						continue;
					}
					Pair<TRightInput, ListChunk<TRightInput>> value = default(Pair<TRightInput, ListChunk<TRightInput>>);
					if (!mutables._rightHashLookup.TryGetValue(second, ref value))
					{
						value = new Pair<TRightInput, ListChunk<TRightInput>>(first, null);
						if (_groupResultSelector != null)
						{
							value.Second = new ListChunk<TRightInput>(2);
							value.Second.Add(first);
						}
						mutables._rightHashLookup.Add(second, value);
					}
					else
					{
						if (value.Second == null)
						{
							value.Second = new ListChunk<TRightInput>(2);
							mutables._rightHashLookup[second] = value;
						}
						value.Second.Add(first);
					}
				}
			}
			ListChunk<TRightInput> currentRightMatches = mutables._currentRightMatches;
			if (currentRightMatches != null && mutables._currentRightMatchesIndex == currentRightMatches.Count)
			{
				currentRightMatches = (mutables._currentRightMatches = currentRightMatches.Next);
				mutables._currentRightMatchesIndex = 0;
			}
			if (mutables._currentRightMatches == null)
			{
				Pair<TLeftInput, THashKey> currentElement3 = default(Pair<TLeftInput, THashKey>);
				TLeftKey currentKey3 = default(TLeftKey);
				while (_leftSource.MoveNext(ref currentElement3, ref currentKey3))
				{
					if ((mutables._outputLoopCount++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					Pair<TRightInput, ListChunk<TRightInput>> value2 = default(Pair<TRightInput, ListChunk<TRightInput>>);
					TLeftInput first2 = currentElement3.First;
					THashKey second2 = currentElement3.Second;
					if (second2 != null && mutables._rightHashLookup.TryGetValue(second2, ref value2) && _singleResultSelector != null)
					{
						mutables._currentRightMatches = value2.Second;
						mutables._currentRightMatchesIndex = 0;
						currentElement = _singleResultSelector(first2, value2.First);
						currentKey = currentKey3;
						if (value2.Second != null)
						{
							mutables._currentLeft = first2;
							mutables._currentLeftKey = currentKey3;
						}
						return true;
					}
					if (_groupResultSelector != null)
					{
						IEnumerable<TRightInput> enumerable = value2.Second;
						if (enumerable == null)
						{
							enumerable = ParallelEnumerable.Empty<TRightInput>();
						}
						currentElement = _groupResultSelector(first2, enumerable);
						currentKey = currentKey3;
						return true;
					}
				}
				return false;
			}
			currentElement = _singleResultSelector(mutables._currentLeft, mutables._currentRightMatches._chunk[mutables._currentRightMatchesIndex]);
			currentKey = mutables._currentLeftKey;
			mutables._currentRightMatchesIndex++;
			return true;
		}

		protected override void Dispose(bool disposing)
		{
			_leftSource.Dispose();
			_rightSource.Dispose();
		}
	}
	internal sealed class IntersectQueryOperator<TInputOutput> : BinaryQueryOperator<TInputOutput, TInputOutput, TInputOutput>
	{
		private class IntersectQueryOperatorEnumerator<TLeftKey> : QueryOperatorEnumerator<TInputOutput, int>
		{
			private QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> _leftSource;

			private QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, int> _rightSource;

			private IEqualityComparer<TInputOutput> _comparer;

			private Set<TInputOutput> _hashLookup;

			private CancellationToken _cancellationToken;

			private Shared<int> _outputLoopCount;

			internal IntersectQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftSource, QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, int> rightSource, IEqualityComparer<TInputOutput> comparer, CancellationToken cancellationToken)
			{
				_leftSource = leftSource;
				_rightSource = rightSource;
				_comparer = comparer;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TInputOutput currentElement, ref int currentKey)
			{
				if (_hashLookup == null)
				{
					_outputLoopCount = new Shared<int>(0);
					_hashLookup = new Set<TInputOutput>(_comparer);
					Pair<TInputOutput, NoKeyMemoizationRequired> currentElement2 = default(Pair<TInputOutput, NoKeyMemoizationRequired>);
					int currentKey2 = 0;
					int num = 0;
					while (_rightSource.MoveNext(ref currentElement2, ref currentKey2))
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						_hashLookup.Add(currentElement2.First);
					}
				}
				Pair<TInputOutput, NoKeyMemoizationRequired> currentElement3 = default(Pair<TInputOutput, NoKeyMemoizationRequired>);
				TLeftKey currentKey3 = default(TLeftKey);
				while (_leftSource.MoveNext(ref currentElement3, ref currentKey3))
				{
					if ((_outputLoopCount.Value++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					if (_hashLookup.Remove(currentElement3.First))
					{
						currentElement = currentElement3.First;
						return true;
					}
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_leftSource.Dispose();
				_rightSource.Dispose();
			}
		}

		private class OrderedIntersectQueryOperatorEnumerator<TLeftKey> : QueryOperatorEnumerator<TInputOutput, TLeftKey>
		{
			private QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> _leftSource;

			private QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, int> _rightSource;

			private IEqualityComparer<Wrapper<TInputOutput>> _comparer;

			private IComparer<TLeftKey> _leftKeyComparer;

			private Dictionary<Wrapper<TInputOutput>, Pair<TInputOutput, TLeftKey>> _hashLookup;

			private CancellationToken _cancellationToken;

			internal OrderedIntersectQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftSource, QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, int> rightSource, IEqualityComparer<TInputOutput> comparer, IComparer<TLeftKey> leftKeyComparer, CancellationToken cancellationToken)
			{
				_leftSource = leftSource;
				_rightSource = rightSource;
				_comparer = new WrapperEqualityComparer<TInputOutput>(comparer);
				_leftKeyComparer = leftKeyComparer;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TInputOutput currentElement, ref TLeftKey currentKey)
			{
				int num = 0;
				if (_hashLookup == null)
				{
					_hashLookup = new Dictionary<Wrapper<TInputOutput>, Pair<TInputOutput, TLeftKey>>(_comparer);
					Pair<TInputOutput, NoKeyMemoizationRequired> currentElement2 = default(Pair<TInputOutput, NoKeyMemoizationRequired>);
					TLeftKey currentKey2 = default(TLeftKey);
					while (_leftSource.MoveNext(ref currentElement2, ref currentKey2))
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						Wrapper<TInputOutput> key = new Wrapper<TInputOutput>(currentElement2.First);
						if (!_hashLookup.TryGetValue(key, out var value) || _leftKeyComparer.Compare(currentKey2, value.Second) < 0)
						{
							_hashLookup[key] = new Pair<TInputOutput, TLeftKey>(currentElement2.First, currentKey2);
						}
					}
				}
				Pair<TInputOutput, NoKeyMemoizationRequired> currentElement3 = default(Pair<TInputOutput, NoKeyMemoizationRequired>);
				int currentKey3 = 0;
				while (_rightSource.MoveNext(ref currentElement3, ref currentKey3))
				{
					if ((num++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					Wrapper<TInputOutput> key2 = new Wrapper<TInputOutput>(currentElement3.First);
					if (_hashLookup.TryGetValue(key2, out var value2))
					{
						currentElement = value2.First;
						currentKey = value2.Second;
						_hashLookup.Remove(new Wrapper<TInputOutput>(value2.First));
						return true;
					}
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_leftSource.Dispose();
				_rightSource.Dispose();
			}
		}

		private readonly IEqualityComparer<TInputOutput> _comparer;

		internal override bool LimitsParallelism => false;

		internal IntersectQueryOperator(ParallelQuery<TInputOutput> left, ParallelQuery<TInputOutput> right, IEqualityComparer<TInputOutput> comparer)
			: base(left, right)
		{
			_comparer = comparer;
			_outputOrdered = base.LeftChild.OutputOrdered;
			SetOrdinalIndex(OrdinalIndexState.Shuffled);
		}

		internal override QueryResults<TInputOutput> Open(QuerySettings settings, bool preferStriping)
		{
			QueryResults<TInputOutput> leftChildQueryResults = base.LeftChild.Open(settings, preferStriping: false);
			QueryResults<TInputOutput> rightChildQueryResults = base.RightChild.Open(settings, preferStriping: false);
			return new BinaryQueryOperatorResults(leftChildQueryResults, rightChildQueryResults, this, settings, preferStriping: false);
		}

		public override void WrapPartitionedStream<TLeftKey, TRightKey>(PartitionedStream<TInputOutput, TLeftKey> leftPartitionedStream, PartitionedStream<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings)
		{
			if (base.OutputOrdered)
			{
				WrapPartitionedStreamHelper(ExchangeUtilities.HashRepartitionOrdered<TInputOutput, NoKeyMemoizationRequired, TLeftKey>(leftPartitionedStream, null, null, _comparer, settings.CancellationState.MergedCancellationToken), rightPartitionedStream, outputRecipient, settings.CancellationState.MergedCancellationToken);
			}
			else
			{
				WrapPartitionedStreamHelper(ExchangeUtilities.HashRepartition<TInputOutput, NoKeyMemoizationRequired, TLeftKey>(leftPartitionedStream, null, null, _comparer, settings.CancellationState.MergedCancellationToken), rightPartitionedStream, outputRecipient, settings.CancellationState.MergedCancellationToken);
			}
		}

		private void WrapPartitionedStreamHelper<TLeftKey, TRightKey>(PartitionedStream<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient<TInputOutput> outputRecipient, CancellationToken cancellationToken)
		{
			int partitionCount = leftHashStream.PartitionCount;
			PartitionedStream<Pair<TInputOutput, NoKeyMemoizationRequired>, int> partitionedStream = ExchangeUtilities.HashRepartition<TInputOutput, NoKeyMemoizationRequired, TRightKey>(rightPartitionedStream, null, null, _comparer, cancellationToken);
			PartitionedStream<TInputOutput, TLeftKey> partitionedStream2 = new PartitionedStream<TInputOutput, TLeftKey>(partitionCount, leftHashStream.KeyComparer, OrdinalIndexState.Shuffled);
			for (int i = 0; i < partitionCount; i++)
			{
				if (base.OutputOrdered)
				{
					partitionedStream2[i] = new OrderedIntersectQueryOperatorEnumerator<TLeftKey>(leftHashStream[i], partitionedStream[i], _comparer, leftHashStream.KeyComparer, cancellationToken);
				}
				else
				{
					partitionedStream2[i] = (QueryOperatorEnumerator<TInputOutput, TLeftKey>)(object)new IntersectQueryOperatorEnumerator<TLeftKey>(leftHashStream[i], partitionedStream[i], _comparer, cancellationToken);
				}
			}
			outputRecipient.Receive(partitionedStream2);
		}

		internal override IEnumerable<TInputOutput> AsSequentialQuery(CancellationToken token)
		{
			IEnumerable<TInputOutput> first = CancellableEnumerable.Wrap(base.LeftChild.AsSequentialQuery(token), token);
			IEnumerable<TInputOutput> second = CancellableEnumerable.Wrap(base.RightChild.AsSequentialQuery(token), token);
			return first.Intersect(second, _comparer);
		}
	}
	internal sealed class JoinQueryOperator<TLeftInput, TRightInput, TKey, TOutput> : BinaryQueryOperator<TLeftInput, TRightInput, TOutput>
	{
		private readonly Func<TLeftInput, TKey> _leftKeySelector;

		private readonly Func<TRightInput, TKey> _rightKeySelector;

		private readonly Func<TLeftInput, TRightInput, TOutput> _resultSelector;

		private readonly IEqualityComparer<TKey> _keyComparer;

		internal override bool LimitsParallelism => false;

		internal JoinQueryOperator(ParallelQuery<TLeftInput> left, ParallelQuery<TRightInput> right, Func<TLeftInput, TKey> leftKeySelector, Func<TRightInput, TKey> rightKeySelector, Func<TLeftInput, TRightInput, TOutput> resultSelector, IEqualityComparer<TKey> keyComparer)
			: base(left, right)
		{
			_leftKeySelector = leftKeySelector;
			_rightKeySelector = rightKeySelector;
			_resultSelector = resultSelector;
			_keyComparer = keyComparer;
			_outputOrdered = base.LeftChild.OutputOrdered;
			SetOrdinalIndex(OrdinalIndexState.Shuffled);
		}

		public override void WrapPartitionedStream<TLeftKey, TRightKey>(PartitionedStream<TLeftInput, TLeftKey> leftStream, PartitionedStream<TRightInput, TRightKey> rightStream, IPartitionedStreamRecipient<TOutput> outputRecipient, bool preferStriping, QuerySettings settings)
		{
			if (base.LeftChild.OutputOrdered)
			{
				WrapPartitionedStreamHelper(ExchangeUtilities.HashRepartitionOrdered(leftStream, _leftKeySelector, _keyComparer, null, settings.CancellationState.MergedCancellationToken), rightStream, outputRecipient, settings.CancellationState.MergedCancellationToken);
			}
			else
			{
				WrapPartitionedStreamHelper(ExchangeUtilities.HashRepartition(leftStream, _leftKeySelector, _keyComparer, null, settings.CancellationState.MergedCancellationToken), rightStream, outputRecipient, settings.CancellationState.MergedCancellationToken);
			}
		}

		private void WrapPartitionedStreamHelper<TLeftKey, TRightKey>(PartitionedStream<Pair<TLeftInput, TKey>, TLeftKey> leftHashStream, PartitionedStream<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient<TOutput> outputRecipient, CancellationToken cancellationToken)
		{
			int partitionCount = leftHashStream.PartitionCount;
			PartitionedStream<Pair<TRightInput, TKey>, int> partitionedStream = ExchangeUtilities.HashRepartition(rightPartitionedStream, _rightKeySelector, _keyComparer, null, cancellationToken);
			PartitionedStream<TOutput, TLeftKey> partitionedStream2 = new PartitionedStream<TOutput, TLeftKey>(partitionCount, leftHashStream.KeyComparer, OrdinalIndexState);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream2[i] = new HashJoinQueryOperatorEnumerator<TLeftInput, TLeftKey, TRightInput, TKey, TOutput>(leftHashStream[i], partitionedStream[i], _resultSelector, null, _keyComparer, cancellationToken);
			}
			outputRecipient.Receive(partitionedStream2);
		}

		internal override QueryResults<TOutput> Open(QuerySettings settings, bool preferStriping)
		{
			QueryResults<TLeftInput> leftChildQueryResults = base.LeftChild.Open(settings, preferStriping: false);
			QueryResults<TRightInput> rightChildQueryResults = base.RightChild.Open(settings, preferStriping: false);
			return new BinaryQueryOperatorResults(leftChildQueryResults, rightChildQueryResults, this, settings, preferStriping: false);
		}

		internal override IEnumerable<TOutput> AsSequentialQuery(CancellationToken token)
		{
			IEnumerable<TLeftInput> outer = CancellableEnumerable.Wrap(base.LeftChild.AsSequentialQuery(token), token);
			IEnumerable<TRightInput> inner = CancellableEnumerable.Wrap(base.RightChild.AsSequentialQuery(token), token);
			return outer.Join(inner, _leftKeySelector, _rightKeySelector, _resultSelector, _keyComparer);
		}
	}
	internal sealed class UnionQueryOperator<TInputOutput> : BinaryQueryOperator<TInputOutput, TInputOutput, TInputOutput>
	{
		private class UnionQueryOperatorEnumerator<TLeftKey, TRightKey> : QueryOperatorEnumerator<TInputOutput, int>
		{
			private QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> _leftSource;

			private QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TRightKey> _rightSource;

			private Set<TInputOutput> _hashLookup;

			private CancellationToken _cancellationToken;

			private Shared<int> _outputLoopCount;

			private readonly IEqualityComparer<TInputOutput> _comparer;

			internal UnionQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftSource, QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TRightKey> rightSource, IEqualityComparer<TInputOutput> comparer, CancellationToken cancellationToken)
			{
				_leftSource = leftSource;
				_rightSource = rightSource;
				_comparer = comparer;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TInputOutput currentElement, ref int currentKey)
			{
				if (_hashLookup == null)
				{
					_hashLookup = new Set<TInputOutput>(_comparer);
					_outputLoopCount = new Shared<int>(0);
				}
				if (_leftSource != null)
				{
					TLeftKey currentKey2 = default(TLeftKey);
					Pair<TInputOutput, NoKeyMemoizationRequired> currentElement2 = default(Pair<TInputOutput, NoKeyMemoizationRequired>);
					int num = 0;
					while (_leftSource.MoveNext(ref currentElement2, ref currentKey2))
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						if (_hashLookup.Add(currentElement2.First))
						{
							currentElement = currentElement2.First;
							return true;
						}
					}
					_leftSource.Dispose();
					_leftSource = null;
				}
				if (_rightSource != null)
				{
					TRightKey currentKey3 = default(TRightKey);
					Pair<TInputOutput, NoKeyMemoizationRequired> currentElement3 = default(Pair<TInputOutput, NoKeyMemoizationRequired>);
					while (_rightSource.MoveNext(ref currentElement3, ref currentKey3))
					{
						if ((_outputLoopCount.Value++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						if (_hashLookup.Add(currentElement3.First))
						{
							currentElement = currentElement3.First;
							return true;
						}
					}
					_rightSource.Dispose();
					_rightSource = null;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				if (_leftSource != null)
				{
					_leftSource.Dispose();
				}
				if (_rightSource != null)
				{
					_rightSource.Dispose();
				}
			}
		}

		private class OrderedUnionQueryOperatorEnumerator<TLeftKey, TRightKey> : QueryOperatorEnumerator<TInputOutput, ConcatKey<TLeftKey, TRightKey>>
		{
			private QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> _leftSource;

			private QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TRightKey> _rightSource;

			private IComparer<ConcatKey<TLeftKey, TRightKey>> _keyComparer;

			private IEnumerator<KeyValuePair<Wrapper<TInputOutput>, Pair<TInputOutput, ConcatKey<TLeftKey, TRightKey>>>> _outputEnumerator;

			private bool _leftOrdered;

			private bool _rightOrdered;

			private IEqualityComparer<TInputOutput> _comparer;

			private CancellationToken _cancellationToken;

			internal OrderedUnionQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftSource, QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TRightKey> rightSource, bool leftOrdered, bool rightOrdered, IEqualityComparer<TInputOutput> comparer, IComparer<ConcatKey<TLeftKey, TRightKey>> keyComparer, CancellationToken cancellationToken)
			{
				_leftSource = leftSource;
				_rightSource = rightSource;
				_keyComparer = keyComparer;
				_leftOrdered = leftOrdered;
				_rightOrdered = rightOrdered;
				_comparer = comparer;
				if (_comparer == null)
				{
					_comparer = EqualityComparer<TInputOutput>.Default;
				}
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TInputOutput currentElement, ref ConcatKey<TLeftKey, TRightKey> currentKey)
			{
				if (_outputEnumerator == null)
				{
					Dictionary<Wrapper<TInputOutput>, Pair<TInputOutput, ConcatKey<TLeftKey, TRightKey>>> dictionary = new Dictionary<Wrapper<TInputOutput>, Pair<TInputOutput, ConcatKey<TLeftKey, TRightKey>>>(new WrapperEqualityComparer<TInputOutput>(_comparer));
					Pair<TInputOutput, NoKeyMemoizationRequired> currentElement2 = default(Pair<TInputOutput, NoKeyMemoizationRequired>);
					TLeftKey currentKey2 = default(TLeftKey);
					int num = 0;
					while (_leftSource.MoveNext(ref currentElement2, ref currentKey2))
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						ConcatKey<TLeftKey, TRightKey> concatKey = ConcatKey<TLeftKey, TRightKey>.MakeLeft(_leftOrdered ? currentKey2 : default(TLeftKey));
						Wrapper<TInputOutput> key = new Wrapper<TInputOutput>(currentElement2.First);
						if (!dictionary.TryGetValue(key, out var value) || _keyComparer.Compare(concatKey, value.Second) < 0)
						{
							dictionary[key] = new Pair<TInputOutput, ConcatKey<TLeftKey, TRightKey>>(currentElement2.First, concatKey);
						}
					}
					TRightKey currentKey3 = default(TRightKey);
					while (_rightSource.MoveNext(ref currentElement2, ref currentKey3))
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						ConcatKey<TLeftKey, TRightKey> concatKey2 = ConcatKey<TLeftKey, TRightKey>.MakeRight(_rightOrdered ? currentKey3 : default(TRightKey));
						Wrapper<TInputOutput> key2 = new Wrapper<TInputOutput>(currentElement2.First);
						if (!dictionary.TryGetValue(key2, out var value2) || _keyComparer.Compare(concatKey2, value2.Second) < 0)
						{
							dictionary[key2] = new Pair<TInputOutput, ConcatKey<TLeftKey, TRightKey>>(currentElement2.First, concatKey2);
						}
					}
					_outputEnumerator = dictionary.GetEnumerator();
				}
				if (_outputEnumerator.MoveNext())
				{
					Pair<TInputOutput, ConcatKey<TLeftKey, TRightKey>> value3 = _outputEnumerator.Current.Value;
					currentElement = value3.First;
					currentKey = value3.Second;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_leftSource.Dispose();
				_rightSource.Dispose();
			}
		}

		private readonly IEqualityComparer<TInputOutput> _comparer;

		internal override bool LimitsParallelism => false;

		internal UnionQueryOperator(ParallelQuery<TInputOutput> left, ParallelQuery<TInputOutput> right, IEqualityComparer<TInputOutput> comparer)
			: base(left, right)
		{
			_comparer = comparer;
			_outputOrdered = base.LeftChild.OutputOrdered || base.RightChild.OutputOrdered;
		}

		internal override QueryResults<TInputOutput> Open(QuerySettings settings, bool preferStriping)
		{
			QueryResults<TInputOutput> leftChildQueryResults = base.LeftChild.Open(settings, preferStriping: false);
			QueryResults<TInputOutput> rightChildQueryResults = base.RightChild.Open(settings, preferStriping: false);
			return new BinaryQueryOperatorResults(leftChildQueryResults, rightChildQueryResults, this, settings, preferStriping: false);
		}

		public override void WrapPartitionedStream<TLeftKey, TRightKey>(PartitionedStream<TInputOutput, TLeftKey> leftStream, PartitionedStream<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings)
		{
			int partitionCount = leftStream.PartitionCount;
			if (base.LeftChild.OutputOrdered)
			{
				PartitionedStream<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream = ExchangeUtilities.HashRepartitionOrdered<TInputOutput, NoKeyMemoizationRequired, TLeftKey>(leftStream, null, null, _comparer, settings.CancellationState.MergedCancellationToken);
				WrapPartitionedStreamFixedLeftType(leftHashStream, rightStream, outputRecipient, partitionCount, settings.CancellationState.MergedCancellationToken);
			}
			else
			{
				PartitionedStream<Pair<TInputOutput, NoKeyMemoizationRequired>, int> leftHashStream2 = ExchangeUtilities.HashRepartition<TInputOutput, NoKeyMemoizationRequired, TLeftKey>(leftStream, null, null, _comparer, settings.CancellationState.MergedCancellationToken);
				WrapPartitionedStreamFixedLeftType(leftHashStream2, rightStream, outputRecipient, partitionCount, settings.CancellationState.MergedCancellationToken);
			}
		}

		private void WrapPartitionedStreamFixedLeftType<TLeftKey, TRightKey>(PartitionedStream<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient<TInputOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken)
		{
			if (base.RightChild.OutputOrdered)
			{
				PartitionedStream<Pair<TInputOutput, NoKeyMemoizationRequired>, TRightKey> rightHashStream = ExchangeUtilities.HashRepartitionOrdered<TInputOutput, NoKeyMemoizationRequired, TRightKey>(rightStream, null, null, _comparer, cancellationToken);
				WrapPartitionedStreamFixedBothTypes(leftHashStream, rightHashStream, outputRecipient, partitionCount, cancellationToken);
			}
			else
			{
				PartitionedStream<Pair<TInputOutput, NoKeyMemoizationRequired>, int> rightHashStream2 = ExchangeUtilities.HashRepartition<TInputOutput, NoKeyMemoizationRequired, TRightKey>(rightStream, null, null, _comparer, cancellationToken);
				WrapPartitionedStreamFixedBothTypes(leftHashStream, rightHashStream2, outputRecipient, partitionCount, cancellationToken);
			}
		}

		private void WrapPartitionedStreamFixedBothTypes<TLeftKey, TRightKey>(PartitionedStream<Pair<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream<Pair<TInputOutput, NoKeyMemoizationRequired>, TRightKey> rightHashStream, IPartitionedStreamRecipient<TInputOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken)
		{
			if (base.LeftChild.OutputOrdered || base.RightChild.OutputOrdered)
			{
				IComparer<ConcatKey<TLeftKey, TRightKey>> keyComparer = ConcatKey<TLeftKey, TRightKey>.MakeComparer(leftHashStream.KeyComparer, rightHashStream.KeyComparer);
				PartitionedStream<TInputOutput, ConcatKey<TLeftKey, TRightKey>> partitionedStream = new PartitionedStream<TInputOutput, ConcatKey<TLeftKey, TRightKey>>(partitionCount, keyComparer, OrdinalIndexState.Shuffled);
				for (int i = 0; i < partitionCount; i++)
				{
					partitionedStream[i] = new OrderedUnionQueryOperatorEnumerator<TLeftKey, TRightKey>(leftHashStream[i], rightHashStream[i], base.LeftChild.OutputOrdered, base.RightChild.OutputOrdered, _comparer, keyComparer, cancellationToken);
				}
				outputRecipient.Receive(partitionedStream);
			}
			else
			{
				PartitionedStream<TInputOutput, int> partitionedStream2 = new PartitionedStream<TInputOutput, int>(partitionCount, Util.GetDefaultComparer<int>(), OrdinalIndexState.Shuffled);
				for (int j = 0; j < partitionCount; j++)
				{
					partitionedStream2[j] = new UnionQueryOperatorEnumerator<TLeftKey, TRightKey>(leftHashStream[j], rightHashStream[j], _comparer, cancellationToken);
				}
				outputRecipient.Receive(partitionedStream2);
			}
		}

		internal override IEnumerable<TInputOutput> AsSequentialQuery(CancellationToken token)
		{
			IEnumerable<TInputOutput> first = CancellableEnumerable.Wrap(base.LeftChild.AsSequentialQuery(token), token);
			IEnumerable<TInputOutput> second = CancellableEnumerable.Wrap(base.RightChild.AsSequentialQuery(token), token);
			return first.Union(second, _comparer);
		}
	}
	internal sealed class ZipQueryOperator<TLeftInput, TRightInput, TOutput> : QueryOperator<TOutput>
	{
		internal class ZipQueryOperatorResults : QueryResults<TOutput>
		{
			private readonly QueryResults<TLeftInput> _leftChildResults;

			private readonly QueryResults<TRightInput> _rightChildResults;

			private readonly Func<TLeftInput, TRightInput, TOutput> _resultSelector;

			private readonly int _count;

			private readonly int _partitionCount;

			private readonly bool _preferStriping;

			internal override int ElementsCount => _count;

			internal override bool IsIndexible => true;

			internal ZipQueryOperatorResults(QueryResults<TLeftInput> leftChildResults, QueryResults<TRightInput> rightChildResults, Func<TLeftInput, TRightInput, TOutput> resultSelector, int partitionCount, bool preferStriping)
			{
				_leftChildResults = leftChildResults;
				_rightChildResults = rightChildResults;
				_resultSelector = resultSelector;
				_partitionCount = partitionCount;
				_preferStriping = preferStriping;
				_count = Math.Min(_leftChildResults.Count, _rightChildResults.Count);
			}

			internal override TOutput GetElement(int index)
			{
				return _resultSelector(_leftChildResults.GetElement(index), _rightChildResults.GetElement(index));
			}

			internal override void GivePartitionedStream(IPartitionedStreamRecipient<TOutput> recipient)
			{
				PartitionedStream<TOutput, int> partitionedStream = ExchangeUtilities.PartitionDataSource(this, _partitionCount, _preferStriping);
				recipient.Receive(partitionedStream);
			}
		}

		private readonly Func<TLeftInput, TRightInput, TOutput> _resultSelector;

		private readonly QueryOperator<TLeftInput> _leftChild;

		private readonly QueryOperator<TRightInput> _rightChild;

		private readonly bool _prematureMergeLeft;

		private readonly bool _prematureMergeRight;

		private readonly bool _limitsParallelism;

		internal override OrdinalIndexState OrdinalIndexState => OrdinalIndexState.Indexable;

		internal override bool LimitsParallelism => _limitsParallelism;

		internal ZipQueryOperator(ParallelQuery<TLeftInput> leftChildSource, ParallelQuery<TRightInput> rightChildSource, Func<TLeftInput, TRightInput, TOutput> resultSelector)
			: this(QueryOperator<TLeftInput>.AsQueryOperator(leftChildSource), QueryOperator<TRightInput>.AsQueryOperator(rightChildSource), resultSelector)
		{
		}

		private ZipQueryOperator(QueryOperator<TLeftInput> left, QueryOperator<TRightInput> right, Func<TLeftInput, TRightInput, TOutput> resultSelector)
			: base(left.SpecifiedQuerySettings.Merge(right.SpecifiedQuerySettings))
		{
			_leftChild = left;
			_rightChild = right;
			_resultSelector = resultSelector;
			_outputOrdered = _leftChild.OutputOrdered || _rightChild.OutputOrdered;
			OrdinalIndexState ordinalIndexState = _leftChild.OrdinalIndexState;
			OrdinalIndexState ordinalIndexState2 = _rightChild.OrdinalIndexState;
			_prematureMergeLeft = ordinalIndexState != OrdinalIndexState.Indexable;
			_prematureMergeRight = ordinalIndexState2 != OrdinalIndexState.Indexable;
			_limitsParallelism = (_prematureMergeLeft && ordinalIndexState != OrdinalIndexState.Shuffled) || (_prematureMergeRight && ordinalIndexState2 != OrdinalIndexState.Shuffled);
		}

		internal override QueryResults<TOutput> Open(QuerySettings settings, bool preferStriping)
		{
			QueryResults<TLeftInput> queryResults = _leftChild.Open(settings, preferStriping);
			QueryResults<TRightInput> queryResults2 = _rightChild.Open(settings, preferStriping);
			int value = settings.DegreeOfParallelism.Value;
			if (_prematureMergeLeft)
			{
				PartitionedStreamMerger<TLeftInput> partitionedStreamMerger = new PartitionedStreamMerger<TLeftInput>(forEffectMerge: false, ParallelMergeOptions.FullyBuffered, settings.TaskScheduler, _leftChild.OutputOrdered, settings.CancellationState, settings.QueryId);
				queryResults.GivePartitionedStream(partitionedStreamMerger);
				queryResults = new ListQueryResults<TLeftInput>(partitionedStreamMerger.MergeExecutor.GetResultsAsArray(), value, preferStriping);
			}
			if (_prematureMergeRight)
			{
				PartitionedStreamMerger<TRightInput> partitionedStreamMerger2 = new PartitionedStreamMerger<TRightInput>(forEffectMerge: false, ParallelMergeOptions.FullyBuffered, settings.TaskScheduler, _rightChild.OutputOrdered, settings.CancellationState, settings.QueryId);
				queryResults2.GivePartitionedStream(partitionedStreamMerger2);
				queryResults2 = new ListQueryResults<TRightInput>(partitionedStreamMerger2.MergeExecutor.GetResultsAsArray(), value, preferStriping);
			}
			return new ZipQueryOperatorResults(queryResults, queryResults2, _resultSelector, value, preferStriping);
		}

		internal override IEnumerable<TOutput> AsSequentialQuery(CancellationToken token)
		{
			using IEnumerator<TLeftInput> leftEnumerator = _leftChild.AsSequentialQuery(token).GetEnumerator();
			using IEnumerator<TRightInput> rightEnumerator = _rightChild.AsSequentialQuery(token).GetEnumerator();
			while (leftEnumerator.MoveNext() && rightEnumerator.MoveNext())
			{
				yield return _resultSelector(leftEnumerator.Current, rightEnumerator.Current);
			}
		}
	}
	internal abstract class BinaryQueryOperator<TLeftInput, TRightInput, TOutput> : QueryOperator<TOutput>
	{
		internal class BinaryQueryOperatorResults : QueryResults<TOutput>
		{
			private class LeftChildResultsRecipient : IPartitionedStreamRecipient<TLeftInput>
			{
				private IPartitionedStreamRecipient<TOutput> _outputRecipient;

				private BinaryQueryOperatorResults _results;

				private bool _preferStriping;

				private QuerySettings _settings;

				internal LeftChildResultsRecipient(IPartitionedStreamRecipient<TOutput> outputRecipient, BinaryQueryOperatorResults results, bool preferStriping, QuerySettings settings)
				{
					_outputRecipient = outputRecipient;
					_results = results;
					_preferStriping = preferStriping;
					_settings = settings;
				}

				public void Receive<TLeftKey>(PartitionedStream<TLeftInput, TLeftKey> source)
				{
					RightChildResultsRecipient<TLeftKey> recipient = new RightChildResultsRecipient<TLeftKey>(_outputRecipient, _results._op, source, _preferStriping, _settings);
					_results._rightChildQueryResults.GivePartitionedStream(recipient);
				}
			}

			private class RightChildResultsRecipient<TLeftKey> : IPartitionedStreamRecipient<TRightInput>
			{
				private IPartitionedStreamRecipient<TOutput> _outputRecipient;

				private PartitionedStream<TLeftInput, TLeftKey> _leftPartitionedStream;

				private BinaryQueryOperator<TLeftInput, TRightInput, TOutput> _op;

				private bool _preferStriping;

				private QuerySettings _settings;

				internal RightChildResultsRecipient(IPartitionedStreamRecipient<TOutput> outputRecipient, BinaryQueryOperator<TLeftInput, TRightInput, TOutput> op, PartitionedStream<TLeftInput, TLeftKey> leftPartitionedStream, bool preferStriping, QuerySettings settings)
				{
					_outputRecipient = outputRecipient;
					_op = op;
					_preferStriping = preferStriping;
					_leftPartitionedStream = leftPartitionedStream;
					_settings = settings;
				}

				public void Receive<TRightKey>(PartitionedStream<TRightInput, TRightKey> rightPartitionedStream)
				{
					_op.WrapPartitionedStream(_leftPartitionedStream, rightPartitionedStream, _outputRecipient, _preferStriping, _settings);
				}
			}

			protected QueryResults<TLeftInput> _leftChildQueryResults;

			protected QueryResults<TRightInput> _rightChildQueryResults;

			private BinaryQueryOperator<TLeftInput, TRightInput, TOutput> _op;

			private QuerySettings _settings;

			private bool _preferStriping;

			internal BinaryQueryOperatorResults(QueryResults<TLeftInput> leftChildQueryResults, QueryResults<TRightInput> rightChildQueryResults, BinaryQueryOperator<TLeftInput, TRightInput, TOutput> op, QuerySettings settings, bool preferStriping)
			{
				_leftChildQueryResults = leftChildQueryResults;
				_rightChildQueryResults = rightChildQueryResults;
				_op = op;
				_settings = settings;
				_preferStriping = preferStriping;
			}

			internal override void GivePartitionedStream(IPartitionedStreamRecipient<TOutput> recipient)
			{
				if (_settings.ExecutionMode.Value == ParallelExecutionMode.Default && _op.LimitsParallelism)
				{
					PartitionedStream<TOutput, int> partitionedStream = ExchangeUtilities.PartitionDataSource(_op.AsSequentialQuery(_settings.CancellationState.ExternalCancellationToken), _settings.DegreeOfParallelism.Value, _preferStriping);
					recipient.Receive(partitionedStream);
				}
				else if (IsIndexible)
				{
					PartitionedStream<TOutput, int> partitionedStream2 = ExchangeUtilities.PartitionDataSource(this, _settings.DegreeOfParallelism.Value, _preferStriping);
					recipient.Receive(partitionedStream2);
				}
				else
				{
					_leftChildQueryResults.GivePartitionedStream(new LeftChildResultsRecipient(recipient, this, _preferStriping, _settings));
				}
			}
		}

		private readonly QueryOperator<TLeftInput> _leftChild;

		private readonly QueryOperator<TRightInput> _rightChild;

		private OrdinalIndexState _indexState = OrdinalIndexState.Shuffled;

		internal QueryOperator<TLeftInput> LeftChild => _leftChild;

		internal QueryOperator<TRightInput> RightChild => _rightChild;

		internal sealed override OrdinalIndexState OrdinalIndexState => _indexState;

		internal BinaryQueryOperator(ParallelQuery<TLeftInput> leftChild, ParallelQuery<TRightInput> rightChild)
			: this(QueryOperator<TLeftInput>.AsQueryOperator(leftChild), QueryOperator<TRightInput>.AsQueryOperator(rightChild))
		{
		}

		internal BinaryQueryOperator(QueryOperator<TLeftInput> leftChild, QueryOperator<TRightInput> rightChild)
			: base(isOrdered: false, leftChild.SpecifiedQuerySettings.Merge(rightChild.SpecifiedQuerySettings))
		{
			_leftChild = leftChild;
			_rightChild = rightChild;
		}

		protected void SetOrdinalIndex(OrdinalIndexState indexState)
		{
			_indexState = indexState;
		}

		public abstract void WrapPartitionedStream<TLeftKey, TRightKey>(PartitionedStream<TLeftInput, TLeftKey> leftPartitionedStream, PartitionedStream<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient<TOutput> outputRecipient, bool preferStriping, QuerySettings settings);
	}
	internal sealed class CountAggregationOperator<TSource> : InlinedAggregationOperator<TSource, int, int>
	{
		private class CountAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<int>
		{
			private readonly QueryOperatorEnumerator<TSource, TKey> _source;

			internal CountAggregationOperatorEnumerator(QueryOperatorEnumerator<TSource, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref int currentElement)
			{
				TSource currentElement2 = default(TSource);
				TKey currentKey = default(TKey);
				QueryOperatorEnumerator<TSource, TKey> source = _source;
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					int num = 0;
					int num2 = 0;
					do
					{
						if ((num2++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						num = checked(num + 1);
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = num;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal CountAggregationOperator(IEnumerable<TSource> child)
			: base(child)
		{
		}

		protected override int InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<int> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			int num = 0;
			while (enumerator.MoveNext())
			{
				num = checked(num + enumerator.Current);
			}
			return num;
		}

		protected override QueryOperatorEnumerator<int, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<TSource, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new CountAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class DecimalAverageAggregationOperator : InlinedAggregationOperator<decimal, Pair<decimal, long>, decimal>
	{
		private class DecimalAverageAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<Pair<decimal, long>>
		{
			private QueryOperatorEnumerator<decimal, TKey> _source;

			internal DecimalAverageAggregationOperatorEnumerator(QueryOperatorEnumerator<decimal, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref Pair<decimal, long> currentElement)
			{
				decimal first = 0.0m;
				long num = 0L;
				QueryOperatorEnumerator<decimal, TKey> source = _source;
				decimal currentElement2 = default(decimal);
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					int num2 = 0;
					do
					{
						if ((num2++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						first += currentElement2;
						num = checked(num + 1);
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = new Pair<decimal, long>(first, num);
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal DecimalAverageAggregationOperator(IEnumerable<decimal> child)
			: base(child)
		{
		}

		protected override decimal InternalAggregate(ref Exception singularExceptionToThrow)
		{
			checked
			{
				using IEnumerator<Pair<decimal, long>> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
				if (!enumerator.MoveNext())
				{
					singularExceptionToThrow = new InvalidOperationException("Sequence contains no elements");
					return 0m;
				}
				Pair<decimal, long> current = enumerator.Current;
				while (enumerator.MoveNext())
				{
					current.First += enumerator.Current.First;
					current.Second += enumerator.Current.Second;
				}
				return current.First / (decimal)current.Second;
			}
		}

		protected override QueryOperatorEnumerator<Pair<decimal, long>, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<decimal, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new DecimalAverageAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class DecimalMinMaxAggregationOperator : InlinedAggregationOperator<decimal, decimal, decimal>
	{
		private class DecimalMinMaxAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<decimal>
		{
			private QueryOperatorEnumerator<decimal, TKey> _source;

			private int _sign;

			internal DecimalMinMaxAggregationOperatorEnumerator(QueryOperatorEnumerator<decimal, TKey> source, int partitionIndex, int sign, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
				_sign = sign;
			}

			protected override bool MoveNextCore(ref decimal currentElement)
			{
				QueryOperatorEnumerator<decimal, TKey> source = _source;
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement, ref currentKey))
				{
					int num = 0;
					if (_sign == -1)
					{
						decimal currentElement2 = default(decimal);
						while (source.MoveNext(ref currentElement2, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (currentElement2 < currentElement)
							{
								currentElement = currentElement2;
							}
						}
					}
					else
					{
						decimal currentElement3 = default(decimal);
						while (source.MoveNext(ref currentElement3, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (currentElement3 > currentElement)
							{
								currentElement = currentElement3;
							}
						}
					}
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly int _sign;

		internal DecimalMinMaxAggregationOperator(IEnumerable<decimal> child, int sign)
			: base(child)
		{
			_sign = sign;
		}

		protected override decimal InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<decimal> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			if (!enumerator.MoveNext())
			{
				singularExceptionToThrow = new InvalidOperationException("Sequence contains no elements");
				return 0m;
			}
			decimal num = enumerator.Current;
			if (_sign == -1)
			{
				while (enumerator.MoveNext())
				{
					decimal current = enumerator.Current;
					if (current < num)
					{
						num = current;
					}
				}
			}
			else
			{
				while (enumerator.MoveNext())
				{
					decimal current2 = enumerator.Current;
					if (current2 > num)
					{
						num = current2;
					}
				}
			}
			return num;
		}

		protected override QueryOperatorEnumerator<decimal, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<decimal, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new DecimalMinMaxAggregationOperatorEnumerator<TKey>(source, index, _sign, cancellationToken);
		}
	}
	internal sealed class DecimalSumAggregationOperator : InlinedAggregationOperator<decimal, decimal, decimal>
	{
		private class DecimalSumAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<decimal>
		{
			private QueryOperatorEnumerator<decimal, TKey> _source;

			internal DecimalSumAggregationOperatorEnumerator(QueryOperatorEnumerator<decimal, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref decimal currentElement)
			{
				decimal currentElement2 = default(decimal);
				TKey currentKey = default(TKey);
				QueryOperatorEnumerator<decimal, TKey> source = _source;
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					decimal num = 0.0m;
					int num2 = 0;
					do
					{
						if ((num2++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						num += currentElement2;
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = num;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal DecimalSumAggregationOperator(IEnumerable<decimal> child)
			: base(child)
		{
		}

		protected override decimal InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<decimal> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			decimal result = 0.0m;
			while (enumerator.MoveNext())
			{
				result += enumerator.Current;
			}
			return result;
		}

		protected override QueryOperatorEnumerator<decimal, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<decimal, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new DecimalSumAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class DoubleAverageAggregationOperator : InlinedAggregationOperator<double, Pair<double, long>, double>
	{
		private class DoubleAverageAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<Pair<double, long>>
		{
			private QueryOperatorEnumerator<double, TKey> _source;

			internal DoubleAverageAggregationOperatorEnumerator(QueryOperatorEnumerator<double, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref Pair<double, long> currentElement)
			{
				double num = 0.0;
				long num2 = 0L;
				QueryOperatorEnumerator<double, TKey> source = _source;
				double currentElement2 = 0.0;
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					int num3 = 0;
					do
					{
						if ((num3++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						num += currentElement2;
						num2 = checked(num2 + 1);
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = new Pair<double, long>(num, num2);
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal DoubleAverageAggregationOperator(IEnumerable<double> child)
			: base(child)
		{
		}

		protected override double InternalAggregate(ref Exception singularExceptionToThrow)
		{
			checked
			{
				using IEnumerator<Pair<double, long>> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
				if (!enumerator.MoveNext())
				{
					singularExceptionToThrow = new InvalidOperationException("Sequence contains no elements");
					return 0.0;
				}
				Pair<double, long> current = enumerator.Current;
				while (enumerator.MoveNext())
				{
					current.First += enumerator.Current.First;
					current.Second += enumerator.Current.Second;
				}
				return current.First / (double)current.Second;
			}
		}

		protected override QueryOperatorEnumerator<Pair<double, long>, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<double, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new DoubleAverageAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class DoubleMinMaxAggregationOperator : InlinedAggregationOperator<double, double, double>
	{
		private class DoubleMinMaxAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<double>
		{
			private QueryOperatorEnumerator<double, TKey> _source;

			private int _sign;

			internal DoubleMinMaxAggregationOperatorEnumerator(QueryOperatorEnumerator<double, TKey> source, int partitionIndex, int sign, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
				_sign = sign;
			}

			protected override bool MoveNextCore(ref double currentElement)
			{
				QueryOperatorEnumerator<double, TKey> source = _source;
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement, ref currentKey))
				{
					int num = 0;
					if (_sign == -1)
					{
						double currentElement2 = 0.0;
						while (source.MoveNext(ref currentElement2, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (currentElement2 < currentElement || double.IsNaN(currentElement2))
							{
								currentElement = currentElement2;
							}
						}
					}
					else
					{
						double currentElement3 = 0.0;
						while (source.MoveNext(ref currentElement3, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (currentElement3 > currentElement || double.IsNaN(currentElement))
							{
								currentElement = currentElement3;
							}
						}
					}
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly int _sign;

		internal DoubleMinMaxAggregationOperator(IEnumerable<double> child, int sign)
			: base(child)
		{
			_sign = sign;
		}

		protected override double InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<double> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			if (!enumerator.MoveNext())
			{
				singularExceptionToThrow = new InvalidOperationException("Sequence contains no elements");
				return 0.0;
			}
			double num = enumerator.Current;
			if (_sign == -1)
			{
				while (enumerator.MoveNext())
				{
					double current = enumerator.Current;
					if (current < num || double.IsNaN(current))
					{
						num = current;
					}
				}
			}
			else
			{
				while (enumerator.MoveNext())
				{
					double current2 = enumerator.Current;
					if (current2 > num || double.IsNaN(num))
					{
						num = current2;
					}
				}
			}
			return num;
		}

		protected override QueryOperatorEnumerator<double, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<double, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new DoubleMinMaxAggregationOperatorEnumerator<TKey>(source, index, _sign, cancellationToken);
		}
	}
	internal sealed class DoubleSumAggregationOperator : InlinedAggregationOperator<double, double, double>
	{
		private class DoubleSumAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<double>
		{
			private readonly QueryOperatorEnumerator<double, TKey> _source;

			internal DoubleSumAggregationOperatorEnumerator(QueryOperatorEnumerator<double, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref double currentElement)
			{
				double currentElement2 = 0.0;
				TKey currentKey = default(TKey);
				QueryOperatorEnumerator<double, TKey> source = _source;
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					double num = 0.0;
					int num2 = 0;
					do
					{
						if ((num2++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						num += currentElement2;
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = num;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal DoubleSumAggregationOperator(IEnumerable<double> child)
			: base(child)
		{
		}

		protected override double InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<double> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			double num = 0.0;
			while (enumerator.MoveNext())
			{
				num += enumerator.Current;
			}
			return num;
		}

		protected override QueryOperatorEnumerator<double, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<double, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new DoubleSumAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class FloatAverageAggregationOperator : InlinedAggregationOperator<float, Pair<double, long>, float>
	{
		private class FloatAverageAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<Pair<double, long>>
		{
			private QueryOperatorEnumerator<float, TKey> _source;

			internal FloatAverageAggregationOperatorEnumerator(QueryOperatorEnumerator<float, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref Pair<double, long> currentElement)
			{
				double num = 0.0;
				long num2 = 0L;
				QueryOperatorEnumerator<float, TKey> source = _source;
				float currentElement2 = 0f;
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					int num3 = 0;
					do
					{
						if ((num3++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						num += (double)currentElement2;
						num2 = checked(num2 + 1);
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = new Pair<double, long>(num, num2);
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal FloatAverageAggregationOperator(IEnumerable<float> child)
			: base(child)
		{
		}

		protected override float InternalAggregate(ref Exception singularExceptionToThrow)
		{
			checked
			{
				using IEnumerator<Pair<double, long>> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
				if (!enumerator.MoveNext())
				{
					singularExceptionToThrow = new InvalidOperationException("Sequence contains no elements");
					return 0f;
				}
				Pair<double, long> current = enumerator.Current;
				while (enumerator.MoveNext())
				{
					current.First += enumerator.Current.First;
					current.Second += enumerator.Current.Second;
				}
				return (float)(current.First / (double)current.Second);
			}
		}

		protected override QueryOperatorEnumerator<Pair<double, long>, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<float, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new FloatAverageAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class FloatMinMaxAggregationOperator : InlinedAggregationOperator<float, float, float>
	{
		private class FloatMinMaxAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<float>
		{
			private QueryOperatorEnumerator<float, TKey> _source;

			private int _sign;

			internal FloatMinMaxAggregationOperatorEnumerator(QueryOperatorEnumerator<float, TKey> source, int partitionIndex, int sign, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
				_sign = sign;
			}

			protected override bool MoveNextCore(ref float currentElement)
			{
				QueryOperatorEnumerator<float, TKey> source = _source;
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement, ref currentKey))
				{
					int num = 0;
					if (_sign == -1)
					{
						float currentElement2 = 0f;
						while (source.MoveNext(ref currentElement2, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (currentElement2 < currentElement || float.IsNaN(currentElement2))
							{
								currentElement = currentElement2;
							}
						}
					}
					else
					{
						float currentElement3 = 0f;
						while (source.MoveNext(ref currentElement3, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (currentElement3 > currentElement || float.IsNaN(currentElement))
							{
								currentElement = currentElement3;
							}
						}
					}
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly int _sign;

		internal FloatMinMaxAggregationOperator(IEnumerable<float> child, int sign)
			: base(child)
		{
			_sign = sign;
		}

		protected override float InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<float> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			if (!enumerator.MoveNext())
			{
				singularExceptionToThrow = new InvalidOperationException("Sequence contains no elements");
				return 0f;
			}
			float num = enumerator.Current;
			if (_sign == -1)
			{
				while (enumerator.MoveNext())
				{
					float current = enumerator.Current;
					if (current < num || float.IsNaN(current))
					{
						num = current;
					}
				}
			}
			else
			{
				while (enumerator.MoveNext())
				{
					float current2 = enumerator.Current;
					if (current2 > num || float.IsNaN(num))
					{
						num = current2;
					}
				}
			}
			return num;
		}

		protected override QueryOperatorEnumerator<float, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<float, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new FloatMinMaxAggregationOperatorEnumerator<TKey>(source, index, _sign, cancellationToken);
		}
	}
	internal sealed class FloatSumAggregationOperator : InlinedAggregationOperator<float, double, float>
	{
		private class FloatSumAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<double>
		{
			private readonly QueryOperatorEnumerator<float, TKey> _source;

			internal FloatSumAggregationOperatorEnumerator(QueryOperatorEnumerator<float, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref double currentElement)
			{
				float currentElement2 = 0f;
				TKey currentKey = default(TKey);
				QueryOperatorEnumerator<float, TKey> source = _source;
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					double num = 0.0;
					int num2 = 0;
					do
					{
						if ((num2++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						num += (double)currentElement2;
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = num;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal FloatSumAggregationOperator(IEnumerable<float> child)
			: base(child)
		{
		}

		protected override float InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<double> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			double num = 0.0;
			while (enumerator.MoveNext())
			{
				num += enumerator.Current;
			}
			return (float)num;
		}

		protected override QueryOperatorEnumerator<double, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<float, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new FloatSumAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal abstract class InlinedAggregationOperator<TSource, TIntermediate, TResult> : UnaryQueryOperator<TSource, TIntermediate>
	{
		internal override bool LimitsParallelism => false;

		internal InlinedAggregationOperator(IEnumerable<TSource> child)
			: base(child)
		{
		}

		internal TResult Aggregate()
		{
			Exception singularExceptionToThrow = null;
			TResult result;
			try
			{
				result = InternalAggregate(ref singularExceptionToThrow);
			}
			catch (Exception ex)
			{
				if (!(ex is AggregateException))
				{
					if (ex is OperationCanceledException ex2 && ex2.CancellationToken == base.SpecifiedQuerySettings.CancellationState.ExternalCancellationToken && base.SpecifiedQuerySettings.CancellationState.ExternalCancellationToken.IsCancellationRequested)
					{
						throw;
					}
					throw new AggregateException(ex);
				}
				throw;
			}
			if (singularExceptionToThrow != null)
			{
				throw singularExceptionToThrow;
			}
			return result;
		}

		protected abstract TResult InternalAggregate(ref Exception singularExceptionToThrow);

		internal override QueryResults<TIntermediate> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping), this, settings, preferStriping);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TSource, TKey> inputStream, IPartitionedStreamRecipient<TIntermediate> recipient, bool preferStriping, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			PartitionedStream<TIntermediate, int> partitionedStream = new PartitionedStream<TIntermediate, int>(partitionCount, Util.GetDefaultComparer<int>(), OrdinalIndexState.Correct);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream[i] = CreateEnumerator(i, partitionCount, inputStream[i], null, settings.CancellationState.MergedCancellationToken);
			}
			recipient.Receive(partitionedStream);
		}

		protected abstract QueryOperatorEnumerator<TIntermediate, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<TSource, TKey> source, object sharedData, CancellationToken cancellationToken);

		[ExcludeFromCodeCoverage]
		internal override IEnumerable<TIntermediate> AsSequentialQuery(CancellationToken token)
		{
			throw new NotSupportedException();
		}
	}
	internal abstract class InlinedAggregationOperatorEnumerator<TIntermediate> : QueryOperatorEnumerator<TIntermediate, int>
	{
		private int _partitionIndex;

		private bool _done;

		protected CancellationToken _cancellationToken;

		internal InlinedAggregationOperatorEnumerator(int partitionIndex, CancellationToken cancellationToken)
		{
			_partitionIndex = partitionIndex;
			_cancellationToken = cancellationToken;
		}

		internal sealed override bool MoveNext(ref TIntermediate currentElement, ref int currentKey)
		{
			if (!_done && MoveNextCore(ref currentElement))
			{
				currentKey = _partitionIndex;
				_done = true;
				return true;
			}
			return false;
		}

		protected abstract bool MoveNextCore(ref TIntermediate currentElement);
	}
	internal sealed class IntAverageAggregationOperator : InlinedAggregationOperator<int, Pair<long, long>, double>
	{
		private class IntAverageAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<Pair<long, long>>
		{
			private QueryOperatorEnumerator<int, TKey> _source;

			internal IntAverageAggregationOperatorEnumerator(QueryOperatorEnumerator<int, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref Pair<long, long> currentElement)
			{
				long num = 0L;
				long num2 = 0L;
				QueryOperatorEnumerator<int, TKey> source = _source;
				int currentElement2 = 0;
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					int num3 = 0;
					do
					{
						if ((num3++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						checked
						{
							num += currentElement2;
							num2++;
						}
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = new Pair<long, long>(num, num2);
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal IntAverageAggregationOperator(IEnumerable<int> child)
			: base(child)
		{
		}

		protected override double InternalAggregate(ref Exception singularExceptionToThrow)
		{
			checked
			{
				using IEnumerator<Pair<long, long>> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
				if (!enumerator.MoveNext())
				{
					singularExceptionToThrow = new InvalidOperationException("Sequence contains no elements");
					return 0.0;
				}
				Pair<long, long> current = enumerator.Current;
				while (enumerator.MoveNext())
				{
					current.First += enumerator.Current.First;
					current.Second += enumerator.Current.Second;
				}
				return (double)current.First / (double)current.Second;
			}
		}

		protected override QueryOperatorEnumerator<Pair<long, long>, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<int, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new IntAverageAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class IntMinMaxAggregationOperator : InlinedAggregationOperator<int, int, int>
	{
		private class IntMinMaxAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<int>
		{
			private readonly QueryOperatorEnumerator<int, TKey> _source;

			private readonly int _sign;

			internal IntMinMaxAggregationOperatorEnumerator(QueryOperatorEnumerator<int, TKey> source, int partitionIndex, int sign, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
				_sign = sign;
			}

			protected override bool MoveNextCore(ref int currentElement)
			{
				QueryOperatorEnumerator<int, TKey> source = _source;
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement, ref currentKey))
				{
					int num = 0;
					if (_sign == -1)
					{
						int currentElement2 = 0;
						while (source.MoveNext(ref currentElement2, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (currentElement2 < currentElement)
							{
								currentElement = currentElement2;
							}
						}
					}
					else
					{
						int currentElement3 = 0;
						while (source.MoveNext(ref currentElement3, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (currentElement3 > currentElement)
							{
								currentElement = currentElement3;
							}
						}
					}
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly int _sign;

		internal IntMinMaxAggregationOperator(IEnumerable<int> child, int sign)
			: base(child)
		{
			_sign = sign;
		}

		protected override int InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<int> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			if (!enumerator.MoveNext())
			{
				singularExceptionToThrow = new InvalidOperationException("Sequence contains no elements");
				return 0;
			}
			int num = enumerator.Current;
			if (_sign == -1)
			{
				while (enumerator.MoveNext())
				{
					int current = enumerator.Current;
					if (current < num)
					{
						num = current;
					}
				}
			}
			else
			{
				while (enumerator.MoveNext())
				{
					int current2 = enumerator.Current;
					if (current2 > num)
					{
						num = current2;
					}
				}
			}
			return num;
		}

		protected override QueryOperatorEnumerator<int, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<int, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new IntMinMaxAggregationOperatorEnumerator<TKey>(source, index, _sign, cancellationToken);
		}
	}
	internal sealed class IntSumAggregationOperator : InlinedAggregationOperator<int, int, int>
	{
		private class IntSumAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<int>
		{
			private readonly QueryOperatorEnumerator<int, TKey> _source;

			internal IntSumAggregationOperatorEnumerator(QueryOperatorEnumerator<int, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref int currentElement)
			{
				int currentElement2 = 0;
				TKey currentKey = default(TKey);
				QueryOperatorEnumerator<int, TKey> source = _source;
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					int num = 0;
					int num2 = 0;
					do
					{
						if ((num2++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						num = checked(num + currentElement2);
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = num;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal IntSumAggregationOperator(IEnumerable<int> child)
			: base(child)
		{
		}

		protected override int InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<int> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			int num = 0;
			while (enumerator.MoveNext())
			{
				num = checked(num + enumerator.Current);
			}
			return num;
		}

		protected override QueryOperatorEnumerator<int, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<int, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new IntSumAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class LongAverageAggregationOperator : InlinedAggregationOperator<long, Pair<long, long>, double>
	{
		private class LongAverageAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<Pair<long, long>>
		{
			private QueryOperatorEnumerator<long, TKey> _source;

			internal LongAverageAggregationOperatorEnumerator(QueryOperatorEnumerator<long, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref Pair<long, long> currentElement)
			{
				long num = 0L;
				long num2 = 0L;
				QueryOperatorEnumerator<long, TKey> source = _source;
				long currentElement2 = 0L;
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					int num3 = 0;
					do
					{
						if ((num3++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						checked
						{
							num += currentElement2;
							num2++;
						}
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = new Pair<long, long>(num, num2);
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal LongAverageAggregationOperator(IEnumerable<long> child)
			: base(child)
		{
		}

		protected override double InternalAggregate(ref Exception singularExceptionToThrow)
		{
			checked
			{
				using IEnumerator<Pair<long, long>> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
				if (!enumerator.MoveNext())
				{
					singularExceptionToThrow = new InvalidOperationException("Sequence contains no elements");
					return 0.0;
				}
				Pair<long, long> current = enumerator.Current;
				while (enumerator.MoveNext())
				{
					current.First += enumerator.Current.First;
					current.Second += enumerator.Current.Second;
				}
				return (double)current.First / (double)current.Second;
			}
		}

		protected override QueryOperatorEnumerator<Pair<long, long>, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<long, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new LongAverageAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class LongCountAggregationOperator<TSource> : InlinedAggregationOperator<TSource, long, long>
	{
		private class LongCountAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<long>
		{
			private readonly QueryOperatorEnumerator<TSource, TKey> _source;

			internal LongCountAggregationOperatorEnumerator(QueryOperatorEnumerator<TSource, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref long currentElement)
			{
				TSource currentElement2 = default(TSource);
				TKey currentKey = default(TKey);
				QueryOperatorEnumerator<TSource, TKey> source = _source;
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					long num = 0L;
					int num2 = 0;
					do
					{
						if ((num2++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						num = checked(num + 1);
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = num;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal LongCountAggregationOperator(IEnumerable<TSource> child)
			: base(child)
		{
		}

		protected override long InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<long> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			long num = 0L;
			while (enumerator.MoveNext())
			{
				num = checked(num + enumerator.Current);
			}
			return num;
		}

		protected override QueryOperatorEnumerator<long, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<TSource, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new LongCountAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class LongMinMaxAggregationOperator : InlinedAggregationOperator<long, long, long>
	{
		private class LongMinMaxAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<long>
		{
			private QueryOperatorEnumerator<long, TKey> _source;

			private int _sign;

			internal LongMinMaxAggregationOperatorEnumerator(QueryOperatorEnumerator<long, TKey> source, int partitionIndex, int sign, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
				_sign = sign;
			}

			protected override bool MoveNextCore(ref long currentElement)
			{
				QueryOperatorEnumerator<long, TKey> source = _source;
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement, ref currentKey))
				{
					int num = 0;
					if (_sign == -1)
					{
						long currentElement2 = 0L;
						while (source.MoveNext(ref currentElement2, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (currentElement2 < currentElement)
							{
								currentElement = currentElement2;
							}
						}
					}
					else
					{
						long currentElement3 = 0L;
						while (source.MoveNext(ref currentElement3, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (currentElement3 > currentElement)
							{
								currentElement = currentElement3;
							}
						}
					}
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly int _sign;

		internal LongMinMaxAggregationOperator(IEnumerable<long> child, int sign)
			: base(child)
		{
			_sign = sign;
		}

		protected override long InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<long> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			if (!enumerator.MoveNext())
			{
				singularExceptionToThrow = new InvalidOperationException("Sequence contains no elements");
				return 0L;
			}
			long num = enumerator.Current;
			if (_sign == -1)
			{
				while (enumerator.MoveNext())
				{
					long current = enumerator.Current;
					if (current < num)
					{
						num = current;
					}
				}
			}
			else
			{
				while (enumerator.MoveNext())
				{
					long current2 = enumerator.Current;
					if (current2 > num)
					{
						num = current2;
					}
				}
			}
			return num;
		}

		protected override QueryOperatorEnumerator<long, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<long, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new LongMinMaxAggregationOperatorEnumerator<TKey>(source, index, _sign, cancellationToken);
		}
	}
	internal sealed class LongSumAggregationOperator : InlinedAggregationOperator<long, long, long>
	{
		private class LongSumAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<long>
		{
			private readonly QueryOperatorEnumerator<long, TKey> _source;

			internal LongSumAggregationOperatorEnumerator(QueryOperatorEnumerator<long, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref long currentElement)
			{
				long currentElement2 = 0L;
				TKey currentKey = default(TKey);
				QueryOperatorEnumerator<long, TKey> source = _source;
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					long num = 0L;
					int num2 = 0;
					do
					{
						if ((num2++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						num = checked(num + currentElement2);
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = num;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal LongSumAggregationOperator(IEnumerable<long> child)
			: base(child)
		{
		}

		protected override long InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<long> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			long num = 0L;
			while (enumerator.MoveNext())
			{
				num = checked(num + enumerator.Current);
			}
			return num;
		}

		protected override QueryOperatorEnumerator<long, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<long, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new LongSumAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class NullableDecimalAverageAggregationOperator : InlinedAggregationOperator<decimal?, Pair<decimal, long>, decimal?>
	{
		private class NullableDecimalAverageAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<Pair<decimal, long>>
		{
			private QueryOperatorEnumerator<decimal?, TKey> _source;

			internal NullableDecimalAverageAggregationOperatorEnumerator(QueryOperatorEnumerator<decimal?, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref Pair<decimal, long> currentElement)
			{
				decimal first = 0.0m;
				long num = 0L;
				QueryOperatorEnumerator<decimal?, TKey> source = _source;
				decimal? currentElement2 = null;
				TKey currentKey = default(TKey);
				int num2 = 0;
				while (source.MoveNext(ref currentElement2, ref currentKey))
				{
					if ((num2++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					if (currentElement2.HasValue)
					{
						first += currentElement2.GetValueOrDefault();
						num = checked(num + 1);
					}
				}
				currentElement = new Pair<decimal, long>(first, num);
				return num > 0;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal NullableDecimalAverageAggregationOperator(IEnumerable<decimal?> child)
			: base(child)
		{
		}

		protected override decimal? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			checked
			{
				using IEnumerator<Pair<decimal, long>> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
				if (!enumerator.MoveNext())
				{
					return null;
				}
				Pair<decimal, long> current = enumerator.Current;
				while (enumerator.MoveNext())
				{
					current.First += enumerator.Current.First;
					current.Second += enumerator.Current.Second;
				}
				return current.First / (decimal)current.Second;
			}
		}

		protected override QueryOperatorEnumerator<Pair<decimal, long>, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<decimal?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableDecimalAverageAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class NullableDecimalMinMaxAggregationOperator : InlinedAggregationOperator<decimal?, decimal?, decimal?>
	{
		private class NullableDecimalMinMaxAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<decimal?>
		{
			private QueryOperatorEnumerator<decimal?, TKey> _source;

			private int _sign;

			internal NullableDecimalMinMaxAggregationOperatorEnumerator(QueryOperatorEnumerator<decimal?, TKey> source, int partitionIndex, int sign, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
				_sign = sign;
			}

			protected override bool MoveNextCore(ref decimal? currentElement)
			{
				QueryOperatorEnumerator<decimal?, TKey> source = _source;
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement, ref currentKey))
				{
					int num = 0;
					if (_sign == -1)
					{
						decimal? currentElement2 = null;
						while (source.MoveNext(ref currentElement2, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (!currentElement.HasValue || currentElement2 < currentElement)
							{
								currentElement = currentElement2;
							}
						}
					}
					else
					{
						decimal? currentElement3 = null;
						while (source.MoveNext(ref currentElement3, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (!currentElement.HasValue || currentElement3 > currentElement)
							{
								currentElement = currentElement3;
							}
						}
					}
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly int _sign;

		internal NullableDecimalMinMaxAggregationOperator(IEnumerable<decimal?> child, int sign)
			: base(child)
		{
			_sign = sign;
		}

		protected override decimal? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<decimal?> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			if (!enumerator.MoveNext())
			{
				return null;
			}
			decimal? num = enumerator.Current;
			if (_sign == -1)
			{
				while (enumerator.MoveNext())
				{
					decimal? current = enumerator.Current;
					if (!num.HasValue || current < num)
					{
						num = current;
					}
				}
			}
			else
			{
				while (enumerator.MoveNext())
				{
					decimal? current2 = enumerator.Current;
					if (!num.HasValue || current2 > num)
					{
						num = current2;
					}
				}
			}
			return num;
		}

		protected override QueryOperatorEnumerator<decimal?, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<decimal?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableDecimalMinMaxAggregationOperatorEnumerator<TKey>(source, index, _sign, cancellationToken);
		}
	}
	internal sealed class NullableDecimalSumAggregationOperator : InlinedAggregationOperator<decimal?, decimal?, decimal?>
	{
		private class NullableDecimalSumAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<decimal?>
		{
			private readonly QueryOperatorEnumerator<decimal?, TKey> _source;

			internal NullableDecimalSumAggregationOperatorEnumerator(QueryOperatorEnumerator<decimal?, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref decimal? currentElement)
			{
				decimal? currentElement2 = null;
				TKey currentKey = default(TKey);
				QueryOperatorEnumerator<decimal?, TKey> source = _source;
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					decimal value = 0.0m;
					int num = 0;
					do
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						value += currentElement2.GetValueOrDefault();
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = value;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal NullableDecimalSumAggregationOperator(IEnumerable<decimal?> child)
			: base(child)
		{
		}

		protected override decimal? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<decimal?> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			decimal value = 0.0m;
			while (enumerator.MoveNext())
			{
				value += enumerator.Current.GetValueOrDefault();
			}
			return value;
		}

		protected override QueryOperatorEnumerator<decimal?, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<decimal?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableDecimalSumAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class NullableDoubleAverageAggregationOperator : InlinedAggregationOperator<double?, Pair<double, long>, double?>
	{
		private class NullableDoubleAverageAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<Pair<double, long>>
		{
			private QueryOperatorEnumerator<double?, TKey> _source;

			internal NullableDoubleAverageAggregationOperatorEnumerator(QueryOperatorEnumerator<double?, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref Pair<double, long> currentElement)
			{
				double num = 0.0;
				long num2 = 0L;
				QueryOperatorEnumerator<double?, TKey> source = _source;
				double? currentElement2 = null;
				TKey currentKey = default(TKey);
				int num3 = 0;
				while (source.MoveNext(ref currentElement2, ref currentKey))
				{
					if (currentElement2.HasValue)
					{
						if ((num3++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						num += currentElement2.GetValueOrDefault();
						num2 = checked(num2 + 1);
					}
				}
				currentElement = new Pair<double, long>(num, num2);
				return num2 > 0;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal NullableDoubleAverageAggregationOperator(IEnumerable<double?> child)
			: base(child)
		{
		}

		protected override double? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			checked
			{
				using IEnumerator<Pair<double, long>> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
				if (!enumerator.MoveNext())
				{
					return null;
				}
				Pair<double, long> current = enumerator.Current;
				while (enumerator.MoveNext())
				{
					current.First += enumerator.Current.First;
					current.Second += enumerator.Current.Second;
				}
				return current.First / (double)current.Second;
			}
		}

		protected override QueryOperatorEnumerator<Pair<double, long>, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<double?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableDoubleAverageAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class NullableDoubleMinMaxAggregationOperator : InlinedAggregationOperator<double?, double?, double?>
	{
		private class NullableDoubleMinMaxAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<double?>
		{
			private QueryOperatorEnumerator<double?, TKey> _source;

			private int _sign;

			internal NullableDoubleMinMaxAggregationOperatorEnumerator(QueryOperatorEnumerator<double?, TKey> source, int partitionIndex, int sign, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
				_sign = sign;
			}

			protected override bool MoveNextCore(ref double? currentElement)
			{
				QueryOperatorEnumerator<double?, TKey> source = _source;
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement, ref currentKey))
				{
					int num = 0;
					if (_sign == -1)
					{
						double? currentElement2 = null;
						while (source.MoveNext(ref currentElement2, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (currentElement2.HasValue && (!currentElement.HasValue || currentElement2 < currentElement || double.IsNaN(currentElement2.GetValueOrDefault())))
							{
								currentElement = currentElement2;
							}
						}
					}
					else
					{
						double? currentElement3 = null;
						while (source.MoveNext(ref currentElement3, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (currentElement3.HasValue && (!currentElement.HasValue || currentElement3 > currentElement || double.IsNaN(currentElement.GetValueOrDefault())))
							{
								currentElement = currentElement3;
							}
						}
					}
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly int _sign;

		internal NullableDoubleMinMaxAggregationOperator(IEnumerable<double?> child, int sign)
			: base(child)
		{
			_sign = sign;
		}

		protected override double? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<double?> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			if (!enumerator.MoveNext())
			{
				return null;
			}
			double? num = enumerator.Current;
			if (_sign == -1)
			{
				while (enumerator.MoveNext())
				{
					double? current = enumerator.Current;
					if (current.HasValue && (!num.HasValue || current < num || double.IsNaN(current.GetValueOrDefault())))
					{
						num = current;
					}
				}
			}
			else
			{
				while (enumerator.MoveNext())
				{
					double? current2 = enumerator.Current;
					if (current2.HasValue && (!num.HasValue || current2 > num || double.IsNaN(num.GetValueOrDefault())))
					{
						num = current2;
					}
				}
			}
			return num;
		}

		protected override QueryOperatorEnumerator<double?, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<double?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableDoubleMinMaxAggregationOperatorEnumerator<TKey>(source, index, _sign, cancellationToken);
		}
	}
	internal sealed class NullableDoubleSumAggregationOperator : InlinedAggregationOperator<double?, double?, double?>
	{
		private class NullableDoubleSumAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<double?>
		{
			private readonly QueryOperatorEnumerator<double?, TKey> _source;

			internal NullableDoubleSumAggregationOperatorEnumerator(QueryOperatorEnumerator<double?, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref double? currentElement)
			{
				double? currentElement2 = null;
				TKey currentKey = default(TKey);
				QueryOperatorEnumerator<double?, TKey> source = _source;
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					double num = 0.0;
					int num2 = 0;
					do
					{
						if ((num2++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						num += currentElement2.GetValueOrDefault();
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = num;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal NullableDoubleSumAggregationOperator(IEnumerable<double?> child)
			: base(child)
		{
		}

		protected override double? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<double?> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			double num = 0.0;
			while (enumerator.MoveNext())
			{
				num += enumerator.Current.GetValueOrDefault();
			}
			return num;
		}

		protected override QueryOperatorEnumerator<double?, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<double?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableDoubleSumAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class NullableFloatAverageAggregationOperator : InlinedAggregationOperator<float?, Pair<double, long>, float?>
	{
		private class NullableFloatAverageAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<Pair<double, long>>
		{
			private QueryOperatorEnumerator<float?, TKey> _source;

			internal NullableFloatAverageAggregationOperatorEnumerator(QueryOperatorEnumerator<float?, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref Pair<double, long> currentElement)
			{
				double num = 0.0;
				long num2 = 0L;
				QueryOperatorEnumerator<float?, TKey> source = _source;
				float? currentElement2 = null;
				TKey currentKey = default(TKey);
				int num3 = 0;
				while (source.MoveNext(ref currentElement2, ref currentKey))
				{
					if ((num3++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					if (currentElement2.HasValue)
					{
						num += (double)currentElement2.GetValueOrDefault();
						num2 = checked(num2 + 1);
					}
				}
				currentElement = new Pair<double, long>(num, num2);
				return num2 > 0;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal NullableFloatAverageAggregationOperator(IEnumerable<float?> child)
			: base(child)
		{
		}

		protected override float? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			checked
			{
				using IEnumerator<Pair<double, long>> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
				if (!enumerator.MoveNext())
				{
					return null;
				}
				Pair<double, long> current = enumerator.Current;
				while (enumerator.MoveNext())
				{
					current.First += enumerator.Current.First;
					current.Second += enumerator.Current.Second;
				}
				return (float)(current.First / (double)current.Second);
			}
		}

		protected override QueryOperatorEnumerator<Pair<double, long>, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<float?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableFloatAverageAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class NullableFloatMinMaxAggregationOperator : InlinedAggregationOperator<float?, float?, float?>
	{
		private class NullableFloatMinMaxAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<float?>
		{
			private QueryOperatorEnumerator<float?, TKey> _source;

			private int _sign;

			internal NullableFloatMinMaxAggregationOperatorEnumerator(QueryOperatorEnumerator<float?, TKey> source, int partitionIndex, int sign, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
				_sign = sign;
			}

			protected override bool MoveNextCore(ref float? currentElement)
			{
				QueryOperatorEnumerator<float?, TKey> source = _source;
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement, ref currentKey))
				{
					int num = 0;
					if (_sign == -1)
					{
						float? currentElement2 = null;
						while (source.MoveNext(ref currentElement2, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (currentElement2.HasValue && (!currentElement.HasValue || currentElement2 < currentElement || float.IsNaN(currentElement2.GetValueOrDefault())))
							{
								currentElement = currentElement2;
							}
						}
					}
					else
					{
						float? currentElement3 = null;
						while (source.MoveNext(ref currentElement3, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (currentElement3.HasValue && (!currentElement.HasValue || currentElement3 > currentElement || float.IsNaN(currentElement.GetValueOrDefault())))
							{
								currentElement = currentElement3;
							}
						}
					}
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly int _sign;

		internal NullableFloatMinMaxAggregationOperator(IEnumerable<float?> child, int sign)
			: base(child)
		{
			_sign = sign;
		}

		protected override float? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<float?> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			if (!enumerator.MoveNext())
			{
				return null;
			}
			float? num = enumerator.Current;
			if (_sign == -1)
			{
				while (enumerator.MoveNext())
				{
					float? current = enumerator.Current;
					if (current.HasValue && (!num.HasValue || current < num || float.IsNaN(current.GetValueOrDefault())))
					{
						num = current;
					}
				}
			}
			else
			{
				while (enumerator.MoveNext())
				{
					float? current2 = enumerator.Current;
					if (current2.HasValue && (!num.HasValue || current2 > num || float.IsNaN(num.GetValueOrDefault())))
					{
						num = current2;
					}
				}
			}
			return num;
		}

		protected override QueryOperatorEnumerator<float?, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<float?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableFloatMinMaxAggregationOperatorEnumerator<TKey>(source, index, _sign, cancellationToken);
		}
	}
	internal sealed class NullableFloatSumAggregationOperator : InlinedAggregationOperator<float?, double?, float?>
	{
		private class NullableFloatSumAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<double?>
		{
			private readonly QueryOperatorEnumerator<float?, TKey> _source;

			internal NullableFloatSumAggregationOperatorEnumerator(QueryOperatorEnumerator<float?, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref double? currentElement)
			{
				float? currentElement2 = null;
				TKey currentKey = default(TKey);
				QueryOperatorEnumerator<float?, TKey> source = _source;
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					double num = 0.0;
					int num2 = 0;
					do
					{
						if ((num2++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						num += (double)currentElement2.GetValueOrDefault();
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = num;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal NullableFloatSumAggregationOperator(IEnumerable<float?> child)
			: base(child)
		{
		}

		protected override float? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<double?> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			double num = 0.0;
			while (enumerator.MoveNext())
			{
				num += enumerator.Current.GetValueOrDefault();
			}
			return (float)num;
		}

		protected override QueryOperatorEnumerator<double?, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<float?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableFloatSumAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class NullableIntAverageAggregationOperator : InlinedAggregationOperator<int?, Pair<long, long>, double?>
	{
		private class NullableIntAverageAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<Pair<long, long>>
		{
			private QueryOperatorEnumerator<int?, TKey> _source;

			internal NullableIntAverageAggregationOperatorEnumerator(QueryOperatorEnumerator<int?, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref Pair<long, long> currentElement)
			{
				long num = 0L;
				long num2 = 0L;
				QueryOperatorEnumerator<int?, TKey> source = _source;
				int? currentElement2 = null;
				TKey currentKey = default(TKey);
				int num3 = 0;
				while (source.MoveNext(ref currentElement2, ref currentKey))
				{
					if ((num3++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					checked
					{
						if (currentElement2.HasValue)
						{
							num += currentElement2.GetValueOrDefault();
							num2++;
						}
					}
				}
				currentElement = new Pair<long, long>(num, num2);
				return num2 > 0;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal NullableIntAverageAggregationOperator(IEnumerable<int?> child)
			: base(child)
		{
		}

		protected override double? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			checked
			{
				using IEnumerator<Pair<long, long>> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
				if (!enumerator.MoveNext())
				{
					return null;
				}
				Pair<long, long> current = enumerator.Current;
				while (enumerator.MoveNext())
				{
					current.First += enumerator.Current.First;
					current.Second += enumerator.Current.Second;
				}
				return (double)current.First / (double)current.Second;
			}
		}

		protected override QueryOperatorEnumerator<Pair<long, long>, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<int?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableIntAverageAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class NullableIntMinMaxAggregationOperator : InlinedAggregationOperator<int?, int?, int?>
	{
		private class NullableIntMinMaxAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<int?>
		{
			private QueryOperatorEnumerator<int?, TKey> _source;

			private int _sign;

			internal NullableIntMinMaxAggregationOperatorEnumerator(QueryOperatorEnumerator<int?, TKey> source, int partitionIndex, int sign, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
				_sign = sign;
			}

			protected override bool MoveNextCore(ref int? currentElement)
			{
				QueryOperatorEnumerator<int?, TKey> source = _source;
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement, ref currentKey))
				{
					int num = 0;
					if (_sign == -1)
					{
						int? currentElement2 = null;
						while (source.MoveNext(ref currentElement2, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (!currentElement.HasValue || currentElement2 < currentElement)
							{
								currentElement = currentElement2;
							}
						}
					}
					else
					{
						int? currentElement3 = null;
						while (source.MoveNext(ref currentElement3, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (!currentElement.HasValue || currentElement3 > currentElement)
							{
								currentElement = currentElement3;
							}
						}
					}
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly int _sign;

		internal NullableIntMinMaxAggregationOperator(IEnumerable<int?> child, int sign)
			: base(child)
		{
			_sign = sign;
		}

		protected override int? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<int?> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			if (!enumerator.MoveNext())
			{
				return null;
			}
			int? num = enumerator.Current;
			if (_sign == -1)
			{
				while (enumerator.MoveNext())
				{
					int? current = enumerator.Current;
					if (!num.HasValue || current < num)
					{
						num = current;
					}
				}
			}
			else
			{
				while (enumerator.MoveNext())
				{
					int? current2 = enumerator.Current;
					if (!num.HasValue || current2 > num)
					{
						num = current2;
					}
				}
			}
			return num;
		}

		protected override QueryOperatorEnumerator<int?, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<int?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableIntMinMaxAggregationOperatorEnumerator<TKey>(source, index, _sign, cancellationToken);
		}
	}
	internal sealed class NullableIntSumAggregationOperator : InlinedAggregationOperator<int?, int?, int?>
	{
		private class NullableIntSumAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<int?>
		{
			private QueryOperatorEnumerator<int?, TKey> _source;

			internal NullableIntSumAggregationOperatorEnumerator(QueryOperatorEnumerator<int?, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref int? currentElement)
			{
				int? currentElement2 = null;
				TKey currentKey = default(TKey);
				QueryOperatorEnumerator<int?, TKey> source = _source;
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					int num = 0;
					int num2 = 0;
					do
					{
						if ((num2++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						num = checked(num + currentElement2.GetValueOrDefault());
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = num;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal NullableIntSumAggregationOperator(IEnumerable<int?> child)
			: base(child)
		{
		}

		protected override int? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<int?> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			int num = 0;
			while (enumerator.MoveNext())
			{
				num = checked(num + enumerator.Current.GetValueOrDefault());
			}
			return num;
		}

		protected override QueryOperatorEnumerator<int?, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<int?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableIntSumAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class NullableLongAverageAggregationOperator : InlinedAggregationOperator<long?, Pair<long, long>, double?>
	{
		private class NullableLongAverageAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<Pair<long, long>>
		{
			private QueryOperatorEnumerator<long?, TKey> _source;

			internal NullableLongAverageAggregationOperatorEnumerator(QueryOperatorEnumerator<long?, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref Pair<long, long> currentElement)
			{
				long num = 0L;
				long num2 = 0L;
				QueryOperatorEnumerator<long?, TKey> source = _source;
				long? currentElement2 = null;
				TKey currentKey = default(TKey);
				int num3 = 0;
				while (source.MoveNext(ref currentElement2, ref currentKey))
				{
					if ((num3++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					checked
					{
						if (currentElement2.HasValue)
						{
							num += currentElement2.GetValueOrDefault();
							num2++;
						}
					}
				}
				currentElement = new Pair<long, long>(num, num2);
				return num2 > 0;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal NullableLongAverageAggregationOperator(IEnumerable<long?> child)
			: base(child)
		{
		}

		protected override double? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			checked
			{
				using IEnumerator<Pair<long, long>> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
				if (!enumerator.MoveNext())
				{
					return null;
				}
				Pair<long, long> current = enumerator.Current;
				while (enumerator.MoveNext())
				{
					current.First += enumerator.Current.First;
					current.Second += enumerator.Current.Second;
				}
				return (double)current.First / (double)current.Second;
			}
		}

		protected override QueryOperatorEnumerator<Pair<long, long>, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<long?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableLongAverageAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal sealed class NullableLongMinMaxAggregationOperator : InlinedAggregationOperator<long?, long?, long?>
	{
		private class NullableLongMinMaxAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<long?>
		{
			private QueryOperatorEnumerator<long?, TKey> _source;

			private int _sign;

			internal NullableLongMinMaxAggregationOperatorEnumerator(QueryOperatorEnumerator<long?, TKey> source, int partitionIndex, int sign, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
				_sign = sign;
			}

			protected override bool MoveNextCore(ref long? currentElement)
			{
				QueryOperatorEnumerator<long?, TKey> source = _source;
				TKey currentKey = default(TKey);
				if (source.MoveNext(ref currentElement, ref currentKey))
				{
					int num = 0;
					if (_sign == -1)
					{
						long? currentElement2 = null;
						while (source.MoveNext(ref currentElement2, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (!currentElement.HasValue || currentElement2 < currentElement)
							{
								currentElement = currentElement2;
							}
						}
					}
					else
					{
						long? currentElement3 = null;
						while (source.MoveNext(ref currentElement3, ref currentKey))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							if (!currentElement.HasValue || currentElement3 > currentElement)
							{
								currentElement = currentElement3;
							}
						}
					}
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly int _sign;

		internal NullableLongMinMaxAggregationOperator(IEnumerable<long?> child, int sign)
			: base(child)
		{
			_sign = sign;
		}

		protected override long? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<long?> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			if (!enumerator.MoveNext())
			{
				return null;
			}
			long? num = enumerator.Current;
			if (_sign == -1)
			{
				while (enumerator.MoveNext())
				{
					long? current = enumerator.Current;
					if (!num.HasValue || current < num)
					{
						num = current;
					}
				}
			}
			else
			{
				while (enumerator.MoveNext())
				{
					long? current2 = enumerator.Current;
					if (!num.HasValue || current2 > num)
					{
						num = current2;
					}
				}
			}
			return num;
		}

		protected override QueryOperatorEnumerator<long?, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<long?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableLongMinMaxAggregationOperatorEnumerator<TKey>(source, index, _sign, cancellationToken);
		}
	}
	internal sealed class NullableLongSumAggregationOperator : InlinedAggregationOperator<long?, long?, long?>
	{
		private class NullableLongSumAggregationOperatorEnumerator<TKey> : InlinedAggregationOperatorEnumerator<long?>
		{
			private readonly QueryOperatorEnumerator<long?, TKey> _source;

			internal NullableLongSumAggregationOperatorEnumerator(QueryOperatorEnumerator<long?, TKey> source, int partitionIndex, CancellationToken cancellationToken)
				: base(partitionIndex, cancellationToken)
			{
				_source = source;
			}

			protected override bool MoveNextCore(ref long? currentElement)
			{
				long? currentElement2 = null;
				TKey currentKey = default(TKey);
				QueryOperatorEnumerator<long?, TKey> source = _source;
				if (source.MoveNext(ref currentElement2, ref currentKey))
				{
					long num = 0L;
					int num2 = 0;
					do
					{
						if ((num2++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						num = checked(num + currentElement2.GetValueOrDefault());
					}
					while (source.MoveNext(ref currentElement2, ref currentKey));
					currentElement = num;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		internal NullableLongSumAggregationOperator(IEnumerable<long?> child)
			: base(child)
		{
		}

		protected override long? InternalAggregate(ref Exception singularExceptionToThrow)
		{
			using IEnumerator<long?> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true);
			long num = 0L;
			while (enumerator.MoveNext())
			{
				num = checked(num + enumerator.Current.GetValueOrDefault());
			}
			return num;
		}

		protected override QueryOperatorEnumerator<long?, int> CreateEnumerator<TKey>(int index, int count, QueryOperatorEnumerator<long?, TKey> source, object sharedData, CancellationToken cancellationToken)
		{
			return new NullableLongSumAggregationOperatorEnumerator<TKey>(source, index, cancellationToken);
		}
	}
	internal class ListQueryResults<T> : QueryResults<T>
	{
		private IList<T> _source;

		private int _partitionCount;

		private bool _useStriping;

		internal override bool IsIndexible => true;

		internal override int ElementsCount => _source.Count;

		internal ListQueryResults(IList<T> source, int partitionCount, bool useStriping)
		{
			_source = source;
			_partitionCount = partitionCount;
			_useStriping = useStriping;
		}

		internal override void GivePartitionedStream(IPartitionedStreamRecipient<T> recipient)
		{
			PartitionedStream<T, int> partitionedStream = GetPartitionedStream();
			recipient.Receive(partitionedStream);
		}

		internal override T GetElement(int index)
		{
			return _source[index];
		}

		internal PartitionedStream<T, int> GetPartitionedStream()
		{
			return ExchangeUtilities.PartitionDataSource(_source, _partitionCount, _useStriping);
		}
	}
	internal sealed class OrderingQueryOperator<TSource> : QueryOperator<TSource>
	{
		private QueryOperator<TSource> _child;

		private OrdinalIndexState _ordinalIndexState;

		internal override bool LimitsParallelism => _child.LimitsParallelism;

		internal override OrdinalIndexState OrdinalIndexState => _ordinalIndexState;

		public OrderingQueryOperator(QueryOperator<TSource> child, bool orderOn)
			: base(orderOn, child.SpecifiedQuerySettings)
		{
			_child = child;
			_ordinalIndexState = _child.OrdinalIndexState;
		}

		internal override QueryResults<TSource> Open(QuerySettings settings, bool preferStriping)
		{
			return _child.Open(settings, preferStriping);
		}

		internal override IEnumerator<TSource> GetEnumerator(ParallelMergeOptions? mergeOptions, bool suppressOrderPreservation)
		{
			if (_child is ScanQueryOperator<TSource> scanQueryOperator)
			{
				return scanQueryOperator.Data.GetEnumerator();
			}
			return base.GetEnumerator(mergeOptions, suppressOrderPreservation);
		}

		internal override IEnumerable<TSource> AsSequentialQuery(CancellationToken token)
		{
			return _child.AsSequentialQuery(token);
		}
	}
	internal class QueryExecutionOption<TSource> : QueryOperator<TSource>
	{
		private QueryOperator<TSource> _child;

		private OrdinalIndexState _indexState;

		internal override OrdinalIndexState OrdinalIndexState => _indexState;

		internal override bool LimitsParallelism => _child.LimitsParallelism;

		internal QueryExecutionOption(QueryOperator<TSource> source, QuerySettings settings)
			: base(source.OutputOrdered, settings.Merge(source.SpecifiedQuerySettings))
		{
			_child = source;
			_indexState = _child.OrdinalIndexState;
		}

		internal override QueryResults<TSource> Open(QuerySettings settings, bool preferStriping)
		{
			return _child.Open(settings, preferStriping);
		}

		internal override IEnumerable<TSource> AsSequentialQuery(CancellationToken token)
		{
			return _child.AsSequentialQuery(token);
		}
	}
	internal enum OrdinalIndexState : byte
	{
		Indexable,
		Correct,
		Increasing,
		Shuffled
	}
	internal class PartitionedStreamMerger<TOutput> : IPartitionedStreamRecipient<TOutput>
	{
		private bool _forEffectMerge;

		private ParallelMergeOptions _mergeOptions;

		private bool _isOrdered;

		private MergeExecutor<TOutput> _mergeExecutor;

		private TaskScheduler _taskScheduler;

		private int _queryId;

		private CancellationState _cancellationState;

		internal MergeExecutor<TOutput> MergeExecutor => _mergeExecutor;

		internal PartitionedStreamMerger(bool forEffectMerge, ParallelMergeOptions mergeOptions, TaskScheduler taskScheduler, bool outputOrdered, CancellationState cancellationState, int queryId)
		{
			_forEffectMerge = forEffectMerge;
			_mergeOptions = mergeOptions;
			_isOrdered = outputOrdered;
			_taskScheduler = taskScheduler;
			_cancellationState = cancellationState;
			_queryId = queryId;
		}

		public void Receive<TKey>(PartitionedStream<TOutput, TKey> partitionedStream)
		{
			_mergeExecutor = MergeExecutor<TOutput>.Execute(partitionedStream, _forEffectMerge, _mergeOptions, _taskScheduler, _isOrdered, _cancellationState, _queryId);
		}
	}
	internal class PartitionerQueryOperator<TElement> : QueryOperator<TElement>
	{
		private class PartitionerQueryOperatorResults : QueryResults<TElement>
		{
			private Partitioner<TElement> _partitioner;

			private QuerySettings _settings;

			internal PartitionerQueryOperatorResults(Partitioner<TElement> partitioner, QuerySettings settings)
			{
				_partitioner = partitioner;
				_settings = settings;
			}

			internal override void GivePartitionedStream(IPartitionedStreamRecipient<TElement> recipient)
			{
				int value = _settings.DegreeOfParallelism.Value;
				OrderablePartitioner<TElement> orderablePartitioner = _partitioner as OrderablePartitioner<TElement>;
				OrdinalIndexState indexState = ((orderablePartitioner != null) ? PartitionerQueryOperator<TElement>.GetOrdinalIndexState((Partitioner<TElement>)orderablePartitioner) : OrdinalIndexState.Shuffled);
				PartitionedStream<TElement, int> partitionedStream = new PartitionedStream<TElement, int>(value, Util.GetDefaultComparer<int>(), indexState);
				if (orderablePartitioner != null)
				{
					IList<IEnumerator<KeyValuePair<long, TElement>>> orderablePartitions = orderablePartitioner.GetOrderablePartitions(value);
					if (orderablePartitions == null)
					{
						throw new InvalidOperationException("Partitioner returned null instead of a list of partitions.");
					}
					if (orderablePartitions.Count != value)
					{
						throw new InvalidOperationException("Partitioner returned a wrong number of partitions.");
					}
					for (int i = 0; i < value; i++)
					{
						IEnumerator<KeyValuePair<long, TElement>> enumerator = orderablePartitions[i];
						if (enumerator == null)
						{
							throw new InvalidOperationException("Partitioner returned a null partition.");
						}
						partitionedStream[i] = new OrderablePartitionerEnumerator(enumerator);
					}
				}
				else
				{
					IList<IEnumerator<TElement>> partitions = _partitioner.GetPartitions(value);
					if (partitions == null)
					{
						throw new InvalidOperationException("Partitioner returned null instead of a list of partitions.");
					}
					if (partitions.Count != value)
					{
						throw new InvalidOperationException("Partitioner returned a wrong number of partitions.");
					}
					for (int j = 0; j < value; j++)
					{
						IEnumerator<TElement> enumerator2 = partitions[j];
						if (enumerator2 == null)
						{
							throw new InvalidOperationException("Partitioner returned a null partition.");
						}
						partitionedStream[j] = new PartitionerEnumerator(enumerator2);
					}
				}
				recipient.Receive(partitionedStream);
			}
		}

		private class OrderablePartitionerEnumerator : QueryOperatorEnumerator<TElement, int>
		{
			private IEnumerator<KeyValuePair<long, TElement>> _sourceEnumerator;

			internal OrderablePartitionerEnumerator(IEnumerator<KeyValuePair<long, TElement>> sourceEnumerator)
			{
				_sourceEnumerator = sourceEnumerator;
			}

			internal override bool MoveNext(ref TElement currentElement, ref int currentKey)
			{
				if (!_sourceEnumerator.MoveNext())
				{
					return false;
				}
				KeyValuePair<long, TElement> current = _sourceEnumerator.Current;
				currentElement = current.Value;
				currentKey = checked((int)current.Key);
				return true;
			}

			protected override void Dispose(bool disposing)
			{
				_sourceEnumerator.Dispose();
			}
		}

		private class PartitionerEnumerator : QueryOperatorEnumerator<TElement, int>
		{
			private IEnumerator<TElement> _sourceEnumerator;

			internal PartitionerEnumerator(IEnumerator<TElement> sourceEnumerator)
			{
				_sourceEnumerator = sourceEnumerator;
			}

			internal override bool MoveNext(ref TElement currentElement, ref int currentKey)
			{
				if (!_sourceEnumerator.MoveNext())
				{
					return false;
				}
				currentElement = _sourceEnumerator.Current;
				currentKey = 0;
				return true;
			}

			protected override void Dispose(bool disposing)
			{
				_sourceEnumerator.Dispose();
			}
		}

		private Partitioner<TElement> _partitioner;

		internal bool Orderable => _partitioner is OrderablePartitioner<TElement>;

		internal override OrdinalIndexState OrdinalIndexState => GetOrdinalIndexState(_partitioner);

		internal override bool LimitsParallelism => false;

		internal PartitionerQueryOperator(Partitioner<TElement> partitioner)
			: base(isOrdered: false, QuerySettings.Empty)
		{
			_partitioner = partitioner;
		}

		internal override QueryResults<TElement> Open(QuerySettings settings, bool preferStriping)
		{
			return new PartitionerQueryOperatorResults(_partitioner, settings);
		}

		internal override IEnumerable<TElement> AsSequentialQuery(CancellationToken token)
		{
			using IEnumerator<TElement> enumerator = _partitioner.GetPartitions(1)[0];
			while (enumerator.MoveNext())
			{
				yield return enumerator.Current;
			}
		}

		internal static OrdinalIndexState GetOrdinalIndexState(Partitioner<TElement> partitioner)
		{
			if (!(partitioner is OrderablePartitioner<TElement> orderablePartitioner))
			{
				return OrdinalIndexState.Shuffled;
			}
			if (orderablePartitioner.KeysOrderedInEachPartition)
			{
				if (orderablePartitioner.KeysNormalized)
				{
					return OrdinalIndexState.Correct;
				}
				return OrdinalIndexState.Increasing;
			}
			return OrdinalIndexState.Shuffled;
		}
	}
	internal class QueryOpeningEnumerator<TOutput> : IEnumerator<TOutput>, IDisposable, IEnumerator
	{
		private readonly QueryOperator<TOutput> _queryOperator;

		private IEnumerator<TOutput> _openedQueryEnumerator;

		private QuerySettings _querySettings;

		private readonly ParallelMergeOptions? _mergeOptions;

		private readonly bool _suppressOrderPreservation;

		private int _moveNextIteration;

		private bool _hasQueryOpeningFailed;

		private readonly Shared<bool> _topLevelDisposedFlag = new Shared<bool>(value: false);

		private readonly CancellationTokenSource _topLevelCancellationTokenSource = new CancellationTokenSource();

		public TOutput Current
		{
			get
			{
				if (_openedQueryEnumerator == null)
				{
					throw new InvalidOperationException("Enumeration has not started. MoveNext must be called to initiate enumeration.");
				}
				return _openedQueryEnumerator.Current;
			}
		}

		object IEnumerator.Current => ((IEnumerator<TOutput>)this).Current;

		internal QueryOpeningEnumerator(QueryOperator<TOutput> queryOperator, ParallelMergeOptions? mergeOptions, bool suppressOrderPreservation)
		{
			_queryOperator = queryOperator;
			_mergeOptions = mergeOptions;
			_suppressOrderPreservation = suppressOrderPreservation;
		}

		public void Dispose()
		{
			_topLevelDisposedFlag.Value = true;
			_topLevelCancellationTokenSource.Cancel();
			if (_openedQueryEnumerator != null)
			{
				_openedQueryEnumerator.Dispose();
				_querySettings.CleanStateAtQueryEnd();
			}
			QueryLifecycle.LogicalQueryExecutionEnd(_querySettings.QueryId);
		}

		public bool MoveNext()
		{
			if (_topLevelDisposedFlag.Value)
			{
				throw new ObjectDisposedException("enumerator", "The query enumerator has been disposed.");
			}
			if (_openedQueryEnumerator == null)
			{
				OpenQuery();
			}
			bool result = _openedQueryEnumerator.MoveNext();
			if ((_moveNextIteration & 0x3F) == 0)
			{
				CancellationState.ThrowWithStandardMessageIfCanceled(_querySettings.CancellationState.ExternalCancellationToken);
			}
			_moveNextIteration++;
			return result;
		}

		private void OpenQuery()
		{
			if (_hasQueryOpeningFailed)
			{
				throw new InvalidOperationException("The query enumerator previously threw an exception.");
			}
			try
			{
				_querySettings = _queryOperator.SpecifiedQuerySettings.WithPerExecutionSettings(_topLevelCancellationTokenSource, _topLevelDisposedFlag).WithDefaults();
				QueryLifecycle.LogicalQueryExecutionBegin(_querySettings.QueryId);
				_openedQueryEnumerator = _queryOperator.GetOpenedEnumerator(_mergeOptions, _suppressOrderPreservation, forEffect: false, _querySettings);
				CancellationState.ThrowWithStandardMessageIfCanceled(_querySettings.CancellationState.ExternalCancellationToken);
			}
			catch
			{
				_hasQueryOpeningFailed = true;
				throw;
			}
		}

		public void Reset()
		{
			throw new NotSupportedException();
		}
	}
	internal abstract class QueryOperator<TOutput> : ParallelQuery<TOutput>
	{
		protected bool _outputOrdered;

		internal bool OutputOrdered => _outputOrdered;

		internal abstract bool LimitsParallelism { get; }

		internal abstract OrdinalIndexState OrdinalIndexState { get; }

		internal QueryOperator(QuerySettings settings)
			: this(isOrdered: false, settings)
		{
		}

		internal QueryOperator(bool isOrdered, QuerySettings settings)
			: base(settings)
		{
			_outputOrdered = isOrdered;
		}

		internal abstract QueryResults<TOutput> Open(QuerySettings settings, bool preferStriping);

		public override IEnumerator<TOutput> GetEnumerator()
		{
			return GetEnumerator(null, suppressOrderPreservation: false);
		}

		public IEnumerator<TOutput> GetEnumerator(ParallelMergeOptions? mergeOptions)
		{
			return GetEnumerator(mergeOptions, suppressOrderPreservation: false);
		}

		internal virtual IEnumerator<TOutput> GetEnumerator(ParallelMergeOptions? mergeOptions, bool suppressOrderPreservation)
		{
			return new QueryOpeningEnumerator<TOutput>(this, mergeOptions, suppressOrderPreservation);
		}

		internal IEnumerator<TOutput> GetOpenedEnumerator(ParallelMergeOptions? mergeOptions, bool suppressOrder, bool forEffect, QuerySettings querySettings)
		{
			if (querySettings.ExecutionMode.Value == ParallelExecutionMode.Default && LimitsParallelism)
			{
				return ExceptionAggregator.WrapEnumerable(AsSequentialQuery(querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState).GetEnumerator();
			}
			QueryResults<TOutput> queryResults = GetQueryResults(querySettings);
			if (!mergeOptions.HasValue)
			{
				mergeOptions = querySettings.MergeOptions;
			}
			if (querySettings.CancellationState.MergedCancellationToken.IsCancellationRequested)
			{
				if (querySettings.CancellationState.ExternalCancellationToken.IsCancellationRequested)
				{
					throw new OperationCanceledException(querySettings.CancellationState.ExternalCancellationToken);
				}
				throw new OperationCanceledException();
			}
			PartitionedStreamMerger<TOutput> partitionedStreamMerger = new PartitionedStreamMerger<TOutput>(outputOrdered: OutputOrdered && !suppressOrder, forEffectMerge: forEffect, mergeOptions: mergeOptions.GetValueOrDefault(), taskScheduler: querySettings.TaskScheduler, cancellationState: querySettings.CancellationState, queryId: querySettings.QueryId);
			queryResults.GivePartitionedStream(partitionedStreamMerger);
			if (forEffect)
			{
				return null;
			}
			return partitionedStreamMerger.MergeExecutor.GetEnumerator();
		}

		private QueryResults<TOutput> GetQueryResults(QuerySettings querySettings)
		{
			return Open(querySettings, preferStriping: false);
		}

		internal TOutput[] ExecuteAndGetResultsAsArray()
		{
			QuerySettings querySettings = base.SpecifiedQuerySettings.WithPerExecutionSettings().WithDefaults();
			QueryLifecycle.LogicalQueryExecutionBegin(querySettings.QueryId);
			try
			{
				if (querySettings.ExecutionMode.Value == ParallelExecutionMode.Default && LimitsParallelism)
				{
					return ExceptionAggregator.WrapEnumerable(CancellableEnumerable.Wrap(AsSequentialQuery(querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState.ExternalCancellationToken), querySettings.CancellationState).ToArray();
				}
				QueryResults<TOutput> queryResults = GetQueryResults(querySettings);
				if (querySettings.CancellationState.MergedCancellationToken.IsCancellationRequested)
				{
					if (querySettings.CancellationState.ExternalCancellationToken.IsCancellationRequested)
					{
						throw new OperationCanceledException(querySettings.CancellationState.ExternalCancellationToken);
					}
					throw new OperationCanceledException();
				}
				if (queryResults.IsIndexible && OutputOrdered)
				{
					ArrayMergeHelper<TOutput> arrayMergeHelper = new ArrayMergeHelper<TOutput>(base.SpecifiedQuerySettings, queryResults);
					arrayMergeHelper.Execute();
					TOutput[] resultsAsArray = arrayMergeHelper.GetResultsAsArray();
					querySettings.CleanStateAtQueryEnd();
					return resultsAsArray;
				}
				PartitionedStreamMerger<TOutput> partitionedStreamMerger = new PartitionedStreamMerger<TOutput>(forEffectMerge: false, ParallelMergeOptions.FullyBuffered, querySettings.TaskScheduler, OutputOrdered, querySettings.CancellationState, querySettings.QueryId);
				queryResults.GivePartitionedStream(partitionedStreamMerger);
				TOutput[] resultsAsArray2 = partitionedStreamMerger.MergeExecutor.GetResultsAsArray();
				querySettings.CleanStateAtQueryEnd();
				return resultsAsArray2;
			}
			finally
			{
				QueryLifecycle.LogicalQueryExecutionEnd(querySettings.QueryId);
			}
		}

		internal abstract IEnumerable<TOutput> AsSequentialQuery(CancellationToken token);

		internal static ListQueryResults<TOutput> ExecuteAndCollectResults<TKey>(PartitionedStream<TOutput, TKey> openedChild, int partitionCount, bool outputOrdered, bool useStriping, QuerySettings settings)
		{
			TaskScheduler taskScheduler = settings.TaskScheduler;
			return new ListQueryResults<TOutput>(MergeExecutor<TOutput>.Execute(openedChild, ignoreOutput: false, ParallelMergeOptions.FullyBuffered, taskScheduler, outputOrdered, settings.CancellationState, settings.QueryId).GetResultsAsArray(), partitionCount, useStriping);
		}

		internal static QueryOperator<TOutput> AsQueryOperator(IEnumerable<TOutput> source)
		{
			QueryOperator<TOutput> queryOperator = source as QueryOperator<TOutput>;
			if (queryOperator == null)
			{
				queryOperator = ((!(source is OrderedParallelQuery<TOutput> orderedParallelQuery)) ? new ScanQueryOperator<TOutput>(source) : orderedParallelQuery.SortOperator);
			}
			return queryOperator;
		}
	}
	internal abstract class QueryOperatorEnumerator<TElement, TKey>
	{
		private class QueryOperatorClassicEnumerator : IEnumerator<TElement>, IDisposable, IEnumerator
		{
			private QueryOperatorEnumerator<TElement, TKey> _operatorEnumerator;

			private TElement _current;

			public TElement Current => _current;

			object IEnumerator.Current => _current;

			internal QueryOperatorClassicEnumerator(QueryOperatorEnumerator<TElement, TKey> operatorEnumerator)
			{
				_operatorEnumerator = operatorEnumerator;
			}

			public bool MoveNext()
			{
				TKey currentKey = default(TKey);
				return _operatorEnumerator.MoveNext(ref _current, ref currentKey);
			}

			public void Dispose()
			{
				_operatorEnumerator.Dispose();
				_operatorEnumerator = null;
			}

			public void Reset()
			{
				_operatorEnumerator.Reset();
			}
		}

		internal abstract bool MoveNext(ref TElement currentElement, ref TKey currentKey);

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		protected virtual void Dispose(bool disposing)
		{
		}

		internal virtual void Reset()
		{
		}

		internal IEnumerator<TElement> AsClassicEnumerator()
		{
			return new QueryOperatorClassicEnumerator(this);
		}
	}
	internal abstract class QueryResults<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
	{
		internal virtual bool IsIndexible => false;

		internal virtual int ElementsCount
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public T this[int index]
		{
			get
			{
				return GetElement(index);
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public int Count => ElementsCount;

		bool ICollection<T>.IsReadOnly => true;

		internal abstract void GivePartitionedStream(IPartitionedStreamRecipient<T> recipient);

		internal virtual T GetElement(int index)
		{
			throw new NotSupportedException();
		}

		int IList<T>.IndexOf(T item)
		{
			throw new NotSupportedException();
		}

		void IList<T>.Insert(int index, T item)
		{
			throw new NotSupportedException();
		}

		void IList<T>.RemoveAt(int index)
		{
			throw new NotSupportedException();
		}

		void ICollection<T>.Add(T item)
		{
			throw new NotSupportedException();
		}

		void ICollection<T>.Clear()
		{
			throw new NotSupportedException();
		}

		bool ICollection<T>.Contains(T item)
		{
			throw new NotSupportedException();
		}

		void ICollection<T>.CopyTo(T[] array, int arrayIndex)
		{
			throw new NotSupportedException();
		}

		bool ICollection<T>.Remove(T item)
		{
			throw new NotSupportedException();
		}

		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			for (int index = 0; index < Count; index++)
			{
				yield return this[index];
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<T>)this).GetEnumerator();
		}
	}
	internal struct QuerySettings
	{
		private TaskScheduler _taskScheduler;

		private int? _degreeOfParallelism;

		private CancellationState _cancellationState;

		private ParallelExecutionMode? _executionMode;

		private ParallelMergeOptions? _mergeOptions;

		private int _queryId;

		internal CancellationState CancellationState
		{
			get
			{
				return _cancellationState;
			}
			set
			{
				_cancellationState = value;
			}
		}

		internal TaskScheduler TaskScheduler
		{
			get
			{
				return _taskScheduler;
			}
			set
			{
				_taskScheduler = value;
			}
		}

		internal int? DegreeOfParallelism
		{
			get
			{
				return _degreeOfParallelism;
			}
			set
			{
				_degreeOfParallelism = value;
			}
		}

		internal ParallelExecutionMode? ExecutionMode
		{
			get
			{
				return _executionMode;
			}
			set
			{
				_executionMode = value;
			}
		}

		internal ParallelMergeOptions? MergeOptions
		{
			get
			{
				return _mergeOptions;
			}
			set
			{
				_mergeOptions = value;
			}
		}

		internal int QueryId => _queryId;

		internal static QuerySettings Empty => new QuerySettings(null, null, default(CancellationToken), null, null);

		internal QuerySettings(TaskScheduler taskScheduler, int? degreeOfParallelism, CancellationToken externalCancellationToken, ParallelExecutionMode? executionMode, ParallelMergeOptions? mergeOptions)
		{
			_taskScheduler = taskScheduler;
			_degreeOfParallelism = degreeOfParallelism;
			_cancellationState = new CancellationState(externalCancellationToken);
			_executionMode = executionMode;
			_mergeOptions = mergeOptions;
			_queryId = -1;
		}

		internal QuerySettings Merge(QuerySettings settings2)
		{
			if (TaskScheduler != null && settings2.TaskScheduler != null)
			{
				throw new InvalidOperationException("The WithTaskScheduler operator may be used at most once in a query.");
			}
			if (DegreeOfParallelism.HasValue && settings2.DegreeOfParallelism.HasValue)
			{
				throw new InvalidOperationException("The WithDegreeOfParallelism operator may be used at most once in a query.");
			}
			if (CancellationState.ExternalCancellationToken.CanBeCanceled && settings2.CancellationState.ExternalCancellationToken.CanBeCanceled)
			{
				throw new InvalidOperationException("The WithCancellation operator may by used at most once in a query.");
			}
			if (ExecutionMode.HasValue && settings2.ExecutionMode.HasValue)
			{
				throw new InvalidOperationException("The WithExecutionMode operator may be used at most once in a query.");
			}
			if (MergeOptions.HasValue && settings2.MergeOptions.HasValue)
			{
				throw new InvalidOperationException("The WithMergeOptions operator may be used at most once in a query.");
			}
			TaskScheduler taskScheduler = ((TaskScheduler == null) ? settings2.TaskScheduler : TaskScheduler);
			int? degreeOfParallelism = (DegreeOfParallelism.HasValue ? DegreeOfParallelism : settings2.DegreeOfParallelism);
			CancellationToken externalCancellationToken = (CancellationState.ExternalCancellationToken.CanBeCanceled ? CancellationState.ExternalCancellationToken : settings2.CancellationState.ExternalCancellationToken);
			ParallelExecutionMode? executionMode = (ExecutionMode.HasValue ? ExecutionMode : settings2.ExecutionMode);
			ParallelMergeOptions? mergeOptions = (MergeOptions.HasValue ? MergeOptions : settings2.MergeOptions);
			return new QuerySettings(taskScheduler, degreeOfParallelism, externalCancellationToken, executionMode, mergeOptions);
		}

		internal QuerySettings WithPerExecutionSettings()
		{
			return WithPerExecutionSettings(new CancellationTokenSource(), new Shared<bool>(value: false));
		}

		internal QuerySettings WithPerExecutionSettings(CancellationTokenSource topLevelCancellationTokenSource, Shared<bool> topLevelDisposedFlag)
		{
			QuerySettings result = new QuerySettings(TaskScheduler, DegreeOfParallelism, CancellationState.ExternalCancellationToken, ExecutionMode, MergeOptions);
			result.CancellationState.InternalCancellationTokenSource = topLevelCancellationTokenSource;
			result.CancellationState.MergedCancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(result.CancellationState.InternalCancellationTokenSource.Token, result.CancellationState.ExternalCancellationToken);
			result.CancellationState.TopLevelDisposedFlag = topLevelDisposedFlag;
			result._queryId = PlinqEtwProvider.NextQueryId();
			return result;
		}

		internal QuerySettings WithDefaults()
		{
			QuerySettings result = this;
			if (result.TaskScheduler == null)
			{
				result.TaskScheduler = TaskScheduler.Default;
			}
			if (!result.DegreeOfParallelism.HasValue)
			{
				result.DegreeOfParallelism = Scheduling.GetDefaultDegreeOfParallelism();
			}
			if (!result.ExecutionMode.HasValue)
			{
				result.ExecutionMode = ParallelExecutionMode.Default;
			}
			if (!result.MergeOptions.HasValue)
			{
				result.MergeOptions = ParallelMergeOptions.Default;
			}
			if (result.MergeOptions == ParallelMergeOptions.Default)
			{
				result.MergeOptions = ParallelMergeOptions.AutoBuffered;
			}
			return result;
		}

		public void CleanStateAtQueryEnd()
		{
			_cancellationState.MergedCancellationTokenSource.Dispose();
		}
	}
	internal sealed class ScanQueryOperator<TElement> : QueryOperator<TElement>
	{
		private class ScanEnumerableQueryOperatorResults : QueryResults<TElement>
		{
			private IEnumerable<TElement> _data;

			private QuerySettings _settings;

			internal ScanEnumerableQueryOperatorResults(IEnumerable<TElement> data, QuerySettings settings)
			{
				_data = data;
				_settings = settings;
			}

			internal override void GivePartitionedStream(IPartitionedStreamRecipient<TElement> recipient)
			{
				PartitionedStream<TElement, int> partitionedStream = ExchangeUtilities.PartitionDataSource(_data, _settings.DegreeOfParallelism.Value, useStriping: false);
				recipient.Receive(partitionedStream);
			}
		}

		private readonly IEnumerable<TElement> _data;

		public IEnumerable<TElement> Data => _data;

		internal override OrdinalIndexState OrdinalIndexState
		{
			get
			{
				if (!(_data is IList<TElement>))
				{
					return OrdinalIndexState.Correct;
				}
				return OrdinalIndexState.Indexable;
			}
		}

		internal override bool LimitsParallelism => false;

		internal ScanQueryOperator(IEnumerable<TElement> data)
			: base(isOrdered: false, QuerySettings.Empty)
		{
			if (data is ParallelEnumerableWrapper<TElement> parallelEnumerableWrapper)
			{
				data = parallelEnumerableWrapper.WrappedEnumerable;
			}
			_data = data;
		}

		internal override QueryResults<TElement> Open(QuerySettings settings, bool preferStriping)
		{
			if (_data is IList<TElement> source)
			{
				return new ListQueryResults<TElement>(source, settings.DegreeOfParallelism.GetValueOrDefault(), preferStriping);
			}
			return new ScanEnumerableQueryOperatorResults(_data, settings);
		}

		internal override IEnumerator<TElement> GetEnumerator(ParallelMergeOptions? mergeOptions, bool suppressOrderPreservation)
		{
			return _data.GetEnumerator();
		}

		internal override IEnumerable<TElement> AsSequentialQuery(CancellationToken token)
		{
			return _data;
		}
	}
	internal sealed class AnyAllSearchOperator<TInput> : UnaryQueryOperator<TInput, bool>
	{
		private class AnyAllSearchOperatorEnumerator<TKey> : QueryOperatorEnumerator<bool, int>
		{
			private readonly QueryOperatorEnumerator<TInput, TKey> _source;

			private readonly Func<TInput, bool> _predicate;

			private readonly bool _qualification;

			private readonly int _partitionIndex;

			private readonly Shared<bool> _resultFoundFlag;

			private readonly CancellationToken _cancellationToken;

			internal AnyAllSearchOperatorEnumerator(QueryOperatorEnumerator<TInput, TKey> source, bool qualification, Func<TInput, bool> predicate, int partitionIndex, Shared<bool> resultFoundFlag, CancellationToken cancellationToken)
			{
				_source = source;
				_qualification = qualification;
				_predicate = predicate;
				_partitionIndex = partitionIndex;
				_resultFoundFlag = resultFoundFlag;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref bool currentElement, ref int currentKey)
			{
				if (_resultFoundFlag.Value)
				{
					return false;
				}
				TInput currentElement2 = default(TInput);
				TKey currentKey2 = default(TKey);
				if (_source.MoveNext(ref currentElement2, ref currentKey2))
				{
					currentElement = !_qualification;
					currentKey = _partitionIndex;
					int num = 0;
					do
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						if (_resultFoundFlag.Value)
						{
							return false;
						}
						if (_predicate(currentElement2) == _qualification)
						{
							_resultFoundFlag.Value = true;
							currentElement = _qualification;
							break;
						}
					}
					while (_source.MoveNext(ref currentElement2, ref currentKey2));
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly Func<TInput, bool> _predicate;

		private readonly bool _qualification;

		internal override bool LimitsParallelism => false;

		internal AnyAllSearchOperator(IEnumerable<TInput> child, bool qualification, Func<TInput, bool> predicate)
			: base(child)
		{
			_qualification = qualification;
			_predicate = predicate;
		}

		internal bool Aggregate()
		{
			using (IEnumerator<bool> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true))
			{
				while (enumerator.MoveNext())
				{
					if (enumerator.Current == _qualification)
					{
						return _qualification;
					}
				}
			}
			return !_qualification;
		}

		internal override QueryResults<bool> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping), this, settings, preferStriping);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TInput, TKey> inputStream, IPartitionedStreamRecipient<bool> recipient, bool preferStriping, QuerySettings settings)
		{
			Shared<bool> resultFoundFlag = new Shared<bool>(value: false);
			int partitionCount = inputStream.PartitionCount;
			PartitionedStream<bool, int> partitionedStream = new PartitionedStream<bool, int>(partitionCount, Util.GetDefaultComparer<int>(), OrdinalIndexState.Correct);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream[i] = new AnyAllSearchOperatorEnumerator<TKey>(inputStream[i], _qualification, _predicate, i, resultFoundFlag, settings.CancellationState.MergedCancellationToken);
			}
			recipient.Receive(partitionedStream);
		}

		[ExcludeFromCodeCoverage]
		internal override IEnumerable<bool> AsSequentialQuery(CancellationToken token)
		{
			throw new NotSupportedException();
		}
	}
	internal sealed class ContainsSearchOperator<TInput> : UnaryQueryOperator<TInput, bool>
	{
		private class ContainsSearchOperatorEnumerator<TKey> : QueryOperatorEnumerator<bool, int>
		{
			private readonly QueryOperatorEnumerator<TInput, TKey> _source;

			private readonly TInput _searchValue;

			private readonly IEqualityComparer<TInput> _comparer;

			private readonly int _partitionIndex;

			private readonly Shared<bool> _resultFoundFlag;

			private CancellationToken _cancellationToken;

			internal ContainsSearchOperatorEnumerator(QueryOperatorEnumerator<TInput, TKey> source, TInput searchValue, IEqualityComparer<TInput> comparer, int partitionIndex, Shared<bool> resultFoundFlag, CancellationToken cancellationToken)
			{
				_source = source;
				_searchValue = searchValue;
				_comparer = comparer;
				_partitionIndex = partitionIndex;
				_resultFoundFlag = resultFoundFlag;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref bool currentElement, ref int currentKey)
			{
				if (_resultFoundFlag.Value)
				{
					return false;
				}
				TInput currentElement2 = default(TInput);
				TKey currentKey2 = default(TKey);
				if (_source.MoveNext(ref currentElement2, ref currentKey2))
				{
					currentElement = false;
					currentKey = _partitionIndex;
					int num = 0;
					do
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						if (_resultFoundFlag.Value)
						{
							return false;
						}
						if (_comparer.Equals(currentElement2, _searchValue))
						{
							_resultFoundFlag.Value = true;
							currentElement = true;
							break;
						}
					}
					while (_source.MoveNext(ref currentElement2, ref currentKey2));
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly TInput _searchValue;

		private readonly IEqualityComparer<TInput> _comparer;

		internal override bool LimitsParallelism => false;

		internal ContainsSearchOperator(IEnumerable<TInput> child, TInput searchValue, IEqualityComparer<TInput> comparer)
			: base(child)
		{
			_searchValue = searchValue;
			if (comparer == null)
			{
				_comparer = EqualityComparer<TInput>.Default;
			}
			else
			{
				_comparer = comparer;
			}
		}

		internal bool Aggregate()
		{
			using (IEnumerator<bool> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrderPreservation: true))
			{
				while (enumerator.MoveNext())
				{
					if (enumerator.Current)
					{
						return true;
					}
				}
			}
			return false;
		}

		internal override QueryResults<bool> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping), this, settings, preferStriping);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TInput, TKey> inputStream, IPartitionedStreamRecipient<bool> recipient, bool preferStriping, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			PartitionedStream<bool, int> partitionedStream = new PartitionedStream<bool, int>(partitionCount, Util.GetDefaultComparer<int>(), OrdinalIndexState.Correct);
			Shared<bool> resultFoundFlag = new Shared<bool>(value: false);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream[i] = new ContainsSearchOperatorEnumerator<TKey>(inputStream[i], _searchValue, _comparer, i, resultFoundFlag, settings.CancellationState.MergedCancellationToken);
			}
			recipient.Receive(partitionedStream);
		}

		[ExcludeFromCodeCoverage]
		internal override IEnumerable<bool> AsSequentialQuery(CancellationToken token)
		{
			throw new NotSupportedException();
		}
	}
	internal sealed class DefaultIfEmptyQueryOperator<TSource> : UnaryQueryOperator<TSource, TSource>
	{
		private class DefaultIfEmptyQueryOperatorEnumerator<TKey> : QueryOperatorEnumerator<TSource, TKey>
		{
			private QueryOperatorEnumerator<TSource, TKey> _source;

			private bool _lookedForEmpty;

			private int _partitionIndex;

			private int _partitionCount;

			private TSource _defaultValue;

			private Shared<int> _sharedEmptyCount;

			private CountdownEvent _sharedLatch;

			private CancellationToken _cancelToken;

			internal DefaultIfEmptyQueryOperatorEnumerator(QueryOperatorEnumerator<TSource, TKey> source, TSource defaultValue, int partitionIndex, int partitionCount, Shared<int> sharedEmptyCount, CountdownEvent sharedLatch, CancellationToken cancelToken)
			{
				_source = source;
				_defaultValue = defaultValue;
				_partitionIndex = partitionIndex;
				_partitionCount = partitionCount;
				_sharedEmptyCount = sharedEmptyCount;
				_sharedLatch = sharedLatch;
				_cancelToken = cancelToken;
			}

			internal override bool MoveNext(ref TSource currentElement, ref TKey currentKey)
			{
				bool flag = _source.MoveNext(ref currentElement, ref currentKey);
				if (!_lookedForEmpty)
				{
					_lookedForEmpty = true;
					if (!flag)
					{
						if (_partitionIndex == 0)
						{
							_sharedLatch.Wait(_cancelToken);
							_sharedLatch.Dispose();
							if (_sharedEmptyCount.Value == _partitionCount - 1)
							{
								currentElement = _defaultValue;
								currentKey = default(TKey);
								return true;
							}
							return false;
						}
						Interlocked.Increment(ref _sharedEmptyCount.Value);
					}
					if (_partitionIndex != 0)
					{
						_sharedLatch.Signal();
					}
				}
				return flag;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly TSource _defaultValue;

		internal override bool LimitsParallelism => false;

		internal DefaultIfEmptyQueryOperator(IEnumerable<TSource> child, TSource defaultValue)
			: base(child)
		{
			_defaultValue = defaultValue;
			SetOrdinalIndexState(base.Child.OrdinalIndexState.Worse(OrdinalIndexState.Correct));
		}

		internal override QueryResults<TSource> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping), this, settings, preferStriping);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TSource, TKey> inputStream, IPartitionedStreamRecipient<TSource> recipient, bool preferStriping, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			Shared<int> sharedEmptyCount = new Shared<int>(0);
			CountdownEvent sharedLatch = new CountdownEvent(partitionCount - 1);
			PartitionedStream<TSource, TKey> partitionedStream = new PartitionedStream<TSource, TKey>(partitionCount, inputStream.KeyComparer, OrdinalIndexState);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream[i] = new DefaultIfEmptyQueryOperatorEnumerator<TKey>(inputStream[i], _defaultValue, i, partitionCount, sharedEmptyCount, sharedLatch, settings.CancellationState.MergedCancellationToken);
			}
			recipient.Receive(partitionedStream);
		}

		internal override IEnumerable<TSource> AsSequentialQuery(CancellationToken token)
		{
			return base.Child.AsSequentialQuery(token).DefaultIfEmpty(_defaultValue);
		}
	}
	internal sealed class DistinctQueryOperator<TInputOutput> : UnaryQueryOperator<TInputOutput, TInputOutput>
	{
		private class DistinctQueryOperatorEnumerator<TKey> : QueryOperatorEnumerator<TInputOutput, int>
		{
			private QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TKey> _source;

			private Set<TInputOutput> _hashLookup;

			private CancellationToken _cancellationToken;

			private Shared<int> _outputLoopCount;

			internal DistinctQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TKey> source, IEqualityComparer<TInputOutput> comparer, CancellationToken cancellationToken)
			{
				_source = source;
				_hashLookup = new Set<TInputOutput>(comparer);
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TInputOutput currentElement, ref int currentKey)
			{
				TKey currentKey2 = default(TKey);
				Pair<TInputOutput, NoKeyMemoizationRequired> currentElement2 = default(Pair<TInputOutput, NoKeyMemoizationRequired>);
				if (_outputLoopCount == null)
				{
					_outputLoopCount = new Shared<int>(0);
				}
				while (_source.MoveNext(ref currentElement2, ref currentKey2))
				{
					if ((_outputLoopCount.Value++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					if (_hashLookup.Add(currentElement2.First))
					{
						currentElement = currentElement2.First;
						return true;
					}
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private class OrderedDistinctQueryOperatorEnumerator<TKey> : QueryOperatorEnumerator<TInputOutput, TKey>
		{
			private QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TKey> _source;

			private Dictionary<Wrapper<TInputOutput>, TKey> _hashLookup;

			private IComparer<TKey> _keyComparer;

			private IEnumerator<KeyValuePair<Wrapper<TInputOutput>, TKey>> _hashLookupEnumerator;

			private CancellationToken _cancellationToken;

			internal OrderedDistinctQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TInputOutput, NoKeyMemoizationRequired>, TKey> source, IEqualityComparer<TInputOutput> comparer, IComparer<TKey> keyComparer, CancellationToken cancellationToken)
			{
				_source = source;
				_keyComparer = keyComparer;
				_hashLookup = new Dictionary<Wrapper<TInputOutput>, TKey>(new WrapperEqualityComparer<TInputOutput>(comparer));
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TInputOutput currentElement, ref TKey currentKey)
			{
				if (_hashLookupEnumerator == null)
				{
					Pair<TInputOutput, NoKeyMemoizationRequired> currentElement2 = default(Pair<TInputOutput, NoKeyMemoizationRequired>);
					TKey currentKey2 = default(TKey);
					int num = 0;
					while (_source.MoveNext(ref currentElement2, ref currentKey2))
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						Wrapper<TInputOutput> key = new Wrapper<TInputOutput>(currentElement2.First);
						if (!_hashLookup.TryGetValue(key, out var value) || _keyComparer.Compare(currentKey2, value) < 0)
						{
							_hashLookup[key] = currentKey2;
						}
					}
					_hashLookupEnumerator = _hashLookup.GetEnumerator();
				}
				if (_hashLookupEnumerator.MoveNext())
				{
					KeyValuePair<Wrapper<TInputOutput>, TKey> current = _hashLookupEnumerator.Current;
					currentElement = current.Key.Value;
					currentKey = current.Value;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
				if (_hashLookupEnumerator != null)
				{
					_hashLookupEnumerator.Dispose();
				}
			}
		}

		private readonly IEqualityComparer<TInputOutput> _comparer;

		internal override bool LimitsParallelism => false;

		internal DistinctQueryOperator(IEnumerable<TInputOutput> source, IEqualityComparer<TInputOutput> comparer)
			: base(source)
		{
			_comparer = comparer;
			SetOrdinalIndexState(OrdinalIndexState.Shuffled);
		}

		internal override QueryResults<TInputOutput> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping: false), this, settings, preferStriping: false);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient<TInputOutput> recipient, bool preferStriping, QuerySettings settings)
		{
			if (base.OutputOrdered)
			{
				WrapPartitionedStreamHelper(ExchangeUtilities.HashRepartitionOrdered<TInputOutput, NoKeyMemoizationRequired, TKey>(inputStream, null, null, _comparer, settings.CancellationState.MergedCancellationToken), recipient, settings.CancellationState.MergedCancellationToken);
			}
			else
			{
				WrapPartitionedStreamHelper(ExchangeUtilities.HashRepartition<TInputOutput, NoKeyMemoizationRequired, TKey>(inputStream, null, null, _comparer, settings.CancellationState.MergedCancellationToken), recipient, settings.CancellationState.MergedCancellationToken);
			}
		}

		private void WrapPartitionedStreamHelper<TKey>(PartitionedStream<Pair<TInputOutput, NoKeyMemoizationRequired>, TKey> hashStream, IPartitionedStreamRecipient<TInputOutput> recipient, CancellationToken cancellationToken)
		{
			int partitionCount = hashStream.PartitionCount;
			PartitionedStream<TInputOutput, TKey> partitionedStream = new PartitionedStream<TInputOutput, TKey>(partitionCount, hashStream.KeyComparer, OrdinalIndexState.Shuffled);
			for (int i = 0; i < partitionCount; i++)
			{
				if (base.OutputOrdered)
				{
					partitionedStream[i] = new OrderedDistinctQueryOperatorEnumerator<TKey>(hashStream[i], _comparer, hashStream.KeyComparer, cancellationToken);
				}
				else
				{
					partitionedStream[i] = (QueryOperatorEnumerator<TInputOutput, TKey>)(object)new DistinctQueryOperatorEnumerator<TKey>(hashStream[i], _comparer, cancellationToken);
				}
			}
			recipient.Receive(partitionedStream);
		}

		internal override IEnumerable<TInputOutput> AsSequentialQuery(CancellationToken token)
		{
			return CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(token), token).Distinct(_comparer);
		}
	}
	internal sealed class ElementAtQueryOperator<TSource> : UnaryQueryOperator<TSource, TSource>
	{
		private class ElementAtQueryOperatorEnumerator : QueryOperatorEnumerator<TSource, int>
		{
			private QueryOperatorEnumerator<TSource, int> _source;

			private int _index;

			private Shared<bool> _resultFoundFlag;

			private CancellationToken _cancellationToken;

			internal ElementAtQueryOperatorEnumerator(QueryOperatorEnumerator<TSource, int> source, int index, Shared<bool> resultFoundFlag, CancellationToken cancellationToken)
			{
				_source = source;
				_index = index;
				_resultFoundFlag = resultFoundFlag;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TSource currentElement, ref int currentKey)
			{
				int num = 0;
				while (_source.MoveNext(ref currentElement, ref currentKey))
				{
					if ((num++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					if (_resultFoundFlag.Value)
					{
						break;
					}
					if (currentKey == _index)
					{
						_resultFoundFlag.Value = true;
						return true;
					}
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly int _index;

		private readonly bool _prematureMerge;

		private readonly bool _limitsParallelism;

		internal override bool LimitsParallelism => _limitsParallelism;

		internal ElementAtQueryOperator(IEnumerable<TSource> child, int index)
			: base(child)
		{
			_index = index;
			OrdinalIndexState ordinalIndexState = base.Child.OrdinalIndexState;
			if (ordinalIndexState.IsWorseThan(OrdinalIndexState.Correct))
			{
				_prematureMerge = true;
				_limitsParallelism = ordinalIndexState != OrdinalIndexState.Shuffled;
			}
		}

		internal override QueryResults<TSource> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping: false), this, settings, preferStriping);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TSource, TKey> inputStream, IPartitionedStreamRecipient<TSource> recipient, bool preferStriping, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			PartitionedStream<TSource, int> partitionedStream = ((!_prematureMerge) ? ((PartitionedStream<TSource, int>)(object)inputStream) : QueryOperator<TSource>.ExecuteAndCollectResults(inputStream, partitionCount, base.Child.OutputOrdered, preferStriping, settings).GetPartitionedStream());
			Shared<bool> resultFoundFlag = new Shared<bool>(value: false);
			PartitionedStream<TSource, int> partitionedStream2 = new PartitionedStream<TSource, int>(partitionCount, Util.GetDefaultComparer<int>(), OrdinalIndexState.Correct);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream2[i] = new ElementAtQueryOperatorEnumerator(partitionedStream[i], _index, resultFoundFlag, settings.CancellationState.MergedCancellationToken);
			}
			recipient.Receive(partitionedStream2);
		}

		[ExcludeFromCodeCoverage]
		internal override IEnumerable<TSource> AsSequentialQuery(CancellationToken token)
		{
			throw new NotSupportedException();
		}

		internal bool Aggregate(out TSource result, bool withDefaultValue)
		{
			if (LimitsParallelism && base.SpecifiedQuerySettings.WithDefaults().ExecutionMode.Value != ParallelExecutionMode.ForceParallelism)
			{
				CancellationState cancellationState = base.SpecifiedQuerySettings.CancellationState;
				if (withDefaultValue)
				{
					IEnumerable<TSource> source = CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(cancellationState.ExternalCancellationToken), cancellationState.ExternalCancellationToken);
					result = ExceptionAggregator.WrapEnumerable(source, cancellationState).ElementAtOrDefault(_index);
				}
				else
				{
					IEnumerable<TSource> source2 = CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(cancellationState.ExternalCancellationToken), cancellationState.ExternalCancellationToken);
					result = ExceptionAggregator.WrapEnumerable(source2, cancellationState).ElementAt(_index);
				}
				return true;
			}
			using (IEnumerator<TSource> enumerator = GetEnumerator(ParallelMergeOptions.FullyBuffered))
			{
				if (enumerator.MoveNext())
				{
					TSource current = enumerator.Current;
					result = current;
					return true;
				}
			}
			result = default(TSource);
			return false;
		}
	}
	internal sealed class FirstQueryOperator<TSource> : UnaryQueryOperator<TSource, TSource>
	{
		private class FirstQueryOperatorEnumerator<TKey> : QueryOperatorEnumerator<TSource, int>
		{
			private QueryOperatorEnumerator<TSource, TKey> _source;

			private Func<TSource, bool> _predicate;

			private bool _alreadySearched;

			private int _partitionId;

			private FirstQueryOperatorState<TKey> _operatorState;

			private CountdownEvent _sharedBarrier;

			private CancellationToken _cancellationToken;

			private IComparer<TKey> _keyComparer;

			internal FirstQueryOperatorEnumerator(QueryOperatorEnumerator<TSource, TKey> source, Func<TSource, bool> predicate, FirstQueryOperatorState<TKey> operatorState, CountdownEvent sharedBarrier, CancellationToken cancellationToken, IComparer<TKey> keyComparer, int partitionId)
			{
				_source = source;
				_predicate = predicate;
				_operatorState = operatorState;
				_sharedBarrier = sharedBarrier;
				_cancellationToken = cancellationToken;
				_keyComparer = keyComparer;
				_partitionId = partitionId;
			}

			internal override bool MoveNext(ref TSource currentElement, ref int currentKey)
			{
				if (_alreadySearched)
				{
					return false;
				}
				TSource val = default(TSource);
				TKey val2 = default(TKey);
				try
				{
					TSource currentElement2 = default(TSource);
					TKey currentKey2 = default(TKey);
					int num = 0;
					while (_source.MoveNext(ref currentElement2, ref currentKey2))
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						if (_predicate != null && !_predicate(currentElement2))
						{
							continue;
						}
						val = currentElement2;
						val2 = currentKey2;
						lock (_operatorState)
						{
							if (_operatorState._partitionId == -1 || _keyComparer.Compare(val2, _operatorState._key) < 0)
							{
								_operatorState._key = val2;
								_operatorState._partitionId = _partitionId;
							}
						}
						break;
					}
				}
				finally
				{
					_sharedBarrier.Signal();
				}
				_alreadySearched = true;
				if (_partitionId == _operatorState._partitionId)
				{
					_sharedBarrier.Wait(_cancellationToken);
					if (_partitionId == _operatorState._partitionId)
					{
						currentElement = val;
						currentKey = 0;
						return true;
					}
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private class FirstQueryOperatorState<TKey>
		{
			internal TKey _key;

			internal int _partitionId = -1;
		}

		private readonly Func<TSource, bool> _predicate;

		private readonly bool _prematureMergeNeeded;

		internal override bool LimitsParallelism => false;

		internal FirstQueryOperator(IEnumerable<TSource> child, Func<TSource, bool> predicate)
			: base(child)
		{
			_predicate = predicate;
			_prematureMergeNeeded = base.Child.OrdinalIndexState.IsWorseThan(OrdinalIndexState.Increasing);
		}

		internal override QueryResults<TSource> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping: false), this, settings, preferStriping);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TSource, TKey> inputStream, IPartitionedStreamRecipient<TSource> recipient, bool preferStriping, QuerySettings settings)
		{
			if (_prematureMergeNeeded)
			{
				ListQueryResults<TSource> listQueryResults = QueryOperator<TSource>.ExecuteAndCollectResults(inputStream, inputStream.PartitionCount, base.Child.OutputOrdered, preferStriping, settings);
				WrapHelper(listQueryResults.GetPartitionedStream(), recipient, settings);
			}
			else
			{
				WrapHelper(inputStream, recipient, settings);
			}
		}

		private void WrapHelper<TKey>(PartitionedStream<TSource, TKey> inputStream, IPartitionedStreamRecipient<TSource> recipient, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			FirstQueryOperatorState<TKey> operatorState = new FirstQueryOperatorState<TKey>();
			CountdownEvent sharedBarrier = new CountdownEvent(partitionCount);
			PartitionedStream<TSource, int> partitionedStream = new PartitionedStream<TSource, int>(partitionCount, Util.GetDefaultComparer<int>(), OrdinalIndexState.Shuffled);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream[i] = new FirstQueryOperatorEnumerator<TKey>(inputStream[i], _predicate, operatorState, sharedBarrier, settings.CancellationState.MergedCancellationToken, inputStream.KeyComparer, i);
			}
			recipient.Receive(partitionedStream);
		}

		[ExcludeFromCodeCoverage]
		internal override IEnumerable<TSource> AsSequentialQuery(CancellationToken token)
		{
			throw new NotSupportedException();
		}
	}
	internal sealed class ForAllOperator<TInput> : UnaryQueryOperator<TInput, TInput>
	{
		private class ForAllEnumerator<TKey> : QueryOperatorEnumerator<TInput, int>
		{
			private readonly QueryOperatorEnumerator<TInput, TKey> _source;

			private readonly Action<TInput> _elementAction;

			private CancellationToken _cancellationToken;

			internal ForAllEnumerator(QueryOperatorEnumerator<TInput, TKey> source, Action<TInput> elementAction, CancellationToken cancellationToken)
			{
				_source = source;
				_elementAction = elementAction;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TInput currentElement, ref int currentKey)
			{
				TInput currentElement2 = default(TInput);
				TKey currentKey2 = default(TKey);
				int num = 0;
				while (_source.MoveNext(ref currentElement2, ref currentKey2))
				{
					if ((num++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					_elementAction(currentElement2);
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly Action<TInput> _elementAction;

		internal override bool LimitsParallelism => false;

		internal ForAllOperator(IEnumerable<TInput> child, Action<TInput> elementAction)
			: base(child)
		{
			_elementAction = elementAction;
		}

		internal void RunSynchronously()
		{
			Shared<bool> topLevelDisposedFlag = new Shared<bool>(value: false);
			CancellationTokenSource topLevelCancellationTokenSource = new CancellationTokenSource();
			QuerySettings querySettings = base.SpecifiedQuerySettings.WithPerExecutionSettings(topLevelCancellationTokenSource, topLevelDisposedFlag).WithDefaults();
			QueryLifecycle.LogicalQueryExecutionBegin(querySettings.QueryId);
			GetOpenedEnumerator(ParallelMergeOptions.FullyBuffered, suppressOrder: true, forEffect: true, querySettings);
			querySettings.CleanStateAtQueryEnd();
			QueryLifecycle.LogicalQueryExecutionEnd(querySettings.QueryId);
		}

		internal override QueryResults<TInput> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping), this, settings, preferStriping);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TInput, TKey> inputStream, IPartitionedStreamRecipient<TInput> recipient, bool preferStriping, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			PartitionedStream<TInput, int> partitionedStream = new PartitionedStream<TInput, int>(partitionCount, Util.GetDefaultComparer<int>(), OrdinalIndexState.Correct);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream[i] = new ForAllEnumerator<TKey>(inputStream[i], _elementAction, settings.CancellationState.MergedCancellationToken);
			}
			recipient.Receive(partitionedStream);
		}

		[ExcludeFromCodeCoverage]
		internal override IEnumerable<TInput> AsSequentialQuery(CancellationToken token)
		{
			throw new InvalidOperationException();
		}
	}
	internal sealed class GroupByQueryOperator<TSource, TGroupKey, TElement> : UnaryQueryOperator<TSource, IGrouping<TGroupKey, TElement>>
	{
		private readonly Func<TSource, TGroupKey> _keySelector;

		private readonly Func<TSource, TElement> _elementSelector;

		private readonly IEqualityComparer<TGroupKey> _keyComparer;

		internal override bool LimitsParallelism => false;

		internal GroupByQueryOperator(IEnumerable<TSource> child, Func<TSource, TGroupKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TGroupKey> keyComparer)
			: base(child)
		{
			_keySelector = keySelector;
			_elementSelector = elementSelector;
			_keyComparer = keyComparer;
			SetOrdinalIndexState(OrdinalIndexState.Shuffled);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TSource, TKey> inputStream, IPartitionedStreamRecipient<IGrouping<TGroupKey, TElement>> recipient, bool preferStriping, QuerySettings settings)
		{
			if (base.Child.OutputOrdered)
			{
				WrapPartitionedStreamHelperOrdered(ExchangeUtilities.HashRepartitionOrdered(inputStream, _keySelector, _keyComparer, null, settings.CancellationState.MergedCancellationToken), recipient, settings.CancellationState.MergedCancellationToken);
			}
			else
			{
				WrapPartitionedStreamHelper<TKey, int>(ExchangeUtilities.HashRepartition(inputStream, _keySelector, _keyComparer, null, settings.CancellationState.MergedCancellationToken), recipient, settings.CancellationState.MergedCancellationToken);
			}
		}

		private void WrapPartitionedStreamHelper<TIgnoreKey, TKey>(PartitionedStream<Pair<TSource, TGroupKey>, TKey> hashStream, IPartitionedStreamRecipient<IGrouping<TGroupKey, TElement>> recipient, CancellationToken cancellationToken)
		{
			int partitionCount = hashStream.PartitionCount;
			PartitionedStream<IGrouping<TGroupKey, TElement>, TKey> partitionedStream = new PartitionedStream<IGrouping<TGroupKey, TElement>, TKey>(partitionCount, hashStream.KeyComparer, OrdinalIndexState.Shuffled);
			for (int i = 0; i < partitionCount; i++)
			{
				if (_elementSelector == null)
				{
					GroupByIdentityQueryOperatorEnumerator<TSource, TGroupKey, TKey> groupByIdentityQueryOperatorEnumerator = new GroupByIdentityQueryOperatorEnumerator<TSource, TGroupKey, TKey>(hashStream[i], _keyComparer, cancellationToken);
					partitionedStream[i] = (QueryOperatorEnumerator<IGrouping<TGroupKey, TElement>, TKey>)(object)groupByIdentityQueryOperatorEnumerator;
				}
				else
				{
					partitionedStream[i] = new GroupByElementSelectorQueryOperatorEnumerator<TSource, TGroupKey, TElement, TKey>(hashStream[i], _keyComparer, _elementSelector, cancellationToken);
				}
			}
			recipient.Receive(partitionedStream);
		}

		private void WrapPartitionedStreamHelperOrdered<TKey>(PartitionedStream<Pair<TSource, TGroupKey>, TKey> hashStream, IPartitionedStreamRecipient<IGrouping<TGroupKey, TElement>> recipient, CancellationToken cancellationToken)
		{
			int partitionCount = hashStream.PartitionCount;
			PartitionedStream<IGrouping<TGroupKey, TElement>, TKey> partitionedStream = new PartitionedStream<IGrouping<TGroupKey, TElement>, TKey>(partitionCount, hashStream.KeyComparer, OrdinalIndexState.Shuffled);
			IComparer<TKey> keyComparer = hashStream.KeyComparer;
			for (int i = 0; i < partitionCount; i++)
			{
				if (_elementSelector == null)
				{
					OrderedGroupByIdentityQueryOperatorEnumerator<TSource, TGroupKey, TKey> orderedGroupByIdentityQueryOperatorEnumerator = new OrderedGroupByIdentityQueryOperatorEnumerator<TSource, TGroupKey, TKey>(hashStream[i], _keySelector, _keyComparer, keyComparer, cancellationToken);
					partitionedStream[i] = (QueryOperatorEnumerator<IGrouping<TGroupKey, TElement>, TKey>)(object)orderedGroupByIdentityQueryOperatorEnumerator;
				}
				else
				{
					partitionedStream[i] = new OrderedGroupByElementSelectorQueryOperatorEnumerator<TSource, TGroupKey, TElement, TKey>(hashStream[i], _keySelector, _elementSelector, _keyComparer, keyComparer, cancellationToken);
				}
			}
			recipient.Receive(partitionedStream);
		}

		internal override QueryResults<IGrouping<TGroupKey, TElement>> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping: false), this, settings, preferStriping: false);
		}

		internal override IEnumerable<IGrouping<TGroupKey, TElement>> AsSequentialQuery(CancellationToken token)
		{
			IEnumerable<TSource> source = CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(token), token);
			if (_elementSelector == null)
			{
				return (IEnumerable<IGrouping<TGroupKey, TElement>>)source.GroupBy(_keySelector, _keyComparer);
			}
			return source.GroupBy(_keySelector, _elementSelector, _keyComparer);
		}
	}
	internal abstract class GroupByQueryOperatorEnumerator<TSource, TGroupKey, TElement, TOrderKey> : QueryOperatorEnumerator<IGrouping<TGroupKey, TElement>, TOrderKey>
	{
		private class Mutables
		{
			internal HashLookup<Wrapper<TGroupKey>, ListChunk<TElement>> _hashLookup;

			internal int _hashLookupIndex;
		}

		protected readonly QueryOperatorEnumerator<Pair<TSource, TGroupKey>, TOrderKey> _source;

		protected readonly IEqualityComparer<TGroupKey> _keyComparer;

		protected readonly CancellationToken _cancellationToken;

		private Mutables _mutables;

		protected GroupByQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer<TGroupKey> keyComparer, CancellationToken cancellationToken)
		{
			_source = source;
			_keyComparer = keyComparer;
			_cancellationToken = cancellationToken;
		}

		internal override bool MoveNext(ref IGrouping<TGroupKey, TElement> currentElement, ref TOrderKey currentKey)
		{
			Mutables mutables = _mutables;
			if (mutables == null)
			{
				mutables = (_mutables = new Mutables());
				mutables._hashLookup = BuildHashLookup();
				mutables._hashLookupIndex = -1;
			}
			if (++mutables._hashLookupIndex < mutables._hashLookup.Count)
			{
				currentElement = new GroupByGrouping<TGroupKey, TElement>(mutables._hashLookup[mutables._hashLookupIndex]);
				return true;
			}
			return false;
		}

		protected abstract HashLookup<Wrapper<TGroupKey>, ListChunk<TElement>> BuildHashLookup();

		protected override void Dispose(bool disposing)
		{
			_source.Dispose();
		}
	}
	internal sealed class GroupByIdentityQueryOperatorEnumerator<TSource, TGroupKey, TOrderKey> : GroupByQueryOperatorEnumerator<TSource, TGroupKey, TSource, TOrderKey>
	{
		internal GroupByIdentityQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer<TGroupKey> keyComparer, CancellationToken cancellationToken)
			: base(source, keyComparer, cancellationToken)
		{
		}

		protected override HashLookup<Wrapper<TGroupKey>, ListChunk<TSource>> BuildHashLookup()
		{
			HashLookup<Wrapper<TGroupKey>, ListChunk<TSource>> hashLookup = new HashLookup<Wrapper<TGroupKey>, ListChunk<TSource>>(new WrapperEqualityComparer<TGroupKey>(_keyComparer));
			Pair<TSource, TGroupKey> currentElement = default(Pair<TSource, TGroupKey>);
			TOrderKey currentKey = default(TOrderKey);
			int num = 0;
			while (_source.MoveNext(ref currentElement, ref currentKey))
			{
				if ((num++ & 0x3F) == 0)
				{
					CancellationState.ThrowIfCanceled(_cancellationToken);
				}
				Wrapper<TGroupKey> key = new Wrapper<TGroupKey>(currentElement.Second);
				ListChunk<TSource> value = null;
				if (!hashLookup.TryGetValue(key, ref value))
				{
					value = new ListChunk<TSource>(2);
					hashLookup.Add(key, value);
				}
				value.Add(currentElement.First);
			}
			return hashLookup;
		}
	}
	internal sealed class GroupByElementSelectorQueryOperatorEnumerator<TSource, TGroupKey, TElement, TOrderKey> : GroupByQueryOperatorEnumerator<TSource, TGroupKey, TElement, TOrderKey>
	{
		private readonly Func<TSource, TElement> _elementSelector;

		internal GroupByElementSelectorQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer<TGroupKey> keyComparer, Func<TSource, TElement> elementSelector, CancellationToken cancellationToken)
			: base(source, keyComparer, cancellationToken)
		{
			_elementSelector = elementSelector;
		}

		protected override HashLookup<Wrapper<TGroupKey>, ListChunk<TElement>> BuildHashLookup()
		{
			HashLookup<Wrapper<TGroupKey>, ListChunk<TElement>> hashLookup = new HashLookup<Wrapper<TGroupKey>, ListChunk<TElement>>(new WrapperEqualityComparer<TGroupKey>(_keyComparer));
			Pair<TSource, TGroupKey> currentElement = default(Pair<TSource, TGroupKey>);
			TOrderKey currentKey = default(TOrderKey);
			int num = 0;
			while (_source.MoveNext(ref currentElement, ref currentKey))
			{
				if ((num++ & 0x3F) == 0)
				{
					CancellationState.ThrowIfCanceled(_cancellationToken);
				}
				Wrapper<TGroupKey> key = new Wrapper<TGroupKey>(currentElement.Second);
				ListChunk<TElement> value = null;
				if (!hashLookup.TryGetValue(key, ref value))
				{
					value = new ListChunk<TElement>(2);
					hashLookup.Add(key, value);
				}
				value.Add(_elementSelector(currentElement.First));
			}
			return hashLookup;
		}
	}
	internal abstract class OrderedGroupByQueryOperatorEnumerator<TSource, TGroupKey, TElement, TOrderKey> : QueryOperatorEnumerator<IGrouping<TGroupKey, TElement>, TOrderKey>
	{
		private class Mutables
		{
			internal HashLookup<Wrapper<TGroupKey>, GroupKeyData> _hashLookup;

			internal int _hashLookupIndex;
		}

		protected class GroupKeyData
		{
			internal TOrderKey _orderKey;

			internal OrderedGroupByGrouping<TGroupKey, TOrderKey, TElement> _grouping;

			internal GroupKeyData(TOrderKey orderKey, TGroupKey hashKey, IComparer<TOrderKey> orderComparer)
			{
				_orderKey = orderKey;
				_grouping = new OrderedGroupByGrouping<TGroupKey, TOrderKey, TElement>(hashKey, orderComparer);
			}
		}

		protected readonly QueryOperatorEnumerator<Pair<TSource, TGroupKey>, TOrderKey> _source;

		private readonly Func<TSource, TGroupKey> _keySelector;

		protected readonly IEqualityComparer<TGroupKey> _keyComparer;

		protected readonly IComparer<TOrderKey> _orderComparer;

		protected readonly CancellationToken _cancellationToken;

		private Mutables _mutables;

		protected OrderedGroupByQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TSource, TGroupKey>, TOrderKey> source, Func<TSource, TGroupKey> keySelector, IEqualityComparer<TGroupKey> keyComparer, IComparer<TOrderKey> orderComparer, CancellationToken cancellationToken)
		{
			_source = source;
			_keySelector = keySelector;
			_keyComparer = keyComparer;
			_orderComparer = orderComparer;
			_cancellationToken = cancellationToken;
		}

		internal override bool MoveNext(ref IGrouping<TGroupKey, TElement> currentElement, ref TOrderKey currentKey)
		{
			Mutables mutables = _mutables;
			if (mutables == null)
			{
				mutables = (_mutables = new Mutables());
				mutables._hashLookup = BuildHashLookup();
				mutables._hashLookupIndex = -1;
			}
			if (++mutables._hashLookupIndex < mutables._hashLookup.Count)
			{
				GroupKeyData value = mutables._hashLookup[mutables._hashLookupIndex].Value;
				currentElement = value._grouping;
				currentKey = value._orderKey;
				return true;
			}
			return false;
		}

		protected abstract HashLookup<Wrapper<TGroupKey>, GroupKeyData> BuildHashLookup();

		protected override void Dispose(bool disposing)
		{
			_source.Dispose();
		}
	}
	internal sealed class OrderedGroupByIdentityQueryOperatorEnumerator<TSource, TGroupKey, TOrderKey> : OrderedGroupByQueryOperatorEnumerator<TSource, TGroupKey, TSource, TOrderKey>
	{
		internal OrderedGroupByIdentityQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TSource, TGroupKey>, TOrderKey> source, Func<TSource, TGroupKey> keySelector, IEqualityComparer<TGroupKey> keyComparer, IComparer<TOrderKey> orderComparer, CancellationToken cancellationToken)
			: base(source, keySelector, keyComparer, orderComparer, cancellationToken)
		{
		}

		protected override HashLookup<Wrapper<TGroupKey>, GroupKeyData> BuildHashLookup()
		{
			HashLookup<Wrapper<TGroupKey>, GroupKeyData> hashLookup = new HashLookup<Wrapper<TGroupKey>, GroupKeyData>(new WrapperEqualityComparer<TGroupKey>(_keyComparer));
			Pair<TSource, TGroupKey> currentElement = default(Pair<TSource, TGroupKey>);
			TOrderKey currentKey = default(TOrderKey);
			int num = 0;
			while (_source.MoveNext(ref currentElement, ref currentKey))
			{
				if ((num++ & 0x3F) == 0)
				{
					CancellationState.ThrowIfCanceled(_cancellationToken);
				}
				Wrapper<TGroupKey> key = new Wrapper<TGroupKey>(currentElement.Second);
				GroupKeyData value = null;
				if (hashLookup.TryGetValue(key, ref value))
				{
					if (_orderComparer.Compare(currentKey, value._orderKey) < 0)
					{
						value._orderKey = currentKey;
					}
				}
				else
				{
					value = new GroupKeyData(currentKey, key.Value, _orderComparer);
					hashLookup.Add(key, value);
				}
				value._grouping.Add(currentElement.First, currentKey);
			}
			for (int i = 0; i < hashLookup.Count; i++)
			{
				hashLookup[i].Value._grouping.DoneAdding();
			}
			return hashLookup;
		}
	}
	internal sealed class OrderedGroupByElementSelectorQueryOperatorEnumerator<TSource, TGroupKey, TElement, TOrderKey> : OrderedGroupByQueryOperatorEnumerator<TSource, TGroupKey, TElement, TOrderKey>
	{
		private readonly Func<TSource, TElement> _elementSelector;

		internal OrderedGroupByElementSelectorQueryOperatorEnumerator(QueryOperatorEnumerator<Pair<TSource, TGroupKey>, TOrderKey> source, Func<TSource, TGroupKey> keySelector, Func<TSource, TElement> elementSelector, IEqualityComparer<TGroupKey> keyComparer, IComparer<TOrderKey> orderComparer, CancellationToken cancellationToken)
			: base(source, keySelector, keyComparer, orderComparer, cancellationToken)
		{
			_elementSelector = elementSelector;
		}

		protected override HashLookup<Wrapper<TGroupKey>, GroupKeyData> BuildHashLookup()
		{
			HashLookup<Wrapper<TGroupKey>, GroupKeyData> hashLookup = new HashLookup<Wrapper<TGroupKey>, GroupKeyData>(new WrapperEqualityComparer<TGroupKey>(_keyComparer));
			Pair<TSource, TGroupKey> currentElement = default(Pair<TSource, TGroupKey>);
			TOrderKey currentKey = default(TOrderKey);
			int num = 0;
			while (_source.MoveNext(ref currentElement, ref currentKey))
			{
				if ((num++ & 0x3F) == 0)
				{
					CancellationState.ThrowIfCanceled(_cancellationToken);
				}
				Wrapper<TGroupKey> key = new Wrapper<TGroupKey>(currentElement.Second);
				GroupKeyData value = null;
				if (hashLookup.TryGetValue(key, ref value))
				{
					if (_orderComparer.Compare(currentKey, value._orderKey) < 0)
					{
						value._orderKey = currentKey;
					}
				}
				else
				{
					value = new GroupKeyData(currentKey, key.Value, _orderComparer);
					hashLookup.Add(key, value);
				}
				value._grouping.Add(_elementSelector(currentElement.First), currentKey);
			}
			for (int i = 0; i < hashLookup.Count; i++)
			{
				hashLookup[i].Value._grouping.DoneAdding();
			}
			return hashLookup;
		}
	}
	internal class GroupByGrouping<TGroupKey, TElement> : IGrouping<TGroupKey, TElement>, IEnumerable<TElement>, IEnumerable
	{
		private KeyValuePair<Wrapper<TGroupKey>, ListChunk<TElement>> _keyValues;

		TGroupKey IGrouping<TGroupKey, TElement>.Key => _keyValues.Key.Value;

		internal GroupByGrouping(KeyValuePair<Wrapper<TGroupKey>, ListChunk<TElement>> keyValues)
		{
			_keyValues = keyValues;
		}

		IEnumerator<TElement> IEnumerable<TElement>.GetEnumerator()
		{
			return _keyValues.Value.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<TElement>)this).GetEnumerator();
		}
	}
	internal class OrderedGroupByGrouping<TGroupKey, TOrderKey, TElement> : IGrouping<TGroupKey, TElement>, IEnumerable<TElement>, IEnumerable
	{
		private class KeyAndValuesComparer : IComparer<KeyValuePair<TOrderKey, TElement>>
		{
			private IComparer<TOrderKey> myComparer;

			public KeyAndValuesComparer(IComparer<TOrderKey> comparer)
			{
				myComparer = comparer;
			}

			public int Compare(KeyValuePair<TOrderKey, TElement> x, KeyValuePair<TOrderKey, TElement> y)
			{
				return myComparer.Compare(x.Key, y.Key);
			}
		}

		private TGroupKey _groupKey;

		private GrowingArray<TElement> _values;

		private GrowingArray<TOrderKey> _orderKeys;

		private IComparer<TOrderKey> _orderComparer;

		private KeyAndValuesComparer _wrappedComparer;

		TGroupKey IGrouping<TGroupKey, TElement>.Key => _groupKey;

		internal OrderedGroupByGrouping(TGroupKey groupKey, IComparer<TOrderKey> orderComparer)
		{
			_groupKey = groupKey;
			_values = new GrowingArray<TElement>();
			_orderKeys = new GrowingArray<TOrderKey>();
			_orderComparer = orderComparer;
			_wrappedComparer = new KeyAndValuesComparer(_orderComparer);
		}

		IEnumerator<TElement> IEnumerable<TElement>.GetEnumerator()
		{
			int valueCount = _values.Count;
			TElement[] valueArray = _values.InternalArray;
			for (int i = 0; i < valueCount; i++)
			{
				yield return valueArray[i];
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<TElement>)this).GetEnumerator();
		}

		internal void Add(TElement value, TOrderKey orderKey)
		{
			_values.Add(value);
			_orderKeys.Add(orderKey);
		}

		internal void DoneAdding()
		{
			List<KeyValuePair<TOrderKey, TElement>> list = new List<KeyValuePair<TOrderKey, TElement>>();
			for (int i = 0; i < _orderKeys.InternalArray.Length; i++)
			{
				list.Add(new KeyValuePair<TOrderKey, TElement>(_orderKeys.InternalArray[i], _values.InternalArray[i]));
			}
			list.Sort(0, _values.Count, _wrappedComparer);
			for (int j = 0; j < _values.InternalArray.Length; j++)
			{
				_orderKeys.InternalArray[j] = list[j].Key;
				_values.InternalArray[j] = list[j].Value;
			}
		}
	}
	internal sealed class IndexedSelectQueryOperator<TInput, TOutput> : UnaryQueryOperator<TInput, TOutput>
	{
		private class IndexedSelectQueryOperatorEnumerator : QueryOperatorEnumerator<TOutput, int>
		{
			private readonly QueryOperatorEnumerator<TInput, int> _source;

			private readonly Func<TInput, int, TOutput> _selector;

			internal IndexedSelectQueryOperatorEnumerator(QueryOperatorEnumerator<TInput, int> source, Func<TInput, int, TOutput> selector)
			{
				_source = source;
				_selector = selector;
			}

			internal override bool MoveNext(ref TOutput currentElement, ref int currentKey)
			{
				TInput currentElement2 = default(TInput);
				if (_source.MoveNext(ref currentElement2, ref currentKey))
				{
					currentElement = _selector(currentElement2, currentKey);
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private class IndexedSelectQueryOperatorResults : UnaryQueryOperatorResults
		{
			private IndexedSelectQueryOperator<TInput, TOutput> _selectOp;

			private int _childCount;

			internal override int ElementsCount => _childQueryResults.ElementsCount;

			internal override bool IsIndexible => true;

			public static QueryResults<TOutput> NewResults(QueryResults<TInput> childQueryResults, IndexedSelectQueryOperator<TInput, TOutput> op, QuerySettings settings, bool preferStriping)
			{
				if (childQueryResults.IsIndexible)
				{
					return new IndexedSelectQueryOperatorResults(childQueryResults, op, settings, preferStriping);
				}
				return new UnaryQueryOperatorResults(childQueryResults, op, settings, preferStriping);
			}

			private IndexedSelectQueryOperatorResults(QueryResults<TInput> childQueryResults, IndexedSelectQueryOperator<TInput, TOutput> op, QuerySettings settings, bool preferStriping)
				: base(childQueryResults, (UnaryQueryOperator<TInput, TOutput>)op, settings, preferStriping)
			{
				_selectOp = op;
				_childCount = _childQueryResults.ElementsCount;
			}

			internal override TOutput GetElement(int index)
			{
				return _selectOp._selector(_childQueryResults.GetElement(index), index);
			}
		}

		private readonly Func<TInput, int, TOutput> _selector;

		private bool _prematureMerge;

		private bool _limitsParallelism;

		internal override bool LimitsParallelism => _limitsParallelism;

		internal IndexedSelectQueryOperator(IEnumerable<TInput> child, Func<TInput, int, TOutput> selector)
			: base(child)
		{
			_selector = selector;
			_outputOrdered = true;
			InitOrdinalIndexState();
		}

		private void InitOrdinalIndexState()
		{
			OrdinalIndexState ordinalIndexState = base.Child.OrdinalIndexState;
			OrdinalIndexState ordinalIndexState2 = ordinalIndexState;
			if (ordinalIndexState.IsWorseThan(OrdinalIndexState.Correct))
			{
				_prematureMerge = true;
				_limitsParallelism = ordinalIndexState != OrdinalIndexState.Shuffled;
				ordinalIndexState2 = OrdinalIndexState.Correct;
			}
			SetOrdinalIndexState(ordinalIndexState2);
		}

		internal override QueryResults<TOutput> Open(QuerySettings settings, bool preferStriping)
		{
			return IndexedSelectQueryOperatorResults.NewResults(base.Child.Open(settings, preferStriping), this, settings, preferStriping);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TInput, TKey> inputStream, IPartitionedStreamRecipient<TOutput> recipient, bool preferStriping, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			PartitionedStream<TInput, int> partitionedStream = ((!_prematureMerge) ? ((PartitionedStream<TInput, int>)(object)inputStream) : QueryOperator<TInput>.ExecuteAndCollectResults(inputStream, partitionCount, base.Child.OutputOrdered, preferStriping, settings).GetPartitionedStream());
			PartitionedStream<TOutput, int> partitionedStream2 = new PartitionedStream<TOutput, int>(partitionCount, Util.GetDefaultComparer<int>(), OrdinalIndexState);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream2[i] = new IndexedSelectQueryOperatorEnumerator(partitionedStream[i], _selector);
			}
			recipient.Receive(partitionedStream2);
		}

		internal override IEnumerable<TOutput> AsSequentialQuery(CancellationToken token)
		{
			return base.Child.AsSequentialQuery(token).Select(_selector);
		}
	}
	internal sealed class IndexedWhereQueryOperator<TInputOutput> : UnaryQueryOperator<TInputOutput, TInputOutput>
	{
		private class IndexedWhereQueryOperatorEnumerator : QueryOperatorEnumerator<TInputOutput, int>
		{
			private readonly QueryOperatorEnumerator<TInputOutput, int> _source;

			private readonly Func<TInputOutput, int, bool> _predicate;

			private CancellationToken _cancellationToken;

			private Shared<int> _outputLoopCount;

			internal IndexedWhereQueryOperatorEnumerator(QueryOperatorEnumerator<TInputOutput, int> source, Func<TInputOutput, int, bool> predicate, CancellationToken cancellationToken)
			{
				_source = source;
				_predicate = predicate;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TInputOutput currentElement, ref int currentKey)
			{
				if (_outputLoopCount == null)
				{
					_outputLoopCount = new Shared<int>(0);
				}
				while (_source.MoveNext(ref currentElement, ref currentKey))
				{
					if ((_outputLoopCount.Value++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					if (_predicate(currentElement, currentKey))
					{
						return true;
					}
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private Func<TInputOutput, int, bool> _predicate;

		private bool _prematureMerge;

		private bool _limitsParallelism;

		internal override bool LimitsParallelism => _limitsParallelism;

		internal IndexedWhereQueryOperator(IEnumerable<TInputOutput> child, Func<TInputOutput, int, bool> predicate)
			: base(child)
		{
			_predicate = predicate;
			_outputOrdered = true;
			InitOrdinalIndexState();
		}

		private void InitOrdinalIndexState()
		{
			OrdinalIndexState ordinalIndexState = base.Child.OrdinalIndexState;
			if (ordinalIndexState.IsWorseThan(OrdinalIndexState.Correct))
			{
				_prematureMerge = true;
				_limitsParallelism = ordinalIndexState != OrdinalIndexState.Shuffled;
			}
			SetOrdinalIndexState(OrdinalIndexState.Increasing);
		}

		internal override QueryResults<TInputOutput> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping), this, settings, preferStriping);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient<TInputOutput> recipient, bool preferStriping, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			PartitionedStream<TInputOutput, int> partitionedStream = ((!_prematureMerge) ? ((PartitionedStream<TInputOutput, int>)(object)inputStream) : QueryOperator<TInputOutput>.ExecuteAndCollectResults(inputStream, partitionCount, base.Child.OutputOrdered, preferStriping, settings).GetPartitionedStream());
			PartitionedStream<TInputOutput, int> partitionedStream2 = new PartitionedStream<TInputOutput, int>(partitionCount, Util.GetDefaultComparer<int>(), OrdinalIndexState);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream2[i] = new IndexedWhereQueryOperatorEnumerator(partitionedStream[i], _predicate, settings.CancellationState.MergedCancellationToken);
			}
			recipient.Receive(partitionedStream2);
		}

		internal override IEnumerable<TInputOutput> AsSequentialQuery(CancellationToken token)
		{
			return CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(token), token).Where(_predicate);
		}
	}
	internal sealed class LastQueryOperator<TSource> : UnaryQueryOperator<TSource, TSource>
	{
		private class LastQueryOperatorEnumerator<TKey> : QueryOperatorEnumerator<TSource, int>
		{
			private QueryOperatorEnumerator<TSource, TKey> _source;

			private Func<TSource, bool> _predicate;

			private bool _alreadySearched;

			private int _partitionId;

			private LastQueryOperatorState<TKey> _operatorState;

			private CountdownEvent _sharedBarrier;

			private CancellationToken _cancellationToken;

			private IComparer<TKey> _keyComparer;

			internal LastQueryOperatorEnumerator(QueryOperatorEnumerator<TSource, TKey> source, Func<TSource, bool> predicate, LastQueryOperatorState<TKey> operatorState, CountdownEvent sharedBarrier, CancellationToken cancelToken, IComparer<TKey> keyComparer, int partitionId)
			{
				_source = source;
				_predicate = predicate;
				_operatorState = operatorState;
				_sharedBarrier = sharedBarrier;
				_cancellationToken = cancelToken;
				_keyComparer = keyComparer;
				_partitionId = partitionId;
			}

			internal override bool MoveNext(ref TSource currentElement, ref int currentKey)
			{
				if (_alreadySearched)
				{
					return false;
				}
				TSource val = default(TSource);
				TKey val2 = default(TKey);
				bool flag = false;
				try
				{
					int num = 0;
					TSource currentElement2 = default(TSource);
					TKey currentKey2 = default(TKey);
					while (_source.MoveNext(ref currentElement2, ref currentKey2))
					{
						if ((num & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						if (_predicate == null || _predicate(currentElement2))
						{
							val = currentElement2;
							val2 = currentKey2;
							flag = true;
						}
						num++;
					}
					if (flag)
					{
						lock (_operatorState)
						{
							if (_operatorState._partitionId == -1 || _keyComparer.Compare(val2, _operatorState._key) > 0)
							{
								_operatorState._partitionId = _partitionId;
								_operatorState._key = val2;
							}
						}
					}
				}
				finally
				{
					_sharedBarrier.Signal();
				}
				_alreadySearched = true;
				if (_partitionId == _operatorState._partitionId)
				{
					_sharedBarrier.Wait(_cancellationToken);
					if (_operatorState._partitionId == _partitionId)
					{
						currentElement = val;
						currentKey = 0;
						return true;
					}
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private class LastQueryOperatorState<TKey>
		{
			internal TKey _key;

			internal int _partitionId = -1;
		}

		private readonly Func<TSource, bool> _predicate;

		private readonly bool _prematureMergeNeeded;

		internal override bool LimitsParallelism => false;

		internal LastQueryOperator(IEnumerable<TSource> child, Func<TSource, bool> predicate)
			: base(child)
		{
			_predicate = predicate;
			_prematureMergeNeeded = base.Child.OrdinalIndexState.IsWorseThan(OrdinalIndexState.Increasing);
		}

		internal override QueryResults<TSource> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping: false), this, settings, preferStriping);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TSource, TKey> inputStream, IPartitionedStreamRecipient<TSource> recipient, bool preferStriping, QuerySettings settings)
		{
			if (_prematureMergeNeeded)
			{
				PartitionedStream<TSource, int> partitionedStream = QueryOperator<TSource>.ExecuteAndCollectResults(inputStream, inputStream.PartitionCount, base.Child.OutputOrdered, preferStriping, settings).GetPartitionedStream();
				WrapHelper(partitionedStream, recipient, settings);
			}
			else
			{
				WrapHelper(inputStream, recipient, settings);
			}
		}

		private void WrapHelper<TKey>(PartitionedStream<TSource, TKey> inputStream, IPartitionedStreamRecipient<TSource> recipient, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			LastQueryOperatorState<TKey> operatorState = new LastQueryOperatorState<TKey>();
			CountdownEvent sharedBarrier = new CountdownEvent(partitionCount);
			PartitionedStream<TSource, int> partitionedStream = new PartitionedStream<TSource, int>(partitionCount, Util.GetDefaultComparer<int>(), OrdinalIndexState.Shuffled);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream[i] = new LastQueryOperatorEnumerator<TKey>(inputStream[i], _predicate, operatorState, sharedBarrier, settings.CancellationState.MergedCancellationToken, inputStream.KeyComparer, i);
			}
			recipient.Receive(partitionedStream);
		}

		[ExcludeFromCodeCoverage]
		internal override IEnumerable<TSource> AsSequentialQuery(CancellationToken token)
		{
			throw new NotSupportedException();
		}
	}
	internal sealed class ReverseQueryOperator<TSource> : UnaryQueryOperator<TSource, TSource>
	{
		private class ReverseQueryOperatorEnumerator<TKey> : QueryOperatorEnumerator<TSource, TKey>
		{
			private readonly QueryOperatorEnumerator<TSource, TKey> _source;

			private readonly CancellationToken _cancellationToken;

			private List<Pair<TSource, TKey>> _buffer;

			private Shared<int> _bufferIndex;

			internal ReverseQueryOperatorEnumerator(QueryOperatorEnumerator<TSource, TKey> source, CancellationToken cancellationToken)
			{
				_source = source;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TSource currentElement, ref TKey currentKey)
			{
				if (_buffer == null)
				{
					_bufferIndex = new Shared<int>(0);
					_buffer = new List<Pair<TSource, TKey>>();
					TSource currentElement2 = default(TSource);
					TKey currentKey2 = default(TKey);
					int num = 0;
					while (_source.MoveNext(ref currentElement2, ref currentKey2))
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						_buffer.Add(new Pair<TSource, TKey>(currentElement2, currentKey2));
						_bufferIndex.Value++;
					}
				}
				if (--_bufferIndex.Value >= 0)
				{
					currentElement = _buffer[_bufferIndex.Value].First;
					currentKey = _buffer[_bufferIndex.Value].Second;
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private class ReverseQueryOperatorResults : UnaryQueryOperatorResults
		{
			private int _count;

			internal override bool IsIndexible => true;

			internal override int ElementsCount => _count;

			public static QueryResults<TSource> NewResults(QueryResults<TSource> childQueryResults, ReverseQueryOperator<TSource> op, QuerySettings settings, bool preferStriping)
			{
				if (childQueryResults.IsIndexible)
				{
					return new ReverseQueryOperatorResults(childQueryResults, op, settings, preferStriping);
				}
				return new UnaryQueryOperatorResults(childQueryResults, op, settings, preferStriping);
			}

			private ReverseQueryOperatorResults(QueryResults<TSource> childQueryResults, ReverseQueryOperator<TSource> op, QuerySettings settings, bool preferStriping)
				: base(childQueryResults, (UnaryQueryOperator<TSource, TSource>)op, settings, preferStriping)
			{
				_count = _childQueryResults.ElementsCount;
			}

			internal override TSource GetElement(int index)
			{
				return _childQueryResults.GetElement(_count - index - 1);
			}
		}

		internal override bool LimitsParallelism => false;

		internal ReverseQueryOperator(IEnumerable<TSource> child)
			: base(child)
		{
			if (base.Child.OrdinalIndexState == OrdinalIndexState.Indexable)
			{
				SetOrdinalIndexState(OrdinalIndexState.Indexable);
			}
			else
			{
				SetOrdinalIndexState(OrdinalIndexState.Shuffled);
			}
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TSource, TKey> inputStream, IPartitionedStreamRecipient<TSource> recipient, bool preferStriping, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			PartitionedStream<TSource, TKey> partitionedStream = new PartitionedStream<TSource, TKey>(partitionCount, new ReverseComparer<TKey>(inputStream.KeyComparer), OrdinalIndexState.Shuffled);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream[i] = new ReverseQueryOperatorEnumerator<TKey>(inputStream[i], settings.CancellationState.MergedCancellationToken);
			}
			recipient.Receive(partitionedStream);
		}

		internal override QueryResults<TSource> Open(QuerySettings settings, bool preferStriping)
		{
			return ReverseQueryOperatorResults.NewResults(base.Child.Open(settings, preferStriping: false), this, settings, preferStriping);
		}

		internal override IEnumerable<TSource> AsSequentialQuery(CancellationToken token)
		{
			return CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(token), token).Reverse();
		}
	}
	internal sealed class SelectManyQueryOperator<TLeftInput, TRightInput, TOutput> : UnaryQueryOperator<TLeftInput, TOutput>
	{
		private class IndexedSelectManyQueryOperatorEnumerator : QueryOperatorEnumerator<TOutput, Pair<int, int>>
		{
			private class Mutables
			{
				internal int _currentRightSourceIndex = -1;

				internal TLeftInput _currentLeftElement;

				internal int _currentLeftSourceIndex;

				internal int _lhsCount;
			}

			private readonly QueryOperatorEnumerator<TLeftInput, int> _leftSource;

			private readonly SelectManyQueryOperator<TLeftInput, TRightInput, TOutput> _selectManyOperator;

			private IEnumerator<TRightInput> _currentRightSource;

			private IEnumerator<TOutput> _currentRightSourceAsOutput;

			private Mutables _mutables;

			private readonly CancellationToken _cancellationToken;

			internal IndexedSelectManyQueryOperatorEnumerator(QueryOperatorEnumerator<TLeftInput, int> leftSource, SelectManyQueryOperator<TLeftInput, TRightInput, TOutput> selectManyOperator, CancellationToken cancellationToken)
			{
				_leftSource = leftSource;
				_selectManyOperator = selectManyOperator;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TOutput currentElement, ref Pair<int, int> currentKey)
			{
				while (true)
				{
					if (_currentRightSource == null)
					{
						_mutables = new Mutables();
						if ((_mutables._lhsCount++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						if (!_leftSource.MoveNext(ref _mutables._currentLeftElement, ref _mutables._currentLeftSourceIndex))
						{
							return false;
						}
						IEnumerable<TRightInput> enumerable = _selectManyOperator._indexedRightChildSelector(_mutables._currentLeftElement, _mutables._currentLeftSourceIndex);
						_currentRightSource = enumerable.GetEnumerator();
						if (_selectManyOperator._resultSelector == null)
						{
							_currentRightSourceAsOutput = (IEnumerator<TOutput>)_currentRightSource;
						}
					}
					if (_currentRightSource.MoveNext())
					{
						break;
					}
					_currentRightSource.Dispose();
					_currentRightSource = null;
					_currentRightSourceAsOutput = null;
				}
				_mutables._currentRightSourceIndex++;
				if (_selectManyOperator._resultSelector != null)
				{
					currentElement = _selectManyOperator._resultSelector(_mutables._currentLeftElement, _currentRightSource.Current);
				}
				else
				{
					currentElement = _currentRightSourceAsOutput.Current;
				}
				currentKey = new Pair<int, int>(_mutables._currentLeftSourceIndex, _mutables._currentRightSourceIndex);
				return true;
			}

			protected override void Dispose(bool disposing)
			{
				_leftSource.Dispose();
				if (_currentRightSource != null)
				{
					_currentRightSource.Dispose();
				}
			}
		}

		private class SelectManyQueryOperatorEnumerator<TLeftKey> : QueryOperatorEnumerator<TOutput, Pair<TLeftKey, int>>
		{
			private class Mutables
			{
				internal int _currentRightSourceIndex = -1;

				internal TLeftInput _currentLeftElement;

				internal TLeftKey _currentLeftKey;

				internal int _lhsCount;
			}

			private readonly QueryOperatorEnumerator<TLeftInput, TLeftKey> _leftSource;

			private readonly SelectManyQueryOperator<TLeftInput, TRightInput, TOutput> _selectManyOperator;

			private IEnumerator<TRightInput> _currentRightSource;

			private IEnumerator<TOutput> _currentRightSourceAsOutput;

			private Mutables _mutables;

			private readonly CancellationToken _cancellationToken;

			internal SelectManyQueryOperatorEnumerator(QueryOperatorEnumerator<TLeftInput, TLeftKey> leftSource, SelectManyQueryOperator<TLeftInput, TRightInput, TOutput> selectManyOperator, CancellationToken cancellationToken)
			{
				_leftSource = leftSource;
				_selectManyOperator = selectManyOperator;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TOutput currentElement, ref Pair<TLeftKey, int> currentKey)
			{
				while (true)
				{
					if (_currentRightSource == null)
					{
						_mutables = new Mutables();
						if ((_mutables._lhsCount++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						if (!_leftSource.MoveNext(ref _mutables._currentLeftElement, ref _mutables._currentLeftKey))
						{
							return false;
						}
						IEnumerable<TRightInput> enumerable = _selectManyOperator._rightChildSelector(_mutables._currentLeftElement);
						_currentRightSource = enumerable.GetEnumerator();
						if (_selectManyOperator._resultSelector == null)
						{
							_currentRightSourceAsOutput = (IEnumerator<TOutput>)_currentRightSource;
						}
					}
					if (_currentRightSource.MoveNext())
					{
						break;
					}
					_currentRightSource.Dispose();
					_currentRightSource = null;
					_currentRightSourceAsOutput = null;
				}
				_mutables._currentRightSourceIndex++;
				if (_selectManyOperator._resultSelector != null)
				{
					currentElement = _selectManyOperator._resultSelector(_mutables._currentLeftElement, _currentRightSource.Current);
				}
				else
				{
					currentElement = _currentRightSourceAsOutput.Current;
				}
				currentKey = new Pair<TLeftKey, int>(_mutables._currentLeftKey, _mutables._currentRightSourceIndex);
				return true;
			}

			protected override void Dispose(bool disposing)
			{
				_leftSource.Dispose();
				if (_currentRightSource != null)
				{
					_currentRightSource.Dispose();
				}
			}
		}

		private readonly Func<TLeftInput, IEnumerable<TRightInput>> _rightChildSelector;

		private readonly Func<TLeftInput, int, IEnumerable<TRightInput>> _indexedRightChildSelector;

		private readonly Func<TLeftInput, TRightInput, TOutput> _resultSelector;

		private bool _prematureMerge;

		private bool _limitsParallelism;

		internal override bool LimitsParallelism => _limitsParallelism;

		internal SelectManyQueryOperator(IEnumerable<TLeftInput> leftChild, Func<TLeftInput, IEnumerable<TRightInput>> rightChildSelector, Func<TLeftInput, int, IEnumerable<TRightInput>> indexedRightChildSelector, Func<TLeftInput, TRightInput, TOutput> resultSelector)
			: base(leftChild)
		{
			_rightChildSelector = rightChildSelector;
			_indexedRightChildSelector = indexedRightChildSelector;
			_resultSelector = resultSelector;
			_outputOrdered = base.Child.OutputOrdered || indexedRightChildSelector != null;
			InitOrderIndex();
		}

		private void InitOrderIndex()
		{
			OrdinalIndexState ordinalIndexState = base.Child.OrdinalIndexState;
			if (_indexedRightChildSelector != null)
			{
				_prematureMerge = ordinalIndexState.IsWorseThan(OrdinalIndexState.Correct);
				_limitsParallelism = _prematureMerge && ordinalIndexState != OrdinalIndexState.Shuffled;
			}
			else if (base.OutputOrdered)
			{
				_prematureMerge = ordinalIndexState.IsWorseThan(OrdinalIndexState.Increasing);
			}
			SetOrdinalIndexState(OrdinalIndexState.Increasing);
		}

		internal override void WrapPartitionedStream<TLeftKey>(PartitionedStream<TLeftInput, TLeftKey> inputStream, IPartitionedStreamRecipient<TOutput> recipient, bool preferStriping, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			if (_indexedRightChildSelector != null)
			{
				PartitionedStream<TLeftInput, int> inputStream2 = ((!_prematureMerge) ? ((PartitionedStream<TLeftInput, int>)(object)inputStream) : QueryOperator<TLeftInput>.ExecuteAndCollectResults(inputStream, partitionCount, base.OutputOrdered, preferStriping, settings).GetPartitionedStream());
				WrapPartitionedStreamIndexed(inputStream2, recipient, settings);
			}
			else if (_prematureMerge)
			{
				PartitionedStream<TLeftInput, int> partitionedStream = QueryOperator<TLeftInput>.ExecuteAndCollectResults(inputStream, partitionCount, base.OutputOrdered, preferStriping, settings).GetPartitionedStream();
				WrapPartitionedStreamNotIndexed(partitionedStream, recipient, settings);
			}
			else
			{
				WrapPartitionedStreamNotIndexed(inputStream, recipient, settings);
			}
		}

		private void WrapPartitionedStreamNotIndexed<TLeftKey>(PartitionedStream<TLeftInput, TLeftKey> inputStream, IPartitionedStreamRecipient<TOutput> recipient, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			PairComparer<TLeftKey, int> keyComparer = new PairComparer<TLeftKey, int>(inputStream.KeyComparer, Util.GetDefaultComparer<int>());
			PartitionedStream<TOutput, Pair<TLeftKey, int>> partitionedStream = new PartitionedStream<TOutput, Pair<TLeftKey, int>>(partitionCount, keyComparer, OrdinalIndexState);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream[i] = new SelectManyQueryOperatorEnumerator<TLeftKey>(inputStream[i], this, settings.CancellationState.MergedCancellationToken);
			}
			recipient.Receive(partitionedStream);
		}

		private void WrapPartitionedStreamIndexed(PartitionedStream<TLeftInput, int> inputStream, IPartitionedStreamRecipient<TOutput> recipient, QuerySettings settings)
		{
			PairComparer<int, int> keyComparer = new PairComparer<int, int>(inputStream.KeyComparer, Util.GetDefaultComparer<int>());
			PartitionedStream<TOutput, Pair<int, int>> partitionedStream = new PartitionedStream<TOutput, Pair<int, int>>(inputStream.PartitionCount, keyComparer, OrdinalIndexState);
			for (int i = 0; i < inputStream.PartitionCount; i++)
			{
				partitionedStream[i] = new IndexedSelectManyQueryOperatorEnumerator(inputStream[i], this, settings.CancellationState.MergedCancellationToken);
			}
			recipient.Receive(partitionedStream);
		}

		internal override QueryResults<TOutput> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping), this, settings, preferStriping);
		}

		internal override IEnumerable<TOutput> AsSequentialQuery(CancellationToken token)
		{
			if (_rightChildSelector != null)
			{
				if (_resultSelector != null)
				{
					return CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(token), token).SelectMany(_rightChildSelector, _resultSelector);
				}
				return (IEnumerable<TOutput>)CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(token), token).SelectMany(_rightChildSelector);
			}
			if (_resultSelector != null)
			{
				return CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(token), token).SelectMany(_indexedRightChildSelector, _resultSelector);
			}
			return (IEnumerable<TOutput>)CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(token), token).SelectMany(_indexedRightChildSelector);
		}
	}
	internal sealed class SelectQueryOperator<TInput, TOutput> : UnaryQueryOperator<TInput, TOutput>
	{
		private class SelectQueryOperatorEnumerator<TKey> : QueryOperatorEnumerator<TOutput, TKey>
		{
			private readonly QueryOperatorEnumerator<TInput, TKey> _source;

			private readonly Func<TInput, TOutput> _selector;

			internal SelectQueryOperatorEnumerator(QueryOperatorEnumerator<TInput, TKey> source, Func<TInput, TOutput> selector)
			{
				_source = source;
				_selector = selector;
			}

			internal override bool MoveNext(ref TOutput currentElement, ref TKey currentKey)
			{
				TInput currentElement2 = default(TInput);
				if (_source.MoveNext(ref currentElement2, ref currentKey))
				{
					currentElement = _selector(currentElement2);
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private class SelectQueryOperatorResults : UnaryQueryOperatorResults
		{
			private Func<TInput, TOutput> _selector;

			private int _childCount;

			internal override bool IsIndexible => true;

			internal override int ElementsCount => _childCount;

			public static QueryResults<TOutput> NewResults(QueryResults<TInput> childQueryResults, SelectQueryOperator<TInput, TOutput> op, QuerySettings settings, bool preferStriping)
			{
				if (childQueryResults.IsIndexible)
				{
					return new SelectQueryOperatorResults(childQueryResults, op, settings, preferStriping);
				}
				return new UnaryQueryOperatorResults(childQueryResults, op, settings, preferStriping);
			}

			private SelectQueryOperatorResults(QueryResults<TInput> childQueryResults, SelectQueryOperator<TInput, TOutput> op, QuerySettings settings, bool preferStriping)
				: base(childQueryResults, (UnaryQueryOperator<TInput, TOutput>)op, settings, preferStriping)
			{
				_selector = op._selector;
				_childCount = _childQueryResults.ElementsCount;
			}

			internal override TOutput GetElement(int index)
			{
				return _selector(_childQueryResults.GetElement(index));
			}
		}

		private Func<TInput, TOutput> _selector;

		internal override bool LimitsParallelism => false;

		internal SelectQueryOperator(IEnumerable<TInput> child, Func<TInput, TOutput> selector)
			: base(child)
		{
			_selector = selector;
			SetOrdinalIndexState(base.Child.OrdinalIndexState);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TInput, TKey> inputStream, IPartitionedStreamRecipient<TOutput> recipient, bool preferStriping, QuerySettings settings)
		{
			PartitionedStream<TOutput, TKey> partitionedStream = new PartitionedStream<TOutput, TKey>(inputStream.PartitionCount, inputStream.KeyComparer, OrdinalIndexState);
			for (int i = 0; i < inputStream.PartitionCount; i++)
			{
				partitionedStream[i] = new SelectQueryOperatorEnumerator<TKey>(inputStream[i], _selector);
			}
			recipient.Receive(partitionedStream);
		}

		internal override QueryResults<TOutput> Open(QuerySettings settings, bool preferStriping)
		{
			return SelectQueryOperatorResults.NewResults(base.Child.Open(settings, preferStriping), this, settings, preferStriping);
		}

		internal override IEnumerable<TOutput> AsSequentialQuery(CancellationToken token)
		{
			return base.Child.AsSequentialQuery(token).Select(_selector);
		}
	}
	internal sealed class SingleQueryOperator<TSource> : UnaryQueryOperator<TSource, TSource>
	{
		private class SingleQueryOperatorEnumerator<TKey> : QueryOperatorEnumerator<TSource, int>
		{
			private QueryOperatorEnumerator<TSource, TKey> _source;

			private Func<TSource, bool> _predicate;

			private bool _alreadySearched;

			private bool _yieldExtra;

			private Shared<int> _totalElementCount;

			internal SingleQueryOperatorEnumerator(QueryOperatorEnumerator<TSource, TKey> source, Func<TSource, bool> predicate, Shared<int> totalElementCount)
			{
				_source = source;
				_predicate = predicate;
				_totalElementCount = totalElementCount;
			}

			internal override bool MoveNext(ref TSource currentElement, ref int currentKey)
			{
				if (_alreadySearched)
				{
					if (_yieldExtra)
					{
						_yieldExtra = false;
						currentElement = default(TSource);
						currentKey = 0;
						return true;
					}
					return false;
				}
				bool flag = false;
				TSource currentElement2 = default(TSource);
				TKey currentKey2 = default(TKey);
				while (_source.MoveNext(ref currentElement2, ref currentKey2))
				{
					if (_predicate == null || _predicate(currentElement2))
					{
						Interlocked.Increment(ref _totalElementCount.Value);
						currentElement = currentElement2;
						currentKey = 0;
						if (flag)
						{
							_yieldExtra = true;
							break;
						}
						flag = true;
					}
					if (Volatile.Read(ref _totalElementCount.Value) > 1)
					{
						break;
					}
				}
				_alreadySearched = true;
				return flag;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private readonly Func<TSource, bool> _predicate;

		internal override bool LimitsParallelism => false;

		internal SingleQueryOperator(IEnumerable<TSource> child, Func<TSource, bool> predicate)
			: base(child)
		{
			_predicate = predicate;
		}

		internal override QueryResults<TSource> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping: false), this, settings, preferStriping);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TSource, TKey> inputStream, IPartitionedStreamRecipient<TSource> recipient, bool preferStriping, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			PartitionedStream<TSource, int> partitionedStream = new PartitionedStream<TSource, int>(partitionCount, Util.GetDefaultComparer<int>(), OrdinalIndexState.Shuffled);
			Shared<int> totalElementCount = new Shared<int>(0);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream[i] = new SingleQueryOperatorEnumerator<TKey>(inputStream[i], _predicate, totalElementCount);
			}
			recipient.Receive(partitionedStream);
		}

		[ExcludeFromCodeCoverage]
		internal override IEnumerable<TSource> AsSequentialQuery(CancellationToken token)
		{
			throw new NotSupportedException();
		}
	}
	internal sealed class SortQueryOperator<TInputOutput, TSortKey> : UnaryQueryOperator<TInputOutput, TInputOutput>, IOrderedEnumerable<TInputOutput>, IEnumerable<TInputOutput>, IEnumerable
	{
		private readonly Func<TInputOutput, TSortKey> _keySelector;

		private readonly IComparer<TSortKey> _comparer;

		internal override bool LimitsParallelism => false;

		internal SortQueryOperator(IEnumerable<TInputOutput> source, Func<TInputOutput, TSortKey> keySelector, IComparer<TSortKey> comparer, bool descending)
			: base(source, outputOrdered: true)
		{
			_keySelector = keySelector;
			if (comparer == null)
			{
				_comparer = Util.GetDefaultComparer<TSortKey>();
			}
			else
			{
				_comparer = comparer;
			}
			if (descending)
			{
				_comparer = new ReverseComparer<TSortKey>(_comparer);
			}
			SetOrdinalIndexState(OrdinalIndexState.Shuffled);
		}

		IOrderedEnumerable<TInputOutput> IOrderedEnumerable<TInputOutput>.CreateOrderedEnumerable<TKey2>(Func<TInputOutput, TKey2> key2Selector, IComparer<TKey2> key2Comparer, bool descending)
		{
			key2Comparer = key2Comparer ?? Util.GetDefaultComparer<TKey2>();
			if (descending)
			{
				key2Comparer = new ReverseComparer<TKey2>(key2Comparer);
			}
			IComparer<Pair<TSortKey, TKey2>> comparer = new PairComparer<TSortKey, TKey2>(_comparer, key2Comparer);
			Func<TInputOutput, Pair<TSortKey, TKey2>> keySelector = (TInputOutput elem) => new Pair<TSortKey, TKey2>(_keySelector(elem), key2Selector(elem));
			return new SortQueryOperator<TInputOutput, Pair<TSortKey, TKey2>>(base.Child, keySelector, comparer, descending: false);
		}

		internal override QueryResults<TInputOutput> Open(QuerySettings settings, bool preferStriping)
		{
			return new SortQueryOperatorResults<TInputOutput, TSortKey>(base.Child.Open(settings, preferStriping: false), this, settings);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient<TInputOutput> recipient, bool preferStriping, QuerySettings settings)
		{
			PartitionedStream<TInputOutput, TSortKey> partitionedStream = new PartitionedStream<TInputOutput, TSortKey>(inputStream.PartitionCount, _comparer, OrdinalIndexState);
			for (int i = 0; i < partitionedStream.PartitionCount; i++)
			{
				partitionedStream[i] = new SortQueryOperatorEnumerator<TInputOutput, TKey, TSortKey>(inputStream[i], _keySelector);
			}
			recipient.Receive(partitionedStream);
		}

		internal override IEnumerable<TInputOutput> AsSequentialQuery(CancellationToken token)
		{
			return CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(token), token).OrderBy(_keySelector, _comparer);
		}
	}
	internal class SortQueryOperatorResults<TInputOutput, TSortKey> : QueryResults<TInputOutput>
	{
		private class ChildResultsRecipient : IPartitionedStreamRecipient<TInputOutput>
		{
			private IPartitionedStreamRecipient<TInputOutput> _outputRecipient;

			private SortQueryOperator<TInputOutput, TSortKey> _op;

			private QuerySettings _settings;

			internal ChildResultsRecipient(IPartitionedStreamRecipient<TInputOutput> outputRecipient, SortQueryOperator<TInputOutput, TSortKey> op, QuerySettings settings)
			{
				_outputRecipient = outputRecipient;
				_op = op;
				_settings = settings;
			}

			public void Receive<TKey>(PartitionedStream<TInputOutput, TKey> childPartitionedStream)
			{
				_op.WrapPartitionedStream(childPartitionedStream, _outputRecipient, preferStriping: false, _settings);
			}
		}

		protected QueryResults<TInputOutput> _childQueryResults;

		private SortQueryOperator<TInputOutput, TSortKey> _op;

		private QuerySettings _settings;

		internal override bool IsIndexible => false;

		internal SortQueryOperatorResults(QueryResults<TInputOutput> childQueryResults, SortQueryOperator<TInputOutput, TSortKey> op, QuerySettings settings)
		{
			_childQueryResults = childQueryResults;
			_op = op;
			_settings = settings;
		}

		internal override void GivePartitionedStream(IPartitionedStreamRecipient<TInputOutput> recipient)
		{
			_childQueryResults.GivePartitionedStream(new ChildResultsRecipient(recipient, _op, _settings));
		}
	}
	internal class SortQueryOperatorEnumerator<TInputOutput, TKey, TSortKey> : QueryOperatorEnumerator<TInputOutput, TSortKey>
	{
		private readonly QueryOperatorEnumerator<TInputOutput, TKey> _source;

		private readonly Func<TInputOutput, TSortKey> _keySelector;

		internal SortQueryOperatorEnumerator(QueryOperatorEnumerator<TInputOutput, TKey> source, Func<TInputOutput, TSortKey> keySelector)
		{
			_source = source;
			_keySelector = keySelector;
		}

		internal override bool MoveNext(ref TInputOutput currentElement, ref TSortKey currentKey)
		{
			TKey currentKey2 = default(TKey);
			if (!_source.MoveNext(ref currentElement, ref currentKey2))
			{
				return false;
			}
			currentKey = _keySelector(currentElement);
			return true;
		}

		protected override void Dispose(bool disposing)
		{
			_source.Dispose();
		}
	}
	internal sealed class TakeOrSkipQueryOperator<TResult> : UnaryQueryOperator<TResult, TResult>
	{
		private class TakeOrSkipQueryOperatorEnumerator<TKey> : QueryOperatorEnumerator<TResult, TKey>
		{
			private readonly QueryOperatorEnumerator<TResult, TKey> _source;

			private readonly int _count;

			private readonly bool _take;

			private readonly IComparer<TKey> _keyComparer;

			private readonly FixedMaxHeap<TKey> _sharedIndices;

			private readonly CountdownEvent _sharedBarrier;

			private readonly CancellationToken _cancellationToken;

			private List<Pair<TResult, TKey>> _buffer;

			private Shared<int> _bufferIndex;

			internal TakeOrSkipQueryOperatorEnumerator(QueryOperatorEnumerator<TResult, TKey> source, bool take, FixedMaxHeap<TKey> sharedIndices, CountdownEvent sharedBarrier, CancellationToken cancellationToken, IComparer<TKey> keyComparer)
			{
				_source = source;
				_count = sharedIndices.Size;
				_take = take;
				_sharedIndices = sharedIndices;
				_sharedBarrier = sharedBarrier;
				_cancellationToken = cancellationToken;
				_keyComparer = keyComparer;
			}

			internal override bool MoveNext(ref TResult currentElement, ref TKey currentKey)
			{
				if (_buffer == null && _count > 0)
				{
					List<Pair<TResult, TKey>> list = new List<Pair<TResult, TKey>>();
					TResult currentElement2 = default(TResult);
					TKey currentKey2 = default(TKey);
					int num = 0;
					while (list.Count < _count && _source.MoveNext(ref currentElement2, ref currentKey2))
					{
						if ((num++ & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(_cancellationToken);
						}
						list.Add(new Pair<TResult, TKey>(currentElement2, currentKey2));
						lock (_sharedIndices)
						{
							if (!_sharedIndices.Insert(currentKey2))
							{
								break;
							}
						}
					}
					_sharedBarrier.Signal();
					_sharedBarrier.Wait(_cancellationToken);
					_buffer = list;
					_bufferIndex = new Shared<int>(-1);
				}
				if (_take)
				{
					if (_count == 0 || _bufferIndex.Value >= _buffer.Count - 1)
					{
						return false;
					}
					_bufferIndex.Value++;
					currentElement = _buffer[_bufferIndex.Value].First;
					currentKey = _buffer[_bufferIndex.Value].Second;
					if (_sharedIndices.Count != 0)
					{
						return _keyComparer.Compare(_buffer[_bufferIndex.Value].Second, _sharedIndices.MaxValue) <= 0;
					}
					return true;
				}
				TKey val = default(TKey);
				if (_count > 0)
				{
					if (_sharedIndices.Count < _count)
					{
						return false;
					}
					val = _sharedIndices.MaxValue;
					if (_bufferIndex.Value < _buffer.Count - 1)
					{
						_bufferIndex.Value++;
						while (_bufferIndex.Value < _buffer.Count)
						{
							if (_keyComparer.Compare(_buffer[_bufferIndex.Value].Second, val) > 0)
							{
								currentElement = _buffer[_bufferIndex.Value].First;
								currentKey = _buffer[_bufferIndex.Value].Second;
								return true;
							}
							_bufferIndex.Value++;
						}
					}
				}
				if (_source.MoveNext(ref currentElement, ref currentKey))
				{
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private class TakeOrSkipQueryOperatorResults : UnaryQueryOperatorResults
		{
			private TakeOrSkipQueryOperator<TResult> _takeOrSkipOp;

			private int _childCount;

			internal override bool IsIndexible => _childCount >= 0;

			internal override int ElementsCount
			{
				get
				{
					if (_takeOrSkipOp._take)
					{
						return Math.Min(_childCount, _takeOrSkipOp._count);
					}
					return Math.Max(_childCount - _takeOrSkipOp._count, 0);
				}
			}

			public static QueryResults<TResult> NewResults(QueryResults<TResult> childQueryResults, TakeOrSkipQueryOperator<TResult> op, QuerySettings settings, bool preferStriping)
			{
				if (childQueryResults.IsIndexible)
				{
					return new TakeOrSkipQueryOperatorResults(childQueryResults, op, settings, preferStriping);
				}
				return new UnaryQueryOperatorResults(childQueryResults, op, settings, preferStriping);
			}

			private TakeOrSkipQueryOperatorResults(QueryResults<TResult> childQueryResults, TakeOrSkipQueryOperator<TResult> takeOrSkipOp, QuerySettings settings, bool preferStriping)
				: base(childQueryResults, (UnaryQueryOperator<TResult, TResult>)takeOrSkipOp, settings, preferStriping)
			{
				_takeOrSkipOp = takeOrSkipOp;
				_childCount = _childQueryResults.ElementsCount;
			}

			internal override TResult GetElement(int index)
			{
				if (_takeOrSkipOp._take)
				{
					return _childQueryResults.GetElement(index);
				}
				return _childQueryResults.GetElement(_takeOrSkipOp._count + index);
			}
		}

		private readonly int _count;

		private readonly bool _take;

		private bool _prematureMerge;

		internal override bool LimitsParallelism => false;

		internal TakeOrSkipQueryOperator(IEnumerable<TResult> child, int count, bool take)
			: base(child)
		{
			_count = count;
			_take = take;
			SetOrdinalIndexState(OutputOrdinalIndexState());
		}

		private OrdinalIndexState OutputOrdinalIndexState()
		{
			OrdinalIndexState ordinalIndexState = base.Child.OrdinalIndexState;
			if (ordinalIndexState == OrdinalIndexState.Indexable)
			{
				return OrdinalIndexState.Indexable;
			}
			if (ordinalIndexState.IsWorseThan(OrdinalIndexState.Increasing))
			{
				_prematureMerge = true;
				ordinalIndexState = OrdinalIndexState.Correct;
			}
			if (!_take && ordinalIndexState == OrdinalIndexState.Correct)
			{
				ordinalIndexState = OrdinalIndexState.Increasing;
			}
			return ordinalIndexState;
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TResult, TKey> inputStream, IPartitionedStreamRecipient<TResult> recipient, bool preferStriping, QuerySettings settings)
		{
			if (_prematureMerge)
			{
				PartitionedStream<TResult, int> partitionedStream = QueryOperator<TResult>.ExecuteAndCollectResults(inputStream, inputStream.PartitionCount, base.Child.OutputOrdered, preferStriping, settings).GetPartitionedStream();
				WrapHelper(partitionedStream, recipient, settings);
			}
			else
			{
				WrapHelper(inputStream, recipient, settings);
			}
		}

		private void WrapHelper<TKey>(PartitionedStream<TResult, TKey> inputStream, IPartitionedStreamRecipient<TResult> recipient, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			FixedMaxHeap<TKey> sharedIndices = new FixedMaxHeap<TKey>(_count, inputStream.KeyComparer);
			CountdownEvent sharedBarrier = new CountdownEvent(partitionCount);
			PartitionedStream<TResult, TKey> partitionedStream = new PartitionedStream<TResult, TKey>(partitionCount, inputStream.KeyComparer, OrdinalIndexState);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream[i] = new TakeOrSkipQueryOperatorEnumerator<TKey>(inputStream[i], _take, sharedIndices, sharedBarrier, settings.CancellationState.MergedCancellationToken, inputStream.KeyComparer);
			}
			recipient.Receive(partitionedStream);
		}

		internal override QueryResults<TResult> Open(QuerySettings settings, bool preferStriping)
		{
			return TakeOrSkipQueryOperatorResults.NewResults(base.Child.Open(settings, preferStriping: true), this, settings, preferStriping);
		}

		internal override IEnumerable<TResult> AsSequentialQuery(CancellationToken token)
		{
			if (_take)
			{
				return base.Child.AsSequentialQuery(token).Take(_count);
			}
			return CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(token), token).Skip(_count);
		}
	}
	internal sealed class TakeOrSkipWhileQueryOperator<TResult> : UnaryQueryOperator<TResult, TResult>
	{
		private class TakeOrSkipWhileQueryOperatorEnumerator<TKey> : QueryOperatorEnumerator<TResult, TKey>
		{
			private readonly QueryOperatorEnumerator<TResult, TKey> _source;

			private readonly Func<TResult, bool> _predicate;

			private readonly Func<TResult, TKey, bool> _indexedPredicate;

			private readonly bool _take;

			private readonly IComparer<TKey> _keyComparer;

			private readonly OperatorState<TKey> _operatorState;

			private readonly CountdownEvent _sharedBarrier;

			private readonly CancellationToken _cancellationToken;

			private List<Pair<TResult, TKey>> _buffer;

			private Shared<int> _bufferIndex;

			private int _updatesSeen;

			private TKey _currentLowKey;

			internal TakeOrSkipWhileQueryOperatorEnumerator(QueryOperatorEnumerator<TResult, TKey> source, Func<TResult, bool> predicate, Func<TResult, TKey, bool> indexedPredicate, bool take, OperatorState<TKey> operatorState, CountdownEvent sharedBarrier, CancellationToken cancelToken, IComparer<TKey> keyComparer)
			{
				_source = source;
				_predicate = predicate;
				_indexedPredicate = indexedPredicate;
				_take = take;
				_operatorState = operatorState;
				_sharedBarrier = sharedBarrier;
				_cancellationToken = cancelToken;
				_keyComparer = keyComparer;
			}

			internal override bool MoveNext(ref TResult currentElement, ref TKey currentKey)
			{
				if (_buffer == null)
				{
					List<Pair<TResult, TKey>> list = new List<Pair<TResult, TKey>>();
					try
					{
						TResult currentElement2 = default(TResult);
						TKey currentKey2 = default(TKey);
						int num = 0;
						while (_source.MoveNext(ref currentElement2, ref currentKey2))
						{
							if ((num++ & 0x3F) == 0)
							{
								CancellationState.ThrowIfCanceled(_cancellationToken);
							}
							list.Add(new Pair<TResult, TKey>(currentElement2, currentKey2));
							if (_updatesSeen != _operatorState._updatesDone)
							{
								lock (_operatorState)
								{
									_currentLowKey = _operatorState._currentLowKey;
									_updatesSeen = _operatorState._updatesDone;
								}
							}
							if (_updatesSeen > 0 && _keyComparer.Compare(currentKey2, _currentLowKey) > 0)
							{
								break;
							}
							if ((_predicate == null) ? _indexedPredicate(currentElement2, currentKey2) : _predicate(currentElement2))
							{
								continue;
							}
							lock (_operatorState)
							{
								if (_operatorState._updatesDone == 0 || _keyComparer.Compare(_operatorState._currentLowKey, currentKey2) > 0)
								{
									_currentLowKey = (_operatorState._currentLowKey = currentKey2);
									_updatesSeen = ++_operatorState._updatesDone;
								}
							}
							break;
						}
					}
					finally
					{
						_sharedBarrier.Signal();
					}
					_sharedBarrier.Wait(_cancellationToken);
					_buffer = list;
					_bufferIndex = new Shared<int>(-1);
				}
				if (_take)
				{
					if (_bufferIndex.Value >= _buffer.Count - 1)
					{
						return false;
					}
					_bufferIndex.Value++;
					currentElement = _buffer[_bufferIndex.Value].First;
					currentKey = _buffer[_bufferIndex.Value].Second;
					if (_operatorState._updatesDone != 0)
					{
						return _keyComparer.Compare(_operatorState._currentLowKey, currentKey) > 0;
					}
					return true;
				}
				if (_operatorState._updatesDone == 0)
				{
					return false;
				}
				if (_bufferIndex.Value < _buffer.Count - 1)
				{
					_bufferIndex.Value++;
					while (_bufferIndex.Value < _buffer.Count)
					{
						if (_keyComparer.Compare(_buffer[_bufferIndex.Value].Second, _operatorState._currentLowKey) >= 0)
						{
							currentElement = _buffer[_bufferIndex.Value].First;
							currentKey = _buffer[_bufferIndex.Value].Second;
							return true;
						}
						_bufferIndex.Value++;
					}
				}
				if (_source.MoveNext(ref currentElement, ref currentKey))
				{
					return true;
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private class OperatorState<TKey>
		{
			internal volatile int _updatesDone;

			internal TKey _currentLowKey;
		}

		private Func<TResult, bool> _predicate;

		private Func<TResult, int, bool> _indexedPredicate;

		private readonly bool _take;

		private bool _prematureMerge;

		private bool _limitsParallelism;

		internal override bool LimitsParallelism => _limitsParallelism;

		internal TakeOrSkipWhileQueryOperator(IEnumerable<TResult> child, Func<TResult, bool> predicate, Func<TResult, int, bool> indexedPredicate, bool take)
			: base(child)
		{
			_predicate = predicate;
			_indexedPredicate = indexedPredicate;
			_take = take;
			InitOrderIndexState();
		}

		private void InitOrderIndexState()
		{
			OrdinalIndexState state = OrdinalIndexState.Increasing;
			OrdinalIndexState ordinalIndexState = base.Child.OrdinalIndexState;
			if (_indexedPredicate != null)
			{
				state = OrdinalIndexState.Correct;
				_limitsParallelism = ordinalIndexState == OrdinalIndexState.Increasing;
			}
			OrdinalIndexState ordinalIndexState2 = ordinalIndexState.Worse(OrdinalIndexState.Correct);
			if (ordinalIndexState2.IsWorseThan(state))
			{
				_prematureMerge = true;
			}
			if (!_take)
			{
				ordinalIndexState2 = ordinalIndexState2.Worse(OrdinalIndexState.Increasing);
			}
			SetOrdinalIndexState(ordinalIndexState2);
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TResult, TKey> inputStream, IPartitionedStreamRecipient<TResult> recipient, bool preferStriping, QuerySettings settings)
		{
			if (_prematureMerge)
			{
				PartitionedStream<TResult, int> partitionedStream = QueryOperator<TResult>.ExecuteAndCollectResults(inputStream, inputStream.PartitionCount, base.Child.OutputOrdered, preferStriping, settings).GetPartitionedStream();
				WrapHelper(partitionedStream, recipient, settings);
			}
			else
			{
				WrapHelper(inputStream, recipient, settings);
			}
		}

		private void WrapHelper<TKey>(PartitionedStream<TResult, TKey> inputStream, IPartitionedStreamRecipient<TResult> recipient, QuerySettings settings)
		{
			int partitionCount = inputStream.PartitionCount;
			OperatorState<TKey> operatorState = new OperatorState<TKey>();
			CountdownEvent sharedBarrier = new CountdownEvent(partitionCount);
			Func<TResult, TKey, bool> indexedPredicate = (Func<TResult, TKey, bool>)(object)_indexedPredicate;
			PartitionedStream<TResult, TKey> partitionedStream = new PartitionedStream<TResult, TKey>(partitionCount, inputStream.KeyComparer, OrdinalIndexState);
			for (int i = 0; i < partitionCount; i++)
			{
				partitionedStream[i] = new TakeOrSkipWhileQueryOperatorEnumerator<TKey>(inputStream[i], _predicate, indexedPredicate, _take, operatorState, sharedBarrier, settings.CancellationState.MergedCancellationToken, inputStream.KeyComparer);
			}
			recipient.Receive(partitionedStream);
		}

		internal override QueryResults<TResult> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping: true), this, settings, preferStriping);
		}

		internal override IEnumerable<TResult> AsSequentialQuery(CancellationToken token)
		{
			if (_take)
			{
				if (_indexedPredicate != null)
				{
					return base.Child.AsSequentialQuery(token).TakeWhile(_indexedPredicate);
				}
				return base.Child.AsSequentialQuery(token).TakeWhile(_predicate);
			}
			if (_indexedPredicate != null)
			{
				return CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(token), token).SkipWhile(_indexedPredicate);
			}
			return CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(token), token).SkipWhile(_predicate);
		}
	}
	internal sealed class WhereQueryOperator<TInputOutput> : UnaryQueryOperator<TInputOutput, TInputOutput>
	{
		private class WhereQueryOperatorEnumerator<TKey> : QueryOperatorEnumerator<TInputOutput, TKey>
		{
			private readonly QueryOperatorEnumerator<TInputOutput, TKey> _source;

			private readonly Func<TInputOutput, bool> _predicate;

			private CancellationToken _cancellationToken;

			private Shared<int> _outputLoopCount;

			internal WhereQueryOperatorEnumerator(QueryOperatorEnumerator<TInputOutput, TKey> source, Func<TInputOutput, bool> predicate, CancellationToken cancellationToken)
			{
				_source = source;
				_predicate = predicate;
				_cancellationToken = cancellationToken;
			}

			internal override bool MoveNext(ref TInputOutput currentElement, ref TKey currentKey)
			{
				if (_outputLoopCount == null)
				{
					_outputLoopCount = new Shared<int>(0);
				}
				while (_source.MoveNext(ref currentElement, ref currentKey))
				{
					if ((_outputLoopCount.Value++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(_cancellationToken);
					}
					if (_predicate(currentElement))
					{
						return true;
					}
				}
				return false;
			}

			protected override void Dispose(bool disposing)
			{
				_source.Dispose();
			}
		}

		private Func<TInputOutput, bool> _predicate;

		internal override bool LimitsParallelism => false;

		internal WhereQueryOperator(IEnumerable<TInputOutput> child, Func<TInputOutput, bool> predicate)
			: base(child)
		{
			SetOrdinalIndexState(base.Child.OrdinalIndexState.Worse(OrdinalIndexState.Increasing));
			_predicate = predicate;
		}

		internal override void WrapPartitionedStream<TKey>(PartitionedStream<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient<TInputOutput> recipient, bool preferStriping, QuerySettings settings)
		{
			PartitionedStream<TInputOutput, TKey> partitionedStream = new PartitionedStream<TInputOutput, TKey>(inputStream.PartitionCount, inputStream.KeyComparer, OrdinalIndexState);
			for (int i = 0; i < inputStream.PartitionCount; i++)
			{
				partitionedStream[i] = new WhereQueryOperatorEnumerator<TKey>(inputStream[i], _predicate, settings.CancellationState.MergedCancellationToken);
			}
			recipient.Receive(partitionedStream);
		}

		internal override QueryResults<TInputOutput> Open(QuerySettings settings, bool preferStriping)
		{
			return new UnaryQueryOperatorResults(base.Child.Open(settings, preferStriping), this, settings, preferStriping);
		}

		internal override IEnumerable<TInputOutput> AsSequentialQuery(CancellationToken token)
		{
			return CancellableEnumerable.Wrap(base.Child.AsSequentialQuery(token), token).Where(_predicate);
		}
	}
	internal abstract class UnaryQueryOperator<TInput, TOutput> : QueryOperator<TOutput>
	{
		internal class UnaryQueryOperatorResults : QueryResults<TOutput>
		{
			private class ChildResultsRecipient : IPartitionedStreamRecipient<TInput>
			{
				private IPartitionedStreamRecipient<TOutput> _outputRecipient;

				private UnaryQueryOperator<TInput, TOutput> _op;

				private bool _preferStriping;

				private QuerySettings _settings;

				internal ChildResultsRecipient(IPartitionedStreamRecipient<TOutput> outputRecipient, UnaryQueryOperator<TInput, TOutput> op, bool preferStriping, QuerySettings settings)
				{
					_outputRecipient = outputRecipient;
					_op = op;
					_preferStriping = preferStriping;
					_settings = settings;
				}

				public void Receive<TKey>(PartitionedStream<TInput, TKey> inputStream)
				{
					_op.WrapPartitionedStream(inputStream, _outputRecipient, _preferStriping, _settings);
				}
			}

			protected QueryResults<TInput> _childQueryResults;

			private UnaryQueryOperator<TInput, TOutput> _op;

			private QuerySettings _settings;

			private bool _preferStriping;

			internal UnaryQueryOperatorResults(QueryResults<TInput> childQueryResults, UnaryQueryOperator<TInput, TOutput> op, QuerySettings settings, bool preferStriping)
			{
				_childQueryResults = childQueryResults;
				_op = op;
				_settings = settings;
				_preferStriping = preferStriping;
			}

			internal override void GivePartitionedStream(IPartitionedStreamRecipient<TOutput> recipient)
			{
				if (_settings.ExecutionMode.Value == ParallelExecutionMode.Default && _op.LimitsParallelism)
				{
					PartitionedStream<TOutput, int> partitionedStream = ExchangeUtilities.PartitionDataSource(_op.AsSequentialQuery(_settings.CancellationState.ExternalCancellationToken), _settings.DegreeOfParallelism.Value, _preferStriping);
					recipient.Receive(partitionedStream);
				}
				else if (IsIndexible)
				{
					PartitionedStream<TOutput, int> partitionedStream2 = ExchangeUtilities.PartitionDataSource(this, _settings.DegreeOfParallelism.Value, _preferStriping);
					recipient.Receive(partitionedStream2);
				}
				else
				{
					_childQueryResults.GivePartitionedStream(new ChildResultsRecipient(recipient, _op, _preferStriping, _settings));
				}
			}
		}

		private readonly QueryOperator<TInput> _child;

		private OrdinalIndexState _indexState = OrdinalIndexState.Shuffled;

		internal QueryOperator<TInput> Child => _child;

		internal sealed override OrdinalIndexState OrdinalIndexState => _indexState;

		internal UnaryQueryOperator(IEnumerable<TInput> child)
			: this(QueryOperator<TInput>.AsQueryOperator(child))
		{
		}

		internal UnaryQueryOperator(IEnumerable<TInput> child, bool outputOrdered)
			: this(QueryOperator<TInput>.AsQueryOperator(child), outputOrdered)
		{
		}

		private UnaryQueryOperator(QueryOperator<TInput> child)
			: this(child, child.OutputOrdered, child.SpecifiedQuerySettings)
		{
		}

		internal UnaryQueryOperator(QueryOperator<TInput> child, bool outputOrdered)
			: this(child, outputOrdered, child.SpecifiedQuerySettings)
		{
		}

		private UnaryQueryOperator(QueryOperator<TInput> child, bool outputOrdered, QuerySettings settings)
			: base(outputOrdered, settings)
		{
			_child = child;
		}

		protected void SetOrdinalIndexState(OrdinalIndexState indexState)
		{
			_indexState = indexState;
		}

		internal abstract void WrapPartitionedStream<TKey>(PartitionedStream<TInput, TKey> inputStream, IPartitionedStreamRecipient<TOutput> recipient, bool preferStriping, QuerySettings settings);
	}
	internal class CancellationState
	{
		internal CancellationTokenSource InternalCancellationTokenSource;

		internal CancellationToken ExternalCancellationToken;

		internal CancellationTokenSource MergedCancellationTokenSource;

		internal Shared<bool> TopLevelDisposedFlag;

		internal const int POLL_INTERVAL = 63;

		internal CancellationToken MergedCancellationToken
		{
			get
			{
				if (MergedCancellationTokenSource != null)
				{
					return MergedCancellationTokenSource.Token;
				}
				return new CancellationToken(canceled: false);
			}
		}

		internal CancellationState(CancellationToken externalCancellationToken)
		{
			ExternalCancellationToken = externalCancellationToken;
			TopLevelDisposedFlag = new Shared<bool>(value: false);
		}

		internal static void ThrowIfCanceled(CancellationToken token)
		{
			if (token.IsCancellationRequested)
			{
				throw new OperationCanceledException(token);
			}
		}

		internal static void ThrowWithStandardMessageIfCanceled(CancellationToken externalCancellationToken)
		{
			if (externalCancellationToken.IsCancellationRequested)
			{
				throw new OperationCanceledException("The query has been canceled via the token supplied to WithCancellation.", externalCancellationToken);
			}
		}
	}
	internal class OrderPreservingPipeliningSpoolingTask<TOutput, TKey> : SpoolingTaskBase
	{
		private readonly QueryTaskGroupState _taskGroupState;

		private readonly QueryOperatorEnumerator<TOutput, TKey> _partition;

		private readonly bool[] _consumerWaiting;

		private readonly bool[] _producerWaiting;

		private readonly bool[] _producerDone;

		private readonly int _partitionIndex;

		private readonly Queue<Pair<TKey, TOutput>>[] _buffers;

		private readonly object _bufferLock;

		private readonly bool _autoBuffered;

		private const int PRODUCER_BUFFER_AUTO_SIZE = 16;

		internal OrderPreservingPipeliningSpoolingTask(QueryOperatorEnumerator<TOutput, TKey> partition, QueryTaskGroupState taskGroupState, bool[] consumerWaiting, bool[] producerWaiting, bool[] producerDone, int partitionIndex, Queue<Pair<TKey, TOutput>>[] buffers, object bufferLock, bool autoBuffered)
			: base(partitionIndex, taskGroupState)
		{
			_partition = partition;
			_taskGroupState = taskGroupState;
			_producerDone = producerDone;
			_consumerWaiting = consumerWaiting;
			_producerWaiting = producerWaiting;
			_partitionIndex = partitionIndex;
			_buffers = buffers;
			_bufferLock = bufferLock;
			_autoBuffered = autoBuffered;
		}

		protected override void SpoolingWork()
		{
			TOutput currentElement = default(TOutput);
			TKey currentKey = default(TKey);
			int num = ((!_autoBuffered) ? 1 : 16);
			Pair<TKey, TOutput>[] array = new Pair<TKey, TOutput>[num];
			QueryOperatorEnumerator<TOutput, TKey> partition = _partition;
			CancellationToken mergedCancellationToken = _taskGroupState.CancellationState.MergedCancellationToken;
			int i;
			do
			{
				for (i = 0; i < num; i++)
				{
					if (!partition.MoveNext(ref currentElement, ref currentKey))
					{
						break;
					}
					array[i] = new Pair<TKey, TOutput>(currentKey, currentElement);
				}
				if (i == 0)
				{
					break;
				}
				lock (_bufferLock)
				{
					if (mergedCancellationToken.IsCancellationRequested)
					{
						break;
					}
					for (int j = 0; j < i; j++)
					{
						_buffers[_partitionIndex].Enqueue(array[j]);
					}
					if (_consumerWaiting[_partitionIndex])
					{
						Monitor.Pulse(_bufferLock);
						_consumerWaiting[_partitionIndex] = false;
					}
					if (_buffers[_partitionIndex].Count >= 8192)
					{
						_producerWaiting[_partitionIndex] = true;
						Monitor.Wait(_bufferLock);
					}
				}
			}
			while (i == num);
		}

		public static void Spool(QueryTaskGroupState groupState, PartitionedStream<TOutput, TKey> partitions, bool[] consumerWaiting, bool[] producerWaiting, bool[] producerDone, Queue<Pair<TKey, TOutput>>[] buffers, object[] bufferLocks, TaskScheduler taskScheduler, bool autoBuffered)
		{
			int degreeOfParallelism = partitions.PartitionCount;
			for (int i = 0; i < degreeOfParallelism; i++)
			{
				buffers[i] = new Queue<Pair<TKey, TOutput>>(128);
				bufferLocks[i] = new object();
			}
			Task task = new Task(delegate
			{
				for (int j = 0; j < degreeOfParallelism; j++)
				{
					new OrderPreservingPipeliningSpoolingTask<TOutput, TKey>(partitions[j], groupState, consumerWaiting, producerWaiting, producerDone, j, buffers, bufferLocks[j], autoBuffered).RunAsynchronously(taskScheduler);
				}
			});
			groupState.QueryBegin(task);
			task.Start(taskScheduler);
		}

		protected override void SpoolingFinally()
		{
			lock (_bufferLock)
			{
				_producerDone[_partitionIndex] = true;
				if (_consumerWaiting[_partitionIndex])
				{
					Monitor.Pulse(_bufferLock);
					_consumerWaiting[_partitionIndex] = false;
				}
			}
			base.SpoolingFinally();
			_partition.Dispose();
		}
	}
	internal class OrderPreservingSpoolingTask<TInputOutput, TKey> : SpoolingTaskBase
	{
		private Shared<TInputOutput[]> _results;

		private SortHelper<TInputOutput> _sortHelper;

		private OrderPreservingSpoolingTask(int taskIndex, QueryTaskGroupState groupState, Shared<TInputOutput[]> results, SortHelper<TInputOutput> sortHelper)
			: base(taskIndex, groupState)
		{
			_results = results;
			_sortHelper = sortHelper;
		}

		internal static void Spool(QueryTaskGroupState groupState, PartitionedStream<TInputOutput, TKey> partitions, Shared<TInputOutput[]> results, TaskScheduler taskScheduler)
		{
			int maxToRunInParallel = partitions.PartitionCount - 1;
			SortHelper<TInputOutput, TKey>[] sortHelpers = SortHelper<TInputOutput, TKey>.GenerateSortHelpers(partitions, groupState);
			Task task = new Task(delegate
			{
				for (int i = 0; i < maxToRunInParallel; i++)
				{
					new OrderPreservingSpoolingTask<TInputOutput, TKey>(i, groupState, results, sortHelpers[i]).RunAsynchronously(taskScheduler);
				}
				new OrderPreservingSpoolingTask<TInputOutput, TKey>(maxToRunInParallel, groupState, results, sortHelpers[maxToRunInParallel]).RunSynchronously(taskScheduler);
			});
			groupState.QueryBegin(task);
			task.RunSynchronously(taskScheduler);
			for (int num = 0; num < sortHelpers.Length; num++)
			{
				sortHelpers[num].Dispose();
			}
			groupState.QueryEnd(userInitiatedDispose: false);
		}

		protected override void SpoolingWork()
		{
			TInputOutput[] value = _sortHelper.Sort();
			if (!_groupState.CancellationState.MergedCancellationToken.IsCancellationRequested && _taskIndex == 0)
			{
				_results.Value = value;
			}
		}
	}
	internal static class QueryLifecycle
	{
		internal static void LogicalQueryExecutionBegin(int queryID)
		{
			PlinqEtwProvider.Log.ParallelQueryBegin(queryID);
		}

		internal static void LogicalQueryExecutionEnd(int queryID)
		{
			PlinqEtwProvider.Log.ParallelQueryEnd(queryID);
		}
	}
	internal abstract class QueryTask
	{
		protected int _taskIndex;

		protected QueryTaskGroupState _groupState;

		private static Action<object> s_runTaskSynchronouslyDelegate = RunTaskSynchronously;

		private static Action<object> s_baseWorkDelegate = delegate(object o)
		{
			((QueryTask)o).BaseWork(null);
		};

		protected QueryTask(int taskIndex, QueryTaskGroupState groupState)
		{
			_taskIndex = taskIndex;
			_groupState = groupState;
		}

		private static void RunTaskSynchronously(object o)
		{
			((QueryTask)o).BaseWork(null);
		}

		internal Task RunSynchronously(TaskScheduler taskScheduler)
		{
			Task task = new Task(s_runTaskSynchronouslyDelegate, this, TaskCreationOptions.AttachedToParent);
			task.RunSynchronously(taskScheduler);
			return task;
		}

		internal Task RunAsynchronously(TaskScheduler taskScheduler)
		{
			return Task.Factory.StartNew(s_baseWorkDelegate, this, default(CancellationToken), TaskCreationOptions.PreferFairness | TaskCreationOptions.AttachedToParent, taskScheduler);
		}

		private void BaseWork(object unused)
		{
			PlinqEtwProvider.Log.ParallelQueryFork(_groupState.QueryId);
			try
			{
				Work();
			}
			finally
			{
				PlinqEtwProvider.Log.ParallelQueryJoin(_groupState.QueryId);
			}
		}

		protected abstract void Work();
	}
	internal class QueryTaskGroupState
	{
		private Task _rootTask;

		private int _alreadyEnded;

		private CancellationState _cancellationState;

		private int _queryId;

		internal bool IsAlreadyEnded => _alreadyEnded == 1;

		internal CancellationState CancellationState => _cancellationState;

		internal int QueryId => _queryId;

		internal QueryTaskGroupState(CancellationState cancellationState, int queryId)
		{
			_cancellationState = cancellationState;
			_queryId = queryId;
		}

		internal void QueryBegin(Task rootTask)
		{
			_rootTask = rootTask;
		}

		internal void QueryEnd(bool userInitiatedDispose)
		{
			if (Interlocked.Exchange(ref _alreadyEnded, 1) != 0)
			{
				return;
			}
			try
			{
				_rootTask.Wait();
			}
			catch (AggregateException ex)
			{
				AggregateException ex2 = ex.Flatten();
				bool flag = true;
				for (int i = 0; i < ex2.InnerExceptions.Count; i++)
				{
					if (!(ex2.InnerExceptions[i] is OperationCanceledException { CancellationToken: { IsCancellationRequested: not false } } ex3) || ex3.CancellationToken != _cancellationState.ExternalCancellationToken)
					{
						flag = false;
						break;
					}
				}
				if (!flag)
				{
					throw ex2;
				}
			}
			finally
			{
				((IDisposable)_rootTask)?.Dispose();
			}
			if (_cancellationState.MergedCancellationToken.IsCancellationRequested)
			{
				if (!_cancellationState.TopLevelDisposedFlag.Value)
				{
					CancellationState.ThrowWithStandardMessageIfCanceled(_cancellationState.ExternalCancellationToken);
				}
				if (!userInitiatedDispose)
				{
					throw new ObjectDisposedException("enumerator", "The query enumerator has been disposed.");
				}
			}
		}
	}
	internal static class Scheduling
	{
		internal const bool DefaultPreserveOrder = false;

		internal static int DefaultDegreeOfParallelism = Math.Min(Environment.ProcessorCount, 16);

		internal const int DEFAULT_BOUNDED_BUFFER_CAPACITY = 512;

		internal const int DEFAULT_BYTES_PER_CHUNK = 512;

		internal const int ZOMBIED_PRODUCER_TIMEOUT = -1;

		internal const int MAX_SUPPORTED_DOP = 512;

		internal static int GetDefaultDegreeOfParallelism()
		{
			return DefaultDegreeOfParallelism;
		}

		internal static int GetDefaultChunkSize<T>()
		{
			if (default(T) != null || Nullable.GetUnderlyingType(typeof(T)) != null)
			{
				return 128;
			}
			return 512 / IntPtr.Size;
		}
	}
	internal static class SpoolingTask
	{
		internal static void SpoolStopAndGo<TInputOutput, TIgnoreKey>(QueryTaskGroupState groupState, PartitionedStream<TInputOutput, TIgnoreKey> partitions, SynchronousChannel<TInputOutput>[] channels, TaskScheduler taskScheduler)
		{
			Task task = new Task(delegate
			{
				int num = partitions.PartitionCount - 1;
				for (int i = 0; i < num; i++)
				{
					new StopAndGoSpoolingTask<TInputOutput, TIgnoreKey>(i, groupState, partitions[i], channels[i]).RunAsynchronously(taskScheduler);
				}
				new StopAndGoSpoolingTask<TInputOutput, TIgnoreKey>(num, groupState, partitions[num], channels[num]).RunSynchronously(taskScheduler);
			});
			groupState.QueryBegin(task);
			task.RunSynchronously(taskScheduler);
			groupState.QueryEnd(userInitiatedDispose: false);
		}

		internal static void SpoolPipeline<TInputOutput, TIgnoreKey>(QueryTaskGroupState groupState, PartitionedStream<TInputOutput, TIgnoreKey> partitions, AsynchronousChannel<TInputOutput>[] channels, TaskScheduler taskScheduler)
		{
			Task task = new Task(delegate
			{
				for (int i = 0; i < partitions.PartitionCount; i++)
				{
					new PipelineSpoolingTask<TInputOutput, TIgnoreKey>(i, groupState, partitions[i], channels[i]).RunAsynchronously(taskScheduler);
				}
			});
			groupState.QueryBegin(task);
			task.Start(taskScheduler);
		}

		internal static void SpoolForAll<TInputOutput, TIgnoreKey>(QueryTaskGroupState groupState, PartitionedStream<TInputOutput, TIgnoreKey> partitions, TaskScheduler taskScheduler)
		{
			Task task = new Task(delegate
			{
				int num = partitions.PartitionCount - 1;
				for (int i = 0; i < num; i++)
				{
					new ForAllSpoolingTask<TInputOutput, TIgnoreKey>(i, groupState, partitions[i]).RunAsynchronously(taskScheduler);
				}
				new ForAllSpoolingTask<TInputOutput, TIgnoreKey>(num, groupState, partitions[num]).RunSynchronously(taskScheduler);
			});
			groupState.QueryBegin(task);
			task.RunSynchronously(taskScheduler);
			groupState.QueryEnd(userInitiatedDispose: false);
		}
	}
	internal class StopAndGoSpoolingTask<TInputOutput, TIgnoreKey> : SpoolingTaskBase
	{
		private QueryOperatorEnumerator<TInputOutput, TIgnoreKey> _source;

		private SynchronousChannel<TInputOutput> _destination;

		internal StopAndGoSpoolingTask(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator<TInputOutput, TIgnoreKey> source, SynchronousChannel<TInputOutput> destination)
			: base(taskIndex, groupState)
		{
			_source = source;
			_destination = destination;
		}

		protected override void SpoolingWork()
		{
			TInputOutput currentElement = default(TInputOutput);
			TIgnoreKey currentKey = default(TIgnoreKey);
			QueryOperatorEnumerator<TInputOutput, TIgnoreKey> source = _source;
			SynchronousChannel<TInputOutput> destination = _destination;
			CancellationToken mergedCancellationToken = _groupState.CancellationState.MergedCancellationToken;
			destination.Init();
			while (source.MoveNext(ref currentElement, ref currentKey) && !mergedCancellationToken.IsCancellationRequested)
			{
				destination.Enqueue(currentElement);
			}
		}

		protected override void SpoolingFinally()
		{
			base.SpoolingFinally();
			if (_destination != null)
			{
				_destination.SetDone();
			}
			_source.Dispose();
		}
	}
	internal class PipelineSpoolingTask<TInputOutput, TIgnoreKey> : SpoolingTaskBase
	{
		private QueryOperatorEnumerator<TInputOutput, TIgnoreKey> _source;

		private AsynchronousChannel<TInputOutput> _destination;

		internal PipelineSpoolingTask(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator<TInputOutput, TIgnoreKey> source, AsynchronousChannel<TInputOutput> destination)
			: base(taskIndex, groupState)
		{
			_source = source;
			_destination = destination;
		}

		protected override void SpoolingWork()
		{
			TInputOutput currentElement = default(TInputOutput);
			TIgnoreKey currentKey = default(TIgnoreKey);
			QueryOperatorEnumerator<TInputOutput, TIgnoreKey> source = _source;
			AsynchronousChannel<TInputOutput> destination = _destination;
			CancellationToken mergedCancellationToken = _groupState.CancellationState.MergedCancellationToken;
			while (source.MoveNext(ref currentElement, ref currentKey) && !mergedCancellationToken.IsCancellationRequested)
			{
				destination.Enqueue(currentElement);
			}
			destination.FlushBuffers();
		}

		protected override void SpoolingFinally()
		{
			base.SpoolingFinally();
			if (_destination != null)
			{
				_destination.SetDone();
			}
			_source.Dispose();
		}
	}
	internal class ForAllSpoolingTask<TInputOutput, TIgnoreKey> : SpoolingTaskBase
	{
		private QueryOperatorEnumerator<TInputOutput, TIgnoreKey> _source;

		internal ForAllSpoolingTask(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator<TInputOutput, TIgnoreKey> source)
			: base(taskIndex, groupState)
		{
			_source = source;
		}

		protected override void SpoolingWork()
		{
			TInputOutput currentElement = default(TInputOutput);
			TIgnoreKey currentKey = default(TIgnoreKey);
			while (_source.MoveNext(ref currentElement, ref currentKey))
			{
			}
		}

		protected override void SpoolingFinally()
		{
			base.SpoolingFinally();
			_source.Dispose();
		}
	}
	internal abstract class SpoolingTaskBase : QueryTask
	{
		protected SpoolingTaskBase(int taskIndex, QueryTaskGroupState groupState)
			: base(taskIndex, groupState)
		{
		}

		protected override void Work()
		{
			try
			{
				SpoolingWork();
			}
			catch (Exception ex)
			{
				if (!(ex is OperationCanceledException ex2) || !(ex2.CancellationToken == _groupState.CancellationState.MergedCancellationToken) || !_groupState.CancellationState.MergedCancellationToken.IsCancellationRequested)
				{
					_groupState.CancellationState.InternalCancellationTokenSource.Cancel();
					throw;
				}
			}
			finally
			{
				SpoolingFinally();
			}
		}

		protected abstract void SpoolingWork();

		protected virtual void SpoolingFinally()
		{
		}
	}
	internal static class CancellableEnumerable
	{
		internal static IEnumerable<TElement> Wrap<TElement>(IEnumerable<TElement> source, CancellationToken token)
		{
			int count = 0;
			foreach (TElement item in source)
			{
				if ((count++ & 0x3F) == 0)
				{
					CancellationState.ThrowIfCanceled(token);
				}
				yield return item;
			}
		}
	}
	internal static class ExceptionAggregator
	{
		internal static IEnumerable<TElement> WrapEnumerable<TElement>(IEnumerable<TElement> source, CancellationState cancellationState)
		{
			using IEnumerator<TElement> enumerator = source.GetEnumerator();
			while (true)
			{
				TElement val = default(TElement);
				try
				{
					if (!enumerator.MoveNext())
					{
						break;
					}
					val = enumerator.Current;
				}
				catch (Exception ex)
				{
					ThrowOCEorAggregateException(ex, cancellationState);
				}
				yield return val;
			}
		}

		internal static IEnumerable<TElement> WrapQueryEnumerator<TElement, TIgnoreKey>(QueryOperatorEnumerator<TElement, TIgnoreKey> source, CancellationState cancellationState)
		{
			TElement elem = default(TElement);
			TIgnoreKey ignoreKey = default(TIgnoreKey);
			try
			{
				while (true)
				{
					try
					{
						if (!source.MoveNext(ref elem, ref ignoreKey))
						{
							break;
						}
					}
					catch (Exception ex)
					{
						ThrowOCEorAggregateException(ex, cancellationState);
					}
					yield return elem;
				}
			}
			finally
			{
				source.Dispose();
			}
		}

		internal static void ThrowOCEorAggregateException(Exception ex, CancellationState cancellationState)
		{
			if (ThrowAnOCE(ex, cancellationState))
			{
				CancellationState.ThrowWithStandardMessageIfCanceled(cancellationState.ExternalCancellationToken);
				return;
			}
			throw new AggregateException(ex);
		}

		internal static Func<T, U> WrapFunc<T, U>(Func<T, U> f, CancellationState cancellationState)
		{
			return delegate(T t)
			{
				U result = default(U);
				try
				{
					result = f(t);
					return result;
				}
				catch (Exception ex)
				{
					ThrowOCEorAggregateException(ex, cancellationState);
				}
				return result;
			};
		}

		private static bool ThrowAnOCE(Exception ex, CancellationState cancellationState)
		{
			OperationCanceledException ex2 = ex as OperationCanceledException;
			if (ex2 != null && ex2.CancellationToken == cancellationState.ExternalCancellationToken && cancellationState.ExternalCancellationToken.IsCancellationRequested)
			{
				return true;
			}
			if (ex2 != null && ex2.CancellationToken == cancellationState.MergedCancellationToken && cancellationState.MergedCancellationToken.IsCancellationRequested && cancellationState.ExternalCancellationToken.IsCancellationRequested)
			{
				return true;
			}
			return false;
		}
	}
	internal static class ExchangeUtilities
	{
		internal static PartitionedStream<T, int> PartitionDataSource<T>(IEnumerable<T> source, int partitionCount, bool useStriping)
		{
			if (source is IParallelPartitionable<T> parallelPartitionable)
			{
				QueryOperatorEnumerator<T, int>[] partitions = parallelPartitionable.GetPartitions(partitionCount);
				if (partitions == null)
				{
					throw new InvalidOperationException("The return value must not be null.");
				}
				if (partitions.Length != partitionCount)
				{
					throw new InvalidOperationException("The returned array's length must equal the number of partitions requested.");
				}
				PartitionedStream<T, int> partitionedStream = new PartitionedStream<T, int>(partitionCount, Util.GetDefaultComparer<int>(), OrdinalIndexState.Correct);
				for (int i = 0; i < partitionCount; i++)
				{
					QueryOperatorEnumerator<T, int> queryOperatorEnumerator = partitions[i];
					if (queryOperatorEnumerator == null)
					{
						throw new InvalidOperationException("Elements returned must not be null.");
					}
					partitionedStream[i] = queryOperatorEnumerator;
				}
				return partitionedStream;
			}
			return new PartitionedDataSource<T>(source, partitionCount, useStriping);
		}

		internal static PartitionedStream<Pair<TElement, THashKey>, int> HashRepartition<TElement, THashKey, TIgnoreKey>(PartitionedStream<TElement, TIgnoreKey> source, Func<TElement, THashKey> keySelector, IEqualityComparer<THashKey> keyComparer, IEqualityComparer<TElement> elementComparer, CancellationToken cancellationToken)
		{
			return new UnorderedHashRepartitionStream<TElement, THashKey, TIgnoreKey>(source, keySelector, keyComparer, elementComparer, cancellationToken);
		}

		internal static PartitionedStream<Pair<TElement, THashKey>, TOrderKey> HashRepartitionOrdered<TElement, THashKey, TOrderKey>(PartitionedStream<TElement, TOrderKey> source, Func<TElement, THashKey> keySelector, IEqualityComparer<THashKey> keyComparer, IEqualityComparer<TElement> elementComparer, CancellationToken cancellationToken)
		{
			return new OrderedHashRepartitionStream<TElement, THashKey, TOrderKey>(source, keySelector, keyComparer, elementComparer, cancellationToken);
		}

		internal static OrdinalIndexState Worse(this OrdinalIndexState state1, OrdinalIndexState state2)
		{
			if ((int)state1 <= (int)state2)
			{
				return state2;
			}
			return state1;
		}

		internal static bool IsWorseThan(this OrdinalIndexState state1, OrdinalIndexState state2)
		{
			return (int)state1 > (int)state2;
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	internal struct NoKeyMemoizationRequired
	{
	}
	internal class FixedMaxHeap<TElement>
	{
		private TElement[] _elements;

		private int _count;

		private IComparer<TElement> _comparer;

		internal int Count => _count;

		internal int Size => _elements.Length;

		internal TElement MaxValue
		{
			get
			{
				if (_count == 0)
				{
					throw new InvalidOperationException("Sequence contains no elements");
				}
				return _elements[0];
			}
		}

		internal FixedMaxHeap(int maximumSize)
			: this(maximumSize, (IComparer<TElement>)Util.GetDefaultComparer<TElement>())
		{
		}

		internal FixedMaxHeap(int maximumSize, IComparer<TElement> comparer)
		{
			_elements = new TElement[maximumSize];
			_comparer = comparer;
		}

		internal void Clear()
		{
			_count = 0;
		}

		internal bool Insert(TElement e)
		{
			if (_count < _elements.Length)
			{
				_elements[_count] = e;
				_count++;
				HeapifyLastLeaf();
				return true;
			}
			if (_comparer.Compare(e, _elements[0]) < 0)
			{
				_elements[0] = e;
				HeapifyRoot();
				return true;
			}
			return false;
		}

		internal void ReplaceMax(TElement newValue)
		{
			_elements[0] = newValue;
			HeapifyRoot();
		}

		internal void RemoveMax()
		{
			_count--;
			if (_count > 0)
			{
				_elements[0] = _elements[_count];
				HeapifyRoot();
			}
		}

		private void Swap(int i, int j)
		{
			TElement val = _elements[i];
			_elements[i] = _elements[j];
			_elements[j] = val;
		}

		private void HeapifyRoot()
		{
			int num = 0;
			int count = _count;
			while (num < count)
			{
				int num2 = (num + 1) * 2 - 1;
				int num3 = num2 + 1;
				if (num2 < count && _comparer.Compare(_elements[num], _elements[num2]) < 0)
				{
					if (num3 < count && _comparer.Compare(_elements[num2], _elements[num3]) < 0)
					{
						Swap(num, num3);
						num = num3;
					}
					else
					{
						Swap(num, num2);
						num = num2;
					}
				}
				else
				{
					if (num3 >= count || _comparer.Compare(_elements[num], _elements[num3]) >= 0)
					{
						break;
					}
					Swap(num, num3);
					num = num3;
				}
			}
		}

		private void HeapifyLastLeaf()
		{
			int num = _count - 1;
			while (num > 0)
			{
				int num2 = (num + 1) / 2 - 1;
				if (_comparer.Compare(_elements[num], _elements[num2]) > 0)
				{
					Swap(num, num2);
					num = num2;
					continue;
				}
				break;
			}
		}
	}
	internal class GrowingArray<T>
	{
		private T[] _array;

		private int _count;

		private const int DEFAULT_ARRAY_SIZE = 1024;

		internal T[] InternalArray => _array;

		internal int Count => _count;

		internal GrowingArray()
		{
			_array = new T[1024];
			_count = 0;
		}

		internal void Add(T element)
		{
			if (_count >= _array.Length)
			{
				GrowArray(2 * _array.Length);
			}
			_array[_count++] = element;
		}

		private void GrowArray(int newSize)
		{
			T[] array = new T[newSize];
			_array.CopyTo(array, 0);
			_array = array;
		}

		internal void CopyFrom(T[] otherArray, int otherCount)
		{
			if (_count + otherCount > _array.Length)
			{
				GrowArray(_count + otherCount);
			}
			Array.Copy(otherArray, 0, _array, _count, otherCount);
			_count += otherCount;
		}
	}
	internal class HashLookup<TKey, TValue>
	{
		internal struct Slot
		{
			internal int hashCode;

			internal int next;

			internal TKey key;

			internal TValue value;
		}

		private int[] buckets;

		private Slot[] slots;

		private int count;

		private int freeList;

		private IEqualityComparer<TKey> comparer;

		private const int HashCodeMask = int.MaxValue;

		internal TValue this[TKey key]
		{
			set
			{
				TValue value2 = value;
				Find(key, add: false, set: true, ref value2);
			}
		}

		internal int Count => count;

		internal KeyValuePair<TKey, TValue> this[int index] => new KeyValuePair<TKey, TValue>(slots[index].key, slots[index].value);

		internal HashLookup()
			: this((IEqualityComparer<TKey>)null)
		{
		}

		internal HashLookup(IEqualityComparer<TKey> comparer)
		{
			this.comparer = comparer;
			buckets = new int[7];
			slots = new Slot[7];
			freeList = -1;
		}

		internal bool Add(TKey key, TValue value)
		{
			return !Find(key, add: true, set: false, ref value);
		}

		internal bool TryGetValue(TKey key, ref TValue value)
		{
			return Find(key, add: false, set: false, ref value);
		}

		private int GetKeyHashCode(TKey key)
		{
			return 0x7FFFFFFF & ((comparer != null) ? comparer.GetHashCode(key) : (key?.GetHashCode() ?? 0));
		}

		private bool AreKeysEqual(TKey key1, TKey key2)
		{
			if (comparer != null)
			{
				return comparer.Equals(key1, key2);
			}
			if (key1 != null || key2 != null)
			{
				return key1?.Equals(key2) ?? false;
			}
			return true;
		}

		private bool Find(TKey key, bool add, bool set, ref TValue value)
		{
			int keyHashCode = GetKeyHashCode(key);
			for (int num = buckets[keyHashCode % buckets.Length] - 1; num >= 0; num = slots[num].next)
			{
				if (slots[num].hashCode == keyHashCode && AreKeysEqual(slots[num].key, key))
				{
					if (set)
					{
						slots[num].value = value;
						return true;
					}
					value = slots[num].value;
					return true;
				}
			}
			if (add)
			{
				int num2;
				if (freeList >= 0)
				{
					num2 = freeList;
					freeList = slots[num2].next;
				}
				else
				{
					if (count == slots.Length)
					{
						Resize();
					}
					num2 = count;
					count++;
				}
				int num3 = keyHashCode % buckets.Length;
				slots[num2].hashCode = keyHashCode;
				slots[num2].key = key;
				slots[num2].value = value;
				slots[num2].next = buckets[num3] - 1;
				buckets[num3] = num2 + 1;
			}
			return false;
		}

		private void Resize()
		{
			int num = checked(count * 2 + 1);
			int[] array = new int[num];
			Slot[] array2 = new Slot[num];
			Array.Copy(slots, 0, array2, 0, count);
			for (int i = 0; i < count; i++)
			{
				int num2 = array2[i].hashCode % num;
				array2[i].next = array[num2] - 1;
				array[num2] = i + 1;
			}
			buckets = array;
			slots = array2;
		}
	}
	internal class IntValueEvent : ManualResetEventSlim
	{
		internal int Value;

		internal IntValueEvent()
			: base(initialState: false)
		{
			Value = 0;
		}

		internal void Set(int index)
		{
			Value = index;
			Set();
		}
	}
	internal class ListChunk<TInputOutput> : IEnumerable<TInputOutput>, IEnumerable
	{
		internal TInputOutput[] _chunk;

		private int _chunkCount;

		private ListChunk<TInputOutput> _nextChunk;

		private ListChunk<TInputOutput> _tailChunk;

		internal ListChunk<TInputOutput> Next => _nextChunk;

		internal int Count => _chunkCount;

		internal ListChunk(int size)
		{
			_chunk = new TInputOutput[size];
			_chunkCount = 0;
			_tailChunk = this;
		}

		internal void Add(TInputOutput e)
		{
			ListChunk<TInputOutput> listChunk = _tailChunk;
			if (listChunk._chunkCount == listChunk._chunk.Length)
			{
				_tailChunk = new ListChunk<TInputOutput>(listChunk._chunkCount * 2);
				listChunk = (listChunk._nextChunk = _tailChunk);
			}
			listChunk._chunk[listChunk._chunkCount++] = e;
		}

		public IEnumerator<TInputOutput> GetEnumerator()
		{
			for (ListChunk<TInputOutput> curr = this; curr != null; curr = curr._nextChunk)
			{
				for (int i = 0; i < curr._chunkCount; i++)
				{
					yield return curr._chunk[i];
				}
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<TInputOutput>)this).GetEnumerator();
		}
	}
	internal class Lookup<TKey, TElement> : ILookup<TKey, TElement>, IEnumerable<IGrouping<TKey, TElement>>, IEnumerable
	{
		private IDictionary<TKey, IGrouping<TKey, TElement>> _dict;

		private IEqualityComparer<TKey> _comparer;

		private IGrouping<TKey, TElement> _defaultKeyGrouping;

		public int Count
		{
			get
			{
				int num = _dict.Count;
				if (_defaultKeyGrouping != null)
				{
					num++;
				}
				return num;
			}
		}

		public IEnumerable<TElement> this[TKey key]
		{
			get
			{
				if (_comparer.Equals(key, default(TKey)))
				{
					if (_defaultKeyGrouping != null)
					{
						return _defaultKeyGrouping;
					}
					return Enumerable.Empty<TElement>();
				}
				if (_dict.TryGetValue(key, out var value))
				{
					return value;
				}
				return Enumerable.Empty<TElement>();
			}
		}

		internal Lookup(IEqualityComparer<TKey> comparer)
		{
			_comparer = comparer;
			_dict = new Dictionary<TKey, IGrouping<TKey, TElement>>(_comparer);
		}

		public bool Contains(TKey key)
		{
			if (_comparer.Equals(key, default(TKey)))
			{
				return _defaultKeyGrouping != null;
			}
			return _dict.ContainsKey(key);
		}

		internal void Add(IGrouping<TKey, TElement> grouping)
		{
			if (_comparer.Equals(grouping.Key, default(TKey)))
			{
				_defaultKeyGrouping = grouping;
			}
			else
			{
				_dict.Add(grouping.Key, grouping);
			}
		}

		public IEnumerator<IGrouping<TKey, TElement>> GetEnumerator()
		{
			foreach (IGrouping<TKey, TElement> value in _dict.Values)
			{
				yield return value;
			}
			if (_defaultKeyGrouping != null)
			{
				yield return _defaultKeyGrouping;
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable<IGrouping<TKey, TElement>>)this).GetEnumerator();
		}
	}
	[EventSource(Name = "System.Linq.Parallel.PlinqEventSource", Guid = "159eeeec-4a14-4418-a8fe-faabcd987887")]
	internal sealed class PlinqEtwProvider : EventSource
	{
		public class Tasks
		{
			public const EventTask Query = (EventTask)1;

			public const EventTask ForkJoin = (EventTask)2;
		}

		internal static PlinqEtwProvider Log = new PlinqEtwProvider();

		private static readonly int s_defaultSchedulerId = TaskScheduler.Default.Id;

		private static int s_queryId = 0;

		private const EventKeywords ALL_KEYWORDS = EventKeywords.All;

		private const int PARALLELQUERYBEGIN_EVENTID = 1;

		private const int PARALLELQUERYEND_EVENTID = 2;

		private const int PARALLELQUERYFORK_EVENTID = 3;

		private const int PARALLELQUERYJOIN_EVENTID = 4;

		private PlinqEtwProvider()
		{
		}

		[NonEvent]
		internal static int NextQueryId()
		{
			return Interlocked.Increment(ref s_queryId);
		}

		[NonEvent]
		internal void ParallelQueryBegin(int queryId)
		{
			if (IsEnabled(EventLevel.Informational, EventKeywords.All))
			{
				int valueOrDefault = Task.CurrentId.GetValueOrDefault();
				ParallelQueryBegin(s_defaultSchedulerId, valueOrDefault, queryId);
			}
		}

		[Event(1, Level = EventLevel.Informational, Task = (EventTask)1, Opcode = EventOpcode.Start)]
		private void ParallelQueryBegin(int taskSchedulerId, int taskId, int queryId)
		{
			WriteEvent(1, taskSchedulerId, taskId, queryId);
		}

		[NonEvent]
		internal void ParallelQueryEnd(int queryId)
		{
			if (IsEnabled(EventLevel.Informational, EventKeywords.All))
			{
				int valueOrDefault = Task.CurrentId.GetValueOrDefault();
				ParallelQueryEnd(s_defaultSchedulerId, valueOrDefault, queryId);
			}
		}

		[Event(2, Level = EventLevel.Informational, Task = (EventTask)1, Opcode = EventOpcode.Stop)]
		private void ParallelQueryEnd(int taskSchedulerId, int taskId, int queryId)
		{
			WriteEvent(2, taskSchedulerId, taskId, queryId);
		}

		[NonEvent]
		internal void ParallelQueryFork(int queryId)
		{
			if (IsEnabled(EventLevel.Verbose, EventKeywords.All))
			{
				int valueOrDefault = Task.CurrentId.GetValueOrDefault();
				ParallelQueryFork(s_defaultSchedulerId, valueOrDefault, queryId);
			}
		}

		[Event(3, Level = EventLevel.Verbose, Task = (EventTask)2, Opcode = EventOpcode.Start)]
		private void ParallelQueryFork(int taskSchedulerId, int taskId, int queryId)
		{
			WriteEvent(3, taskSchedulerId, taskId, queryId);
		}

		[NonEvent]
		internal void ParallelQueryJoin(int queryId)
		{
			if (IsEnabled(EventLevel.Verbose, EventKeywords.All))
			{
				int valueOrDefault = Task.CurrentId.GetValueOrDefault();
				ParallelQueryJoin(s_defaultSchedulerId, valueOrDefault, queryId);
			}
		}

		[Event(4, Level = EventLevel.Verbose, Task = (EventTask)2, Opcode = EventOpcode.Stop)]
		private void ParallelQueryJoin(int taskSchedulerId, int taskId, int queryId)
		{
			WriteEvent(4, taskSchedulerId, taskId, queryId);
		}
	}
	internal struct Pair<T, U>
	{
		internal T _first;

		internal U _second;

		public T First
		{
			get
			{
				return _first;
			}
			set
			{
				_first = value;
			}
		}

		public U Second
		{
			get
			{
				return _second;
			}
			set
			{
				_second = value;
			}
		}

		public Pair(T first, U second)
		{
			_first = first;
			_second = second;
		}
	}
	internal sealed class PairComparer<T, U> : IComparer<Pair<T, U>>
	{
		private readonly IComparer<T> _comparer1;

		private readonly IComparer<U> _comparer2;

		public PairComparer(IComparer<T> comparer1, IComparer<U> comparer2)
		{
			_comparer1 = comparer1;
			_comparer2 = comparer2;
		}

		public int Compare(Pair<T, U> x, Pair<T, U> y)
		{
			int num = _comparer1.Compare(x.First, y.First);
			if (num != 0)
			{
				return num;
			}
			return _comparer2.Compare(x.Second, y.Second);
		}
	}
	internal class ReverseComparer<T> : IComparer<T>
	{
		private IComparer<T> _comparer;

		internal ReverseComparer(IComparer<T> comparer)
		{
			_comparer = comparer;
		}

		public int Compare(T x, T y)
		{
			return _comparer.Compare(y, x);
		}
	}
	internal class Shared<T>
	{
		internal T Value;

		internal Shared(T value)
		{
			Value = value;
		}
	}
	internal abstract class SortHelper<TInputOutput>
	{
		internal abstract TInputOutput[] Sort();
	}
	internal class SortHelper<TInputOutput, TKey> : SortHelper<TInputOutput>, IDisposable
	{
		private QueryOperatorEnumerator<TInputOutput, TKey> _source;

		private int _partitionCount;

		private int _partitionIndex;

		private QueryTaskGroupState _groupState;

		private int[][] _sharedIndices;

		private GrowingArray<TKey>[] _sharedKeys;

		private TInputOutput[][] _sharedValues;

		private Barrier[][] _sharedBarriers;

		private OrdinalIndexState _indexState;

		private IComparer<TKey> _keyComparer;

		private SortHelper(QueryOperatorEnumerator<TInputOutput, TKey> source, int partitionCount, int partitionIndex, QueryTaskGroupState groupState, int[][] sharedIndices, OrdinalIndexState indexState, IComparer<TKey> keyComparer, GrowingArray<TKey>[] sharedkeys, TInputOutput[][] sharedValues, Barrier[][] sharedBarriers)
		{
			_source = source;
			_partitionCount = partitionCount;
			_partitionIndex = partitionIndex;
			_groupState = groupState;
			_sharedIndices = sharedIndices;
			_indexState = indexState;
			_keyComparer = keyComparer;
			_sharedKeys = sharedkeys;
			_sharedValues = sharedValues;
			_sharedBarriers = sharedBarriers;
		}

		internal static SortHelper<TInputOutput, TKey>[] GenerateSortHelpers(PartitionedStream<TInputOutput, TKey> partitions, QueryTaskGroupState groupState)
		{
			int partitionCount = partitions.PartitionCount;
			SortHelper<TInputOutput, TKey>[] array = new SortHelper<TInputOutput, TKey>[partitionCount];
			int num = 1;
			int num2 = 0;
			while (num < partitionCount)
			{
				num2++;
				num <<= 1;
			}
			int[][] sharedIndices = new int[partitionCount][];
			GrowingArray<TKey>[] sharedkeys = new GrowingArray<TKey>[partitionCount];
			TInputOutput[][] sharedValues = new TInputOutput[partitionCount][];
			Barrier[][] array2 = JaggedArray<Barrier>.Allocate(num2, partitionCount);
			if (partitionCount > 1)
			{
				int num3 = 1;
				for (int i = 0; i < array2.Length; i++)
				{
					for (int j = 0; j < array2[i].Length; j++)
					{
						if (j % num3 == 0)
						{
							array2[i][j] = new Barrier(2);
						}
					}
					num3 *= 2;
				}
			}
			for (int k = 0; k < partitionCount; k++)
			{
				array[k] = new SortHelper<TInputOutput, TKey>(partitions[k], partitionCount, k, groupState, sharedIndices, partitions.OrdinalIndexState, partitions.KeyComparer, sharedkeys, sharedValues, array2);
			}
			return array;
		}

		public void Dispose()
		{
			if (_partitionIndex != 0)
			{
				return;
			}
			for (int i = 0; i < _sharedBarriers.Length; i++)
			{
				for (int j = 0; j < _sharedBarriers[i].Length; j++)
				{
					_sharedBarriers[i][j]?.Dispose();
				}
			}
		}

		internal override TInputOutput[] Sort()
		{
			GrowingArray<TKey> keys = null;
			List<TInputOutput> values = null;
			BuildKeysFromSource(ref keys, ref values);
			QuickSortIndicesInPlace(keys, values, _indexState);
			if (_partitionCount > 1)
			{
				MergeSortCooperatively();
			}
			return _sharedValues[_partitionIndex];
		}

		private void BuildKeysFromSource(ref GrowingArray<TKey> keys, ref List<TInputOutput> values)
		{
			values = new List<TInputOutput>();
			CancellationToken mergedCancellationToken = _groupState.CancellationState.MergedCancellationToken;
			try
			{
				TInputOutput currentElement = default(TInputOutput);
				TKey currentKey = default(TKey);
				bool num = _source.MoveNext(ref currentElement, ref currentKey);
				if (keys == null)
				{
					keys = new GrowingArray<TKey>();
				}
				if (!num)
				{
					return;
				}
				int num2 = 0;
				do
				{
					if ((num2++ & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(mergedCancellationToken);
					}
					keys.Add(currentKey);
					values.Add(currentElement);
				}
				while (_source.MoveNext(ref currentElement, ref currentKey));
			}
			finally
			{
				_source.Dispose();
			}
		}

		private void QuickSortIndicesInPlace(GrowingArray<TKey> keys, List<TInputOutput> values, OrdinalIndexState ordinalIndexState)
		{
			int[] array = new int[values.Count];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = i;
			}
			if (array.Length > 1 && ordinalIndexState.IsWorseThan(OrdinalIndexState.Increasing))
			{
				QuickSort(0, array.Length - 1, keys.InternalArray, array, _groupState.CancellationState.MergedCancellationToken);
			}
			if (_partitionCount == 1)
			{
				TInputOutput[] array2 = new TInputOutput[values.Count];
				for (int j = 0; j < array.Length; j++)
				{
					array2[j] = values[array[j]];
				}
				_sharedValues[_partitionIndex] = array2;
			}
			else
			{
				_sharedIndices[_partitionIndex] = array;
				_sharedKeys[_partitionIndex] = keys;
				_sharedValues[_partitionIndex] = new TInputOutput[values.Count];
				values.CopyTo(_sharedValues[_partitionIndex]);
			}
		}

		private void MergeSortCooperatively()
		{
			CancellationToken mergedCancellationToken = _groupState.CancellationState.MergedCancellationToken;
			int num = _sharedBarriers.Length;
			for (int i = 0; i < num; i++)
			{
				bool flag = i == num - 1;
				int num2 = ComputePartnerIndex(i);
				if (num2 >= _partitionCount)
				{
					continue;
				}
				int[] array = _sharedIndices[_partitionIndex];
				GrowingArray<TKey> growingArray = _sharedKeys[_partitionIndex];
				TKey[] internalArray = growingArray.InternalArray;
				TInputOutput[] array2 = _sharedValues[_partitionIndex];
				_sharedBarriers[i][Math.Min(_partitionIndex, num2)].SignalAndWait(mergedCancellationToken);
				if (_partitionIndex < num2)
				{
					int[] array3 = _sharedIndices[num2];
					TKey[] internalArray2 = _sharedKeys[num2].InternalArray;
					TInputOutput[] array4 = _sharedValues[num2];
					_sharedIndices[num2] = array;
					_sharedKeys[num2] = growingArray;
					_sharedValues[num2] = array2;
					int num3 = array2.Length;
					int num4 = array4.Length;
					int num5 = num3 + num4;
					int[] array5 = null;
					TInputOutput[] array6 = new TInputOutput[num5];
					if (!flag)
					{
						array5 = new int[num5];
					}
					_sharedIndices[_partitionIndex] = array5;
					_sharedKeys[_partitionIndex] = growingArray;
					_sharedValues[_partitionIndex] = array6;
					_sharedBarriers[i][_partitionIndex].SignalAndWait(mergedCancellationToken);
					int num6 = (num5 + 1) / 2;
					int j = 0;
					int num7 = 0;
					int num8 = 0;
					for (; j < num6; j++)
					{
						if ((j & 0x3F) == 0)
						{
							CancellationState.ThrowIfCanceled(mergedCancellationToken);
						}
						if (num7 < num3 && (num8 >= num4 || _keyComparer.Compare(internalArray[array[num7]], internalArray2[array3[num8]]) <= 0))
						{
							if (flag)
							{
								array6[j] = array2[array[num7]];
							}
							else
							{
								array5[j] = array[num7];
							}
							num7++;
						}
						else
						{
							if (flag)
							{
								array6[j] = array4[array3[num8]];
							}
							else
							{
								array5[j] = num3 + array3[num8];
							}
							num8++;
						}
					}
					if (!flag && num3 > 0)
					{
						Array.Copy(array2, 0, array6, 0, num3);
					}
					_sharedBarriers[i][_partitionIndex].SignalAndWait(mergedCancellationToken);
					continue;
				}
				_sharedBarriers[i][num2].SignalAndWait(mergedCancellationToken);
				int[] array7 = _sharedIndices[_partitionIndex];
				TKey[] internalArray3 = _sharedKeys[_partitionIndex].InternalArray;
				TInputOutput[] array8 = _sharedValues[_partitionIndex];
				int[] array9 = _sharedIndices[num2];
				GrowingArray<TKey> growingArray2 = _sharedKeys[num2];
				TInputOutput[] array10 = _sharedValues[num2];
				int num9 = array8.Length;
				int num10 = array2.Length;
				int num11 = num9 + num10;
				int num12 = (num11 + 1) / 2;
				int num13 = num11 - 1;
				int num14 = num9 - 1;
				int num15 = num10 - 1;
				while (num13 >= num12)
				{
					if ((num13 & 0x3F) == 0)
					{
						CancellationState.ThrowIfCanceled(mergedCancellationToken);
					}
					if (num14 >= 0 && (num15 < 0 || _keyComparer.Compare(internalArray3[array7[num14]], internalArray[array[num15]]) > 0))
					{
						if (flag)
						{
							array10[num13] = array8[array7[num14]];
						}
						else
						{
							array9[num13] = array7[num14];
						}
						num14--;
					}
					else
					{
						if (flag)
						{
							array10[num13] = array2[array[num15]];
						}
						else
						{
							array9[num13] = num9 + array[num15];
						}
						num15--;
					}
					num13--;
				}
				if (!flag && array2.Length != 0)
				{
					growingArray2.CopyFrom(internalArray, array2.Length);
					Array.Copy(array2, 0, array10, num9, array2.Length);
				}
				_sharedBarriers[i][num2].SignalAndWait(mergedCancellationToken);
				break;
			}
		}

		private int ComputePartnerIndex(int phase)
		{
			int num = 1 << phase;
			return _partitionIndex + ((_partitionIndex % (num * 2) == 0) ? num : (-num));
		}

		private void QuickSort(int left, int right, TKey[] keys, int[] indices, CancellationToken cancelToken)
		{
			if (right - left > 63)
			{
				CancellationState.ThrowIfCanceled(cancelToken);
			}
			do
			{
				int num = left;
				int num2 = right;
				int num3 = indices[num + (num2 - num >> 1)];
				TKey y = keys[num3];
				while (true)
				{
					if (_keyComparer.Compare(keys[indices[num]], y) < 0)
					{
						num++;
						continue;
					}
					while (_keyComparer.Compare(keys[indices[num2]], y) > 0)
					{
						num2--;
					}
					if (num > num2)
					{
						break;
					}
					if (num < num2)
					{
						int num4 = indices[num];
						indices[num] = indices[num2];
						indices[num2] = num4;
					}
					num++;
					num2--;
					if (num > num2)
					{
						break;
					}
				}
				if (num2 - left <= right - num)
				{
					if (left < num2)
					{
						QuickSort(left, num2, keys, indices, cancelToken);
					}
					left = num;
				}
				else
				{
					if (num < right)
					{
						QuickSort(num, right, keys, indices, cancelToken);
					}
					right = num2;
				}
			}
			while (left < right);
		}
	}
	internal static class TraceHelpers
	{
		[Conditional("PFXTRACE")]
		internal static void TraceInfo(string msg, params object[] args)
		{
		}
	}
	internal static class Util
	{
		private class FastIntComparer : Comparer<int>
		{
			public override int Compare(int x, int y)
			{
				return x.CompareTo(y);
			}
		}

		private class FastLongComparer : Comparer<long>
		{
			public override int Compare(long x, long y)
			{
				return x.CompareTo(y);
			}
		}

		private class FastFloatComparer : Comparer<float>
		{
			public override int Compare(float x, float y)
			{
				return x.CompareTo(y);
			}
		}

		private class FastDoubleComparer : Comparer<double>
		{
			public override int Compare(double x, double y)
			{
				return x.CompareTo(y);
			}
		}

		private class FastDateTimeComparer : Comparer<DateTime>
		{
			public override int Compare(DateTime x, DateTime y)
			{
				return x.CompareTo(y);
			}
		}

		private static FastIntComparer s_fastIntComparer = new FastIntComparer();

		private static FastLongComparer s_fastLongComparer = new FastLongComparer();

		private static FastFloatComparer s_fastFloatComparer = new FastFloatComparer();

		private static FastDoubleComparer s_fastDoubleComparer = new FastDoubleComparer();

		private static FastDateTimeComparer s_fastDateTimeComparer = new FastDateTimeComparer();

		internal static int Sign(int x)
		{
			if (x >= 0)
			{
				if (x != 0)
				{
					return 1;
				}
				return 0;
			}
			return -1;
		}

		internal static Comparer<TKey> GetDefaultComparer<TKey>()
		{
			if (typeof(TKey) == typeof(int))
			{
				return (Comparer<TKey>)(object)s_fastIntComparer;
			}
			if (typeof(TKey) == typeof(long))
			{
				return (Comparer<TKey>)(object)s_fastLongComparer;
			}
			if (typeof(TKey) == typeof(float))
			{
				return (Comparer<TKey>)(object)s_fastFloatComparer;
			}
			if (typeof(TKey) == typeof(double))
			{
				return (Comparer<TKey>)(object)s_fastDoubleComparer;
			}
			if (typeof(TKey) == typeof(DateTime))
			{
				return (Comparer<TKey>)(object)s_fastDateTimeComparer;
			}
			return Comparer<TKey>.Default;
		}
	}
	internal struct Wrapper<T>
	{
		internal T Value;

		internal Wrapper(T value)
		{
			Value = value;
		}
	}
	internal struct WrapperEqualityComparer<T> : IEqualityComparer<Wrapper<T>>
	{
		private IEqualityComparer<T> _comparer;

		internal WrapperEqualityComparer(IEqualityComparer<T> comparer)
		{
			if (comparer == null)
			{
				_comparer = EqualityComparer<T>.Default;
			}
			else
			{
				_comparer = comparer;
			}
		}

		public bool Equals(Wrapper<T> x, Wrapper<T> y)
		{
			return _comparer.Equals(x.Value, y.Value);
		}

		public int GetHashCode(Wrapper<T> x)
		{
			return _comparer.GetHashCode(x.Value);
		}
	}
}
namespace System.Linq.Expressions
{
	internal static class CachedReflectionInfo
	{
		private static MethodInfo s_String_Format_String_ObjectArray;

		private static ConstructorInfo s_InvalidCastException_Ctor_String;

		private static MethodInfo s_CallSiteOps_SetNotMatched;

		private static MethodInfo s_CallSiteOps_CreateMatchmaker;

		private static MethodInfo s_CallSiteOps_GetMatch;

		private static MethodInfo s_CallSiteOps_ClearMatch;

		private static MethodInfo s_CallSiteOps_UpdateRules;

		private static MethodInfo s_CallSiteOps_GetRules;

		private static MethodInfo s_CallSiteOps_GetRuleCache;

		private static MethodInfo s_CallSiteOps_GetCachedRules;

		private static MethodInfo s_CallSiteOps_AddRule;

		private static MethodInfo s_CallSiteOps_MoveRule;

		private static MethodInfo s_CallSiteOps_Bind;

		private static MethodInfo s_DynamicObject_TryGetMember;

		private static MethodInfo s_DynamicObject_TrySetMember;

		private static MethodInfo s_DynamicObject_TryDeleteMember;

		private static MethodInfo s_DynamicObject_TryGetIndex;

		private static MethodInfo s_DynamicObject_TrySetIndex;

		private static MethodInfo s_DynamicObject_TryDeleteIndex;

		private static MethodInfo s_DynamicObject_TryConvert;

		private static MethodInfo s_DynamicObject_TryInvoke;

		private static MethodInfo s_DynamicObject_TryInvokeMember;

		private static MethodInfo s_DynamicObject_TryBinaryOperation;

		private static MethodInfo s_DynamicObject_TryUnaryOperation;

		private static MethodInfo s_DynamicObject_TryCreateInstance;

		private static ConstructorInfo s_Nullable_Boolean_Ctor;

		private static ConstructorInfo s_Decimal_Ctor_Int32;

		private static ConstructorInfo s_Decimal_Ctor_UInt32;

		private static ConstructorInfo s_Decimal_Ctor_Int64;

		private static ConstructorInfo s_Decimal_Ctor_UInt64;

		private static ConstructorInfo s_Decimal_Ctor_Int32_Int32_Int32_Bool_Byte;

		private static FieldInfo s_Decimal_One;

		private static FieldInfo s_Decimal_MinusOne;

		private static FieldInfo s_Decimal_MinValue;

		private static FieldInfo s_Decimal_MaxValue;

		private static FieldInfo s_Decimal_Zero;

		private static FieldInfo s_DateTime_MinValue;

		private static MethodInfo s_MethodBase_GetMethodFromHandle_RuntimeMethodHandle;

		private static MethodInfo s_MethodBase_GetMethodFromHandle_RuntimeMethodHandle_RuntimeTypeHandle;

		private static MethodInfo s_MethodInfo_CreateDelegate_Type_Object;

		private static MethodInfo s_String_op_Equality_String_String;

		private static MethodInfo s_String_Equals_String_String;

		private static MethodInfo s_DictionaryOfStringInt32_Add_String_Int32;

		private static ConstructorInfo s_DictionaryOfStringInt32_Ctor_Int32;

		private static MethodInfo s_Type_GetTypeFromHandle;

		private static MethodInfo s_Object_GetType;

		private static MethodInfo s_Decimal_op_Implicit_Byte;

		private static MethodInfo s_Decimal_op_Implicit_SByte;

		private static MethodInfo s_Decimal_op_Implicit_Int16;

		private static MethodInfo s_Decimal_op_Implicit_UInt16;

		private static MethodInfo s_Decimal_op_Implicit_Int32;

		private static MethodInfo s_Decimal_op_Implicit_UInt32;

		private static MethodInfo s_Decimal_op_Implicit_Int64;

		private static MethodInfo s_Decimal_op_Implicit_UInt64;

		private static MethodInfo s_Decimal_op_Implicit_Char;

		private static MethodInfo s_Math_Pow_Double_Double;

		private static ConstructorInfo s_Closure_ObjectArray_ObjectArray;

		private static FieldInfo s_Closure_Constants;

		private static FieldInfo s_Closure_Locals;

		private static MethodInfo s_RuntimeOps_CreateRuntimeVariables_ObjectArray_Int64Array;

		private static MethodInfo s_RuntimeOps_CreateRuntimeVariables;

		private static MethodInfo s_RuntimeOps_MergeRuntimeVariables;

		private static MethodInfo s_RuntimeOps_Quote;

		public static MethodInfo String_Format_String_ObjectArray => s_String_Format_String_ObjectArray ?? (s_String_Format_String_ObjectArray = typeof(string).GetMethod("Format", new Type[2]
		{
			typeof(string),
			typeof(object[])
		}));

		public static ConstructorInfo InvalidCastException_Ctor_String => s_InvalidCastException_Ctor_String ?? (s_InvalidCastException_Ctor_String = typeof(InvalidCastException).GetConstructor(new Type[1] { typeof(string) }));

		public static MethodInfo CallSiteOps_SetNotMatched => s_CallSiteOps_SetNotMatched ?? (s_CallSiteOps_SetNotMatched = typeof(CallSiteOps).GetMethod("SetNotMatched"));

		public static MethodInfo CallSiteOps_CreateMatchmaker => s_CallSiteOps_CreateMatchmaker ?? (s_CallSiteOps_CreateMatchmaker = typeof(CallSiteOps).GetMethod("CreateMatchmaker"));

		public static MethodInfo CallSiteOps_GetMatch => s_CallSiteOps_GetMatch ?? (s_CallSiteOps_GetMatch = typeof(CallSiteOps).GetMethod("GetMatch"));

		public static MethodInfo CallSiteOps_ClearMatch => s_CallSiteOps_ClearMatch ?? (s_CallSiteOps_ClearMatch = typeof(CallSiteOps).GetMethod("ClearMatch"));

		public static MethodInfo CallSiteOps_UpdateRules => s_CallSiteOps_UpdateRules ?? (s_CallSiteOps_UpdateRules = typeof(CallSiteOps).GetMethod("UpdateRules"));

		public static MethodInfo CallSiteOps_GetRules => s_CallSiteOps_GetRules ?? (s_CallSiteOps_GetRules = typeof(CallSiteOps).GetMethod("GetRules"));

		public static MethodInfo CallSiteOps_GetRuleCache => s_CallSiteOps_GetRuleCache ?? (s_CallSiteOps_GetRuleCache = typeof(CallSiteOps).GetMethod("GetRuleCache"));

		public static MethodInfo CallSiteOps_GetCachedRules => s_CallSiteOps_GetCachedRules ?? (s_CallSiteOps_GetCachedRules = typeof(CallSiteOps).GetMethod("GetCachedRules"));

		public static MethodInfo CallSiteOps_AddRule => s_CallSiteOps_AddRule ?? (s_CallSiteOps_AddRule = typeof(CallSiteOps).GetMethod("AddRule"));

		public static MethodInfo CallSiteOps_MoveRule => s_CallSiteOps_MoveRule ?? (s_CallSiteOps_MoveRule = typeof(CallSiteOps).GetMethod("MoveRule"));

		public static MethodInfo CallSiteOps_Bind => s_CallSiteOps_Bind ?? (s_CallSiteOps_Bind = typeof(CallSiteOps).GetMethod("Bind"));

		public static MethodInfo DynamicObject_TryGetMember => s_DynamicObject_TryGetMember ?? (s_DynamicObject_TryGetMember = typeof(DynamicObject).GetMethod("TryGetMember"));

		public static MethodInfo DynamicObject_TrySetMember => s_DynamicObject_TrySetMember ?? (s_DynamicObject_TrySetMember = typeof(DynamicObject).GetMethod("TrySetMember"));

		public static MethodInfo DynamicObject_TryDeleteMember => s_DynamicObject_TryDeleteMember ?? (s_DynamicObject_TryDeleteMember = typeof(DynamicObject).GetMethod("TryDeleteMember"));

		public static MethodInfo DynamicObject_TryGetIndex => s_DynamicObject_TryGetIndex ?? (s_DynamicObject_TryGetIndex = typeof(DynamicObject).GetMethod("TryGetIndex"));

		public static MethodInfo DynamicObject_TrySetIndex => s_DynamicObject_TrySetIndex ?? (s_DynamicObject_TrySetIndex = typeof(DynamicObject).GetMethod("TrySetIndex"));

		public static MethodInfo DynamicObject_TryDeleteIndex => s_DynamicObject_TryDeleteIndex ?? (s_DynamicObject_TryDeleteIndex = typeof(DynamicObject).GetMethod("TryDeleteIndex"));

		public static MethodInfo DynamicObject_TryConvert => s_DynamicObject_TryConvert ?? (s_DynamicObject_TryConvert = typeof(DynamicObject).GetMethod("TryConvert"));

		public static MethodInfo DynamicObject_TryInvoke => s_DynamicObject_TryInvoke ?? (s_DynamicObject_TryInvoke = typeof(DynamicObject).GetMethod("TryInvoke"));

		public static MethodInfo DynamicObject_TryInvokeMember => s_DynamicObject_TryInvokeMember ?? (s_DynamicObject_TryInvokeMember = typeof(DynamicObject).GetMethod("TryInvokeMember"));

		public static MethodInfo DynamicObject_TryBinaryOperation => s_DynamicObject_TryBinaryOperation ?? (s_DynamicObject_TryBinaryOperation = typeof(DynamicObject).GetMethod("TryBinaryOperation"));

		public static MethodInfo DynamicObject_TryUnaryOperation => s_DynamicObject_TryUnaryOperation ?? (s_DynamicObject_TryUnaryOperation = typeof(DynamicObject).GetMethod("TryUnaryOperation"));

		public static MethodInfo DynamicObject_TryCreateInstance => s_DynamicObject_TryCreateInstance ?? (s_DynamicObject_TryCreateInstance = typeof(DynamicObject).GetMethod("TryCreateInstance"));

		public static ConstructorInfo Nullable_Boolean_Ctor => s_Nullable_Boolean_Ctor ?? (s_Nullable_Boolean_Ctor = typeof(bool?).GetConstructor(new Type[1] { typeof(bool) }));

		public static ConstructorInfo Decimal_Ctor_Int32 => s_Decimal_Ctor_Int32 ?? (s_Decimal_Ctor_Int32 = typeof(decimal).GetConstructor(new Type[1] { typeof(int) }));

		public static ConstructorInfo Decimal_Ctor_UInt32 => s_Decimal_Ctor_UInt32 ?? (s_Decimal_Ctor_UInt32 = typeof(decimal).GetConstructor(new Type[1] { typeof(uint) }));

		public static ConstructorInfo Decimal_Ctor_Int64 => s_Decimal_Ctor_Int64 ?? (s_Decimal_Ctor_Int64 = typeof(decimal).GetConstructor(new Type[1] { typeof(long) }));

		public static ConstructorInfo Decimal_Ctor_UInt64 => s_Decimal_Ctor_UInt64 ?? (s_Decimal_Ctor_UInt64 = typeof(decimal).GetConstructor(new Type[1] { typeof(ulong) }));

		public static ConstructorInfo Decimal_Ctor_Int32_Int32_Int32_Bool_Byte => s_Decimal_Ctor_Int32_Int32_Int32_Bool_Byte ?? (s_Decimal_Ctor_Int32_Int32_Int32_Bool_Byte = typeof(decimal).GetConstructor(new Type[5]
		{
			typeof(int),
			typeof(int),
			typeof(int),
			typeof(bool),
			typeof(byte)
		}));

		public static FieldInfo Decimal_One => s_Decimal_One ?? (s_Decimal_One = typeof(decimal).GetField("One"));

		public static FieldInfo Decimal_MinusOne => s_Decimal_MinusOne ?? (s_Decimal_MinusOne = typeof(decimal).GetField("MinusOne"));

		public static FieldInfo Decimal_MinValue => s_Decimal_MinValue ?? (s_Decimal_MinValue = typeof(decimal).GetField("MinValue"));

		public static FieldInfo Decimal_MaxValue => s_Decimal_MaxValue ?? (s_Decimal_MaxValue = typeof(decimal).GetField("MaxValue"));

		public static FieldInfo Decimal_Zero => s_Decimal_Zero ?? (s_Decimal_Zero = typeof(decimal).GetField("Zero"));

		public static FieldInfo DateTime_MinValue => s_DateTime_MinValue ?? (s_DateTime_MinValue = typeof(DateTime).GetField("MinValue"));

		public static MethodInfo MethodBase_GetMethodFromHandle_RuntimeMethodHandle => s_MethodBase_GetMethodFromHandle_RuntimeMethodHandle ?? (s_MethodBase_GetMethodFromHandle_RuntimeMethodHandle = typeof(MethodBase).GetMethod("GetMethodFromHandle", new Type[1] { typeof(RuntimeMethodHandle) }));

		public static MethodInfo MethodBase_GetMethodFromHandle_RuntimeMethodHandle_RuntimeTypeHandle => s_MethodBase_GetMethodFromHandle_RuntimeMethodHandle_RuntimeTypeHandle ?? (s_MethodBase_GetMethodFromHandle_RuntimeMethodHandle_RuntimeTypeHandle = typeof(MethodBase).GetMethod("GetMethodFromHandle", new Type[2]
		{
			typeof(RuntimeMethodHandle),
			typeof(RuntimeTypeHandle)
		}));

		public static MethodInfo MethodInfo_CreateDelegate_Type_Object => s_MethodInfo_CreateDelegate_Type_Object ?? (s_MethodInfo_CreateDelegate_Type_Object = typeof(MethodInfo).GetMethod("CreateDelegate", new Type[2]
		{
			typeof(Type),
			typeof(object)
		}));

		public static MethodInfo String_op_Equality_String_String => s_String_op_Equality_String_String ?? (s_String_op_Equality_String_String = typeof(string).GetMethod("op_Equality", new Type[2]
		{
			typeof(string),
			typeof(string)
		}));

		public static MethodInfo String_Equals_String_String => s_String_Equals_String_String ?? (s_String_Equals_String_String = typeof(string).GetMethod("Equals", new Type[2]
		{
			typeof(string),
			typeof(string)
		}));

		public static MethodInfo DictionaryOfStringInt32_Add_String_Int32 => s_DictionaryOfStringInt32_Add_String_Int32 ?? (s_DictionaryOfStringInt32_Add_String_Int32 = typeof(Dictionary<string, int>).GetMethod("Add", new Type[2]
		{
			typeof(string),
			typeof(int)
		}));

		public static ConstructorInfo DictionaryOfStringInt32_Ctor_Int32 => s_DictionaryOfStringInt32_Ctor_Int32 ?? (s_DictionaryOfStringInt32_Ctor_Int32 = typeof(Dictionary<string, int>).GetConstructor(new Type[1] { typeof(int) }));

		public static MethodInfo Type_GetTypeFromHandle => s_Type_GetTypeFromHandle ?? (s_Type_GetTypeFromHandle = typeof(Type).GetMethod("GetTypeFromHandle"));

		public static MethodInfo Object_GetType => s_Object_GetType ?? (s_Object_GetType = typeof(object).GetMethod("GetType"));

		public static MethodInfo Decimal_op_Implicit_Byte => s_Decimal_op_Implicit_Byte ?? (s_Decimal_op_Implicit_Byte = typeof(decimal).GetMethod("op_Implicit", new Type[1] { typeof(byte) }));

		public static MethodInfo Decimal_op_Implicit_SByte => s_Decimal_op_Implicit_SByte ?? (s_Decimal_op_Implicit_SByte = typeof(decimal).GetMethod("op_Implicit", new Type[1] { typeof(sbyte) }));

		public static MethodInfo Decimal_op_Implicit_Int16 => s_Decimal_op_Implicit_Int16 ?? (s_Decimal_op_Implicit_Int16 = typeof(decimal).GetMethod("op_Implicit", new Type[1] { typeof(short) }));

		public static MethodInfo Decimal_op_Implicit_UInt16 => s_Decimal_op_Implicit_UInt16 ?? (s_Decimal_op_Implicit_UInt16 = typeof(decimal).GetMethod("op_Implicit", new Type[1] { typeof(ushort) }));

		public static MethodInfo Decimal_op_Implicit_Int32 => s_Decimal_op_Implicit_Int32 ?? (s_Decimal_op_Implicit_Int32 = typeof(decimal).GetMethod("op_Implicit", new Type[1] { typeof(int) }));

		public static MethodInfo Decimal_op_Implicit_UInt32 => s_Decimal_op_Implicit_UInt32 ?? (s_Decimal_op_Implicit_UInt32 = typeof(decimal).GetMethod("op_Implicit", new Type[1] { typeof(uint) }));

		public static MethodInfo Decimal_op_Implicit_Int64 => s_Decimal_op_Implicit_Int64 ?? (s_Decimal_op_Implicit_Int64 = typeof(decimal).GetMethod("op_Implicit", new Type[1] { typeof(long) }));

		public static MethodInfo Decimal_op_Implicit_UInt64 => s_Decimal_op_Implicit_UInt64 ?? (s_Decimal_op_Implicit_UInt64 = typeof(decimal).GetMethod("op_Implicit", new Type[1] { typeof(ulong) }));

		public static MethodInfo Decimal_op_Implicit_Char => s_Decimal_op_Implicit_Char ?? (s_Decimal_op_Implicit_Char = typeof(decimal).GetMethod("op_Implicit", new Type[1] { typeof(char) }));

		public static MethodInfo Math_Pow_Double_Double => s_Math_Pow_Double_Double ?? (s_Math_Pow_Double_Double = typeof(Math).GetMethod("Pow", new Type[2]
		{
			typeof(double),
			typeof(double)
		}));

		public static ConstructorInfo Closure_ObjectArray_ObjectArray => s_Closure_ObjectArray_ObjectArray ?? (s_Closure_ObjectArray_ObjectArray = typeof(Closure).GetConstructor(new Type[2]
		{
			typeof(object[]),
			typeof(object[])
		}));

		public static FieldInfo Closure_Constants => s_Closure_Constants ?? (s_Closure_Constants = typeof(Closure).GetField("Constants"));

		public static FieldInfo Closure_Locals => s_Closure_Locals ?? (s_Closure_Locals = typeof(Closure).GetField("Locals"));

		public static MethodInfo RuntimeOps_CreateRuntimeVariables_ObjectArray_Int64Array => s_RuntimeOps_CreateRuntimeVariables_ObjectArray_Int64Array ?? (s_RuntimeOps_CreateRuntimeVariables_ObjectArray_Int64Array = typeof(RuntimeOps).GetMethod("CreateRuntimeVariables", new Type[2]
		{
			typeof(object[]),
			typeof(long[])
		}));

		public static MethodInfo RuntimeOps_CreateRuntimeVariables => s_RuntimeOps_CreateRuntimeVariables ?? (s_RuntimeOps_CreateRuntimeVariables = typeof(RuntimeOps).GetMethod("CreateRuntimeVariables", Type.EmptyTypes));

		public static MethodInfo RuntimeOps_MergeRuntimeVariables => s_RuntimeOps_MergeRuntimeVariables ?? (s_RuntimeOps_MergeRuntimeVariables = typeof(RuntimeOps).GetMethod("MergeRuntimeVariables"));

		public static MethodInfo RuntimeOps_Quote => s_RuntimeOps_Quote ?? (s_RuntimeOps_Quote = typeof(RuntimeOps).GetMethod("Quote"));
	}
	/// <summary>Represents an expression that has a binary operator.</summary>
	[DebuggerTypeProxy(typeof(BinaryExpressionProxy))]
	public class BinaryExpression : Expression
	{
		/// <summary>Gets a value that indicates whether the expression tree node can be reduced.</summary>
		/// <returns>True if the expression tree node can be reduced, otherwise false.</returns>
		public override bool CanReduce => IsOpAssignment(NodeType);

		/// <summary>Gets the right operand of the binary operation.</summary>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand of the binary operation.</returns>
		public Expression Right { get; }

		/// <summary>Gets the left operand of the binary operation.</summary>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand of the binary operation.</returns>
		public Expression Left { get; }

		/// <summary>Gets the implementing method for the binary operation.</summary>
		/// <returns>The <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</returns>
		public MethodInfo Method => GetMethod();

		/// <summary>Gets the type conversion function that is used by a coalescing or compound assignment operation.</summary>
		/// <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that represents a type conversion function.</returns>
		public LambdaExpression Conversion => GetConversion();

		/// <summary>Gets a value that indicates whether the expression tree node represents a lifted call to an operator.</summary>
		/// <returns>
		///     <see langword="true" /> if the node represents a lifted call; otherwise, <see langword="false" />.</returns>
		public bool IsLifted
		{
			get
			{
				if (NodeType == ExpressionType.Coalesce || NodeType == ExpressionType.Assign)
				{
					return false;
				}
				if (Left.Type.IsNullableType())
				{
					MethodInfo method = GetMethod();
					if (!(method == null))
					{
						return !TypeUtils.AreEquivalent(method.GetParametersCached()[0].ParameterType.GetNonRefType(), Left.Type);
					}
					return true;
				}
				return false;
			}
		}

		/// <summary>Gets a value that indicates whether the expression tree node represents a lifted call to an operator whose return type is lifted to a nullable type.</summary>
		/// <returns>
		///     <see langword="true" /> if the operator's return type is lifted to a nullable type; otherwise, <see langword="false" />.</returns>
		public bool IsLiftedToNull
		{
			get
			{
				if (IsLifted)
				{
					return Type.IsNullableType();
				}
				return false;
			}
		}

		internal bool IsLiftedLogical
		{
			get
			{
				Type type = Left.Type;
				Type type2 = Right.Type;
				MethodInfo method = GetMethod();
				ExpressionType nodeType = NodeType;
				if ((nodeType == ExpressionType.AndAlso || nodeType == ExpressionType.OrElse) && TypeUtils.AreEquivalent(type2, type) && type.IsNullableType() && method != null)
				{
					return TypeUtils.AreEquivalent(method.ReturnType, type.GetNonNullableType());
				}
				return false;
			}
		}

		internal bool IsReferenceComparison
		{
			get
			{
				Type type = Left.Type;
				Type type2 = Right.Type;
				MethodInfo method = GetMethod();
				ExpressionType nodeType = NodeType;
				if ((nodeType == ExpressionType.Equal || nodeType == ExpressionType.NotEqual) && method == null && !type.IsValueType)
				{
					return !type2.IsValueType;
				}
				return false;
			}
		}

		internal BinaryExpression(Expression left, Expression right)
		{
			Left = left;
			Right = right;
		}

		private static bool IsOpAssignment(ExpressionType op)
		{
			if ((uint)(op - 63) <= 13u)
			{
				return true;
			}
			return false;
		}

		internal virtual MethodInfo GetMethod()
		{
			return null;
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="left">The <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property of the result. </param>
		/// <param name="conversion">The <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" />property of the result.</param>
		/// <param name="right">The <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property of the result. </param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public BinaryExpression Update(Expression left, LambdaExpression conversion, Expression right)
		{
			if (left == Left && right == Right && conversion == Conversion)
			{
				return this;
			}
			if (IsReferenceComparison)
			{
				if (NodeType == ExpressionType.Equal)
				{
					return Expression.ReferenceEqual(left, right);
				}
				return Expression.ReferenceNotEqual(left, right);
			}
			return Expression.MakeBinary(NodeType, left, right, IsLiftedToNull, Method, conversion);
		}

		/// <summary>Reduces the binary expression node to a simpler expression.</summary>
		/// <returns>The reduced expression.</returns>
		public override Expression Reduce()
		{
			if (IsOpAssignment(NodeType))
			{
				return Left.NodeType switch
				{
					ExpressionType.MemberAccess => ReduceMember(), 
					ExpressionType.Index => ReduceIndex(), 
					_ => ReduceVariable(), 
				};
			}
			return this;
		}

		private static ExpressionType GetBinaryOpFromAssignmentOp(ExpressionType op)
		{
			return op switch
			{
				ExpressionType.AddAssign => ExpressionType.Add, 
				ExpressionType.AddAssignChecked => ExpressionType.AddChecked, 
				ExpressionType.SubtractAssign => ExpressionType.Subtract, 
				ExpressionType.SubtractAssignChecked => ExpressionType.SubtractChecked, 
				ExpressionType.MultiplyAssign => ExpressionType.Multiply, 
				ExpressionType.MultiplyAssignChecked => ExpressionType.MultiplyChecked, 
				ExpressionType.DivideAssign => ExpressionType.Divide, 
				ExpressionType.ModuloAssign => ExpressionType.Modulo, 
				ExpressionType.PowerAssign => ExpressionType.Power, 
				ExpressionType.AndAssign => ExpressionType.And, 
				ExpressionType.OrAssign => ExpressionType.Or, 
				ExpressionType.RightShiftAssign => ExpressionType.RightShift, 
				ExpressionType.LeftShiftAssign => ExpressionType.LeftShift, 
				ExpressionType.ExclusiveOrAssign => ExpressionType.ExclusiveOr, 
				_ => throw ContractUtils.Unreachable, 
			};
		}

		private Expression ReduceVariable()
		{
			Expression expression = Expression.MakeBinary(GetBinaryOpFromAssignmentOp(NodeType), Left, Right, liftToNull: false, Method);
			LambdaExpression conversion = GetConversion();
			if (conversion != null)
			{
				expression = Expression.Invoke(conversion, expression);
			}
			return Expression.Assign(Left, expression);
		}

		private Expression ReduceMember()
		{
			MemberExpression memberExpression = (MemberExpression)Left;
			if (memberExpression.Expression == null)
			{
				return ReduceVariable();
			}
			ParameterExpression parameterExpression = Expression.Variable(memberExpression.Expression.Type, "temp1");
			Expression expression = Expression.Assign(parameterExpression, memberExpression.Expression);
			Expression expression2 = Expression.MakeBinary(GetBinaryOpFromAssignmentOp(NodeType), Expression.MakeMemberAccess(parameterExpression, memberExpression.Member), Right, liftToNull: false, Method);
			LambdaExpression conversion = GetConversion();
			if (conversion != null)
			{
				expression2 = Expression.Invoke(conversion, expression2);
			}
			ParameterExpression parameterExpression2 = Expression.Variable(expression2.Type, "temp2");
			expression2 = Expression.Assign(parameterExpression2, expression2);
			Expression expression3 = Expression.Assign(Expression.MakeMemberAccess(parameterExpression, memberExpression.Member), parameterExpression2);
			Expression expression4 = parameterExpression2;
			return Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(parameterExpression, parameterExpression2), new TrueReadOnlyCollection<Expression>(expression, expression2, expression3, expression4));
		}

		private Expression ReduceIndex()
		{
			IndexExpression indexExpression = (IndexExpression)Left;
			ArrayBuilder<ParameterExpression> builder = new ArrayBuilder<ParameterExpression>(indexExpression.ArgumentCount + 2);
			ArrayBuilder<Expression> builder2 = new ArrayBuilder<Expression>(indexExpression.ArgumentCount + 3);
			ParameterExpression parameterExpression = Expression.Variable(indexExpression.Object.Type, "tempObj");
			builder.UncheckedAdd(parameterExpression);
			builder2.UncheckedAdd(Expression.Assign(parameterExpression, indexExpression.Object));
			int argumentCount = indexExpression.ArgumentCount;
			ArrayBuilder<Expression> builder3 = new ArrayBuilder<Expression>(argumentCount);
			for (int i = 0; i < argumentCount; i++)
			{
				Expression argument = indexExpression.GetArgument(i);
				ParameterExpression parameterExpression2 = Expression.Variable(argument.Type, "tempArg" + i);
				builder.UncheckedAdd(parameterExpression2);
				builder3.UncheckedAdd(parameterExpression2);
				builder2.UncheckedAdd(Expression.Assign(parameterExpression2, argument));
			}
			IndexExpression left = Expression.MakeIndex(parameterExpression, indexExpression.Indexer, builder3.ToReadOnly());
			Expression expression = Expression.MakeBinary(GetBinaryOpFromAssignmentOp(NodeType), left, Right, liftToNull: false, Method);
			LambdaExpression conversion = GetConversion();
			if (conversion != null)
			{
				expression = Expression.Invoke(conversion, expression);
			}
			ParameterExpression parameterExpression3 = Expression.Variable(expression.Type, "tempValue");
			builder.UncheckedAdd(parameterExpression3);
			builder2.UncheckedAdd(Expression.Assign(parameterExpression3, expression));
			builder2.UncheckedAdd(Expression.Assign(left, parameterExpression3));
			return Expression.Block(builder.ToReadOnly(), builder2.ToReadOnly());
		}

		internal virtual LambdaExpression GetConversion()
		{
			return null;
		}

		/// <summary>Dispatches to the specific visit method for this node type. For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
		/// <param name="visitor">The visitor to visit this node with.</param>
		/// <returns>The result of visiting this node.</returns>
		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitBinary(this);
		}

		internal static BinaryExpression Create(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method, LambdaExpression conversion)
		{
			if (conversion != null)
			{
				return new CoalesceConversionBinaryExpression(left, right, conversion);
			}
			if (method != null)
			{
				return new MethodBinaryExpression(nodeType, left, right, type, method);
			}
			if (type == typeof(bool))
			{
				return new LogicalBinaryExpression(nodeType, left, right);
			}
			return new SimpleBinaryExpression(nodeType, left, right, type);
		}

		internal Expression ReduceUserdefinedLifted()
		{
			ParameterExpression parameterExpression = Expression.Parameter(Left.Type, "left");
			ParameterExpression parameterExpression2 = Expression.Parameter(Right.Type, "right");
			string name = ((NodeType == ExpressionType.AndAlso) ? "op_False" : "op_True");
			MethodInfo booleanOperator = TypeUtils.GetBooleanOperator(Method.DeclaringType, name);
			return Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(parameterExpression), new TrueReadOnlyCollection<Expression>(Expression.Assign(parameterExpression, Left), Expression.Condition(Expression.Property(parameterExpression, "HasValue"), Expression.Condition(Expression.Call(booleanOperator, Expression.Call(parameterExpression, "GetValueOrDefault", null)), parameterExpression, Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(parameterExpression2), new TrueReadOnlyCollection<Expression>(Expression.Assign(parameterExpression2, Right), Expression.Condition(Expression.Property(parameterExpression2, "HasValue"), Expression.Convert(Expression.Call(Method, Expression.Call(parameterExpression, "GetValueOrDefault", null), Expression.Call(parameterExpression2, "GetValueOrDefault", null)), Type), Expression.Constant(null, Type))))), Expression.Constant(null, Type))));
		}

		internal BinaryExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal sealed class LogicalBinaryExpression : BinaryExpression
	{
		public sealed override Type Type => typeof(bool);

		public sealed override ExpressionType NodeType { get; }

		internal LogicalBinaryExpression(ExpressionType nodeType, Expression left, Expression right)
			: base(left, right)
		{
			NodeType = nodeType;
		}
	}
	internal class AssignBinaryExpression : BinaryExpression
	{
		internal virtual bool IsByRef => false;

		public sealed override Type Type => base.Left.Type;

		public sealed override ExpressionType NodeType => ExpressionType.Assign;

		internal AssignBinaryExpression(Expression left, Expression right)
			: base(left, right)
		{
		}

		public static AssignBinaryExpression Make(Expression left, Expression right, bool byRef)
		{
			if (byRef)
			{
				return new ByRefAssignBinaryExpression(left, right);
			}
			return new AssignBinaryExpression(left, right);
		}
	}
	internal class ByRefAssignBinaryExpression : AssignBinaryExpression
	{
		internal override bool IsByRef => true;

		internal ByRefAssignBinaryExpression(Expression left, Expression right)
			: base(left, right)
		{
		}
	}
	internal sealed class CoalesceConversionBinaryExpression : BinaryExpression
	{
		private readonly LambdaExpression _conversion;

		public sealed override ExpressionType NodeType => ExpressionType.Coalesce;

		public sealed override Type Type => base.Right.Type;

		internal CoalesceConversionBinaryExpression(Expression left, Expression right, LambdaExpression conversion)
			: base(left, right)
		{
			_conversion = conversion;
		}

		internal override LambdaExpression GetConversion()
		{
			return _conversion;
		}
	}
	internal sealed class OpAssignMethodConversionBinaryExpression : MethodBinaryExpression
	{
		private readonly LambdaExpression _conversion;

		internal OpAssignMethodConversionBinaryExpression(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method, LambdaExpression conversion)
			: base(nodeType, left, right, type, method)
		{
			_conversion = conversion;
		}

		internal override LambdaExpression GetConversion()
		{
			return _conversion;
		}
	}
	internal class SimpleBinaryExpression : BinaryExpression
	{
		public sealed override ExpressionType NodeType { get; }

		public sealed override Type Type { get; }

		internal SimpleBinaryExpression(ExpressionType nodeType, Expression left, Expression right, Type type)
			: base(left, right)
		{
			NodeType = nodeType;
			Type = type;
		}
	}
	internal class MethodBinaryExpression : SimpleBinaryExpression
	{
		private readonly MethodInfo _method;

		internal MethodBinaryExpression(ExpressionType nodeType, Expression left, Expression right, Type type, MethodInfo method)
			: base(nodeType, left, right, type)
		{
			_method = method;
		}

		internal override MethodInfo GetMethod()
		{
			return _method;
		}
	}
	/// <summary>Provides the base class from which the classes that represent expression tree nodes are derived. It also contains <see langword="static" /> (<see langword="Shared" /> in Visual Basic) factory methods to create the various node types. This is an <see langword="abstract" /> class.</summary>
	public abstract class Expression
	{
		internal class BinaryExpressionProxy
		{
			private readonly BinaryExpression _node;

			public bool CanReduce => _node.CanReduce;

			public LambdaExpression Conversion => _node.Conversion;

			public string DebugView => _node.DebugView;

			public bool IsLifted => _node.IsLifted;

			public bool IsLiftedToNull => _node.IsLiftedToNull;

			public Expression Left => _node.Left;

			public MethodInfo Method => _node.Method;

			public ExpressionType NodeType => _node.NodeType;

			public Expression Right => _node.Right;

			public Type Type => _node.Type;

			public BinaryExpressionProxy(BinaryExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class BlockExpressionProxy
		{
			private readonly BlockExpression _node;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public ReadOnlyCollection<Expression> Expressions => _node.Expressions;

			public ExpressionType NodeType => _node.NodeType;

			public Expression Result => _node.Result;

			public Type Type => _node.Type;

			public ReadOnlyCollection<ParameterExpression> Variables => _node.Variables;

			public BlockExpressionProxy(BlockExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class CatchBlockProxy
		{
			private readonly CatchBlock _node;

			public Expression Body => _node.Body;

			public Expression Filter => _node.Filter;

			public Type Test => _node.Test;

			public ParameterExpression Variable => _node.Variable;

			public CatchBlockProxy(CatchBlock node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class ConditionalExpressionProxy
		{
			private readonly ConditionalExpression _node;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public Expression IfFalse => _node.IfFalse;

			public Expression IfTrue => _node.IfTrue;

			public ExpressionType NodeType => _node.NodeType;

			public Expression Test => _node.Test;

			public Type Type => _node.Type;

			public ConditionalExpressionProxy(ConditionalExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class ConstantExpressionProxy
		{
			private readonly ConstantExpression _node;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public ExpressionType NodeType => _node.NodeType;

			public Type Type => _node.Type;

			public object Value => _node.Value;

			public ConstantExpressionProxy(ConstantExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class DebugInfoExpressionProxy
		{
			private readonly DebugInfoExpression _node;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public SymbolDocumentInfo Document => _node.Document;

			public int EndColumn => _node.EndColumn;

			public int EndLine => _node.EndLine;

			public bool IsClear => _node.IsClear;

			public ExpressionType NodeType => _node.NodeType;

			public int StartColumn => _node.StartColumn;

			public int StartLine => _node.StartLine;

			public Type Type => _node.Type;

			public DebugInfoExpressionProxy(DebugInfoExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class DefaultExpressionProxy
		{
			private readonly DefaultExpression _node;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public ExpressionType NodeType => _node.NodeType;

			public Type Type => _node.Type;

			public DefaultExpressionProxy(DefaultExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class GotoExpressionProxy
		{
			private readonly GotoExpression _node;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public GotoExpressionKind Kind => _node.Kind;

			public ExpressionType NodeType => _node.NodeType;

			public LabelTarget Target => _node.Target;

			public Type Type => _node.Type;

			public Expression Value => _node.Value;

			public GotoExpressionProxy(GotoExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class IndexExpressionProxy
		{
			private readonly IndexExpression _node;

			public ReadOnlyCollection<Expression> Arguments => _node.Arguments;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public PropertyInfo Indexer => _node.Indexer;

			public ExpressionType NodeType => _node.NodeType;

			public Expression Object => _node.Object;

			public Type Type => _node.Type;

			public IndexExpressionProxy(IndexExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class InvocationExpressionProxy
		{
			private readonly InvocationExpression _node;

			public ReadOnlyCollection<Expression> Arguments => _node.Arguments;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public Expression Expression => _node.Expression;

			public ExpressionType NodeType => _node.NodeType;

			public Type Type => _node.Type;

			public InvocationExpressionProxy(InvocationExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class LabelExpressionProxy
		{
			private readonly LabelExpression _node;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public Expression DefaultValue => _node.DefaultValue;

			public ExpressionType NodeType => _node.NodeType;

			public LabelTarget Target => _node.Target;

			public Type Type => _node.Type;

			public LabelExpressionProxy(LabelExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class LambdaExpressionProxy
		{
			private readonly LambdaExpression _node;

			public Expression Body => _node.Body;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public string Name => _node.Name;

			public ExpressionType NodeType => _node.NodeType;

			public ReadOnlyCollection<ParameterExpression> Parameters => _node.Parameters;

			public Type ReturnType => _node.ReturnType;

			public bool TailCall => _node.TailCall;

			public Type Type => _node.Type;

			public LambdaExpressionProxy(LambdaExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class ListInitExpressionProxy
		{
			private readonly ListInitExpression _node;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public ReadOnlyCollection<ElementInit> Initializers => _node.Initializers;

			public NewExpression NewExpression => _node.NewExpression;

			public ExpressionType NodeType => _node.NodeType;

			public Type Type => _node.Type;

			public ListInitExpressionProxy(ListInitExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class LoopExpressionProxy
		{
			private readonly LoopExpression _node;

			public Expression Body => _node.Body;

			public LabelTarget BreakLabel => _node.BreakLabel;

			public bool CanReduce => _node.CanReduce;

			public LabelTarget ContinueLabel => _node.ContinueLabel;

			public string DebugView => _node.DebugView;

			public ExpressionType NodeType => _node.NodeType;

			public Type Type => _node.Type;

			public LoopExpressionProxy(LoopExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class MemberExpressionProxy
		{
			private readonly MemberExpression _node;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public Expression Expression => _node.Expression;

			public MemberInfo Member => _node.Member;

			public ExpressionType NodeType => _node.NodeType;

			public Type Type => _node.Type;

			public MemberExpressionProxy(MemberExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class MemberInitExpressionProxy
		{
			private readonly MemberInitExpression _node;

			public ReadOnlyCollection<MemberBinding> Bindings => _node.Bindings;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public NewExpression NewExpression => _node.NewExpression;

			public ExpressionType NodeType => _node.NodeType;

			public Type Type => _node.Type;

			public MemberInitExpressionProxy(MemberInitExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class MethodCallExpressionProxy
		{
			private readonly MethodCallExpression _node;

			public ReadOnlyCollection<Expression> Arguments => _node.Arguments;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public MethodInfo Method => _node.Method;

			public ExpressionType NodeType => _node.NodeType;

			public Expression Object => _node.Object;

			public Type Type => _node.Type;

			public MethodCallExpressionProxy(MethodCallExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class NewArrayExpressionProxy
		{
			private readonly NewArrayExpression _node;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public ReadOnlyCollection<Expression> Expressions => _node.Expressions;

			public ExpressionType NodeType => _node.NodeType;

			public Type Type => _node.Type;

			public NewArrayExpressionProxy(NewArrayExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class NewExpressionProxy
		{
			private readonly NewExpression _node;

			public ReadOnlyCollection<Expression> Arguments => _node.Arguments;

			public bool CanReduce => _node.CanReduce;

			public ConstructorInfo Constructor => _node.Constructor;

			public string DebugView => _node.DebugView;

			public ReadOnlyCollection<MemberInfo> Members => _node.Members;

			public ExpressionType NodeType => _node.NodeType;

			public Type Type => _node.Type;

			public NewExpressionProxy(NewExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class ParameterExpressionProxy
		{
			private readonly ParameterExpression _node;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public bool IsByRef => _node.IsByRef;

			public string Name => _node.Name;

			public ExpressionType NodeType => _node.NodeType;

			public Type Type => _node.Type;

			public ParameterExpressionProxy(ParameterExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class RuntimeVariablesExpressionProxy
		{
			private readonly RuntimeVariablesExpression _node;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public ExpressionType NodeType => _node.NodeType;

			public Type Type => _node.Type;

			public ReadOnlyCollection<ParameterExpression> Variables => _node.Variables;

			public RuntimeVariablesExpressionProxy(RuntimeVariablesExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class SwitchCaseProxy
		{
			private readonly SwitchCase _node;

			public Expression Body => _node.Body;

			public ReadOnlyCollection<Expression> TestValues => _node.TestValues;

			public SwitchCaseProxy(SwitchCase node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class SwitchExpressionProxy
		{
			private readonly SwitchExpression _node;

			public bool CanReduce => _node.CanReduce;

			public ReadOnlyCollection<SwitchCase> Cases => _node.Cases;

			public MethodInfo Comparison => _node.Comparison;

			public string DebugView => _node.DebugView;

			public Expression DefaultBody => _node.DefaultBody;

			public ExpressionType NodeType => _node.NodeType;

			public Expression SwitchValue => _node.SwitchValue;

			public Type Type => _node.Type;

			public SwitchExpressionProxy(SwitchExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class TryExpressionProxy
		{
			private readonly TryExpression _node;

			public Expression Body => _node.Body;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public Expression Fault => _node.Fault;

			public Expression Finally => _node.Finally;

			public ReadOnlyCollection<CatchBlock> Handlers => _node.Handlers;

			public ExpressionType NodeType => _node.NodeType;

			public Type Type => _node.Type;

			public TryExpressionProxy(TryExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class TypeBinaryExpressionProxy
		{
			private readonly TypeBinaryExpression _node;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public Expression Expression => _node.Expression;

			public ExpressionType NodeType => _node.NodeType;

			public Type Type => _node.Type;

			public Type TypeOperand => _node.TypeOperand;

			public TypeBinaryExpressionProxy(TypeBinaryExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		internal class UnaryExpressionProxy
		{
			private readonly UnaryExpression _node;

			public bool CanReduce => _node.CanReduce;

			public string DebugView => _node.DebugView;

			public bool IsLifted => _node.IsLifted;

			public bool IsLiftedToNull => _node.IsLiftedToNull;

			public MethodInfo Method => _node.Method;

			public ExpressionType NodeType => _node.NodeType;

			public Expression Operand => _node.Operand;

			public Type Type => _node.Type;

			public UnaryExpressionProxy(UnaryExpression node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}
		}

		private class ExtensionInfo
		{
			internal readonly ExpressionType NodeType;

			internal readonly Type Type;

			public ExtensionInfo(ExpressionType nodeType, Type type)
			{
				NodeType = nodeType;
				Type = type;
			}
		}

		private enum TryGetFuncActionArgsResult
		{
			Valid,
			ArgumentNull,
			ByRef,
			PointerOrVoid
		}

		private static readonly CacheDict<Type, MethodInfo> s_lambdaDelegateCache = new CacheDict<Type, MethodInfo>(40);

		private static volatile CacheDict<Type, Func<Expression, string, bool, ReadOnlyCollection<ParameterExpression>, LambdaExpression>> s_lambdaFactories;

		private static ConditionalWeakTable<Expression, ExtensionInfo> s_legacyCtorSupportTable;

		/// <summary>Gets the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		/// <returns>One of the <see cref="T:System.Linq.Expressions.ExpressionType" /> values.</returns>
		public virtual ExpressionType NodeType
		{
			get
			{
				if (s_legacyCtorSupportTable != null && s_legacyCtorSupportTable.TryGetValue(this, out var value))
				{
					return value.NodeType;
				}
				throw Error.ExtensionNodeMustOverrideProperty("Expression.NodeType");
			}
		}

		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="T:System.Type" /> that represents the static type of the expression.</returns>
		public virtual Type Type
		{
			get
			{
				if (s_legacyCtorSupportTable != null && s_legacyCtorSupportTable.TryGetValue(this, out var value))
				{
					return value.Type;
				}
				throw Error.ExtensionNodeMustOverrideProperty("Expression.Type");
			}
		}

		/// <summary>Indicates that the node can be reduced to a simpler node. If this returns true, Reduce() can be called to produce the reduced form.</summary>
		/// <returns>True if the node can be reduced, otherwise false.</returns>
		public virtual bool CanReduce => false;

		private string DebugView
		{
			get
			{
				using StringWriter stringWriter = new StringWriter(CultureInfo.CurrentCulture);
				DebugViewWriter.WriteTo(this, stringWriter);
				return stringWriter.ToString();
			}
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Assign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression Assign(Expression left, Expression right)
		{
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			TypeUtils.ValidateType(left.Type, "left", allowByRef: true, allowPointer: true);
			TypeUtils.ValidateType(right.Type, "right", allowByRef: true, allowPointer: true);
			if (!TypeUtils.AreReferenceAssignable(left.Type, right.Type))
			{
				throw Error.ExpressionTypeDoesNotMatchAssignment(right.Type, left.Type);
			}
			return new AssignBinaryExpression(left, right);
		}

		private static BinaryExpression GetUserDefinedBinaryOperator(ExpressionType binaryType, string name, Expression left, Expression right, bool liftToNull)
		{
			MethodInfo userDefinedBinaryOperator = GetUserDefinedBinaryOperator(binaryType, left.Type, right.Type, name);
			if (userDefinedBinaryOperator != null)
			{
				return new MethodBinaryExpression(binaryType, left, right, userDefinedBinaryOperator.ReturnType, userDefinedBinaryOperator);
			}
			if (left.Type.IsNullableType() && right.Type.IsNullableType())
			{
				Type nonNullableType = left.Type.GetNonNullableType();
				Type nonNullableType2 = right.Type.GetNonNullableType();
				userDefinedBinaryOperator = GetUserDefinedBinaryOperator(binaryType, nonNullableType, nonNullableType2, name);
				if (userDefinedBinaryOperator != null && userDefinedBinaryOperator.ReturnType.IsValueType && !userDefinedBinaryOperator.ReturnType.IsNullableType())
				{
					if (userDefinedBinaryOperator.ReturnType != typeof(bool) || liftToNull)
					{
						return new MethodBinaryExpression(binaryType, left, right, userDefinedBinaryOperator.ReturnType.GetNullableType(), userDefinedBinaryOperator);
					}
					return new MethodBinaryExpression(binaryType, left, right, typeof(bool), userDefinedBinaryOperator);
				}
			}
			return null;
		}

		private static BinaryExpression GetMethodBasedBinaryOperator(ExpressionType binaryType, Expression left, Expression right, MethodInfo method, bool liftToNull)
		{
			ValidateOperator(method);
			ParameterInfo[] parametersCached = method.GetParametersCached();
			if (parametersCached.Length != 2)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(method, "method");
			}
			if (ParameterIsAssignable(parametersCached[0], left.Type) && ParameterIsAssignable(parametersCached[1], right.Type))
			{
				ValidateParamswithOperandsOrThrow(parametersCached[0].ParameterType, left.Type, binaryType, method.Name);
				ValidateParamswithOperandsOrThrow(parametersCached[1].ParameterType, right.Type, binaryType, method.Name);
				return new MethodBinaryExpression(binaryType, left, right, method.ReturnType, method);
			}
			if (left.Type.IsNullableType() && right.Type.IsNullableType() && ParameterIsAssignable(parametersCached[0], left.Type.GetNonNullableType()) && ParameterIsAssignable(parametersCached[1], right.Type.GetNonNullableType()) && method.ReturnType.IsValueType && !method.ReturnType.IsNullableType())
			{
				if (method.ReturnType != typeof(bool) || liftToNull)
				{
					return new MethodBinaryExpression(binaryType, left, right, method.ReturnType.GetNullableType(), method);
				}
				return new MethodBinaryExpression(binaryType, left, right, typeof(bool), method);
			}
			throw Error.OperandTypesDoNotMatchParameters(binaryType, method.Name);
		}

		private static BinaryExpression GetMethodBasedAssignOperator(ExpressionType binaryType, Expression left, Expression right, MethodInfo method, LambdaExpression conversion, bool liftToNull)
		{
			BinaryExpression binaryExpression = GetMethodBasedBinaryOperator(binaryType, left, right, method, liftToNull);
			if (conversion == null)
			{
				if (!TypeUtils.AreReferenceAssignable(left.Type, binaryExpression.Type))
				{
					throw Error.UserDefinedOpMustHaveValidReturnType(binaryType, binaryExpression.Method.Name);
				}
			}
			else
			{
				ValidateOpAssignConversionLambda(conversion, binaryExpression.Left, binaryExpression.Method, binaryExpression.NodeType);
				binaryExpression = new OpAssignMethodConversionBinaryExpression(binaryExpression.NodeType, binaryExpression.Left, binaryExpression.Right, binaryExpression.Left.Type, binaryExpression.Method, conversion);
			}
			return binaryExpression;
		}

		private static BinaryExpression GetUserDefinedBinaryOperatorOrThrow(ExpressionType binaryType, string name, Expression left, Expression right, bool liftToNull)
		{
			BinaryExpression userDefinedBinaryOperator = GetUserDefinedBinaryOperator(binaryType, name, left, right, liftToNull);
			if (userDefinedBinaryOperator != null)
			{
				ParameterInfo[] parametersCached = userDefinedBinaryOperator.Method.GetParametersCached();
				ValidateParamswithOperandsOrThrow(parametersCached[0].ParameterType, left.Type, binaryType, name);
				ValidateParamswithOperandsOrThrow(parametersCached[1].ParameterType, right.Type, binaryType, name);
				return userDefinedBinaryOperator;
			}
			throw Error.BinaryOperatorNotDefined(binaryType, left.Type, right.Type);
		}

		private static BinaryExpression GetUserDefinedAssignOperatorOrThrow(ExpressionType binaryType, string name, Expression left, Expression right, LambdaExpression conversion, bool liftToNull)
		{
			BinaryExpression binaryExpression = GetUserDefinedBinaryOperatorOrThrow(binaryType, name, left, right, liftToNull);
			if (conversion == null)
			{
				if (!TypeUtils.AreReferenceAssignable(left.Type, binaryExpression.Type))
				{
					throw Error.UserDefinedOpMustHaveValidReturnType(binaryType, binaryExpression.Method.Name);
				}
			}
			else
			{
				ValidateOpAssignConversionLambda(conversion, binaryExpression.Left, binaryExpression.Method, binaryExpression.NodeType);
				binaryExpression = new OpAssignMethodConversionBinaryExpression(binaryExpression.NodeType, binaryExpression.Left, binaryExpression.Right, binaryExpression.Left.Type, binaryExpression.Method, conversion);
			}
			return binaryExpression;
		}

		private static MethodInfo GetUserDefinedBinaryOperator(ExpressionType binaryType, Type leftType, Type rightType, string name)
		{
			Type[] types = new Type[2] { leftType, rightType };
			Type nonNullableType = leftType.GetNonNullableType();
			Type nonNullableType2 = rightType.GetNonNullableType();
			MethodInfo methodInfo = nonNullableType.GetAnyStaticMethodValidated(name, types);
			if (methodInfo == null && !TypeUtils.AreEquivalent(leftType, rightType))
			{
				methodInfo = nonNullableType2.GetAnyStaticMethodValidated(name, types);
			}
			if (IsLiftingConditionalLogicalOperator(leftType, rightType, methodInfo, binaryType))
			{
				methodInfo = GetUserDefinedBinaryOperator(binaryType, nonNullableType, nonNullableType2, name);
			}
			return methodInfo;
		}

		private static bool IsLiftingConditionalLogicalOperator(Type left, Type right, MethodInfo method, ExpressionType binaryType)
		{
			if (right.IsNullableType() && left.IsNullableType() && method == null)
			{
				if (binaryType != ExpressionType.AndAlso)
				{
					return binaryType == ExpressionType.OrElse;
				}
				return true;
			}
			return false;
		}

		internal static bool ParameterIsAssignable(ParameterInfo pi, Type argType)
		{
			Type type = pi.ParameterType;
			if (type.IsByRef)
			{
				type = type.GetElementType();
			}
			return TypeUtils.AreReferenceAssignable(type, argType);
		}

		private static void ValidateParamswithOperandsOrThrow(Type paramType, Type operandType, ExpressionType exprType, string name)
		{
			if (paramType.IsNullableType() && !operandType.IsNullableType())
			{
				throw Error.OperandTypesDoNotMatchParameters(exprType, name);
			}
		}

		private static void ValidateOperator(MethodInfo method)
		{
			ValidateMethodInfo(method, "method");
			if (!method.IsStatic)
			{
				throw Error.UserDefinedOperatorMustBeStatic(method, "method");
			}
			if (method.ReturnType == typeof(void))
			{
				throw Error.UserDefinedOperatorMustNotBeVoid(method, "method");
			}
		}

		private static void ValidateMethodInfo(MethodInfo method, string paramName)
		{
			if (method.ContainsGenericParameters)
			{
				throw method.IsGenericMethodDefinition ? Error.MethodIsGeneric(method, paramName) : Error.MethodContainsGenericParameters(method, paramName);
			}
		}

		private static bool IsNullComparison(Expression left, Expression right)
		{
			if (!IsNullConstant(left))
			{
				if (IsNullConstant(right))
				{
					return left.Type.IsNullableType();
				}
				return false;
			}
			if (!IsNullConstant(right))
			{
				return right.Type.IsNullableType();
			}
			return false;
		}

		private static bool IsNullConstant(Expression e)
		{
			if (e is ConstantExpression constantExpression)
			{
				return constantExpression.Value == null;
			}
			return false;
		}

		private static void ValidateUserDefinedConditionalLogicOperator(ExpressionType nodeType, Type left, Type right, MethodInfo method)
		{
			ValidateOperator(method);
			ParameterInfo[] parametersCached = method.GetParametersCached();
			if (parametersCached.Length != 2)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(method, "method");
			}
			if (!ParameterIsAssignable(parametersCached[0], left) && (!left.IsNullableType() || !ParameterIsAssignable(parametersCached[0], left.GetNonNullableType())))
			{
				throw Error.OperandTypesDoNotMatchParameters(nodeType, method.Name);
			}
			if (!ParameterIsAssignable(parametersCached[1], right) && (!right.IsNullableType() || !ParameterIsAssignable(parametersCached[1], right.GetNonNullableType())))
			{
				throw Error.OperandTypesDoNotMatchParameters(nodeType, method.Name);
			}
			if (parametersCached[0].ParameterType != parametersCached[1].ParameterType)
			{
				throw Error.UserDefinedOpMustHaveConsistentTypes(nodeType, method.Name);
			}
			if (method.ReturnType != parametersCached[0].ParameterType)
			{
				throw Error.UserDefinedOpMustHaveConsistentTypes(nodeType, method.Name);
			}
			if (IsValidLiftedConditionalLogicalOperator(left, right, parametersCached))
			{
				left = left.GetNonNullableType();
			}
			Type declaringType = method.DeclaringType;
			if (declaringType == null)
			{
				throw Error.LogicalOperatorMustHaveBooleanOperators(nodeType, method.Name);
			}
			MethodInfo booleanOperator = TypeUtils.GetBooleanOperator(declaringType, "op_True");
			MethodInfo booleanOperator2 = TypeUtils.GetBooleanOperator(declaringType, "op_False");
			if (booleanOperator == null || booleanOperator.ReturnType != typeof(bool) || booleanOperator2 == null || booleanOperator2.ReturnType != typeof(bool))
			{
				throw Error.LogicalOperatorMustHaveBooleanOperators(nodeType, method.Name);
			}
			VerifyOpTrueFalse(nodeType, left, booleanOperator2, "method");
			VerifyOpTrueFalse(nodeType, left, booleanOperator, "method");
		}

		private static void VerifyOpTrueFalse(ExpressionType nodeType, Type left, MethodInfo opTrue, string paramName)
		{
			ParameterInfo[] parametersCached = opTrue.GetParametersCached();
			if (parametersCached.Length != 1)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(opTrue, paramName);
			}
			if (!ParameterIsAssignable(parametersCached[0], left) && (!left.IsNullableType() || !ParameterIsAssignable(parametersCached[0], left.GetNonNullableType())))
			{
				throw Error.OperandTypesDoNotMatchParameters(nodeType, opTrue.Name);
			}
		}

		private static bool IsValidLiftedConditionalLogicalOperator(Type left, Type right, ParameterInfo[] pms)
		{
			if (TypeUtils.AreEquivalent(left, right) && right.IsNullableType())
			{
				return TypeUtils.AreEquivalent(pms[1].ParameterType, right.GetNonNullableType());
			}
			return false;
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left and right operands, by calling an appropriate factory method.</summary>
		/// <param name="binaryType">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</param>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</param>
		/// <returns>The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="binaryType" /> does not correspond to a binary expression node.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right)
		{
			return MakeBinary(binaryType, left, right, liftToNull: false, null, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand and implementing method, by calling the appropriate factory method.</summary>
		/// <param name="binaryType">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</param>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</param>
		/// <param name="liftToNull">
		///       <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</param>
		/// <returns>The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="binaryType" /> does not correspond to a binary expression node.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method)
		{
			return MakeBinary(binaryType, left, right, liftToNull, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" />, given the left operand, right operand, implementing method and type conversion function, by calling the appropriate factory method.</summary>
		/// <param name="binaryType">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of binary operation.</param>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the left operand.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the right operand.</param>
		/// <param name="liftToNull">
		///       <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> that specifies the implementing method.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that represents a type conversion function. This parameter is used only if <paramref name="binaryType" /> is <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> or compound assignment..</param>
		/// <returns>The <see cref="T:System.Linq.Expressions.BinaryExpression" /> that results from calling the appropriate factory method.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="binaryType" /> does not correspond to a binary expression node.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		public static BinaryExpression MakeBinary(ExpressionType binaryType, Expression left, Expression right, bool liftToNull, MethodInfo method, LambdaExpression conversion)
		{
			return binaryType switch
			{
				ExpressionType.Add => Add(left, right, method), 
				ExpressionType.AddChecked => AddChecked(left, right, method), 
				ExpressionType.Subtract => Subtract(left, right, method), 
				ExpressionType.SubtractChecked => SubtractChecked(left, right, method), 
				ExpressionType.Multiply => Multiply(left, right, method), 
				ExpressionType.MultiplyChecked => MultiplyChecked(left, right, method), 
				ExpressionType.Divide => Divide(left, right, method), 
				ExpressionType.Modulo => Modulo(left, right, method), 
				ExpressionType.Power => Power(left, right, method), 
				ExpressionType.And => And(left, right, method), 
				ExpressionType.AndAlso => AndAlso(left, right, method), 
				ExpressionType.Or => Or(left, right, method), 
				ExpressionType.OrElse => OrElse(left, right, method), 
				ExpressionType.LessThan => LessThan(left, right, liftToNull, method), 
				ExpressionType.LessThanOrEqual => LessThanOrEqual(left, right, liftToNull, method), 
				ExpressionType.GreaterThan => GreaterThan(left, right, liftToNull, method), 
				ExpressionType.GreaterThanOrEqual => GreaterThanOrEqual(left, right, liftToNull, method), 
				ExpressionType.Equal => Equal(left, right, liftToNull, method), 
				ExpressionType.NotEqual => NotEqual(left, right, liftToNull, method), 
				ExpressionType.ExclusiveOr => ExclusiveOr(left, right, method), 
				ExpressionType.Coalesce => Coalesce(left, right, conversion), 
				ExpressionType.ArrayIndex => ArrayIndex(left, right), 
				ExpressionType.RightShift => RightShift(left, right, method), 
				ExpressionType.LeftShift => LeftShift(left, right, method), 
				ExpressionType.Assign => Assign(left, right), 
				ExpressionType.AddAssign => AddAssign(left, right, method, conversion), 
				ExpressionType.AndAssign => AndAssign(left, right, method, conversion), 
				ExpressionType.DivideAssign => DivideAssign(left, right, method, conversion), 
				ExpressionType.ExclusiveOrAssign => ExclusiveOrAssign(left, right, method, conversion), 
				ExpressionType.LeftShiftAssign => LeftShiftAssign(left, right, method, conversion), 
				ExpressionType.ModuloAssign => ModuloAssign(left, right, method, conversion), 
				ExpressionType.MultiplyAssign => MultiplyAssign(left, right, method, conversion), 
				ExpressionType.OrAssign => OrAssign(left, right, method, conversion), 
				ExpressionType.PowerAssign => PowerAssign(left, right, method, conversion), 
				ExpressionType.RightShiftAssign => RightShiftAssign(left, right, method, conversion), 
				ExpressionType.SubtractAssign => SubtractAssign(left, right, method, conversion), 
				ExpressionType.AddAssignChecked => AddAssignChecked(left, right, method, conversion), 
				ExpressionType.SubtractAssignChecked => SubtractAssignChecked(left, right, method, conversion), 
				ExpressionType.MultiplyAssignChecked => MultiplyAssignChecked(left, right, method, conversion), 
				_ => throw Error.UnhandledBinary(binaryType, "binaryType"), 
			};
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression Equal(Expression left, Expression right)
		{
			return Equal(left, right, liftToNull: false, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an equality comparison. The implementing method can be specified.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="liftToNull">
		///       <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the equality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression Equal(Expression left, Expression right, bool liftToNull, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				return GetEqualityComparisonOperator(ExpressionType.Equal, "op_Equality", left, right, liftToNull);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Equal, left, right, method, liftToNull);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference equality comparison.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Equal" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression ReferenceEqual(Expression left, Expression right)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (TypeUtils.HasReferenceEquality(left.Type, right.Type))
			{
				return new LogicalBinaryExpression(ExpressionType.Equal, left, right);
			}
			throw Error.ReferenceEqualityNotDefined(left.Type, right.Type);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression NotEqual(Expression left, Expression right)
		{
			return NotEqual(left, right, liftToNull: false, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an inequality comparison.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="liftToNull">
		///       <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the inequality operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression NotEqual(Expression left, Expression right, bool liftToNull, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				return GetEqualityComparisonOperator(ExpressionType.NotEqual, "op_Inequality", left, right, liftToNull);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.NotEqual, left, right, method, liftToNull);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a reference inequality comparison.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NotEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression ReferenceNotEqual(Expression left, Expression right)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (TypeUtils.HasReferenceEquality(left.Type, right.Type))
			{
				return new LogicalBinaryExpression(ExpressionType.NotEqual, left, right);
			}
			throw Error.ReferenceEqualityNotDefined(left.Type, right.Type);
		}

		private static BinaryExpression GetEqualityComparisonOperator(ExpressionType binaryType, string opName, Expression left, Expression right, bool liftToNull)
		{
			if (left.Type == right.Type && (left.Type.IsNumeric() || left.Type == typeof(object) || left.Type.IsBool() || left.Type.GetNonNullableType().IsEnum))
			{
				if (left.Type.IsNullableType() && liftToNull)
				{
					return new SimpleBinaryExpression(binaryType, left, right, typeof(bool?));
				}
				return new LogicalBinaryExpression(binaryType, left, right);
			}
			BinaryExpression userDefinedBinaryOperator = GetUserDefinedBinaryOperator(binaryType, opName, left, right, liftToNull);
			if (userDefinedBinaryOperator != null)
			{
				return userDefinedBinaryOperator;
			}
			if (TypeUtils.HasBuiltInEqualityOperator(left.Type, right.Type) || IsNullComparison(left, right))
			{
				if (left.Type.IsNullableType() && liftToNull)
				{
					return new SimpleBinaryExpression(binaryType, left, right, typeof(bool?));
				}
				return new LogicalBinaryExpression(binaryType, left, right);
			}
			throw Error.BinaryOperatorNotDefined(binaryType, left.Type, right.Type);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression GreaterThan(Expression left, Expression right)
		{
			return GreaterThan(left, right, liftToNull: false, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than" numeric comparison. The implementing method can be specified.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="liftToNull">
		///       <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the "greater than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression GreaterThan(Expression left, Expression right, bool liftToNull, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				return GetComparisonOperator(ExpressionType.GreaterThan, "op_GreaterThan", left, right, liftToNull);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.GreaterThan, left, right, method, liftToNull);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression LessThan(Expression left, Expression right)
		{
			return LessThan(left, right, liftToNull: false, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than" numeric comparison.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="liftToNull">
		///       <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThan" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the "less than" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression LessThan(Expression left, Expression right, bool liftToNull, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				return GetComparisonOperator(ExpressionType.LessThan, "op_LessThan", left, right, liftToNull);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.LessThan, left, right, method, liftToNull);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right)
		{
			return GreaterThanOrEqual(left, right, liftToNull: false, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "greater than or equal" numeric comparison.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="liftToNull">
		///       <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.GreaterThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the "greater than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression GreaterThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				return GetComparisonOperator(ExpressionType.GreaterThanOrEqual, "op_GreaterThanOrEqual", left, right, liftToNull);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.GreaterThanOrEqual, left, right, method, liftToNull);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a " less than or equal" numeric comparison.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression LessThanOrEqual(Expression left, Expression right)
		{
			return LessThanOrEqual(left, right, liftToNull: false, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a "less than or equal" numeric comparison.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="liftToNull">
		///       <see langword="true" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="true" />; <see langword="false" /> to set <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" /> to <see langword="false" />.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LessThanOrEqual" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.IsLiftedToNull" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the "less than or equal" operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression LessThanOrEqual(Expression left, Expression right, bool liftToNull, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				return GetComparisonOperator(ExpressionType.LessThanOrEqual, "op_LessThanOrEqual", left, right, liftToNull);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.LessThanOrEqual, left, right, method, liftToNull);
		}

		private static BinaryExpression GetComparisonOperator(ExpressionType binaryType, string opName, Expression left, Expression right, bool liftToNull)
		{
			if (left.Type == right.Type && left.Type.IsNumeric())
			{
				if (left.Type.IsNullableType() && liftToNull)
				{
					return new SimpleBinaryExpression(binaryType, left, right, typeof(bool?));
				}
				return new LogicalBinaryExpression(binaryType, left, right);
			}
			return GetUserDefinedBinaryOperatorOrThrow(binaryType, opName, left, right, liftToNull);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />.</summary>
		/// <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.-or-
		///         <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</exception>
		public static BinaryExpression AndAlso(Expression left, Expression right)
		{
			return AndAlso(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand is resolved to true. The implementing method can be specified.</summary>
		/// <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAlso" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.-or-
		///         <paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</exception>
		public static BinaryExpression AndAlso(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			Type type;
			if (method == null)
			{
				if (left.Type == right.Type)
				{
					if (left.Type == typeof(bool))
					{
						return new LogicalBinaryExpression(ExpressionType.AndAlso, left, right);
					}
					if (left.Type == typeof(bool?))
					{
						return new SimpleBinaryExpression(ExpressionType.AndAlso, left, right, left.Type);
					}
				}
				method = GetUserDefinedBinaryOperator(ExpressionType.AndAlso, left.Type, right.Type, "op_BitwiseAnd");
				if (method != null)
				{
					ValidateUserDefinedConditionalLogicOperator(ExpressionType.AndAlso, left.Type, right.Type, method);
					type = ((left.Type.IsNullableType() && TypeUtils.AreEquivalent(method.ReturnType, left.Type.GetNonNullableType())) ? left.Type : method.ReturnType);
					return new MethodBinaryExpression(ExpressionType.AndAlso, left, right, type, method);
				}
				throw Error.BinaryOperatorNotDefined(ExpressionType.AndAlso, left.Type, right.Type);
			}
			ValidateUserDefinedConditionalLogicOperator(ExpressionType.AndAlso, left.Type, right.Type, method);
			type = ((left.Type.IsNullableType() && TypeUtils.AreEquivalent(method.ReturnType, left.Type.GetNonNullableType())) ? left.Type : method.ReturnType);
			return new MethodBinaryExpression(ExpressionType.AndAlso, left, right, type, method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.-or-
		///         <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</exception>
		public static BinaryExpression OrElse(Expression left, Expression right)
		{
			return OrElse(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a conditional <see langword="OR" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="false" />.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrElse" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.-or-
		///         <paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and <paramref name="right" />.Type are not the same Boolean type.</exception>
		public static BinaryExpression OrElse(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			Type type;
			if (method == null)
			{
				if (left.Type == right.Type)
				{
					if (left.Type == typeof(bool))
					{
						return new LogicalBinaryExpression(ExpressionType.OrElse, left, right);
					}
					if (left.Type == typeof(bool?))
					{
						return new SimpleBinaryExpression(ExpressionType.OrElse, left, right, left.Type);
					}
				}
				method = GetUserDefinedBinaryOperator(ExpressionType.OrElse, left.Type, right.Type, "op_BitwiseOr");
				if (method != null)
				{
					ValidateUserDefinedConditionalLogicOperator(ExpressionType.OrElse, left.Type, right.Type, method);
					type = ((left.Type.IsNullableType() && method.ReturnType == left.Type.GetNonNullableType()) ? left.Type : method.ReturnType);
					return new MethodBinaryExpression(ExpressionType.OrElse, left, right, type, method);
				}
				throw Error.BinaryOperatorNotDefined(ExpressionType.OrElse, left.Type, right.Type);
			}
			ValidateUserDefinedConditionalLogicOperator(ExpressionType.OrElse, left.Type, right.Type, method);
			type = ((left.Type.IsNullableType() && method.ReturnType == left.Type.GetNonNullableType()) ? left.Type : method.ReturnType);
			return new MethodBinaryExpression(ExpressionType.OrElse, left, right, type, method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.</exception>
		public static BinaryExpression Coalesce(Expression left, Expression right)
		{
			return Coalesce(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a coalescing operation, given a conversion function.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Coalesce" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="left" />.Type and <paramref name="right" />.Type are not convertible to each other.-or-
		///         <paramref name="conversion" /> is not <see langword="null" /> and <paramref name="conversion" />.Type is a delegate type that does not take exactly one argument.</exception>
		/// <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> does not represent a reference type or a nullable value type.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="left" /> represents a type that is not assignable to the parameter type of the delegate type <paramref name="conversion" />.Type.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of <paramref name="right" /> is not equal to the return type of the delegate type <paramref name="conversion" />.Type.</exception>
		public static BinaryExpression Coalesce(Expression left, Expression right, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (conversion == null)
			{
				Type type = ValidateCoalesceArgTypes(left.Type, right.Type);
				return new SimpleBinaryExpression(ExpressionType.Coalesce, left, right, type);
			}
			if (left.Type.IsValueType && !left.Type.IsNullableType())
			{
				throw Error.CoalesceUsedOnNonNullType();
			}
			MethodInfo invokeMethod = conversion.Type.GetInvokeMethod();
			if (invokeMethod.ReturnType == typeof(void))
			{
				throw Error.UserDefinedOperatorMustNotBeVoid(conversion, "conversion");
			}
			ParameterInfo[] parametersCached = invokeMethod.GetParametersCached();
			if (parametersCached.Length != 1)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(conversion, "conversion");
			}
			if (!TypeUtils.AreEquivalent(invokeMethod.ReturnType, right.Type))
			{
				throw Error.OperandTypesDoNotMatchParameters(ExpressionType.Coalesce, conversion.ToString());
			}
			if (!ParameterIsAssignable(parametersCached[0], left.Type.GetNonNullableType()) && !ParameterIsAssignable(parametersCached[0], left.Type))
			{
				throw Error.OperandTypesDoNotMatchParameters(ExpressionType.Coalesce, conversion.ToString());
			}
			return new CoalesceConversionBinaryExpression(left, right, conversion);
		}

		private static Type ValidateCoalesceArgTypes(Type left, Type right)
		{
			Type nonNullableType = left.GetNonNullableType();
			if (left.IsValueType && !left.IsNullableType())
			{
				throw Error.CoalesceUsedOnNonNullType();
			}
			if (left.IsNullableType() && right.IsImplicitlyConvertibleTo(nonNullableType))
			{
				return nonNullableType;
			}
			if (right.IsImplicitlyConvertibleTo(left))
			{
				return left;
			}
			if (nonNullableType.IsImplicitlyConvertibleTo(right))
			{
				return right;
			}
			throw Error.ArgumentTypesMustMatch();
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking.</summary>
		/// <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression Add(Expression left, Expression right)
		{
			return Add(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that does not have overflow checking. The implementing method can be specified.</summary>
		/// <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Add" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression Add(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					return new SimpleBinaryExpression(ExpressionType.Add, left, right, left.Type);
				}
				return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.Add, "op_Addition", left, right, liftToNull: true);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Add, left, right, method, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression AddAssign(Expression left, Expression right)
		{
			return AddAssign(left, right, null, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method)
		{
			return AddAssign(left, right, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		public static BinaryExpression AddAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					if (conversion != null)
					{
						throw Error.ConversionIsNotSupportedForArithmeticTypes();
					}
					return new SimpleBinaryExpression(ExpressionType.AddAssign, left, right, left.Type);
				}
				return GetUserDefinedAssignOperatorOrThrow(ExpressionType.AddAssign, "op_Addition", left, right, conversion, liftToNull: true);
			}
			return GetMethodBasedAssignOperator(ExpressionType.AddAssign, left, right, method, conversion, liftToNull: true);
		}

		private static void ValidateOpAssignConversionLambda(LambdaExpression conversion, Expression left, MethodInfo method, ExpressionType nodeType)
		{
			MethodInfo invokeMethod = conversion.Type.GetInvokeMethod();
			ParameterInfo[] parametersCached = invokeMethod.GetParametersCached();
			if (parametersCached.Length != 1)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(conversion, "conversion");
			}
			if (!TypeUtils.AreEquivalent(invokeMethod.ReturnType, left.Type))
			{
				throw Error.OperandTypesDoNotMatchParameters(nodeType, conversion.ToString());
			}
			if (!TypeUtils.AreEquivalent(parametersCached[0].ParameterType, method.ReturnType))
			{
				throw Error.OverloadOperatorTypeDoesNotMatchConversionType(nodeType, conversion.ToString());
			}
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression AddAssignChecked(Expression left, Expression right)
		{
			return AddAssignChecked(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method)
		{
			return AddAssignChecked(left, right, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an addition assignment operation that has overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		public static BinaryExpression AddAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					if (conversion != null)
					{
						throw Error.ConversionIsNotSupportedForArithmeticTypes();
					}
					return new SimpleBinaryExpression(ExpressionType.AddAssignChecked, left, right, left.Type);
				}
				return GetUserDefinedAssignOperatorOrThrow(ExpressionType.AddAssignChecked, "op_Addition", left, right, conversion, liftToNull: true);
			}
			return GetMethodBasedAssignOperator(ExpressionType.AddAssignChecked, left, right, method, conversion, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking.</summary>
		/// <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression AddChecked(Expression left, Expression right)
		{
			return AddChecked(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic addition operation that has overflow checking. The implementing method can be specified.</summary>
		/// <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AddChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the addition operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression AddChecked(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					return new SimpleBinaryExpression(ExpressionType.AddChecked, left, right, left.Type);
				}
				return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.AddChecked, "op_Addition", left, right, liftToNull: true);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.AddChecked, left, right, method, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression Subtract(Expression left, Expression right)
		{
			return Subtract(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that does not have overflow checking.</summary>
		/// <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Subtract" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression Subtract(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					return new SimpleBinaryExpression(ExpressionType.Subtract, left, right, left.Type);
				}
				return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.Subtract, "op_Subtraction", left, right, liftToNull: true);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Subtract, left, right, method, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression SubtractAssign(Expression left, Expression right)
		{
			return SubtractAssign(left, right, null, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method)
		{
			return SubtractAssign(left, right, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		public static BinaryExpression SubtractAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					if (conversion != null)
					{
						throw Error.ConversionIsNotSupportedForArithmeticTypes();
					}
					return new SimpleBinaryExpression(ExpressionType.SubtractAssign, left, right, left.Type);
				}
				return GetUserDefinedAssignOperatorOrThrow(ExpressionType.SubtractAssign, "op_Subtraction", left, right, conversion, liftToNull: true);
			}
			return GetMethodBasedAssignOperator(ExpressionType.SubtractAssign, left, right, method, conversion, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression SubtractAssignChecked(Expression left, Expression right)
		{
			return SubtractAssignChecked(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method)
		{
			return SubtractAssignChecked(left, right, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a subtraction assignment operation that has overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		public static BinaryExpression SubtractAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					if (conversion != null)
					{
						throw Error.ConversionIsNotSupportedForArithmeticTypes();
					}
					return new SimpleBinaryExpression(ExpressionType.SubtractAssignChecked, left, right, left.Type);
				}
				return GetUserDefinedAssignOperatorOrThrow(ExpressionType.SubtractAssignChecked, "op_Subtraction", left, right, conversion, liftToNull: true);
			}
			return GetMethodBasedAssignOperator(ExpressionType.SubtractAssignChecked, left, right, method, conversion, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</summary>
		/// <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression SubtractChecked(Expression left, Expression right)
		{
			return SubtractChecked(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic subtraction operation that has overflow checking.</summary>
		/// <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.SubtractChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the subtraction operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression SubtractChecked(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					return new SimpleBinaryExpression(ExpressionType.SubtractChecked, left, right, left.Type);
				}
				return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.SubtractChecked, "op_Subtraction", left, right, liftToNull: true);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.SubtractChecked, left, right, method, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression Divide(Expression left, Expression right)
		{
			return Divide(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic division operation. The implementing method can be specified.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Divide" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the division operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression Divide(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					return new SimpleBinaryExpression(ExpressionType.Divide, left, right, left.Type);
				}
				return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.Divide, "op_Division", left, right, liftToNull: true);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Divide, left, right, method, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression DivideAssign(Expression left, Expression right)
		{
			return DivideAssign(left, right, null, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method)
		{
			return DivideAssign(left, right, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a division assignment operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.DivideAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		public static BinaryExpression DivideAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					if (conversion != null)
					{
						throw Error.ConversionIsNotSupportedForArithmeticTypes();
					}
					return new SimpleBinaryExpression(ExpressionType.DivideAssign, left, right, left.Type);
				}
				return GetUserDefinedAssignOperatorOrThrow(ExpressionType.DivideAssign, "op_Division", left, right, conversion, liftToNull: true);
			}
			return GetMethodBasedAssignOperator(ExpressionType.DivideAssign, left, right, method, conversion, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression Modulo(Expression left, Expression right)
		{
			return Modulo(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic remainder operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Modulo" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the modulus operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression Modulo(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					return new SimpleBinaryExpression(ExpressionType.Modulo, left, right, left.Type);
				}
				return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.Modulo, "op_Modulus", left, right, liftToNull: true);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Modulo, left, right, method, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression ModuloAssign(Expression left, Expression right)
		{
			return ModuloAssign(left, right, null, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method)
		{
			return ModuloAssign(left, right, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a remainder assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ModuloAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		public static BinaryExpression ModuloAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					if (conversion != null)
					{
						throw Error.ConversionIsNotSupportedForArithmeticTypes();
					}
					return new SimpleBinaryExpression(ExpressionType.ModuloAssign, left, right, left.Type);
				}
				return GetUserDefinedAssignOperatorOrThrow(ExpressionType.ModuloAssign, "op_Modulus", left, right, conversion, liftToNull: true);
			}
			return GetMethodBasedAssignOperator(ExpressionType.ModuloAssign, left, right, method, conversion, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression Multiply(Expression left, Expression right)
		{
			return Multiply(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Multiply" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression Multiply(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					return new SimpleBinaryExpression(ExpressionType.Multiply, left, right, left.Type);
				}
				return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.Multiply, "op_Multiply", left, right, liftToNull: true);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Multiply, left, right, method, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression MultiplyAssign(Expression left, Expression right)
		{
			return MultiplyAssign(left, right, null, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method)
		{
			return MultiplyAssign(left, right, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that does not have overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		public static BinaryExpression MultiplyAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					if (conversion != null)
					{
						throw Error.ConversionIsNotSupportedForArithmeticTypes();
					}
					return new SimpleBinaryExpression(ExpressionType.MultiplyAssign, left, right, left.Type);
				}
				return GetUserDefinedAssignOperatorOrThrow(ExpressionType.MultiplyAssign, "op_Multiply", left, right, conversion, liftToNull: true);
			}
			return GetMethodBasedAssignOperator(ExpressionType.MultiplyAssign, left, right, method, conversion, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right)
		{
			return MultiplyAssignChecked(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method)
		{
			return MultiplyAssignChecked(left, right, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a multiplication assignment operation that has overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyAssignChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		public static BinaryExpression MultiplyAssignChecked(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					if (conversion != null)
					{
						throw Error.ConversionIsNotSupportedForArithmeticTypes();
					}
					return new SimpleBinaryExpression(ExpressionType.MultiplyAssignChecked, left, right, left.Type);
				}
				return GetUserDefinedAssignOperatorOrThrow(ExpressionType.MultiplyAssignChecked, "op_Multiply", left, right, conversion, liftToNull: true);
			}
			return GetMethodBasedAssignOperator(ExpressionType.MultiplyAssignChecked, left, right, method, conversion, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression MultiplyChecked(Expression left, Expression right)
		{
			return MultiplyChecked(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents an arithmetic multiplication operation that has overflow checking.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MultiplyChecked" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the multiplication operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression MultiplyChecked(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsArithmetic())
				{
					return new SimpleBinaryExpression(ExpressionType.MultiplyChecked, left, right, left.Type);
				}
				return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.MultiplyChecked, "op_Multiply", left, right, liftToNull: true);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.MultiplyChecked, left, right, method, liftToNull: true);
		}

		private static bool IsSimpleShift(Type left, Type right)
		{
			if (left.IsInteger())
			{
				return right.GetNonNullableType() == typeof(int);
			}
			return false;
		}

		private static Type GetResultTypeOfShift(Type left, Type right)
		{
			if (!left.IsNullableType() && right.IsNullableType())
			{
				return typeof(Nullable<>).MakeGenericType(left);
			}
			return left;
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression LeftShift(Expression left, Expression right)
		{
			return LeftShift(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the left-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression LeftShift(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (IsSimpleShift(left.Type, right.Type))
				{
					Type resultTypeOfShift = GetResultTypeOfShift(left.Type, right.Type);
					return new SimpleBinaryExpression(ExpressionType.LeftShift, left, right, resultTypeOfShift);
				}
				return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.LeftShift, "op_LeftShift", left, right, liftToNull: true);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.LeftShift, left, right, method, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression LeftShiftAssign(Expression left, Expression right)
		{
			return LeftShiftAssign(left, right, null, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method)
		{
			return LeftShiftAssign(left, right, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise left-shift assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.LeftShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		public static BinaryExpression LeftShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (IsSimpleShift(left.Type, right.Type))
				{
					if (conversion != null)
					{
						throw Error.ConversionIsNotSupportedForArithmeticTypes();
					}
					Type resultTypeOfShift = GetResultTypeOfShift(left.Type, right.Type);
					return new SimpleBinaryExpression(ExpressionType.LeftShiftAssign, left, right, resultTypeOfShift);
				}
				return GetUserDefinedAssignOperatorOrThrow(ExpressionType.LeftShiftAssign, "op_LeftShift", left, right, conversion, liftToNull: true);
			}
			return GetMethodBasedAssignOperator(ExpressionType.LeftShiftAssign, left, right, method, conversion, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression RightShift(Expression left, Expression right)
		{
			return RightShift(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShift" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the right-shift operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression RightShift(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (IsSimpleShift(left.Type, right.Type))
				{
					Type resultTypeOfShift = GetResultTypeOfShift(left.Type, right.Type);
					return new SimpleBinaryExpression(ExpressionType.RightShift, left, right, resultTypeOfShift);
				}
				return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.RightShift, "op_RightShift", left, right, liftToNull: true);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.RightShift, left, right, method, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression RightShiftAssign(Expression left, Expression right)
		{
			return RightShiftAssign(left, right, null, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method)
		{
			return RightShiftAssign(left, right, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise right-shift assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RightShiftAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		public static BinaryExpression RightShiftAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (IsSimpleShift(left.Type, right.Type))
				{
					if (conversion != null)
					{
						throw Error.ConversionIsNotSupportedForArithmeticTypes();
					}
					Type resultTypeOfShift = GetResultTypeOfShift(left.Type, right.Type);
					return new SimpleBinaryExpression(ExpressionType.RightShiftAssign, left, right, resultTypeOfShift);
				}
				return GetUserDefinedAssignOperatorOrThrow(ExpressionType.RightShiftAssign, "op_RightShift", left, right, conversion, liftToNull: true);
			}
			return GetMethodBasedAssignOperator(ExpressionType.RightShiftAssign, left, right, method, conversion, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation.</summary>
		/// <param name="left">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression And(Expression left, Expression right)
		{
			return And(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="AND" /> operation. The implementing method can be specified.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.And" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="AND" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression And(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsIntegerOrBool())
				{
					return new SimpleBinaryExpression(ExpressionType.And, left, right, left.Type);
				}
				return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.And, "op_BitwiseAnd", left, right, liftToNull: true);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.And, left, right, method, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression AndAssign(Expression left, Expression right)
		{
			return AndAssign(left, right, null, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method)
		{
			return AndAssign(left, right, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise AND assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.AndAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		public static BinaryExpression AndAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsIntegerOrBool())
				{
					if (conversion != null)
					{
						throw Error.ConversionIsNotSupportedForArithmeticTypes();
					}
					return new SimpleBinaryExpression(ExpressionType.AndAssign, left, right, left.Type);
				}
				return GetUserDefinedAssignOperatorOrThrow(ExpressionType.AndAssign, "op_BitwiseAnd", left, right, conversion, liftToNull: true);
			}
			return GetMethodBasedAssignOperator(ExpressionType.AndAssign, left, right, method, conversion, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression Or(Expression left, Expression right)
		{
			return Or(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="OR" /> operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Or" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the bitwise <see langword="OR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression Or(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsIntegerOrBool())
				{
					return new SimpleBinaryExpression(ExpressionType.Or, left, right, left.Type);
				}
				return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.Or, "op_BitwiseOr", left, right, liftToNull: true);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Or, left, right, method, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression OrAssign(Expression left, Expression right)
		{
			return OrAssign(left, right, null, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method)
		{
			return OrAssign(left, right, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise OR assignment operation.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.OrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		public static BinaryExpression OrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsIntegerOrBool())
				{
					if (conversion != null)
					{
						throw Error.ConversionIsNotSupportedForArithmeticTypes();
					}
					return new SimpleBinaryExpression(ExpressionType.OrAssign, left, right, left.Type);
				}
				return GetUserDefinedAssignOperatorOrThrow(ExpressionType.OrAssign, "op_BitwiseOr", left, right, conversion, liftToNull: true);
			}
			return GetMethodBasedAssignOperator(ExpressionType.OrAssign, left, right, method, conversion, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using op_ExclusiveOr for user-defined types.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression ExclusiveOr(Expression left, Expression right)
		{
			return ExclusiveOr(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise <see langword="XOR" /> operation, using op_ExclusiveOr for user-defined types. The implementing method can be specified.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOr" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the <see langword="XOR" /> operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.</exception>
		public static BinaryExpression ExclusiveOr(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsIntegerOrBool())
				{
					return new SimpleBinaryExpression(ExpressionType.ExclusiveOr, left, right, left.Type);
				}
				return GetUserDefinedBinaryOperatorOrThrow(ExpressionType.ExclusiveOr, "op_ExclusiveOr", left, right, liftToNull: true);
			}
			return GetMethodBasedBinaryOperator(ExpressionType.ExclusiveOr, left, right, method, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using op_ExclusiveOr for user-defined types.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right)
		{
			return ExclusiveOrAssign(left, right, null, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using op_ExclusiveOr for user-defined types.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method)
		{
			return ExclusiveOrAssign(left, right, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents a bitwise XOR assignment operation, using op_ExclusiveOr for user-defined types.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ExclusiveOrAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		public static BinaryExpression ExclusiveOrAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (left.Type == right.Type && left.Type.IsIntegerOrBool())
				{
					if (conversion != null)
					{
						throw Error.ConversionIsNotSupportedForArithmeticTypes();
					}
					return new SimpleBinaryExpression(ExpressionType.ExclusiveOrAssign, left, right, left.Type);
				}
				return GetUserDefinedAssignOperatorOrThrow(ExpressionType.ExclusiveOrAssign, "op_ExclusiveOr", left, right, conversion, liftToNull: true);
			}
			return GetMethodBasedAssignOperator(ExpressionType.ExclusiveOrAssign, left, right, method, conversion, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.-or-
		///         <paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</exception>
		public static BinaryExpression Power(Expression left, Expression right)
		{
			return Power(left, right, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising a number to a power.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Power" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="left" /> or <paramref name="right" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly two arguments.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the exponentiation operator is not defined for <paramref name="left" />.Type and <paramref name="right" />.Type.-or-
		///         <paramref name="method" /> is <see langword="null" /> and <paramref name="left" />.Type and/or <paramref name="right" />.Type are not <see cref="T:System.Double" />.</exception>
		public static BinaryExpression Power(Expression left, Expression right, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				if (!(left.Type == right.Type) || !left.Type.IsArithmetic())
				{
					string name = "op_Exponent";
					BinaryExpression userDefinedBinaryOperator = GetUserDefinedBinaryOperator(ExpressionType.Power, name, left, right, liftToNull: true);
					if (userDefinedBinaryOperator == null)
					{
						name = "op_Exponentiation";
						userDefinedBinaryOperator = GetUserDefinedBinaryOperator(ExpressionType.Power, name, left, right, liftToNull: true);
						if (userDefinedBinaryOperator == null)
						{
							throw Error.BinaryOperatorNotDefined(ExpressionType.Power, left.Type, right.Type);
						}
					}
					ParameterInfo[] parametersCached = userDefinedBinaryOperator.Method.GetParametersCached();
					ValidateParamswithOperandsOrThrow(parametersCached[0].ParameterType, left.Type, ExpressionType.Power, name);
					ValidateParamswithOperandsOrThrow(parametersCached[1].ParameterType, right.Type, ExpressionType.Power, name);
					return userDefinedBinaryOperator;
				}
				method = CachedReflectionInfo.Math_Pow_Double_Double;
			}
			return GetMethodBasedBinaryOperator(ExpressionType.Power, left, right, method, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		public static BinaryExpression PowerAssign(Expression left, Expression right)
		{
			return PowerAssign(left, right, null, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> properties set to the specified values.</returns>
		public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method)
		{
			return PowerAssign(left, right, method, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents raising an expression to a power and assigning the result back to the expression.</summary>
		/// <param name="left">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="right">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Method" /> property equal to.</param>
		/// <param name="conversion">A <see cref="T:System.Linq.Expressions.LambdaExpression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.PowerAssign" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Right" />, <see cref="P:System.Linq.Expressions.BinaryExpression.Method" />, and <see cref="P:System.Linq.Expressions.BinaryExpression.Conversion" /> properties set to the specified values.</returns>
		public static BinaryExpression PowerAssign(Expression left, Expression right, MethodInfo method, LambdaExpression conversion)
		{
			ExpressionUtils.RequiresCanRead(left, "left");
			RequiresCanWrite(left, "left");
			ExpressionUtils.RequiresCanRead(right, "right");
			if (method == null)
			{
				method = CachedReflectionInfo.Math_Pow_Double_Double;
				if (method == null)
				{
					throw Error.BinaryOperatorNotDefined(ExpressionType.PowerAssign, left.Type, right.Type);
				}
			}
			return GetMethodBasedAssignOperator(ExpressionType.PowerAssign, left, right, method, conversion, liftToNull: true);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BinaryExpression" /> that represents applying an array index operator to an array of rank one.</summary>
		/// <param name="array">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> property equal to.</param>
		/// <param name="index">A <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.BinaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayIndex" /> and the <see cref="P:System.Linq.Expressions.BinaryExpression.Left" /> and <see cref="P:System.Linq.Expressions.BinaryExpression.Right" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="array" /> or <paramref name="index" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="array" />.Type does not represent an array type.-or-
		///         <paramref name="array" />.Type represents an array type whose rank is not 1.-or-
		///         <paramref name="index" />.Type does not represent the <see cref="T:System.Int32" /> type.</exception>
		public static BinaryExpression ArrayIndex(Expression array, Expression index)
		{
			ExpressionUtils.RequiresCanRead(array, "array");
			ExpressionUtils.RequiresCanRead(index, "index");
			if (index.Type != typeof(int))
			{
				throw Error.ArgumentMustBeArrayIndexType("index");
			}
			Type type = array.Type;
			if (!type.IsArray)
			{
				throw Error.ArgumentMustBeArray("array");
			}
			if (type.GetArrayRank() != 1)
			{
				throw Error.IncorrectNumberOfIndexes();
			}
			return new SimpleBinaryExpression(ExpressionType.ArrayIndex, array, index, type.GetElementType());
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains two expressions and has no variables.</summary>
		/// <param name="arg0">The first expression in the block.</param>
		/// <param name="arg1">The second expression in the block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
		public static BlockExpression Block(Expression arg0, Expression arg1)
		{
			ExpressionUtils.RequiresCanRead(arg0, "arg0");
			ExpressionUtils.RequiresCanRead(arg1, "arg1");
			return new Block2(arg0, arg1);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains three expressions and has no variables.</summary>
		/// <param name="arg0">The first expression in the block.</param>
		/// <param name="arg1">The second expression in the block.</param>
		/// <param name="arg2">The third expression in the block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
		public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2)
		{
			ExpressionUtils.RequiresCanRead(arg0, "arg0");
			ExpressionUtils.RequiresCanRead(arg1, "arg1");
			ExpressionUtils.RequiresCanRead(arg2, "arg2");
			return new Block3(arg0, arg1, arg2);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains four expressions and has no variables.</summary>
		/// <param name="arg0">The first expression in the block.</param>
		/// <param name="arg1">The second expression in the block.</param>
		/// <param name="arg2">The third expression in the block.</param>
		/// <param name="arg3">The fourth expression in the block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
		public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3)
		{
			ExpressionUtils.RequiresCanRead(arg0, "arg0");
			ExpressionUtils.RequiresCanRead(arg1, "arg1");
			ExpressionUtils.RequiresCanRead(arg2, "arg2");
			ExpressionUtils.RequiresCanRead(arg3, "arg3");
			return new Block4(arg0, arg1, arg2, arg3);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains five expressions and has no variables.</summary>
		/// <param name="arg0">The first expression in the block.</param>
		/// <param name="arg1">The second expression in the block.</param>
		/// <param name="arg2">The third expression in the block.</param>
		/// <param name="arg3">The fourth expression in the block.</param>
		/// <param name="arg4">The fifth expression in the block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
		public static BlockExpression Block(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4)
		{
			ExpressionUtils.RequiresCanRead(arg0, "arg0");
			ExpressionUtils.RequiresCanRead(arg1, "arg1");
			ExpressionUtils.RequiresCanRead(arg2, "arg2");
			ExpressionUtils.RequiresCanRead(arg3, "arg3");
			ExpressionUtils.RequiresCanRead(arg4, "arg4");
			return new Block5(arg0, arg1, arg2, arg3, arg4);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</summary>
		/// <param name="expressions">The expressions in the block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
		public static BlockExpression Block(params Expression[] expressions)
		{
			ContractUtils.RequiresNotNull(expressions, "expressions");
			RequiresCanRead(expressions, "expressions");
			return GetOptimizedBlockExpression(expressions);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions and has no variables.</summary>
		/// <param name="expressions">The expressions in the block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
		public static BlockExpression Block(IEnumerable<Expression> expressions)
		{
			return Block(EmptyReadOnlyCollection<ParameterExpression>.Instance, expressions);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</summary>
		/// <param name="type">The result type of the block.</param>
		/// <param name="expressions">The expressions in the block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
		public static BlockExpression Block(Type type, params Expression[] expressions)
		{
			ContractUtils.RequiresNotNull(expressions, "expressions");
			return Block(type, (IEnumerable<Expression>)expressions);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given expressions, has no variables and has specific result type.</summary>
		/// <param name="type">The result type of the block.</param>
		/// <param name="expressions">The expressions in the block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
		public static BlockExpression Block(Type type, IEnumerable<Expression> expressions)
		{
			return Block(type, EmptyReadOnlyCollection<ParameterExpression>.Instance, expressions);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</summary>
		/// <param name="variables">The variables in the block.</param>
		/// <param name="expressions">The expressions in the block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
		public static BlockExpression Block(IEnumerable<ParameterExpression> variables, params Expression[] expressions)
		{
			return Block(variables, (IEnumerable<Expression>)expressions);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</summary>
		/// <param name="type">The result type of the block.</param>
		/// <param name="variables">The variables in the block.</param>
		/// <param name="expressions">The expressions in the block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
		public static BlockExpression Block(Type type, IEnumerable<ParameterExpression> variables, params Expression[] expressions)
		{
			return Block(type, variables, (IEnumerable<Expression>)expressions);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</summary>
		/// <param name="variables">The variables in the block.</param>
		/// <param name="expressions">The expressions in the block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
		public static BlockExpression Block(IEnumerable<ParameterExpression> variables, IEnumerable<Expression> expressions)
		{
			ContractUtils.RequiresNotNull(expressions, "expressions");
			ReadOnlyCollection<ParameterExpression> readOnlyCollection = variables.ToReadOnly();
			if (readOnlyCollection.Count == 0)
			{
				IReadOnlyList<Expression> obj = (expressions as IReadOnlyList<Expression>) ?? expressions.ToReadOnly();
				RequiresCanRead(obj, "expressions");
				return GetOptimizedBlockExpression(obj);
			}
			ReadOnlyCollection<Expression> readOnlyCollection2 = expressions.ToReadOnly();
			RequiresCanRead(readOnlyCollection2, "expressions");
			return BlockCore(null, readOnlyCollection, readOnlyCollection2);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.BlockExpression" /> that contains the given variables and expressions.</summary>
		/// <param name="type">The result type of the block.</param>
		/// <param name="variables">The variables in the block.</param>
		/// <param name="expressions">The expressions in the block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.BlockExpression" />.</returns>
		public static BlockExpression Block(Type type, IEnumerable<ParameterExpression> variables, IEnumerable<Expression> expressions)
		{
			ContractUtils.RequiresNotNull(type, "type");
			ContractUtils.RequiresNotNull(expressions, "expressions");
			ReadOnlyCollection<Expression> readOnlyCollection = expressions.ToReadOnly();
			RequiresCanRead(readOnlyCollection, "expressions");
			ReadOnlyCollection<ParameterExpression> readOnlyCollection2 = variables.ToReadOnly();
			if (readOnlyCollection2.Count == 0 && readOnlyCollection.Count != 0)
			{
				int count = readOnlyCollection.Count;
				if (count != 0 && readOnlyCollection[count - 1].Type == type)
				{
					return GetOptimizedBlockExpression(readOnlyCollection);
				}
			}
			return BlockCore(type, readOnlyCollection2, readOnlyCollection);
		}

		private static BlockExpression BlockCore(Type type, ReadOnlyCollection<ParameterExpression> variables, ReadOnlyCollection<Expression> expressions)
		{
			ValidateVariables(variables, "variables");
			if (type != null)
			{
				if (expressions.Count == 0)
				{
					if (type != typeof(void))
					{
						throw Error.ArgumentTypesMustMatch();
					}
					return new ScopeWithType(variables, expressions, type);
				}
				Expression expression = expressions.Last();
				if (type != typeof(void) && !TypeUtils.AreReferenceAssignable(type, expression.Type))
				{
					throw Error.ArgumentTypesMustMatch();
				}
				if (!TypeUtils.AreEquivalent(type, expression.Type))
				{
					return new ScopeWithType(variables, expressions, type);
				}
			}
			return expressions.Count switch
			{
				0 => new ScopeWithType(variables, expressions, typeof(void)), 
				1 => new Scope1(variables, expressions[0]), 
				_ => new ScopeN(variables, expressions), 
			};
		}

		internal static void ValidateVariables(ReadOnlyCollection<ParameterExpression> varList, string collectionName)
		{
			int count = varList.Count;
			if (count == 0)
			{
				return;
			}
			HashSet<ParameterExpression> hashSet = new HashSet<ParameterExpression>();
			for (int i = 0; i < count; i++)
			{
				ParameterExpression parameterExpression = varList[i];
				ContractUtils.RequiresNotNull(parameterExpression, collectionName, i);
				if (parameterExpression.IsByRef)
				{
					throw Error.VariableMustNotBeByRef(parameterExpression, parameterExpression.Type, collectionName, i);
				}
				if (!hashSet.Add(parameterExpression))
				{
					throw Error.DuplicateVariable(parameterExpression, collectionName, i);
				}
			}
		}

		private static BlockExpression GetOptimizedBlockExpression(IReadOnlyList<Expression> expressions)
		{
			switch (expressions.Count)
			{
			case 0:
				return BlockCore(typeof(void), EmptyReadOnlyCollection<ParameterExpression>.Instance, EmptyReadOnlyCollection<Expression>.Instance);
			case 2:
				return new Block2(expressions[0], expressions[1]);
			case 3:
				return new Block3(expressions[0], expressions[1], expressions[2]);
			case 4:
				return new Block4(expressions[0], expressions[1], expressions[2], expressions[3]);
			case 5:
				return new Block5(expressions[0], expressions[1], expressions[2], expressions[3], expressions[4]);
			default:
			{
				IReadOnlyList<Expression> readOnlyList = expressions as ReadOnlyCollection<Expression>;
				return new BlockN(readOnlyList ?? expressions.ToArray());
			}
			}
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement.</summary>
		/// <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</param>
		/// <param name="body">The body of the catch statement.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
		public static CatchBlock Catch(Type type, Expression body)
		{
			return MakeCatchBlock(type, null, body, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with a reference to the caught <see cref="T:System.Exception" /> object for use in the handler body.</summary>
		/// <param name="variable">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</param>
		/// <param name="body">The body of the catch statement.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
		public static CatchBlock Catch(ParameterExpression variable, Expression body)
		{
			ContractUtils.RequiresNotNull(variable, "variable");
			return MakeCatchBlock(variable.Type, variable, body, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter but no reference to the caught <see cref="T:System.Exception" /> object.</summary>
		/// <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</param>
		/// <param name="body">The body of the catch statement.</param>
		/// <param name="filter">The body of the <see cref="T:System.Exception" /> filter.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
		public static CatchBlock Catch(Type type, Expression body, Expression filter)
		{
			return MakeCatchBlock(type, null, body, filter);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with an <see cref="T:System.Exception" /> filter and a reference to the caught <see cref="T:System.Exception" /> object.</summary>
		/// <param name="variable">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</param>
		/// <param name="body">The body of the catch statement.</param>
		/// <param name="filter">The body of the <see cref="T:System.Exception" /> filter.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
		public static CatchBlock Catch(ParameterExpression variable, Expression body, Expression filter)
		{
			ContractUtils.RequiresNotNull(variable, "variable");
			return MakeCatchBlock(variable.Type, variable, body, filter);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.CatchBlock" /> representing a catch statement with the specified elements.</summary>
		/// <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of <see cref="T:System.Exception" /> this <see cref="T:System.Linq.Expressions.CatchBlock" /> will handle.</param>
		/// <param name="variable">A <see cref="T:System.Linq.Expressions.ParameterExpression" /> representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</param>
		/// <param name="body">The body of the catch statement.</param>
		/// <param name="filter">The body of the <see cref="T:System.Exception" /> filter.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.CatchBlock" />.</returns>
		public static CatchBlock MakeCatchBlock(Type type, ParameterExpression variable, Expression body, Expression filter)
		{
			ContractUtils.RequiresNotNull(type, "type");
			ContractUtils.Requires(variable == null || TypeUtils.AreEquivalent(variable.Type, type), "variable");
			if (variable == null)
			{
				TypeUtils.ValidateType(type, "type");
			}
			else if (variable.IsByRef)
			{
				throw Error.VariableMustNotBeByRef(variable, variable.Type, "variable");
			}
			ExpressionUtils.RequiresCanRead(body, "body");
			if (filter != null)
			{
				ExpressionUtils.RequiresCanRead(filter, "filter");
				if (filter.Type != typeof(bool))
				{
					throw Error.ArgumentMustBeBoolean("filter");
				}
			}
			return new CatchBlock(type, variable, body, filter);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</summary>
		/// <param name="test">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</param>
		/// <param name="ifTrue">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</param>
		/// <param name="ifFalse">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="test" /> or <paramref name="ifTrue" /> or <paramref name="ifFalse" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="test" />.Type is not <see cref="T:System.Boolean" />.-or-
		///         <paramref name="ifTrue" />.Type is not equal to <paramref name="ifFalse" />.Type.</exception>
		public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse)
		{
			ExpressionUtils.RequiresCanRead(test, "test");
			ExpressionUtils.RequiresCanRead(ifTrue, "ifTrue");
			ExpressionUtils.RequiresCanRead(ifFalse, "ifFalse");
			if (test.Type != typeof(bool))
			{
				throw Error.ArgumentMustBeBoolean("test");
			}
			if (!TypeUtils.AreEquivalent(ifTrue.Type, ifFalse.Type))
			{
				throw Error.ArgumentTypesMustMatch();
			}
			return ConditionalExpression.Make(test, ifTrue, ifFalse, ifTrue.Type);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional statement.</summary>
		/// <param name="test">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</param>
		/// <param name="ifTrue">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</param>
		/// <param name="ifFalse">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</param>
		/// <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values.</returns>
		public static ConditionalExpression Condition(Expression test, Expression ifTrue, Expression ifFalse, Type type)
		{
			ExpressionUtils.RequiresCanRead(test, "test");
			ExpressionUtils.RequiresCanRead(ifTrue, "ifTrue");
			ExpressionUtils.RequiresCanRead(ifFalse, "ifFalse");
			ContractUtils.RequiresNotNull(type, "type");
			if (test.Type != typeof(bool))
			{
				throw Error.ArgumentMustBeBoolean("test");
			}
			if (type != typeof(void) && (!TypeUtils.AreReferenceAssignable(type, ifTrue.Type) || !TypeUtils.AreReferenceAssignable(type, ifFalse.Type)))
			{
				throw Error.ArgumentTypesMustMatch();
			}
			return ConditionalExpression.Make(test, ifTrue, ifFalse, type);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with an <see langword="if" /> statement.</summary>
		/// <param name="test">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</param>
		/// <param name="ifTrue">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, properties set to the specified values. The <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property is set to default expression and the type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</returns>
		public static ConditionalExpression IfThen(Expression test, Expression ifTrue)
		{
			return Condition(test, ifTrue, Empty(), typeof(void));
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that represents a conditional block with <see langword="if" /> and <see langword="else" /> statements.</summary>
		/// <param name="test">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property equal to.</param>
		/// <param name="ifTrue">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" /> property equal to.</param>
		/// <param name="ifFalse">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ConditionalExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Conditional" /> and the <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" />, <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />, and <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> properties set to the specified values. The type of the resulting <see cref="T:System.Linq.Expressions.ConditionalExpression" /> returned by this method is <see cref="T:System.Void" />.</returns>
		public static ConditionalExpression IfThenElse(Expression test, Expression ifTrue, Expression ifFalse)
		{
			return Condition(test, ifTrue, ifFalse, typeof(void));
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</summary>
		/// <param name="value">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property set to the specified value.</returns>
		public static ConstantExpression Constant(object value)
		{
			return new ConstantExpression(value);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</summary>
		/// <param name="value">An <see cref="T:System.Object" /> to set the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> property equal to.</param>
		/// <param name="type">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ConstantExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Constant" /> and the <see cref="P:System.Linq.Expressions.ConstantExpression.Value" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="type" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="value" /> is not <see langword="null" /> and <paramref name="type" /> is not assignable from the dynamic type of <paramref name="value" />.</exception>
		public static ConstantExpression Constant(object value, Type type)
		{
			ContractUtils.RequiresNotNull(type, "type");
			TypeUtils.ValidateType(type, "type");
			if (value == null)
			{
				if (type == typeof(object))
				{
					return new ConstantExpression(null);
				}
				if (!type.IsValueType || type.IsNullableType())
				{
					return new TypedConstantExpression(null, type);
				}
			}
			else
			{
				Type type2 = value.GetType();
				if (type == type2)
				{
					return new ConstantExpression(value);
				}
				if (type.IsAssignableFrom(type2))
				{
					return new TypedConstantExpression(value, type);
				}
			}
			throw Error.ArgumentTypesMustMatch();
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> with the specified span.</summary>
		/// <param name="document">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</param>
		/// <param name="startLine">The start line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Must be greater than 0.</param>
		/// <param name="startColumn">The start column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Must be greater than 0.</param>
		/// <param name="endLine">The end line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. Must be greater or equal than the start line.</param>
		/// <param name="endColumn">The end column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />. If the end line is the same as the start line, it must be greater or equal than the start column. In any case, must be greater than 0.</param>
		/// <returns>An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</returns>
		public static DebugInfoExpression DebugInfo(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn)
		{
			ContractUtils.RequiresNotNull(document, "document");
			if (startLine == 16707566 && startColumn == 0 && endLine == 16707566 && endColumn == 0)
			{
				return new ClearDebugInfoExpression(document);
			}
			ValidateSpan(startLine, startColumn, endLine, endColumn);
			return new SpanDebugInfoExpression(document, startLine, startColumn, endLine, endColumn);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearing a sequence point.</summary>
		/// <param name="document">The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</param>
		/// <returns>An instance of <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> for clearning a sequence point.</returns>
		public static DebugInfoExpression ClearDebugInfo(SymbolDocumentInfo document)
		{
			ContractUtils.RequiresNotNull(document, "document");
			return new ClearDebugInfoExpression(document);
		}

		private static void ValidateSpan(int startLine, int startColumn, int endLine, int endColumn)
		{
			if (startLine < 1)
			{
				throw Error.OutOfRange("startLine", 1);
			}
			if (startColumn < 1)
			{
				throw Error.OutOfRange("startColumn", 1);
			}
			if (endLine < 1)
			{
				throw Error.OutOfRange("endLine", 1);
			}
			if (endColumn < 1)
			{
				throw Error.OutOfRange("endColumn", 1);
			}
			if (startLine > endLine)
			{
				throw Error.StartEndMustBeOrdered();
			}
			if (startLine == endLine && startColumn > endColumn)
			{
				throw Error.StartEndMustBeOrdered();
			}
		}

		/// <summary>Creates an empty expression that has <see cref="T:System.Void" /> type.</summary>
		/// <returns>A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <see cref="T:System.Void" />.</returns>
		public static DefaultExpression Empty()
		{
			return new DefaultExpression(typeof(void));
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</summary>
		/// <param name="type">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DefaultExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Default" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to the specified type.</returns>
		public static DefaultExpression Default(Type type)
		{
			ContractUtils.RequiresNotNull(type, "type");
			TypeUtils.ValidateType(type, "type");
			return new DefaultExpression(type);
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an array of values as the second argument.</summary>
		/// <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</param>
		/// <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</param>
		/// <returns>An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The method that addMethod represents is not named "Add" (case insensitive).-or-The method that addMethod represents is not an instance method.-or-arguments does not contain the same number of elements as the number of parameters for the method that addMethod represents.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</exception>
		public static ElementInit ElementInit(MethodInfo addMethod, params Expression[] arguments)
		{
			return ElementInit(addMethod, (IEnumerable<Expression>)arguments);
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.ElementInit" />, given an <see cref="T:System.Collections.Generic.IEnumerable`1" /> as the second argument.</summary>
		/// <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> property equal to.</param>
		/// <param name="arguments">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to set the <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property equal to.</param>
		/// <returns>An <see cref="T:System.Linq.Expressions.ElementInit" /> that has the <see cref="P:System.Linq.Expressions.ElementInit.AddMethod" /> and <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="addMethod" /> or <paramref name="arguments" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The method that <paramref name="addMethod" /> represents is not named "Add" (case insensitive).-or-The method that <paramref name="addMethod" /> represents is not an instance method.-or-
		///         <paramref name="arguments" /> does not contain the same number of elements as the number of parameters for the method that <paramref name="addMethod" /> represents.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the method that <paramref name="addMethod" /> represents.</exception>
		public static ElementInit ElementInit(MethodInfo addMethod, IEnumerable<Expression> arguments)
		{
			ContractUtils.RequiresNotNull(addMethod, "addMethod");
			ContractUtils.RequiresNotNull(arguments, "arguments");
			ReadOnlyCollection<Expression> arguments2 = arguments.ToReadOnly();
			RequiresCanRead(arguments2, "arguments");
			ValidateElementInitAddMethodInfo(addMethod, "addMethod");
			ValidateArgumentTypes(addMethod, ExpressionType.Call, ref arguments2, "addMethod");
			return new ElementInit(addMethod, arguments2);
		}

		private static void ValidateElementInitAddMethodInfo(MethodInfo addMethod, string paramName)
		{
			ValidateMethodInfo(addMethod, paramName);
			ParameterInfo[] parametersCached = addMethod.GetParametersCached();
			if (parametersCached.Length == 0)
			{
				throw Error.ElementInitializerMethodWithZeroArgs(paramName);
			}
			if (!addMethod.Name.Equals("Add", StringComparison.OrdinalIgnoreCase))
			{
				throw Error.ElementInitializerMethodNotAdd(paramName);
			}
			if (addMethod.IsStatic)
			{
				throw Error.ElementInitializerMethodStatic(paramName);
			}
			ParameterInfo[] array = parametersCached;
			foreach (ParameterInfo parameterInfo in array)
			{
				if (parameterInfo.ParameterType.IsByRef)
				{
					throw Error.ElementInitializerMethodNoRefOutParam(parameterInfo.Name, addMethod.Name, paramName);
				}
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Linq.Expressions.Expression" /> class.</summary>
		/// <param name="nodeType">The <see cref="T:System.Linq.Expressions.ExpressionType" /> to set as the node type.</param>
		/// <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" /> of this <see cref="T:System.Linq.Expressions.Expression" />.</param>
		[Obsolete("use a different constructor that does not take ExpressionType. Then override NodeType and Type properties to provide the values that would be specified to this constructor.")]
		protected Expression(ExpressionType nodeType, Type type)
		{
			if (s_legacyCtorSupportTable == null)
			{
				Interlocked.CompareExchange(ref s_legacyCtorSupportTable, new ConditionalWeakTable<Expression, ExtensionInfo>(), null);
			}
			s_legacyCtorSupportTable.Add(this, new ExtensionInfo(nodeType, type));
		}

		/// <summary>Constructs a new instance of <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		protected Expression()
		{
		}

		/// <summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
		/// <returns>The reduced expression.</returns>
		public virtual Expression Reduce()
		{
			if (CanReduce)
			{
				throw Error.ReducibleMustOverrideReduce();
			}
			return this;
		}

		/// <summary>Reduces the node and then calls the visitor delegate on the reduced expression. The method throws an exception if the node is not reducible.</summary>
		/// <param name="visitor">An instance of <see cref="T:System.Func`2" />.</param>
		/// <returns>The expression being visited, or an expression which should replace it in the tree.</returns>
		protected internal virtual Expression VisitChildren(ExpressionVisitor visitor)
		{
			if (!CanReduce)
			{
				throw Error.MustBeReducible();
			}
			return visitor.Visit(ReduceAndCheck());
		}

		/// <summary>Dispatches to the specific visit method for this node type. For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
		/// <param name="visitor">The visitor to visit this node with.</param>
		/// <returns>The result of visiting this node.</returns>
		protected internal virtual Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitExtension(this);
		}

		/// <summary>Reduces this node to a simpler expression. If CanReduce returns true, this should return a valid expression. This method can return another node which itself must be reduced.</summary>
		/// <returns>The reduced expression.</returns>
		public Expression ReduceAndCheck()
		{
			if (!CanReduce)
			{
				throw Error.MustBeReducible();
			}
			Expression expression = Reduce();
			if (expression == null || expression == this)
			{
				throw Error.MustReduceToDifferent();
			}
			if (!TypeUtils.AreReferenceAssignable(Type, expression.Type))
			{
				throw Error.ReducedNotCompatible();
			}
			return expression;
		}

		/// <summary>Reduces the expression to a known node type (that is not an Extension node) or just returns the expression if it is already a known type.</summary>
		/// <returns>The reduced expression.</returns>
		public Expression ReduceExtensions()
		{
			Expression expression = this;
			while (expression.NodeType == ExpressionType.Extension)
			{
				expression = expression.ReduceAndCheck();
			}
			return expression;
		}

		/// <summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		/// <returns>A textual representation of the <see cref="T:System.Linq.Expressions.Expression" />.</returns>
		public override string ToString()
		{
			return ExpressionStringBuilder.ExpressionToString(this);
		}

		private static void RequiresCanRead(IReadOnlyList<Expression> items, string paramName)
		{
			int i = 0;
			for (int count = items.Count; i < count; i++)
			{
				ExpressionUtils.RequiresCanRead(items[i], paramName, i);
			}
		}

		private static void RequiresCanWrite(Expression expression, string paramName)
		{
			if (expression == null)
			{
				throw new ArgumentNullException(paramName);
			}
			switch (expression.NodeType)
			{
			case ExpressionType.Index:
			{
				PropertyInfo indexer = ((IndexExpression)expression).Indexer;
				if (indexer == null || indexer.CanWrite)
				{
					return;
				}
				break;
			}
			case ExpressionType.MemberAccess:
			{
				MemberInfo member = ((MemberExpression)expression).Member;
				PropertyInfo propertyInfo = member as PropertyInfo;
				if (propertyInfo != null)
				{
					if (propertyInfo.CanWrite)
					{
						return;
					}
					break;
				}
				FieldInfo fieldInfo = (FieldInfo)member;
				if (!fieldInfo.IsInitOnly && !fieldInfo.IsLiteral)
				{
					return;
				}
				break;
			}
			case ExpressionType.Parameter:
				return;
			}
			throw Error.ExpressionMustBeWriteable(paramName);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="returnType">The result type of the dynamic expression.</param>
		/// <param name="arguments">The arguments to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable<Expression> arguments)
		{
			return DynamicExpression.Dynamic(binder, returnType, arguments);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="returnType">The result type of the dynamic expression.</param>
		/// <param name="arg0">The first argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0)
		{
			return DynamicExpression.Dynamic(binder, returnType, arg0);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="returnType">The result type of the dynamic expression.</param>
		/// <param name="arg0">The first argument to the dynamic operation.</param>
		/// <param name="arg1">The second argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1)
		{
			return DynamicExpression.Dynamic(binder, returnType, arg0, arg1);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="returnType">The result type of the dynamic expression.</param>
		/// <param name="arg0">The first argument to the dynamic operation.</param>
		/// <param name="arg1">The second argument to the dynamic operation.</param>
		/// <param name="arg2">The third argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2)
		{
			return DynamicExpression.Dynamic(binder, returnType, arg0, arg1, arg2);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="returnType">The result type of the dynamic expression.</param>
		/// <param name="arg0">The first argument to the dynamic operation.</param>
		/// <param name="arg1">The second argument to the dynamic operation.</param>
		/// <param name="arg2">The third argument to the dynamic operation.</param>
		/// <param name="arg3">The fourth argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
		{
			return DynamicExpression.Dynamic(binder, returnType, arg0, arg1, arg2, arg3);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="returnType">The result type of the dynamic expression.</param>
		/// <param name="arguments">The arguments to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, params Expression[] arguments)
		{
			return DynamicExpression.Dynamic(binder, returnType, arguments);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="arguments">The arguments to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable<Expression> arguments)
		{
			return DynamicExpression.MakeDynamic(delegateType, binder, arguments);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and one argument.</summary>
		/// <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="arg0">The argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0)
		{
			return DynamicExpression.MakeDynamic(delegateType, binder, arg0);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and two arguments.</summary>
		/// <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="arg0">The first argument to the dynamic operation.</param>
		/// <param name="arg1">The second argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1)
		{
			return DynamicExpression.MakeDynamic(delegateType, binder, arg0, arg1);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and three arguments.</summary>
		/// <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="arg0">The first argument to the dynamic operation.</param>
		/// <param name="arg1">The second argument to the dynamic operation.</param>
		/// <param name="arg2">The third argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2)
		{
			return DynamicExpression.MakeDynamic(delegateType, binder, arg0, arg1, arg2);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and four arguments.</summary>
		/// <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="arg0">The first argument to the dynamic operation.</param>
		/// <param name="arg1">The second argument to the dynamic operation.</param>
		/// <param name="arg2">The third argument to the dynamic operation.</param>
		/// <param name="arg3">The fourth argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
		{
			return DynamicExpression.MakeDynamic(delegateType, binder, arg0, arg1, arg2, arg3);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="arguments">The arguments to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.Expression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" /> and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, params Expression[] arguments)
		{
			return MakeDynamic(delegateType, binder, (IEnumerable<Expression>)arguments);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</returns>
		public static GotoExpression Break(LabelTarget target)
		{
			return MakeGoto(GotoExpressionKind.Break, target, null, typeof(void));
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement. The value passed to the label upon jumping can be specified.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <param name="value">The value that will be passed to the associated label upon jumping.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</returns>
		public static GotoExpression Break(LabelTarget target, Expression value)
		{
			return MakeGoto(GotoExpressionKind.Break, target, value, typeof(void));
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <param name="type">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />.</returns>
		public static GotoExpression Break(LabelTarget target, Type type)
		{
			return MakeGoto(GotoExpressionKind.Break, target, null, type);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a break statement with the specified type. The value passed to the label upon jumping can be specified.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <param name="value">The value that will be passed to the associated label upon jumping.</param>
		/// <param name="type">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Break, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</returns>
		public static GotoExpression Break(LabelTarget target, Expression value, Type type)
		{
			return MakeGoto(GotoExpressionKind.Break, target, value, type);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</returns>
		public static GotoExpression Continue(LabelTarget target)
		{
			return MakeGoto(GotoExpressionKind.Continue, target, null, typeof(void));
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a continue statement with the specified type.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <param name="type">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</returns>
		public static GotoExpression Continue(LabelTarget target, Type type)
		{
			return MakeGoto(GotoExpressionKind.Continue, target, null, type);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and a null value to be passed to the target label upon jumping.</returns>
		public static GotoExpression Return(LabelTarget target)
		{
			return MakeGoto(GotoExpressionKind.Return, target, null, typeof(void));
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <param name="type">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Return, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</returns>
		public static GotoExpression Return(LabelTarget target, Type type)
		{
			return MakeGoto(GotoExpressionKind.Return, target, null, type);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement. The value passed to the label upon jumping can be specified.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <param name="value">The value that will be passed to the associated label upon jumping.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</returns>
		public static GotoExpression Return(LabelTarget target, Expression value)
		{
			return MakeGoto(GotoExpressionKind.Return, target, value, typeof(void));
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a return statement with the specified type. The value passed to the label upon jumping can be specified.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <param name="value">The value that will be passed to the associated label upon jumping.</param>
		/// <param name="type">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Continue, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</returns>
		public static GotoExpression Return(LabelTarget target, Expression value, Type type)
		{
			return MakeGoto(GotoExpressionKind.Return, target, value, type);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, and a null value to be passed to the target label upon jumping.</returns>
		public static GotoExpression Goto(LabelTarget target)
		{
			return MakeGoto(GotoExpressionKind.Goto, target, null, typeof(void));
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <param name="type">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to the specified value, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and a null value to be passed to the target label upon jumping.</returns>
		public static GotoExpression Goto(LabelTarget target, Type type)
		{
			return MakeGoto(GotoExpressionKind.Goto, target, null, type);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement. The value passed to the label upon jumping can be specified.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <param name="value">The value that will be passed to the associated label upon jumping.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, and <paramref name="value" /> to be passed to the target label upon jumping.</returns>
		public static GotoExpression Goto(LabelTarget target, Expression value)
		{
			return MakeGoto(GotoExpressionKind.Goto, target, value, typeof(void));
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a "go to" statement with the specified type. The value passed to the label upon jumping can be specified.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <param name="value">The value that will be passed to the associated label upon jumping.</param>
		/// <param name="type">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to Goto, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</returns>
		public static GotoExpression Goto(LabelTarget target, Expression value, Type type)
		{
			return MakeGoto(GotoExpressionKind.Goto, target, value, type);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.GotoExpression" /> representing a jump of the specified <see cref="T:System.Linq.Expressions.GotoExpressionKind" />. The value passed to the label upon jumping can also be specified.</summary>
		/// <param name="kind">The <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> of the <see cref="T:System.Linq.Expressions.GotoExpression" />.</param>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> that the <see cref="T:System.Linq.Expressions.GotoExpression" /> will jump to.</param>
		/// <param name="value">The value that will be passed to the associated label upon jumping.</param>
		/// <param name="type">An <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.GotoExpression" /> with <see cref="P:System.Linq.Expressions.GotoExpression.Kind" /> equal to <paramref name="kind" />, the <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property set to <paramref name="target" />, the <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to <paramref name="type" />, and <paramref name="value" /> to be passed to the target label upon jumping.</returns>
		public static GotoExpression MakeGoto(GotoExpressionKind kind, LabelTarget target, Expression value, Type type)
		{
			ValidateGoto(target, ref value, "target", "value", type);
			return new GotoExpression(kind, target, value, type);
		}

		private static void ValidateGoto(LabelTarget target, ref Expression value, string targetParameter, string valueParameter, Type type)
		{
			ContractUtils.RequiresNotNull(target, targetParameter);
			if (value == null)
			{
				if (target.Type != typeof(void))
				{
					throw Error.LabelMustBeVoidOrHaveExpression("target");
				}
				if (type != null)
				{
					TypeUtils.ValidateType(type, "type");
				}
			}
			else
			{
				ValidateGotoType(target.Type, ref value, valueParameter);
			}
		}

		private static void ValidateGotoType(Type expectedType, ref Expression value, string paramName)
		{
			ExpressionUtils.RequiresCanRead(value, paramName);
			if (expectedType != typeof(void) && !TypeUtils.AreReferenceAssignable(expectedType, value.Type) && !TryQuote(expectedType, ref value))
			{
				throw Error.ExpressionTypeDoesNotMatchLabel(value.Type, expectedType);
			}
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> that represents accessing an indexed property in an object.</summary>
		/// <param name="instance">The object to which the property belongs. It should be null if the property is <see langword="static" /> (<see langword="shared" /> in Visual Basic).</param>
		/// <param name="indexer">An <see cref="T:System.Linq.Expressions.Expression" /> representing the property to index.</param>
		/// <param name="arguments">An IEnumerable&lt;Expression&gt; (IEnumerable (Of Expression) in Visual Basic) that contains the arguments that will be used to index the property.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
		public static IndexExpression MakeIndex(Expression instance, PropertyInfo indexer, IEnumerable<Expression> arguments)
		{
			if (indexer != null)
			{
				return Property(instance, indexer, arguments);
			}
			return ArrayAccess(instance, arguments);
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access an array.</summary>
		/// <param name="array">An expression representing the array to index.</param>
		/// <param name="indexes">An array that contains expressions used to index the array.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
		public static IndexExpression ArrayAccess(Expression array, params Expression[] indexes)
		{
			return ArrayAccess(array, (IEnumerable<Expression>)indexes);
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> to access a multidimensional array.</summary>
		/// <param name="array">An expression that represents the multidimensional array.</param>
		/// <param name="indexes">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing expressions used to index the array.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
		public static IndexExpression ArrayAccess(Expression array, IEnumerable<Expression> indexes)
		{
			ExpressionUtils.RequiresCanRead(array, "array");
			Type type = array.Type;
			if (!type.IsArray)
			{
				throw Error.ArgumentMustBeArray("array");
			}
			ReadOnlyCollection<Expression> readOnlyCollection = indexes.ToReadOnly();
			if (type.GetArrayRank() != readOnlyCollection.Count)
			{
				throw Error.IncorrectNumberOfIndexes();
			}
			foreach (Expression item in readOnlyCollection)
			{
				ExpressionUtils.RequiresCanRead(item, "indexes");
				if (item.Type != typeof(int))
				{
					throw Error.ArgumentMustBeArrayIndexType("indexes");
				}
			}
			return new IndexExpression(array, null, readOnlyCollection);
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</summary>
		/// <param name="instance">The object to which the property belongs. If the property is static/shared, it must be null.</param>
		/// <param name="propertyName">The name of the indexer.</param>
		/// <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
		public static IndexExpression Property(Expression instance, string propertyName, params Expression[] arguments)
		{
			ExpressionUtils.RequiresCanRead(instance, "instance");
			ContractUtils.RequiresNotNull(propertyName, "propertyName");
			PropertyInfo indexer = FindInstanceProperty(instance.Type, propertyName, arguments);
			return MakeIndexProperty(instance, indexer, "propertyName", arguments.ToReadOnly());
		}

		private static PropertyInfo FindInstanceProperty(Type type, string propertyName, Expression[] arguments)
		{
			BindingFlags flags = BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy;
			PropertyInfo propertyInfo = FindProperty(type, propertyName, arguments, flags);
			if (propertyInfo == null)
			{
				flags = BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy;
				propertyInfo = FindProperty(type, propertyName, arguments, flags);
			}
			if (propertyInfo == null)
			{
				if (arguments == null || arguments.Length == 0)
				{
					throw Error.InstancePropertyWithoutParameterNotDefinedForType(propertyName, type);
				}
				throw Error.InstancePropertyWithSpecifiedParametersNotDefinedForType(propertyName, GetArgTypesString(arguments), type, "propertyName");
			}
			return propertyInfo;
		}

		private static string GetArgTypesString(Expression[] arguments)
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append('(');
			for (int i = 0; i < arguments.Length; i++)
			{
				if (i != 0)
				{
					stringBuilder.Append(", ");
				}
				stringBuilder.Append(arguments[i]?.Type.Name);
			}
			stringBuilder.Append(')');
			return stringBuilder.ToString();
		}

		private static PropertyInfo FindProperty(Type type, string propertyName, Expression[] arguments, BindingFlags flags)
		{
			PropertyInfo propertyInfo = null;
			PropertyInfo[] properties = type.GetProperties(flags);
			foreach (PropertyInfo propertyInfo2 in properties)
			{
				if (propertyInfo2.Name.Equals(propertyName, StringComparison.OrdinalIgnoreCase) && IsCompatible(propertyInfo2, arguments))
				{
					if (!(propertyInfo == null))
					{
						throw Error.PropertyWithMoreThanOneMatch(propertyName, type);
					}
					propertyInfo = propertyInfo2;
				}
			}
			return propertyInfo;
		}

		private static bool IsCompatible(PropertyInfo pi, Expression[] args)
		{
			MethodInfo getMethod = pi.GetGetMethod(nonPublic: true);
			ParameterInfo[] array;
			if (getMethod != null)
			{
				array = getMethod.GetParametersCached();
			}
			else
			{
				getMethod = pi.GetSetMethod(nonPublic: true);
				if (getMethod == null)
				{
					return false;
				}
				array = getMethod.GetParametersCached();
				if (array.Length == 0)
				{
					return false;
				}
				array = array.RemoveLast();
			}
			if (args == null)
			{
				return array.Length == 0;
			}
			if (array.Length != args.Length)
			{
				return false;
			}
			for (int i = 0; i < args.Length; i++)
			{
				if (args[i] == null)
				{
					return false;
				}
				if (!TypeUtils.AreReferenceAssignable(array[i].ParameterType, args[i].Type))
				{
					return false;
				}
			}
			return true;
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</summary>
		/// <param name="instance">The object to which the property belongs. If the property is static/shared, it must be null.</param>
		/// <param name="indexer">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</param>
		/// <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
		public static IndexExpression Property(Expression instance, PropertyInfo indexer, params Expression[] arguments)
		{
			return Property(instance, indexer, (IEnumerable<Expression>)arguments);
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.IndexExpression" /> representing the access to an indexed property.</summary>
		/// <param name="instance">The object to which the property belongs. If the property is static/shared, it must be null.</param>
		/// <param name="indexer">The <see cref="T:System.Reflection.PropertyInfo" /> that represents the property to index.</param>
		/// <param name="arguments">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:System.Linq.Expressions.Expression" /> objects that are used to index the property.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.IndexExpression" />.</returns>
		public static IndexExpression Property(Expression instance, PropertyInfo indexer, IEnumerable<Expression> arguments)
		{
			return MakeIndexProperty(instance, indexer, "indexer", arguments.ToReadOnly());
		}

		private static IndexExpression MakeIndexProperty(Expression instance, PropertyInfo indexer, string paramName, ReadOnlyCollection<Expression> argList)
		{
			ValidateIndexedProperty(instance, indexer, paramName, ref argList);
			return new IndexExpression(instance, indexer, argList);
		}

		private static void ValidateIndexedProperty(Expression instance, PropertyInfo indexer, string paramName, ref ReadOnlyCollection<Expression> argList)
		{
			ContractUtils.RequiresNotNull(indexer, paramName);
			if (indexer.PropertyType.IsByRef)
			{
				throw Error.PropertyCannotHaveRefType(paramName);
			}
			if (indexer.PropertyType == typeof(void))
			{
				throw Error.PropertyTypeCannotBeVoid(paramName);
			}
			ParameterInfo[] array = null;
			MethodInfo getMethod = indexer.GetGetMethod(nonPublic: true);
			if (getMethod != null)
			{
				if (getMethod.ReturnType != indexer.PropertyType)
				{
					throw Error.PropertyTypeMustMatchGetter(paramName);
				}
				array = getMethod.GetParametersCached();
				ValidateAccessor(instance, getMethod, array, ref argList, paramName);
			}
			MethodInfo setMethod = indexer.GetSetMethod(nonPublic: true);
			if (setMethod != null)
			{
				ParameterInfo[] parametersCached = setMethod.GetParametersCached();
				if (parametersCached.Length == 0)
				{
					throw Error.SetterHasNoParams(paramName);
				}
				Type parameterType = parametersCached[^1].ParameterType;
				if (parameterType.IsByRef)
				{
					throw Error.PropertyCannotHaveRefType(paramName);
				}
				if (setMethod.ReturnType != typeof(void))
				{
					throw Error.SetterMustBeVoid(paramName);
				}
				if (indexer.PropertyType != parameterType)
				{
					throw Error.PropertyTypeMustMatchSetter(paramName);
				}
				if (getMethod != null)
				{
					if (getMethod.IsStatic ^ setMethod.IsStatic)
					{
						throw Error.BothAccessorsMustBeStatic(paramName);
					}
					if (array.Length != parametersCached.Length - 1)
					{
						throw Error.IndexesOfSetGetMustMatch(paramName);
					}
					for (int i = 0; i < array.Length; i++)
					{
						if (array[i].ParameterType != parametersCached[i].ParameterType)
						{
							throw Error.IndexesOfSetGetMustMatch(paramName);
						}
					}
				}
				else
				{
					ValidateAccessor(instance, setMethod, parametersCached.RemoveLast(), ref argList, paramName);
				}
			}
			else if (getMethod == null)
			{
				throw Error.PropertyDoesNotHaveAccessor(indexer, paramName);
			}
		}

		private static void ValidateAccessor(Expression instance, MethodInfo method, ParameterInfo[] indexes, ref ReadOnlyCollection<Expression> arguments, string paramName)
		{
			ContractUtils.RequiresNotNull(arguments, "arguments");
			ValidateMethodInfo(method, "method");
			if ((method.CallingConvention & CallingConventions.VarArgs) != 0)
			{
				throw Error.AccessorsCannotHaveVarArgs(paramName);
			}
			if (method.IsStatic)
			{
				if (instance != null)
				{
					throw Error.OnlyStaticPropertiesHaveNullInstance("instance");
				}
			}
			else
			{
				if (instance == null)
				{
					throw Error.OnlyStaticPropertiesHaveNullInstance("instance");
				}
				ExpressionUtils.RequiresCanRead(instance, "instance");
				ValidateCallInstanceType(instance.Type, method);
			}
			ValidateAccessorArgumentTypes(method, indexes, ref arguments, paramName);
		}

		private static void ValidateAccessorArgumentTypes(MethodInfo method, ParameterInfo[] indexes, ref ReadOnlyCollection<Expression> arguments, string paramName)
		{
			if (indexes.Length != 0)
			{
				if (indexes.Length != arguments.Count)
				{
					throw Error.IncorrectNumberOfMethodCallArguments(method, paramName);
				}
				Expression[] array = null;
				int i = 0;
				for (int num = indexes.Length; i < num; i++)
				{
					Expression argument = arguments[i];
					ParameterInfo obj = indexes[i];
					ExpressionUtils.RequiresCanRead(argument, "arguments", i);
					Type parameterType = obj.ParameterType;
					if (parameterType.IsByRef)
					{
						throw Error.AccessorsCannotHaveByRefArgs("indexes", i);
					}
					TypeUtils.ValidateType(parameterType, "indexes", i);
					if (!TypeUtils.AreReferenceAssignable(parameterType, argument.Type) && !TryQuote(parameterType, ref argument))
					{
						throw Error.ExpressionTypeDoesNotMatchMethodParameter(argument.Type, parameterType, method, "arguments", i);
					}
					if (array == null && argument != arguments[i])
					{
						array = new Expression[arguments.Count];
						for (int j = 0; j < i; j++)
						{
							array[j] = arguments[j];
						}
					}
					if (array != null)
					{
						array[i] = argument;
					}
				}
				if (array != null)
				{
					arguments = new TrueReadOnlyCollection<Expression>(array);
				}
			}
			else if (arguments.Count > 0)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(method, paramName);
			}
		}

		internal static InvocationExpression Invoke(Expression expression)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			MethodInfo invokeMethod = GetInvokeMethod(expression);
			ParameterInfo[] parametersForValidation = GetParametersForValidation(invokeMethod, ExpressionType.Invoke);
			ValidateArgumentCount(invokeMethod, ExpressionType.Invoke, 0, parametersForValidation);
			return new InvocationExpression0(expression, invokeMethod.ReturnType);
		}

		internal static InvocationExpression Invoke(Expression expression, Expression arg0)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			MethodInfo invokeMethod = GetInvokeMethod(expression);
			ParameterInfo[] parametersForValidation = GetParametersForValidation(invokeMethod, ExpressionType.Invoke);
			ValidateArgumentCount(invokeMethod, ExpressionType.Invoke, 1, parametersForValidation);
			arg0 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg0, parametersForValidation[0], "expression", "arg0");
			return new InvocationExpression1(expression, invokeMethod.ReturnType, arg0);
		}

		internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			MethodInfo invokeMethod = GetInvokeMethod(expression);
			ParameterInfo[] parametersForValidation = GetParametersForValidation(invokeMethod, ExpressionType.Invoke);
			ValidateArgumentCount(invokeMethod, ExpressionType.Invoke, 2, parametersForValidation);
			arg0 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg0, parametersForValidation[0], "expression", "arg0");
			arg1 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg1, parametersForValidation[1], "expression", "arg1");
			return new InvocationExpression2(expression, invokeMethod.ReturnType, arg0, arg1);
		}

		internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			MethodInfo invokeMethod = GetInvokeMethod(expression);
			ParameterInfo[] parametersForValidation = GetParametersForValidation(invokeMethod, ExpressionType.Invoke);
			ValidateArgumentCount(invokeMethod, ExpressionType.Invoke, 3, parametersForValidation);
			arg0 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg0, parametersForValidation[0], "expression", "arg0");
			arg1 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg1, parametersForValidation[1], "expression", "arg1");
			arg2 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg2, parametersForValidation[2], "expression", "arg2");
			return new InvocationExpression3(expression, invokeMethod.ReturnType, arg0, arg1, arg2);
		}

		internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			MethodInfo invokeMethod = GetInvokeMethod(expression);
			ParameterInfo[] parametersForValidation = GetParametersForValidation(invokeMethod, ExpressionType.Invoke);
			ValidateArgumentCount(invokeMethod, ExpressionType.Invoke, 4, parametersForValidation);
			arg0 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg0, parametersForValidation[0], "expression", "arg0");
			arg1 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg1, parametersForValidation[1], "expression", "arg1");
			arg2 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg2, parametersForValidation[2], "expression", "arg2");
			arg3 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg3, parametersForValidation[3], "expression", "arg3");
			return new InvocationExpression4(expression, invokeMethod.ReturnType, arg0, arg1, arg2, arg3);
		}

		internal static InvocationExpression Invoke(Expression expression, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			MethodInfo invokeMethod = GetInvokeMethod(expression);
			ParameterInfo[] parametersForValidation = GetParametersForValidation(invokeMethod, ExpressionType.Invoke);
			ValidateArgumentCount(invokeMethod, ExpressionType.Invoke, 5, parametersForValidation);
			arg0 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg0, parametersForValidation[0], "expression", "arg0");
			arg1 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg1, parametersForValidation[1], "expression", "arg1");
			arg2 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg2, parametersForValidation[2], "expression", "arg2");
			arg3 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg3, parametersForValidation[3], "expression", "arg3");
			arg4 = ValidateOneArgument(invokeMethod, ExpressionType.Invoke, arg4, parametersForValidation[4], "expression", "arg4");
			return new InvocationExpression5(expression, invokeMethod.ReturnType, arg0, arg1, arg2, arg3, arg4);
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied.</param>
		/// <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</param>
		/// <returns>An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</exception>
		public static InvocationExpression Invoke(Expression expression, params Expression[] arguments)
		{
			return Invoke(expression, (IEnumerable<Expression>)arguments);
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies a delegate or lambda expression to a list of argument expressions.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate or lambda expression to be applied to.</param>
		/// <param name="arguments">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments that the delegate or lambda expression is applied to.</param>
		/// <returns>An <see cref="T:System.Linq.Expressions.InvocationExpression" /> that applies the specified delegate or lambda expression to the provided arguments.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="expression" />.Type does not represent a delegate type or an <see cref="T:System.Linq.Expressions.Expression`1" />.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the delegate represented by <paramref name="expression" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="arguments" /> does not contain the same number of elements as the list of parameters for the delegate represented by <paramref name="expression" />.</exception>
		public static InvocationExpression Invoke(Expression expression, IEnumerable<Expression> arguments)
		{
			IReadOnlyList<Expression> readOnlyList = (arguments as IReadOnlyList<Expression>) ?? arguments.ToReadOnly();
			switch (readOnlyList.Count)
			{
			case 0:
				return Invoke(expression);
			case 1:
				return Invoke(expression, readOnlyList[0]);
			case 2:
				return Invoke(expression, readOnlyList[0], readOnlyList[1]);
			case 3:
				return Invoke(expression, readOnlyList[0], readOnlyList[1], readOnlyList[2]);
			case 4:
				return Invoke(expression, readOnlyList[0], readOnlyList[1], readOnlyList[2], readOnlyList[3]);
			case 5:
				return Invoke(expression, readOnlyList[0], readOnlyList[1], readOnlyList[2], readOnlyList[3], readOnlyList[4]);
			default:
			{
				ExpressionUtils.RequiresCanRead(expression, "expression");
				ReadOnlyCollection<Expression> arguments2 = readOnlyList.ToReadOnly();
				MethodInfo invokeMethod = GetInvokeMethod(expression);
				ValidateArgumentTypes(invokeMethod, ExpressionType.Invoke, ref arguments2, "expression");
				return new InvocationExpressionN(expression, arguments2, invokeMethod.ReturnType);
			}
			}
		}

		internal static MethodInfo GetInvokeMethod(Expression expression)
		{
			Type delegateType = expression.Type;
			if (!expression.Type.IsSubclassOf(typeof(MulticastDelegate)))
			{
				Type type = TypeUtils.FindGenericType(typeof(Expression<>), expression.Type);
				if (type == null)
				{
					throw Error.ExpressionTypeNotInvocable(expression.Type, "expression");
				}
				delegateType = type.GetGenericArguments()[0];
			}
			return delegateType.GetInvokeMethod();
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label without a default value.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.LabelExpression" /> without a default value.</returns>
		public static LabelExpression Label(LabelTarget target)
		{
			return Label(target, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.LabelExpression" /> representing a label with the given default value.</summary>
		/// <param name="target">The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this <see cref="T:System.Linq.Expressions.LabelExpression" /> will be associated with.</param>
		/// <param name="defaultValue">The value of this <see cref="T:System.Linq.Expressions.LabelExpression" /> when the label is reached through regular control flow.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.LabelExpression" /> with the given default value.</returns>
		public static LabelExpression Label(LabelTarget target, Expression defaultValue)
		{
			ValidateGoto(target, ref defaultValue, "target", "defaultValue", null);
			return new LabelExpression(target, defaultValue);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and no name.</summary>
		/// <returns>The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
		public static LabelTarget Label()
		{
			return Label(typeof(void), null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with void type and the given name.</summary>
		/// <param name="name">The name of the label.</param>
		/// <returns>The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
		public static LabelTarget Label(string name)
		{
			return Label(typeof(void), name);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type.</summary>
		/// <param name="type">The type of value that is passed when jumping to the label.</param>
		/// <returns>The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
		public static LabelTarget Label(Type type)
		{
			return Label(type, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.LabelTarget" /> representing a label with the given type and name.</summary>
		/// <param name="type">The type of value that is passed when jumping to the label.</param>
		/// <param name="name">The name of the label.</param>
		/// <returns>The new <see cref="T:System.Linq.Expressions.LabelTarget" />.</returns>
		public static LabelTarget Label(Type type, string name)
		{
			ContractUtils.RequiresNotNull(type, "type");
			TypeUtils.ValidateType(type, "type");
			return new LabelTarget(type, name);
		}

		internal static LambdaExpression CreateLambda(Type delegateType, Expression body, string name, bool tailCall, ReadOnlyCollection<ParameterExpression> parameters)
		{
			CacheDict<Type, Func<Expression, string, bool, ReadOnlyCollection<ParameterExpression>, LambdaExpression>> cacheDict = s_lambdaFactories;
			if (cacheDict == null)
			{
				cacheDict = (s_lambdaFactories = new CacheDict<Type, Func<Expression, string, bool, ReadOnlyCollection<ParameterExpression>, LambdaExpression>>(50));
			}
			if (!cacheDict.TryGetValue(delegateType, out var value))
			{
				MethodInfo method = typeof(Expression<>).MakeGenericType(delegateType).GetMethod("Create", BindingFlags.Static | BindingFlags.NonPublic);
				if (delegateType.IsCollectible)
				{
					return (LambdaExpression)method.Invoke(null, new object[4] { body, name, tailCall, parameters });
				}
				value = (cacheDict[delegateType] = (Func<Expression, string, bool, ReadOnlyCollection<ParameterExpression>, LambdaExpression>)method.CreateDelegate(typeof(Func<Expression, string, bool, ReadOnlyCollection<ParameterExpression>, LambdaExpression>)));
			}
			return value(body, name, tailCall, parameters);
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</summary>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="parameters">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <typeparam name="TDelegate">A delegate type.</typeparam>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="body" /> is <see langword="null" />.-or-One or more elements in <paramref name="parameters" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="TDelegate" /> is not a delegate type.-or-
		///         <paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.-or-
		///         <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</exception>
		public static Expression<TDelegate> Lambda<TDelegate>(Expression body, params ParameterExpression[] parameters)
		{
			return Expression.Lambda<TDelegate>(body, tailCall: false, (IEnumerable<ParameterExpression>)parameters);
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</summary>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="tailCall">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</param>
		/// <param name="parameters">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <typeparam name="TDelegate">The delegate type. </typeparam>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		public static Expression<TDelegate> Lambda<TDelegate>(Expression body, bool tailCall, params ParameterExpression[] parameters)
		{
			return Expression.Lambda<TDelegate>(body, tailCall, (IEnumerable<ParameterExpression>)parameters);
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</summary>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="parameters">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <typeparam name="TDelegate">A delegate type.</typeparam>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="body" /> is <see langword="null" />.-or-One or more elements in <paramref name="parameters" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="TDelegate" /> is not a delegate type.-or-
		///         <paramref name="body" />.Type represents a type that is not assignable to the return type of <paramref name="TDelegate" />.-or-
		///         <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for <paramref name="TDelegate" />.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of <paramref name="TDelegate" />.</exception>
		public static Expression<TDelegate> Lambda<TDelegate>(Expression body, IEnumerable<ParameterExpression> parameters)
		{
			return Lambda<TDelegate>(body, null, tailCall: false, parameters);
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</summary>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="tailCall">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</param>
		/// <param name="parameters">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <typeparam name="TDelegate">The delegate type. </typeparam>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		public static Expression<TDelegate> Lambda<TDelegate>(Expression body, bool tailCall, IEnumerable<ParameterExpression> parameters)
		{
			return Lambda<TDelegate>(body, null, tailCall, parameters);
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</summary>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="name">The name of the lambda. Used for generating debugging information.</param>
		/// <param name="parameters">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <typeparam name="TDelegate">The delegate type. </typeparam>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		public static Expression<TDelegate> Lambda<TDelegate>(Expression body, string name, IEnumerable<ParameterExpression> parameters)
		{
			return Lambda<TDelegate>(body, name, tailCall: false, parameters);
		}

		/// <summary>Creates an <see cref="T:System.Linq.Expressions.Expression`1" /> where the delegate type is known at compile time.</summary>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="name">The name of the lambda. Used for generating debugging info.</param>
		/// <param name="tailCall">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</param>
		/// <param name="parameters">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <typeparam name="TDelegate">The delegate type. </typeparam>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression`1" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		public static Expression<TDelegate> Lambda<TDelegate>(Expression body, string name, bool tailCall, IEnumerable<ParameterExpression> parameters)
		{
			ReadOnlyCollection<ParameterExpression> parameters2 = parameters.ToReadOnly();
			ValidateLambdaArgs(typeof(TDelegate), ref body, parameters2, "TDelegate");
			return (Expression<TDelegate>)CreateLambda(typeof(TDelegate), body, name, tailCall, parameters2);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type.</summary>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="parameters">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="body" /> is <see langword="null" />.-or-One or more elements of <paramref name="parameters" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="parameters" /> contains more than sixteen elements.</exception>
		public static LambdaExpression Lambda(Expression body, params ParameterExpression[] parameters)
		{
			return Lambda(body, tailCall: false, (IEnumerable<ParameterExpression>)parameters);
		}

		/// <summary>Creates a LambdaExpression by first constructing a delegate type.</summary>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="tailCall">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</param>
		/// <param name="parameters">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		public static LambdaExpression Lambda(Expression body, bool tailCall, params ParameterExpression[] parameters)
		{
			return Lambda(body, tailCall, (IEnumerable<ParameterExpression>)parameters);
		}

		/// <summary>Creates a LambdaExpression by first constructing a delegate type.</summary>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="parameters">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		public static LambdaExpression Lambda(Expression body, IEnumerable<ParameterExpression> parameters)
		{
			return Lambda(body, null, tailCall: false, parameters);
		}

		/// <summary>Creates a LambdaExpression by first constructing a delegate type.</summary>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="tailCall">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</param>
		/// <param name="parameters">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		public static LambdaExpression Lambda(Expression body, bool tailCall, IEnumerable<ParameterExpression> parameters)
		{
			return Lambda(body, null, tailCall, parameters);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type. It can be used when the delegate type is not known at compile time.</summary>
		/// <param name="delegateType">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</param>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="parameters">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <returns>An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.-or-One or more elements in <paramref name="parameters" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="delegateType" /> does not represent a delegate type.-or-
		///         <paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.-or-
		///         <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</exception>
		public static LambdaExpression Lambda(Type delegateType, Expression body, params ParameterExpression[] parameters)
		{
			return Lambda(delegateType, body, null, tailCall: false, parameters);
		}

		/// <summary>Creates a LambdaExpression by first constructing a delegate type.</summary>
		/// <param name="delegateType">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</param>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="tailCall">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</param>
		/// <param name="parameters">An array that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, params ParameterExpression[] parameters)
		{
			return Lambda(delegateType, body, null, tailCall, parameters);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.LambdaExpression" /> by first constructing a delegate type. It can be used when the delegate type is not known at compile time.</summary>
		/// <param name="delegateType">A <see cref="T:System.Type" /> that represents a delegate signature for the lambda.</param>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="parameters">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <returns>An object that represents a lambda expression which has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Lambda" /> and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="delegateType" /> or <paramref name="body" /> is <see langword="null" />.-or-One or more elements in <paramref name="parameters" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="delegateType" /> does not represent a delegate type.-or-
		///         <paramref name="body" />.Type represents a type that is not assignable to the return type of the delegate type represented by <paramref name="delegateType" />.-or-
		///         <paramref name="parameters" /> does not contain the same number of elements as the list of parameters for the delegate type represented by <paramref name="delegateType" />.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="parameters" /> is not assignable from the type of the corresponding parameter type of the delegate type represented by <paramref name="delegateType" />.</exception>
		public static LambdaExpression Lambda(Type delegateType, Expression body, IEnumerable<ParameterExpression> parameters)
		{
			return Lambda(delegateType, body, null, tailCall: false, parameters);
		}

		/// <summary>Creates a LambdaExpression by first constructing a delegate type.</summary>
		/// <param name="delegateType">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</param>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="tailCall">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</param>
		/// <param name="parameters">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		public static LambdaExpression Lambda(Type delegateType, Expression body, bool tailCall, IEnumerable<ParameterExpression> parameters)
		{
			return Lambda(delegateType, body, null, tailCall, parameters);
		}

		/// <summary>Creates a LambdaExpression by first constructing a delegate type.</summary>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="name">The name for the lambda. Used for emitting debug information.</param>
		/// <param name="parameters">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		public static LambdaExpression Lambda(Expression body, string name, IEnumerable<ParameterExpression> parameters)
		{
			return Lambda(body, name, tailCall: false, parameters);
		}

		/// <summary>Creates a LambdaExpression by first constructing a delegate type.</summary>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="name">The name for the lambda. Used for emitting debug information.</param>
		/// <param name="tailCall">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression.</param>
		/// <param name="parameters">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		public static LambdaExpression Lambda(Expression body, string name, bool tailCall, IEnumerable<ParameterExpression> parameters)
		{
			ContractUtils.RequiresNotNull(body, "body");
			ReadOnlyCollection<ParameterExpression> readOnlyCollection = parameters.ToReadOnly();
			int count = readOnlyCollection.Count;
			Type[] array = new Type[count + 1];
			if (count > 0)
			{
				HashSet<ParameterExpression> hashSet = new HashSet<ParameterExpression>();
				for (int i = 0; i < count; i++)
				{
					ParameterExpression parameterExpression = readOnlyCollection[i];
					ContractUtils.RequiresNotNull(parameterExpression, "parameter");
					array[i] = (parameterExpression.IsByRef ? parameterExpression.Type.MakeByRefType() : parameterExpression.Type);
					if (!hashSet.Add(parameterExpression))
					{
						throw Error.DuplicateVariable(parameterExpression, "parameters", i);
					}
				}
			}
			array[count] = body.Type;
			return CreateLambda(DelegateHelpers.MakeDelegateType(array), body, name, tailCall, readOnlyCollection);
		}

		/// <summary>Creates a LambdaExpression by first constructing a delegate type.</summary>
		/// <param name="delegateType">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</param>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to.</param>
		/// <param name="name">The name for the lambda. Used for emitting debug information.</param>
		/// <param name="parameters">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		public static LambdaExpression Lambda(Type delegateType, Expression body, string name, IEnumerable<ParameterExpression> parameters)
		{
			ReadOnlyCollection<ParameterExpression> parameters2 = parameters.ToReadOnly();
			ValidateLambdaArgs(delegateType, ref body, parameters2, "delegateType");
			return CreateLambda(delegateType, body, name, tailCall: false, parameters2);
		}

		/// <summary>Creates a LambdaExpression by first constructing a delegate type.</summary>
		/// <param name="delegateType">A <see cref="P:System.Linq.Expressions.Expression.Type" /> representing the delegate signature for the lambda.</param>
		/// <param name="body">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property equal to. </param>
		/// <param name="name">The name for the lambda. Used for emitting debug information.</param>
		/// <param name="tailCall">A <see cref="T:System.Boolean" /> that indicates if tail call optimization will be applied when compiling the created expression. </param>
		/// <param name="parameters">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> collection. </param>
		/// <returns>A <see cref="T:System.Linq.Expressions.LambdaExpression" /> that has the <see cref="P:System.Linq.Expressions.LambdaExpression.NodeType" /> property equal to Lambda and the <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> and <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" /> properties set to the specified values.</returns>
		public static LambdaExpression Lambda(Type delegateType, Expression body, string name, bool tailCall, IEnumerable<ParameterExpression> parameters)
		{
			ReadOnlyCollection<ParameterExpression> parameters2 = parameters.ToReadOnly();
			ValidateLambdaArgs(delegateType, ref body, parameters2, "delegateType");
			return CreateLambda(delegateType, body, name, tailCall, parameters2);
		}

		private static void ValidateLambdaArgs(Type delegateType, ref Expression body, ReadOnlyCollection<ParameterExpression> parameters, string paramName)
		{
			ContractUtils.RequiresNotNull(delegateType, "delegateType");
			ExpressionUtils.RequiresCanRead(body, "body");
			if (!typeof(MulticastDelegate).IsAssignableFrom(delegateType) || delegateType == typeof(MulticastDelegate))
			{
				throw Error.LambdaTypeMustBeDerivedFromSystemDelegate(paramName);
			}
			TypeUtils.ValidateType(delegateType, "delegateType", allowByRef: true, allowPointer: true);
			CacheDict<Type, MethodInfo> cacheDict = s_lambdaDelegateCache;
			if (!cacheDict.TryGetValue(delegateType, out var value))
			{
				value = delegateType.GetInvokeMethod();
				if (!delegateType.IsCollectible)
				{
					cacheDict[delegateType] = value;
				}
			}
			ParameterInfo[] parametersCached = value.GetParametersCached();
			if (parametersCached.Length != 0)
			{
				if (parametersCached.Length != parameters.Count)
				{
					throw Error.IncorrectNumberOfLambdaDeclarationParameters();
				}
				HashSet<ParameterExpression> hashSet = new HashSet<ParameterExpression>();
				int i = 0;
				for (int num = parametersCached.Length; i < num; i++)
				{
					ParameterExpression parameterExpression = parameters[i];
					ParameterInfo obj = parametersCached[i];
					ExpressionUtils.RequiresCanRead(parameterExpression, "parameters", i);
					Type type = obj.ParameterType;
					if (parameterExpression.IsByRef)
					{
						if (!type.IsByRef)
						{
							throw Error.ParameterExpressionNotValidAsDelegate(parameterExpression.Type.MakeByRefType(), type);
						}
						type = type.GetElementType();
					}
					if (!TypeUtils.AreReferenceAssignable(parameterExpression.Type, type))
					{
						throw Error.ParameterExpressionNotValidAsDelegate(parameterExpression.Type, type);
					}
					if (!hashSet.Add(parameterExpression))
					{
						throw Error.DuplicateVariable(parameterExpression, "parameters", i);
					}
				}
			}
			else if (parameters.Count > 0)
			{
				throw Error.IncorrectNumberOfLambdaDeclarationParameters();
			}
			if (value.ReturnType != typeof(void) && !TypeUtils.AreReferenceAssignable(value.ReturnType, body.Type) && !TryQuote(value.ReturnType, ref body))
			{
				throw Error.ExpressionTypeDoesNotMatchReturn(body.Type, value.ReturnType);
			}
		}

		private static TryGetFuncActionArgsResult ValidateTryGetFuncActionArgs(Type[] typeArgs)
		{
			if (typeArgs == null)
			{
				return TryGetFuncActionArgsResult.ArgumentNull;
			}
			foreach (Type type in typeArgs)
			{
				if (type == null)
				{
					return TryGetFuncActionArgsResult.ArgumentNull;
				}
				if (type.IsByRef)
				{
					return TryGetFuncActionArgsResult.ByRef;
				}
				if (type == typeof(void) || type.IsPointer)
				{
					return TryGetFuncActionArgsResult.PointerOrVoid;
				}
			}
			return TryGetFuncActionArgsResult.Valid;
		}

		/// <summary>Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Func delegate type that has specific type arguments. The last type argument specifies the return type of the created delegate.</summary>
		/// <param name="typeArgs">An array of one to seventeen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Func" /> delegate type.</param>
		/// <returns>The type of a System.Func delegate that has the specified type arguments.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="typeArgs" /> contains fewer than one or more than seventeen elements.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="typeArgs" /> is <see langword="null" />.</exception>
		public static Type GetFuncType(params Type[] typeArgs)
		{
			switch (ValidateTryGetFuncActionArgs(typeArgs))
			{
			case TryGetFuncActionArgsResult.ArgumentNull:
				throw new ArgumentNullException("typeArgs");
			case TryGetFuncActionArgsResult.ByRef:
				throw Error.TypeMustNotBeByRef("typeArgs");
			default:
			{
				Type funcType = DelegateHelpers.GetFuncType(typeArgs);
				if (funcType == null)
				{
					throw Error.IncorrectNumberOfTypeArgsForFunc("typeArgs");
				}
				return funcType;
			}
			}
		}

		/// <summary>Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Func delegate type that has specific type arguments. The last type argument specifies the return type of the created delegate.</summary>
		/// <param name="typeArgs">An array of Type objects that specify the type arguments for the System.Func delegate type.</param>
		/// <param name="funcType">When this method returns, contains the generic System.Func delegate type that has specific type arguments. Contains null if there is no generic System.Func delegate that matches the <paramref name="typeArgs" />.This parameter is passed uninitialized.</param>
		/// <returns>true if generic System.Func delegate type was created for specific <paramref name="typeArgs" />; false otherwise.</returns>
		public static bool TryGetFuncType(Type[] typeArgs, out Type funcType)
		{
			if (ValidateTryGetFuncActionArgs(typeArgs) == TryGetFuncActionArgsResult.Valid)
			{
				return (funcType = DelegateHelpers.GetFuncType(typeArgs)) != null;
			}
			funcType = null;
			return false;
		}

		/// <summary>Creates a <see cref="T:System.Type" /> object that represents a generic System.Action delegate type that has specific type arguments.</summary>
		/// <param name="typeArgs">An array of up to sixteen <see cref="T:System.Type" /> objects that specify the type arguments for the <see langword="System.Action" /> delegate type.</param>
		/// <returns>The type of a System.Action delegate that has the specified type arguments.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="typeArgs" /> contains more than sixteen elements.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="typeArgs" /> is <see langword="null" />.</exception>
		public static Type GetActionType(params Type[] typeArgs)
		{
			switch (ValidateTryGetFuncActionArgs(typeArgs))
			{
			case TryGetFuncActionArgsResult.ArgumentNull:
				throw new ArgumentNullException("typeArgs");
			case TryGetFuncActionArgsResult.ByRef:
				throw Error.TypeMustNotBeByRef("typeArgs");
			default:
			{
				Type actionType = DelegateHelpers.GetActionType(typeArgs);
				if (actionType == null)
				{
					throw Error.IncorrectNumberOfTypeArgsForAction("typeArgs");
				}
				return actionType;
			}
			}
		}

		/// <summary>Creates a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Action delegate type that has specific type arguments.</summary>
		/// <param name="typeArgs">An array of Type objects that specify the type arguments for the System.Action delegate type.</param>
		/// <param name="actionType">When this method returns, contains the generic System.Action delegate type that has specific type arguments. Contains null if there is no generic System.Action delegate that matches the <paramref name="typeArgs" />.This parameter is passed uninitialized.</param>
		/// <returns>true if generic System.Action delegate type was created for specific <paramref name="typeArgs" />; false otherwise.</returns>
		public static bool TryGetActionType(Type[] typeArgs, out Type actionType)
		{
			if (ValidateTryGetFuncActionArgs(typeArgs) == TryGetFuncActionArgsResult.Valid)
			{
				return (actionType = DelegateHelpers.GetActionType(typeArgs)) != null;
			}
			actionType = null;
			return false;
		}

		/// <summary>Gets a <see cref="P:System.Linq.Expressions.Expression.Type" /> object that represents a generic System.Func or System.Action delegate type that has specific type arguments.</summary>
		/// <param name="typeArgs">The type arguments of the delegate.</param>
		/// <returns>The delegate type.</returns>
		public static Type GetDelegateType(params Type[] typeArgs)
		{
			ContractUtils.RequiresNotEmpty(typeArgs, "typeArgs");
			ContractUtils.RequiresNotNullItems(typeArgs, "typeArgs");
			return DelegateHelpers.MakeDelegateType(typeArgs);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</summary>
		/// <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</param>
		/// <param name="initializers">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.-or-One or more elements of <paramref name="initializers" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.-or-The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.-or-The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.-or-More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</exception>
		public static ListInitExpression ListInit(NewExpression newExpression, params Expression[] initializers)
		{
			return ListInit(newExpression, (IEnumerable<Expression>)initializers);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a method named "Add" to add elements to a collection.</summary>
		/// <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</param>
		/// <param name="initializers">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.-or-One or more elements of <paramref name="initializers" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">There is no instance method named "Add" (case insensitive) declared in <paramref name="newExpression" />.Type or its base type.-or-The add method on <paramref name="newExpression" />.Type or its base type does not take exactly one argument.-or-The type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the first element of <paramref name="initializers" /> is not assignable to the argument type of the add method on <paramref name="newExpression" />.Type or its base type.-or-More than one argument-compatible method named "Add" (case-insensitive) exists on <paramref name="newExpression" />.Type and/or its base type.</exception>
		public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable<Expression> initializers)
		{
			ContractUtils.RequiresNotNull(newExpression, "newExpression");
			ContractUtils.RequiresNotNull(initializers, "initializers");
			ReadOnlyCollection<Expression> readOnlyCollection = initializers.ToReadOnly();
			if (readOnlyCollection.Count == 0)
			{
				return new ListInitExpression(newExpression, EmptyReadOnlyCollection<System.Linq.Expressions.ElementInit>.Instance);
			}
			MethodInfo addMethod = FindMethod(newExpression.Type, "Add", null, new Expression[1] { readOnlyCollection[0] }, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
			return ListInit(newExpression, addMethod, readOnlyCollection);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</summary>
		/// <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</param>
		/// <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method that takes one argument, that adds an element to a collection.</param>
		/// <param name="initializers">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.-or-One or more elements of <paramref name="initializers" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.-or-
		///         <paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.-or-
		///         <paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</exception>
		public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, params Expression[] initializers)
		{
			return ListInit(newExpression, addMethod, (IEnumerable<Expression>)initializers);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses a specified method to add elements to a collection.</summary>
		/// <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</param>
		/// <param name="addMethod">A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method named "Add" (case insensitive), that adds an element to a collection.</param>
		/// <param name="initializers">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property set to the specified value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.-or-One or more elements of <paramref name="initializers" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.-or-
		///         <paramref name="addMethod" /> is not <see langword="null" /> and it does not represent an instance method named "Add" (case insensitive) that takes exactly one argument.-or-
		///         <paramref name="addMethod" /> is not <see langword="null" /> and the type represented by the <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="initializers" /> is not assignable to the argument type of the method that <paramref name="addMethod" /> represents.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="addMethod" /> is <see langword="null" /> and no instance method named "Add" that takes one type-compatible argument exists on <paramref name="newExpression" />.Type or its base type.</exception>
		public static ListInitExpression ListInit(NewExpression newExpression, MethodInfo addMethod, IEnumerable<Expression> initializers)
		{
			if (addMethod == null)
			{
				return ListInit(newExpression, initializers);
			}
			ContractUtils.RequiresNotNull(newExpression, "newExpression");
			ContractUtils.RequiresNotNull(initializers, "initializers");
			ReadOnlyCollection<Expression> readOnlyCollection = initializers.ToReadOnly();
			ElementInit[] array = new ElementInit[readOnlyCollection.Count];
			for (int i = 0; i < readOnlyCollection.Count; i++)
			{
				array[i] = ElementInit(addMethod, readOnlyCollection[i]);
			}
			return ListInit(newExpression, new TrueReadOnlyCollection<ElementInit>(array));
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</summary>
		/// <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</param>
		/// <param name="initializers">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.-or-One or more elements of <paramref name="initializers" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</exception>
		public static ListInitExpression ListInit(NewExpression newExpression, params ElementInit[] initializers)
		{
			return ListInit(newExpression, (IEnumerable<ElementInit>)initializers);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ListInitExpression" /> that uses specified <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection.</summary>
		/// <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property equal to.</param>
		/// <param name="initializers">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ListInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ListInit" /> and the <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="newExpression" /> or <paramref name="initializers" /> is <see langword="null" />.-or-One or more elements of <paramref name="initializers" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="newExpression" />.Type does not implement <see cref="T:System.Collections.IEnumerable" />.</exception>
		public static ListInitExpression ListInit(NewExpression newExpression, IEnumerable<ElementInit> initializers)
		{
			ContractUtils.RequiresNotNull(newExpression, "newExpression");
			ContractUtils.RequiresNotNull(initializers, "initializers");
			ReadOnlyCollection<ElementInit> initializers2 = initializers.ToReadOnly();
			ValidateListInitArgs(newExpression.Type, initializers2, "newExpression");
			return new ListInitExpression(newExpression, initializers2);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</summary>
		/// <param name="body">The body of the loop.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
		public static LoopExpression Loop(Expression body)
		{
			return Loop(body, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body and break target.</summary>
		/// <param name="body">The body of the loop.</param>
		/// <param name="break">The break target used by the loop body.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
		public static LoopExpression Loop(Expression body, LabelTarget @break)
		{
			return Loop(body, @break, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.LoopExpression" /> with the given body.</summary>
		/// <param name="body">The body of the loop.</param>
		/// <param name="break">The break target used by the loop body.</param>
		/// <param name="continue">The continue target used by the loop body.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.LoopExpression" />.</returns>
		public static LoopExpression Loop(Expression body, LabelTarget @break, LabelTarget @continue)
		{
			ExpressionUtils.RequiresCanRead(body, "body");
			if (@continue != null && @continue.Type != typeof(void))
			{
				throw Error.LabelTypeMustBeVoid("continue");
			}
			return new LoopExpression(body, @break, @continue);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a field or property.</summary>
		/// <param name="member">A <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</param>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="member" /> or <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="member" /> does not represent a field or property.-or-The property represented by <paramref name="member" /> does not have a <see langword="set" /> accessor.-or-
		///         <paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</exception>
		public static MemberAssignment Bind(MemberInfo member, Expression expression)
		{
			ContractUtils.RequiresNotNull(member, "member");
			ExpressionUtils.RequiresCanRead(expression, "expression");
			ValidateSettableFieldOrPropertyMember(member, out var memberType);
			if (!memberType.IsAssignableFrom(expression.Type))
			{
				throw Error.ArgumentTypesMustMatch();
			}
			return new MemberAssignment(member, expression);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberAssignment" /> that represents the initialization of a member by using a property accessor method.</summary>
		/// <param name="propertyAccessor">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</param>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberAssignment" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.Assignment" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and the <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property set to <paramref name="expression" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="propertyAccessor" /> or <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="propertyAccessor" /> does not represent a property accessor method.-or-The property accessed by <paramref name="propertyAccessor" /> does not have a <see langword="set" /> accessor.-or-
		///         <paramref name="expression" />.Type is not assignable to the type of the field or property that <paramref name="member" /> represents.</exception>
		public static MemberAssignment Bind(MethodInfo propertyAccessor, Expression expression)
		{
			ContractUtils.RequiresNotNull(propertyAccessor, "propertyAccessor");
			ContractUtils.RequiresNotNull(expression, "expression");
			ValidateMethodInfo(propertyAccessor, "propertyAccessor");
			return Bind(GetProperty(propertyAccessor, "propertyAccessor"), expression);
		}

		private static void ValidateSettableFieldOrPropertyMember(MemberInfo member, out Type memberType)
		{
			Type declaringType = member.DeclaringType;
			if (declaringType == null)
			{
				throw Error.NotAMemberOfAnyType(member, "member");
			}
			TypeUtils.ValidateType(declaringType, null);
			if (!(member is PropertyInfo propertyInfo))
			{
				if (!(member is FieldInfo fieldInfo))
				{
					throw Error.ArgumentMustBeFieldInfoOrPropertyInfo("member");
				}
				memberType = fieldInfo.FieldType;
			}
			else
			{
				if (!propertyInfo.CanWrite)
				{
					throw Error.PropertyDoesNotHaveSetter(propertyInfo, "member");
				}
				memberType = propertyInfo.PropertyType;
			}
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to. For <see langword="static" /> (<see langword="Shared" /> in Visual Basic), <paramref name="expression" /> must be <see langword="null" />.</param>
		/// <param name="field">The <see cref="T:System.Reflection.FieldInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="field" /> is <see langword="null" />.-or-The field represented by <paramref name="field" /> is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="expression" />.Type is not assignable to the declaring type of the field represented by <paramref name="field" />.</exception>
		public static MemberExpression Field(Expression expression, FieldInfo field)
		{
			ContractUtils.RequiresNotNull(field, "field");
			if (field.IsStatic)
			{
				if (expression != null)
				{
					throw Error.OnlyStaticFieldsHaveNullInstance("expression");
				}
			}
			else
			{
				if (expression == null)
				{
					throw Error.OnlyStaticFieldsHaveNullInstance("field");
				}
				ExpressionUtils.RequiresCanRead(expression, "expression");
				if (!TypeUtils.AreReferenceAssignable(field.DeclaringType, expression.Type))
				{
					throw Error.FieldInfoNotDefinedForType(field.DeclaringType, field.Name, expression.Type);
				}
			}
			return MemberExpression.Make(expression, field);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field given the name of the field.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a field named <paramref name="fieldName" />. This can be null for static fields.</param>
		/// <param name="fieldName">The name of a field to be accessed.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.FieldInfo" /> that represents the field denoted by <paramref name="fieldName" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> or <paramref name="fieldName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">No field named <paramref name="fieldName" /> is defined in <paramref name="expression" />.Type or its base types.</exception>
		public static MemberExpression Field(Expression expression, string fieldName)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			ContractUtils.RequiresNotNull(fieldName, "fieldName");
			FieldInfo fieldInfo = expression.Type.GetField(fieldName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy) ?? expression.Type.GetField(fieldName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy);
			if (fieldInfo == null)
			{
				throw Error.InstanceFieldNotDefinedForType(fieldName, expression.Type);
			}
			return Field(expression, fieldInfo);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a field.</summary>
		/// <param name="expression">The containing object of the field. This can be null for static fields.</param>
		/// <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the field.</param>
		/// <param name="fieldName">The field to be accessed.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
		public static MemberExpression Field(Expression expression, Type type, string fieldName)
		{
			ContractUtils.RequiresNotNull(type, "type");
			FieldInfo fieldInfo = type.GetField(fieldName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy) ?? type.GetField(fieldName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy);
			if (fieldInfo == null)
			{
				throw Error.FieldNotDefinedForType(fieldName, type);
			}
			return Field(expression, fieldInfo);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property named <paramref name="propertyName" />. This can be <see langword="null" /> for static properties.</param>
		/// <param name="propertyName">The name of a property to be accessed.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property denoted by <paramref name="propertyName" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> or <paramref name="propertyName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">No property named <paramref name="propertyName" /> is defined in <paramref name="expression" />.Type or its base types.</exception>
		public static MemberExpression Property(Expression expression, string propertyName)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			ContractUtils.RequiresNotNull(propertyName, "propertyName");
			PropertyInfo propertyInfo = expression.Type.GetProperty(propertyName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy) ?? expression.Type.GetProperty(propertyName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy);
			if (propertyInfo == null)
			{
				throw Error.InstancePropertyNotDefinedForType(propertyName, expression.Type, "propertyName");
			}
			return Property(expression, propertyInfo);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> accessing a property.</summary>
		/// <param name="expression">The containing object of the property. This can be null for static properties.</param>
		/// <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" /> that contains the property.</param>
		/// <param name="propertyName">The property to be accessed.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.MemberExpression" />.</returns>
		public static MemberExpression Property(Expression expression, Type type, string propertyName)
		{
			ContractUtils.RequiresNotNull(type, "type");
			ContractUtils.RequiresNotNull(propertyName, "propertyName");
			PropertyInfo propertyInfo = type.GetProperty(propertyName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy) ?? type.GetProperty(propertyName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy);
			if (propertyInfo == null)
			{
				throw Error.PropertyNotDefinedForType(propertyName, type, "propertyName");
			}
			return Property(expression, propertyInfo);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to. This can be null for static properties.</param>
		/// <param name="property">The <see cref="T:System.Reflection.PropertyInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> and <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="property" /> is <see langword="null" />.-or-The property that <paramref name="property" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="expression" />.Type is not assignable to the declaring type of the property that <paramref name="property" /> represents.</exception>
		public static MemberExpression Property(Expression expression, PropertyInfo property)
		{
			ContractUtils.RequiresNotNull(property, "property");
			MethodInfo methodInfo = property.GetGetMethod(nonPublic: true);
			if (methodInfo == null)
			{
				methodInfo = property.GetSetMethod(nonPublic: true);
				if (methodInfo == null)
				{
					throw Error.PropertyDoesNotHaveAccessor(property, "property");
				}
				if (methodInfo.GetParametersCached().Length != 1)
				{
					throw Error.IncorrectNumberOfMethodCallArguments(methodInfo, "property");
				}
			}
			else if (methodInfo.GetParametersCached().Length != 0)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(methodInfo, "property");
			}
			if (methodInfo.IsStatic)
			{
				if (expression != null)
				{
					throw Error.OnlyStaticPropertiesHaveNullInstance("expression");
				}
			}
			else
			{
				if (expression == null)
				{
					throw Error.OnlyStaticPropertiesHaveNullInstance("property");
				}
				ExpressionUtils.RequiresCanRead(expression, "expression");
				if (!TypeUtils.IsValidInstanceType(property, expression.Type))
				{
					throw Error.PropertyNotDefinedForType(property, expression.Type, "property");
				}
			}
			ValidateMethodInfo(methodInfo, "property");
			return MemberExpression.Make(expression, property);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property by using a property accessor method.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property equal to. This can be null for static properties.</param>
		/// <param name="propertyAccessor">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" /> and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="propertyAccessor" /> is <see langword="null" />.-or-The method that <paramref name="propertyAccessor" /> represents is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic) and <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="expression" />.Type is not assignable to the declaring type of the method represented by <paramref name="propertyAccessor" />.-or-The method that <paramref name="propertyAccessor" /> represents is not a property accessor method.</exception>
		public static MemberExpression Property(Expression expression, MethodInfo propertyAccessor)
		{
			ContractUtils.RequiresNotNull(propertyAccessor, "propertyAccessor");
			ValidateMethodInfo(propertyAccessor, "propertyAccessor");
			return Property(expression, GetProperty(propertyAccessor, "propertyAccessor"));
		}

		private static PropertyInfo GetProperty(MethodInfo mi, string paramName, int index = -1)
		{
			Type declaringType = mi.DeclaringType;
			if (declaringType != null)
			{
				BindingFlags bindingFlags = BindingFlags.Public | BindingFlags.NonPublic;
				bindingFlags = (BindingFlags)((int)bindingFlags | (mi.IsStatic ? 8 : 4));
				PropertyInfo[] properties = declaringType.GetProperties(bindingFlags);
				foreach (PropertyInfo propertyInfo in properties)
				{
					if (propertyInfo.CanRead && CheckMethod(mi, propertyInfo.GetGetMethod(nonPublic: true)))
					{
						return propertyInfo;
					}
					if (propertyInfo.CanWrite && CheckMethod(mi, propertyInfo.GetSetMethod(nonPublic: true)))
					{
						return propertyInfo;
					}
				}
			}
			throw Error.MethodNotPropertyAccessor(mi.DeclaringType, mi.Name, paramName, index);
		}

		private static bool CheckMethod(MethodInfo method, MethodInfo propertyMethod)
		{
			if (method.Equals(propertyMethod))
			{
				return true;
			}
			Type declaringType = method.DeclaringType;
			if (declaringType.IsInterface && method.Name == propertyMethod.Name && declaringType.GetMethod(method.Name) == propertyMethod)
			{
				return true;
			}
			return false;
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing a property or field.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> contains a property or field named <paramref name="propertyOrFieldName" />. This can be null for static members.</param>
		/// <param name="propertyOrFieldName">The name of a property or field to be accessed.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberAccess" />, the <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property set to <paramref name="expression" />, and the <see cref="P:System.Linq.Expressions.MemberExpression.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> or <see cref="T:System.Reflection.FieldInfo" /> that represents the property or field denoted by <paramref name="propertyOrFieldName" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> or <paramref name="propertyOrFieldName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">No property or field named <paramref name="propertyOrFieldName" /> is defined in <paramref name="expression" />.Type or its base types.</exception>
		public static MemberExpression PropertyOrField(Expression expression, string propertyOrFieldName)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			PropertyInfo property = expression.Type.GetProperty(propertyOrFieldName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);
			if (property != null)
			{
				return Property(expression, property);
			}
			FieldInfo field = expression.Type.GetField(propertyOrFieldName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy);
			if (field != null)
			{
				return Field(expression, field);
			}
			property = expression.Type.GetProperty(propertyOrFieldName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy);
			if (property != null)
			{
				return Property(expression, property);
			}
			field = expression.Type.GetField(propertyOrFieldName, BindingFlags.IgnoreCase | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy);
			if (field != null)
			{
				return Field(expression, field);
			}
			throw Error.NotAMemberOfType(propertyOrFieldName, expression.Type, "propertyOrFieldName");
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberExpression" /> that represents accessing either a field or a property.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the object that the member belongs to. This can be null for static members.</param>
		/// <param name="member">The <see cref="T:System.Reflection.MemberInfo" /> that describes the field or property to be accessed.</param>
		/// <returns>The <see cref="T:System.Linq.Expressions.MemberExpression" /> that results from calling the appropriate factory method.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="member" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="member" /> does not represent a field or property.</exception>
		public static MemberExpression MakeMemberAccess(Expression expression, MemberInfo member)
		{
			ContractUtils.RequiresNotNull(member, "member");
			FieldInfo fieldInfo = member as FieldInfo;
			if (fieldInfo != null)
			{
				return Field(expression, fieldInfo);
			}
			PropertyInfo propertyInfo = member as PropertyInfo;
			if (propertyInfo != null)
			{
				return Property(expression, propertyInfo);
			}
			throw Error.MemberNotFieldOrProperty(member, "member");
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
		/// <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</param>
		/// <param name="bindings">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</exception>
		public static MemberInitExpression MemberInit(NewExpression newExpression, params MemberBinding[] bindings)
		{
			return MemberInit(newExpression, (IEnumerable<MemberBinding>)bindings);
		}

		/// <summary>Represents an expression that creates a new object and initializes a property of the object.</summary>
		/// <param name="newExpression">A <see cref="T:System.Linq.Expressions.NewExpression" /> to set the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property equal to.</param>
		/// <param name="bindings">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberInitExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.MemberInit" /> and the <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> and <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="newExpression" /> or <paramref name="bindings" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type that <paramref name="newExpression" />.Type represents.</exception>
		public static MemberInitExpression MemberInit(NewExpression newExpression, IEnumerable<MemberBinding> bindings)
		{
			ContractUtils.RequiresNotNull(newExpression, "newExpression");
			ContractUtils.RequiresNotNull(bindings, "bindings");
			ReadOnlyCollection<MemberBinding> bindings2 = bindings.ToReadOnly();
			ValidateMemberInitArgs(newExpression.Type, bindings2);
			return new MemberInitExpression(newExpression, bindings2);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</summary>
		/// <param name="member">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</param>
		/// <param name="initializers">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="member" /> is <see langword="null" />. -or-One or more elements of <paramref name="initializers" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="member" /> does not represent a field or property.-or-The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</exception>
		public static MemberListBinding ListBind(MemberInfo member, params ElementInit[] initializers)
		{
			return ListBind(member, (IEnumerable<ElementInit>)initializers);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> where the member is a field or property.</summary>
		/// <param name="member">A <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</param>
		/// <param name="initializers">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="member" /> is <see langword="null" />. -or-One or more elements of <paramref name="initializers" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="member" /> does not represent a field or property.-or-The <see cref="P:System.Reflection.FieldInfo.FieldType" /> or <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the field or property that <paramref name="member" /> represents does not implement <see cref="T:System.Collections.IEnumerable" />.</exception>
		public static MemberListBinding ListBind(MemberInfo member, IEnumerable<ElementInit> initializers)
		{
			ContractUtils.RequiresNotNull(member, "member");
			ContractUtils.RequiresNotNull(initializers, "initializers");
			ValidateGettableFieldOrPropertyMember(member, out var memberType);
			ReadOnlyCollection<ElementInit> initializers2 = initializers.ToReadOnly();
			ValidateListInitArgs(memberType, initializers2, "member");
			return new MemberListBinding(member, initializers2);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> object based on a specified property accessor method.</summary>
		/// <param name="propertyAccessor">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</param>
		/// <param name="initializers">An array of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="propertyAccessor" /> is <see langword="null" />. -or-One or more elements of <paramref name="initializers" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="propertyAccessor" /> does not represent a property accessor method.-or-The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</exception>
		public static MemberListBinding ListBind(MethodInfo propertyAccessor, params ElementInit[] initializers)
		{
			return ListBind(propertyAccessor, (IEnumerable<ElementInit>)initializers);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberListBinding" /> based on a specified property accessor method.</summary>
		/// <param name="propertyAccessor">A <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</param>
		/// <param name="initializers">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.ElementInit" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberListBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.ListBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.MemberInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> populated with the elements of <paramref name="initializers" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="propertyAccessor" /> is <see langword="null" />. -or-One or more elements of <paramref name="initializers" /> are <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="propertyAccessor" /> does not represent a property accessor method.-or-The <see cref="P:System.Reflection.PropertyInfo.PropertyType" /> of the property that the method represented by <paramref name="propertyAccessor" /> accesses does not implement <see cref="T:System.Collections.IEnumerable" />.</exception>
		public static MemberListBinding ListBind(MethodInfo propertyAccessor, IEnumerable<ElementInit> initializers)
		{
			ContractUtils.RequiresNotNull(propertyAccessor, "propertyAccessor");
			ContractUtils.RequiresNotNull(initializers, "initializers");
			return ListBind(GetProperty(propertyAccessor, "propertyAccessor"), initializers);
		}

		private static void ValidateListInitArgs(Type listType, ReadOnlyCollection<ElementInit> initializers, string listTypeParamName)
		{
			if (!typeof(IEnumerable).IsAssignableFrom(listType))
			{
				throw Error.TypeNotIEnumerable(listType, listTypeParamName);
			}
			int i = 0;
			for (int count = initializers.Count; i < count; i++)
			{
				ElementInit elementInit = initializers[i];
				ContractUtils.RequiresNotNull(elementInit, "initializers", i);
				ValidateCallInstanceType(listType, elementInit.AddMethod);
			}
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</summary>
		/// <param name="member">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</param>
		/// <param name="bindings">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="member" /> does not represent a field or property.-or-The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</exception>
		public static MemberMemberBinding MemberBind(MemberInfo member, params MemberBinding[] bindings)
		{
			return MemberBind(member, (IEnumerable<MemberBinding>)bindings);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a field or property.</summary>
		/// <param name="member">The <see cref="T:System.Reflection.MemberInfo" /> to set the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property equal to.</param>
		/// <param name="bindings">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" /> and the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="member" /> or <paramref name="bindings" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="member" /> does not represent a field or property.-or-The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the field or property that <paramref name="member" /> represents.</exception>
		public static MemberMemberBinding MemberBind(MemberInfo member, IEnumerable<MemberBinding> bindings)
		{
			ContractUtils.RequiresNotNull(member, "member");
			ContractUtils.RequiresNotNull(bindings, "bindings");
			ReadOnlyCollection<MemberBinding> bindings2 = bindings.ToReadOnly();
			ValidateGettableFieldOrPropertyMember(member, out var memberType);
			ValidateMemberInitArgs(memberType, bindings2);
			return new MemberMemberBinding(member, bindings2);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</summary>
		/// <param name="propertyAccessor">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</param>
		/// <param name="bindings">An array of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="propertyAccessor" /> does not represent a property accessor method.-or-The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</exception>
		public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, params MemberBinding[] bindings)
		{
			return MemberBind(propertyAccessor, (IEnumerable<MemberBinding>)bindings);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that represents the recursive initialization of members of a member that is accessed by using a property accessor method.</summary>
		/// <param name="propertyAccessor">The <see cref="T:System.Reflection.MethodInfo" /> that represents a property accessor method.</param>
		/// <param name="bindings">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.MemberBinding" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MemberMemberBinding" /> that has the <see cref="P:System.Linq.Expressions.MemberBinding.BindingType" /> property equal to <see cref="F:System.Linq.Expressions.MemberBindingType.MemberBinding" />, the <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property set to the <see cref="T:System.Reflection.PropertyInfo" /> that represents the property accessed in <paramref name="propertyAccessor" />, and <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="propertyAccessor" /> or <paramref name="bindings" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="propertyAccessor" /> does not represent a property accessor method.-or-The <see cref="P:System.Linq.Expressions.MemberBinding.Member" /> property of an element of <paramref name="bindings" /> does not represent a member of the type of the property accessed by the method that <paramref name="propertyAccessor" /> represents.</exception>
		public static MemberMemberBinding MemberBind(MethodInfo propertyAccessor, IEnumerable<MemberBinding> bindings)
		{
			ContractUtils.RequiresNotNull(propertyAccessor, "propertyAccessor");
			return MemberBind(GetProperty(propertyAccessor, "propertyAccessor"), bindings);
		}

		private static void ValidateGettableFieldOrPropertyMember(MemberInfo member, out Type memberType)
		{
			Type declaringType = member.DeclaringType;
			if (declaringType == null)
			{
				throw Error.NotAMemberOfAnyType(member, "member");
			}
			TypeUtils.ValidateType(declaringType, null, allowByRef: true, allowPointer: true);
			if (!(member is PropertyInfo propertyInfo))
			{
				if (!(member is FieldInfo fieldInfo))
				{
					throw Error.ArgumentMustBeFieldInfoOrPropertyInfo("member");
				}
				memberType = fieldInfo.FieldType;
			}
			else
			{
				if (!propertyInfo.CanRead)
				{
					throw Error.PropertyDoesNotHaveGetter(propertyInfo, "member");
				}
				memberType = propertyInfo.PropertyType;
			}
		}

		private static void ValidateMemberInitArgs(Type type, ReadOnlyCollection<MemberBinding> bindings)
		{
			int i = 0;
			for (int count = bindings.Count; i < count; i++)
			{
				MemberBinding memberBinding = bindings[i];
				ContractUtils.RequiresNotNull(memberBinding, "bindings");
				memberBinding.ValidateAsDefinedHere(i);
				if (!memberBinding.Member.DeclaringType.IsAssignableFrom(type))
				{
					throw Error.NotAMemberOfType(memberBinding.Member.Name, type, "bindings", i);
				}
			}
		}

		internal static MethodCallExpression Call(MethodInfo method)
		{
			ContractUtils.RequiresNotNull(method, "method");
			ParameterInfo[] pis = ValidateMethodAndGetParameters(null, method);
			ValidateArgumentCount(method, ExpressionType.Call, 0, pis);
			return new MethodCallExpression0(method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that takes one argument.</summary>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</param>
		/// <param name="arg0">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="method" /> is null.</exception>
		public static MethodCallExpression Call(MethodInfo method, Expression arg0)
		{
			ContractUtils.RequiresNotNull(method, "method");
			ContractUtils.RequiresNotNull(arg0, "arg0");
			ParameterInfo[] array = ValidateMethodAndGetParameters(null, method);
			ValidateArgumentCount(method, ExpressionType.Call, 1, array);
			arg0 = ValidateOneArgument(method, ExpressionType.Call, arg0, array[0], "method", "arg0");
			return new MethodCallExpression1(method, arg0);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes two arguments.</summary>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</param>
		/// <param name="arg0">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</param>
		/// <param name="arg1">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="method" /> is null.</exception>
		public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1)
		{
			ContractUtils.RequiresNotNull(method, "method");
			ContractUtils.RequiresNotNull(arg0, "arg0");
			ContractUtils.RequiresNotNull(arg1, "arg1");
			ParameterInfo[] array = ValidateMethodAndGetParameters(null, method);
			ValidateArgumentCount(method, ExpressionType.Call, 2, array);
			arg0 = ValidateOneArgument(method, ExpressionType.Call, arg0, array[0], "method", "arg0");
			arg1 = ValidateOneArgument(method, ExpressionType.Call, arg1, array[1], "method", "arg1");
			return new MethodCallExpression2(method, arg0, arg1);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes three arguments.</summary>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</param>
		/// <param name="arg0">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</param>
		/// <param name="arg1">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</param>
		/// <param name="arg2">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="method" /> is null.</exception>
		public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2)
		{
			ContractUtils.RequiresNotNull(method, "method");
			ContractUtils.RequiresNotNull(arg0, "arg0");
			ContractUtils.RequiresNotNull(arg1, "arg1");
			ContractUtils.RequiresNotNull(arg2, "arg2");
			ParameterInfo[] array = ValidateMethodAndGetParameters(null, method);
			ValidateArgumentCount(method, ExpressionType.Call, 3, array);
			arg0 = ValidateOneArgument(method, ExpressionType.Call, arg0, array[0], "method", "arg0");
			arg1 = ValidateOneArgument(method, ExpressionType.Call, arg1, array[1], "method", "arg1");
			arg2 = ValidateOneArgument(method, ExpressionType.Call, arg2, array[2], "method", "arg2");
			return new MethodCallExpression3(method, arg0, arg1, arg2);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes four arguments.</summary>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</param>
		/// <param name="arg0">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</param>
		/// <param name="arg1">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</param>
		/// <param name="arg2">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</param>
		/// <param name="arg3">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="method" /> is null.</exception>
		public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
		{
			ContractUtils.RequiresNotNull(method, "method");
			ContractUtils.RequiresNotNull(arg0, "arg0");
			ContractUtils.RequiresNotNull(arg1, "arg1");
			ContractUtils.RequiresNotNull(arg2, "arg2");
			ContractUtils.RequiresNotNull(arg3, "arg3");
			ParameterInfo[] array = ValidateMethodAndGetParameters(null, method);
			ValidateArgumentCount(method, ExpressionType.Call, 4, array);
			arg0 = ValidateOneArgument(method, ExpressionType.Call, arg0, array[0], "method", "arg0");
			arg1 = ValidateOneArgument(method, ExpressionType.Call, arg1, array[1], "method", "arg1");
			arg2 = ValidateOneArgument(method, ExpressionType.Call, arg2, array[2], "method", "arg2");
			arg3 = ValidateOneArgument(method, ExpressionType.Call, arg3, array[3], "method", "arg3");
			return new MethodCallExpression4(method, arg0, arg1, arg2, arg3);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static method that takes five arguments.</summary>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</param>
		/// <param name="arg0">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</param>
		/// <param name="arg1">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</param>
		/// <param name="arg2">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</param>
		/// <param name="arg3">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fourth argument.</param>
		/// <param name="arg4">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the fifth argument.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="method" /> is null.</exception>
		public static MethodCallExpression Call(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4)
		{
			ContractUtils.RequiresNotNull(method, "method");
			ContractUtils.RequiresNotNull(arg0, "arg0");
			ContractUtils.RequiresNotNull(arg1, "arg1");
			ContractUtils.RequiresNotNull(arg2, "arg2");
			ContractUtils.RequiresNotNull(arg3, "arg3");
			ContractUtils.RequiresNotNull(arg4, "arg4");
			ParameterInfo[] array = ValidateMethodAndGetParameters(null, method);
			ValidateArgumentCount(method, ExpressionType.Call, 5, array);
			arg0 = ValidateOneArgument(method, ExpressionType.Call, arg0, array[0], "method", "arg0");
			arg1 = ValidateOneArgument(method, ExpressionType.Call, arg1, array[1], "method", "arg1");
			arg2 = ValidateOneArgument(method, ExpressionType.Call, arg2, array[2], "method", "arg2");
			arg3 = ValidateOneArgument(method, ExpressionType.Call, arg3, array[3], "method", "arg3");
			arg4 = ValidateOneArgument(method, ExpressionType.Call, arg4, array[4], "method", "arg4");
			return new MethodCallExpression5(method, arg0, arg1, arg2, arg3, arg4);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method that has arguments.</summary>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> that represents a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</param>
		/// <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="method" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.-or-One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</exception>
		public static MethodCallExpression Call(MethodInfo method, params Expression[] arguments)
		{
			return Call(null, method, arguments);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a static (Shared in Visual Basic) method.</summary>
		/// <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</param>
		/// <param name="arguments">A collection of <see cref="T:System.Linq.Expressions.Expression" /> that represents the call arguments.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</returns>
		public static MethodCallExpression Call(MethodInfo method, IEnumerable<Expression> arguments)
		{
			return Call(null, method, arguments);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes no arguments.</summary>
		/// <param name="instance">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="method" /> is <see langword="null" />.-or-
		///         <paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.</exception>
		public static MethodCallExpression Call(Expression instance, MethodInfo method)
		{
			ContractUtils.RequiresNotNull(method, "method");
			ParameterInfo[] pis = ValidateMethodAndGetParameters(instance, method);
			ValidateArgumentCount(method, ExpressionType.Call, 0, pis);
			if (instance != null)
			{
				return new InstanceMethodCallExpression0(method, instance);
			}
			return new MethodCallExpression0(method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</summary>
		/// <param name="instance">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance method call (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</param>
		/// <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="method" /> is <see langword="null" />.-or-
		///         <paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.-or-
		///         <paramref name="arguments" /> is not <see langword="null" /> and one or more of its elements is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.-or-The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.-or-One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</exception>
		public static MethodCallExpression Call(Expression instance, MethodInfo method, params Expression[] arguments)
		{
			return Call(instance, method, (IEnumerable<Expression>)arguments);
		}

		internal static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0)
		{
			ContractUtils.RequiresNotNull(method, "method");
			ContractUtils.RequiresNotNull(arg0, "arg0");
			ParameterInfo[] array = ValidateMethodAndGetParameters(instance, method);
			ValidateArgumentCount(method, ExpressionType.Call, 1, array);
			arg0 = ValidateOneArgument(method, ExpressionType.Call, arg0, array[0], "method", "arg0");
			if (instance != null)
			{
				return new InstanceMethodCallExpression1(method, instance, arg0);
			}
			return new MethodCallExpression1(method, arg0);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes two arguments.</summary>
		/// <param name="instance">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call. (pass null for a static (Shared in Visual Basic) method).</param>
		/// <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</param>
		/// <param name="arg0">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</param>
		/// <param name="arg1">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</returns>
		public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1)
		{
			ContractUtils.RequiresNotNull(method, "method");
			ContractUtils.RequiresNotNull(arg0, "arg0");
			ContractUtils.RequiresNotNull(arg1, "arg1");
			ParameterInfo[] array = ValidateMethodAndGetParameters(instance, method);
			ValidateArgumentCount(method, ExpressionType.Call, 2, array);
			arg0 = ValidateOneArgument(method, ExpressionType.Call, arg0, array[0], "method", "arg0");
			arg1 = ValidateOneArgument(method, ExpressionType.Call, arg1, array[1], "method", "arg1");
			if (instance != null)
			{
				return new InstanceMethodCallExpression2(method, instance, arg0, arg1);
			}
			return new MethodCallExpression2(method, arg0, arg1);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes three arguments.</summary>
		/// <param name="instance">An <see cref="T:System.Linq.Expressions.Expression" /> that specifies the instance for an instance call. (pass null for a static (Shared in Visual Basic) method).</param>
		/// <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> that represents the target method.</param>
		/// <param name="arg0">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the first argument.</param>
		/// <param name="arg1">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the second argument.</param>
		/// <param name="arg2">The <see cref="T:System.Linq.Expressions.Expression" /> that represents the third argument.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> properties set to the specified values.</returns>
		public static MethodCallExpression Call(Expression instance, MethodInfo method, Expression arg0, Expression arg1, Expression arg2)
		{
			ContractUtils.RequiresNotNull(method, "method");
			ContractUtils.RequiresNotNull(arg0, "arg0");
			ContractUtils.RequiresNotNull(arg1, "arg1");
			ContractUtils.RequiresNotNull(arg2, "arg2");
			ParameterInfo[] array = ValidateMethodAndGetParameters(instance, method);
			ValidateArgumentCount(method, ExpressionType.Call, 3, array);
			arg0 = ValidateOneArgument(method, ExpressionType.Call, arg0, array[0], "method", "arg0");
			arg1 = ValidateOneArgument(method, ExpressionType.Call, arg1, array[1], "method", "arg1");
			arg2 = ValidateOneArgument(method, ExpressionType.Call, arg2, array[2], "method", "arg2");
			if (instance != null)
			{
				return new InstanceMethodCallExpression3(method, instance, arg0, arg1, arg2);
			}
			return new MethodCallExpression3(method, arg0, arg1, arg2);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method by calling the appropriate factory method.</summary>
		/// <param name="instance">An <see cref="T:System.Linq.Expressions.Expression" /> whose <see cref="P:System.Linq.Expressions.Expression.Type" /> property value will be searched for a specific method.</param>
		/// <param name="methodName">The name of the method.</param>
		/// <param name="typeArguments">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method. This argument should be null when methodName specifies a non-generic method.</param>
		/// <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represents the arguments to the method.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to <paramref name="instance" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified instance method, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> set to the specified arguments.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="instance" /> or <paramref name="methodName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.-or-More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="instance" />.Type or its base types.</exception>
		public static MethodCallExpression Call(Expression instance, string methodName, Type[] typeArguments, params Expression[] arguments)
		{
			ContractUtils.RequiresNotNull(instance, "instance");
			ContractUtils.RequiresNotNull(methodName, "methodName");
			if (arguments == null)
			{
				arguments = Array.Empty<Expression>();
			}
			BindingFlags flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy;
			return Call(instance, FindMethod(instance.Type, methodName, typeArguments, arguments, flags), arguments);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method by calling the appropriate factory method.</summary>
		/// <param name="type">The <see cref="T:System.Type" /> that specifies the type that contains the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method.</param>
		/// <param name="methodName">The name of the method.</param>
		/// <param name="typeArguments">An array of <see cref="T:System.Type" /> objects that specify the type parameters of the generic method. This argument should be null when methodName specifies a non-generic method.</param>
		/// <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments to the method.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" />, the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property set to the <see cref="T:System.Reflection.MethodInfo" /> that represents the specified <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method, and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> property set to the specified arguments.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="type" /> or <paramref name="methodName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">No method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.-or-More than one method whose name is <paramref name="methodName" />, whose type parameters match <paramref name="typeArguments" />, and whose parameter types match <paramref name="arguments" /> is found in <paramref name="type" /> or its base types.</exception>
		public static MethodCallExpression Call(Type type, string methodName, Type[] typeArguments, params Expression[] arguments)
		{
			ContractUtils.RequiresNotNull(type, "type");
			ContractUtils.RequiresNotNull(methodName, "methodName");
			if (arguments == null)
			{
				arguments = Array.Empty<Expression>();
			}
			BindingFlags flags = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.FlattenHierarchy;
			return Call(null, FindMethod(type, methodName, typeArguments, arguments, flags), arguments);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents a call to a method that takes arguments.</summary>
		/// <param name="instance">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to (pass <see langword="null" /> for a <see langword="static" /> (<see langword="Shared" /> in Visual Basic) method).</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" /> property equal to.</param>
		/// <param name="arguments">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" />, <see cref="P:System.Linq.Expressions.MethodCallExpression.Method" />, and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="method" /> is <see langword="null" />.-or-
		///         <paramref name="instance" /> is <see langword="null" /> and <paramref name="method" /> represents an instance method.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="instance" />.Type is not assignable to the declaring type of the method represented by <paramref name="method" />.-or-The number of elements in <paramref name="arguments" /> does not equal the number of parameters for the method represented by <paramref name="method" />.-or-One or more of the elements of <paramref name="arguments" /> is not assignable to the corresponding parameter for the method represented by <paramref name="method" />.</exception>
		public static MethodCallExpression Call(Expression instance, MethodInfo method, IEnumerable<Expression> arguments)
		{
			IReadOnlyList<Expression> readOnlyList = (arguments as IReadOnlyList<Expression>) ?? arguments.ToReadOnly();
			int count = readOnlyList.Count;
			switch (count)
			{
			case 0:
				return Call(instance, method);
			case 1:
				return Call(instance, method, readOnlyList[0]);
			case 2:
				return Call(instance, method, readOnlyList[0], readOnlyList[1]);
			case 3:
				return Call(instance, method, readOnlyList[0], readOnlyList[1], readOnlyList[2]);
			default:
			{
				if (instance == null)
				{
					switch (count)
					{
					case 4:
						return Call(method, readOnlyList[0], readOnlyList[1], readOnlyList[2], readOnlyList[3]);
					case 5:
						return Call(method, readOnlyList[0], readOnlyList[1], readOnlyList[2], readOnlyList[3], readOnlyList[4]);
					}
				}
				ContractUtils.RequiresNotNull(method, "method");
				ReadOnlyCollection<Expression> arguments2 = readOnlyList.ToReadOnly();
				ValidateMethodInfo(method, "method");
				ValidateStaticOrInstanceMethod(instance, method);
				ValidateArgumentTypes(method, ExpressionType.Call, ref arguments2, "method");
				if (instance == null)
				{
					return new MethodCallExpressionN(method, arguments2);
				}
				return new InstanceMethodCallExpressionN(method, instance, arguments2);
			}
			}
		}

		private static ParameterInfo[] ValidateMethodAndGetParameters(Expression instance, MethodInfo method)
		{
			ValidateMethodInfo(method, "method");
			ValidateStaticOrInstanceMethod(instance, method);
			return GetParametersForValidation(method, ExpressionType.Call);
		}

		private static void ValidateStaticOrInstanceMethod(Expression instance, MethodInfo method)
		{
			if (method.IsStatic)
			{
				if (instance != null)
				{
					throw Error.OnlyStaticMethodsHaveNullInstance();
				}
				return;
			}
			if (instance == null)
			{
				throw Error.OnlyStaticMethodsHaveNullInstance();
			}
			ExpressionUtils.RequiresCanRead(instance, "instance");
			ValidateCallInstanceType(instance.Type, method);
		}

		private static void ValidateCallInstanceType(Type instanceType, MethodInfo method)
		{
			if (!TypeUtils.IsValidInstanceType(method, instanceType))
			{
				throw Error.InstanceAndMethodTypeMismatch(method, method.DeclaringType, instanceType);
			}
		}

		private static void ValidateArgumentTypes(MethodBase method, ExpressionType nodeKind, ref ReadOnlyCollection<Expression> arguments, string methodParamName)
		{
			ExpressionUtils.ValidateArgumentTypes(method, nodeKind, ref arguments, methodParamName);
		}

		private static ParameterInfo[] GetParametersForValidation(MethodBase method, ExpressionType nodeKind)
		{
			return ExpressionUtils.GetParametersForValidation(method, nodeKind);
		}

		private static void ValidateArgumentCount(MethodBase method, ExpressionType nodeKind, int count, ParameterInfo[] pis)
		{
			ExpressionUtils.ValidateArgumentCount(method, nodeKind, count, pis);
		}

		private static Expression ValidateOneArgument(MethodBase method, ExpressionType nodeKind, Expression arg, ParameterInfo pi, string methodParamName, string argumentParamName)
		{
			return ExpressionUtils.ValidateOneArgument(method, nodeKind, arg, pi, methodParamName, argumentParamName);
		}

		private static bool TryQuote(Type parameterType, ref Expression argument)
		{
			return ExpressionUtils.TryQuote(parameterType, ref argument);
		}

		private static MethodInfo FindMethod(Type type, string methodName, Type[] typeArgs, Expression[] args, BindingFlags flags)
		{
			int num = 0;
			MethodInfo methodInfo = null;
			MethodInfo[] methods = type.GetMethods(flags);
			foreach (MethodInfo methodInfo2 in methods)
			{
				if (!methodInfo2.Name.Equals(methodName, StringComparison.OrdinalIgnoreCase))
				{
					continue;
				}
				MethodInfo methodInfo3 = ApplyTypeArgs(methodInfo2, typeArgs);
				if (methodInfo3 != null && IsCompatible(methodInfo3, args))
				{
					if (methodInfo == null || (!methodInfo.IsPublic && methodInfo3.IsPublic))
					{
						methodInfo = methodInfo3;
						num = 1;
					}
					else if (methodInfo.IsPublic == methodInfo3.IsPublic)
					{
						num++;
					}
				}
			}
			if (num == 0)
			{
				if (typeArgs != null && typeArgs.Length != 0)
				{
					throw Error.GenericMethodWithArgsDoesNotExistOnType(methodName, type);
				}
				throw Error.MethodWithArgsDoesNotExistOnType(methodName, type);
			}
			if (num > 1)
			{
				throw Error.MethodWithMoreThanOneMatch(methodName, type);
			}
			return methodInfo;
		}

		private static bool IsCompatible(MethodBase m, Expression[] arguments)
		{
			ParameterInfo[] parametersCached = m.GetParametersCached();
			if (parametersCached.Length != arguments.Length)
			{
				return false;
			}
			for (int i = 0; i < arguments.Length; i++)
			{
				Expression expression = arguments[i];
				ContractUtils.RequiresNotNull(expression, "arguments");
				Type type = expression.Type;
				Type type2 = parametersCached[i].ParameterType;
				if (type2.IsByRef)
				{
					type2 = type2.GetElementType();
				}
				if (!TypeUtils.AreReferenceAssignable(type2, type) && (!TypeUtils.IsSameOrSubclass(typeof(LambdaExpression), type2) || !type2.IsAssignableFrom(expression.GetType())))
				{
					return false;
				}
			}
			return true;
		}

		private static MethodInfo ApplyTypeArgs(MethodInfo m, Type[] typeArgs)
		{
			if (typeArgs == null || typeArgs.Length == 0)
			{
				if (!m.IsGenericMethodDefinition)
				{
					return m;
				}
			}
			else if (m.IsGenericMethodDefinition && m.GetGenericArguments().Length == typeArgs.Length)
			{
				return m.MakeGenericMethod(typeArgs);
			}
			return null;
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to a multidimensional array.</summary>
		/// <param name="array">An array of <see cref="T:System.Linq.Expressions.Expression" /> instances - indexes for the array index operation.</param>
		/// <param name="indexes">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="array" />.Type does not represent an array type.-or-The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</exception>
		public static MethodCallExpression ArrayIndex(Expression array, params Expression[] indexes)
		{
			return ArrayIndex(array, (IEnumerable<Expression>)indexes);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that represents applying an array index operator to an array of rank more than one.</summary>
		/// <param name="array">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property equal to.</param>
		/// <param name="indexes">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.MethodCallExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Call" /> and the <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> and <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="array" /> or <paramref name="indexes" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="array" />.Type does not represent an array type.-or-The rank of <paramref name="array" />.Type does not match the number of elements in <paramref name="indexes" />.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of one or more elements of <paramref name="indexes" /> does not represent the <see cref="T:System.Int32" /> type.</exception>
		public static MethodCallExpression ArrayIndex(Expression array, IEnumerable<Expression> indexes)
		{
			ExpressionUtils.RequiresCanRead(array, "array", -1);
			ContractUtils.RequiresNotNull(indexes, "indexes");
			Type type = array.Type;
			if (!type.IsArray)
			{
				throw Error.ArgumentMustBeArray("array");
			}
			ReadOnlyCollection<Expression> readOnlyCollection = indexes.ToReadOnly();
			if (type.GetArrayRank() != readOnlyCollection.Count)
			{
				throw Error.IncorrectNumberOfIndexes();
			}
			int i = 0;
			for (int count = readOnlyCollection.Count; i < count; i++)
			{
				Expression expression = readOnlyCollection[i];
				ExpressionUtils.RequiresCanRead(expression, "indexes", i);
				if (expression.Type != typeof(int))
				{
					throw Error.ArgumentMustBeArrayIndexType("indexes", i);
				}
			}
			MethodInfo method = array.Type.GetMethod("Get", BindingFlags.Instance | BindingFlags.Public);
			return Call(array, method, readOnlyCollection);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</summary>
		/// <param name="type">A <see cref="T:System.Type" /> that represents the element type of the array.</param>
		/// <param name="initializers">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.-or-An element of <paramref name="initializers" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type <paramref name="type" />.</exception>
		public static NewArrayExpression NewArrayInit(Type type, params Expression[] initializers)
		{
			return NewArrayInit(type, (IEnumerable<Expression>)initializers);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating a one-dimensional array and initializing it from a list of elements.</summary>
		/// <param name="type">A <see cref="T:System.Type" /> that represents the element type of the array.</param>
		/// <param name="initializers">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="type" /> or <paramref name="initializers" /> is <see langword="null" />.-or-An element of <paramref name="initializers" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="initializers" /> represents a type that is not assignable to the type that <paramref name="type" /> represents.</exception>
		public static NewArrayExpression NewArrayInit(Type type, IEnumerable<Expression> initializers)
		{
			ContractUtils.RequiresNotNull(type, "type");
			ContractUtils.RequiresNotNull(initializers, "initializers");
			if (type == typeof(void))
			{
				throw Error.ArgumentCannotBeOfTypeVoid("type");
			}
			TypeUtils.ValidateType(type, "type");
			ReadOnlyCollection<Expression> readOnlyCollection = initializers.ToReadOnly();
			Expression[] array = null;
			int i = 0;
			for (int count = readOnlyCollection.Count; i < count; i++)
			{
				Expression argument = readOnlyCollection[i];
				ExpressionUtils.RequiresCanRead(argument, "initializers", i);
				if (!TypeUtils.AreReferenceAssignable(type, argument.Type))
				{
					if (!TryQuote(type, ref argument))
					{
						throw Error.ExpressionTypeCannotInitializeArrayType(argument.Type, type);
					}
					if (array == null)
					{
						array = new Expression[readOnlyCollection.Count];
						for (int j = 0; j < i; j++)
						{
							array[j] = readOnlyCollection[j];
						}
					}
				}
				if (array != null)
				{
					array[i] = argument;
				}
			}
			if (array != null)
			{
				readOnlyCollection = new TrueReadOnlyCollection<Expression>(array);
			}
			return NewArrayExpression.Make(ExpressionType.NewArrayInit, type.MakeArrayType(), readOnlyCollection);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</summary>
		/// <param name="type">A <see cref="T:System.Type" /> that represents the element type of the array.</param>
		/// <param name="bounds">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.-or-An element of <paramref name="bounds" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</exception>
		public static NewArrayExpression NewArrayBounds(Type type, params Expression[] bounds)
		{
			return NewArrayBounds(type, (IEnumerable<Expression>)bounds);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that represents creating an array that has a specified rank.</summary>
		/// <param name="type">A <see cref="T:System.Type" /> that represents the element type of the array.</param>
		/// <param name="bounds">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.NewArrayExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" /> and the <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property set to the specified value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="type" /> or <paramref name="bounds" /> is <see langword="null" />.-or-An element of <paramref name="bounds" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="bounds" /> does not represent an integral type.</exception>
		public static NewArrayExpression NewArrayBounds(Type type, IEnumerable<Expression> bounds)
		{
			ContractUtils.RequiresNotNull(type, "type");
			ContractUtils.RequiresNotNull(bounds, "bounds");
			if (type == typeof(void))
			{
				throw Error.ArgumentCannotBeOfTypeVoid("type");
			}
			TypeUtils.ValidateType(type, "type");
			ReadOnlyCollection<Expression> readOnlyCollection = bounds.ToReadOnly();
			int count = readOnlyCollection.Count;
			if (count <= 0)
			{
				throw Error.BoundsCannotBeLessThanOne("bounds");
			}
			for (int i = 0; i < count; i++)
			{
				Expression expression = readOnlyCollection[i];
				ExpressionUtils.RequiresCanRead(expression, "bounds", i);
				if (!expression.Type.IsInteger())
				{
					throw Error.ArgumentMustBeInteger("bounds", i);
				}
			}
			Type type2 = ((count != 1) ? type.MakeArrayType(count) : type.MakeArrayType());
			return NewArrayExpression.Make(ExpressionType.NewArrayBounds, type2, readOnlyCollection);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor that takes no arguments.</summary>
		/// <param name="constructor">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the specified value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="constructor" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The constructor that <paramref name="constructor" /> represents has at least one parameter.</exception>
		public static NewExpression New(ConstructorInfo constructor)
		{
			return New(constructor, (IEnumerable<Expression>)null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</summary>
		/// <param name="constructor">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</param>
		/// <param name="arguments">An array of <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="constructor" /> is <see langword="null" />.-or-An element of <paramref name="arguments" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The length of <paramref name="arguments" /> does match the number of parameters for the constructor that <paramref name="constructor" /> represents.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</exception>
		public static NewExpression New(ConstructorInfo constructor, params Expression[] arguments)
		{
			return New(constructor, (IEnumerable<Expression>)arguments);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments.</summary>
		/// <param name="constructor">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</param>
		/// <param name="arguments">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> and <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="constructor" /> is <see langword="null" />.-or-An element of <paramref name="arguments" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.</exception>
		public static NewExpression New(ConstructorInfo constructor, IEnumerable<Expression> arguments)
		{
			ContractUtils.RequiresNotNull(constructor, "constructor");
			ContractUtils.RequiresNotNull(constructor.DeclaringType, "constructor.DeclaringType");
			TypeUtils.ValidateType(constructor.DeclaringType, "constructor", allowByRef: true, allowPointer: true);
			ValidateConstructor(constructor, "constructor");
			ReadOnlyCollection<Expression> arguments2 = arguments.ToReadOnly();
			ValidateArgumentTypes(constructor, ExpressionType.New, ref arguments2, "constructor");
			return new NewExpression(constructor, arguments2, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments. The members that access the constructor initialized fields are specified.</summary>
		/// <param name="constructor">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</param>
		/// <param name="arguments">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</param>
		/// <param name="members">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="constructor" /> is <see langword="null" />.-or-An element of <paramref name="arguments" /> is <see langword="null" />.-or-An element of <paramref name="members" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.-or-The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.-or-An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</exception>
		public static NewExpression New(ConstructorInfo constructor, IEnumerable<Expression> arguments, IEnumerable<MemberInfo> members)
		{
			ContractUtils.RequiresNotNull(constructor, "constructor");
			ContractUtils.RequiresNotNull(constructor.DeclaringType, "constructor.DeclaringType");
			TypeUtils.ValidateType(constructor.DeclaringType, "constructor", allowByRef: true, allowPointer: true);
			ValidateConstructor(constructor, "constructor");
			ReadOnlyCollection<MemberInfo> members2 = members.ToReadOnly();
			ReadOnlyCollection<Expression> arguments2 = arguments.ToReadOnly();
			ValidateNewArgs(constructor, ref arguments2, ref members2);
			return new NewExpression(constructor, arguments2, members2);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the specified constructor with the specified arguments. The members that access the constructor initialized fields are specified as an array.</summary>
		/// <param name="constructor">The <see cref="T:System.Reflection.ConstructorInfo" /> to set the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property equal to.</param>
		/// <param name="arguments">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains <see cref="T:System.Linq.Expressions.Expression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> collection.</param>
		/// <param name="members">An array of <see cref="T:System.Reflection.MemberInfo" /> objects to use to populate the <see cref="P:System.Linq.Expressions.NewExpression.Members" /> collection.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" />, <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> and <see cref="P:System.Linq.Expressions.NewExpression.Members" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="constructor" /> is <see langword="null" />.-or-An element of <paramref name="arguments" /> is <see langword="null" />.-or-An element of <paramref name="members" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <paramref name="arguments" /> parameter does not contain the same number of elements as the number of parameters for the constructor that <paramref name="constructor" /> represents.-or-The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of an element of <paramref name="arguments" /> is not assignable to the type of the corresponding parameter of the constructor that <paramref name="constructor" /> represents.-or-The <paramref name="members" /> parameter does not have the same number of elements as <paramref name="arguments" />.-or-An element of <paramref name="arguments" /> has a <see cref="P:System.Linq.Expressions.Expression.Type" /> property that represents a type that is not assignable to the type of the member that is represented by the corresponding element of <paramref name="members" />.</exception>
		public static NewExpression New(ConstructorInfo constructor, IEnumerable<Expression> arguments, params MemberInfo[] members)
		{
			return New(constructor, arguments, (IEnumerable<MemberInfo>)members);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.NewExpression" /> that represents calling the parameterless constructor of the specified type.</summary>
		/// <param name="type">A <see cref="T:System.Type" /> that has a constructor that takes no arguments.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.New" /> and the <see cref="P:System.Linq.Expressions.NewExpression.Constructor" /> property set to the <see cref="T:System.Reflection.ConstructorInfo" /> that represents the constructor without parameters for the specified type.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="type" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The type that <paramref name="type" /> represents does not have a constructor without parameters.</exception>
		public static NewExpression New(Type type)
		{
			ContractUtils.RequiresNotNull(type, "type");
			if (type == typeof(void))
			{
				throw Error.ArgumentCannotBeOfTypeVoid("type");
			}
			TypeUtils.ValidateType(type, "type");
			if (!type.IsValueType)
			{
				ConstructorInfo constructorInfo = type.GetConstructors(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic).SingleOrDefault((ConstructorInfo c) => c.GetParametersCached().Length == 0);
				if (constructorInfo == null)
				{
					throw Error.TypeMissingDefaultConstructor(type, "type");
				}
				return New(constructorInfo);
			}
			return new NewValueTypeExpression(type, EmptyReadOnlyCollection<Expression>.Instance, null);
		}

		private static void ValidateNewArgs(ConstructorInfo constructor, ref ReadOnlyCollection<Expression> arguments, ref ReadOnlyCollection<MemberInfo> members)
		{
			ParameterInfo[] parametersCached;
			if ((parametersCached = constructor.GetParametersCached()).Length != 0)
			{
				if (arguments.Count != parametersCached.Length)
				{
					throw Error.IncorrectNumberOfConstructorArguments();
				}
				if (arguments.Count != members.Count)
				{
					throw Error.IncorrectNumberOfArgumentsForMembers();
				}
				Expression[] array = null;
				MemberInfo[] array2 = null;
				int i = 0;
				for (int count = arguments.Count; i < count; i++)
				{
					Expression argument = arguments[i];
					ExpressionUtils.RequiresCanRead(argument, "arguments", i);
					MemberInfo member = members[i];
					ContractUtils.RequiresNotNull(member, "members", i);
					if (!TypeUtils.AreEquivalent(member.DeclaringType, constructor.DeclaringType))
					{
						throw Error.ArgumentMemberNotDeclOnType(member.Name, constructor.DeclaringType.Name, "members", i);
					}
					ValidateAnonymousTypeMember(ref member, out var memberType, "members", i);
					if (!TypeUtils.AreReferenceAssignable(memberType, argument.Type) && !TryQuote(memberType, ref argument))
					{
						throw Error.ArgumentTypeDoesNotMatchMember(argument.Type, memberType, "arguments", i);
					}
					Type type = parametersCached[i].ParameterType;
					if (type.IsByRef)
					{
						type = type.GetElementType();
					}
					if (!TypeUtils.AreReferenceAssignable(type, argument.Type) && !TryQuote(type, ref argument))
					{
						throw Error.ExpressionTypeDoesNotMatchConstructorParameter(argument.Type, type, "arguments", i);
					}
					if (array == null && argument != arguments[i])
					{
						array = new Expression[arguments.Count];
						for (int j = 0; j < i; j++)
						{
							array[j] = arguments[j];
						}
					}
					if (array != null)
					{
						array[i] = argument;
					}
					if (array2 == null && member != members[i])
					{
						array2 = new MemberInfo[members.Count];
						for (int k = 0; k < i; k++)
						{
							array2[k] = members[k];
						}
					}
					if (array2 != null)
					{
						array2[i] = member;
					}
				}
				if (array != null)
				{
					arguments = new TrueReadOnlyCollection<Expression>(array);
				}
				if (array2 != null)
				{
					members = new TrueReadOnlyCollection<MemberInfo>(array2);
				}
			}
			else
			{
				if (arguments != null && arguments.Count > 0)
				{
					throw Error.IncorrectNumberOfConstructorArguments();
				}
				if (members != null && members.Count > 0)
				{
					throw Error.IncorrectNumberOfMembersForGivenConstructor();
				}
			}
		}

		private static void ValidateAnonymousTypeMember(ref MemberInfo member, out Type memberType, string paramName, int index)
		{
			FieldInfo fieldInfo = member as FieldInfo;
			if (fieldInfo != null)
			{
				if (fieldInfo.IsStatic)
				{
					throw Error.ArgumentMustBeInstanceMember(paramName, index);
				}
				memberType = fieldInfo.FieldType;
				return;
			}
			PropertyInfo propertyInfo = member as PropertyInfo;
			if (propertyInfo != null)
			{
				if (!propertyInfo.CanRead)
				{
					throw Error.PropertyDoesNotHaveGetter(propertyInfo, paramName, index);
				}
				if (propertyInfo.GetGetMethod().IsStatic)
				{
					throw Error.ArgumentMustBeInstanceMember(paramName, index);
				}
				memberType = propertyInfo.PropertyType;
				return;
			}
			MethodInfo methodInfo = member as MethodInfo;
			if (methodInfo != null)
			{
				if (methodInfo.IsStatic)
				{
					throw Error.ArgumentMustBeInstanceMember(paramName, index);
				}
				memberType = ((PropertyInfo)(member = GetProperty(methodInfo, paramName, index))).PropertyType;
				return;
			}
			throw Error.ArgumentMustBeFieldInfoOrPropertyInfoOrMethod(paramName, index);
		}

		private static void ValidateConstructor(ConstructorInfo constructor, string paramName)
		{
			if (constructor.IsStatic)
			{
				throw Error.NonStaticConstructorRequired(paramName);
			}
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</summary>
		/// <param name="type">The type of the parameter or variable.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</returns>
		public static ParameterExpression Parameter(Type type)
		{
			return Parameter(type, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</summary>
		/// <param name="type">The type of the parameter or variable.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type</returns>
		public static ParameterExpression Variable(Type type)
		{
			return Variable(type, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</summary>
		/// <param name="type">The type of the parameter or variable.</param>
		/// <param name="name">The name of the parameter or variable, used for debugging or printing purpose only.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Parameter" /> and the <see cref="P:System.Linq.Expressions.Expression.Type" /> and <see cref="P:System.Linq.Expressions.ParameterExpression.Name" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="type" /> is <see langword="null" />.</exception>
		public static ParameterExpression Parameter(Type type, string name)
		{
			Validate(type, allowByRef: true);
			bool isByRef = type.IsByRef;
			if (isByRef)
			{
				type = type.GetElementType();
			}
			return ParameterExpression.Make(type, name, isByRef);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.ParameterExpression" /> node that can be used to identify a parameter or a variable in an expression tree.</summary>
		/// <param name="type">The type of the parameter or variable.</param>
		/// <param name="name">The name of the parameter or variable. This name is used for debugging or printing purpose only.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.ParameterExpression" /> node with the specified name and type.</returns>
		public static ParameterExpression Variable(Type type, string name)
		{
			Validate(type, allowByRef: false);
			return ParameterExpression.Make(type, name, isByRef: false);
		}

		private static void Validate(Type type, bool allowByRef)
		{
			ContractUtils.RequiresNotNull(type, "type");
			TypeUtils.ValidateType(type, "type", allowByRef, allowPointer: false);
			if (type == typeof(void))
			{
				throw Error.ArgumentCannotBeOfTypeVoid("type");
			}
		}

		/// <summary>Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
		/// <param name="variables">An array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</param>
		/// <returns>An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</returns>
		public static RuntimeVariablesExpression RuntimeVariables(params ParameterExpression[] variables)
		{
			return RuntimeVariables((IEnumerable<ParameterExpression>)variables);
		}

		/// <summary>Creates an instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
		/// <param name="variables">A collection of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects to use to populate the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> collection.</param>
		/// <returns>An instance of <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.RuntimeVariables" /> and the <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property set to the specified value.</returns>
		public static RuntimeVariablesExpression RuntimeVariables(IEnumerable<ParameterExpression> variables)
		{
			ContractUtils.RequiresNotNull(variables, "variables");
			ReadOnlyCollection<ParameterExpression> readOnlyCollection = variables.ToReadOnly();
			for (int i = 0; i < readOnlyCollection.Count; i++)
			{
				ContractUtils.RequiresNotNull(readOnlyCollection[i], "variables", i);
			}
			return new RuntimeVariablesExpression(readOnlyCollection);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> for use in a <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
		/// <param name="body">The body of the case.</param>
		/// <param name="testValues">The test values of the case.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
		public static SwitchCase SwitchCase(Expression body, params Expression[] testValues)
		{
			return SwitchCase(body, (IEnumerable<Expression>)testValues);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.SwitchCase" /> object to be used in a <see cref="T:System.Linq.Expressions.SwitchExpression" /> object.</summary>
		/// <param name="body">The body of the case.</param>
		/// <param name="testValues">The test values of the case.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.SwitchCase" />.</returns>
		public static SwitchCase SwitchCase(Expression body, IEnumerable<Expression> testValues)
		{
			ExpressionUtils.RequiresCanRead(body, "body");
			ReadOnlyCollection<Expression> readOnlyCollection = testValues.ToReadOnly();
			ContractUtils.RequiresNotEmpty(readOnlyCollection, "testValues");
			RequiresCanRead(readOnlyCollection, "testValues");
			return new SwitchCase(body, readOnlyCollection);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement without a default case.</summary>
		/// <param name="switchValue">The value to be tested against each case.</param>
		/// <param name="cases">The set of cases for this switch expression.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
		public static SwitchExpression Switch(Expression switchValue, params SwitchCase[] cases)
		{
			return Switch(switchValue, (Expression)null, (MethodInfo)null, (IEnumerable<SwitchCase>)cases);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</summary>
		/// <param name="switchValue">The value to be tested against each case.</param>
		/// <param name="defaultBody">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</param>
		/// <param name="cases">The set of cases for this switch expression.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
		public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, params SwitchCase[] cases)
		{
			return Switch(switchValue, defaultBody, (MethodInfo)null, (IEnumerable<SwitchCase>)cases);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</summary>
		/// <param name="switchValue">The value to be tested against each case.</param>
		/// <param name="defaultBody">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</param>
		/// <param name="comparison">The equality comparison method to use.</param>
		/// <param name="cases">The set of cases for this switch expression.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
		public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, params SwitchCase[] cases)
		{
			return Switch(switchValue, defaultBody, comparison, (IEnumerable<SwitchCase>)cases);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case..</summary>
		/// <param name="type">The result type of the switch.</param>
		/// <param name="switchValue">The value to be tested against each case.</param>
		/// <param name="defaultBody">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</param>
		/// <param name="comparison">The equality comparison method to use.</param>
		/// <param name="cases">The set of cases for this switch expression.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
		public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, params SwitchCase[] cases)
		{
			return Switch(type, switchValue, defaultBody, comparison, (IEnumerable<SwitchCase>)cases);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</summary>
		/// <param name="switchValue">The value to be tested against each case.</param>
		/// <param name="defaultBody">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</param>
		/// <param name="comparison">The equality comparison method to use.</param>
		/// <param name="cases">The set of cases for this switch expression.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
		public static SwitchExpression Switch(Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable<SwitchCase> cases)
		{
			return Switch(null, switchValue, defaultBody, comparison, cases);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.SwitchExpression" /> that represents a <see langword="switch" /> statement that has a default case.</summary>
		/// <param name="type">The result type of the switch.</param>
		/// <param name="switchValue">The value to be tested against each case.</param>
		/// <param name="defaultBody">The result of the switch if <paramref name="switchValue" /> does not match any of the cases.</param>
		/// <param name="comparison">The equality comparison method to use.</param>
		/// <param name="cases">The set of cases for this switch expression.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.SwitchExpression" />.</returns>
		public static SwitchExpression Switch(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, IEnumerable<SwitchCase> cases)
		{
			ExpressionUtils.RequiresCanRead(switchValue, "switchValue");
			if (switchValue.Type == typeof(void))
			{
				throw Error.ArgumentCannotBeOfTypeVoid("switchValue");
			}
			ReadOnlyCollection<SwitchCase> readOnlyCollection = cases.ToReadOnly();
			ContractUtils.RequiresNotNullItems(readOnlyCollection, "cases");
			Type type2 = ((type != null) ? type : ((readOnlyCollection.Count != 0) ? readOnlyCollection[0].Body.Type : ((defaultBody == null) ? typeof(void) : defaultBody.Type)));
			bool customType = type != null;
			if (comparison != null)
			{
				ValidateMethodInfo(comparison, "comparison");
				ParameterInfo[] parametersCached = comparison.GetParametersCached();
				if (parametersCached.Length != 2)
				{
					throw Error.IncorrectNumberOfMethodCallArguments(comparison, "comparison");
				}
				ParameterInfo parameterInfo = parametersCached[0];
				bool flag = false;
				if (!ParameterIsAssignable(parameterInfo, switchValue.Type))
				{
					flag = ParameterIsAssignable(parameterInfo, switchValue.Type.GetNonNullableType());
					if (!flag)
					{
						throw Error.SwitchValueTypeDoesNotMatchComparisonMethodParameter(switchValue.Type, parameterInfo.ParameterType);
					}
				}
				ParameterInfo parameterInfo2 = parametersCached[1];
				foreach (SwitchCase item in readOnlyCollection)
				{
					ContractUtils.RequiresNotNull(item, "cases");
					ValidateSwitchCaseType(item.Body, customType, type2, "cases");
					int i = 0;
					for (int count = item.TestValues.Count; i < count; i++)
					{
						Type type3 = item.TestValues[i].Type;
						if (flag)
						{
							if (!type3.IsNullableType())
							{
								throw Error.TestValueTypeDoesNotMatchComparisonMethodParameter(type3, parameterInfo2.ParameterType);
							}
							type3 = type3.GetNonNullableType();
						}
						if (!ParameterIsAssignable(parameterInfo2, type3))
						{
							throw Error.TestValueTypeDoesNotMatchComparisonMethodParameter(type3, parameterInfo2.ParameterType);
						}
					}
				}
				if (comparison.ReturnType != typeof(bool))
				{
					throw Error.EqualityMustReturnBoolean(comparison, "comparison");
				}
			}
			else if (readOnlyCollection.Count != 0)
			{
				Expression expression = readOnlyCollection[0].TestValues[0];
				foreach (SwitchCase item2 in readOnlyCollection)
				{
					ContractUtils.RequiresNotNull(item2, "cases");
					ValidateSwitchCaseType(item2.Body, customType, type2, "cases");
					int j = 0;
					for (int count2 = item2.TestValues.Count; j < count2; j++)
					{
						if (!TypeUtils.AreEquivalent(expression.Type, item2.TestValues[j].Type))
						{
							throw Error.AllTestValuesMustHaveSameType("cases");
						}
					}
				}
				comparison = Equal(switchValue, expression, liftToNull: false, comparison).Method;
			}
			if (defaultBody == null)
			{
				if (type2 != typeof(void))
				{
					throw Error.DefaultBodyMustBeSupplied("defaultBody");
				}
			}
			else
			{
				ValidateSwitchCaseType(defaultBody, customType, type2, "defaultBody");
			}
			return new SwitchExpression(type2, switchValue, defaultBody, comparison, readOnlyCollection);
		}

		private static void ValidateSwitchCaseType(Expression @case, bool customType, Type resultType, string parameterName)
		{
			if (customType)
			{
				if (resultType != typeof(void) && !TypeUtils.AreReferenceAssignable(resultType, @case.Type))
				{
					throw Error.ArgumentTypesMustMatch(parameterName);
				}
			}
			else if (!TypeUtils.AreEquivalent(resultType, @case.Type))
			{
				throw Error.AllCaseBodiesMustHaveSameType(parameterName);
			}
		}

		/// <summary>Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> property set to the specified value.</returns>
		public static SymbolDocumentInfo SymbolDocument(string fileName)
		{
			return new SymbolDocumentInfo(fileName);
		}

		/// <summary>Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</param>
		/// <param name="language">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> properties set to the specified value.</returns>
		public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language)
		{
			return new SymbolDocumentWithGuids(fileName, ref language);
		}

		/// <summary>Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</param>
		/// <param name="language">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</param>
		/// <param name="languageVendor">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> properties set to the specified value.</returns>
		public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor)
		{
			return new SymbolDocumentWithGuids(fileName, ref language, ref languageVendor);
		}

		/// <summary>Creates an instance of <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" />.</summary>
		/// <param name="fileName">A <see cref="T:System.String" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> equal to.</param>
		/// <param name="language">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> equal to.</param>
		/// <param name="languageVendor">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> equal to.</param>
		/// <param name="documentType">A <see cref="T:System.Guid" /> to set the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that has the <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.FileName" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.Language" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.LanguageVendor" /> and <see cref="P:System.Linq.Expressions.SymbolDocumentInfo.DocumentType" /> properties set to the specified value.</returns>
		public static SymbolDocumentInfo SymbolDocument(string fileName, Guid language, Guid languageVendor, Guid documentType)
		{
			return new SymbolDocumentWithGuids(fileName, ref language, ref languageVendor, ref documentType);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a fault block and no catch statements.</summary>
		/// <param name="body">The body of the try block.</param>
		/// <param name="fault">The body of the fault block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
		public static TryExpression TryFault(Expression body, Expression fault)
		{
			return MakeTry(null, body, null, fault, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with a finally block and no catch statements.</summary>
		/// <param name="body">The body of the try block.</param>
		/// <param name="finally">The body of the finally block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
		public static TryExpression TryFinally(Expression body, Expression @finally)
		{
			return MakeTry(null, body, @finally, null, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and neither a fault nor finally block.</summary>
		/// <param name="body">The body of the try block.</param>
		/// <param name="handlers">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
		public static TryExpression TryCatch(Expression body, params CatchBlock[] handlers)
		{
			return MakeTry(null, body, null, null, handlers);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with any number of catch statements and a finally block.</summary>
		/// <param name="body">The body of the try block.</param>
		/// <param name="finally">The body of the finally block.</param>
		/// <param name="handlers">The array of zero or more <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions representing the catch statements to be associated with the try block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
		public static TryExpression TryCatchFinally(Expression body, Expression @finally, params CatchBlock[] handlers)
		{
			return MakeTry(null, body, @finally, null, handlers);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.TryExpression" /> representing a try block with the specified elements.</summary>
		/// <param name="type">The result type of the try expression. If null, bodh and all handlers must have identical type.</param>
		/// <param name="body">The body of the try block.</param>
		/// <param name="finally">The body of the finally block. Pass null if the try block has no finally block associated with it.</param>
		/// <param name="fault">The body of the fault block. Pass null if the try block has no fault block associated with it.</param>
		/// <param name="handlers">A collection of <see cref="T:System.Linq.Expressions.CatchBlock" />s representing the catch statements to be associated with the try block.</param>
		/// <returns>The created <see cref="T:System.Linq.Expressions.TryExpression" />.</returns>
		public static TryExpression MakeTry(Type type, Expression body, Expression @finally, Expression fault, IEnumerable<CatchBlock> handlers)
		{
			ExpressionUtils.RequiresCanRead(body, "body");
			ReadOnlyCollection<CatchBlock> readOnlyCollection = handlers.ToReadOnly();
			ContractUtils.RequiresNotNullItems(readOnlyCollection, "handlers");
			ValidateTryAndCatchHaveSameType(type, body, readOnlyCollection);
			if (fault != null)
			{
				if (@finally != null || readOnlyCollection.Count > 0)
				{
					throw Error.FaultCannotHaveCatchOrFinally("fault");
				}
				ExpressionUtils.RequiresCanRead(fault, "fault");
			}
			else if (@finally != null)
			{
				ExpressionUtils.RequiresCanRead(@finally, "finally");
			}
			else if (readOnlyCollection.Count == 0)
			{
				throw Error.TryMustHaveCatchFinallyOrFault();
			}
			return new TryExpression(type ?? body.Type, body, @finally, fault, readOnlyCollection);
		}

		private static void ValidateTryAndCatchHaveSameType(Type type, Expression tryBody, ReadOnlyCollection<CatchBlock> handlers)
		{
			if (type != null)
			{
				if (!(type != typeof(void)))
				{
					return;
				}
				if (!TypeUtils.AreReferenceAssignable(type, tryBody.Type))
				{
					throw Error.ArgumentTypesMustMatch();
				}
				{
					foreach (CatchBlock handler in handlers)
					{
						if (!TypeUtils.AreReferenceAssignable(type, handler.Body.Type))
						{
							throw Error.ArgumentTypesMustMatch();
						}
					}
					return;
				}
			}
			if (tryBody.Type == typeof(void))
			{
				foreach (CatchBlock handler2 in handlers)
				{
					if (handler2.Body.Type != typeof(void))
					{
						throw Error.BodyOfCatchMustHaveSameTypeAsBodyOfTry();
					}
				}
				return;
			}
			type = tryBody.Type;
			foreach (CatchBlock handler3 in handlers)
			{
				if (!TypeUtils.AreEquivalent(handler3.Body.Type, type))
				{
					throw Error.BodyOfCatchMustHaveSameTypeAsBodyOfTry();
				}
			}
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> property equal to.</param>
		/// <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeIs" /> and for which the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</exception>
		public static TypeBinaryExpression TypeIs(Expression expression, Type type)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			ContractUtils.RequiresNotNull(type, "type");
			if (type.IsByRef)
			{
				throw Error.TypeMustNotBeByRef("type");
			}
			return new TypeBinaryExpression(expression, type, ExpressionType.TypeIs);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> that compares run-time type identity.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="T:System.Linq.Expressions.Expression" /> property equal to.</param>
		/// <param name="type">A <see cref="P:System.Linq.Expressions.Expression.Type" /> to set the <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.TypeBinaryExpression" /> for which the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is equal to <see cref="M:System.Linq.Expressions.Expression.TypeEqual(System.Linq.Expressions.Expression,System.Type)" /> and for which the <see cref="T:System.Linq.Expressions.Expression" /> and <see cref="P:System.Linq.Expressions.TypeBinaryExpression.TypeOperand" /> properties are set to the specified values.</returns>
		public static TypeBinaryExpression TypeEqual(Expression expression, Type type)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			ContractUtils.RequiresNotNull(type, "type");
			if (type.IsByRef)
			{
				throw Error.TypeMustNotBeByRef("type");
			}
			return new TypeBinaryExpression(expression, type, ExpressionType.TypeEqual);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand, by calling the appropriate factory method.</summary>
		/// <param name="unaryType">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</param>
		/// <param name="operand">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</param>
		/// <param name="type">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</param>
		/// <returns>The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="operand" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="unaryType" /> does not correspond to a unary expression node.</exception>
		public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type)
		{
			return MakeUnary(unaryType, operand, type, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" />, given an operand and implementing method, by calling the appropriate factory method.</summary>
		/// <param name="unaryType">The <see cref="T:System.Linq.Expressions.ExpressionType" /> that specifies the type of unary operation.</param>
		/// <param name="operand">An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand.</param>
		/// <param name="type">The <see cref="T:System.Type" /> that specifies the type to be converted to (pass <see langword="null" /> if not applicable).</param>
		/// <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</param>
		/// <returns>The <see cref="T:System.Linq.Expressions.UnaryExpression" /> that results from calling the appropriate factory method.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="operand" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="unaryType" /> does not correspond to a unary expression node.</exception>
		public static UnaryExpression MakeUnary(ExpressionType unaryType, Expression operand, Type type, MethodInfo method)
		{
			return unaryType switch
			{
				ExpressionType.Negate => Negate(operand, method), 
				ExpressionType.NegateChecked => NegateChecked(operand, method), 
				ExpressionType.Not => Not(operand, method), 
				ExpressionType.IsFalse => IsFalse(operand, method), 
				ExpressionType.IsTrue => IsTrue(operand, method), 
				ExpressionType.OnesComplement => OnesComplement(operand, method), 
				ExpressionType.ArrayLength => ArrayLength(operand), 
				ExpressionType.Convert => Convert(operand, type, method), 
				ExpressionType.ConvertChecked => ConvertChecked(operand, type, method), 
				ExpressionType.Throw => Throw(operand, type), 
				ExpressionType.TypeAs => TypeAs(operand, type), 
				ExpressionType.Quote => Quote(operand), 
				ExpressionType.UnaryPlus => UnaryPlus(operand, method), 
				ExpressionType.Unbox => Unbox(operand, type), 
				ExpressionType.Increment => Increment(operand, method), 
				ExpressionType.Decrement => Decrement(operand, method), 
				ExpressionType.PreIncrementAssign => PreIncrementAssign(operand, method), 
				ExpressionType.PostIncrementAssign => PostIncrementAssign(operand, method), 
				ExpressionType.PreDecrementAssign => PreDecrementAssign(operand, method), 
				ExpressionType.PostDecrementAssign => PostDecrementAssign(operand, method), 
				_ => throw Error.UnhandledUnary(unaryType, "unaryType"), 
			};
		}

		private static UnaryExpression GetUserDefinedUnaryOperatorOrThrow(ExpressionType unaryType, string name, Expression operand)
		{
			UnaryExpression userDefinedUnaryOperator = GetUserDefinedUnaryOperator(unaryType, name, operand);
			if (userDefinedUnaryOperator != null)
			{
				ValidateParamswithOperandsOrThrow(userDefinedUnaryOperator.Method.GetParametersCached()[0].ParameterType, operand.Type, unaryType, name);
				return userDefinedUnaryOperator;
			}
			throw Error.UnaryOperatorNotDefined(unaryType, operand.Type);
		}

		private static UnaryExpression GetUserDefinedUnaryOperator(ExpressionType unaryType, string name, Expression operand)
		{
			Type type = operand.Type;
			Type[] array = new Type[1] { type };
			Type nonNullableType = type.GetNonNullableType();
			MethodInfo anyStaticMethodValidated = nonNullableType.GetAnyStaticMethodValidated(name, array);
			if (anyStaticMethodValidated != null)
			{
				return new UnaryExpression(unaryType, operand, anyStaticMethodValidated.ReturnType, anyStaticMethodValidated);
			}
			if (type.IsNullableType())
			{
				array[0] = nonNullableType;
				anyStaticMethodValidated = nonNullableType.GetAnyStaticMethodValidated(name, array);
				if (anyStaticMethodValidated != null && anyStaticMethodValidated.ReturnType.IsValueType && !anyStaticMethodValidated.ReturnType.IsNullableType())
				{
					return new UnaryExpression(unaryType, operand, anyStaticMethodValidated.ReturnType.GetNullableType(), anyStaticMethodValidated);
				}
			}
			return null;
		}

		private static UnaryExpression GetMethodBasedUnaryOperator(ExpressionType unaryType, Expression operand, MethodInfo method)
		{
			ValidateOperator(method);
			ParameterInfo[] parametersCached = method.GetParametersCached();
			if (parametersCached.Length != 1)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(method, "method");
			}
			if (ParameterIsAssignable(parametersCached[0], operand.Type))
			{
				ValidateParamswithOperandsOrThrow(parametersCached[0].ParameterType, operand.Type, unaryType, method.Name);
				return new UnaryExpression(unaryType, operand, method.ReturnType, method);
			}
			if (operand.Type.IsNullableType() && ParameterIsAssignable(parametersCached[0], operand.Type.GetNonNullableType()) && method.ReturnType.IsValueType && !method.ReturnType.IsNullableType())
			{
				return new UnaryExpression(unaryType, operand, method.ReturnType.GetNullableType(), method);
			}
			throw Error.OperandTypesDoNotMatchParameters(unaryType, method.Name);
		}

		private static UnaryExpression GetUserDefinedCoercionOrThrow(ExpressionType coercionType, Expression expression, Type convertToType)
		{
			UnaryExpression userDefinedCoercion = GetUserDefinedCoercion(coercionType, expression, convertToType);
			if (userDefinedCoercion != null)
			{
				return userDefinedCoercion;
			}
			throw Error.CoercionOperatorNotDefined(expression.Type, convertToType);
		}

		private static UnaryExpression GetUserDefinedCoercion(ExpressionType coercionType, Expression expression, Type convertToType)
		{
			MethodInfo userDefinedCoercionMethod = TypeUtils.GetUserDefinedCoercionMethod(expression.Type, convertToType);
			if (userDefinedCoercionMethod != null)
			{
				return new UnaryExpression(coercionType, expression, convertToType, userDefinedCoercionMethod);
			}
			return null;
		}

		private static UnaryExpression GetMethodBasedCoercionOperator(ExpressionType unaryType, Expression operand, Type convertToType, MethodInfo method)
		{
			ValidateOperator(method);
			ParameterInfo[] parametersCached = method.GetParametersCached();
			if (parametersCached.Length != 1)
			{
				throw Error.IncorrectNumberOfMethodCallArguments(method, "method");
			}
			if (ParameterIsAssignable(parametersCached[0], operand.Type) && TypeUtils.AreEquivalent(method.ReturnType, convertToType))
			{
				return new UnaryExpression(unaryType, operand, method.ReturnType, method);
			}
			if ((operand.Type.IsNullableType() || convertToType.IsNullableType()) && ParameterIsAssignable(parametersCached[0], operand.Type.GetNonNullableType()) && (TypeUtils.AreEquivalent(method.ReturnType, convertToType.GetNonNullableType()) || TypeUtils.AreEquivalent(method.ReturnType, convertToType)))
			{
				return new UnaryExpression(unaryType, operand, convertToType, method);
			}
			throw Error.OperandTypesDoNotMatchParameters(unaryType, method.Name);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The unary minus operator is not defined for <paramref name="expression" />.Type.</exception>
		public static UnaryExpression Negate(Expression expression)
		{
			return Negate(expression, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Negate" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.-or-
		///         <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</exception>
		public static UnaryExpression Negate(Expression expression, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			if (method == null)
			{
				if (expression.Type.IsArithmetic() && !expression.Type.IsUnsignedInt())
				{
					return new UnaryExpression(ExpressionType.Negate, expression, expression.Type, null);
				}
				return GetUserDefinedUnaryOperatorOrThrow(ExpressionType.Negate, "op_UnaryNegation", expression);
			}
			return GetMethodBasedUnaryOperator(ExpressionType.Negate, expression, method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The unary plus operator is not defined for <paramref name="expression" />.Type.</exception>
		public static UnaryExpression UnaryPlus(Expression expression)
		{
			return UnaryPlus(expression, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a unary plus operation.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.UnaryPlus" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the unary plus operator is not defined for <paramref name="expression" />.Type.-or-
		///         <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</exception>
		public static UnaryExpression UnaryPlus(Expression expression, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			if (method == null)
			{
				if (expression.Type.IsArithmetic())
				{
					return new UnaryExpression(ExpressionType.UnaryPlus, expression, expression.Type, null);
				}
				return GetUserDefinedUnaryOperatorOrThrow(ExpressionType.UnaryPlus, "op_UnaryPlus", expression);
			}
			return GetMethodBasedUnaryOperator(ExpressionType.UnaryPlus, expression, method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The unary minus operator is not defined for <paramref name="expression" />.Type.</exception>
		public static UnaryExpression NegateChecked(Expression expression)
		{
			return NegateChecked(expression, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an arithmetic negation operation that has overflow checking. The implementing method can be specified.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.NegateChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the unary minus operator is not defined for <paramref name="expression" />.Type.-or-
		///         <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</exception>
		public static UnaryExpression NegateChecked(Expression expression, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			if (method == null)
			{
				if (expression.Type.IsArithmetic() && !expression.Type.IsUnsignedInt())
				{
					return new UnaryExpression(ExpressionType.NegateChecked, expression, expression.Type, null);
				}
				return GetUserDefinedUnaryOperatorOrThrow(ExpressionType.NegateChecked, "op_UnaryNegation", expression);
			}
			return GetMethodBasedUnaryOperator(ExpressionType.NegateChecked, expression, method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The unary not operator is not defined for <paramref name="expression" />.Type.</exception>
		public static UnaryExpression Not(Expression expression)
		{
			return Not(expression, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a bitwise complement operation. The implementing method can be specified.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Not" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</exception>
		/// <exception cref="T:System.InvalidOperationException">
		///         <paramref name="method" /> is <see langword="null" /> and the unary not operator is not defined for <paramref name="expression" />.Type.-or-
		///         <paramref name="expression" />.Type (or its corresponding non-nullable type if it is a nullable value type) is not assignable to the argument type of the method represented by <paramref name="method" />.</exception>
		public static UnaryExpression Not(Expression expression, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			if (method == null)
			{
				if (expression.Type.IsIntegerOrBool())
				{
					return new UnaryExpression(ExpressionType.Not, expression, expression.Type, null);
				}
				UnaryExpression userDefinedUnaryOperator = GetUserDefinedUnaryOperator(ExpressionType.Not, "op_LogicalNot", expression);
				if (userDefinedUnaryOperator != null)
				{
					return userDefinedUnaryOperator;
				}
				return GetUserDefinedUnaryOperatorOrThrow(ExpressionType.Not, "op_OnesComplement", expression);
			}
			return GetMethodBasedUnaryOperator(ExpressionType.Not, expression, method);
		}

		/// <summary>Returns whether the expression evaluates to false.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</param>
		/// <returns>An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
		public static UnaryExpression IsFalse(Expression expression)
		{
			return IsFalse(expression, null);
		}

		/// <summary>Returns whether the expression evaluates to false.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</param>
		/// <returns>An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
		public static UnaryExpression IsFalse(Expression expression, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			if (method == null)
			{
				if (expression.Type.IsBool())
				{
					return new UnaryExpression(ExpressionType.IsFalse, expression, expression.Type, null);
				}
				return GetUserDefinedUnaryOperatorOrThrow(ExpressionType.IsFalse, "op_False", expression);
			}
			return GetMethodBasedUnaryOperator(ExpressionType.IsFalse, expression, method);
		}

		/// <summary>Returns whether the expression evaluates to true.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</param>
		/// <returns>An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
		public static UnaryExpression IsTrue(Expression expression)
		{
			return IsTrue(expression, null);
		}

		/// <summary>Returns whether the expression evaluates to true.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to evaluate.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</param>
		/// <returns>An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
		public static UnaryExpression IsTrue(Expression expression, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			if (method == null)
			{
				if (expression.Type.IsBool())
				{
					return new UnaryExpression(ExpressionType.IsTrue, expression, expression.Type, null);
				}
				return GetUserDefinedUnaryOperatorOrThrow(ExpressionType.IsTrue, "op_True", expression);
			}
			return GetMethodBasedUnaryOperator(ExpressionType.IsTrue, expression, method);
		}

		/// <summary>Returns the expression representing the ones complement.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />.</param>
		/// <returns>An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
		public static UnaryExpression OnesComplement(Expression expression)
		{
			return OnesComplement(expression, null);
		}

		/// <summary>Returns the expression representing the ones complement.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" />.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</param>
		/// <returns>An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
		public static UnaryExpression OnesComplement(Expression expression, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			if (method == null)
			{
				if (expression.Type.IsInteger())
				{
					return new UnaryExpression(ExpressionType.OnesComplement, expression, expression.Type, null);
				}
				return GetUserDefinedUnaryOperatorOrThrow(ExpressionType.OnesComplement, "op_OnesComplement", expression);
			}
			return GetMethodBasedUnaryOperator(ExpressionType.OnesComplement, expression, method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit reference or boxing conversion where <see langword="null" /> is supplied if the conversion fails.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <param name="type">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.TypeAs" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</exception>
		public static UnaryExpression TypeAs(Expression expression, Type type)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			ContractUtils.RequiresNotNull(type, "type");
			TypeUtils.ValidateType(type, "type");
			if (type.IsValueType && !type.IsNullableType())
			{
				throw Error.IncorrectTypeForTypeAs(type, "type");
			}
			return new UnaryExpression(ExpressionType.TypeAs, expression, type, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an explicit unboxing.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to unbox.</param>
		/// <param name="type">The new <see cref="T:System.Type" /> of the expression.</param>
		/// <returns>An instance of <see cref="T:System.Linq.Expressions.UnaryExpression" />.</returns>
		public static UnaryExpression Unbox(Expression expression, Type type)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			ContractUtils.RequiresNotNull(type, "type");
			if (!expression.Type.IsInterface && expression.Type != typeof(object))
			{
				throw Error.InvalidUnboxType("expression");
			}
			if (!type.IsValueType)
			{
				throw Error.InvalidUnboxType("type");
			}
			TypeUtils.ValidateType(type, "type");
			return new UnaryExpression(ExpressionType.Unbox, expression, type, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a type conversion operation.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <param name="type">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</exception>
		public static UnaryExpression Convert(Expression expression, Type type)
		{
			return Convert(expression, type, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation for which the implementing method is specified.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <param name="type">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Convert" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</exception>
		/// <exception cref="T:System.InvalidOperationException">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.-or-
		///         <paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.-or-The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.-or-
		///         <paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</exception>
		/// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method that matches the <paramref name="method" /> description was found.</exception>
		public static UnaryExpression Convert(Expression expression, Type type, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			ContractUtils.RequiresNotNull(type, "type");
			TypeUtils.ValidateType(type, "type");
			if (method == null)
			{
				if (expression.Type.HasIdentityPrimitiveOrNullableConversionTo(type) || expression.Type.HasReferenceConversionTo(type))
				{
					return new UnaryExpression(ExpressionType.Convert, expression, type, null);
				}
				return GetUserDefinedCoercionOrThrow(ExpressionType.Convert, expression, type);
			}
			return GetMethodBasedCoercionOperator(ExpressionType.Convert, expression, type, method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <param name="type">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.</exception>
		public static UnaryExpression ConvertChecked(Expression expression, Type type)
		{
			return ConvertChecked(expression, type, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a conversion operation that throws an exception if the target type is overflowed and for which the implementing method is specified.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <param name="type">A <see cref="T:System.Type" /> to set the <see cref="P:System.Linq.Expressions.Expression.Type" /> property equal to.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" />, <see cref="P:System.Linq.Expressions.Expression.Type" />, and <see cref="P:System.Linq.Expressions.UnaryExpression.Method" /> properties set to the specified values.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> or <paramref name="type" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="method" /> is not <see langword="null" /> and the method it represents returns <see langword="void" />, is not <see langword="static" /> (<see langword="Shared" /> in Visual Basic), or does not take exactly one argument.</exception>
		/// <exception cref="T:System.InvalidOperationException">No conversion operator is defined between <paramref name="expression" />.Type and <paramref name="type" />.-or-
		///         <paramref name="expression" />.Type is not assignable to the argument type of the method represented by <paramref name="method" />.-or-The return type of the method represented by <paramref name="method" /> is not assignable to <paramref name="type" />.-or-
		///         <paramref name="expression" />.Type or <paramref name="type" /> is a nullable value type and the corresponding non-nullable value type does not equal the argument type or the return type, respectively, of the method represented by <paramref name="method" />.</exception>
		/// <exception cref="T:System.Reflection.AmbiguousMatchException">More than one method that matches the <paramref name="method" /> description was found.</exception>
		public static UnaryExpression ConvertChecked(Expression expression, Type type, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			ContractUtils.RequiresNotNull(type, "type");
			TypeUtils.ValidateType(type, "type");
			if (method == null)
			{
				if (expression.Type.HasIdentityPrimitiveOrNullableConversionTo(type))
				{
					return new UnaryExpression(ExpressionType.ConvertChecked, expression, type, null);
				}
				if (expression.Type.HasReferenceConversionTo(type))
				{
					return new UnaryExpression(ExpressionType.Convert, expression, type, null);
				}
				return GetUserDefinedCoercionOrThrow(ExpressionType.ConvertChecked, expression, type);
			}
			return GetMethodBasedCoercionOperator(ExpressionType.ConvertChecked, expression, type, method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression for obtaining the length of a one-dimensional array.</summary>
		/// <param name="array">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ArrayLength" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to <paramref name="array" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="array" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="array" />.Type does not represent an array type.</exception>
		public static UnaryExpression ArrayLength(Expression array)
		{
			ExpressionUtils.RequiresCanRead(array, "array");
			if (!array.Type.IsSZArray)
			{
				if (!array.Type.IsArray || !typeof(Array).IsAssignableFrom(array.Type))
				{
					throw Error.ArgumentMustBeArray("array");
				}
				throw Error.ArgumentMustBeSingleDimensionalArrayType("array");
			}
			return new UnaryExpression(ExpressionType.ArrayLength, array, typeof(int), null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents an expression that has a constant value of type <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to set the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property equal to.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property set to the specified value.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="expression" /> is <see langword="null" />.</exception>
		public static UnaryExpression Quote(Expression expression)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			if (!(expression is LambdaExpression lambdaExpression))
			{
				throw Error.QuotedExpressionMustBeLambda("expression");
			}
			return new UnaryExpression(ExpressionType.Quote, lambdaExpression, lambdaExpression.PublicType, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</summary>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</returns>
		public static UnaryExpression Rethrow()
		{
			return Throw(null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception with a given type.</summary>
		/// <param name="type">The new <see cref="T:System.Type" /> of the expression.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a rethrowing of an exception.</returns>
		public static UnaryExpression Rethrow(Type type)
		{
			return Throw(null, type);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception.</summary>
		/// <param name="value">An <see cref="T:System.Linq.Expressions.Expression" />.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</returns>
		public static UnaryExpression Throw(Expression value)
		{
			return Throw(value, typeof(void));
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents a throwing of an exception with a given type.</summary>
		/// <param name="value">An <see cref="T:System.Linq.Expressions.Expression" />.</param>
		/// <param name="type">The new <see cref="T:System.Type" /> of the expression.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the exception.</returns>
		public static UnaryExpression Throw(Expression value, Type type)
		{
			ContractUtils.RequiresNotNull(type, "type");
			TypeUtils.ValidateType(type, "type");
			if (value != null)
			{
				ExpressionUtils.RequiresCanRead(value, "value");
				if (value.Type.IsValueType)
				{
					throw Error.ArgumentMustNotHaveValueType("value");
				}
			}
			return new UnaryExpression(ExpressionType.Throw, value, type, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression value by 1.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</returns>
		public static UnaryExpression Increment(Expression expression)
		{
			return Increment(expression, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incrementing of the expression by 1.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to increment.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the incremented expression.</returns>
		public static UnaryExpression Increment(Expression expression, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			if (method == null)
			{
				if (expression.Type.IsArithmetic())
				{
					return new UnaryExpression(ExpressionType.Increment, expression, expression.Type, null);
				}
				return GetUserDefinedUnaryOperatorOrThrow(ExpressionType.Increment, "op_Increment", expression);
			}
			return GetMethodBasedUnaryOperator(ExpressionType.Increment, expression, method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</returns>
		public static UnaryExpression Decrement(Expression expression)
		{
			return Decrement(expression, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decrementing of the expression by 1.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to decrement.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the decremented expression.</returns>
		public static UnaryExpression Decrement(Expression expression, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			if (method == null)
			{
				if (expression.Type.IsArithmetic())
				{
					return new UnaryExpression(ExpressionType.Decrement, expression, expression.Type, null);
				}
				return GetUserDefinedUnaryOperatorOrThrow(ExpressionType.Decrement, "op_Decrement", expression);
			}
			return GetMethodBasedUnaryOperator(ExpressionType.Decrement, expression, method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</returns>
		public static UnaryExpression PreIncrementAssign(Expression expression)
		{
			return MakeOpAssignUnary(ExpressionType.PreIncrementAssign, expression, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that increments the expression by 1 and assigns the result back to the expression.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</returns>
		public static UnaryExpression PreIncrementAssign(Expression expression, MethodInfo method)
		{
			return MakeOpAssignUnary(ExpressionType.PreIncrementAssign, expression, method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</returns>
		public static UnaryExpression PreDecrementAssign(Expression expression)
		{
			return MakeOpAssignUnary(ExpressionType.PreDecrementAssign, expression, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that decrements the expression by 1 and assigns the result back to the expression.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</returns>
		public static UnaryExpression PreDecrementAssign(Expression expression, MethodInfo method)
		{
			return MakeOpAssignUnary(ExpressionType.PreDecrementAssign, expression, method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</returns>
		public static UnaryExpression PostIncrementAssign(Expression expression)
		{
			return MakeOpAssignUnary(ExpressionType.PostIncrementAssign, expression, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent increment by 1 of the original expression.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</returns>
		public static UnaryExpression PostIncrementAssign(Expression expression, MethodInfo method)
		{
			return MakeOpAssignUnary(ExpressionType.PostIncrementAssign, expression, method);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</returns>
		public static UnaryExpression PostDecrementAssign(Expression expression)
		{
			return MakeOpAssignUnary(ExpressionType.PostDecrementAssign, expression, null);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the assignment of the expression followed by a subsequent decrement by 1 of the original expression.</summary>
		/// <param name="expression">An <see cref="T:System.Linq.Expressions.Expression" /> to apply the operations on.</param>
		/// <param name="method">A <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.UnaryExpression" /> that represents the resultant expression.</returns>
		public static UnaryExpression PostDecrementAssign(Expression expression, MethodInfo method)
		{
			return MakeOpAssignUnary(ExpressionType.PostDecrementAssign, expression, method);
		}

		private static UnaryExpression MakeOpAssignUnary(ExpressionType kind, Expression expression, MethodInfo method)
		{
			ExpressionUtils.RequiresCanRead(expression, "expression");
			RequiresCanWrite(expression, "expression");
			UnaryExpression unaryExpression;
			if (method == null)
			{
				if (expression.Type.IsArithmetic())
				{
					return new UnaryExpression(kind, expression, expression.Type, null);
				}
				string name = ((kind != ExpressionType.PreIncrementAssign && kind != ExpressionType.PostIncrementAssign) ? "op_Decrement" : "op_Increment");
				unaryExpression = GetUserDefinedUnaryOperatorOrThrow(kind, name, expression);
			}
			else
			{
				unaryExpression = GetMethodBasedUnaryOperator(kind, expression, method);
			}
			if (!TypeUtils.AreReferenceAssignable(expression.Type, unaryExpression.Type))
			{
				throw Error.UserDefinedOpMustHaveValidReturnType(kind, method.Name);
			}
			return unaryExpression;
		}
	}
	/// <summary>Represents a block that contains a sequence of expressions where variables can be defined.</summary>
	[DebuggerTypeProxy(typeof(BlockExpressionProxy))]
	public class BlockExpression : Expression
	{
		/// <summary>Gets the expressions in this block.</summary>
		/// <returns>The read-only collection containing all the expressions in this block.</returns>
		public ReadOnlyCollection<Expression> Expressions => GetOrMakeExpressions();

		/// <summary>Gets the variables defined in this block.</summary>
		/// <returns>The read-only collection containing all the variables defined in this block.</returns>
		public ReadOnlyCollection<ParameterExpression> Variables => GetOrMakeVariables();

		/// <summary>Gets the last expression in this block.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.Expression" /> object representing the last expression in this block.</returns>
		public Expression Result => GetExpression(ExpressionCount - 1);

		/// <summary>Returns the node type of this expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> when overriding this method.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> of the expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Block;

		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.BlockExpression.Type" /> that represents the static type of the expression.</returns>
		public override Type Type => GetExpression(ExpressionCount - 1).Type;

		[ExcludeFromCodeCoverage]
		internal virtual int ExpressionCount
		{
			get
			{
				throw ContractUtils.Unreachable;
			}
		}

		internal BlockExpression()
		{
		}

		/// <summary>Dispatches to the specific visit method for this node type. For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
		/// <param name="visitor">The visitor to visit this node with.</param>
		/// <returns>The result of visiting this node.</returns>
		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitBlock(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="variables">The <see cref="P:System.Linq.Expressions.BlockExpression.Variables" /> property of the result. </param>
		/// <param name="expressions">The <see cref="P:System.Linq.Expressions.BlockExpression.Expressions" /> property of the result. </param>
		/// <returns>This expression if no children changed, or an expression with the updated children.</returns>
		public BlockExpression Update(IEnumerable<ParameterExpression> variables, IEnumerable<Expression> expressions)
		{
			if (expressions != null)
			{
				ICollection<ParameterExpression> collection;
				if (variables == null)
				{
					collection = null;
				}
				else
				{
					collection = variables as ICollection<ParameterExpression>;
					if (collection == null)
					{
						variables = (collection = variables.ToReadOnly());
					}
				}
				if (SameVariables(collection))
				{
					ICollection<Expression> collection2 = expressions as ICollection<Expression>;
					if (collection2 == null)
					{
						expressions = (collection2 = expressions.ToReadOnly());
					}
					if (SameExpressions(collection2))
					{
						return this;
					}
				}
			}
			return Expression.Block(Type, variables, expressions);
		}

		internal virtual bool SameVariables(ICollection<ParameterExpression> variables)
		{
			if (variables != null)
			{
				return variables.Count == 0;
			}
			return true;
		}

		[ExcludeFromCodeCoverage]
		internal virtual bool SameExpressions(ICollection<Expression> expressions)
		{
			throw ContractUtils.Unreachable;
		}

		[ExcludeFromCodeCoverage]
		internal virtual Expression GetExpression(int index)
		{
			throw ContractUtils.Unreachable;
		}

		[ExcludeFromCodeCoverage]
		internal virtual ReadOnlyCollection<Expression> GetOrMakeExpressions()
		{
			throw ContractUtils.Unreachable;
		}

		internal virtual ReadOnlyCollection<ParameterExpression> GetOrMakeVariables()
		{
			return EmptyReadOnlyCollection<ParameterExpression>.Instance;
		}

		[ExcludeFromCodeCoverage]
		internal virtual BlockExpression Rewrite(ReadOnlyCollection<ParameterExpression> variables, Expression[] args)
		{
			throw ContractUtils.Unreachable;
		}

		internal static ReadOnlyCollection<Expression> ReturnReadOnlyExpressions(BlockExpression provider, ref object collection)
		{
			if (collection is Expression expression)
			{
				Interlocked.CompareExchange(ref collection, new ReadOnlyCollection<Expression>(new BlockExpressionList(provider, expression)), expression);
			}
			return (ReadOnlyCollection<Expression>)collection;
		}
	}
	internal sealed class Block2 : BlockExpression
	{
		private object _arg0;

		private readonly Expression _arg1;

		internal override int ExpressionCount => 2;

		internal Block2(Expression arg0, Expression arg1)
		{
			_arg0 = arg0;
			_arg1 = arg1;
		}

		internal override Expression GetExpression(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				_ => throw Error.ArgumentOutOfRange("index"), 
			};
		}

		internal override bool SameExpressions(ICollection<Expression> expressions)
		{
			if (expressions.Count == 2)
			{
				if (_arg0 is ReadOnlyCollection<Expression> current)
				{
					return ExpressionUtils.SameElements(expressions, current);
				}
				using IEnumerator<Expression> enumerator = expressions.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _arg0)
				{
					enumerator.MoveNext();
					return enumerator.Current == _arg1;
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeExpressions()
		{
			return BlockExpression.ReturnReadOnlyExpressions(this, ref _arg0);
		}

		internal override BlockExpression Rewrite(ReadOnlyCollection<ParameterExpression> variables, Expression[] args)
		{
			return new Block2(args[0], args[1]);
		}
	}
	internal sealed class Block3 : BlockExpression
	{
		private object _arg0;

		private readonly Expression _arg1;

		private readonly Expression _arg2;

		internal override int ExpressionCount => 3;

		internal Block3(Expression arg0, Expression arg1, Expression arg2)
		{
			_arg0 = arg0;
			_arg1 = arg1;
			_arg2 = arg2;
		}

		internal override bool SameExpressions(ICollection<Expression> expressions)
		{
			if (expressions.Count == 3)
			{
				if (_arg0 is ReadOnlyCollection<Expression> current)
				{
					return ExpressionUtils.SameElements(expressions, current);
				}
				using IEnumerator<Expression> enumerator = expressions.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _arg0)
				{
					enumerator.MoveNext();
					if (enumerator.Current == _arg1)
					{
						enumerator.MoveNext();
						return enumerator.Current == _arg2;
					}
				}
			}
			return false;
		}

		internal override Expression GetExpression(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				2 => _arg2, 
				_ => throw Error.ArgumentOutOfRange("index"), 
			};
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeExpressions()
		{
			return BlockExpression.ReturnReadOnlyExpressions(this, ref _arg0);
		}

		internal override BlockExpression Rewrite(ReadOnlyCollection<ParameterExpression> variables, Expression[] args)
		{
			return new Block3(args[0], args[1], args[2]);
		}
	}
	internal sealed class Block4 : BlockExpression
	{
		private object _arg0;

		private readonly Expression _arg1;

		private readonly Expression _arg2;

		private readonly Expression _arg3;

		internal override int ExpressionCount => 4;

		internal Block4(Expression arg0, Expression arg1, Expression arg2, Expression arg3)
		{
			_arg0 = arg0;
			_arg1 = arg1;
			_arg2 = arg2;
			_arg3 = arg3;
		}

		internal override bool SameExpressions(ICollection<Expression> expressions)
		{
			if (expressions.Count == 4)
			{
				if (_arg0 is ReadOnlyCollection<Expression> current)
				{
					return ExpressionUtils.SameElements(expressions, current);
				}
				using IEnumerator<Expression> enumerator = expressions.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _arg0)
				{
					enumerator.MoveNext();
					if (enumerator.Current == _arg1)
					{
						enumerator.MoveNext();
						if (enumerator.Current == _arg2)
						{
							enumerator.MoveNext();
							return enumerator.Current == _arg3;
						}
					}
				}
			}
			return false;
		}

		internal override Expression GetExpression(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				2 => _arg2, 
				3 => _arg3, 
				_ => throw Error.ArgumentOutOfRange("index"), 
			};
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeExpressions()
		{
			return BlockExpression.ReturnReadOnlyExpressions(this, ref _arg0);
		}

		internal override BlockExpression Rewrite(ReadOnlyCollection<ParameterExpression> variables, Expression[] args)
		{
			return new Block4(args[0], args[1], args[2], args[3]);
		}
	}
	internal sealed class Block5 : BlockExpression
	{
		private object _arg0;

		private readonly Expression _arg1;

		private readonly Expression _arg2;

		private readonly Expression _arg3;

		private readonly Expression _arg4;

		internal override int ExpressionCount => 5;

		internal Block5(Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4)
		{
			_arg0 = arg0;
			_arg1 = arg1;
			_arg2 = arg2;
			_arg3 = arg3;
			_arg4 = arg4;
		}

		internal override Expression GetExpression(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				2 => _arg2, 
				3 => _arg3, 
				4 => _arg4, 
				_ => throw Error.ArgumentOutOfRange("index"), 
			};
		}

		internal override bool SameExpressions(ICollection<Expression> expressions)
		{
			if (expressions.Count == 5)
			{
				if (_arg0 is ReadOnlyCollection<Expression> current)
				{
					return ExpressionUtils.SameElements(expressions, current);
				}
				using IEnumerator<Expression> enumerator = expressions.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _arg0)
				{
					enumerator.MoveNext();
					if (enumerator.Current == _arg1)
					{
						enumerator.MoveNext();
						if (enumerator.Current == _arg2)
						{
							enumerator.MoveNext();
							if (enumerator.Current == _arg3)
							{
								enumerator.MoveNext();
								return enumerator.Current == _arg4;
							}
						}
					}
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeExpressions()
		{
			return BlockExpression.ReturnReadOnlyExpressions(this, ref _arg0);
		}

		internal override BlockExpression Rewrite(ReadOnlyCollection<ParameterExpression> variables, Expression[] args)
		{
			return new Block5(args[0], args[1], args[2], args[3], args[4]);
		}
	}
	internal class BlockN : BlockExpression
	{
		private IReadOnlyList<Expression> _expressions;

		internal override int ExpressionCount => _expressions.Count;

		internal BlockN(IReadOnlyList<Expression> expressions)
		{
			_expressions = expressions;
		}

		internal override bool SameExpressions(ICollection<Expression> expressions)
		{
			return ExpressionUtils.SameElements(expressions, _expressions);
		}

		internal override Expression GetExpression(int index)
		{
			return _expressions[index];
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeExpressions()
		{
			return ExpressionUtils.ReturnReadOnly(ref _expressions);
		}

		internal override BlockExpression Rewrite(ReadOnlyCollection<ParameterExpression> variables, Expression[] args)
		{
			return new BlockN(args);
		}
	}
	internal class ScopeExpression : BlockExpression
	{
		private IReadOnlyList<ParameterExpression> _variables;

		protected IReadOnlyList<ParameterExpression> VariablesList => _variables;

		internal ScopeExpression(IReadOnlyList<ParameterExpression> variables)
		{
			_variables = variables;
		}

		internal override bool SameVariables(ICollection<ParameterExpression> variables)
		{
			return ExpressionUtils.SameElements(variables, _variables);
		}

		internal override ReadOnlyCollection<ParameterExpression> GetOrMakeVariables()
		{
			return ExpressionUtils.ReturnReadOnly(ref _variables);
		}

		internal IReadOnlyList<ParameterExpression> ReuseOrValidateVariables(ReadOnlyCollection<ParameterExpression> variables)
		{
			if (variables != null && variables != VariablesList)
			{
				Expression.ValidateVariables(variables, "variables");
				return variables;
			}
			return VariablesList;
		}
	}
	internal sealed class Scope1 : ScopeExpression
	{
		private object _body;

		internal override int ExpressionCount => 1;

		internal Scope1(IReadOnlyList<ParameterExpression> variables, Expression body)
			: this(variables, (object)body)
		{
		}

		private Scope1(IReadOnlyList<ParameterExpression> variables, object body)
			: base(variables)
		{
			_body = body;
		}

		internal override bool SameExpressions(ICollection<Expression> expressions)
		{
			if (expressions.Count == 1)
			{
				if (_body is ReadOnlyCollection<Expression> current)
				{
					return ExpressionUtils.SameElements(expressions, current);
				}
				using IEnumerator<Expression> enumerator = expressions.GetEnumerator();
				enumerator.MoveNext();
				return ExpressionUtils.ReturnObject<Expression>(_body) == enumerator.Current;
			}
			return false;
		}

		internal override Expression GetExpression(int index)
		{
			if (index == 0)
			{
				return ExpressionUtils.ReturnObject<Expression>(_body);
			}
			throw Error.ArgumentOutOfRange("index");
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeExpressions()
		{
			return BlockExpression.ReturnReadOnlyExpressions(this, ref _body);
		}

		internal override BlockExpression Rewrite(ReadOnlyCollection<ParameterExpression> variables, Expression[] args)
		{
			if (args == null)
			{
				Expression.ValidateVariables(variables, "variables");
				return new Scope1(variables, _body);
			}
			return new Scope1(ReuseOrValidateVariables(variables), args[0]);
		}
	}
	internal class ScopeN : ScopeExpression
	{
		private IReadOnlyList<Expression> _body;

		protected IReadOnlyList<Expression> Body => _body;

		internal override int ExpressionCount => _body.Count;

		internal ScopeN(IReadOnlyList<ParameterExpression> variables, IReadOnlyList<Expression> body)
			: base(variables)
		{
			_body = body;
		}

		internal override bool SameExpressions(ICollection<Expression> expressions)
		{
			return ExpressionUtils.SameElements(expressions, _body);
		}

		internal override Expression GetExpression(int index)
		{
			return _body[index];
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeExpressions()
		{
			return ExpressionUtils.ReturnReadOnly(ref _body);
		}

		internal override BlockExpression Rewrite(ReadOnlyCollection<ParameterExpression> variables, Expression[] args)
		{
			if (args == null)
			{
				Expression.ValidateVariables(variables, "variables");
				return new ScopeN(variables, _body);
			}
			return new ScopeN(ReuseOrValidateVariables(variables), args);
		}
	}
	internal sealed class ScopeWithType : ScopeN
	{
		public sealed override Type Type { get; }

		internal ScopeWithType(IReadOnlyList<ParameterExpression> variables, IReadOnlyList<Expression> expressions, Type type)
			: base(variables, expressions)
		{
			Type = type;
		}

		internal override BlockExpression Rewrite(ReadOnlyCollection<ParameterExpression> variables, Expression[] args)
		{
			if (args == null)
			{
				Expression.ValidateVariables(variables, "variables");
				return new ScopeWithType(variables, base.Body, Type);
			}
			return new ScopeWithType(ReuseOrValidateVariables(variables), args, Type);
		}
	}
	internal class BlockExpressionList : IList<Expression>, ICollection<Expression>, IEnumerable<Expression>, IEnumerable
	{
		private readonly BlockExpression _block;

		private readonly Expression _arg0;

		public Expression this[int index]
		{
			get
			{
				if (index == 0)
				{
					return _arg0;
				}
				return _block.GetExpression(index);
			}
			[ExcludeFromCodeCoverage]
			set
			{
				throw ContractUtils.Unreachable;
			}
		}

		public int Count => _block.ExpressionCount;

		[ExcludeFromCodeCoverage]
		public bool IsReadOnly
		{
			get
			{
				throw ContractUtils.Unreachable;
			}
		}

		internal BlockExpressionList(BlockExpression provider, Expression arg0)
		{
			_block = provider;
			_arg0 = arg0;
		}

		public int IndexOf(Expression item)
		{
			if (_arg0 == item)
			{
				return 0;
			}
			for (int i = 1; i < _block.ExpressionCount; i++)
			{
				if (_block.GetExpression(i) == item)
				{
					return i;
				}
			}
			return -1;
		}

		[ExcludeFromCodeCoverage]
		public void Insert(int index, Expression item)
		{
			throw ContractUtils.Unreachable;
		}

		[ExcludeFromCodeCoverage]
		public void RemoveAt(int index)
		{
			throw ContractUtils.Unreachable;
		}

		[ExcludeFromCodeCoverage]
		public void Add(Expression item)
		{
			throw ContractUtils.Unreachable;
		}

		[ExcludeFromCodeCoverage]
		public void Clear()
		{
			throw ContractUtils.Unreachable;
		}

		public bool Contains(Expression item)
		{
			return IndexOf(item) != -1;
		}

		public void CopyTo(Expression[] array, int index)
		{
			ContractUtils.RequiresNotNull(array, "array");
			if (index < 0)
			{
				throw Error.ArgumentOutOfRange("index");
			}
			int expressionCount = _block.ExpressionCount;
			if (index + expressionCount > array.Length)
			{
				throw new ArgumentException();
			}
			array[index++] = _arg0;
			for (int i = 1; i < expressionCount; i++)
			{
				array[index++] = _block.GetExpression(i);
			}
		}

		[ExcludeFromCodeCoverage]
		public bool Remove(Expression item)
		{
			throw ContractUtils.Unreachable;
		}

		public IEnumerator<Expression> GetEnumerator()
		{
			yield return _arg0;
			for (int i = 1; i < _block.ExpressionCount; i++)
			{
				yield return _block.GetExpression(i);
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	/// <summary>Represents a catch statement in a try block.</summary>
	[DebuggerTypeProxy(typeof(Expression.CatchBlockProxy))]
	public sealed class CatchBlock
	{
		/// <summary>Gets a reference to the <see cref="T:System.Exception" /> object caught by this handler.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ParameterExpression" /> object representing a reference to the <see cref="T:System.Exception" /> object caught by this handler.</returns>
		public ParameterExpression Variable { get; }

		/// <summary>Gets the type of <see cref="T:System.Exception" /> this handler catches.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the type of <see cref="T:System.Exception" /> this handler catches.</returns>
		public Type Test { get; }

		/// <summary>Gets the body of the catch block.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.Expression" /> object representing the catch body.</returns>
		public Expression Body { get; }

		/// <summary>Gets the body of the <see cref="T:System.Linq.Expressions.CatchBlock" /> filter.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.Expression" /> object representing the body of the <see cref="T:System.Linq.Expressions.CatchBlock" /> filter.</returns>
		public Expression Filter { get; }

		internal CatchBlock(Type test, ParameterExpression variable, Expression body, Expression filter)
		{
			Test = test;
			Variable = variable;
			Body = body;
			Filter = filter;
		}

		/// <summary>Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</returns>
		public override string ToString()
		{
			return ExpressionStringBuilder.CatchBlockToString(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="variable">The <see cref="P:System.Linq.Expressions.CatchBlock.Variable" /> property of the result.</param>
		/// <param name="filter">The <see cref="P:System.Linq.Expressions.CatchBlock.Filter" /> property of the result.</param>
		/// <param name="body">The <see cref="P:System.Linq.Expressions.CatchBlock.Body" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public CatchBlock Update(ParameterExpression variable, Expression filter, Expression body)
		{
			if (variable == Variable && filter == Filter && body == Body)
			{
				return this;
			}
			return Expression.MakeCatchBlock(Test, variable, body, filter);
		}

		internal CatchBlock()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal static class ArrayBuilderExtensions
	{
		public static ReadOnlyCollection<T> ToReadOnly<T>(this ArrayBuilder<T> builder)
		{
			return new TrueReadOnlyCollection<T>(builder.ToArray());
		}
	}
	internal enum AnalyzeTypeIsResult
	{
		KnownFalse,
		KnownTrue,
		KnownAssignable,
		Unknown
	}
	internal static class ConstantCheck
	{
		internal static bool IsNull(Expression e)
		{
			return e.NodeType switch
			{
				ExpressionType.Constant => ((ConstantExpression)e).Value == null, 
				ExpressionType.Default => e.Type.IsNullableOrReferenceType(), 
				_ => false, 
			};
		}

		internal static AnalyzeTypeIsResult AnalyzeTypeIs(TypeBinaryExpression typeIs)
		{
			return AnalyzeTypeIs(typeIs.Expression, typeIs.TypeOperand);
		}

		private static AnalyzeTypeIsResult AnalyzeTypeIs(Expression operand, Type testType)
		{
			Type type = operand.Type;
			if (type == typeof(void))
			{
				if (!(testType == typeof(void)))
				{
					return AnalyzeTypeIsResult.KnownFalse;
				}
				return AnalyzeTypeIsResult.KnownTrue;
			}
			if (testType == typeof(void) || testType.IsPointer)
			{
				return AnalyzeTypeIsResult.KnownFalse;
			}
			Type nonNullableType = type.GetNonNullableType();
			if (testType.GetNonNullableType().IsAssignableFrom(nonNullableType))
			{
				if (type.IsValueType && !type.IsNullableType())
				{
					return AnalyzeTypeIsResult.KnownTrue;
				}
				return AnalyzeTypeIsResult.KnownAssignable;
			}
			return AnalyzeTypeIsResult.Unknown;
		}
	}
	/// <summary>Represents an expression that has a conditional operator.</summary>
	[DebuggerTypeProxy(typeof(ConditionalExpressionProxy))]
	public class ConditionalExpression : Expression
	{
		/// <summary>Returns the node type of this expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> when overriding this method.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> of the expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Conditional;

		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.ConditionalExpression.Type" /> that represents the static type of the expression.</returns>
		public override Type Type => IfTrue.Type;

		/// <summary>Gets the test of the conditional operation.</summary>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression" /> that represents the test of the conditional operation.</returns>
		public Expression Test { get; }

		/// <summary>Gets the expression to execute if the test evaluates to <see langword="true" />.</summary>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression" /> that represents the expression to execute if the test is <see langword="true" />.</returns>
		public Expression IfTrue { get; }

		/// <summary>Gets the expression to execute if the test evaluates to <see langword="false" />.</summary>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression" /> that represents the expression to execute if the test is <see langword="false" />.</returns>
		public Expression IfFalse => GetFalse();

		internal ConditionalExpression(Expression test, Expression ifTrue)
		{
			Test = test;
			IfTrue = ifTrue;
		}

		internal static ConditionalExpression Make(Expression test, Expression ifTrue, Expression ifFalse, Type type)
		{
			if (ifTrue.Type != type || ifFalse.Type != type)
			{
				return new FullConditionalExpressionWithType(test, ifTrue, ifFalse, type);
			}
			if (ifFalse is DefaultExpression && ifFalse.Type == typeof(void))
			{
				return new ConditionalExpression(test, ifTrue);
			}
			return new FullConditionalExpression(test, ifTrue, ifFalse);
		}

		internal virtual Expression GetFalse()
		{
			return Utils.Empty;
		}

		/// <summary>Dispatches to the specific visit method for this node type. For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
		/// <param name="visitor">The visitor to visit this node with.</param>
		/// <returns>The result of visiting this node.</returns>
		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitConditional(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression</summary>
		/// <param name="test">The <see cref="P:System.Linq.Expressions.ConditionalExpression.Test" /> property of the result.</param>
		/// <param name="ifTrue">The <see cref="P:System.Linq.Expressions.ConditionalExpression.IfTrue" />property of the result.</param>
		/// <param name="ifFalse">The <see cref="P:System.Linq.Expressions.ConditionalExpression.IfFalse" /> property of the result.</param>
		/// <returns>This expression if no children changed, or an expression with the updated children.</returns>
		public ConditionalExpression Update(Expression test, Expression ifTrue, Expression ifFalse)
		{
			if (test == Test && ifTrue == IfTrue && ifFalse == IfFalse)
			{
				return this;
			}
			return Expression.Condition(test, ifTrue, ifFalse, Type);
		}

		internal ConditionalExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal class FullConditionalExpression : ConditionalExpression
	{
		private readonly Expression _false;

		internal FullConditionalExpression(Expression test, Expression ifTrue, Expression ifFalse)
			: base(test, ifTrue)
		{
			_false = ifFalse;
		}

		internal override Expression GetFalse()
		{
			return _false;
		}
	}
	internal sealed class FullConditionalExpressionWithType : FullConditionalExpression
	{
		public sealed override Type Type { get; }

		internal FullConditionalExpressionWithType(Expression test, Expression ifTrue, Expression ifFalse, Type type)
			: base(test, ifTrue, ifFalse)
		{
			Type = type;
		}
	}
	/// <summary>Represents an expression that has a constant value.</summary>
	[DebuggerTypeProxy(typeof(ConstantExpressionProxy))]
	public class ConstantExpression : Expression
	{
		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.ConstantExpression.Type" /> that represents the static type of the expression.</returns>
		public override Type Type
		{
			get
			{
				if (Value == null)
				{
					return typeof(object);
				}
				return Value.GetType();
			}
		}

		/// <summary>Returns the node type of this Expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> when overriding this method.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> of the expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Constant;

		/// <summary>Gets the value of the constant expression.</summary>
		/// <returns>An <see cref="T:System.Object" /> equal to the value of the represented expression.</returns>
		public object Value { get; }

		internal ConstantExpression(object value)
		{
			Value = value;
		}

		/// <summary>Dispatches to the specific visit method for this node type. For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
		/// <param name="visitor">The visitor to visit this node with.</param>
		/// <returns>The result of visiting this node.</returns>
		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitConstant(this);
		}

		internal ConstantExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal class TypedConstantExpression : ConstantExpression
	{
		public sealed override Type Type { get; }

		internal TypedConstantExpression(object value, Type type)
			: base(value)
		{
			Type = type;
		}
	}
	/// <summary>Emits or clears a sequence point for debug information. This allows the debugger to highlight the correct source code when debugging.</summary>
	[DebuggerTypeProxy(typeof(DebugInfoExpressionProxy))]
	public class DebugInfoExpression : Expression
	{
		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.DebugInfoExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type => typeof(void);

		/// <summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> that represents this expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.DebugInfo;

		/// <summary>Gets the start line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
		/// <returns>The number of the start line of the code that was used to generate the wrapped expression.</returns>
		[ExcludeFromCodeCoverage]
		public virtual int StartLine
		{
			get
			{
				throw ContractUtils.Unreachable;
			}
		}

		/// <summary>Gets the start column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
		/// <returns>The number of the start column of the code that was used to generate the wrapped expression.</returns>
		[ExcludeFromCodeCoverage]
		public virtual int StartColumn
		{
			get
			{
				throw ContractUtils.Unreachable;
			}
		}

		/// <summary>Gets the end line of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
		/// <returns>The number of the end line of the code that was used to generate the wrapped expression.</returns>
		[ExcludeFromCodeCoverage]
		public virtual int EndLine
		{
			get
			{
				throw ContractUtils.Unreachable;
			}
		}

		/// <summary>Gets the end column of this <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
		/// <returns>The number of the end column of the code that was used to generate the wrapped expression.</returns>
		[ExcludeFromCodeCoverage]
		public virtual int EndColumn
		{
			get
			{
				throw ContractUtils.Unreachable;
			}
		}

		/// <summary>Gets the <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.SymbolDocumentInfo" /> that represents the source file.</returns>
		public SymbolDocumentInfo Document { get; }

		/// <summary>Gets the value to indicate if the <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> is for clearing a sequence point.</summary>
		/// <returns>True if the <see cref="T:System.Linq.Expressions.DebugInfoExpression" /> is for clearing a sequence point, otherwise false.</returns>
		[ExcludeFromCodeCoverage]
		public virtual bool IsClear
		{
			get
			{
				throw ContractUtils.Unreachable;
			}
		}

		internal DebugInfoExpression(SymbolDocumentInfo document)
		{
			Document = document;
		}

		/// <summary>Dispatches to the specific visit method for this node type. For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
		/// <param name="visitor">The visitor to visit this node with.</param>
		/// <returns>The result of visiting this node.</returns>
		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitDebugInfo(this);
		}

		internal DebugInfoExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal sealed class SpanDebugInfoExpression : DebugInfoExpression
	{
		private readonly int _startLine;

		private readonly int _startColumn;

		private readonly int _endLine;

		private readonly int _endColumn;

		public override int StartLine => _startLine;

		public override int StartColumn => _startColumn;

		public override int EndLine => _endLine;

		public override int EndColumn => _endColumn;

		public override bool IsClear => false;

		internal SpanDebugInfoExpression(SymbolDocumentInfo document, int startLine, int startColumn, int endLine, int endColumn)
			: base(document)
		{
			_startLine = startLine;
			_startColumn = startColumn;
			_endLine = endLine;
			_endColumn = endColumn;
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitDebugInfo(this);
		}
	}
	internal sealed class ClearDebugInfoExpression : DebugInfoExpression
	{
		public override bool IsClear => true;

		public override int StartLine => 16707566;

		public override int StartColumn => 0;

		public override int EndLine => 16707566;

		public override int EndColumn => 0;

		internal ClearDebugInfoExpression(SymbolDocumentInfo document)
			: base(document)
		{
		}
	}
	internal sealed class DebugViewWriter : ExpressionVisitor
	{
		[Flags]
		private enum Flow
		{
			None = 0,
			Space = 1,
			NewLine = 2,
			Break = 0x8000
		}

		private const int Tab = 4;

		private const int MaxColumn = 120;

		private readonly TextWriter _out;

		private int _column;

		private readonly Stack<int> _stack = new Stack<int>();

		private int _delta;

		private Flow _flow;

		private Queue<LambdaExpression> _lambdas;

		private Dictionary<LambdaExpression, int> _lambdaIds;

		private Dictionary<ParameterExpression, int> _paramIds;

		private Dictionary<LabelTarget, int> _labelIds;

		private int Base
		{
			get
			{
				if (_stack.Count <= 0)
				{
					return 0;
				}
				return _stack.Peek();
			}
		}

		private int Delta => _delta;

		private int Depth => Base + Delta;

		private DebugViewWriter(TextWriter file)
		{
			_out = file;
		}

		private void Indent()
		{
			_delta += 4;
		}

		private void Dedent()
		{
			_delta -= 4;
		}

		private void NewLine()
		{
			_flow = Flow.NewLine;
		}

		private static int GetId<T>(T e, ref Dictionary<T, int> ids)
		{
			if (ids == null)
			{
				ids = new Dictionary<T, int>();
				ids.Add(e, 1);
				return 1;
			}
			if (!ids.TryGetValue(e, out var value))
			{
				value = ids.Count + 1;
				ids.Add(e, value);
			}
			return value;
		}

		private int GetLambdaId(LambdaExpression le)
		{
			return GetId(le, ref _lambdaIds);
		}

		private int GetParamId(ParameterExpression p)
		{
			return GetId(p, ref _paramIds);
		}

		private int GetLabelTargetId(LabelTarget target)
		{
			return GetId(target, ref _labelIds);
		}

		internal static void WriteTo(Expression node, TextWriter writer)
		{
			new DebugViewWriter(writer).WriteTo(node);
		}

		private void WriteTo(Expression node)
		{
			if (node is LambdaExpression lambda)
			{
				WriteLambda(lambda);
			}
			else
			{
				Visit(node);
			}
			while (_lambdas != null && _lambdas.Count > 0)
			{
				WriteLine();
				WriteLine();
				WriteLambda(_lambdas.Dequeue());
			}
		}

		private void Out(string s)
		{
			Out(Flow.None, s, Flow.None);
		}

		private void Out(Flow before, string s)
		{
			Out(before, s, Flow.None);
		}

		private void Out(string s, Flow after)
		{
			Out(Flow.None, s, after);
		}

		private void Out(Flow before, string s, Flow after)
		{
			switch (GetFlow(before))
			{
			case Flow.Space:
				Write(" ");
				break;
			case Flow.NewLine:
				WriteLine();
				Write(new string(' ', Depth));
				break;
			}
			Write(s);
			_flow = after;
		}

		private void WriteLine()
		{
			_out.WriteLine();
			_column = 0;
		}

		private void Write(string s)
		{
			_out.Write(s);
			_column += s.Length;
		}

		private Flow GetFlow(Flow flow)
		{
			Flow val = CheckBreak(_flow);
			flow = CheckBreak(flow);
			return (Flow)Math.Max((int)val, (int)flow);
		}

		private Flow CheckBreak(Flow flow)
		{
			if ((flow & Flow.Break) != Flow.None)
			{
				flow = ((_column <= 120 + Depth) ? (flow & ~Flow.Break) : Flow.NewLine);
			}
			return flow;
		}

		private void VisitExpressions<T>(char open, IReadOnlyList<T> expressions) where T : Expression
		{
			VisitExpressions(open, ',', expressions);
		}

		private void VisitExpressions<T>(char open, char separator, IReadOnlyList<T> expressions) where T : Expression
		{
			VisitExpressions(open, separator, expressions, delegate(T e)
			{
				Visit(e);
			});
		}

		private void VisitDeclarations(IReadOnlyList<ParameterExpression> expressions)
		{
			VisitExpressions('(', ',', expressions, delegate(ParameterExpression variable)
			{
				Out(variable.Type.ToString());
				if (variable.IsByRef)
				{
					Out("&");
				}
				Out(" ");
				VisitParameter(variable);
			});
		}

		private void VisitExpressions<T>(char open, char separator, IReadOnlyList<T> expressions, Action<T> visit)
		{
			Out(open.ToString());
			if (expressions != null)
			{
				Indent();
				bool flag = true;
				foreach (T expression in expressions)
				{
					if (flag)
					{
						if (open == '{' || expressions.Count > 1)
						{
							NewLine();
						}
						flag = false;
					}
					else
					{
						Out(separator.ToString(), Flow.NewLine);
					}
					visit(expression);
				}
				Dedent();
			}
			char c = open switch
			{
				'(' => ')', 
				'{' => '}', 
				'[' => ']', 
				_ => throw ContractUtils.Unreachable, 
			};
			if (open == '{')
			{
				NewLine();
			}
			Out(c.ToString(), Flow.Break);
		}

		protected internal override Expression VisitBinary(BinaryExpression node)
		{
			if (node.NodeType == ExpressionType.ArrayIndex)
			{
				ParenthesizedVisit(node, node.Left);
				Out("[");
				Visit(node.Right);
				Out("]");
			}
			else
			{
				bool flag = NeedsParentheses(node, node.Left);
				bool flag2 = NeedsParentheses(node, node.Right);
				Flow before = Flow.Space;
				string s;
				switch (node.NodeType)
				{
				case ExpressionType.Assign:
					s = "=";
					break;
				case ExpressionType.Equal:
					s = "==";
					break;
				case ExpressionType.NotEqual:
					s = "!=";
					break;
				case ExpressionType.AndAlso:
					s = "&&";
					before = Flow.Space | Flow.Break;
					break;
				case ExpressionType.OrElse:
					s = "||";
					before = Flow.Space | Flow.Break;
					break;
				case ExpressionType.GreaterThan:
					s = ">";
					break;
				case ExpressionType.LessThan:
					s = "<";
					break;
				case ExpressionType.GreaterThanOrEqual:
					s = ">=";
					break;
				case ExpressionType.LessThanOrEqual:
					s = "<=";
					break;
				case ExpressionType.Add:
					s = "+";
					break;
				case ExpressionType.AddAssign:
					s = "+=";
					break;
				case ExpressionType.AddAssignChecked:
					s = "#+=";
					break;
				case ExpressionType.AddChecked:
					s = "#+";
					break;
				case ExpressionType.Subtract:
					s = "-";
					break;
				case ExpressionType.SubtractAssign:
					s = "-=";
					break;
				case ExpressionType.SubtractAssignChecked:
					s = "#-=";
					break;
				case ExpressionType.SubtractChecked:
					s = "#-";
					break;
				case ExpressionType.Divide:
					s = "/";
					break;
				case ExpressionType.DivideAssign:
					s = "/=";
					break;
				case ExpressionType.Modulo:
					s = "%";
					break;
				case ExpressionType.ModuloAssign:
					s = "%=";
					break;
				case ExpressionType.Multiply:
					s = "*";
					break;
				case ExpressionType.MultiplyAssign:
					s = "*=";
					break;
				case ExpressionType.MultiplyAssignChecked:
					s = "#*=";
					break;
				case ExpressionType.MultiplyChecked:
					s = "#*";
					break;
				case ExpressionType.LeftShift:
					s = "<<";
					break;
				case ExpressionType.LeftShiftAssign:
					s = "<<=";
					break;
				case ExpressionType.RightShift:
					s = ">>";
					break;
				case ExpressionType.RightShiftAssign:
					s = ">>=";
					break;
				case ExpressionType.And:
					s = "&";
					break;
				case ExpressionType.AndAssign:
					s = "&=";
					break;
				case ExpressionType.Or:
					s = "|";
					break;
				case ExpressionType.OrAssign:
					s = "|=";
					break;
				case ExpressionType.ExclusiveOr:
					s = "^";
					break;
				case ExpressionType.ExclusiveOrAssign:
					s = "^=";
					break;
				case ExpressionType.Power:
					s = "**";
					break;
				case ExpressionType.PowerAssign:
					s = "**=";
					break;
				case ExpressionType.Coalesce:
					s = "??";
					break;
				default:
					throw new InvalidOperationException();
				}
				if (flag)
				{
					Out("(", Flow.None);
				}
				Visit(node.Left);
				if (flag)
				{
					Out(Flow.None, ")", Flow.Break);
				}
				Out(before, s, Flow.Space | Flow.Break);
				if (flag2)
				{
					Out("(", Flow.None);
				}
				Visit(node.Right);
				if (flag2)
				{
					Out(Flow.None, ")", Flow.Break);
				}
			}
			return node;
		}

		protected internal override Expression VisitParameter(ParameterExpression node)
		{
			Out("$");
			if (string.IsNullOrEmpty(node.Name))
			{
				Out("var" + GetParamId(node));
			}
			else
			{
				Out(GetDisplayName(node.Name));
			}
			return node;
		}

		protected internal override Expression VisitLambda<T>(Expression<T> node)
		{
			Out(string.Format(CultureInfo.CurrentCulture, ".Lambda {0}<{1}>", GetLambdaName(node), node.Type.ToString()));
			if (_lambdas == null)
			{
				_lambdas = new Queue<LambdaExpression>();
			}
			if (!_lambdas.Contains(node))
			{
				_lambdas.Enqueue(node);
			}
			return node;
		}

		private static bool IsSimpleExpression(Expression node)
		{
			if (node is BinaryExpression binaryExpression)
			{
				if (!(binaryExpression.Left is BinaryExpression))
				{
					return !(binaryExpression.Right is BinaryExpression);
				}
				return false;
			}
			return false;
		}

		protected internal override Expression VisitConditional(ConditionalExpression node)
		{
			if (IsSimpleExpression(node.Test))
			{
				Out(".If (");
				Visit(node.Test);
				Out(") {", Flow.NewLine);
			}
			else
			{
				Out(".If (", Flow.NewLine);
				Indent();
				Visit(node.Test);
				Dedent();
				Out(Flow.NewLine, ") {", Flow.NewLine);
			}
			Indent();
			Visit(node.IfTrue);
			Dedent();
			Out(Flow.NewLine, "} .Else {", Flow.NewLine);
			Indent();
			Visit(node.IfFalse);
			Dedent();
			Out(Flow.NewLine, "}");
			return node;
		}

		protected internal override Expression VisitConstant(ConstantExpression node)
		{
			object value = node.Value;
			if (value == null)
			{
				Out("null");
			}
			else if (value is string && node.Type == typeof(string))
			{
				Out(string.Format(CultureInfo.CurrentCulture, "\"{0}\"", value));
			}
			else if (value is char && node.Type == typeof(char))
			{
				Out(string.Format(CultureInfo.CurrentCulture, "'{0}'", value));
			}
			else if ((value is int && node.Type == typeof(int)) || (value is bool && node.Type == typeof(bool)))
			{
				Out(value.ToString());
			}
			else
			{
				string constantValueSuffix = GetConstantValueSuffix(node.Type);
				if (constantValueSuffix != null)
				{
					Out(value.ToString());
					Out(constantValueSuffix);
				}
				else
				{
					Out(string.Format(CultureInfo.CurrentCulture, ".Constant<{0}>({1})", node.Type.ToString(), value));
				}
			}
			return node;
		}

		private static string GetConstantValueSuffix(Type type)
		{
			if (type == typeof(uint))
			{
				return "U";
			}
			if (type == typeof(long))
			{
				return "L";
			}
			if (type == typeof(ulong))
			{
				return "UL";
			}
			if (type == typeof(double))
			{
				return "D";
			}
			if (type == typeof(float))
			{
				return "F";
			}
			if (type == typeof(decimal))
			{
				return "M";
			}
			return null;
		}

		protected internal override Expression VisitRuntimeVariables(RuntimeVariablesExpression node)
		{
			Out(".RuntimeVariables");
			VisitExpressions('(', node.Variables);
			return node;
		}

		private void OutMember(Expression node, Expression instance, MemberInfo member)
		{
			if (instance != null)
			{
				ParenthesizedVisit(node, instance);
				Out("." + member.Name);
			}
			else
			{
				Out(member.DeclaringType.ToString() + "." + member.Name);
			}
		}

		protected internal override Expression VisitMember(MemberExpression node)
		{
			OutMember(node, node.Expression, node.Member);
			return node;
		}

		protected internal override Expression VisitInvocation(InvocationExpression node)
		{
			Out(".Invoke ");
			ParenthesizedVisit(node, node.Expression);
			VisitExpressions('(', node.Arguments);
			return node;
		}

		private static bool NeedsParentheses(Expression parent, Expression child)
		{
			if (child == null)
			{
				return false;
			}
			switch (parent.NodeType)
			{
			case ExpressionType.Decrement:
			case ExpressionType.Increment:
			case ExpressionType.Unbox:
			case ExpressionType.IsTrue:
			case ExpressionType.IsFalse:
				return true;
			default:
			{
				int operatorPrecedence = GetOperatorPrecedence(child);
				int operatorPrecedence2 = GetOperatorPrecedence(parent);
				if (operatorPrecedence == operatorPrecedence2)
				{
					switch (parent.NodeType)
					{
					case ExpressionType.And:
					case ExpressionType.AndAlso:
					case ExpressionType.ExclusiveOr:
					case ExpressionType.Or:
					case ExpressionType.OrElse:
						return false;
					case ExpressionType.Add:
					case ExpressionType.AddChecked:
					case ExpressionType.Multiply:
					case ExpressionType.MultiplyChecked:
						return false;
					case ExpressionType.Divide:
					case ExpressionType.Modulo:
					case ExpressionType.Subtract:
					case ExpressionType.SubtractChecked:
					{
						BinaryExpression binaryExpression = parent as BinaryExpression;
						return child == binaryExpression.Right;
					}
					default:
						return true;
					}
				}
				if (child != null && child.NodeType == ExpressionType.Constant && (parent.NodeType == ExpressionType.Negate || parent.NodeType == ExpressionType.NegateChecked))
				{
					return true;
				}
				return operatorPrecedence < operatorPrecedence2;
			}
			}
		}

		private static int GetOperatorPrecedence(Expression node)
		{
			switch (node.NodeType)
			{
			case ExpressionType.Coalesce:
			case ExpressionType.Assign:
			case ExpressionType.AddAssign:
			case ExpressionType.AndAssign:
			case ExpressionType.DivideAssign:
			case ExpressionType.ExclusiveOrAssign:
			case ExpressionType.LeftShiftAssign:
			case ExpressionType.ModuloAssign:
			case ExpressionType.MultiplyAssign:
			case ExpressionType.OrAssign:
			case ExpressionType.PowerAssign:
			case ExpressionType.RightShiftAssign:
			case ExpressionType.SubtractAssign:
			case ExpressionType.AddAssignChecked:
			case ExpressionType.MultiplyAssignChecked:
			case ExpressionType.SubtractAssignChecked:
				return 1;
			case ExpressionType.OrElse:
				return 2;
			case ExpressionType.AndAlso:
				return 3;
			case ExpressionType.Or:
				return 4;
			case ExpressionType.ExclusiveOr:
				return 5;
			case ExpressionType.And:
				return 6;
			case ExpressionType.Equal:
			case ExpressionType.NotEqual:
				return 7;
			case ExpressionType.GreaterThan:
			case ExpressionType.GreaterThanOrEqual:
			case ExpressionType.LessThan:
			case ExpressionType.LessThanOrEqual:
			case ExpressionType.TypeAs:
			case ExpressionType.TypeIs:
			case ExpressionType.TypeEqual:
				return 8;
			case ExpressionType.LeftShift:
			case ExpressionType.RightShift:
				return 9;
			case ExpressionType.Add:
			case ExpressionType.AddChecked:
			case ExpressionType.Subtract:
			case ExpressionType.SubtractChecked:
				return 10;
			case ExpressionType.Divide:
			case ExpressionType.Modulo:
			case ExpressionType.Multiply:
			case ExpressionType.MultiplyChecked:
				return 11;
			case ExpressionType.Convert:
			case ExpressionType.ConvertChecked:
			case ExpressionType.Negate:
			case ExpressionType.UnaryPlus:
			case ExpressionType.NegateChecked:
			case ExpressionType.Not:
			case ExpressionType.Decrement:
			case ExpressionType.Increment:
			case ExpressionType.Throw:
			case ExpressionType.Unbox:
			case ExpressionType.PreIncrementAssign:
			case ExpressionType.PreDecrementAssign:
			case ExpressionType.OnesComplement:
			case ExpressionType.IsTrue:
			case ExpressionType.IsFalse:
				return 12;
			case ExpressionType.Power:
				return 13;
			default:
				return 14;
			case ExpressionType.Constant:
			case ExpressionType.Parameter:
				return 15;
			}
		}

		private void ParenthesizedVisit(Expression parent, Expression nodeToVisit)
		{
			if (NeedsParentheses(parent, nodeToVisit))
			{
				Out("(");
				Visit(nodeToVisit);
				Out(")");
			}
			else
			{
				Visit(nodeToVisit);
			}
		}

		protected internal override Expression VisitMethodCall(MethodCallExpression node)
		{
			Out(".Call ");
			if (node.Object != null)
			{
				ParenthesizedVisit(node, node.Object);
			}
			else if (node.Method.DeclaringType != null)
			{
				Out(node.Method.DeclaringType.ToString());
			}
			else
			{
				Out("<UnknownType>");
			}
			Out(".");
			Out(node.Method.Name);
			VisitExpressions('(', node.Arguments);
			return node;
		}

		protected internal override Expression VisitNewArray(NewArrayExpression node)
		{
			if (node.NodeType == ExpressionType.NewArrayBounds)
			{
				Out(".NewArray " + node.Type.GetElementType().ToString());
				VisitExpressions('[', node.Expressions);
			}
			else
			{
				Out(".NewArray " + node.Type.ToString(), Flow.Space);
				VisitExpressions('{', node.Expressions);
			}
			return node;
		}

		protected internal override Expression VisitNew(NewExpression node)
		{
			Out(".New " + node.Type.ToString());
			VisitExpressions('(', node.Arguments);
			return node;
		}

		protected override ElementInit VisitElementInit(ElementInit node)
		{
			if (node.Arguments.Count == 1)
			{
				Visit(node.Arguments[0]);
			}
			else
			{
				VisitExpressions('{', node.Arguments);
			}
			return node;
		}

		protected internal override Expression VisitListInit(ListInitExpression node)
		{
			Visit(node.NewExpression);
			VisitExpressions('{', ',', node.Initializers, delegate(ElementInit e)
			{
				VisitElementInit(e);
			});
			return node;
		}

		protected override MemberAssignment VisitMemberAssignment(MemberAssignment assignment)
		{
			Out(assignment.Member.Name);
			Out(Flow.Space, "=", Flow.Space);
			Visit(assignment.Expression);
			return assignment;
		}

		protected override MemberListBinding VisitMemberListBinding(MemberListBinding binding)
		{
			Out(binding.Member.Name);
			Out(Flow.Space, "=", Flow.Space);
			VisitExpressions('{', ',', binding.Initializers, delegate(ElementInit e)
			{
				VisitElementInit(e);
			});
			return binding;
		}

		protected override MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding)
		{
			Out(binding.Member.Name);
			Out(Flow.Space, "=", Flow.Space);
			VisitExpressions('{', ',', binding.Bindings, delegate(MemberBinding e)
			{
				VisitMemberBinding(e);
			});
			return binding;
		}

		protected internal override Expression VisitMemberInit(MemberInitExpression node)
		{
			Visit(node.NewExpression);
			VisitExpressions('{', ',', node.Bindings, delegate(MemberBinding e)
			{
				VisitMemberBinding(e);
			});
			return node;
		}

		protected internal override Expression VisitTypeBinary(TypeBinaryExpression node)
		{
			ParenthesizedVisit(node, node.Expression);
			switch (node.NodeType)
			{
			case ExpressionType.TypeIs:
				Out(Flow.Space, ".Is", Flow.Space);
				break;
			case ExpressionType.TypeEqual:
				Out(Flow.Space, ".TypeEqual", Flow.Space);
				break;
			}
			Out(node.TypeOperand.ToString());
			return node;
		}

		protected internal override Expression VisitUnary(UnaryExpression node)
		{
			switch (node.NodeType)
			{
			case ExpressionType.Convert:
				Out("(" + node.Type.ToString() + ")");
				break;
			case ExpressionType.ConvertChecked:
				Out("#(" + node.Type.ToString() + ")");
				break;
			case ExpressionType.Not:
				Out((node.Type == typeof(bool)) ? "!" : "~");
				break;
			case ExpressionType.OnesComplement:
				Out("~");
				break;
			case ExpressionType.Negate:
				Out("-");
				break;
			case ExpressionType.NegateChecked:
				Out("#-");
				break;
			case ExpressionType.UnaryPlus:
				Out("+");
				break;
			case ExpressionType.Quote:
				Out("'");
				break;
			case ExpressionType.Throw:
				if (node.Operand == null)
				{
					Out(".Rethrow");
				}
				else
				{
					Out(".Throw", Flow.Space);
				}
				break;
			case ExpressionType.IsFalse:
				Out(".IsFalse");
				break;
			case ExpressionType.IsTrue:
				Out(".IsTrue");
				break;
			case ExpressionType.Decrement:
				Out(".Decrement");
				break;
			case ExpressionType.Increment:
				Out(".Increment");
				break;
			case ExpressionType.PreDecrementAssign:
				Out("--");
				break;
			case ExpressionType.PreIncrementAssign:
				Out("++");
				break;
			case ExpressionType.Unbox:
				Out(".Unbox");
				break;
			}
			ParenthesizedVisit(node, node.Operand);
			switch (node.NodeType)
			{
			case ExpressionType.TypeAs:
				Out(Flow.Space, ".As", Flow.Space | Flow.Break);
				Out(node.Type.ToString());
				break;
			case ExpressionType.ArrayLength:
				Out(".Length");
				break;
			case ExpressionType.PostDecrementAssign:
				Out("--");
				break;
			case ExpressionType.PostIncrementAssign:
				Out("++");
				break;
			}
			return node;
		}

		protected internal override Expression VisitBlock(BlockExpression node)
		{
			Out(".Block");
			if (node.Type != node.GetExpression(node.ExpressionCount - 1).Type)
			{
				Out(string.Format(CultureInfo.CurrentCulture, "<{0}>", node.Type.ToString()));
			}
			VisitDeclarations(node.Variables);
			Out(" ");
			VisitExpressions('{', ';', node.Expressions);
			return node;
		}

		protected internal override Expression VisitDefault(DefaultExpression node)
		{
			Out(".Default(" + node.Type.ToString() + ")");
			return node;
		}

		protected internal override Expression VisitLabel(LabelExpression node)
		{
			Out(".Label", Flow.NewLine);
			Indent();
			Visit(node.DefaultValue);
			Dedent();
			NewLine();
			DumpLabel(node.Target);
			return node;
		}

		protected internal override Expression VisitGoto(GotoExpression node)
		{
			Out("." + node.Kind, Flow.Space);
			Out(GetLabelTargetName(node.Target), Flow.Space);
			Out("{", Flow.Space);
			Visit(node.Value);
			Out(Flow.Space, "}");
			return node;
		}

		protected internal override Expression VisitLoop(LoopExpression node)
		{
			Out(".Loop", Flow.Space);
			if (node.ContinueLabel != null)
			{
				DumpLabel(node.ContinueLabel);
			}
			Out(" {", Flow.NewLine);
			Indent();
			Visit(node.Body);
			Dedent();
			Out(Flow.NewLine, "}");
			if (node.BreakLabel != null)
			{
				Out("", Flow.NewLine);
				DumpLabel(node.BreakLabel);
			}
			return node;
		}

		protected override SwitchCase VisitSwitchCase(SwitchCase node)
		{
			foreach (Expression testValue in node.TestValues)
			{
				Out(".Case (");
				Visit(testValue);
				Out("):", Flow.NewLine);
			}
			Indent();
			Indent();
			Visit(node.Body);
			Dedent();
			Dedent();
			NewLine();
			return node;
		}

		protected internal override Expression VisitSwitch(SwitchExpression node)
		{
			Out(".Switch ");
			Out("(");
			Visit(node.SwitchValue);
			Out(") {", Flow.NewLine);
			ExpressionVisitor.Visit(node.Cases, VisitSwitchCase);
			if (node.DefaultBody != null)
			{
				Out(".Default:", Flow.NewLine);
				Indent();
				Indent();
				Visit(node.DefaultBody);
				Dedent();
				Dedent();
				NewLine();
			}
			Out("}");
			return node;
		}

		protected override CatchBlock VisitCatchBlock(CatchBlock node)
		{
			Out(Flow.NewLine, "} .Catch (" + node.Test.ToString());
			if (node.Variable != null)
			{
				Out(Flow.Space, "");
				VisitParameter(node.Variable);
			}
			if (node.Filter != null)
			{
				Out(") .If (", Flow.Break);
				Visit(node.Filter);
			}
			Out(") {", Flow.NewLine);
			Indent();
			Visit(node.Body);
			Dedent();
			return node;
		}

		protected internal override Expression VisitTry(TryExpression node)
		{
			Out(".Try {", Flow.NewLine);
			Indent();
			Visit(node.Body);
			Dedent();
			ExpressionVisitor.Visit(node.Handlers, VisitCatchBlock);
			if (node.Finally != null)
			{
				Out(Flow.NewLine, "} .Finally {", Flow.NewLine);
				Indent();
				Visit(node.Finally);
				Dedent();
			}
			else if (node.Fault != null)
			{
				Out(Flow.NewLine, "} .Fault {", Flow.NewLine);
				Indent();
				Visit(node.Fault);
				Dedent();
			}
			Out(Flow.NewLine, "}");
			return node;
		}

		protected internal override Expression VisitIndex(IndexExpression node)
		{
			if (node.Indexer != null)
			{
				OutMember(node, node.Object, node.Indexer);
			}
			else
			{
				ParenthesizedVisit(node, node.Object);
			}
			VisitExpressions('[', node.Arguments);
			return node;
		}

		protected internal override Expression VisitExtension(Expression node)
		{
			Out(string.Format(CultureInfo.CurrentCulture, ".Extension<{0}>", node.GetType().ToString()));
			if (node.CanReduce)
			{
				Out(Flow.Space, "{", Flow.NewLine);
				Indent();
				Visit(node.Reduce());
				Dedent();
				Out(Flow.NewLine, "}");
			}
			return node;
		}

		protected internal override Expression VisitDebugInfo(DebugInfoExpression node)
		{
			Out(string.Format(CultureInfo.CurrentCulture, ".DebugInfo({0}: {1}, {2} - {3}, {4})", node.Document.FileName, node.StartLine, node.StartColumn, node.EndLine, node.EndColumn));
			return node;
		}

		private void DumpLabel(LabelTarget target)
		{
			Out(string.Format(CultureInfo.CurrentCulture, ".LabelTarget {0}:", GetLabelTargetName(target)));
		}

		private string GetLabelTargetName(LabelTarget target)
		{
			if (string.IsNullOrEmpty(target.Name))
			{
				return "#Label" + GetLabelTargetId(target);
			}
			return GetDisplayName(target.Name);
		}

		private void WriteLambda(LambdaExpression lambda)
		{
			Out(string.Format(CultureInfo.CurrentCulture, ".Lambda {0}<{1}>", GetLambdaName(lambda), lambda.Type.ToString()));
			VisitDeclarations(lambda.Parameters);
			Out(Flow.Space, "{", Flow.NewLine);
			Indent();
			Visit(lambda.Body);
			Dedent();
			Out(Flow.NewLine, "}");
		}

		private string GetLambdaName(LambdaExpression lambda)
		{
			if (string.IsNullOrEmpty(lambda.Name))
			{
				return "#Lambda" + GetLambdaId(lambda);
			}
			return GetDisplayName(lambda.Name);
		}

		private static bool ContainsWhiteSpace(string name)
		{
			for (int i = 0; i < name.Length; i++)
			{
				if (char.IsWhiteSpace(name[i]))
				{
					return true;
				}
			}
			return false;
		}

		private static string QuoteName(string name)
		{
			return string.Format(CultureInfo.CurrentCulture, "'{0}'", name);
		}

		private static string GetDisplayName(string name)
		{
			if (ContainsWhiteSpace(name))
			{
				return QuoteName(name);
			}
			return name;
		}
	}
	/// <summary>Represents the default value of a type or an empty expression.</summary>
	[DebuggerTypeProxy(typeof(DefaultExpressionProxy))]
	public sealed class DefaultExpression : Expression
	{
		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.DefaultExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type { get; }

		/// <summary>Returns the node type of this expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> when overriding this method.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> of the expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Default;

		internal DefaultExpression(Type type)
		{
			Type = type;
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitDefault(this);
		}

		internal DefaultExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents a dynamic operation.</summary>
	public class DynamicExpression : Expression, IDynamicExpression, IArgumentProvider
	{
		public override bool CanReduce => true;

		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.DynamicExpression.Type" /> that represents the static type of the expression.</returns>
		public override Type Type => typeof(object);

		/// <summary>Returns the node type of this expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> when overriding this method.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> of the expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Dynamic;

		/// <summary>Gets the <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, which determines the run-time behavior of the dynamic site.</summary>
		/// <returns>The <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />, which determines the run-time behavior of the dynamic site.</returns>
		public CallSiteBinder Binder { get; }

		/// <summary>Gets the type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</returns>
		public Type DelegateType { get; }

		/// <summary>Gets the arguments to the dynamic operation.</summary>
		/// <returns>The read-only collections containing the arguments to the dynamic operation.</returns>
		public ReadOnlyCollection<Expression> Arguments => GetOrMakeArguments();

		/// <summary>Returns the number of arguments to the expression tree node.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.</summary>
		/// <returns>Returns <see cref="T:System.Int32" />.</returns>
		[ExcludeFromCodeCoverage]
		int IArgumentProvider.ArgumentCount
		{
			get
			{
				throw ContractUtils.Unreachable;
			}
		}

		internal DynamicExpression(Type delegateType, CallSiteBinder binder)
		{
			DelegateType = delegateType;
			Binder = binder;
		}

		public override Expression Reduce()
		{
			ConstantExpression constantExpression = Expression.Constant(CallSite.Create(DelegateType, Binder));
			return Expression.Invoke(Expression.Field(constantExpression, "Target"), Arguments.AddFirst(constantExpression));
		}

		internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, ReadOnlyCollection<Expression> arguments)
		{
			if (returnType == typeof(object))
			{
				return new DynamicExpressionN(delegateType, binder, arguments);
			}
			return new TypedDynamicExpressionN(returnType, delegateType, binder, arguments);
		}

		internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0)
		{
			if (returnType == typeof(object))
			{
				return new DynamicExpression1(delegateType, binder, arg0);
			}
			return new TypedDynamicExpression1(returnType, delegateType, binder, arg0);
		}

		internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1)
		{
			if (returnType == typeof(object))
			{
				return new DynamicExpression2(delegateType, binder, arg0, arg1);
			}
			return new TypedDynamicExpression2(returnType, delegateType, binder, arg0, arg1);
		}

		internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2)
		{
			if (returnType == typeof(object))
			{
				return new DynamicExpression3(delegateType, binder, arg0, arg1, arg2);
			}
			return new TypedDynamicExpression3(returnType, delegateType, binder, arg0, arg1, arg2);
		}

		internal static DynamicExpression Make(Type returnType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
		{
			if (returnType == typeof(object))
			{
				return new DynamicExpression4(delegateType, binder, arg0, arg1, arg2, arg3);
			}
			return new TypedDynamicExpression4(returnType, delegateType, binder, arg0, arg1, arg2, arg3);
		}

		[ExcludeFromCodeCoverage]
		internal virtual ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			throw ContractUtils.Unreachable;
		}

		/// <summary>Dispatches to the specific visit method for this node type. For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
		/// <param name="visitor">The visitor to visit this node with.</param>
		/// <returns>The result of visiting this node.</returns>
		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			if (visitor is DynamicExpressionVisitor dynamicExpressionVisitor)
			{
				return dynamicExpressionVisitor.VisitDynamic(this);
			}
			return visitor.VisitDynamic(this);
		}

		[ExcludeFromCodeCoverage]
		internal virtual DynamicExpression Rewrite(Expression[] args)
		{
			throw ContractUtils.Unreachable;
		}

		/// <summary>Compares the value sent to the parameter, arguments, to the <see langword="Arguments" /> property of the current instance of <see langword="DynamicExpression" />. If the values of the parameter and the property are equal, the current instance is returned. If they are not equal, a new <see langword="DynamicExpression" /> instance is returned that is identical to the current instance except that the <see langword="Arguments" /> property is set to the value of parameter arguments. </summary>
		/// <param name="arguments">The <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public DynamicExpression Update(IEnumerable<Expression> arguments)
		{
			ICollection<Expression> collection;
			if (arguments == null)
			{
				collection = null;
			}
			else
			{
				collection = arguments as ICollection<Expression>;
				if (collection == null)
				{
					arguments = (collection = arguments.ToReadOnly());
				}
			}
			if (SameArguments(collection))
			{
				return this;
			}
			return ExpressionExtension.MakeDynamic(DelegateType, Binder, arguments);
		}

		[ExcludeFromCodeCoverage]
		internal virtual bool SameArguments(ICollection<Expression> arguments)
		{
			throw ContractUtils.Unreachable;
		}

		/// <summary>Returns the argument at index, throwing if index is out of bounds.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.</summary>
		/// <param name="index">The index of the argument.</param>
		/// <returns>Returns <see cref="T:System.Linq.Expressions.Expression" />.</returns>
		[ExcludeFromCodeCoverage]
		Expression IArgumentProvider.GetArgument(int index)
		{
			throw ContractUtils.Unreachable;
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="returnType">The result type of the dynamic expression.</param>
		/// <param name="arguments">The arguments to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public new static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, params Expression[] arguments)
		{
			return ExpressionExtension.Dynamic(binder, returnType, arguments);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="returnType">The result type of the dynamic expression.</param>
		/// <param name="arguments">The arguments to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />,  and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public new static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable<Expression> arguments)
		{
			return ExpressionExtension.Dynamic(binder, returnType, arguments);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="returnType">The result type of the dynamic expression.</param>
		/// <param name="arg0">The first argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />,  and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public new static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0)
		{
			return ExpressionExtension.Dynamic(binder, returnType, arg0);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="returnType">The result type of the dynamic expression.</param>
		/// <param name="arg0">The first argument to the dynamic operation.</param>
		/// <param name="arg1">The second argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public new static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1)
		{
			return ExpressionExtension.Dynamic(binder, returnType, arg0, arg1);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="returnType">The result type of the dynamic expression.</param>
		/// <param name="arg0">The first argument to the dynamic operation.</param>
		/// <param name="arg1">The second argument to the dynamic operation.</param>
		/// <param name="arg2">The third argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public new static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2)
		{
			return ExpressionExtension.Dynamic(binder, returnType, arg0, arg1, arg2);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="returnType">The result type of the dynamic expression.</param>
		/// <param name="arg0">The first argument to the dynamic operation.</param>
		/// <param name="arg1">The second argument to the dynamic operation.</param>
		/// <param name="arg2">The third argument to the dynamic operation.</param>
		/// <param name="arg3">The fourth argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, and has the <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" /> and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public new static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
		{
			return ExpressionExtension.Dynamic(binder, returnType, arg0, arg1, arg2, arg3);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="arguments">The arguments to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public new static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable<Expression> arguments)
		{
			return ExpressionExtension.MakeDynamic(delegateType, binder, arguments);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" />.</summary>
		/// <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="arguments">The arguments to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public new static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, params Expression[] arguments)
		{
			return ExpressionExtension.MakeDynamic(delegateType, binder, arguments);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and one argument.</summary>
		/// <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="arg0">The argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public new static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0)
		{
			return ExpressionExtension.MakeDynamic(delegateType, binder, arg0);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and two arguments.</summary>
		/// <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="arg0">The first argument to the dynamic operation.</param>
		/// <param name="arg1">The second argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public new static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1)
		{
			return ExpressionExtension.MakeDynamic(delegateType, binder, arg0, arg1);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and three arguments.</summary>
		/// <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="arg0">The first argument to the dynamic operation.</param>
		/// <param name="arg1">The second argument to the dynamic operation.</param>
		/// <param name="arg2">The third argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public new static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2)
		{
			return ExpressionExtension.MakeDynamic(delegateType, binder, arg0, arg1, arg2);
		}

		/// <summary>Creates a <see cref="T:System.Linq.Expressions.DynamicExpression" /> that represents a dynamic operation bound by the provided <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> and four arguments.</summary>
		/// <param name="delegateType">The type of the delegate used by the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</param>
		/// <param name="binder">The runtime binder for the dynamic operation.</param>
		/// <param name="arg0">The first argument to the dynamic operation.</param>
		/// <param name="arg1">The second argument to the dynamic operation.</param>
		/// <param name="arg2">The third argument to the dynamic operation.</param>
		/// <param name="arg3">The fourth argument to the dynamic operation.</param>
		/// <returns>A <see cref="T:System.Linq.Expressions.DynamicExpression" /> that has <see cref="P:System.Linq.Expressions.DynamicExpression.NodeType" /> equal to <see cref="F:System.Linq.Expressions.ExpressionType.Dynamic" />, and has the <see cref="P:System.Linq.Expressions.DynamicExpression.DelegateType" />, <see cref="P:System.Linq.Expressions.DynamicExpression.Binder" />, and <see cref="P:System.Linq.Expressions.DynamicExpression.Arguments" /> set to the specified values.</returns>
		public new static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
		{
			return ExpressionExtension.MakeDynamic(delegateType, binder, arg0, arg1, arg2, arg3);
		}

		/// <summary>Rewrite this node replacing the dynamic expressions arguments with the provided values.  The number of args needs to match the number of the current expression.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.  This helper method allows re-writing of nodes to be independent of the specific implementation class deriving from DynamicExpression that is being used at the call site.</summary>
		/// <param name="args">The arguments.</param>
		/// <returns>Returns <see cref="T:System.Linq.Expressions.Expression" />, the rewritten expression.</returns>
		Expression IDynamicExpression.Rewrite(Expression[] args)
		{
			return Rewrite(args);
		}

		/// <summary>Optionally creates the CallSite and returns the CallSite for the DynamicExpressions polymorphic inline cache.  You should not use this member.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.</summary>
		/// <returns>Returns <see cref="T:System.Object" />.</returns>
		object IDynamicExpression.CreateCallSite()
		{
			return CallSite.Create(DelegateType, Binder);
		}

		internal DynamicExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal class DynamicExpressionN : DynamicExpression, IArgumentProvider
	{
		private IReadOnlyList<Expression> _arguments;

		int IArgumentProvider.ArgumentCount => _arguments.Count;

		internal DynamicExpressionN(Type delegateType, CallSiteBinder binder, IReadOnlyList<Expression> arguments)
			: base(delegateType, binder)
		{
			_arguments = arguments;
		}

		Expression IArgumentProvider.GetArgument(int index)
		{
			return _arguments[index];
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			return ExpressionUtils.SameElements(arguments, _arguments);
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(ref _arguments);
		}

		internal override DynamicExpression Rewrite(Expression[] args)
		{
			return ExpressionExtension.MakeDynamic(base.DelegateType, base.Binder, args);
		}
	}
	internal class TypedDynamicExpressionN : DynamicExpressionN
	{
		public sealed override Type Type { get; }

		internal TypedDynamicExpressionN(Type returnType, Type delegateType, CallSiteBinder binder, IReadOnlyList<Expression> arguments)
			: base(delegateType, binder, arguments)
		{
			Type = returnType;
		}
	}
	internal class DynamicExpression1 : DynamicExpression, IArgumentProvider
	{
		private object _arg0;

		int IArgumentProvider.ArgumentCount => 1;

		internal DynamicExpression1(Type delegateType, CallSiteBinder binder, Expression arg0)
			: base(delegateType, binder)
		{
			_arg0 = arg0;
		}

		Expression IArgumentProvider.GetArgument(int index)
		{
			if (index == 0)
			{
				return ExpressionUtils.ReturnObject<Expression>(_arg0);
			}
			throw new ArgumentOutOfRangeException("index");
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			if (arguments != null && arguments.Count == 1)
			{
				using (IEnumerator<Expression> enumerator = arguments.GetEnumerator())
				{
					enumerator.MoveNext();
					return enumerator.Current == ExpressionUtils.ReturnObject<Expression>(_arg0);
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		internal override DynamicExpression Rewrite(Expression[] args)
		{
			return ExpressionExtension.MakeDynamic(base.DelegateType, base.Binder, args[0]);
		}
	}
	internal sealed class TypedDynamicExpression1 : DynamicExpression1
	{
		public sealed override Type Type { get; }

		internal TypedDynamicExpression1(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0)
			: base(delegateType, binder, arg0)
		{
			Type = retType;
		}
	}
	internal class DynamicExpression2 : DynamicExpression, IArgumentProvider
	{
		private object _arg0;

		private readonly Expression _arg1;

		int IArgumentProvider.ArgumentCount => 2;

		internal DynamicExpression2(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1)
			: base(delegateType, binder)
		{
			_arg0 = arg0;
			_arg1 = arg1;
		}

		Expression IArgumentProvider.GetArgument(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				_ => throw new ArgumentOutOfRangeException("index"), 
			};
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			if (arguments != null && arguments.Count == 2)
			{
				if (_arg0 is ReadOnlyCollection<Expression> current)
				{
					return ExpressionUtils.SameElements(arguments, current);
				}
				using IEnumerator<Expression> enumerator = arguments.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _arg0)
				{
					enumerator.MoveNext();
					return enumerator.Current == _arg1;
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		internal override DynamicExpression Rewrite(Expression[] args)
		{
			return ExpressionExtension.MakeDynamic(base.DelegateType, base.Binder, args[0], args[1]);
		}
	}
	internal sealed class TypedDynamicExpression2 : DynamicExpression2
	{
		public sealed override Type Type { get; }

		internal TypedDynamicExpression2(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1)
			: base(delegateType, binder, arg0, arg1)
		{
			Type = retType;
		}
	}
	internal class DynamicExpression3 : DynamicExpression, IArgumentProvider
	{
		private object _arg0;

		private readonly Expression _arg1;

		private readonly Expression _arg2;

		int IArgumentProvider.ArgumentCount => 3;

		internal DynamicExpression3(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2)
			: base(delegateType, binder)
		{
			_arg0 = arg0;
			_arg1 = arg1;
			_arg2 = arg2;
		}

		Expression IArgumentProvider.GetArgument(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				2 => _arg2, 
				_ => throw new ArgumentOutOfRangeException("index"), 
			};
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			if (arguments != null && arguments.Count == 3)
			{
				if (_arg0 is ReadOnlyCollection<Expression> current)
				{
					return ExpressionUtils.SameElements(arguments, current);
				}
				using IEnumerator<Expression> enumerator = arguments.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _arg0)
				{
					enumerator.MoveNext();
					if (enumerator.Current == _arg1)
					{
						enumerator.MoveNext();
						return enumerator.Current == _arg2;
					}
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		internal override DynamicExpression Rewrite(Expression[] args)
		{
			return ExpressionExtension.MakeDynamic(base.DelegateType, base.Binder, args[0], args[1], args[2]);
		}
	}
	internal sealed class TypedDynamicExpression3 : DynamicExpression3
	{
		public sealed override Type Type { get; }

		internal TypedDynamicExpression3(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2)
			: base(delegateType, binder, arg0, arg1, arg2)
		{
			Type = retType;
		}
	}
	internal class DynamicExpression4 : DynamicExpression, IArgumentProvider
	{
		private object _arg0;

		private readonly Expression _arg1;

		private readonly Expression _arg2;

		private readonly Expression _arg3;

		int IArgumentProvider.ArgumentCount => 4;

		internal DynamicExpression4(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
			: base(delegateType, binder)
		{
			_arg0 = arg0;
			_arg1 = arg1;
			_arg2 = arg2;
			_arg3 = arg3;
		}

		Expression IArgumentProvider.GetArgument(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				2 => _arg2, 
				3 => _arg3, 
				_ => throw new ArgumentOutOfRangeException("index"), 
			};
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			if (arguments != null && arguments.Count == 4)
			{
				if (_arg0 is ReadOnlyCollection<Expression> current)
				{
					return ExpressionUtils.SameElements(arguments, current);
				}
				using IEnumerator<Expression> enumerator = arguments.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _arg0)
				{
					enumerator.MoveNext();
					if (enumerator.Current == _arg1)
					{
						enumerator.MoveNext();
						if (enumerator.Current == _arg2)
						{
							enumerator.MoveNext();
							return enumerator.Current == _arg3;
						}
					}
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		internal override DynamicExpression Rewrite(Expression[] args)
		{
			return ExpressionExtension.MakeDynamic(base.DelegateType, base.Binder, args[0], args[1], args[2], args[3]);
		}
	}
	internal sealed class TypedDynamicExpression4 : DynamicExpression4
	{
		public sealed override Type Type { get; }

		internal TypedDynamicExpression4(Type retType, Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
			: base(delegateType, binder, arg0, arg1, arg2, arg3)
		{
			Type = retType;
		}
	}
	internal static class ExpressionExtension
	{
		public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, params Expression[] arguments)
		{
			return MakeDynamic(delegateType, binder, (IEnumerable<Expression>)arguments);
		}

		public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, IEnumerable<Expression> arguments)
		{
			IReadOnlyList<Expression> readOnlyList = (arguments as IReadOnlyList<Expression>) ?? arguments.ToReadOnly();
			switch (readOnlyList.Count)
			{
			case 1:
				return MakeDynamic(delegateType, binder, readOnlyList[0]);
			case 2:
				return MakeDynamic(delegateType, binder, readOnlyList[0], readOnlyList[1]);
			case 3:
				return MakeDynamic(delegateType, binder, readOnlyList[0], readOnlyList[1], readOnlyList[2]);
			case 4:
				return MakeDynamic(delegateType, binder, readOnlyList[0], readOnlyList[1], readOnlyList[2], readOnlyList[3]);
			default:
			{
				ContractUtils.RequiresNotNull(delegateType, "delegateType");
				ContractUtils.RequiresNotNull(binder, "binder");
				if (!delegateType.IsSubclassOf(typeof(MulticastDelegate)))
				{
					throw Error.TypeMustBeDerivedFromSystemDelegate();
				}
				MethodInfo validMethodForDynamic = GetValidMethodForDynamic(delegateType);
				ReadOnlyCollection<Expression> arguments2 = arguments.ToReadOnly();
				ExpressionUtils.ValidateArgumentTypes(validMethodForDynamic, ExpressionType.Dynamic, ref arguments2, "delegateType");
				return DynamicExpression.Make(validMethodForDynamic.GetReturnType(), delegateType, binder, arguments2);
			}
			}
		}

		public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0)
		{
			ContractUtils.RequiresNotNull(delegateType, "delegateType");
			ContractUtils.RequiresNotNull(binder, "binder");
			if (!delegateType.IsSubclassOf(typeof(MulticastDelegate)))
			{
				throw Error.TypeMustBeDerivedFromSystemDelegate();
			}
			MethodInfo validMethodForDynamic = GetValidMethodForDynamic(delegateType);
			ParameterInfo[] parametersCached = validMethodForDynamic.GetParametersCached();
			ExpressionUtils.ValidateArgumentCount(validMethodForDynamic, ExpressionType.Dynamic, 2, parametersCached);
			ValidateDynamicArgument(arg0, "arg0");
			ExpressionUtils.ValidateOneArgument(validMethodForDynamic, ExpressionType.Dynamic, arg0, parametersCached[1], "delegateType", "arg0");
			return DynamicExpression.Make(validMethodForDynamic.GetReturnType(), delegateType, binder, arg0);
		}

		public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1)
		{
			ContractUtils.RequiresNotNull(delegateType, "delegateType");
			ContractUtils.RequiresNotNull(binder, "binder");
			if (!delegateType.IsSubclassOf(typeof(MulticastDelegate)))
			{
				throw Error.TypeMustBeDerivedFromSystemDelegate();
			}
			MethodInfo validMethodForDynamic = GetValidMethodForDynamic(delegateType);
			ParameterInfo[] parametersCached = validMethodForDynamic.GetParametersCached();
			ExpressionUtils.ValidateArgumentCount(validMethodForDynamic, ExpressionType.Dynamic, 3, parametersCached);
			ValidateDynamicArgument(arg0, "arg0");
			ExpressionUtils.ValidateOneArgument(validMethodForDynamic, ExpressionType.Dynamic, arg0, parametersCached[1], "delegateType", "arg0");
			ValidateDynamicArgument(arg1, "arg1");
			ExpressionUtils.ValidateOneArgument(validMethodForDynamic, ExpressionType.Dynamic, arg1, parametersCached[2], "delegateType", "arg1");
			return DynamicExpression.Make(validMethodForDynamic.GetReturnType(), delegateType, binder, arg0, arg1);
		}

		public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2)
		{
			ContractUtils.RequiresNotNull(delegateType, "delegateType");
			ContractUtils.RequiresNotNull(binder, "binder");
			if (!delegateType.IsSubclassOf(typeof(MulticastDelegate)))
			{
				throw Error.TypeMustBeDerivedFromSystemDelegate();
			}
			MethodInfo validMethodForDynamic = GetValidMethodForDynamic(delegateType);
			ParameterInfo[] parametersCached = validMethodForDynamic.GetParametersCached();
			ExpressionUtils.ValidateArgumentCount(validMethodForDynamic, ExpressionType.Dynamic, 4, parametersCached);
			ValidateDynamicArgument(arg0, "arg0");
			ExpressionUtils.ValidateOneArgument(validMethodForDynamic, ExpressionType.Dynamic, arg0, parametersCached[1], "delegateType", "arg0");
			ValidateDynamicArgument(arg1, "arg1");
			ExpressionUtils.ValidateOneArgument(validMethodForDynamic, ExpressionType.Dynamic, arg1, parametersCached[2], "delegateType", "arg1");
			ValidateDynamicArgument(arg2, "arg2");
			ExpressionUtils.ValidateOneArgument(validMethodForDynamic, ExpressionType.Dynamic, arg2, parametersCached[3], "delegateType", "arg2");
			return DynamicExpression.Make(validMethodForDynamic.GetReturnType(), delegateType, binder, arg0, arg1, arg2);
		}

		public static DynamicExpression MakeDynamic(Type delegateType, CallSiteBinder binder, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
		{
			ContractUtils.RequiresNotNull(delegateType, "delegateType");
			ContractUtils.RequiresNotNull(binder, "binder");
			if (!delegateType.IsSubclassOf(typeof(MulticastDelegate)))
			{
				throw Error.TypeMustBeDerivedFromSystemDelegate();
			}
			MethodInfo validMethodForDynamic = GetValidMethodForDynamic(delegateType);
			ParameterInfo[] parametersCached = validMethodForDynamic.GetParametersCached();
			ExpressionUtils.ValidateArgumentCount(validMethodForDynamic, ExpressionType.Dynamic, 5, parametersCached);
			ValidateDynamicArgument(arg0, "arg0");
			ExpressionUtils.ValidateOneArgument(validMethodForDynamic, ExpressionType.Dynamic, arg0, parametersCached[1], "delegateType", "arg0");
			ValidateDynamicArgument(arg1, "arg1");
			ExpressionUtils.ValidateOneArgument(validMethodForDynamic, ExpressionType.Dynamic, arg1, parametersCached[2], "delegateType", "arg1");
			ValidateDynamicArgument(arg2, "arg2");
			ExpressionUtils.ValidateOneArgument(validMethodForDynamic, ExpressionType.Dynamic, arg2, parametersCached[3], "delegateType", "arg2");
			ValidateDynamicArgument(arg3, "arg3");
			ExpressionUtils.ValidateOneArgument(validMethodForDynamic, ExpressionType.Dynamic, arg3, parametersCached[4], "delegateType", "arg3");
			return DynamicExpression.Make(validMethodForDynamic.GetReturnType(), delegateType, binder, arg0, arg1, arg2, arg3);
		}

		private static MethodInfo GetValidMethodForDynamic(Type delegateType)
		{
			MethodInfo invokeMethod = delegateType.GetInvokeMethod();
			ParameterInfo[] parametersCached = invokeMethod.GetParametersCached();
			if (parametersCached.Length == 0 || parametersCached[0].ParameterType != typeof(CallSite))
			{
				throw Error.FirstArgumentMustBeCallSite();
			}
			return invokeMethod;
		}

		public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, params Expression[] arguments)
		{
			return Dynamic(binder, returnType, (IEnumerable<Expression>)arguments);
		}

		public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			ValidateDynamicArgument(arg0, "arg0");
			DelegateHelpers.TypeInfo nextTypeInfo = DelegateHelpers.GetNextTypeInfo(returnType, DelegateHelpers.GetNextTypeInfo(arg0.Type, DelegateHelpers.NextTypeInfo(typeof(CallSite))));
			Type delegateType = nextTypeInfo.DelegateType ?? nextTypeInfo.MakeDelegateType(returnType, arg0);
			return DynamicExpression.Make(returnType, delegateType, binder, arg0);
		}

		public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			ValidateDynamicArgument(arg0, "arg0");
			ValidateDynamicArgument(arg1, "arg1");
			DelegateHelpers.TypeInfo nextTypeInfo = DelegateHelpers.GetNextTypeInfo(returnType, DelegateHelpers.GetNextTypeInfo(arg1.Type, DelegateHelpers.GetNextTypeInfo(arg0.Type, DelegateHelpers.NextTypeInfo(typeof(CallSite)))));
			Type delegateType = nextTypeInfo.DelegateType ?? nextTypeInfo.MakeDelegateType(returnType, arg0, arg1);
			return DynamicExpression.Make(returnType, delegateType, binder, arg0, arg1);
		}

		public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			ValidateDynamicArgument(arg0, "arg0");
			ValidateDynamicArgument(arg1, "arg1");
			ValidateDynamicArgument(arg2, "arg2");
			DelegateHelpers.TypeInfo nextTypeInfo = DelegateHelpers.GetNextTypeInfo(returnType, DelegateHelpers.GetNextTypeInfo(arg2.Type, DelegateHelpers.GetNextTypeInfo(arg1.Type, DelegateHelpers.GetNextTypeInfo(arg0.Type, DelegateHelpers.NextTypeInfo(typeof(CallSite))))));
			Type delegateType = nextTypeInfo.DelegateType ?? nextTypeInfo.MakeDelegateType(returnType, arg0, arg1, arg2);
			return DynamicExpression.Make(returnType, delegateType, binder, arg0, arg1, arg2);
		}

		public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			ValidateDynamicArgument(arg0, "arg0");
			ValidateDynamicArgument(arg1, "arg1");
			ValidateDynamicArgument(arg2, "arg2");
			ValidateDynamicArgument(arg3, "arg3");
			DelegateHelpers.TypeInfo nextTypeInfo = DelegateHelpers.GetNextTypeInfo(returnType, DelegateHelpers.GetNextTypeInfo(arg3.Type, DelegateHelpers.GetNextTypeInfo(arg2.Type, DelegateHelpers.GetNextTypeInfo(arg1.Type, DelegateHelpers.GetNextTypeInfo(arg0.Type, DelegateHelpers.NextTypeInfo(typeof(CallSite)))))));
			Type delegateType = nextTypeInfo.DelegateType ?? nextTypeInfo.MakeDelegateType(returnType, arg0, arg1, arg2, arg3);
			return DynamicExpression.Make(returnType, delegateType, binder, arg0, arg1, arg2, arg3);
		}

		public static DynamicExpression Dynamic(CallSiteBinder binder, Type returnType, IEnumerable<Expression> arguments)
		{
			ContractUtils.RequiresNotNull(arguments, "arguments");
			ContractUtils.RequiresNotNull(returnType, "returnType");
			ReadOnlyCollection<Expression> readOnlyCollection = arguments.ToReadOnly();
			ContractUtils.RequiresNotEmpty(readOnlyCollection, "arguments");
			return MakeDynamic(binder, returnType, readOnlyCollection);
		}

		private static DynamicExpression MakeDynamic(CallSiteBinder binder, Type returnType, ReadOnlyCollection<Expression> arguments)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			int count = arguments.Count;
			for (int i = 0; i < count; i++)
			{
				ValidateDynamicArgument(arguments[i], "arguments", i);
			}
			Type delegateType = DelegateHelpers.MakeCallSiteDelegate(arguments, returnType);
			return count switch
			{
				1 => DynamicExpression.Make(returnType, delegateType, binder, arguments[0]), 
				2 => DynamicExpression.Make(returnType, delegateType, binder, arguments[0], arguments[1]), 
				3 => DynamicExpression.Make(returnType, delegateType, binder, arguments[0], arguments[1], arguments[2]), 
				4 => DynamicExpression.Make(returnType, delegateType, binder, arguments[0], arguments[1], arguments[2], arguments[3]), 
				_ => DynamicExpression.Make(returnType, delegateType, binder, arguments), 
			};
		}

		private static void ValidateDynamicArgument(Expression arg, string paramName)
		{
			ValidateDynamicArgument(arg, paramName, -1);
		}

		private static void ValidateDynamicArgument(Expression arg, string paramName, int index)
		{
			ExpressionUtils.RequiresCanRead(arg, paramName, index);
			Type type = arg.Type;
			ContractUtils.RequiresNotNull(type, "type");
			TypeUtils.ValidateType(type, "type", allowByRef: true, allowPointer: true);
			if (type == typeof(void))
			{
				throw Error.ArgumentTypeCannotBeVoid();
			}
		}
	}
	/// <summary>Represents a visitor or rewriter for dynamic expression trees.</summary>
	public class DynamicExpressionVisitor : ExpressionVisitor
	{
		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>Returns <see cref="T:System.Linq.Expressions.Expression" />, the modified expression, if it or any subexpression is modified; otherwise, returns the original expression.</returns>
		protected internal override Expression VisitDynamic(DynamicExpression node)
		{
			Expression[] array = ExpressionVisitorUtils.VisitArguments(this, node);
			if (array == null)
			{
				return node;
			}
			return node.Rewrite(array);
		}

		/// <summary>Initializes a new instance of <see cref="T:System.Linq.Expressions.DynamicExpressionVisitor" />.</summary>
		public DynamicExpressionVisitor()
		{
		}
	}
	/// <summary>Represents an initializer for a single element of an <see cref="T:System.Collections.IEnumerable" /> collection.</summary>
	public sealed class ElementInit : IArgumentProvider
	{
		/// <summary>Gets the instance method that is used to add an element to an <see cref="T:System.Collections.IEnumerable" /> collection.</summary>
		/// <returns>A <see cref="T:System.Reflection.MethodInfo" /> that represents an instance method that adds an element to a collection.</returns>
		public MethodInfo AddMethod { get; }

		/// <summary>Gets the collection of arguments that are passed to a method that adds an element to an <see cref="T:System.Collections.IEnumerable" /> collection.</summary>
		/// <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments for a method that adds an element to a collection.</returns>
		public ReadOnlyCollection<Expression> Arguments { get; }

		public int ArgumentCount => Arguments.Count;

		internal ElementInit(MethodInfo addMethod, ReadOnlyCollection<Expression> arguments)
		{
			AddMethod = addMethod;
			Arguments = arguments;
		}

		public Expression GetArgument(int index)
		{
			return Arguments[index];
		}

		/// <summary>Returns a textual representation of an <see cref="T:System.Linq.Expressions.ElementInit" /> object.</summary>
		/// <returns>A textual representation of the <see cref="T:System.Linq.Expressions.ElementInit" /> object.</returns>
		public override string ToString()
		{
			return ExpressionStringBuilder.ElementInitBindingToString(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="arguments">The <see cref="P:System.Linq.Expressions.ElementInit.Arguments" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public ElementInit Update(IEnumerable<Expression> arguments)
		{
			if (arguments == Arguments)
			{
				return this;
			}
			return Expression.ElementInit(AddMethod, arguments);
		}

		internal ElementInit()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal static class Error
	{
		internal static Exception ReducibleMustOverrideReduce()
		{
			return new ArgumentException(Strings.ReducibleMustOverrideReduce);
		}

		internal static Exception ArgCntMustBeGreaterThanNameCnt()
		{
			return new ArgumentException(Strings.ArgCntMustBeGreaterThanNameCnt);
		}

		internal static Exception InvalidMetaObjectCreated(object p0)
		{
			return new InvalidOperationException(Strings.InvalidMetaObjectCreated(p0));
		}

		internal static Exception AmbiguousMatchInExpandoObject(object p0)
		{
			return new AmbiguousMatchException(Strings.AmbiguousMatchInExpandoObject(p0));
		}

		internal static Exception SameKeyExistsInExpando(object key)
		{
			return new ArgumentException(Strings.SameKeyExistsInExpando(key), "key");
		}

		internal static Exception KeyDoesNotExistInExpando(object p0)
		{
			return new KeyNotFoundException(Strings.KeyDoesNotExistInExpando(p0));
		}

		internal static Exception CollectionModifiedWhileEnumerating()
		{
			return new InvalidOperationException(Strings.CollectionModifiedWhileEnumerating);
		}

		internal static Exception CollectionReadOnly()
		{
			return new NotSupportedException(Strings.CollectionReadOnly);
		}

		internal static Exception MustReduceToDifferent()
		{
			return new ArgumentException(Strings.MustReduceToDifferent);
		}

		internal static Exception BinderNotCompatibleWithCallSite(object p0, object p1, object p2)
		{
			return new InvalidOperationException(Strings.BinderNotCompatibleWithCallSite(p0, p1, p2));
		}

		internal static Exception DynamicBindingNeedsRestrictions(object p0, object p1)
		{
			return new InvalidOperationException(Strings.DynamicBindingNeedsRestrictions(p0, p1));
		}

		internal static Exception DynamicObjectResultNotAssignable(object p0, object p1, object p2, object p3)
		{
			return new InvalidCastException(Strings.DynamicObjectResultNotAssignable(p0, p1, p2, p3));
		}

		internal static Exception DynamicBinderResultNotAssignable(object p0, object p1, object p2)
		{
			return new InvalidCastException(Strings.DynamicBinderResultNotAssignable(p0, p1, p2));
		}

		internal static Exception BindingCannotBeNull()
		{
			return new InvalidOperationException(Strings.BindingCannotBeNull);
		}

		internal static Exception ReducedNotCompatible()
		{
			return new ArgumentException(Strings.ReducedNotCompatible);
		}

		internal static Exception SetterHasNoParams(string paramName)
		{
			return new ArgumentException(Strings.SetterHasNoParams, paramName);
		}

		internal static Exception PropertyCannotHaveRefType(string paramName)
		{
			return new ArgumentException(Strings.PropertyCannotHaveRefType, paramName);
		}

		internal static Exception IndexesOfSetGetMustMatch(string paramName)
		{
			return new ArgumentException(Strings.IndexesOfSetGetMustMatch, paramName);
		}

		internal static Exception TypeParameterIsNotDelegate(object p0)
		{
			return new InvalidOperationException(Strings.TypeParameterIsNotDelegate(p0));
		}

		internal static Exception FirstArgumentMustBeCallSite()
		{
			return new ArgumentException(Strings.FirstArgumentMustBeCallSite);
		}

		internal static Exception AccessorsCannotHaveVarArgs(string paramName)
		{
			return new ArgumentException(Strings.AccessorsCannotHaveVarArgs, paramName);
		}

		private static Exception AccessorsCannotHaveByRefArgs(string paramName)
		{
			return new ArgumentException(Strings.AccessorsCannotHaveByRefArgs, paramName);
		}

		internal static Exception AccessorsCannotHaveByRefArgs(string paramName, int index)
		{
			return AccessorsCannotHaveByRefArgs(GetParamName(paramName, index));
		}

		internal static Exception TypeMustBeDerivedFromSystemDelegate()
		{
			return new ArgumentException(Strings.TypeMustBeDerivedFromSystemDelegate);
		}

		internal static Exception NoOrInvalidRuleProduced()
		{
			return new InvalidOperationException(Strings.NoOrInvalidRuleProduced);
		}

		internal static Exception BoundsCannotBeLessThanOne(string paramName)
		{
			return new ArgumentException(Strings.BoundsCannotBeLessThanOne, paramName);
		}

		internal static Exception TypeMustNotBeByRef(string paramName)
		{
			return new ArgumentException(Strings.TypeMustNotBeByRef, paramName);
		}

		internal static Exception TypeMustNotBePointer(string paramName)
		{
			return new ArgumentException(Strings.TypeMustNotBePointer, paramName);
		}

		internal static Exception SetterMustBeVoid(string paramName)
		{
			return new ArgumentException(Strings.SetterMustBeVoid, paramName);
		}

		internal static Exception PropertyTypeMustMatchGetter(string paramName)
		{
			return new ArgumentException(Strings.PropertyTypeMustMatchGetter, paramName);
		}

		internal static Exception PropertyTypeMustMatchSetter(string paramName)
		{
			return new ArgumentException(Strings.PropertyTypeMustMatchSetter, paramName);
		}

		internal static Exception BothAccessorsMustBeStatic(string paramName)
		{
			return new ArgumentException(Strings.BothAccessorsMustBeStatic, paramName);
		}

		internal static Exception OnlyStaticFieldsHaveNullInstance(string paramName)
		{
			return new ArgumentException(Strings.OnlyStaticFieldsHaveNullInstance, paramName);
		}

		internal static Exception OnlyStaticPropertiesHaveNullInstance(string paramName)
		{
			return new ArgumentException(Strings.OnlyStaticPropertiesHaveNullInstance, paramName);
		}

		internal static Exception OnlyStaticMethodsHaveNullInstance()
		{
			return new ArgumentException(Strings.OnlyStaticMethodsHaveNullInstance);
		}

		internal static Exception PropertyTypeCannotBeVoid(string paramName)
		{
			return new ArgumentException(Strings.PropertyTypeCannotBeVoid, paramName);
		}

		internal static Exception InvalidUnboxType(string paramName)
		{
			return new ArgumentException(Strings.InvalidUnboxType, paramName);
		}

		internal static Exception ExpressionMustBeWriteable(string paramName)
		{
			return new ArgumentException(Strings.ExpressionMustBeWriteable, paramName);
		}

		internal static Exception ArgumentMustNotHaveValueType(string paramName)
		{
			return new ArgumentException(Strings.ArgumentMustNotHaveValueType, paramName);
		}

		internal static Exception MustBeReducible()
		{
			return new ArgumentException(Strings.MustBeReducible);
		}

		internal static Exception AllTestValuesMustHaveSameType(string paramName)
		{
			return new ArgumentException(Strings.AllTestValuesMustHaveSameType, paramName);
		}

		internal static Exception AllCaseBodiesMustHaveSameType(string paramName)
		{
			return new ArgumentException(Strings.AllCaseBodiesMustHaveSameType, paramName);
		}

		internal static Exception DefaultBodyMustBeSupplied(string paramName)
		{
			return new ArgumentException(Strings.DefaultBodyMustBeSupplied, paramName);
		}

		internal static Exception LabelMustBeVoidOrHaveExpression(string paramName)
		{
			return new ArgumentException(Strings.LabelMustBeVoidOrHaveExpression, paramName);
		}

		internal static Exception LabelTypeMustBeVoid(string paramName)
		{
			return new ArgumentException(Strings.LabelTypeMustBeVoid, paramName);
		}

		internal static Exception QuotedExpressionMustBeLambda(string paramName)
		{
			return new ArgumentException(Strings.QuotedExpressionMustBeLambda, paramName);
		}

		internal static Exception VariableMustNotBeByRef(object p0, object p1, string paramName)
		{
			return new ArgumentException(Strings.VariableMustNotBeByRef(p0, p1), paramName);
		}

		internal static Exception VariableMustNotBeByRef(object p0, object p1, string paramName, int index)
		{
			return VariableMustNotBeByRef(p0, p1, GetParamName(paramName, index));
		}

		private static Exception DuplicateVariable(object p0, string paramName)
		{
			return new ArgumentException(Strings.DuplicateVariable(p0), paramName);
		}

		internal static Exception DuplicateVariable(object p0, string paramName, int index)
		{
			return DuplicateVariable(p0, GetParamName(paramName, index));
		}

		internal static Exception StartEndMustBeOrdered()
		{
			return new ArgumentException(Strings.StartEndMustBeOrdered);
		}

		internal static Exception FaultCannotHaveCatchOrFinally(string paramName)
		{
			return new ArgumentException(Strings.FaultCannotHaveCatchOrFinally, paramName);
		}

		internal static Exception TryMustHaveCatchFinallyOrFault()
		{
			return new ArgumentException(Strings.TryMustHaveCatchFinallyOrFault);
		}

		internal static Exception BodyOfCatchMustHaveSameTypeAsBodyOfTry()
		{
			return new ArgumentException(Strings.BodyOfCatchMustHaveSameTypeAsBodyOfTry);
		}

		internal static Exception ExtensionNodeMustOverrideProperty(object p0)
		{
			return new InvalidOperationException(Strings.ExtensionNodeMustOverrideProperty(p0));
		}

		internal static Exception UserDefinedOperatorMustBeStatic(object p0, string paramName)
		{
			return new ArgumentException(Strings.UserDefinedOperatorMustBeStatic(p0), paramName);
		}

		internal static Exception UserDefinedOperatorMustNotBeVoid(object p0, string paramName)
		{
			return new ArgumentException(Strings.UserDefinedOperatorMustNotBeVoid(p0), paramName);
		}

		internal static Exception CoercionOperatorNotDefined(object p0, object p1)
		{
			return new InvalidOperationException(Strings.CoercionOperatorNotDefined(p0, p1));
		}

		internal static Exception UnaryOperatorNotDefined(object p0, object p1)
		{
			return new InvalidOperationException(Strings.UnaryOperatorNotDefined(p0, p1));
		}

		internal static Exception BinaryOperatorNotDefined(object p0, object p1, object p2)
		{
			return new InvalidOperationException(Strings.BinaryOperatorNotDefined(p0, p1, p2));
		}

		internal static Exception ReferenceEqualityNotDefined(object p0, object p1)
		{
			return new InvalidOperationException(Strings.ReferenceEqualityNotDefined(p0, p1));
		}

		internal static Exception OperandTypesDoNotMatchParameters(object p0, object p1)
		{
			return new InvalidOperationException(Strings.OperandTypesDoNotMatchParameters(p0, p1));
		}

		internal static Exception OverloadOperatorTypeDoesNotMatchConversionType(object p0, object p1)
		{
			return new InvalidOperationException(Strings.OverloadOperatorTypeDoesNotMatchConversionType(p0, p1));
		}

		internal static Exception ConversionIsNotSupportedForArithmeticTypes()
		{
			return new InvalidOperationException(Strings.ConversionIsNotSupportedForArithmeticTypes);
		}

		internal static Exception ArgumentTypeCannotBeVoid()
		{
			return new ArgumentException(Strings.ArgumentTypeCannotBeVoid);
		}

		internal static Exception ArgumentMustBeArray(string paramName)
		{
			return new ArgumentException(Strings.ArgumentMustBeArray, paramName);
		}

		internal static Exception ArgumentMustBeBoolean(string paramName)
		{
			return new ArgumentException(Strings.ArgumentMustBeBoolean, paramName);
		}

		internal static Exception EqualityMustReturnBoolean(object p0, string paramName)
		{
			return new ArgumentException(Strings.EqualityMustReturnBoolean(p0), paramName);
		}

		internal static Exception ArgumentMustBeFieldInfoOrPropertyInfo(string paramName)
		{
			return new ArgumentException(Strings.ArgumentMustBeFieldInfoOrPropertyInfo, paramName);
		}

		private static Exception ArgumentMustBeFieldInfoOrPropertyInfoOrMethod(string paramName)
		{
			return new ArgumentException(Strings.ArgumentMustBeFieldInfoOrPropertyInfoOrMethod, paramName);
		}

		internal static Exception ArgumentMustBeFieldInfoOrPropertyInfoOrMethod(string paramName, int index)
		{
			return ArgumentMustBeFieldInfoOrPropertyInfoOrMethod(GetParamName(paramName, index));
		}

		private static Exception ArgumentMustBeInstanceMember(string paramName)
		{
			return new ArgumentException(Strings.ArgumentMustBeInstanceMember, paramName);
		}

		internal static Exception ArgumentMustBeInstanceMember(string paramName, int index)
		{
			return ArgumentMustBeInstanceMember(GetParamName(paramName, index));
		}

		private static Exception ArgumentMustBeInteger(string paramName)
		{
			return new ArgumentException(Strings.ArgumentMustBeInteger, paramName);
		}

		internal static Exception ArgumentMustBeInteger(string paramName, int index)
		{
			return ArgumentMustBeInteger(GetParamName(paramName, index));
		}

		internal static Exception ArgumentMustBeArrayIndexType(string paramName)
		{
			return new ArgumentException(Strings.ArgumentMustBeArrayIndexType, paramName);
		}

		internal static Exception ArgumentMustBeArrayIndexType(string paramName, int index)
		{
			return ArgumentMustBeArrayIndexType(GetParamName(paramName, index));
		}

		internal static Exception ArgumentMustBeSingleDimensionalArrayType(string paramName)
		{
			return new ArgumentException(Strings.ArgumentMustBeSingleDimensionalArrayType, paramName);
		}

		internal static Exception ArgumentTypesMustMatch()
		{
			return new ArgumentException(Strings.ArgumentTypesMustMatch);
		}

		internal static Exception ArgumentTypesMustMatch(string paramName)
		{
			return new ArgumentException(Strings.ArgumentTypesMustMatch, paramName);
		}

		internal static Exception CannotAutoInitializeValueTypeElementThroughProperty(object p0)
		{
			return new InvalidOperationException(Strings.CannotAutoInitializeValueTypeElementThroughProperty(p0));
		}

		internal static Exception CannotAutoInitializeValueTypeMemberThroughProperty(object p0)
		{
			return new InvalidOperationException(Strings.CannotAutoInitializeValueTypeMemberThroughProperty(p0));
		}

		internal static Exception IncorrectTypeForTypeAs(object p0, string paramName)
		{
			return new ArgumentException(Strings.IncorrectTypeForTypeAs(p0), paramName);
		}

		internal static Exception CoalesceUsedOnNonNullType()
		{
			return new InvalidOperationException(Strings.CoalesceUsedOnNonNullType);
		}

		internal static Exception ExpressionTypeCannotInitializeArrayType(object p0, object p1)
		{
			return new InvalidOperationException(Strings.ExpressionTypeCannotInitializeArrayType(p0, p1));
		}

		private static Exception ArgumentTypeDoesNotMatchMember(object p0, object p1, string paramName)
		{
			return new ArgumentException(Strings.ArgumentTypeDoesNotMatchMember(p0, p1), paramName);
		}

		internal static Exception ArgumentTypeDoesNotMatchMember(object p0, object p1, string paramName, int index)
		{
			return ArgumentTypeDoesNotMatchMember(p0, p1, GetParamName(paramName, index));
		}

		private static Exception ArgumentMemberNotDeclOnType(object p0, object p1, string paramName)
		{
			return new ArgumentException(Strings.ArgumentMemberNotDeclOnType(p0, p1), paramName);
		}

		internal static Exception ArgumentMemberNotDeclOnType(object p0, object p1, string paramName, int index)
		{
			return ArgumentMemberNotDeclOnType(p0, p1, GetParamName(paramName, index));
		}

		internal static Exception ExpressionTypeDoesNotMatchReturn(object p0, object p1)
		{
			return new ArgumentException(Strings.ExpressionTypeDoesNotMatchReturn(p0, p1));
		}

		internal static Exception ExpressionTypeDoesNotMatchAssignment(object p0, object p1)
		{
			return new ArgumentException(Strings.ExpressionTypeDoesNotMatchAssignment(p0, p1));
		}

		internal static Exception ExpressionTypeDoesNotMatchLabel(object p0, object p1)
		{
			return new ArgumentException(Strings.ExpressionTypeDoesNotMatchLabel(p0, p1));
		}

		internal static Exception ExpressionTypeNotInvocable(object p0, string paramName)
		{
			return new ArgumentException(Strings.ExpressionTypeNotInvocable(p0), paramName);
		}

		internal static Exception FieldNotDefinedForType(object p0, object p1)
		{
			return new ArgumentException(Strings.FieldNotDefinedForType(p0, p1));
		}

		internal static Exception InstanceFieldNotDefinedForType(object p0, object p1)
		{
			return new ArgumentException(Strings.InstanceFieldNotDefinedForType(p0, p1));
		}

		internal static Exception FieldInfoNotDefinedForType(object p0, object p1, object p2)
		{
			return new ArgumentException(Strings.FieldInfoNotDefinedForType(p0, p1, p2));
		}

		internal static Exception IncorrectNumberOfIndexes()
		{
			return new ArgumentException(Strings.IncorrectNumberOfIndexes);
		}

		internal static Exception IncorrectNumberOfLambdaDeclarationParameters()
		{
			return new ArgumentException(Strings.IncorrectNumberOfLambdaDeclarationParameters);
		}

		internal static Exception IncorrectNumberOfMembersForGivenConstructor()
		{
			return new ArgumentException(Strings.IncorrectNumberOfMembersForGivenConstructor);
		}

		internal static Exception IncorrectNumberOfArgumentsForMembers()
		{
			return new ArgumentException(Strings.IncorrectNumberOfArgumentsForMembers);
		}

		internal static Exception LambdaTypeMustBeDerivedFromSystemDelegate(string paramName)
		{
			return new ArgumentException(Strings.LambdaTypeMustBeDerivedFromSystemDelegate, paramName);
		}

		internal static Exception MemberNotFieldOrProperty(object p0, string paramName)
		{
			return new ArgumentException(Strings.MemberNotFieldOrProperty(p0), paramName);
		}

		internal static Exception MethodContainsGenericParameters(object p0, string paramName)
		{
			return new ArgumentException(Strings.MethodContainsGenericParameters(p0), paramName);
		}

		internal static Exception MethodIsGeneric(object p0, string paramName)
		{
			return new ArgumentException(Strings.MethodIsGeneric(p0), paramName);
		}

		private static Exception MethodNotPropertyAccessor(object p0, object p1, string paramName)
		{
			return new ArgumentException(Strings.MethodNotPropertyAccessor(p0, p1), paramName);
		}

		internal static Exception MethodNotPropertyAccessor(object p0, object p1, string paramName, int index)
		{
			return MethodNotPropertyAccessor(p0, p1, GetParamName(paramName, index));
		}

		internal static Exception PropertyDoesNotHaveGetter(object p0, string paramName)
		{
			return new ArgumentException(Strings.PropertyDoesNotHaveGetter(p0), paramName);
		}

		internal static Exception PropertyDoesNotHaveGetter(object p0, string paramName, int index)
		{
			return PropertyDoesNotHaveGetter(p0, GetParamName(paramName, index));
		}

		internal static Exception PropertyDoesNotHaveSetter(object p0, string paramName)
		{
			return new ArgumentException(Strings.PropertyDoesNotHaveSetter(p0), paramName);
		}

		internal static Exception PropertyDoesNotHaveAccessor(object p0, string paramName)
		{
			return new ArgumentException(Strings.PropertyDoesNotHaveAccessor(p0), paramName);
		}

		internal static Exception NotAMemberOfType(object p0, object p1, string paramName)
		{
			return new ArgumentException(Strings.NotAMemberOfType(p0, p1), paramName);
		}

		internal static Exception NotAMemberOfType(object p0, object p1, string paramName, int index)
		{
			return NotAMemberOfType(p0, p1, GetParamName(paramName, index));
		}

		internal static Exception NotAMemberOfAnyType(object p0, string paramName)
		{
			return new ArgumentException(Strings.NotAMemberOfAnyType(p0), paramName);
		}

		internal static Exception ParameterExpressionNotValidAsDelegate(object p0, object p1)
		{
			return new ArgumentException(Strings.ParameterExpressionNotValidAsDelegate(p0, p1));
		}

		internal static Exception PropertyNotDefinedForType(object p0, object p1, string paramName)
		{
			return new ArgumentException(Strings.PropertyNotDefinedForType(p0, p1), paramName);
		}

		internal static Exception InstancePropertyNotDefinedForType(object p0, object p1, string paramName)
		{
			return new ArgumentException(Strings.InstancePropertyNotDefinedForType(p0, p1), paramName);
		}

		internal static Exception InstancePropertyWithoutParameterNotDefinedForType(object p0, object p1)
		{
			return new ArgumentException(Strings.InstancePropertyWithoutParameterNotDefinedForType(p0, p1));
		}

		internal static Exception InstancePropertyWithSpecifiedParametersNotDefinedForType(object p0, object p1, object p2, string paramName)
		{
			return new ArgumentException(Strings.InstancePropertyWithSpecifiedParametersNotDefinedForType(p0, p1, p2), paramName);
		}

		internal static Exception InstanceAndMethodTypeMismatch(object p0, object p1, object p2)
		{
			return new ArgumentException(Strings.InstanceAndMethodTypeMismatch(p0, p1, p2));
		}

		internal static Exception TypeMissingDefaultConstructor(object p0, string paramName)
		{
			return new ArgumentException(Strings.TypeMissingDefaultConstructor(p0), paramName);
		}

		internal static Exception ElementInitializerMethodNotAdd(string paramName)
		{
			return new ArgumentException(Strings.ElementInitializerMethodNotAdd, paramName);
		}

		internal static Exception ElementInitializerMethodNoRefOutParam(object p0, object p1, string paramName)
		{
			return new ArgumentException(Strings.ElementInitializerMethodNoRefOutParam(p0, p1), paramName);
		}

		internal static Exception ElementInitializerMethodWithZeroArgs(string paramName)
		{
			return new ArgumentException(Strings.ElementInitializerMethodWithZeroArgs, paramName);
		}

		internal static Exception ElementInitializerMethodStatic(string paramName)
		{
			return new ArgumentException(Strings.ElementInitializerMethodStatic, paramName);
		}

		internal static Exception TypeNotIEnumerable(object p0, string paramName)
		{
			return new ArgumentException(Strings.TypeNotIEnumerable(p0), paramName);
		}

		internal static Exception UnhandledBinary(object p0, string paramName)
		{
			return new ArgumentException(Strings.UnhandledBinary(p0), paramName);
		}

		internal static Exception UnhandledBinding()
		{
			return new ArgumentException(Strings.UnhandledBinding);
		}

		internal static Exception UnhandledBindingType(object p0)
		{
			return new ArgumentException(Strings.UnhandledBindingType(p0));
		}

		internal static Exception UnhandledUnary(object p0, string paramName)
		{
			return new ArgumentException(Strings.UnhandledUnary(p0), paramName);
		}

		internal static Exception UnknownBindingType(int index)
		{
			return new ArgumentException(Strings.UnknownBindingType, $"bindings[{index}]");
		}

		internal static Exception UserDefinedOpMustHaveConsistentTypes(object p0, object p1)
		{
			return new ArgumentException(Strings.UserDefinedOpMustHaveConsistentTypes(p0, p1));
		}

		internal static Exception UserDefinedOpMustHaveValidReturnType(object p0, object p1)
		{
			return new ArgumentException(Strings.UserDefinedOpMustHaveValidReturnType(p0, p1));
		}

		internal static Exception LogicalOperatorMustHaveBooleanOperators(object p0, object p1)
		{
			return new ArgumentException(Strings.LogicalOperatorMustHaveBooleanOperators(p0, p1));
		}

		internal static Exception MethodWithArgsDoesNotExistOnType(object p0, object p1)
		{
			return new InvalidOperationException(Strings.MethodWithArgsDoesNotExistOnType(p0, p1));
		}

		internal static Exception GenericMethodWithArgsDoesNotExistOnType(object p0, object p1)
		{
			return new InvalidOperationException(Strings.GenericMethodWithArgsDoesNotExistOnType(p0, p1));
		}

		internal static Exception MethodWithMoreThanOneMatch(object p0, object p1)
		{
			return new InvalidOperationException(Strings.MethodWithMoreThanOneMatch(p0, p1));
		}

		internal static Exception PropertyWithMoreThanOneMatch(object p0, object p1)
		{
			return new InvalidOperationException(Strings.PropertyWithMoreThanOneMatch(p0, p1));
		}

		internal static Exception IncorrectNumberOfTypeArgsForFunc(string paramName)
		{
			return new ArgumentException(Strings.IncorrectNumberOfTypeArgsForFunc, paramName);
		}

		internal static Exception IncorrectNumberOfTypeArgsForAction(string paramName)
		{
			return new ArgumentException(Strings.IncorrectNumberOfTypeArgsForAction, paramName);
		}

		internal static Exception ArgumentCannotBeOfTypeVoid(string paramName)
		{
			return new ArgumentException(Strings.ArgumentCannotBeOfTypeVoid, paramName);
		}

		internal static Exception OutOfRange(string paramName, object p1)
		{
			return new ArgumentOutOfRangeException(paramName, Strings.OutOfRange(paramName, p1));
		}

		internal static Exception LabelTargetAlreadyDefined(object p0)
		{
			return new InvalidOperationException(Strings.LabelTargetAlreadyDefined(p0));
		}

		internal static Exception LabelTargetUndefined(object p0)
		{
			return new InvalidOperationException(Strings.LabelTargetUndefined(p0));
		}

		internal static Exception ControlCannotLeaveFinally()
		{
			return new InvalidOperationException(Strings.ControlCannotLeaveFinally);
		}

		internal static Exception ControlCannotLeaveFilterTest()
		{
			return new InvalidOperationException(Strings.ControlCannotLeaveFilterTest);
		}

		internal static Exception AmbiguousJump(object p0)
		{
			return new InvalidOperationException(Strings.AmbiguousJump(p0));
		}

		internal static Exception ControlCannotEnterTry()
		{
			return new InvalidOperationException(Strings.ControlCannotEnterTry);
		}

		internal static Exception ControlCannotEnterExpression()
		{
			return new InvalidOperationException(Strings.ControlCannotEnterExpression);
		}

		internal static Exception NonLocalJumpWithValue(object p0)
		{
			return new InvalidOperationException(Strings.NonLocalJumpWithValue(p0));
		}

		internal static Exception CannotCompileConstant(object p0)
		{
			return new InvalidOperationException(Strings.CannotCompileConstant(p0));
		}

		internal static Exception CannotCompileDynamic()
		{
			return new NotSupportedException(Strings.CannotCompileDynamic);
		}

		internal static Exception MethodBuilderDoesNotHaveTypeBuilder()
		{
			return new ArgumentException(Strings.MethodBuilderDoesNotHaveTypeBuilder);
		}

		internal static Exception InvalidLvalue(ExpressionType p0)
		{
			return new InvalidOperationException(Strings.InvalidLvalue(p0));
		}

		internal static Exception UndefinedVariable(object p0, object p1, object p2)
		{
			return new InvalidOperationException(Strings.UndefinedVariable(p0, p1, p2));
		}

		internal static Exception CannotCloseOverByRef(object p0, object p1)
		{
			return new InvalidOperationException(Strings.CannotCloseOverByRef(p0, p1));
		}

		internal static Exception UnexpectedVarArgsCall(object p0)
		{
			return new InvalidOperationException(Strings.UnexpectedVarArgsCall(p0));
		}

		internal static Exception RethrowRequiresCatch()
		{
			return new InvalidOperationException(Strings.RethrowRequiresCatch);
		}

		internal static Exception TryNotAllowedInFilter()
		{
			return new InvalidOperationException(Strings.TryNotAllowedInFilter);
		}

		internal static Exception MustRewriteToSameNode(object p0, object p1, object p2)
		{
			return new InvalidOperationException(Strings.MustRewriteToSameNode(p0, p1, p2));
		}

		internal static Exception MustRewriteChildToSameType(object p0, object p1, object p2)
		{
			return new InvalidOperationException(Strings.MustRewriteChildToSameType(p0, p1, p2));
		}

		internal static Exception MustRewriteWithoutMethod(object p0, object p1)
		{
			return new InvalidOperationException(Strings.MustRewriteWithoutMethod(p0, p1));
		}

		internal static Exception TryNotSupportedForMethodsWithRefArgs(object p0)
		{
			return new NotSupportedException(Strings.TryNotSupportedForMethodsWithRefArgs(p0));
		}

		internal static Exception TryNotSupportedForValueTypeInstances(object p0)
		{
			return new NotSupportedException(Strings.TryNotSupportedForValueTypeInstances(p0));
		}

		internal static Exception TestValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1)
		{
			return new ArgumentException(Strings.TestValueTypeDoesNotMatchComparisonMethodParameter(p0, p1));
		}

		internal static Exception SwitchValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1)
		{
			return new ArgumentException(Strings.SwitchValueTypeDoesNotMatchComparisonMethodParameter(p0, p1));
		}

		internal static Exception ArgumentOutOfRange(string paramName)
		{
			return new ArgumentOutOfRangeException(paramName);
		}

		internal static Exception NotSupported()
		{
			return new NotSupportedException();
		}

		internal static Exception NonStaticConstructorRequired(string paramName)
		{
			return new ArgumentException(Strings.NonStaticConstructorRequired, paramName);
		}

		internal static Exception NonAbstractConstructorRequired()
		{
			return new InvalidOperationException(Strings.NonAbstractConstructorRequired);
		}

		internal static Exception InvalidProgram()
		{
			return new InvalidProgramException();
		}

		internal static Exception EnumerationIsDone()
		{
			return new InvalidOperationException(Strings.EnumerationIsDone);
		}

		private static Exception TypeContainsGenericParameters(object p0, string paramName)
		{
			return new ArgumentException(Strings.TypeContainsGenericParameters(p0), paramName);
		}

		internal static Exception TypeContainsGenericParameters(object p0, string paramName, int index)
		{
			return TypeContainsGenericParameters(p0, GetParamName(paramName, index));
		}

		internal static Exception TypeIsGeneric(object p0, string paramName)
		{
			return new ArgumentException(Strings.TypeIsGeneric(p0), paramName);
		}

		internal static Exception TypeIsGeneric(object p0, string paramName, int index)
		{
			return TypeIsGeneric(p0, GetParamName(paramName, index));
		}

		internal static Exception IncorrectNumberOfConstructorArguments()
		{
			return new ArgumentException(Strings.IncorrectNumberOfConstructorArguments);
		}

		internal static Exception ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2, string paramName)
		{
			return new ArgumentException(Strings.ExpressionTypeDoesNotMatchMethodParameter(p0, p1, p2), paramName);
		}

		internal static Exception ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2, string paramName, int index)
		{
			return ExpressionTypeDoesNotMatchMethodParameter(p0, p1, p2, GetParamName(paramName, index));
		}

		internal static Exception ExpressionTypeDoesNotMatchParameter(object p0, object p1, string paramName)
		{
			return new ArgumentException(Strings.ExpressionTypeDoesNotMatchParameter(p0, p1), paramName);
		}

		internal static Exception ExpressionTypeDoesNotMatchParameter(object p0, object p1, string paramName, int index)
		{
			return ExpressionTypeDoesNotMatchParameter(p0, p1, GetParamName(paramName, index));
		}

		internal static Exception IncorrectNumberOfLambdaArguments()
		{
			return new InvalidOperationException(Strings.IncorrectNumberOfLambdaArguments);
		}

		internal static Exception IncorrectNumberOfMethodCallArguments(object p0, string paramName)
		{
			return new ArgumentException(Strings.IncorrectNumberOfMethodCallArguments(p0), paramName);
		}

		internal static Exception ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1, string paramName)
		{
			return new ArgumentException(Strings.ExpressionTypeDoesNotMatchConstructorParameter(p0, p1), paramName);
		}

		internal static Exception ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1, string paramName, int index)
		{
			return ExpressionTypeDoesNotMatchConstructorParameter(p0, p1, GetParamName(paramName, index));
		}

		internal static Exception ExpressionMustBeReadable(string paramName)
		{
			return new ArgumentException(Strings.ExpressionMustBeReadable, paramName);
		}

		internal static Exception ExpressionMustBeReadable(string paramName, int index)
		{
			return ExpressionMustBeReadable(GetParamName(paramName, index));
		}

		internal static Exception InvalidArgumentValue(string paramName)
		{
			return new ArgumentException(Strings.InvalidArgumentValue, paramName);
		}

		internal static Exception NonEmptyCollectionRequired(string paramName)
		{
			return new ArgumentException(Strings.NonEmptyCollectionRequired, paramName);
		}

		internal static Exception InvalidNullValue(Type type, string paramName)
		{
			return new ArgumentException(Strings.InvalidNullValue(type), paramName);
		}

		internal static Exception InvalidTypeException(object value, Type type, string paramName)
		{
			return new ArgumentException(Strings.InvalidObjectType(((object)value?.GetType()) ?? ((object)"null"), type), paramName);
		}

		private static string GetParamName(string paramName, int index)
		{
			if (index >= 0)
			{
				return $"{paramName}[{index}]";
			}
			return paramName;
		}
	}
	internal sealed class ExpressionStringBuilder : ExpressionVisitor
	{
		private readonly StringBuilder _out;

		private Dictionary<object, int> _ids;

		private ExpressionStringBuilder()
		{
			_out = new StringBuilder();
		}

		public override string ToString()
		{
			return _out.ToString();
		}

		private int GetLabelId(LabelTarget label)
		{
			return GetId(label);
		}

		private int GetParamId(ParameterExpression p)
		{
			return GetId(p);
		}

		private int GetId(object o)
		{
			if (_ids == null)
			{
				_ids = new Dictionary<object, int>();
			}
			if (!_ids.TryGetValue(o, out var value))
			{
				value = _ids.Count;
				_ids.Add(o, value);
			}
			return value;
		}

		private void Out(string s)
		{
			_out.Append(s);
		}

		private void Out(char c)
		{
			_out.Append(c);
		}

		internal static string ExpressionToString(Expression node)
		{
			ExpressionStringBuilder expressionStringBuilder = new ExpressionStringBuilder();
			expressionStringBuilder.Visit(node);
			return expressionStringBuilder.ToString();
		}

		internal static string CatchBlockToString(CatchBlock node)
		{
			ExpressionStringBuilder expressionStringBuilder = new ExpressionStringBuilder();
			expressionStringBuilder.VisitCatchBlock(node);
			return expressionStringBuilder.ToString();
		}

		internal static string SwitchCaseToString(SwitchCase node)
		{
			ExpressionStringBuilder expressionStringBuilder = new ExpressionStringBuilder();
			expressionStringBuilder.VisitSwitchCase(node);
			return expressionStringBuilder.ToString();
		}

		internal static string MemberBindingToString(MemberBinding node)
		{
			ExpressionStringBuilder expressionStringBuilder = new ExpressionStringBuilder();
			expressionStringBuilder.VisitMemberBinding(node);
			return expressionStringBuilder.ToString();
		}

		internal static string ElementInitBindingToString(ElementInit node)
		{
			ExpressionStringBuilder expressionStringBuilder = new ExpressionStringBuilder();
			expressionStringBuilder.VisitElementInit(node);
			return expressionStringBuilder.ToString();
		}

		private void VisitExpressions<T>(char open, ReadOnlyCollection<T> expressions, char close) where T : Expression
		{
			VisitExpressions(open, expressions, close, ", ");
		}

		private void VisitExpressions<T>(char open, ReadOnlyCollection<T> expressions, char close, string seperator) where T : Expression
		{
			Out(open);
			if (expressions != null)
			{
				bool flag = true;
				foreach (T expression in expressions)
				{
					if (flag)
					{
						flag = false;
					}
					else
					{
						Out(seperator);
					}
					Visit(expression);
				}
			}
			Out(close);
		}

		protected internal override Expression VisitBinary(BinaryExpression node)
		{
			if (node.NodeType == ExpressionType.ArrayIndex)
			{
				Visit(node.Left);
				Out('[');
				Visit(node.Right);
				Out(']');
			}
			else
			{
				string s;
				switch (node.NodeType)
				{
				case ExpressionType.AndAlso:
					s = "AndAlso";
					break;
				case ExpressionType.OrElse:
					s = "OrElse";
					break;
				case ExpressionType.Assign:
					s = "=";
					break;
				case ExpressionType.Equal:
					s = "==";
					break;
				case ExpressionType.NotEqual:
					s = "!=";
					break;
				case ExpressionType.GreaterThan:
					s = ">";
					break;
				case ExpressionType.LessThan:
					s = "<";
					break;
				case ExpressionType.GreaterThanOrEqual:
					s = ">=";
					break;
				case ExpressionType.LessThanOrEqual:
					s = "<=";
					break;
				case ExpressionType.Add:
				case ExpressionType.AddChecked:
					s = "+";
					break;
				case ExpressionType.AddAssign:
				case ExpressionType.AddAssignChecked:
					s = "+=";
					break;
				case ExpressionType.Subtract:
				case ExpressionType.SubtractChecked:
					s = "-";
					break;
				case ExpressionType.SubtractAssign:
				case ExpressionType.SubtractAssignChecked:
					s = "-=";
					break;
				case ExpressionType.Divide:
					s = "/";
					break;
				case ExpressionType.DivideAssign:
					s = "/=";
					break;
				case ExpressionType.Modulo:
					s = "%";
					break;
				case ExpressionType.ModuloAssign:
					s = "%=";
					break;
				case ExpressionType.Multiply:
				case ExpressionType.MultiplyChecked:
					s = "*";
					break;
				case ExpressionType.MultiplyAssign:
				case ExpressionType.MultiplyAssignChecked:
					s = "*=";
					break;
				case ExpressionType.LeftShift:
					s = "<<";
					break;
				case ExpressionType.LeftShiftAssign:
					s = "<<=";
					break;
				case ExpressionType.RightShift:
					s = ">>";
					break;
				case ExpressionType.RightShiftAssign:
					s = ">>=";
					break;
				case ExpressionType.And:
					s = (IsBool(node) ? "And" : "&");
					break;
				case ExpressionType.AndAssign:
					s = (IsBool(node) ? "&&=" : "&=");
					break;
				case ExpressionType.Or:
					s = (IsBool(node) ? "Or" : "|");
					break;
				case ExpressionType.OrAssign:
					s = (IsBool(node) ? "||=" : "|=");
					break;
				case ExpressionType.ExclusiveOr:
					s = "^";
					break;
				case ExpressionType.ExclusiveOrAssign:
					s = "^=";
					break;
				case ExpressionType.Power:
					s = "**";
					break;
				case ExpressionType.PowerAssign:
					s = "**=";
					break;
				case ExpressionType.Coalesce:
					s = "??";
					break;
				default:
					throw new InvalidOperationException();
				}
				Out('(');
				Visit(node.Left);
				Out(' ');
				Out(s);
				Out(' ');
				Visit(node.Right);
				Out(')');
			}
			return node;
		}

		protected internal override Expression VisitParameter(ParameterExpression node)
		{
			if (node.IsByRef)
			{
				Out("ref ");
			}
			string name = node.Name;
			if (string.IsNullOrEmpty(name))
			{
				Out("Param_" + GetParamId(node));
			}
			else
			{
				Out(name);
			}
			return node;
		}

		protected internal override Expression VisitLambda<T>(Expression<T> node)
		{
			if (node.ParameterCount == 1)
			{
				Visit(node.GetParameter(0));
			}
			else
			{
				Out('(');
				string s = ", ";
				int i = 0;
				for (int parameterCount = node.ParameterCount; i < parameterCount; i++)
				{
					if (i > 0)
					{
						Out(s);
					}
					Visit(node.GetParameter(i));
				}
				Out(')');
			}
			Out(" => ");
			Visit(node.Body);
			return node;
		}

		protected internal override Expression VisitListInit(ListInitExpression node)
		{
			Visit(node.NewExpression);
			Out(" {");
			int i = 0;
			for (int count = node.Initializers.Count; i < count; i++)
			{
				if (i > 0)
				{
					Out(", ");
				}
				VisitElementInit(node.Initializers[i]);
			}
			Out('}');
			return node;
		}

		protected internal override Expression VisitConditional(ConditionalExpression node)
		{
			Out("IIF(");
			Visit(node.Test);
			Out(", ");
			Visit(node.IfTrue);
			Out(", ");
			Visit(node.IfFalse);
			Out(')');
			return node;
		}

		protected internal override Expression VisitConstant(ConstantExpression node)
		{
			if (node.Value != null)
			{
				string text = node.Value.ToString();
				if (node.Value is string)
				{
					Out('"');
					Out(text);
					Out('"');
				}
				else if (text == node.Value.GetType().ToString())
				{
					Out("value(");
					Out(text);
					Out(')');
				}
				else
				{
					Out(text);
				}
			}
			else
			{
				Out("null");
			}
			return node;
		}

		protected internal override Expression VisitDebugInfo(DebugInfoExpression node)
		{
			string s = string.Format(CultureInfo.CurrentCulture, "<DebugInfo({0}: {1}, {2}, {3}, {4})>", node.Document.FileName, node.StartLine, node.StartColumn, node.EndLine, node.EndColumn);
			Out(s);
			return node;
		}

		protected internal override Expression VisitRuntimeVariables(RuntimeVariablesExpression node)
		{
			VisitExpressions('(', node.Variables, ')');
			return node;
		}

		private void OutMember(Expression instance, MemberInfo member)
		{
			if (instance != null)
			{
				Visit(instance);
			}
			else
			{
				Out(member.DeclaringType.Name);
			}
			Out('.');
			Out(member.Name);
		}

		protected internal override Expression VisitMember(MemberExpression node)
		{
			OutMember(node.Expression, node.Member);
			return node;
		}

		protected internal override Expression VisitMemberInit(MemberInitExpression node)
		{
			if (node.NewExpression.ArgumentCount == 0 && node.NewExpression.Type.Name.Contains("<"))
			{
				Out("new");
			}
			else
			{
				Visit(node.NewExpression);
			}
			Out(" {");
			int i = 0;
			for (int count = node.Bindings.Count; i < count; i++)
			{
				MemberBinding node2 = node.Bindings[i];
				if (i > 0)
				{
					Out(", ");
				}
				VisitMemberBinding(node2);
			}
			Out('}');
			return node;
		}

		protected override MemberAssignment VisitMemberAssignment(MemberAssignment assignment)
		{
			Out(assignment.Member.Name);
			Out(" = ");
			Visit(assignment.Expression);
			return assignment;
		}

		protected override MemberListBinding VisitMemberListBinding(MemberListBinding binding)
		{
			Out(binding.Member.Name);
			Out(" = {");
			int i = 0;
			for (int count = binding.Initializers.Count; i < count; i++)
			{
				if (i > 0)
				{
					Out(", ");
				}
				VisitElementInit(binding.Initializers[i]);
			}
			Out('}');
			return binding;
		}

		protected override MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding binding)
		{
			Out(binding.Member.Name);
			Out(" = {");
			int i = 0;
			for (int count = binding.Bindings.Count; i < count; i++)
			{
				if (i > 0)
				{
					Out(", ");
				}
				VisitMemberBinding(binding.Bindings[i]);
			}
			Out('}');
			return binding;
		}

		protected override ElementInit VisitElementInit(ElementInit initializer)
		{
			Out(initializer.AddMethod.ToString());
			string s = ", ";
			Out('(');
			int i = 0;
			for (int argumentCount = initializer.ArgumentCount; i < argumentCount; i++)
			{
				if (i > 0)
				{
					Out(s);
				}
				Visit(initializer.GetArgument(i));
			}
			Out(')');
			return initializer;
		}

		protected internal override Expression VisitInvocation(InvocationExpression node)
		{
			Out("Invoke(");
			Visit(node.Expression);
			string s = ", ";
			int i = 0;
			for (int argumentCount = node.ArgumentCount; i < argumentCount; i++)
			{
				Out(s);
				Visit(node.GetArgument(i));
			}
			Out(')');
			return node;
		}

		protected internal override Expression VisitMethodCall(MethodCallExpression node)
		{
			int num = 0;
			Expression expression = node.Object;
			if (node.Method.GetCustomAttribute(typeof(ExtensionAttribute)) != null)
			{
				num = 1;
				expression = node.GetArgument(0);
			}
			if (expression != null)
			{
				Visit(expression);
				Out('.');
			}
			Out(node.Method.Name);
			Out('(');
			int i = num;
			for (int argumentCount = node.ArgumentCount; i < argumentCount; i++)
			{
				if (i > num)
				{
					Out(", ");
				}
				Visit(node.GetArgument(i));
			}
			Out(')');
			return node;
		}

		protected internal override Expression VisitNewArray(NewArrayExpression node)
		{
			switch (node.NodeType)
			{
			case ExpressionType.NewArrayBounds:
				Out("new ");
				Out(node.Type.ToString());
				VisitExpressions('(', node.Expressions, ')');
				break;
			case ExpressionType.NewArrayInit:
				Out("new [] ");
				VisitExpressions('{', node.Expressions, '}');
				break;
			}
			return node;
		}

		protected internal override Expression VisitNew(NewExpression node)
		{
			Out("new ");
			Out(node.Type.Name);
			Out('(');
			ReadOnlyCollection<MemberInfo> members = node.Members;
			for (int i = 0; i < node.ArgumentCount; i++)
			{
				if (i > 0)
				{
					Out(", ");
				}
				if (members != null)
				{
					string name = members[i].Name;
					Out(name);
					Out(" = ");
				}
				Visit(node.GetArgument(i));
			}
			Out(')');
			return node;
		}

		protected internal override Expression VisitTypeBinary(TypeBinaryExpression node)
		{
			Out('(');
			Visit(node.Expression);
			switch (node.NodeType)
			{
			case ExpressionType.TypeIs:
				Out(" Is ");
				break;
			case ExpressionType.TypeEqual:
				Out(" TypeEqual ");
				break;
			}
			Out(node.TypeOperand.Name);
			Out(')');
			return node;
		}

		protected internal override Expression VisitUnary(UnaryExpression node)
		{
			switch (node.NodeType)
			{
			case ExpressionType.Negate:
			case ExpressionType.NegateChecked:
				Out('-');
				break;
			case ExpressionType.Not:
				Out("Not(");
				break;
			case ExpressionType.IsFalse:
				Out("IsFalse(");
				break;
			case ExpressionType.IsTrue:
				Out("IsTrue(");
				break;
			case ExpressionType.OnesComplement:
				Out("~(");
				break;
			case ExpressionType.ArrayLength:
				Out("ArrayLength(");
				break;
			case ExpressionType.Convert:
				Out("Convert(");
				break;
			case ExpressionType.ConvertChecked:
				Out("ConvertChecked(");
				break;
			case ExpressionType.Throw:
				Out("throw(");
				break;
			case ExpressionType.TypeAs:
				Out('(');
				break;
			case ExpressionType.UnaryPlus:
				Out('+');
				break;
			case ExpressionType.Unbox:
				Out("Unbox(");
				break;
			case ExpressionType.Increment:
				Out("Increment(");
				break;
			case ExpressionType.Decrement:
				Out("Decrement(");
				break;
			case ExpressionType.PreIncrementAssign:
				Out("++");
				break;
			case ExpressionType.PreDecrementAssign:
				Out("--");
				break;
			default:
				throw new InvalidOperationException();
			case ExpressionType.Quote:
			case ExpressionType.PostIncrementAssign:
			case ExpressionType.PostDecrementAssign:
				break;
			}
			Visit(node.Operand);
			switch (node.NodeType)
			{
			case ExpressionType.TypeAs:
				Out(" As ");
				Out(node.Type.Name);
				Out(')');
				break;
			case ExpressionType.Convert:
			case ExpressionType.ConvertChecked:
				Out(", ");
				Out(node.Type.Name);
				Out(')');
				break;
			case ExpressionType.PostIncrementAssign:
				Out("++");
				break;
			case ExpressionType.PostDecrementAssign:
				Out("--");
				break;
			default:
				Out(')');
				break;
			case ExpressionType.Negate:
			case ExpressionType.UnaryPlus:
			case ExpressionType.NegateChecked:
			case ExpressionType.Quote:
			case ExpressionType.PreIncrementAssign:
			case ExpressionType.PreDecrementAssign:
				break;
			}
			return node;
		}

		protected internal override Expression VisitBlock(BlockExpression node)
		{
			Out('{');
			foreach (ParameterExpression variable in node.Variables)
			{
				Out("var ");
				Visit(variable);
				Out(';');
			}
			Out(" ... }");
			return node;
		}

		protected internal override Expression VisitDefault(DefaultExpression node)
		{
			Out("default(");
			Out(node.Type.Name);
			Out(')');
			return node;
		}

		protected internal override Expression VisitLabel(LabelExpression node)
		{
			Out("{ ... } ");
			DumpLabel(node.Target);
			Out(':');
			return node;
		}

		protected internal override Expression VisitGoto(GotoExpression node)
		{
			Out(node.Kind switch
			{
				GotoExpressionKind.Goto => "goto", 
				GotoExpressionKind.Break => "break", 
				GotoExpressionKind.Continue => "continue", 
				GotoExpressionKind.Return => "return", 
				_ => throw new InvalidOperationException(), 
			});
			Out(' ');
			DumpLabel(node.Target);
			if (node.Value != null)
			{
				Out(" (");
				Visit(node.Value);
				Out(")");
			}
			return node;
		}

		protected internal override Expression VisitLoop(LoopExpression node)
		{
			Out("loop { ... }");
			return node;
		}

		protected override SwitchCase VisitSwitchCase(SwitchCase node)
		{
			Out("case ");
			VisitExpressions('(', node.TestValues, ')');
			Out(": ...");
			return node;
		}

		protected internal override Expression VisitSwitch(SwitchExpression node)
		{
			Out("switch ");
			Out('(');
			Visit(node.SwitchValue);
			Out(") { ... }");
			return node;
		}

		protected override CatchBlock VisitCatchBlock(CatchBlock node)
		{
			Out("catch (");
			Out(node.Test.Name);
			if (!string.IsNullOrEmpty(node.Variable?.Name))
			{
				Out(' ');
				Out(node.Variable.Name);
			}
			Out(") { ... }");
			return node;
		}

		protected internal override Expression VisitTry(TryExpression node)
		{
			Out("try { ... }");
			return node;
		}

		protected internal override Expression VisitIndex(IndexExpression node)
		{
			if (node.Object != null)
			{
				Visit(node.Object);
			}
			else
			{
				Out(node.Indexer.DeclaringType.Name);
			}
			if (node.Indexer != null)
			{
				Out('.');
				Out(node.Indexer.Name);
			}
			Out('[');
			int i = 0;
			for (int argumentCount = node.ArgumentCount; i < argumentCount; i++)
			{
				if (i > 0)
				{
					Out(", ");
				}
				Visit(node.GetArgument(i));
			}
			Out(']');
			return node;
		}

		protected internal override Expression VisitExtension(Expression node)
		{
			MethodInfo method = node.GetType().GetMethod("ToString", Type.EmptyTypes);
			if (method.DeclaringType != typeof(Expression) && !method.IsStatic)
			{
				Out(node.ToString());
				return node;
			}
			Out('[');
			Out((node.NodeType == ExpressionType.Extension) ? node.GetType().FullName : node.NodeType.ToString());
			Out(']');
			return node;
		}

		private void DumpLabel(LabelTarget target)
		{
			if (!string.IsNullOrEmpty(target.Name))
			{
				Out(target.Name);
			}
			else
			{
				Out("UnnamedLabel_" + GetLabelId(target));
			}
		}

		private static bool IsBool(Expression node)
		{
			if (!(node.Type == typeof(bool)))
			{
				return node.Type == typeof(bool?);
			}
			return true;
		}
	}
	/// <summary>Describes the node types for the nodes of an expression tree.</summary>
	public enum ExpressionType
	{
		/// <summary>An addition operation, such as a + b, without overflow checking, for numeric operands.</summary>
		Add,
		/// <summary>An addition operation, such as (a + b), with overflow checking, for numeric operands.</summary>
		AddChecked,
		/// <summary>A bitwise or logical <see langword="AND" /> operation, such as (a &amp; b) in C# and (a And b) in Visual Basic.</summary>
		And,
		/// <summary>A conditional <see langword="AND" /> operation that evaluates the second operand only if the first operand evaluates to <see langword="true" />. It corresponds to (a &amp;&amp; b) in C# and (a AndAlso b) in Visual Basic.</summary>
		AndAlso,
		/// <summary>An operation that obtains the length of a one-dimensional array, such as array.Length.</summary>
		ArrayLength,
		/// <summary>An indexing operation in a one-dimensional array, such as array[index] in C# or array(index) in Visual Basic.</summary>
		ArrayIndex,
		/// <summary>A method call, such as in the obj.sampleMethod() expression.</summary>
		Call,
		/// <summary>A node that represents a null coalescing operation, such as (a ?? b) in C# or If(a, b) in Visual Basic.</summary>
		Coalesce,
		/// <summary>A conditional operation, such as a &gt; b ? a : b in C# or If(a &gt; b, a, b) in Visual Basic.</summary>
		Conditional,
		/// <summary>A constant value.</summary>
		Constant,
		/// <summary>A cast or conversion operation, such as (SampleType)obj in C#or CType(obj, SampleType) in Visual Basic. For a numeric conversion, if the converted value is too large for the destination type, no exception is thrown.</summary>
		Convert,
		/// <summary>A cast or conversion operation, such as (SampleType)obj in C#or CType(obj, SampleType) in Visual Basic. For a numeric conversion, if the converted value does not fit the destination type, an exception is thrown.</summary>
		ConvertChecked,
		/// <summary>A division operation, such as (a / b), for numeric operands.</summary>
		Divide,
		/// <summary>A node that represents an equality comparison, such as (a == b) in C# or (a = b) in Visual Basic.</summary>
		Equal,
		/// <summary>A bitwise or logical <see langword="XOR" /> operation, such as (a ^ b) in C# or (a Xor b) in Visual Basic.</summary>
		ExclusiveOr,
		/// <summary>A "greater than" comparison, such as (a &gt; b).</summary>
		GreaterThan,
		/// <summary>A "greater than or equal to" comparison, such as (a &gt;= b).</summary>
		GreaterThanOrEqual,
		/// <summary>An operation that invokes a delegate or lambda expression, such as sampleDelegate.Invoke().</summary>
		Invoke,
		/// <summary>A lambda expression, such as a =&gt; a + a in C# or Function(a) a + a in Visual Basic.</summary>
		Lambda,
		/// <summary>A bitwise left-shift operation, such as (a &lt;&lt; b).</summary>
		LeftShift,
		/// <summary>A "less than" comparison, such as (a &lt; b).</summary>
		LessThan,
		/// <summary>A "less than or equal to" comparison, such as (a &lt;= b).</summary>
		LessThanOrEqual,
		/// <summary>An operation that creates a new <see cref="T:System.Collections.IEnumerable" /> object and initializes it from a list of elements, such as new List&lt;SampleType&gt;(){ a, b, c } in C# or Dim sampleList = { a, b, c } in Visual Basic.</summary>
		ListInit,
		/// <summary>An operation that reads from a field or property, such as obj.SampleProperty.</summary>
		MemberAccess,
		/// <summary>An operation that creates a new object and initializes one or more of its members, such as new Point { X = 1, Y = 2 } in C# or New Point With {.X = 1, .Y = 2} in Visual Basic.</summary>
		MemberInit,
		/// <summary>An arithmetic remainder operation, such as (a % b) in C# or (a Mod b) in Visual Basic.</summary>
		Modulo,
		/// <summary>A multiplication operation, such as (a * b), without overflow checking, for numeric operands.</summary>
		Multiply,
		/// <summary>An multiplication operation, such as (a * b), that has overflow checking, for numeric operands.</summary>
		MultiplyChecked,
		/// <summary>An arithmetic negation operation, such as (-a). The object a should not be modified in place.</summary>
		Negate,
		/// <summary>A unary plus operation, such as (+a). The result of a predefined unary plus operation is the value of the operand, but user-defined implementations might have unusual results.</summary>
		UnaryPlus,
		/// <summary>An arithmetic negation operation, such as (-a), that has overflow checking. The object a should not be modified in place.</summary>
		NegateChecked,
		/// <summary>An operation that calls a constructor to create a new object, such as new SampleType().</summary>
		New,
		/// <summary>An operation that creates a new one-dimensional array and initializes it from a list of elements, such as new SampleType[]{a, b, c} in C# or New SampleType(){a, b, c} in Visual Basic.</summary>
		NewArrayInit,
		/// <summary>An operation that creates a new array, in which the bounds for each dimension are specified, such as new SampleType[dim1, dim2] in C# or New SampleType(dim1, dim2) in Visual Basic.</summary>
		NewArrayBounds,
		/// <summary>A bitwise complement or logical negation operation. In C#, it is equivalent to (~a) for integral types and to (!a) for Boolean values. In Visual Basic, it is equivalent to (Not a). The object a should not be modified in place.</summary>
		Not,
		/// <summary>An inequality comparison, such as (a != b) in C# or (a &lt;&gt; b) in Visual Basic.</summary>
		NotEqual,
		/// <summary>A bitwise or logical <see langword="OR" /> operation, such as (a | b) in C# or (a Or b) in Visual Basic.</summary>
		Or,
		/// <summary>A short-circuiting conditional <see langword="OR" /> operation, such as (a || b) in C# or (a OrElse b) in Visual Basic.</summary>
		OrElse,
		/// <summary>A reference to a parameter or variable that is defined in the context of the expression. For more information, see <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
		Parameter,
		/// <summary>A mathematical operation that raises a number to a power, such as (a ^ b) in Visual Basic.</summary>
		Power,
		/// <summary>An expression that has a constant value of type <see cref="T:System.Linq.Expressions.Expression" />. A <see cref="F:System.Linq.Expressions.ExpressionType.Quote" /> node can contain references to parameters that are defined in the context of the expression it represents.</summary>
		Quote,
		/// <summary>A bitwise right-shift operation, such as (a &gt;&gt; b).</summary>
		RightShift,
		/// <summary>A subtraction operation, such as (a - b), without overflow checking, for numeric operands.</summary>
		Subtract,
		/// <summary>An arithmetic subtraction operation, such as (a - b), that has overflow checking, for numeric operands.</summary>
		SubtractChecked,
		/// <summary>An explicit reference or boxing conversion in which <see langword="null" /> is supplied if the conversion fails, such as (obj as SampleType) in C# or TryCast(obj, SampleType) in Visual Basic.</summary>
		TypeAs,
		/// <summary>A type test, such as obj is SampleType in C# or TypeOf obj is SampleType in Visual Basic.</summary>
		TypeIs,
		/// <summary>An assignment operation, such as (a = b).</summary>
		Assign,
		/// <summary>A block of expressions.</summary>
		Block,
		/// <summary>Debugging information.</summary>
		DebugInfo,
		/// <summary>A unary decrement operation, such as (a - 1) in C# and Visual Basic. The object a should not be modified in place.</summary>
		Decrement,
		/// <summary>A dynamic operation.</summary>
		Dynamic,
		/// <summary>A default value.</summary>
		Default,
		/// <summary>An extension expression.</summary>
		Extension,
		/// <summary>A "go to" expression, such as goto Label in C# or GoTo Label in Visual Basic.</summary>
		Goto,
		/// <summary>A unary increment operation, such as (a + 1) in C# and Visual Basic. The object a should not be modified in place.</summary>
		Increment,
		/// <summary>An index operation or an operation that accesses a property that takes arguments. </summary>
		Index,
		/// <summary>A label.</summary>
		Label,
		/// <summary>A list of run-time variables. For more information, see <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
		RuntimeVariables,
		/// <summary>A loop, such as for or while.</summary>
		Loop,
		/// <summary>A switch operation, such as <see langword="switch" /> in C# or <see langword="Select Case" /> in Visual Basic.</summary>
		Switch,
		/// <summary>An operation that throws an exception, such as throw new Exception().</summary>
		Throw,
		/// <summary>A <see langword="try-catch" /> expression.</summary>
		Try,
		/// <summary>An unbox value type operation, such as <see langword="unbox" /> and <see langword="unbox.any" /> instructions in MSIL. </summary>
		Unbox,
		/// <summary>An addition compound assignment operation, such as (a += b), without overflow checking, for numeric operands.</summary>
		AddAssign,
		/// <summary>A bitwise or logical <see langword="AND" /> compound assignment operation, such as (a &amp;= b) in C#.</summary>
		AndAssign,
		/// <summary>An division compound assignment operation, such as (a /= b), for numeric operands.</summary>
		DivideAssign,
		/// <summary>A bitwise or logical <see langword="XOR" /> compound assignment operation, such as (a ^= b) in C#.</summary>
		ExclusiveOrAssign,
		/// <summary>A bitwise left-shift compound assignment, such as (a &lt;&lt;= b).</summary>
		LeftShiftAssign,
		/// <summary>An arithmetic remainder compound assignment operation, such as (a %= b) in C#.</summary>
		ModuloAssign,
		/// <summary>A multiplication compound assignment operation, such as (a *= b), without overflow checking, for numeric operands.</summary>
		MultiplyAssign,
		/// <summary>A bitwise or logical <see langword="OR" /> compound assignment, such as (a |= b) in C#.</summary>
		OrAssign,
		/// <summary>A compound assignment operation that raises a number to a power, such as (a ^= b) in Visual Basic.</summary>
		PowerAssign,
		/// <summary>A bitwise right-shift compound assignment operation, such as (a &gt;&gt;= b).</summary>
		RightShiftAssign,
		/// <summary>A subtraction compound assignment operation, such as (a -= b), without overflow checking, for numeric operands.</summary>
		SubtractAssign,
		/// <summary>An addition compound assignment operation, such as (a += b), with overflow checking, for numeric operands.</summary>
		AddAssignChecked,
		/// <summary>A multiplication compound assignment operation, such as (a *= b), that has overflow checking, for numeric operands.</summary>
		MultiplyAssignChecked,
		/// <summary>A subtraction compound assignment operation, such as (a -= b), that has overflow checking, for numeric operands.</summary>
		SubtractAssignChecked,
		/// <summary>A unary prefix increment, such as (++a). The object a should be modified in place.</summary>
		PreIncrementAssign,
		/// <summary>A unary prefix decrement, such as (--a). The object a should be modified in place.</summary>
		PreDecrementAssign,
		/// <summary>A unary postfix increment, such as (a++). The object a should be modified in place.</summary>
		PostIncrementAssign,
		/// <summary>A unary postfix decrement, such as (a--). The object a should be modified in place.</summary>
		PostDecrementAssign,
		/// <summary>An exact type test.</summary>
		TypeEqual,
		/// <summary>A ones complement operation, such as (~a) in C#.</summary>
		OnesComplement,
		/// <summary>A <see langword="true" /> condition value.</summary>
		IsTrue,
		/// <summary>A <see langword="false" /> condition value.</summary>
		IsFalse
	}
	/// <summary>Represents a visitor or rewriter for expression trees.</summary>
	public abstract class ExpressionVisitor
	{
		/// <summary>Initializes a new instance of <see cref="T:System.Linq.Expressions.ExpressionVisitor" />.</summary>
		protected ExpressionVisitor()
		{
		}

		/// <summary>Dispatches the expression to one of the more specialized visit methods in this class.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		public virtual Expression Visit(Expression node)
		{
			return node?.Accept(this);
		}

		/// <summary>Dispatches the list of expressions to one of the more specialized visit methods in this class.</summary>
		/// <param name="nodes">The expressions to visit.</param>
		/// <returns>The modified expression list, if any one of the elements were modified; otherwise, returns the original expression list.</returns>
		public ReadOnlyCollection<Expression> Visit(ReadOnlyCollection<Expression> nodes)
		{
			ContractUtils.RequiresNotNull(nodes, "nodes");
			Expression[] array = null;
			int i = 0;
			for (int count = nodes.Count; i < count; i++)
			{
				Expression expression = Visit(nodes[i]);
				if (array != null)
				{
					array[i] = expression;
				}
				else if (expression != nodes[i])
				{
					array = new Expression[count];
					for (int j = 0; j < i; j++)
					{
						array[j] = nodes[j];
					}
					array[i] = expression;
				}
			}
			if (array == null)
			{
				return nodes;
			}
			return new TrueReadOnlyCollection<Expression>(array);
		}

		private Expression[] VisitArguments(IArgumentProvider nodes)
		{
			return ExpressionVisitorUtils.VisitArguments(this, nodes);
		}

		private ParameterExpression[] VisitParameters(IParameterProvider nodes, string callerName)
		{
			return ExpressionVisitorUtils.VisitParameters(this, nodes, callerName);
		}

		/// <summary>Visits all nodes in the collection using a specified element visitor.</summary>
		/// <param name="nodes">The nodes to visit.</param>
		/// <param name="elementVisitor">A delegate that visits a single element, optionally replacing it with a new element.</param>
		/// <typeparam name="T">The type of the nodes.</typeparam>
		/// <returns>The modified node list, if any of the elements were modified; otherwise, returns the original node list.</returns>
		public static ReadOnlyCollection<T> Visit<T>(ReadOnlyCollection<T> nodes, Func<T, T> elementVisitor)
		{
			ContractUtils.RequiresNotNull(nodes, "nodes");
			ContractUtils.RequiresNotNull(elementVisitor, "elementVisitor");
			T[] array = null;
			int i = 0;
			for (int count = nodes.Count; i < count; i++)
			{
				T val = elementVisitor(nodes[i]);
				if (array != null)
				{
					array[i] = val;
				}
				else if ((object)val != (object)nodes[i])
				{
					array = new T[count];
					for (int j = 0; j < i; j++)
					{
						array[j] = nodes[j];
					}
					array[i] = val;
				}
			}
			if (array == null)
			{
				return nodes;
			}
			return new TrueReadOnlyCollection<T>(array);
		}

		/// <summary>Visits an expression, casting the result back to the original expression type.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <param name="callerName">The name of the calling method; used to report to report a better error message.</param>
		/// <typeparam name="T">The type of the expression.</typeparam>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		/// <exception cref="T:System.InvalidOperationException">The visit method for this node returned a different type.</exception>
		public T VisitAndConvert<T>(T node, string callerName) where T : Expression
		{
			if (node == null)
			{
				return null;
			}
			node = Visit(node) as T;
			if (node == null)
			{
				throw Error.MustRewriteToSameNode(callerName, typeof(T), callerName);
			}
			return node;
		}

		/// <summary>Visits an expression, casting the result back to the original expression type.</summary>
		/// <param name="nodes">The expression to visit.</param>
		/// <param name="callerName">The name of the calling method; used to report to report a better error message.</param>
		/// <typeparam name="T">The type of the expression.</typeparam>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		/// <exception cref="T:System.InvalidOperationException">The visit method for this node returned a different type.</exception>
		public ReadOnlyCollection<T> VisitAndConvert<T>(ReadOnlyCollection<T> nodes, string callerName) where T : Expression
		{
			ContractUtils.RequiresNotNull(nodes, "nodes");
			T[] array = null;
			int i = 0;
			for (int count = nodes.Count; i < count; i++)
			{
				if (!(Visit(nodes[i]) is T val))
				{
					throw Error.MustRewriteToSameNode(callerName, typeof(T), callerName);
				}
				if (array != null)
				{
					array[i] = val;
				}
				else if (val != nodes[i])
				{
					array = new T[count];
					for (int j = 0; j < i; j++)
					{
						array[j] = nodes[j];
					}
					array[i] = val;
				}
			}
			if (array == null)
			{
				return nodes;
			}
			return new TrueReadOnlyCollection<T>(array);
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.BinaryExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitBinary(BinaryExpression node)
		{
			return ValidateBinary(node, node.Update(Visit(node.Left), VisitAndConvert(node.Conversion, "VisitBinary"), Visit(node.Right)));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.BlockExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitBlock(BlockExpression node)
		{
			Expression[] array = ExpressionVisitorUtils.VisitBlockExpressions(this, node);
			ReadOnlyCollection<ParameterExpression> readOnlyCollection = VisitAndConvert(node.Variables, "VisitBlock");
			if (readOnlyCollection == node.Variables && array == null)
			{
				return node;
			}
			return node.Rewrite(readOnlyCollection, array);
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.ConditionalExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitConditional(ConditionalExpression node)
		{
			return node.Update(Visit(node.Test), Visit(node.IfTrue), Visit(node.IfFalse));
		}

		/// <summary>Visits the <see cref="T:System.Linq.Expressions.ConstantExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitConstant(ConstantExpression node)
		{
			return node;
		}

		/// <summary>Visits the <see cref="T:System.Linq.Expressions.DebugInfoExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitDebugInfo(DebugInfoExpression node)
		{
			return node;
		}

		/// <summary>Visits the <see cref="T:System.Linq.Expressions.DefaultExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitDefault(DefaultExpression node)
		{
			return node;
		}

		/// <summary>Visits the children of the extension expression.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitExtension(Expression node)
		{
			return node.VisitChildren(this);
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitGoto(GotoExpression node)
		{
			return node.Update(VisitLabelTarget(node.Target), Visit(node.Value));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.InvocationExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitInvocation(InvocationExpression node)
		{
			Expression expression = Visit(node.Expression);
			Expression[] array = VisitArguments(node);
			if (expression == node.Expression && array == null)
			{
				return node;
			}
			return node.Rewrite(expression, array);
		}

		/// <summary>Visits the <see cref="T:System.Linq.Expressions.LabelTarget" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected virtual LabelTarget VisitLabelTarget(LabelTarget node)
		{
			return node;
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.LabelExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitLabel(LabelExpression node)
		{
			return node.Update(VisitLabelTarget(node.Target), Visit(node.DefaultValue));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.Expression`1" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <typeparam name="T">The type of the delegate.</typeparam>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitLambda<T>(Expression<T> node)
		{
			Expression expression = Visit(node.Body);
			ParameterExpression[] array = VisitParameters(node, "VisitLambda");
			if (expression == node.Body && array == null)
			{
				return node;
			}
			return node.Rewrite(expression, array);
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.LoopExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitLoop(LoopExpression node)
		{
			return node.Update(VisitLabelTarget(node.BreakLabel), VisitLabelTarget(node.ContinueLabel), Visit(node.Body));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.MemberExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitMember(MemberExpression node)
		{
			return node.Update(Visit(node.Expression));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.IndexExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitIndex(IndexExpression node)
		{
			Expression expression = Visit(node.Object);
			Expression[] array = VisitArguments(node);
			if (expression == node.Object && array == null)
			{
				return node;
			}
			return node.Rewrite(expression, array);
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.MethodCallExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitMethodCall(MethodCallExpression node)
		{
			Expression expression = Visit(node.Object);
			Expression[] array = VisitArguments(node);
			if (expression == node.Object && array == null)
			{
				return node;
			}
			return node.Rewrite(expression, array);
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.NewArrayExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitNewArray(NewArrayExpression node)
		{
			return node.Update(Visit(node.Expressions));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.NewExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitNew(NewExpression node)
		{
			Expression[] array = VisitArguments(node);
			if (array == null)
			{
				return node;
			}
			return node.Update(array);
		}

		/// <summary>Visits the <see cref="T:System.Linq.Expressions.ParameterExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitParameter(ParameterExpression node)
		{
			return node;
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.RuntimeVariablesExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node)
		{
			return node.Update(VisitAndConvert(node.Variables, "VisitRuntimeVariables"));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected virtual SwitchCase VisitSwitchCase(SwitchCase node)
		{
			return node.Update(Visit(node.TestValues), Visit(node.Body));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitSwitch(SwitchExpression node)
		{
			return ValidateSwitch(node, node.Update(Visit(node.SwitchValue), Visit(node.Cases, VisitSwitchCase), Visit(node.DefaultBody)));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.CatchBlock" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected virtual CatchBlock VisitCatchBlock(CatchBlock node)
		{
			return node.Update(VisitAndConvert(node.Variable, "VisitCatchBlock"), Visit(node.Filter), Visit(node.Body));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.TryExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitTry(TryExpression node)
		{
			return node.Update(Visit(node.Body), Visit(node.Handlers, VisitCatchBlock), Visit(node.Finally), Visit(node.Fault));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.TypeBinaryExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitTypeBinary(TypeBinaryExpression node)
		{
			return node.Update(Visit(node.Expression));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.UnaryExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitUnary(UnaryExpression node)
		{
			return ValidateUnary(node, node.Update(Visit(node.Operand)));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.MemberInitExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitMemberInit(MemberInitExpression node)
		{
			return node.Update(VisitAndConvert(node.NewExpression, "VisitMemberInit"), Visit(node.Bindings, VisitMemberBinding));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.ListInitExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitListInit(ListInitExpression node)
		{
			return node.Update(VisitAndConvert(node.NewExpression, "VisitListInit"), Visit(node.Initializers, VisitElementInit));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.ElementInit" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected virtual ElementInit VisitElementInit(ElementInit node)
		{
			return node.Update(Visit(node.Arguments));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected virtual MemberBinding VisitMemberBinding(MemberBinding node)
		{
			return node.BindingType switch
			{
				MemberBindingType.Assignment => VisitMemberAssignment((MemberAssignment)node), 
				MemberBindingType.MemberBinding => VisitMemberMemberBinding((MemberMemberBinding)node), 
				MemberBindingType.ListBinding => VisitMemberListBinding((MemberListBinding)node), 
				_ => throw Error.UnhandledBindingType(node.BindingType), 
			};
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.MemberAssignment" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected virtual MemberAssignment VisitMemberAssignment(MemberAssignment node)
		{
			return node.Update(Visit(node.Expression));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.MemberMemberBinding" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected virtual MemberMemberBinding VisitMemberMemberBinding(MemberMemberBinding node)
		{
			return node.Update(Visit(node.Bindings, VisitMemberBinding));
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.MemberListBinding" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected virtual MemberListBinding VisitMemberListBinding(MemberListBinding node)
		{
			return node.Update(Visit(node.Initializers, VisitElementInit));
		}

		private static UnaryExpression ValidateUnary(UnaryExpression before, UnaryExpression after)
		{
			if (before != after && before.Method == null)
			{
				if (after.Method != null)
				{
					throw Error.MustRewriteWithoutMethod(after.Method, "VisitUnary");
				}
				if (before.Operand != null && after.Operand != null)
				{
					ValidateChildType(before.Operand.Type, after.Operand.Type, "VisitUnary");
				}
			}
			return after;
		}

		private static BinaryExpression ValidateBinary(BinaryExpression before, BinaryExpression after)
		{
			if (before != after && before.Method == null)
			{
				if (after.Method != null)
				{
					throw Error.MustRewriteWithoutMethod(after.Method, "VisitBinary");
				}
				ValidateChildType(before.Left.Type, after.Left.Type, "VisitBinary");
				ValidateChildType(before.Right.Type, after.Right.Type, "VisitBinary");
			}
			return after;
		}

		private static SwitchExpression ValidateSwitch(SwitchExpression before, SwitchExpression after)
		{
			if (before.Comparison == null && after.Comparison != null)
			{
				throw Error.MustRewriteWithoutMethod(after.Comparison, "VisitSwitch");
			}
			return after;
		}

		private static void ValidateChildType(Type before, Type after, string methodName)
		{
			if (before.IsValueType)
			{
				if (TypeUtils.AreEquivalent(before, after))
				{
					return;
				}
			}
			else if (!after.IsValueType)
			{
				return;
			}
			throw Error.MustRewriteChildToSameType(before, after, methodName);
		}

		/// <summary>Visits the children of the <see cref="T:System.Linq.Expressions.DynamicExpression" />.</summary>
		/// <param name="node">The expression to visit.</param>
		/// <returns>The modified expression, if it or any subexpression was modified; otherwise, returns the original expression.</returns>
		protected internal virtual Expression VisitDynamic(DynamicExpression node)
		{
			Expression[] array = VisitArguments(node);
			if (array == null)
			{
				return node;
			}
			return node.Rewrite(array);
		}
	}
	/// <summary>Specifies what kind of jump this <see cref="T:System.Linq.Expressions.GotoExpression" /> represents.</summary>
	public enum GotoExpressionKind
	{
		/// <summary>A <see cref="T:System.Linq.Expressions.GotoExpression" /> that represents a jump to some location.</summary>
		Goto,
		/// <summary>A <see cref="T:System.Linq.Expressions.GotoExpression" /> that represents a return statement.</summary>
		Return,
		/// <summary>A <see cref="T:System.Linq.Expressions.GotoExpression" /> that represents a break statement.</summary>
		Break,
		/// <summary>A <see cref="T:System.Linq.Expressions.GotoExpression" /> that represents a continue statement.</summary>
		Continue
	}
	/// <summary>Represents an unconditional jump. This includes return statements, break and continue statements, and other jumps.</summary>
	[DebuggerTypeProxy(typeof(GotoExpressionProxy))]
	public sealed class GotoExpression : Expression
	{
		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.GotoExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type { get; }

		/// <summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> that represents this expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Goto;

		/// <summary>The value passed to the target, or null if the target is of type System.Void.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.Expression" /> object representing the value passed to the target or null.</returns>
		public Expression Value { get; }

		/// <summary>The target label where this node jumps to.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.LabelTarget" /> object representing the target label for this node.</returns>
		public LabelTarget Target { get; }

		/// <summary>The kind of the "go to" expression. Serves information purposes only.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.GotoExpressionKind" /> object representing the kind of the "go to" expression.</returns>
		public GotoExpressionKind Kind { get; }

		internal GotoExpression(GotoExpressionKind kind, LabelTarget target, Expression value, Type type)
		{
			Kind = kind;
			Value = value;
			Target = target;
			Type = type;
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitGoto(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="target">The <see cref="P:System.Linq.Expressions.GotoExpression.Target" /> property of the result. </param>
		/// <param name="value">The <see cref="P:System.Linq.Expressions.GotoExpression.Value" /> property of the result. </param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public GotoExpression Update(LabelTarget target, Expression value)
		{
			if (target == Target && value == Value)
			{
				return this;
			}
			return Expression.MakeGoto(Kind, target, value, Type);
		}

		internal GotoExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Provides an internal interface for accessing the arguments of multiple tree nodes (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression, and InexExpression).  You should not use this API.  It is only public due to DLL refactoring and exists only for internal performance optimizations.This enables two optimizations which reduce the size of expression trees.  The first enables the tree nodes to hold onto an IList&lt;T&gt; instead of a ReadOnlyCollection.  IList&lt;T&gt; saves the cost of allocating the ReadOnlyCollection for each node.  The second enables creating specialized subclasses that hold onto a specific number of arguments (for example, Block2, Block3, Block4).  Therefore, these nodes avoid allocating both a ReadOnlyCollection and an array for storing their elements, saving 32 bytes per node.The expression tree nodes continue to expose the original LINQ properties of ReadOnlyCollections.  The nodes do this by re-using a field for storing both the array or an element that would normally be stored in the array.For the array case, the collection is typed to IList&lt;T&gt; instead of ReadOnlyCollection&lt;T&gt;.  When the node is initially constructed it is an array.  When the compiler accesses the members it uses this interface.  Accessing array elements promotes the array to a ReadOnlyCollection.For the object case we store the first argument in a field typed to object.  When the node is initially constructed, the field holds the Expression.  The compiler accesses arguments through this interface, and the accessor for the first argument uses Expression.ReturnObject to return the object that handles the Expression or ReadOnlyCollection case.  When the user accesses the ReadOnlyCollection, then the object field is updated to hold directly onto the ReadOnlyCollection.It is important that the Expressions consistently return the same ReadOnlyCollection.  Otherwise, the re-writer tree walker will break.  It is a breaking change from LINQ v1 to return different ReadOnlyCollections form the same Expression node.  Currently users can rely on object identity to tell if the node has changed.  Storing the ReadOnlyCollection in an overloaded field both reduces memory usage and maintains compatibility for the public API.</summary>
	public interface IArgumentProvider
	{
		/// <summary>Returns the number of arguments to the expression tree node.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.</summary>
		/// <returns>The number of arguments to the expression tree node as <see cref="T:System.Int32" />.</returns>
		int ArgumentCount { get; }

		/// <summary>Returns the argument at index, throwing if index is out of bounds.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.</summary>
		/// <param name="index">The index of the argument.</param>
		/// <returns>The argument at index, throwing if index is out of bounds as <see cref="T:System.Linq.Expressions.Expression" />.</returns>
		Expression GetArgument(int index);
	}
	/// <summary>Provides an internal interface for accessing the arguments of DynamicExpression tree nodes as well as CallSite and Rewriting functionality.  You should not use this API.  It is only public due to DLL refactoring and exists only for internal performance optimizations.</summary>
	public interface IDynamicExpression : IArgumentProvider
	{
		/// <summary>Gets the delegate type used by the CallSite, which is the type of the rules used in the dynamic expressions polymorhphic inline cache. </summary>
		/// <returns>The delegate type used by the CallSite.</returns>
		Type DelegateType { get; }

		/// <summary>Rewrites this node replacing the dynamic expressions arguments with the provided values.  The number of args needs to match the number of the current expression.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.  This helper method allows re-writing of nodes to be independent of the specific implementation class deriving from DynamicExpression that is being used at the call site.</summary>
		/// <param name="args">The arguments used to replace this node.</param>
		/// <returns>The rewritten node, but if no changes were made, then returns the same node.</returns>
		Expression Rewrite(Expression[] args);

		/// <summary>Optionally creates the CallSite and returns the CallSite for the DynamicExpressions polymorphic inline cache.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.</summary>
		/// <returns>The CallSite for the DynamicExpressions polymorphic inline cache.</returns>
		object CreateCallSite();
	}
	internal interface IParameterProvider
	{
		int ParameterCount { get; }

		ParameterExpression GetParameter(int index);
	}
	/// <summary>Represents indexing a property or array.</summary>
	[DebuggerTypeProxy(typeof(IndexExpressionProxy))]
	public sealed class IndexExpression : Expression, IArgumentProvider
	{
		private IReadOnlyList<Expression> _arguments;

		/// <summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> that represents this expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Index;

		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.IndexExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type
		{
			get
			{
				if (Indexer != null)
				{
					return Indexer.PropertyType;
				}
				return Object.Type.GetElementType();
			}
		}

		/// <summary>An object to index.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.Expression" /> representing the object to index.</returns>
		public Expression Object { get; }

		/// <summary>Gets the <see cref="T:System.Reflection.PropertyInfo" /> for the property if the expression represents an indexed property, returns null otherwise.</summary>
		/// <returns>The <see cref="T:System.Reflection.PropertyInfo" /> for the property if the expression represents an indexed property, otherwise null.</returns>
		public PropertyInfo Indexer { get; }

		/// <summary>Gets the arguments that will be used to index the property or array.</summary>
		/// <returns>The read-only collection containing the arguments that will be used to index the property or array.</returns>
		public ReadOnlyCollection<Expression> Arguments => ExpressionUtils.ReturnReadOnly(ref _arguments);

		public int ArgumentCount => _arguments.Count;

		internal IndexExpression(Expression instance, PropertyInfo indexer, IReadOnlyList<Expression> arguments)
		{
			_ = indexer == null;
			Object = instance;
			Indexer = indexer;
			_arguments = arguments;
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="object">The <see cref="P:System.Linq.Expressions.IndexExpression.Object" /> property of the result.</param>
		/// <param name="arguments">The <see cref="P:System.Linq.Expressions.IndexExpression.Arguments" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public IndexExpression Update(Expression @object, IEnumerable<Expression> arguments)
		{
			if (@object == Object && arguments != null && ExpressionUtils.SameElements(ref arguments, Arguments))
			{
				return this;
			}
			return Expression.MakeIndex(@object, Indexer, arguments);
		}

		public Expression GetArgument(int index)
		{
			return _arguments[index];
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitIndex(this);
		}

		internal Expression Rewrite(Expression instance, Expression[] arguments)
		{
			return Expression.MakeIndex(instance, Indexer, arguments ?? _arguments);
		}

		internal IndexExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents an expression that applies a delegate or lambda expression to a list of argument expressions.</summary>
	[DebuggerTypeProxy(typeof(InvocationExpressionProxy))]
	public class InvocationExpression : Expression, IArgumentProvider
	{
		/// <summary>Gets the static type of the expression that this <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.InvocationExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type { get; }

		/// <summary>Returns the node type of this expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> when overriding this method.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> of the expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Invoke;

		/// <summary>Gets the delegate or lambda expression to be applied.</summary>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression" /> that represents the delegate to be applied.</returns>
		public Expression Expression { get; }

		/// <summary>Gets the arguments that the delegate or lambda expression is applied to.</summary>
		/// <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> of <see cref="T:System.Linq.Expressions.Expression" /> objects which represent the arguments that the delegate is applied to.</returns>
		public ReadOnlyCollection<Expression> Arguments => GetOrMakeArguments();

		[ExcludeFromCodeCoverage]
		public virtual int ArgumentCount
		{
			get
			{
				throw ContractUtils.Unreachable;
			}
		}

		internal LambdaExpression LambdaOperand
		{
			get
			{
				if (Expression.NodeType != ExpressionType.Quote)
				{
					return Expression as LambdaExpression;
				}
				return (LambdaExpression)((UnaryExpression)Expression).Operand;
			}
		}

		internal InvocationExpression(Expression expression, Type returnType)
		{
			Expression = expression;
			Type = returnType;
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="expression">The <see cref="P:System.Linq.Expressions.InvocationExpression.Expression" /> property of the result.</param>
		/// <param name="arguments">The <see cref="P:System.Linq.Expressions.InvocationExpression.Arguments" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public InvocationExpression Update(Expression expression, IEnumerable<Expression> arguments)
		{
			if (expression == Expression && arguments != null && ExpressionUtils.SameElements(ref arguments, Arguments))
			{
				return this;
			}
			return Expression.Invoke(expression, arguments);
		}

		[ExcludeFromCodeCoverage]
		internal virtual ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			throw ContractUtils.Unreachable;
		}

		[ExcludeFromCodeCoverage]
		public virtual Expression GetArgument(int index)
		{
			throw ContractUtils.Unreachable;
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitInvocation(this);
		}

		[ExcludeFromCodeCoverage]
		internal virtual InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
		{
			throw ContractUtils.Unreachable;
		}

		internal InvocationExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal sealed class InvocationExpressionN : InvocationExpression
	{
		private IReadOnlyList<Expression> _arguments;

		public override int ArgumentCount => _arguments.Count;

		public InvocationExpressionN(Expression lambda, IReadOnlyList<Expression> arguments, Type returnType)
			: base(lambda, returnType)
		{
			_arguments = arguments;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(ref _arguments);
		}

		public override Expression GetArgument(int index)
		{
			return _arguments[index];
		}

		internal override InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
		{
			return Expression.Invoke(lambda, arguments ?? _arguments);
		}
	}
	internal sealed class InvocationExpression0 : InvocationExpression
	{
		public override int ArgumentCount => 0;

		public InvocationExpression0(Expression lambda, Type returnType)
			: base(lambda, returnType)
		{
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return EmptyReadOnlyCollection<Expression>.Instance;
		}

		public override Expression GetArgument(int index)
		{
			throw new ArgumentOutOfRangeException("index");
		}

		internal override InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
		{
			return Expression.Invoke(lambda);
		}
	}
	internal sealed class InvocationExpression1 : InvocationExpression
	{
		private object _arg0;

		public override int ArgumentCount => 1;

		public InvocationExpression1(Expression lambda, Type returnType, Expression arg0)
			: base(lambda, returnType)
		{
			_arg0 = arg0;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		public override Expression GetArgument(int index)
		{
			if (index == 0)
			{
				return ExpressionUtils.ReturnObject<Expression>(_arg0);
			}
			throw new ArgumentOutOfRangeException("index");
		}

		internal override InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
		{
			if (arguments != null)
			{
				return Expression.Invoke(lambda, arguments[0]);
			}
			return Expression.Invoke(lambda, ExpressionUtils.ReturnObject<Expression>(_arg0));
		}
	}
	internal sealed class InvocationExpression2 : InvocationExpression
	{
		private object _arg0;

		private readonly Expression _arg1;

		public override int ArgumentCount => 2;

		public InvocationExpression2(Expression lambda, Type returnType, Expression arg0, Expression arg1)
			: base(lambda, returnType)
		{
			_arg0 = arg0;
			_arg1 = arg1;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		public override Expression GetArgument(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				_ => throw new ArgumentOutOfRangeException("index"), 
			};
		}

		internal override InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
		{
			if (arguments != null)
			{
				return Expression.Invoke(lambda, arguments[0], arguments[1]);
			}
			return Expression.Invoke(lambda, ExpressionUtils.ReturnObject<Expression>(_arg0), _arg1);
		}
	}
	internal sealed class InvocationExpression3 : InvocationExpression
	{
		private object _arg0;

		private readonly Expression _arg1;

		private readonly Expression _arg2;

		public override int ArgumentCount => 3;

		public InvocationExpression3(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2)
			: base(lambda, returnType)
		{
			_arg0 = arg0;
			_arg1 = arg1;
			_arg2 = arg2;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		public override Expression GetArgument(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				2 => _arg2, 
				_ => throw new ArgumentOutOfRangeException("index"), 
			};
		}

		internal override InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
		{
			if (arguments != null)
			{
				return Expression.Invoke(lambda, arguments[0], arguments[1], arguments[2]);
			}
			return Expression.Invoke(lambda, ExpressionUtils.ReturnObject<Expression>(_arg0), _arg1, _arg2);
		}
	}
	internal sealed class InvocationExpression4 : InvocationExpression
	{
		private object _arg0;

		private readonly Expression _arg1;

		private readonly Expression _arg2;

		private readonly Expression _arg3;

		public override int ArgumentCount => 4;

		public InvocationExpression4(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
			: base(lambda, returnType)
		{
			_arg0 = arg0;
			_arg1 = arg1;
			_arg2 = arg2;
			_arg3 = arg3;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		public override Expression GetArgument(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				2 => _arg2, 
				3 => _arg3, 
				_ => throw new ArgumentOutOfRangeException("index"), 
			};
		}

		internal override InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
		{
			if (arguments != null)
			{
				return Expression.Invoke(lambda, arguments[0], arguments[1], arguments[2], arguments[3]);
			}
			return Expression.Invoke(lambda, ExpressionUtils.ReturnObject<Expression>(_arg0), _arg1, _arg2, _arg3);
		}
	}
	internal sealed class InvocationExpression5 : InvocationExpression
	{
		private object _arg0;

		private readonly Expression _arg1;

		private readonly Expression _arg2;

		private readonly Expression _arg3;

		private readonly Expression _arg4;

		public override int ArgumentCount => 5;

		public InvocationExpression5(Expression lambda, Type returnType, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4)
			: base(lambda, returnType)
		{
			_arg0 = arg0;
			_arg1 = arg1;
			_arg2 = arg2;
			_arg3 = arg3;
			_arg4 = arg4;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		public override Expression GetArgument(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				2 => _arg2, 
				3 => _arg3, 
				4 => _arg4, 
				_ => throw new ArgumentOutOfRangeException("index"), 
			};
		}

		internal override InvocationExpression Rewrite(Expression lambda, Expression[] arguments)
		{
			if (arguments != null)
			{
				return Expression.Invoke(lambda, arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]);
			}
			return Expression.Invoke(lambda, ExpressionUtils.ReturnObject<Expression>(_arg0), _arg1, _arg2, _arg3, _arg4);
		}
	}
	/// <summary>Represents a label, which can be put in any <see cref="T:System.Linq.Expressions.Expression" /> context. If it is jumped to, it will get the value provided by the corresponding <see cref="T:System.Linq.Expressions.GotoExpression" />. Otherwise, it receives the value in <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" />. If the <see cref="T:System.Type" /> equals System.Void, no value should be provided.</summary>
	[DebuggerTypeProxy(typeof(LabelExpressionProxy))]
	public sealed class LabelExpression : Expression
	{
		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.LabelExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type => Target.Type;

		/// <summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> that represents this expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Label;

		/// <summary>The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this label is associated with.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.LabelTarget" /> which this label is associated with.</returns>
		public LabelTarget Target { get; }

		/// <summary>The value of the <see cref="T:System.Linq.Expressions.LabelExpression" /> when the label is reached through regular control flow (for example, is not jumped to).</summary>
		/// <returns>The Expression object representing the value of the <see cref="T:System.Linq.Expressions.LabelExpression" />.</returns>
		public Expression DefaultValue { get; }

		internal LabelExpression(LabelTarget label, Expression defaultValue)
		{
			Target = label;
			DefaultValue = defaultValue;
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitLabel(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="target">The <see cref="P:System.Linq.Expressions.LabelExpression.Target" /> property of the result.</param>
		/// <param name="defaultValue">The <see cref="P:System.Linq.Expressions.LabelExpression.DefaultValue" /> property of the result</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public LabelExpression Update(LabelTarget target, Expression defaultValue)
		{
			if (target == Target && defaultValue == DefaultValue)
			{
				return this;
			}
			return Expression.Label(target, defaultValue);
		}

		internal LabelExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Used to represent the target of a <see cref="T:System.Linq.Expressions.GotoExpression" />.</summary>
	public sealed class LabelTarget
	{
		/// <summary>Gets the name of the label.</summary>
		/// <returns>The name of the label.</returns>
		public string Name { get; }

		/// <summary>The type of value that is passed when jumping to the label (or <see cref="T:System.Void" /> if no value should be passed).</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the type of the value that is passed when jumping to the label or <see cref="T:System.Void" /> if no value should be passed</returns>
		public Type Type { get; }

		internal LabelTarget(Type type, string name)
		{
			Type = type;
			Name = name;
		}

		/// <summary>Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</returns>
		public override string ToString()
		{
			if (!string.IsNullOrEmpty(Name))
			{
				return Name;
			}
			return "UnamedLabel";
		}

		internal LabelTarget()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Describes a lambda expression. This captures a block of code that is similar to a .NET method body.</summary>
	[DebuggerTypeProxy(typeof(LambdaExpressionProxy))]
	public abstract class LambdaExpression : Expression, IParameterProvider
	{
		private readonly Expression _body;

		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.LambdaExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type => TypeCore;

		internal abstract Type TypeCore { get; }

		internal abstract Type PublicType { get; }

		/// <summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> that represents this expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Lambda;

		/// <summary>Gets the parameters of the lambda expression.</summary>
		/// <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> of <see cref="T:System.Linq.Expressions.ParameterExpression" /> objects that represent the parameters of the lambda expression.</returns>
		public ReadOnlyCollection<ParameterExpression> Parameters => GetOrMakeParameters();

		/// <summary>Gets the name of the lambda expression.</summary>
		/// <returns>The name of the lambda expression.</returns>
		public string Name => NameCore;

		internal virtual string NameCore => null;

		/// <summary>Gets the body of the lambda expression.</summary>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression" /> that represents the body of the lambda expression.</returns>
		public Expression Body => _body;

		/// <summary>Gets the return type of the lambda expression.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the type of the lambda expression.</returns>
		public Type ReturnType => Type.GetInvokeMethod().ReturnType;

		/// <summary>Gets the value that indicates if the lambda expression will be compiled with the tail call optimization.</summary>
		/// <returns>True if the lambda expression will be compiled with the tail call optimization, otherwise false.</returns>
		public bool TailCall => TailCallCore;

		internal virtual bool TailCallCore => false;

		[ExcludeFromCodeCoverage]
		int IParameterProvider.ParameterCount => ParameterCount;

		[ExcludeFromCodeCoverage]
		internal virtual int ParameterCount
		{
			get
			{
				throw ContractUtils.Unreachable;
			}
		}

		internal LambdaExpression(Expression body)
		{
			_body = body;
		}

		[ExcludeFromCodeCoverage]
		internal virtual ReadOnlyCollection<ParameterExpression> GetOrMakeParameters()
		{
			throw ContractUtils.Unreachable;
		}

		[ExcludeFromCodeCoverage]
		ParameterExpression IParameterProvider.GetParameter(int index)
		{
			return GetParameter(index);
		}

		[ExcludeFromCodeCoverage]
		internal virtual ParameterExpression GetParameter(int index)
		{
			throw ContractUtils.Unreachable;
		}

		/// <summary>Produces a delegate that represents the lambda expression.</summary>
		/// <returns>A <see cref="T:System.Delegate" /> that contains the compiled version of the lambda expression.</returns>
		public Delegate Compile()
		{
			return Compile(preferInterpretation: false);
		}

		/// <summary>Produces an interpreted or compiled delegate that represents the lambda expression. </summary>
		/// <param name="preferInterpretation">
		///   <see langword="true" /> to indicate that the expression should be compiled to an interpreted form, if it's available; otherwise, <see langword="false" />.</param>
		/// <returns>A delegate that represents the compiled lambda expression described by the <see cref="T:System.Linq.Expressions.LambdaExpression" /> object.</returns>
		public Delegate Compile(bool preferInterpretation)
		{
			return LambdaCompiler.Compile(this);
		}

		/// <summary>Compiles the lambda into a method definition.</summary>
		/// <param name="method">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> which will be used to hold the lambda's IL.</param>
		public void CompileToMethod(MethodBuilder method)
		{
			ContractUtils.RequiresNotNull(method, "method");
			ContractUtils.Requires(method.IsStatic, "method");
			if (method.DeclaringType as TypeBuilder == null)
			{
				throw Error.MethodBuilderDoesNotHaveTypeBuilder();
			}
			LambdaCompiler.Compile(this, method);
		}

		internal abstract LambdaExpression Accept(StackSpiller spiller);

		/// <summary>Produces a delegate that represents the lambda expression.</summary>
		/// <param name="debugInfoGenerator">Debugging information generator used by the compiler to mark sequence points and annotate local variables.</param>
		/// <returns>A delegate containing the compiled version of the lambda.</returns>
		public Delegate Compile(DebugInfoGenerator debugInfoGenerator)
		{
			return Compile();
		}

		/// <summary>Compiles the lambda into a method definition and custom debug information.</summary>
		/// <param name="method">A <see cref="T:System.Reflection.Emit.MethodBuilder" /> which will be used to hold the lambda's IL.</param>
		/// <param name="debugInfoGenerator">Debugging information generator used by the compiler to mark sequence points and annotate local variables.</param>
		public void CompileToMethod(MethodBuilder method, DebugInfoGenerator debugInfoGenerator)
		{
			CompileToMethod(method);
		}

		internal LambdaExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents a strongly typed lambda expression as a data structure in the form of an expression tree. This class cannot be inherited.</summary>
	/// <typeparam name="TDelegate">The type of the delegate that the <see cref="T:System.Linq.Expressions.Expression`1" /> represents.</typeparam>
	public class Expression<TDelegate> : LambdaExpression
	{
		internal sealed override Type TypeCore => typeof(TDelegate);

		internal override Type PublicType => typeof(Expression<TDelegate>);

		internal Expression(Expression body)
			: base(body)
		{
		}

		/// <summary>Compiles the lambda expression described by the expression tree into executable code and produces a delegate that represents the lambda expression.</summary>
		/// <returns>A delegate of type <paramref name="TDelegate" /> that represents the compiled lambda expression described by the <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
		public new TDelegate Compile()
		{
			return Compile(preferInterpretation: false);
		}

		/// <summary>Compiles the lambda expression described by the expression tree into interpreted or compiled code and produces a delegate that represents the lambda expression.</summary>
		/// <param name="preferInterpretation">
		///   <see langword="true" /> to indicate that the expression should be compiled to an interpreted form, if it is available; <see langword="false" /> otherwise.</param>
		/// <returns>A delegate that represents the compiled lambda expression described by the <see cref="T:System.Linq.Expressions.Expression`1" />.</returns>
		public new TDelegate Compile(bool preferInterpretation)
		{
			return (TDelegate)(object)LambdaCompiler.Compile(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="body">The <see cref="P:System.Linq.Expressions.LambdaExpression.Body" /> property of the result.</param>
		/// <param name="parameters">The <see cref="P:System.Linq.Expressions.LambdaExpression.Parameters" />property of the result. </param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public Expression<TDelegate> Update(Expression body, IEnumerable<ParameterExpression> parameters)
		{
			if (body == base.Body)
			{
				ICollection<ParameterExpression> collection;
				if (parameters == null)
				{
					collection = null;
				}
				else
				{
					collection = parameters as ICollection<ParameterExpression>;
					if (collection == null)
					{
						parameters = (collection = parameters.ToReadOnly());
					}
				}
				if (SameParameters(collection))
				{
					return this;
				}
			}
			return Expression.Lambda<TDelegate>(body, base.Name, base.TailCall, parameters);
		}

		[ExcludeFromCodeCoverage]
		internal virtual bool SameParameters(ICollection<ParameterExpression> parameters)
		{
			throw ContractUtils.Unreachable;
		}

		[ExcludeFromCodeCoverage]
		internal virtual Expression<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters)
		{
			throw ContractUtils.Unreachable;
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitLambda(this);
		}

		internal override LambdaExpression Accept(StackSpiller spiller)
		{
			return spiller.Rewrite(this);
		}

		internal static Expression<TDelegate> Create(Expression body, string name, bool tailCall, IReadOnlyList<ParameterExpression> parameters)
		{
			if (name == null && !tailCall)
			{
				return parameters.Count switch
				{
					0 => new Expression0<TDelegate>(body), 
					1 => new Expression1<TDelegate>(body, parameters[0]), 
					2 => new Expression2<TDelegate>(body, parameters[0], parameters[1]), 
					3 => new Expression3<TDelegate>(body, parameters[0], parameters[1], parameters[2]), 
					_ => new ExpressionN<TDelegate>(body, parameters), 
				};
			}
			return new FullExpression<TDelegate>(body, name, tailCall, parameters);
		}

		/// <summary>Produces a delegate that represents the lambda expression.</summary>
		/// <param name="debugInfoGenerator">Debugging information generator used by the compiler to mark sequence points and annotate local variables.</param>
		/// <returns>A delegate containing the compiled version of the lambda.</returns>
		public new TDelegate Compile(DebugInfoGenerator debugInfoGenerator)
		{
			return Compile();
		}

		internal Expression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal sealed class Expression0<TDelegate> : Expression<TDelegate>
	{
		internal override int ParameterCount => 0;

		public Expression0(Expression body)
			: base(body)
		{
		}

		internal override bool SameParameters(ICollection<ParameterExpression> parameters)
		{
			if (parameters != null)
			{
				return parameters.Count == 0;
			}
			return true;
		}

		internal override ParameterExpression GetParameter(int index)
		{
			throw Error.ArgumentOutOfRange("index");
		}

		internal override ReadOnlyCollection<ParameterExpression> GetOrMakeParameters()
		{
			return EmptyReadOnlyCollection<ParameterExpression>.Instance;
		}

		internal override Expression<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters)
		{
			return Expression.Lambda<TDelegate>(body, parameters);
		}
	}
	internal sealed class Expression1<TDelegate> : Expression<TDelegate>
	{
		private object _par0;

		internal override int ParameterCount => 1;

		public Expression1(Expression body, ParameterExpression par0)
			: base(body)
		{
			_par0 = par0;
		}

		internal override ParameterExpression GetParameter(int index)
		{
			if (index == 0)
			{
				return ExpressionUtils.ReturnObject<ParameterExpression>(_par0);
			}
			throw Error.ArgumentOutOfRange("index");
		}

		internal override bool SameParameters(ICollection<ParameterExpression> parameters)
		{
			if (parameters != null && parameters.Count == 1)
			{
				using (IEnumerator<ParameterExpression> enumerator = parameters.GetEnumerator())
				{
					enumerator.MoveNext();
					return enumerator.Current == ExpressionUtils.ReturnObject<ParameterExpression>(_par0);
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<ParameterExpression> GetOrMakeParameters()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _par0);
		}

		internal override Expression<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters)
		{
			if (parameters != null)
			{
				return Expression.Lambda<TDelegate>(body, parameters);
			}
			return Expression.Lambda<TDelegate>(body, new ParameterExpression[1] { ExpressionUtils.ReturnObject<ParameterExpression>(_par0) });
		}
	}
	internal sealed class Expression2<TDelegate> : Expression<TDelegate>
	{
		private object _par0;

		private readonly ParameterExpression _par1;

		internal override int ParameterCount => 2;

		public Expression2(Expression body, ParameterExpression par0, ParameterExpression par1)
			: base(body)
		{
			_par0 = par0;
			_par1 = par1;
		}

		internal override ParameterExpression GetParameter(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<ParameterExpression>(_par0), 
				1 => _par1, 
				_ => throw Error.ArgumentOutOfRange("index"), 
			};
		}

		internal override bool SameParameters(ICollection<ParameterExpression> parameters)
		{
			if (parameters != null && parameters.Count == 2)
			{
				if (_par0 is ReadOnlyCollection<ParameterExpression> current)
				{
					return ExpressionUtils.SameElements(parameters, current);
				}
				using IEnumerator<ParameterExpression> enumerator = parameters.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _par0)
				{
					enumerator.MoveNext();
					return enumerator.Current == _par1;
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<ParameterExpression> GetOrMakeParameters()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _par0);
		}

		internal override Expression<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters)
		{
			if (parameters != null)
			{
				return Expression.Lambda<TDelegate>(body, parameters);
			}
			return Expression.Lambda<TDelegate>(body, new ParameterExpression[2]
			{
				ExpressionUtils.ReturnObject<ParameterExpression>(_par0),
				_par1
			});
		}
	}
	internal sealed class Expression3<TDelegate> : Expression<TDelegate>
	{
		private object _par0;

		private readonly ParameterExpression _par1;

		private readonly ParameterExpression _par2;

		internal override int ParameterCount => 3;

		public Expression3(Expression body, ParameterExpression par0, ParameterExpression par1, ParameterExpression par2)
			: base(body)
		{
			_par0 = par0;
			_par1 = par1;
			_par2 = par2;
		}

		internal override ParameterExpression GetParameter(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<ParameterExpression>(_par0), 
				1 => _par1, 
				2 => _par2, 
				_ => throw Error.ArgumentOutOfRange("index"), 
			};
		}

		internal override bool SameParameters(ICollection<ParameterExpression> parameters)
		{
			if (parameters != null && parameters.Count == 3)
			{
				if (_par0 is ReadOnlyCollection<ParameterExpression> current)
				{
					return ExpressionUtils.SameElements(parameters, current);
				}
				using IEnumerator<ParameterExpression> enumerator = parameters.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _par0)
				{
					enumerator.MoveNext();
					if (enumerator.Current == _par1)
					{
						enumerator.MoveNext();
						return enumerator.Current == _par2;
					}
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<ParameterExpression> GetOrMakeParameters()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _par0);
		}

		internal override Expression<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters)
		{
			if (parameters != null)
			{
				return Expression.Lambda<TDelegate>(body, parameters);
			}
			return Expression.Lambda<TDelegate>(body, new ParameterExpression[3]
			{
				ExpressionUtils.ReturnObject<ParameterExpression>(_par0),
				_par1,
				_par2
			});
		}
	}
	internal class ExpressionN<TDelegate> : Expression<TDelegate>
	{
		private IReadOnlyList<ParameterExpression> _parameters;

		internal override int ParameterCount => _parameters.Count;

		public ExpressionN(Expression body, IReadOnlyList<ParameterExpression> parameters)
			: base(body)
		{
			_parameters = parameters;
		}

		internal override ParameterExpression GetParameter(int index)
		{
			return _parameters[index];
		}

		internal override bool SameParameters(ICollection<ParameterExpression> parameters)
		{
			return ExpressionUtils.SameElements(parameters, _parameters);
		}

		internal override ReadOnlyCollection<ParameterExpression> GetOrMakeParameters()
		{
			return ExpressionUtils.ReturnReadOnly(ref _parameters);
		}

		internal override Expression<TDelegate> Rewrite(Expression body, ParameterExpression[] parameters)
		{
			return Expression.Lambda<TDelegate>(body, base.Name, base.TailCall, parameters ?? _parameters);
		}
	}
	internal sealed class FullExpression<TDelegate> : ExpressionN<TDelegate>
	{
		internal override string NameCore { get; }

		internal override bool TailCallCore { get; }

		public FullExpression(Expression body, string name, bool tailCall, IReadOnlyList<ParameterExpression> parameters)
			: base(body, parameters)
		{
			NameCore = name;
			TailCallCore = tailCall;
		}
	}
	/// <summary>Represents a constructor call that has a collection initializer.</summary>
	[DebuggerTypeProxy(typeof(ListInitExpressionProxy))]
	public sealed class ListInitExpression : Expression
	{
		/// <summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> that represents this expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.ListInit;

		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.ListInitExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type => NewExpression.Type;

		/// <summary>Gets a value that indicates whether the expression tree node can be reduced.</summary>
		/// <returns>True if the node can be reduced, otherwise false.</returns>
		public override bool CanReduce => true;

		/// <summary>Gets the expression that contains a call to the constructor of a collection type.</summary>
		/// <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> that represents the call to the constructor of a collection type.</returns>
		public NewExpression NewExpression { get; }

		/// <summary>Gets the element initializers that are used to initialize a collection.</summary>
		/// <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> of <see cref="T:System.Linq.Expressions.ElementInit" /> objects which represent the elements that are used to initialize the collection.</returns>
		public ReadOnlyCollection<ElementInit> Initializers { get; }

		internal ListInitExpression(NewExpression newExpression, ReadOnlyCollection<ElementInit> initializers)
		{
			NewExpression = newExpression;
			Initializers = initializers;
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitListInit(this);
		}

		/// <summary>Reduces the binary expression node to a simpler expression.</summary>
		/// <returns>The reduced expression.</returns>
		public override Expression Reduce()
		{
			return MemberInitExpression.ReduceListInit(NewExpression, Initializers, keepOnStack: true);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="newExpression">The <see cref="P:System.Linq.Expressions.ListInitExpression.NewExpression" /> property of the result.</param>
		/// <param name="initializers">The <see cref="P:System.Linq.Expressions.ListInitExpression.Initializers" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public ListInitExpression Update(NewExpression newExpression, IEnumerable<ElementInit> initializers)
		{
			if (newExpression == NewExpression && initializers != null && ExpressionUtils.SameElements(ref initializers, Initializers))
			{
				return this;
			}
			return Expression.ListInit(newExpression, initializers);
		}

		internal ListInitExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents an infinite loop. It can be exited with "break".</summary>
	[DebuggerTypeProxy(typeof(LoopExpressionProxy))]
	public sealed class LoopExpression : Expression
	{
		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.LoopExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type
		{
			get
			{
				if (BreakLabel != null)
				{
					return BreakLabel.Type;
				}
				return typeof(void);
			}
		}

		/// <summary>Returns the node type of this expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> when overriding this method.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> of the expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Loop;

		/// <summary>Gets the <see cref="T:System.Linq.Expressions.Expression" /> that is the body of the loop.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.Expression" /> that is the body of the loop.</returns>
		public Expression Body { get; }

		/// <summary>Gets the <see cref="T:System.Linq.Expressions.LabelTarget" /> that is used by the loop body as a break statement target.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.LabelTarget" /> that is used by the loop body as a break statement target.</returns>
		public LabelTarget BreakLabel { get; }

		/// <summary>Gets the <see cref="T:System.Linq.Expressions.LabelTarget" /> that is used by the loop body as a continue statement target.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.LabelTarget" /> that is used by the loop body as a continue statement target.</returns>
		public LabelTarget ContinueLabel { get; }

		internal LoopExpression(Expression body, LabelTarget @break, LabelTarget @continue)
		{
			Body = body;
			BreakLabel = @break;
			ContinueLabel = @continue;
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitLoop(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="breakLabel">The <see cref="P:System.Linq.Expressions.LoopExpression.BreakLabel" /> property of the result.</param>
		/// <param name="continueLabel">The <see cref="P:System.Linq.Expressions.LoopExpression.ContinueLabel" /> property of the result.</param>
		/// <param name="body">The <see cref="P:System.Linq.Expressions.LoopExpression.Body" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public LoopExpression Update(LabelTarget breakLabel, LabelTarget continueLabel, Expression body)
		{
			if (breakLabel == BreakLabel && continueLabel == ContinueLabel && body == Body)
			{
				return this;
			}
			return Expression.Loop(body, breakLabel, continueLabel);
		}

		internal LoopExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents assignment operation for a field or property of an object.</summary>
	public sealed class MemberAssignment : MemberBinding
	{
		private readonly Expression _expression;

		/// <summary>Gets the expression to assign to the field or property.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.Expression" /> that represents the value to assign to the field or property.</returns>
		public Expression Expression => _expression;

		internal MemberAssignment(MemberInfo member, Expression expression)
			: base(MemberBindingType.Assignment, member)
		{
			_expression = expression;
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="expression">The <see cref="P:System.Linq.Expressions.MemberAssignment.Expression" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public MemberAssignment Update(Expression expression)
		{
			if (expression == Expression)
			{
				return this;
			}
			return Expression.Bind(base.Member, expression);
		}

		internal override void ValidateAsDefinedHere(int index)
		{
		}

		internal MemberAssignment()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Describes the binding types that are used in <see cref="T:System.Linq.Expressions.MemberInitExpression" /> objects.</summary>
	public enum MemberBindingType
	{
		/// <summary>A binding that represents initializing a member with the value of an expression.</summary>
		Assignment,
		/// <summary>A binding that represents recursively initializing members of a member.</summary>
		MemberBinding,
		/// <summary>A binding that represents initializing a member of type <see cref="T:System.Collections.IList" /> or <see cref="T:System.Collections.Generic.ICollection`1" /> from a list of elements.</summary>
		ListBinding
	}
	/// <summary>Provides the base class from which the classes that represent bindings that are used to initialize members of a newly created object derive.</summary>
	public abstract class MemberBinding
	{
		/// <summary>Gets the type of binding that is represented.</summary>
		/// <returns>One of the <see cref="T:System.Linq.Expressions.MemberBindingType" /> values.</returns>
		public MemberBindingType BindingType { get; }

		/// <summary>Gets the field or property to be initialized.</summary>
		/// <returns>The <see cref="T:System.Reflection.MemberInfo" /> that represents the field or property to be initialized.</returns>
		public MemberInfo Member { get; }

		/// <summary>Initializes a new instance of the <see cref="T:System.Linq.Expressions.MemberBinding" /> class.</summary>
		/// <param name="type">The <see cref="T:System.Linq.Expressions.MemberBindingType" /> that discriminates the type of binding that is represented.</param>
		/// <param name="member">The <see cref="T:System.Reflection.MemberInfo" /> that represents a field or property to be initialized.</param>
		[Obsolete("Do not use this constructor. It will be removed in future releases.")]
		protected MemberBinding(MemberBindingType type, MemberInfo member)
		{
			BindingType = type;
			Member = member;
		}

		/// <summary>Returns a textual representation of the <see cref="T:System.Linq.Expressions.MemberBinding" />.</summary>
		/// <returns>A textual representation of the <see cref="T:System.Linq.Expressions.MemberBinding" />.</returns>
		public override string ToString()
		{
			return ExpressionStringBuilder.MemberBindingToString(this);
		}

		internal virtual void ValidateAsDefinedHere(int index)
		{
			throw Error.UnknownBindingType(index);
		}
	}
	/// <summary>Represents accessing a field or property.</summary>
	[DebuggerTypeProxy(typeof(MemberExpressionProxy))]
	public class MemberExpression : Expression
	{
		/// <summary>Gets the field or property to be accessed.</summary>
		/// <returns>The <see cref="T:System.Reflection.MemberInfo" /> that represents the field or property to be accessed.</returns>
		public MemberInfo Member => GetMember();

		/// <summary>Gets the containing object of the field or property.</summary>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression" /> that represents the containing object of the field or property.</returns>
		public Expression Expression { get; }

		/// <summary>Returns the node type of this <see cref="P:System.Linq.Expressions.MemberExpression.Expression" />.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> that represents this expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.MemberAccess;

		internal MemberExpression(Expression expression)
		{
			Expression = expression;
		}

		internal static PropertyExpression Make(Expression expression, PropertyInfo property)
		{
			return new PropertyExpression(expression, property);
		}

		internal static FieldExpression Make(Expression expression, FieldInfo field)
		{
			return new FieldExpression(expression, field);
		}

		internal static MemberExpression Make(Expression expression, MemberInfo member)
		{
			FieldInfo fieldInfo = member as FieldInfo;
			if (!(fieldInfo == null))
			{
				return Make(expression, fieldInfo);
			}
			return Make(expression, (PropertyInfo)member);
		}

		[ExcludeFromCodeCoverage]
		internal virtual MemberInfo GetMember()
		{
			throw ContractUtils.Unreachable;
		}

		/// <summary>Dispatches to the specific visit method for this node type. For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
		/// <param name="visitor">The visitor to visit this node with.</param>
		/// <returns>The result of visiting this node.</returns>
		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitMember(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="expression">The <see cref="P:System.Linq.Expressions.MemberExpression.Expression" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public MemberExpression Update(Expression expression)
		{
			if (expression == Expression)
			{
				return this;
			}
			return Expression.MakeMemberAccess(expression, Member);
		}

		internal MemberExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal sealed class FieldExpression : MemberExpression
	{
		private readonly FieldInfo _field;

		public sealed override Type Type => _field.FieldType;

		public FieldExpression(Expression expression, FieldInfo member)
			: base(expression)
		{
			_field = member;
		}

		internal override MemberInfo GetMember()
		{
			return _field;
		}
	}
	internal sealed class PropertyExpression : MemberExpression
	{
		private readonly PropertyInfo _property;

		public sealed override Type Type => _property.PropertyType;

		public PropertyExpression(Expression expression, PropertyInfo member)
			: base(expression)
		{
			_property = member;
		}

		internal override MemberInfo GetMember()
		{
			return _property;
		}
	}
	/// <summary>Represents calling a constructor and initializing one or more members of the new object.</summary>
	[DebuggerTypeProxy(typeof(MemberInitExpressionProxy))]
	public sealed class MemberInitExpression : Expression
	{
		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.MemberInitExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type => NewExpression.Type;

		/// <summary>Gets a value that indicates whether the expression tree node can be reduced.</summary>
		/// <returns>True if the node can be reduced, otherwise false.</returns>
		public override bool CanReduce => true;

		/// <summary>Returns the node type of this Expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> when overriding this method.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> of the expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.MemberInit;

		/// <summary>Gets the expression that represents the constructor call.</summary>
		/// <returns>A <see cref="T:System.Linq.Expressions.NewExpression" /> that represents the constructor call.</returns>
		public NewExpression NewExpression { get; }

		/// <summary>Gets the bindings that describe how to initialize the members of the newly created object.</summary>
		/// <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects which describe how to initialize the members.</returns>
		public ReadOnlyCollection<MemberBinding> Bindings { get; }

		internal MemberInitExpression(NewExpression newExpression, ReadOnlyCollection<MemberBinding> bindings)
		{
			NewExpression = newExpression;
			Bindings = bindings;
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitMemberInit(this);
		}

		/// <summary>Reduces the <see cref="T:System.Linq.Expressions.MemberInitExpression" /> to a simpler expression. </summary>
		/// <returns>The reduced expression.</returns>
		public override Expression Reduce()
		{
			return ReduceMemberInit(NewExpression, Bindings, keepOnStack: true);
		}

		private static Expression ReduceMemberInit(Expression objExpression, ReadOnlyCollection<MemberBinding> bindings, bool keepOnStack)
		{
			ParameterExpression parameterExpression = Expression.Variable(objExpression.Type);
			int count = bindings.Count;
			Expression[] array = new Expression[count + 2];
			array[0] = Expression.Assign(parameterExpression, objExpression);
			for (int i = 0; i < count; i++)
			{
				array[i + 1] = ReduceMemberBinding(parameterExpression, bindings[i]);
			}
			array[count + 1] = (keepOnStack ? ((Expression)parameterExpression) : ((Expression)Utils.Empty));
			return Expression.Block(new ParameterExpression[1] { parameterExpression }, array);
		}

		internal static Expression ReduceListInit(Expression listExpression, ReadOnlyCollection<ElementInit> initializers, bool keepOnStack)
		{
			ParameterExpression parameterExpression = Expression.Variable(listExpression.Type);
			int count = initializers.Count;
			Expression[] array = new Expression[count + 2];
			array[0] = Expression.Assign(parameterExpression, listExpression);
			for (int i = 0; i < count; i++)
			{
				ElementInit elementInit = initializers[i];
				array[i + 1] = Expression.Call(parameterExpression, elementInit.AddMethod, elementInit.Arguments);
			}
			array[count + 1] = (keepOnStack ? ((Expression)parameterExpression) : ((Expression)Utils.Empty));
			return Expression.Block(new ParameterExpression[1] { parameterExpression }, array);
		}

		internal static Expression ReduceMemberBinding(ParameterExpression objVar, MemberBinding binding)
		{
			MemberExpression memberExpression = Expression.MakeMemberAccess(objVar, binding.Member);
			return binding.BindingType switch
			{
				MemberBindingType.Assignment => Expression.Assign(memberExpression, ((MemberAssignment)binding).Expression), 
				MemberBindingType.ListBinding => ReduceListInit(memberExpression, ((MemberListBinding)binding).Initializers, keepOnStack: false), 
				MemberBindingType.MemberBinding => ReduceMemberInit(memberExpression, ((MemberMemberBinding)binding).Bindings, keepOnStack: false), 
				_ => throw ContractUtils.Unreachable, 
			};
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="newExpression">The <see cref="P:System.Linq.Expressions.MemberInitExpression.NewExpression" /> property of the result.</param>
		/// <param name="bindings">The <see cref="P:System.Linq.Expressions.MemberInitExpression.Bindings" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public MemberInitExpression Update(NewExpression newExpression, IEnumerable<MemberBinding> bindings)
		{
			if (newExpression == NewExpression && bindings != null && ExpressionUtils.SameElements(ref bindings, Bindings))
			{
				return this;
			}
			return Expression.MemberInit(newExpression, bindings);
		}

		internal MemberInitExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents initializing the elements of a collection member of a newly created object.</summary>
	public sealed class MemberListBinding : MemberBinding
	{
		/// <summary>Gets the element initializers for initializing a collection member of a newly created object.</summary>
		/// <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> of <see cref="T:System.Linq.Expressions.ElementInit" /> objects to initialize a collection member with.</returns>
		public ReadOnlyCollection<ElementInit> Initializers { get; }

		internal MemberListBinding(MemberInfo member, ReadOnlyCollection<ElementInit> initializers)
			: base(MemberBindingType.ListBinding, member)
		{
			Initializers = initializers;
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="initializers">The <see cref="P:System.Linq.Expressions.MemberListBinding.Initializers" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public MemberListBinding Update(IEnumerable<ElementInit> initializers)
		{
			if (initializers != null && ExpressionUtils.SameElements(ref initializers, Initializers))
			{
				return this;
			}
			return Expression.ListBind(base.Member, initializers);
		}

		internal override void ValidateAsDefinedHere(int index)
		{
		}

		internal MemberListBinding()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents initializing members of a member of a newly created object.</summary>
	public sealed class MemberMemberBinding : MemberBinding
	{
		/// <summary>Gets the bindings that describe how to initialize the members of a member.</summary>
		/// <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> of <see cref="T:System.Linq.Expressions.MemberBinding" /> objects that describe how to initialize the members of the member.</returns>
		public ReadOnlyCollection<MemberBinding> Bindings { get; }

		internal MemberMemberBinding(MemberInfo member, ReadOnlyCollection<MemberBinding> bindings)
			: base(MemberBindingType.MemberBinding, member)
		{
			Bindings = bindings;
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="bindings">The <see cref="P:System.Linq.Expressions.MemberMemberBinding.Bindings" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public MemberMemberBinding Update(IEnumerable<MemberBinding> bindings)
		{
			if (bindings != null && ExpressionUtils.SameElements(ref bindings, Bindings))
			{
				return this;
			}
			return Expression.MemberBind(base.Member, bindings);
		}

		internal override void ValidateAsDefinedHere(int index)
		{
		}

		internal MemberMemberBinding()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents a call to either static or an instance method.</summary>
	[DebuggerTypeProxy(typeof(MethodCallExpressionProxy))]
	public class MethodCallExpression : Expression, IArgumentProvider
	{
		/// <summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> that represents this expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Call;

		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.MethodCallExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type => Method.ReturnType;

		/// <summary>Gets the <see cref="T:System.Reflection.MethodInfo" /> for the method to be called.</summary>
		/// <returns>The <see cref="T:System.Reflection.MethodInfo" /> that represents the called method.</returns>
		public MethodInfo Method { get; }

		/// <summary>Gets the <see cref="T:System.Linq.Expressions.Expression" /> that represents the instance for instance method calls or null for static method calls.</summary>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression" /> that represents the receiving object of the method.</returns>
		public Expression Object => GetInstance();

		/// <summary>Gets a collection of expressions that represent arguments of the called method.</summary>
		/// <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> of <see cref="T:System.Linq.Expressions.Expression" /> objects which represent the arguments to the called method.</returns>
		public ReadOnlyCollection<Expression> Arguments => GetOrMakeArguments();

		[ExcludeFromCodeCoverage]
		public virtual int ArgumentCount
		{
			get
			{
				throw ContractUtils.Unreachable;
			}
		}

		internal MethodCallExpression(MethodInfo method)
		{
			Method = method;
		}

		internal virtual Expression GetInstance()
		{
			return null;
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="object">The <see cref="P:System.Linq.Expressions.MethodCallExpression.Object" /> property of the result.</param>
		/// <param name="arguments">The <see cref="P:System.Linq.Expressions.MethodCallExpression.Arguments" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public MethodCallExpression Update(Expression @object, IEnumerable<Expression> arguments)
		{
			if (@object == Object)
			{
				ICollection<Expression> collection;
				if (arguments == null)
				{
					collection = null;
				}
				else
				{
					collection = arguments as ICollection<Expression>;
					if (collection == null)
					{
						arguments = (collection = arguments.ToReadOnly());
					}
				}
				if (SameArguments(collection))
				{
					return this;
				}
			}
			return Expression.Call(@object, Method, arguments);
		}

		[ExcludeFromCodeCoverage]
		internal virtual bool SameArguments(ICollection<Expression> arguments)
		{
			throw ContractUtils.Unreachable;
		}

		[ExcludeFromCodeCoverage]
		internal virtual ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			throw ContractUtils.Unreachable;
		}

		/// <summary>Dispatches to the specific visit method for this node type. For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
		/// <param name="visitor">The visitor to visit this node with.</param>
		/// <returns>The result of visiting this node.</returns>
		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitMethodCall(this);
		}

		[ExcludeFromCodeCoverage]
		internal virtual MethodCallExpression Rewrite(Expression instance, IReadOnlyList<Expression> args)
		{
			throw ContractUtils.Unreachable;
		}

		[ExcludeFromCodeCoverage]
		public virtual Expression GetArgument(int index)
		{
			throw ContractUtils.Unreachable;
		}

		internal MethodCallExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal class InstanceMethodCallExpression : MethodCallExpression, IArgumentProvider
	{
		private readonly Expression _instance;

		public InstanceMethodCallExpression(MethodInfo method, Expression instance)
			: base(method)
		{
			_instance = instance;
		}

		internal override Expression GetInstance()
		{
			return _instance;
		}
	}
	internal sealed class MethodCallExpressionN : MethodCallExpression, IArgumentProvider
	{
		private IReadOnlyList<Expression> _arguments;

		public override int ArgumentCount => _arguments.Count;

		public MethodCallExpressionN(MethodInfo method, IReadOnlyList<Expression> args)
			: base(method)
		{
			_arguments = args;
		}

		public override Expression GetArgument(int index)
		{
			return _arguments[index];
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(ref _arguments);
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			return ExpressionUtils.SameElements(arguments, _arguments);
		}

		internal override MethodCallExpression Rewrite(Expression instance, IReadOnlyList<Expression> args)
		{
			return Expression.Call(base.Method, args ?? _arguments);
		}
	}
	internal sealed class InstanceMethodCallExpressionN : InstanceMethodCallExpression, IArgumentProvider
	{
		private IReadOnlyList<Expression> _arguments;

		public override int ArgumentCount => _arguments.Count;

		public InstanceMethodCallExpressionN(MethodInfo method, Expression instance, IReadOnlyList<Expression> args)
			: base(method, instance)
		{
			_arguments = args;
		}

		public override Expression GetArgument(int index)
		{
			return _arguments[index];
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			return ExpressionUtils.SameElements(arguments, _arguments);
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(ref _arguments);
		}

		internal override MethodCallExpression Rewrite(Expression instance, IReadOnlyList<Expression> args)
		{
			return Expression.Call(instance, base.Method, args ?? _arguments);
		}
	}
	internal sealed class MethodCallExpression0 : MethodCallExpression, IArgumentProvider
	{
		public override int ArgumentCount => 0;

		public MethodCallExpression0(MethodInfo method)
			: base(method)
		{
		}

		public override Expression GetArgument(int index)
		{
			throw new ArgumentOutOfRangeException("index");
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return EmptyReadOnlyCollection<Expression>.Instance;
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			if (arguments != null)
			{
				return arguments.Count == 0;
			}
			return true;
		}

		internal override MethodCallExpression Rewrite(Expression instance, IReadOnlyList<Expression> args)
		{
			return Expression.Call(base.Method);
		}
	}
	internal sealed class MethodCallExpression1 : MethodCallExpression, IArgumentProvider
	{
		private object _arg0;

		public override int ArgumentCount => 1;

		public MethodCallExpression1(MethodInfo method, Expression arg0)
			: base(method)
		{
			_arg0 = arg0;
		}

		public override Expression GetArgument(int index)
		{
			if (index == 0)
			{
				return ExpressionUtils.ReturnObject<Expression>(_arg0);
			}
			throw new ArgumentOutOfRangeException("index");
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			if (arguments != null && arguments.Count == 1)
			{
				using (IEnumerator<Expression> enumerator = arguments.GetEnumerator())
				{
					enumerator.MoveNext();
					return enumerator.Current == ExpressionUtils.ReturnObject<Expression>(_arg0);
				}
			}
			return false;
		}

		internal override MethodCallExpression Rewrite(Expression instance, IReadOnlyList<Expression> args)
		{
			if (args != null)
			{
				return Expression.Call(base.Method, args[0]);
			}
			return Expression.Call(base.Method, ExpressionUtils.ReturnObject<Expression>(_arg0));
		}
	}
	internal sealed class MethodCallExpression2 : MethodCallExpression, IArgumentProvider
	{
		private object _arg0;

		private readonly Expression _arg1;

		public override int ArgumentCount => 2;

		public MethodCallExpression2(MethodInfo method, Expression arg0, Expression arg1)
			: base(method)
		{
			_arg0 = arg0;
			_arg1 = arg1;
		}

		public override Expression GetArgument(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				_ => throw new ArgumentOutOfRangeException("index"), 
			};
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			if (arguments != null && arguments.Count == 2)
			{
				if (_arg0 is ReadOnlyCollection<Expression> current)
				{
					return ExpressionUtils.SameElements(arguments, current);
				}
				using IEnumerator<Expression> enumerator = arguments.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _arg0)
				{
					enumerator.MoveNext();
					return enumerator.Current == _arg1;
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		internal override MethodCallExpression Rewrite(Expression instance, IReadOnlyList<Expression> args)
		{
			if (args != null)
			{
				return Expression.Call(base.Method, args[0], args[1]);
			}
			return Expression.Call(base.Method, ExpressionUtils.ReturnObject<Expression>(_arg0), _arg1);
		}
	}
	internal sealed class MethodCallExpression3 : MethodCallExpression, IArgumentProvider
	{
		private object _arg0;

		private readonly Expression _arg1;

		private readonly Expression _arg2;

		public override int ArgumentCount => 3;

		public MethodCallExpression3(MethodInfo method, Expression arg0, Expression arg1, Expression arg2)
			: base(method)
		{
			_arg0 = arg0;
			_arg1 = arg1;
			_arg2 = arg2;
		}

		public override Expression GetArgument(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				2 => _arg2, 
				_ => throw new ArgumentOutOfRangeException("index"), 
			};
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			if (arguments != null && arguments.Count == 3)
			{
				if (_arg0 is ReadOnlyCollection<Expression> current)
				{
					return ExpressionUtils.SameElements(arguments, current);
				}
				using IEnumerator<Expression> enumerator = arguments.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _arg0)
				{
					enumerator.MoveNext();
					if (enumerator.Current == _arg1)
					{
						enumerator.MoveNext();
						return enumerator.Current == _arg2;
					}
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		internal override MethodCallExpression Rewrite(Expression instance, IReadOnlyList<Expression> args)
		{
			if (args != null)
			{
				return Expression.Call(base.Method, args[0], args[1], args[2]);
			}
			return Expression.Call(base.Method, ExpressionUtils.ReturnObject<Expression>(_arg0), _arg1, _arg2);
		}
	}
	internal sealed class MethodCallExpression4 : MethodCallExpression, IArgumentProvider
	{
		private object _arg0;

		private readonly Expression _arg1;

		private readonly Expression _arg2;

		private readonly Expression _arg3;

		public override int ArgumentCount => 4;

		public MethodCallExpression4(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3)
			: base(method)
		{
			_arg0 = arg0;
			_arg1 = arg1;
			_arg2 = arg2;
			_arg3 = arg3;
		}

		public override Expression GetArgument(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				2 => _arg2, 
				3 => _arg3, 
				_ => throw new ArgumentOutOfRangeException("index"), 
			};
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			if (arguments != null && arguments.Count == 4)
			{
				if (_arg0 is ReadOnlyCollection<Expression> current)
				{
					return ExpressionUtils.SameElements(arguments, current);
				}
				using IEnumerator<Expression> enumerator = arguments.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _arg0)
				{
					enumerator.MoveNext();
					if (enumerator.Current == _arg1)
					{
						enumerator.MoveNext();
						if (enumerator.Current == _arg2)
						{
							enumerator.MoveNext();
							return enumerator.Current == _arg3;
						}
					}
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		internal override MethodCallExpression Rewrite(Expression instance, IReadOnlyList<Expression> args)
		{
			if (args != null)
			{
				return Expression.Call(base.Method, args[0], args[1], args[2], args[3]);
			}
			return Expression.Call(base.Method, ExpressionUtils.ReturnObject<Expression>(_arg0), _arg1, _arg2, _arg3);
		}
	}
	internal sealed class MethodCallExpression5 : MethodCallExpression, IArgumentProvider
	{
		private object _arg0;

		private readonly Expression _arg1;

		private readonly Expression _arg2;

		private readonly Expression _arg3;

		private readonly Expression _arg4;

		public override int ArgumentCount => 5;

		public MethodCallExpression5(MethodInfo method, Expression arg0, Expression arg1, Expression arg2, Expression arg3, Expression arg4)
			: base(method)
		{
			_arg0 = arg0;
			_arg1 = arg1;
			_arg2 = arg2;
			_arg3 = arg3;
			_arg4 = arg4;
		}

		public override Expression GetArgument(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				2 => _arg2, 
				3 => _arg3, 
				4 => _arg4, 
				_ => throw new ArgumentOutOfRangeException("index"), 
			};
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			if (arguments != null && arguments.Count == 5)
			{
				if (_arg0 is ReadOnlyCollection<Expression> current)
				{
					return ExpressionUtils.SameElements(arguments, current);
				}
				using IEnumerator<Expression> enumerator = arguments.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _arg0)
				{
					enumerator.MoveNext();
					if (enumerator.Current == _arg1)
					{
						enumerator.MoveNext();
						if (enumerator.Current == _arg2)
						{
							enumerator.MoveNext();
							if (enumerator.Current == _arg3)
							{
								enumerator.MoveNext();
								return enumerator.Current == _arg4;
							}
						}
					}
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		internal override MethodCallExpression Rewrite(Expression instance, IReadOnlyList<Expression> args)
		{
			if (args != null)
			{
				return Expression.Call(base.Method, args[0], args[1], args[2], args[3], args[4]);
			}
			return Expression.Call(base.Method, ExpressionUtils.ReturnObject<Expression>(_arg0), _arg1, _arg2, _arg3, _arg4);
		}
	}
	internal sealed class InstanceMethodCallExpression0 : InstanceMethodCallExpression, IArgumentProvider
	{
		public override int ArgumentCount => 0;

		public InstanceMethodCallExpression0(MethodInfo method, Expression instance)
			: base(method, instance)
		{
		}

		public override Expression GetArgument(int index)
		{
			throw new ArgumentOutOfRangeException("index");
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return EmptyReadOnlyCollection<Expression>.Instance;
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			if (arguments != null)
			{
				return arguments.Count == 0;
			}
			return true;
		}

		internal override MethodCallExpression Rewrite(Expression instance, IReadOnlyList<Expression> args)
		{
			return Expression.Call(instance, base.Method);
		}
	}
	internal sealed class InstanceMethodCallExpression1 : InstanceMethodCallExpression, IArgumentProvider
	{
		private object _arg0;

		public override int ArgumentCount => 1;

		public InstanceMethodCallExpression1(MethodInfo method, Expression instance, Expression arg0)
			: base(method, instance)
		{
			_arg0 = arg0;
		}

		public override Expression GetArgument(int index)
		{
			if (index == 0)
			{
				return ExpressionUtils.ReturnObject<Expression>(_arg0);
			}
			throw new ArgumentOutOfRangeException("index");
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			if (arguments != null && arguments.Count == 1)
			{
				using (IEnumerator<Expression> enumerator = arguments.GetEnumerator())
				{
					enumerator.MoveNext();
					return enumerator.Current == ExpressionUtils.ReturnObject<Expression>(_arg0);
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		internal override MethodCallExpression Rewrite(Expression instance, IReadOnlyList<Expression> args)
		{
			if (args != null)
			{
				return Expression.Call(instance, base.Method, args[0]);
			}
			return Expression.Call(instance, base.Method, ExpressionUtils.ReturnObject<Expression>(_arg0));
		}
	}
	internal sealed class InstanceMethodCallExpression2 : InstanceMethodCallExpression, IArgumentProvider
	{
		private object _arg0;

		private readonly Expression _arg1;

		public override int ArgumentCount => 2;

		public InstanceMethodCallExpression2(MethodInfo method, Expression instance, Expression arg0, Expression arg1)
			: base(method, instance)
		{
			_arg0 = arg0;
			_arg1 = arg1;
		}

		public override Expression GetArgument(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				_ => throw new ArgumentOutOfRangeException("index"), 
			};
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			if (arguments != null && arguments.Count == 2)
			{
				if (_arg0 is ReadOnlyCollection<Expression> current)
				{
					return ExpressionUtils.SameElements(arguments, current);
				}
				using IEnumerator<Expression> enumerator = arguments.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _arg0)
				{
					enumerator.MoveNext();
					return enumerator.Current == _arg1;
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		internal override MethodCallExpression Rewrite(Expression instance, IReadOnlyList<Expression> args)
		{
			if (args != null)
			{
				return Expression.Call(instance, base.Method, args[0], args[1]);
			}
			return Expression.Call(instance, base.Method, ExpressionUtils.ReturnObject<Expression>(_arg0), _arg1);
		}
	}
	internal sealed class InstanceMethodCallExpression3 : InstanceMethodCallExpression, IArgumentProvider
	{
		private object _arg0;

		private readonly Expression _arg1;

		private readonly Expression _arg2;

		public override int ArgumentCount => 3;

		public InstanceMethodCallExpression3(MethodInfo method, Expression instance, Expression arg0, Expression arg1, Expression arg2)
			: base(method, instance)
		{
			_arg0 = arg0;
			_arg1 = arg1;
			_arg2 = arg2;
		}

		public override Expression GetArgument(int index)
		{
			return index switch
			{
				0 => ExpressionUtils.ReturnObject<Expression>(_arg0), 
				1 => _arg1, 
				2 => _arg2, 
				_ => throw new ArgumentOutOfRangeException("index"), 
			};
		}

		internal override bool SameArguments(ICollection<Expression> arguments)
		{
			if (arguments != null && arguments.Count == 3)
			{
				if (_arg0 is ReadOnlyCollection<Expression> current)
				{
					return ExpressionUtils.SameElements(arguments, current);
				}
				using IEnumerator<Expression> enumerator = arguments.GetEnumerator();
				enumerator.MoveNext();
				if (enumerator.Current == _arg0)
				{
					enumerator.MoveNext();
					if (enumerator.Current == _arg1)
					{
						enumerator.MoveNext();
						return enumerator.Current == _arg2;
					}
				}
			}
			return false;
		}

		internal override ReadOnlyCollection<Expression> GetOrMakeArguments()
		{
			return ExpressionUtils.ReturnReadOnly(this, ref _arg0);
		}

		internal override MethodCallExpression Rewrite(Expression instance, IReadOnlyList<Expression> args)
		{
			if (args != null)
			{
				return Expression.Call(instance, base.Method, args[0], args[1], args[2]);
			}
			return Expression.Call(instance, base.Method, ExpressionUtils.ReturnObject<Expression>(_arg0), _arg1, _arg2);
		}
	}
	/// <summary>Represents creating a new array and possibly initializing the elements of the new array.</summary>
	[DebuggerTypeProxy(typeof(NewArrayExpressionProxy))]
	public class NewArrayExpression : Expression
	{
		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.NewArrayExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type { get; }

		/// <summary>Gets the bounds of the array if the value of the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayBounds" />, or the values to initialize the elements of the new array if the value of the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property is <see cref="F:System.Linq.Expressions.ExpressionType.NewArrayInit" />.</summary>
		/// <returns>A <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> of <see cref="T:System.Linq.Expressions.Expression" /> objects which represent either the bounds of the array or the initialization values.</returns>
		public ReadOnlyCollection<Expression> Expressions { get; }

		internal NewArrayExpression(Type type, ReadOnlyCollection<Expression> expressions)
		{
			Expressions = expressions;
			Type = type;
		}

		internal static NewArrayExpression Make(ExpressionType nodeType, Type type, ReadOnlyCollection<Expression> expressions)
		{
			if (nodeType == ExpressionType.NewArrayInit)
			{
				return new NewArrayInitExpression(type, expressions);
			}
			return new NewArrayBoundsExpression(type, expressions);
		}

		/// <summary>Dispatches to the specific visit method for this node type. For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
		/// <param name="visitor">The visitor to visit this node with.</param>
		/// <returns>The result of visiting this node.</returns>
		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitNewArray(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="expressions">The <see cref="P:System.Linq.Expressions.NewArrayExpression.Expressions" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public NewArrayExpression Update(IEnumerable<Expression> expressions)
		{
			ContractUtils.RequiresNotNull(expressions, "expressions");
			if (ExpressionUtils.SameElements(ref expressions, Expressions))
			{
				return this;
			}
			if (NodeType != ExpressionType.NewArrayInit)
			{
				return Expression.NewArrayBounds(Type.GetElementType(), expressions);
			}
			return Expression.NewArrayInit(Type.GetElementType(), expressions);
		}

		internal NewArrayExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal sealed class NewArrayInitExpression : NewArrayExpression
	{
		public sealed override ExpressionType NodeType => ExpressionType.NewArrayInit;

		internal NewArrayInitExpression(Type type, ReadOnlyCollection<Expression> expressions)
			: base(type, expressions)
		{
		}
	}
	internal sealed class NewArrayBoundsExpression : NewArrayExpression
	{
		public sealed override ExpressionType NodeType => ExpressionType.NewArrayBounds;

		internal NewArrayBoundsExpression(Type type, ReadOnlyCollection<Expression> expressions)
			: base(type, expressions)
		{
		}
	}
	/// <summary>Represents a constructor call.</summary>
	[DebuggerTypeProxy(typeof(NewExpressionProxy))]
	public class NewExpression : Expression, IArgumentProvider
	{
		private IReadOnlyList<Expression> _arguments;

		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.NewExpression.Type" /> that represents the static type of the expression.</returns>
		public override Type Type => Constructor.DeclaringType;

		/// <summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> that represents this expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.New;

		/// <summary>Gets the called constructor.</summary>
		/// <returns>The <see cref="T:System.Reflection.ConstructorInfo" /> that represents the called constructor.</returns>
		public ConstructorInfo Constructor { get; }

		/// <summary>Gets the arguments to the constructor.</summary>
		/// <returns>A collection of <see cref="T:System.Linq.Expressions.Expression" /> objects that represent the arguments to the constructor.</returns>
		public ReadOnlyCollection<Expression> Arguments => ExpressionUtils.ReturnReadOnly(ref _arguments);

		public int ArgumentCount => _arguments.Count;

		/// <summary>Gets the members that can retrieve the values of the fields that were initialized with constructor arguments.</summary>
		/// <returns>A collection of <see cref="T:System.Reflection.MemberInfo" /> objects that represent the members that can retrieve the values of the fields that were initialized with constructor arguments.</returns>
		public ReadOnlyCollection<MemberInfo> Members { get; }

		internal NewExpression(ConstructorInfo constructor, IReadOnlyList<Expression> arguments, ReadOnlyCollection<MemberInfo> members)
		{
			Constructor = constructor;
			_arguments = arguments;
			Members = members;
		}

		public Expression GetArgument(int index)
		{
			return _arguments[index];
		}

		/// <summary>Dispatches to the specific visit method for this node type. For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
		/// <param name="visitor">The visitor to visit this node with.</param>
		/// <returns>The result of visiting this node.</returns>
		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitNew(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="arguments">The <see cref="P:System.Linq.Expressions.NewExpression.Arguments" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public NewExpression Update(IEnumerable<Expression> arguments)
		{
			if (ExpressionUtils.SameElements(ref arguments, Arguments))
			{
				return this;
			}
			if (Members == null)
			{
				return Expression.New(Constructor, arguments);
			}
			return Expression.New(Constructor, arguments, Members);
		}

		internal NewExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal sealed class NewValueTypeExpression : NewExpression
	{
		public sealed override Type Type { get; }

		internal NewValueTypeExpression(Type type, ReadOnlyCollection<Expression> arguments, ReadOnlyCollection<MemberInfo> members)
			: base(null, arguments, members)
		{
			Type = type;
		}
	}
	/// <summary>Represents a named parameter expression.</summary>
	[DebuggerTypeProxy(typeof(ParameterExpressionProxy))]
	public class ParameterExpression : Expression
	{
		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.ParameterExpression.Type" /> that represents the static type of the expression.</returns>
		public override Type Type => typeof(object);

		/// <summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> that represents this expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Parameter;

		/// <summary>Gets the name of the parameter or variable.</summary>
		/// <returns>A <see cref="T:System.String" /> that contains the name of the parameter.</returns>
		public string Name { get; }

		/// <summary>Indicates that this ParameterExpression is to be treated as a <see langword="ByRef" /> parameter.</summary>
		/// <returns>True if this ParameterExpression is a <see langword="ByRef" /> parameter, otherwise false.</returns>
		public bool IsByRef => GetIsByRef();

		internal ParameterExpression(string name)
		{
			Name = name;
		}

		internal static ParameterExpression Make(Type type, string name, bool isByRef)
		{
			if (isByRef)
			{
				return new ByRefParameterExpression(type, name);
			}
			if (!type.IsEnum)
			{
				switch (type.GetTypeCode())
				{
				case TypeCode.Boolean:
					return new PrimitiveParameterExpression<bool>(name);
				case TypeCode.Byte:
					return new PrimitiveParameterExpression<byte>(name);
				case TypeCode.Char:
					return new PrimitiveParameterExpression<char>(name);
				case TypeCode.DateTime:
					return new PrimitiveParameterExpression<DateTime>(name);
				case TypeCode.Decimal:
					return new PrimitiveParameterExpression<decimal>(name);
				case TypeCode.Double:
					return new PrimitiveParameterExpression<double>(name);
				case TypeCode.Int16:
					return new PrimitiveParameterExpression<short>(name);
				case TypeCode.Int32:
					return new PrimitiveParameterExpression<int>(name);
				case TypeCode.Int64:
					return new PrimitiveParameterExpression<long>(name);
				case TypeCode.Object:
					if (type == typeof(object))
					{
						return new ParameterExpression(name);
					}
					if (type == typeof(Exception))
					{
						return new PrimitiveParameterExpression<Exception>(name);
					}
					if (type == typeof(object[]))
					{
						return new PrimitiveParameterExpression<object[]>(name);
					}
					break;
				case TypeCode.SByte:
					return new PrimitiveParameterExpression<sbyte>(name);
				case TypeCode.Single:
					return new PrimitiveParameterExpression<float>(name);
				case TypeCode.String:
					return new PrimitiveParameterExpression<string>(name);
				case TypeCode.UInt16:
					return new PrimitiveParameterExpression<ushort>(name);
				case TypeCode.UInt32:
					return new PrimitiveParameterExpression<uint>(name);
				case TypeCode.UInt64:
					return new PrimitiveParameterExpression<ulong>(name);
				}
			}
			return new TypedParameterExpression(type, name);
		}

		internal virtual bool GetIsByRef()
		{
			return false;
		}

		/// <summary>Dispatches to the specific visit method for this node type. For example, <see cref="T:System.Linq.Expressions.MethodCallExpression" /> calls the <see cref="M:System.Linq.Expressions.ExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)" />.</summary>
		/// <param name="visitor">The visitor to visit this node with.</param>
		/// <returns>The result of visiting this node.</returns>
		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitParameter(this);
		}

		internal ParameterExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal sealed class ByRefParameterExpression : TypedParameterExpression
	{
		internal ByRefParameterExpression(Type type, string name)
			: base(type, name)
		{
		}

		internal override bool GetIsByRef()
		{
			return true;
		}
	}
	internal class TypedParameterExpression : ParameterExpression
	{
		public sealed override Type Type { get; }

		internal TypedParameterExpression(Type type, string name)
			: base(name)
		{
			Type = type;
		}
	}
	internal sealed class PrimitiveParameterExpression<T> : ParameterExpression
	{
		public sealed override Type Type => typeof(T);

		internal PrimitiveParameterExpression(string name)
			: base(name)
		{
		}
	}
	/// <summary>An expression that provides runtime read/write permission for variables.</summary>
	[DebuggerTypeProxy(typeof(RuntimeVariablesExpressionProxy))]
	public sealed class RuntimeVariablesExpression : Expression
	{
		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type => typeof(IRuntimeVariables);

		/// <summary>Returns the node type of this Expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> when overriding this method.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> of the expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.RuntimeVariables;

		/// <summary>The variables or parameters to which to provide runtime access.</summary>
		/// <returns>The read-only collection containing parameters that will be provided the runtime access.</returns>
		public ReadOnlyCollection<ParameterExpression> Variables { get; }

		internal RuntimeVariablesExpression(ReadOnlyCollection<ParameterExpression> variables)
		{
			Variables = variables;
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitRuntimeVariables(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="variables">The <see cref="P:System.Linq.Expressions.RuntimeVariablesExpression.Variables" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public RuntimeVariablesExpression Update(IEnumerable<ParameterExpression> variables)
		{
			if (variables != null && ExpressionUtils.SameElements(ref variables, Variables))
			{
				return this;
			}
			return Expression.RuntimeVariables(variables);
		}

		internal RuntimeVariablesExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal sealed class StackGuard
	{
		private const int MaxExecutionStackCount = 1024;

		private int _executionStackCount;

		public bool TryEnterOnCurrentStack()
		{
			if (RuntimeHelpers.TryEnsureSufficientExecutionStack())
			{
				return true;
			}
			if (_executionStackCount < 1024)
			{
				return false;
			}
			throw new InsufficientExecutionStackException();
		}

		public void RunOnEmptyStack<T1, T2>(Action<T1, T2> action, T1 arg1, T2 arg2)
		{
			RunOnEmptyStackCore(delegate(object s)
			{
				Tuple<Action<T1, T2>, T1, T2> tuple = (Tuple<Action<T1, T2>, T1, T2>)s;
				tuple.Item1(tuple.Item2, tuple.Item3);
				return (object)null;
			}, Tuple.Create(action, arg1, arg2));
		}

		public void RunOnEmptyStack<T1, T2, T3>(Action<T1, T2, T3> action, T1 arg1, T2 arg2, T3 arg3)
		{
			RunOnEmptyStackCore(delegate(object s)
			{
				Tuple<Action<T1, T2, T3>, T1, T2, T3> tuple = (Tuple<Action<T1, T2, T3>, T1, T2, T3>)s;
				tuple.Item1(tuple.Item2, tuple.Item3, tuple.Item4);
				return (object)null;
			}, Tuple.Create(action, arg1, arg2, arg3));
		}

		public R RunOnEmptyStack<T1, T2, R>(Func<T1, T2, R> action, T1 arg1, T2 arg2)
		{
			return RunOnEmptyStackCore(delegate(object s)
			{
				Tuple<Func<T1, T2, R>, T1, T2> tuple = (Tuple<Func<T1, T2, R>, T1, T2>)s;
				return tuple.Item1(tuple.Item2, tuple.Item3);
			}, Tuple.Create(action, arg1, arg2));
		}

		public R RunOnEmptyStack<T1, T2, T3, R>(Func<T1, T2, T3, R> action, T1 arg1, T2 arg2, T3 arg3)
		{
			return RunOnEmptyStackCore(delegate(object s)
			{
				Tuple<Func<T1, T2, T3, R>, T1, T2, T3> tuple = (Tuple<Func<T1, T2, T3, R>, T1, T2, T3>)s;
				return tuple.Item1(tuple.Item2, tuple.Item3, tuple.Item4);
			}, Tuple.Create(action, arg1, arg2, arg3));
		}

		private R RunOnEmptyStackCore<R>(Func<object, R> action, object state)
		{
			_executionStackCount++;
			try
			{
				Task<R> task = Task.Factory.StartNew(action, state, CancellationToken.None, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);
				TaskAwaiter<R> awaiter = task.GetAwaiter();
				if (!awaiter.IsCompleted)
				{
					((IAsyncResult)task).AsyncWaitHandle.WaitOne();
				}
				return awaiter.GetResult();
			}
			finally
			{
				_executionStackCount--;
			}
		}
	}
	internal static class Strings
	{
		internal static string ReducibleMustOverrideReduce => "reducible nodes must override Expression.Reduce()";

		internal static string MustReduceToDifferent => "node cannot reduce to itself or null";

		internal static string ReducedNotCompatible => "cannot assign from the reduced node type to the original node type";

		internal static string SetterHasNoParams => "Setter must have parameters.";

		internal static string PropertyCannotHaveRefType => "Property cannot have a managed pointer type.";

		internal static string IndexesOfSetGetMustMatch => "Indexing parameters of getter and setter must match.";

		internal static string AccessorsCannotHaveVarArgs => "Accessor method should not have VarArgs.";

		internal static string AccessorsCannotHaveByRefArgs => "Accessor indexes cannot be passed ByRef.";

		internal static string BoundsCannotBeLessThanOne => "Bounds count cannot be less than 1";

		internal static string TypeMustNotBeByRef => "Type must not be ByRef";

		internal static string TypeMustNotBePointer => "Type must not be a pointer type";

		internal static string SetterMustBeVoid => "Setter should have void type.";

		internal static string PropertyTypeMustMatchGetter => "Property type must match the value type of getter";

		internal static string PropertyTypeMustMatchSetter => "Property type must match the value type of setter";

		internal static string BothAccessorsMustBeStatic => "Both accessors must be static.";

		internal static string OnlyStaticFieldsHaveNullInstance => "Static field requires null instance, non-static field requires non-null instance.";

		internal static string OnlyStaticPropertiesHaveNullInstance => "Static property requires null instance, non-static property requires non-null instance.";

		internal static string OnlyStaticMethodsHaveNullInstance => "Static method requires null instance, non-static method requires non-null instance.";

		internal static string PropertyTypeCannotBeVoid => "Property cannot have a void type.";

		internal static string InvalidUnboxType => "Can only unbox from an object or interface type to a value type.";

		internal static string ExpressionMustBeWriteable => "Expression must be writeable";

		internal static string ArgumentMustNotHaveValueType => "Argument must not have a value type.";

		internal static string MustBeReducible => "must be reducible node";

		internal static string AllTestValuesMustHaveSameType => "All test values must have the same type.";

		internal static string AllCaseBodiesMustHaveSameType => "All case bodies and the default body must have the same type.";

		internal static string DefaultBodyMustBeSupplied => "Default body must be supplied if case bodies are not System.Void.";

		internal static string LabelMustBeVoidOrHaveExpression => "Label type must be System.Void if an expression is not supplied";

		internal static string LabelTypeMustBeVoid => "Type must be System.Void for this label argument";

		internal static string QuotedExpressionMustBeLambda => "Quoted expression must be a lambda";

		internal static string CollectionModifiedWhileEnumerating => "Collection was modified; enumeration operation may not execute.";

		internal static string CollectionReadOnly => "Collection is read-only.";

		internal static string ArgCntMustBeGreaterThanNameCnt => "Argument count must be greater than number of named arguments.";

		internal static string BindingCannotBeNull => "Bind cannot return null.";

		internal static string ArgumentTypeCannotBeVoid => "Argument type cannot be void";

		internal static string NoOrInvalidRuleProduced => "No or Invalid rule produced";

		internal static string TypeMustBeDerivedFromSystemDelegate => "Type must be derived from System.Delegate";

		internal static string FirstArgumentMustBeCallSite => "First argument of delegate must be CallSite";

		internal static string StartEndMustBeOrdered => "Start and End must be well ordered";

		internal static string FaultCannotHaveCatchOrFinally => "fault cannot be used with catch or finally clauses";

		internal static string TryMustHaveCatchFinallyOrFault => "try must have at least one catch, finally, or fault clause";

		internal static string BodyOfCatchMustHaveSameTypeAsBodyOfTry => "Body of catch must have the same type as body of try.";

		internal static string ConversionIsNotSupportedForArithmeticTypes => "Conversion is not supported for arithmetic types without operator overloading.";

		internal static string ArgumentMustBeArray => "Argument must be array";

		internal static string ArgumentMustBeBoolean => "Argument must be boolean";

		internal static string ArgumentMustBeFieldInfoOrPropertyInfo => "Argument must be either a FieldInfo or PropertyInfo";

		internal static string ArgumentMustBeFieldInfoOrPropertyInfoOrMethod => "Argument must be either a FieldInfo, PropertyInfo or MethodInfo";

		internal static string ArgumentMustBeInstanceMember => "Argument must be an instance member";

		internal static string ArgumentMustBeInteger => "Argument must be of an integer type";

		internal static string ArgumentMustBeArrayIndexType => "Argument for array index must be of type Int32";

		internal static string ArgumentMustBeSingleDimensionalArrayType => "Argument must be single-dimensional, zero-based array type";

		internal static string ArgumentTypesMustMatch => "Argument types do not match";

		internal static string CoalesceUsedOnNonNullType => "Coalesce used with type that cannot be null";

		internal static string IncorrectNumberOfIndexes => "Incorrect number of indexes";

		internal static string IncorrectNumberOfLambdaDeclarationParameters => "Incorrect number of parameters supplied for lambda declaration";

		internal static string IncorrectNumberOfMembersForGivenConstructor => " Incorrect number of members for constructor";

		internal static string IncorrectNumberOfArgumentsForMembers => "Incorrect number of arguments for the given members ";

		internal static string LambdaTypeMustBeDerivedFromSystemDelegate => "Lambda type parameter must be derived from System.MulticastDelegate";

		internal static string ElementInitializerMethodNotAdd => "Element initializer method must be named 'Add'";

		internal static string ElementInitializerMethodWithZeroArgs => "Element initializer method must have at least 1 parameter";

		internal static string ElementInitializerMethodStatic => "Element initializer method must be an instance method";

		internal static string UnhandledBinding => "Unhandled binding ";

		internal static string UnknownBindingType => "Unknown binding type";

		internal static string IncorrectNumberOfTypeArgsForFunc => "An incorrect number of type arguments were specified for the declaration of a Func type.";

		internal static string IncorrectNumberOfTypeArgsForAction => "An incorrect number of type arguments were specified for the declaration of an Action type.";

		internal static string ArgumentCannotBeOfTypeVoid => "Argument type cannot be System.Void.";

		internal static string ControlCannotLeaveFinally => "Control cannot leave a finally block.";

		internal static string ControlCannotLeaveFilterTest => "Control cannot leave a filter test.";

		internal static string ControlCannotEnterTry => "Control cannot enter a try block.";

		internal static string ControlCannotEnterExpression => "Control cannot enter an expression--only statements can be jumped into.";

		internal static string CannotCompileDynamic => "Dynamic expressions are not supported by CompileToMethod. Instead, create an expression tree that uses System.Runtime.CompilerServices.CallSite.";

		internal static string MethodBuilderDoesNotHaveTypeBuilder => "MethodBuilder does not have a valid TypeBuilder";

		internal static string RethrowRequiresCatch => "Rethrow statement is valid only inside a Catch block.";

		internal static string TryNotAllowedInFilter => "Try expression is not allowed inside a filter body.";

		internal static string NonStaticConstructorRequired => "The constructor should not be static";

		internal static string NonAbstractConstructorRequired => "Can't compile a NewExpression with a constructor declared on an abstract class";

		internal static string ExpressionMustBeReadable => "Expression must be readable";

		internal static string EnumerationIsDone => "Enumeration has either not started or has already finished.";

		internal static string InvalidArgumentValue => "Invalid argument value";

		internal static string NonEmptyCollectionRequired => "Non-empty collection required";

		internal static string IncorrectNumberOfLambdaArguments => "Incorrect number of arguments supplied for lambda invocation";

		internal static string IncorrectNumberOfConstructorArguments => "Incorrect number of arguments for constructor";

		internal static string VariableMustNotBeByRef(object p0, object p1)
		{
			return SR.Format("Variable '{0}' uses unsupported type '{1}'. Reference types are not supported for variables.", p0, p1);
		}

		internal static string AmbiguousMatchInExpandoObject(object p0)
		{
			return SR.Format("More than one key matching '{0}' was found in the ExpandoObject.", p0);
		}

		internal static string SameKeyExistsInExpando(object p0)
		{
			return SR.Format("An element with the same key '{0}' already exists in the ExpandoObject.", p0);
		}

		internal static string KeyDoesNotExistInExpando(object p0)
		{
			return SR.Format("The specified key '{0}' does not exist in the ExpandoObject.", p0);
		}

		internal static string InvalidMetaObjectCreated(object p0)
		{
			return SR.Format("An IDynamicMetaObjectProvider {0} created an invalid DynamicMetaObject instance.", p0);
		}

		internal static string BinderNotCompatibleWithCallSite(object p0, object p1, object p2)
		{
			return SR.Format("The result type '{0}' of the binder '{1}' is not compatible with the result type '{2}' expected by the call site.", p0, p1, p2);
		}

		internal static string DynamicBindingNeedsRestrictions(object p0, object p1)
		{
			return SR.Format("The result of the dynamic binding produced by the object with type '{0}' for the binder '{1}' needs at least one restriction.", p0, p1);
		}

		internal static string DynamicObjectResultNotAssignable(object p0, object p1, object p2, object p3)
		{
			return SR.Format("The result type '{0}' of the dynamic binding produced by the object with type '{1}' for the binder '{2}' is not compatible with the result type '{3}' expected by the call site.", p0, p1, p2, p3);
		}

		internal static string DynamicBinderResultNotAssignable(object p0, object p1, object p2)
		{
			return SR.Format("The result type '{0}' of the dynamic binding produced by binder '{1}' is not compatible with the result type '{2}' expected by the call site.", p0, p1, p2);
		}

		internal static string DuplicateVariable(object p0)
		{
			return SR.Format("Found duplicate parameter '{0}'. Each ParameterExpression in the list must be a unique object.", p0);
		}

		internal static string TypeParameterIsNotDelegate(object p0)
		{
			return SR.Format("Type parameter is {0}. Expected a delegate.", p0);
		}

		internal static string ExtensionNodeMustOverrideProperty(object p0)
		{
			return SR.Format("Extension node must override the property {0}.", p0);
		}

		internal static string UserDefinedOperatorMustBeStatic(object p0)
		{
			return SR.Format("User-defined operator method '{0}' must be static.", p0);
		}

		internal static string UserDefinedOperatorMustNotBeVoid(object p0)
		{
			return SR.Format("User-defined operator method '{0}' must not be void.", p0);
		}

		internal static string CoercionOperatorNotDefined(object p0, object p1)
		{
			return SR.Format("No coercion operator is defined between types '{0}' and '{1}'.", p0, p1);
		}

		internal static string UnaryOperatorNotDefined(object p0, object p1)
		{
			return SR.Format("The unary operator {0} is not defined for the type '{1}'.", p0, p1);
		}

		internal static string BinaryOperatorNotDefined(object p0, object p1, object p2)
		{
			return SR.Format("The binary operator {0} is not defined for the types '{1}' and '{2}'.", p0, p1, p2);
		}

		internal static string ReferenceEqualityNotDefined(object p0, object p1)
		{
			return SR.Format("Reference equality is not defined for the types '{0}' and '{1}'.", p0, p1);
		}

		internal static string OperandTypesDoNotMatchParameters(object p0, object p1)
		{
			return SR.Format("The operands for operator '{0}' do not match the parameters of method '{1}'.", p0, p1);
		}

		internal static string OverloadOperatorTypeDoesNotMatchConversionType(object p0, object p1)
		{
			return SR.Format("The return type of overload method for operator '{0}' does not match the parameter type of conversion method '{1}'.", p0, p1);
		}

		internal static string EqualityMustReturnBoolean(object p0)
		{
			return SR.Format("The user-defined equality method '{0}' must return a boolean value.", p0);
		}

		internal static string CannotAutoInitializeValueTypeElementThroughProperty(object p0)
		{
			return SR.Format("Cannot auto initialize elements of value type through property '{0}', use assignment instead", p0);
		}

		internal static string CannotAutoInitializeValueTypeMemberThroughProperty(object p0)
		{
			return SR.Format("Cannot auto initialize members of value type through property '{0}', use assignment instead", p0);
		}

		internal static string IncorrectTypeForTypeAs(object p0)
		{
			return SR.Format("The type used in TypeAs Expression must be of reference or nullable type, {0} is neither", p0);
		}

		internal static string ExpressionTypeCannotInitializeArrayType(object p0, object p1)
		{
			return SR.Format("An expression of type '{0}' cannot be used to initialize an array of type '{1}'", p0, p1);
		}

		internal static string ArgumentTypeDoesNotMatchMember(object p0, object p1)
		{
			return SR.Format(" Argument type '{0}' does not match the corresponding member type '{1}'", p0, p1);
		}

		internal static string ArgumentMemberNotDeclOnType(object p0, object p1)
		{
			return SR.Format(" The member '{0}' is not declared on type '{1}' being created", p0, p1);
		}

		internal static string ExpressionTypeDoesNotMatchReturn(object p0, object p1)
		{
			return SR.Format("Expression of type '{0}' cannot be used for return type '{1}'", p0, p1);
		}

		internal static string ExpressionTypeDoesNotMatchAssignment(object p0, object p1)
		{
			return SR.Format("Expression of type '{0}' cannot be used for assignment to type '{1}'", p0, p1);
		}

		internal static string ExpressionTypeDoesNotMatchLabel(object p0, object p1)
		{
			return SR.Format("Expression of type '{0}' cannot be used for label of type '{1}'", p0, p1);
		}

		internal static string ExpressionTypeNotInvocable(object p0)
		{
			return SR.Format("Expression of type '{0}' cannot be invoked", p0);
		}

		internal static string FieldNotDefinedForType(object p0, object p1)
		{
			return SR.Format("Field '{0}' is not defined for type '{1}'", p0, p1);
		}

		internal static string InstanceFieldNotDefinedForType(object p0, object p1)
		{
			return SR.Format("Instance field '{0}' is not defined for type '{1}'", p0, p1);
		}

		internal static string FieldInfoNotDefinedForType(object p0, object p1, object p2)
		{
			return SR.Format("Field '{0}.{1}' is not defined for type '{2}'", p0, p1, p2);
		}

		internal static string MemberNotFieldOrProperty(object p0)
		{
			return SR.Format("Member '{0}' not field or property", p0);
		}

		internal static string MethodContainsGenericParameters(object p0)
		{
			return SR.Format("Method {0} contains generic parameters", p0);
		}

		internal static string MethodIsGeneric(object p0)
		{
			return SR.Format("Method {0} is a generic method definition", p0);
		}

		internal static string MethodNotPropertyAccessor(object p0, object p1)
		{
			return SR.Format("The method '{0}.{1}' is not a property accessor", p0, p1);
		}

		internal static string PropertyDoesNotHaveGetter(object p0)
		{
			return SR.Format("The property '{0}' has no 'get' accessor", p0);
		}

		internal static string PropertyDoesNotHaveSetter(object p0)
		{
			return SR.Format("The property '{0}' has no 'set' accessor", p0);
		}

		internal static string PropertyDoesNotHaveAccessor(object p0)
		{
			return SR.Format("The property '{0}' has no 'get' or 'set' accessors", p0);
		}

		internal static string NotAMemberOfType(object p0, object p1)
		{
			return SR.Format("'{0}' is not a member of type '{1}'", p0, p1);
		}

		internal static string NotAMemberOfAnyType(object p0)
		{
			return SR.Format("'{0}' is not a member of any type", p0);
		}

		internal static string ParameterExpressionNotValidAsDelegate(object p0, object p1)
		{
			return SR.Format("ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'", p0, p1);
		}

		internal static string PropertyNotDefinedForType(object p0, object p1)
		{
			return SR.Format("Property '{0}' is not defined for type '{1}'", p0, p1);
		}

		internal static string InstancePropertyNotDefinedForType(object p0, object p1)
		{
			return SR.Format("Instance property '{0}' is not defined for type '{1}'", p0, p1);
		}

		internal static string InstancePropertyWithoutParameterNotDefinedForType(object p0, object p1)
		{
			return SR.Format("Instance property '{0}' that takes no argument is not defined for type '{1}'", p0, p1);
		}

		internal static string InstancePropertyWithSpecifiedParametersNotDefinedForType(object p0, object p1, object p2)
		{
			return SR.Format("Instance property '{0}{1}' is not defined for type '{2}'", p0, p1, p2);
		}

		internal static string InstanceAndMethodTypeMismatch(object p0, object p1, object p2)
		{
			return SR.Format("Method '{0}' declared on type '{1}' cannot be called with instance of type '{2}'", p0, p1, p2);
		}

		internal static string TypeMissingDefaultConstructor(object p0)
		{
			return SR.Format("Type '{0}' does not have a default constructor", p0);
		}

		internal static string ElementInitializerMethodNoRefOutParam(object p0, object p1)
		{
			return SR.Format("Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter", p0, p1);
		}

		internal static string TypeNotIEnumerable(object p0)
		{
			return SR.Format("Type '{0}' is not IEnumerable", p0);
		}

		internal static string UnhandledBinary(object p0)
		{
			return SR.Format("Unhandled binary: {0}", p0);
		}

		internal static string UnhandledBindingType(object p0)
		{
			return SR.Format("Unhandled Binding Type: {0}", p0);
		}

		internal static string UnhandledUnary(object p0)
		{
			return SR.Format("Unhandled unary: {0}", p0);
		}

		internal static string UserDefinedOpMustHaveConsistentTypes(object p0, object p1)
		{
			return SR.Format("The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types.", p0, p1);
		}

		internal static string UserDefinedOpMustHaveValidReturnType(object p0, object p1)
		{
			return SR.Format("The user-defined operator method '{1}' for operator '{0}' must return the same type as its parameter or a derived type.", p0, p1);
		}

		internal static string LogicalOperatorMustHaveBooleanOperators(object p0, object p1)
		{
			return SR.Format("The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators.", p0, p1);
		}

		internal static string MethodWithArgsDoesNotExistOnType(object p0, object p1)
		{
			return SR.Format("No method '{0}' on type '{1}' is compatible with the supplied arguments.", p0, p1);
		}

		internal static string GenericMethodWithArgsDoesNotExistOnType(object p0, object p1)
		{
			return SR.Format("No generic method '{0}' on type '{1}' is compatible with the supplied type arguments and arguments. No type arguments should be provided if the method is non-generic. ", p0, p1);
		}

		internal static string MethodWithMoreThanOneMatch(object p0, object p1)
		{
			return SR.Format("More than one method '{0}' on type '{1}' is compatible with the supplied arguments.", p0, p1);
		}

		internal static string PropertyWithMoreThanOneMatch(object p0, object p1)
		{
			return SR.Format("More than one property '{0}' on type '{1}' is compatible with the supplied arguments.", p0, p1);
		}

		internal static string OutOfRange(object p0, object p1)
		{
			return SR.Format("{0} must be greater than or equal to {1}", p0, p1);
		}

		internal static string LabelTargetAlreadyDefined(object p0)
		{
			return SR.Format("Cannot redefine label '{0}' in an inner block.", p0);
		}

		internal static string LabelTargetUndefined(object p0)
		{
			return SR.Format("Cannot jump to undefined label '{0}'.", p0);
		}

		internal static string AmbiguousJump(object p0)
		{
			return SR.Format("Cannot jump to ambiguous label '{0}'.", p0);
		}

		internal static string NonLocalJumpWithValue(object p0)
		{
			return SR.Format("Cannot jump to non-local label '{0}' with a value. Only jumps to labels defined in outer blocks can pass values.", p0);
		}

		internal static string CannotCompileConstant(object p0)
		{
			return SR.Format("CompileToMethod cannot compile constant '{0}' because it is a non-trivial value, such as a live object. Instead, create an expression tree that can construct this value.", p0);
		}

		internal static string InvalidLvalue(object p0)
		{
			return SR.Format("Invalid lvalue for assignment: {0}.", p0);
		}

		internal static string UndefinedVariable(object p0, object p1, object p2)
		{
			return SR.Format("variable '{0}' of type '{1}' referenced from scope '{2}', but it is not defined", p0, p1, p2);
		}

		internal static string CannotCloseOverByRef(object p0, object p1)
		{
			return SR.Format("Cannot close over byref parameter '{0}' referenced in lambda '{1}'", p0, p1);
		}

		internal static string UnexpectedVarArgsCall(object p0)
		{
			return SR.Format("Unexpected VarArgs call to method '{0}'", p0);
		}

		internal static string MustRewriteToSameNode(object p0, object p1, object p2)
		{
			return SR.Format("When called from '{0}', rewriting a node of type '{1}' must return a non-null value of the same type. Alternatively, override '{2}' and change it to not visit children of this type.", p0, p1, p2);
		}

		internal static string MustRewriteChildToSameType(object p0, object p1, object p2)
		{
			return SR.Format("Rewriting child expression from type '{0}' to type '{1}' is not allowed, because it would change the meaning of the operation. If this is intentional, override '{2}' and change it to allow this rewrite.", p0, p1, p2);
		}

		internal static string MustRewriteWithoutMethod(object p0, object p1)
		{
			return SR.Format("Rewritten expression calls operator method '{0}', but the original node had no operator method. If this is intentional, override '{1}' and change it to allow this rewrite.", p0, p1);
		}

		internal static string TryNotSupportedForMethodsWithRefArgs(object p0)
		{
			return SR.Format("TryExpression is not supported as an argument to method '{0}' because it has an argument with by-ref type. Construct the tree so the TryExpression is not nested inside of this expression.", p0);
		}

		internal static string TryNotSupportedForValueTypeInstances(object p0)
		{
			return SR.Format("TryExpression is not supported as a child expression when accessing a member on type '{0}' because it is a value type. Construct the tree so the TryExpression is not nested inside of this expression.", p0);
		}

		internal static string TestValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1)
		{
			return SR.Format("Test value of type '{0}' cannot be used for the comparison method parameter of type '{1}'", p0, p1);
		}

		internal static string SwitchValueTypeDoesNotMatchComparisonMethodParameter(object p0, object p1)
		{
			return SR.Format("Switch value of type '{0}' cannot be used for the comparison method parameter of type '{1}'", p0, p1);
		}

		internal static string ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1)
		{
			return SR.Format("Expression of type '{0}' cannot be used for constructor parameter of type '{1}'", p0, p1);
		}

		internal static string TypeContainsGenericParameters(object p0)
		{
			return SR.Format("Type {0} contains generic parameters", p0);
		}

		internal static string TypeIsGeneric(object p0)
		{
			return SR.Format("Type {0} is a generic type definition", p0);
		}

		internal static string InvalidNullValue(object p0)
		{
			return SR.Format("The value null is not of type '{0}' and cannot be used in this collection.", p0);
		}

		internal static string InvalidObjectType(object p0, object p1)
		{
			return SR.Format("The value '{0}' is not of type '{1}' and cannot be used in this collection.", p0, p1);
		}

		internal static string ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2)
		{
			return SR.Format("Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'", p0, p1, p2);
		}

		internal static string ExpressionTypeDoesNotMatchParameter(object p0, object p1)
		{
			return SR.Format("Expression of type '{0}' cannot be used for parameter of type '{1}'", p0, p1);
		}

		internal static string IncorrectNumberOfMethodCallArguments(object p0)
		{
			return SR.Format("Incorrect number of arguments supplied for call to method '{0}'", p0);
		}
	}
	/// <summary>Represents one case of a <see cref="T:System.Linq.Expressions.SwitchExpression" />.</summary>
	[DebuggerTypeProxy(typeof(Expression.SwitchCaseProxy))]
	public sealed class SwitchCase
	{
		/// <summary>Gets the values of this case. This case is selected for execution when the <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> matches any of these values.</summary>
		/// <returns>The read-only collection of the values for this case block.</returns>
		public ReadOnlyCollection<Expression> TestValues { get; }

		/// <summary>Gets the body of this case.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.Expression" /> object that represents the body of the case block.</returns>
		public Expression Body { get; }

		internal SwitchCase(Expression body, ReadOnlyCollection<Expression> testValues)
		{
			Body = body;
			TestValues = testValues;
		}

		/// <summary>Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</summary>
		/// <returns>A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.</returns>
		public override string ToString()
		{
			return ExpressionStringBuilder.SwitchCaseToString(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="testValues">The <see cref="P:System.Linq.Expressions.SwitchCase.TestValues" /> property of the result.</param>
		/// <param name="body">The <see cref="P:System.Linq.Expressions.SwitchCase.Body" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public SwitchCase Update(IEnumerable<Expression> testValues, Expression body)
		{
			if (body == Body && testValues != null && ExpressionUtils.SameElements(ref testValues, TestValues))
			{
				return this;
			}
			return Expression.SwitchCase(body, testValues);
		}

		internal SwitchCase()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents a control expression that handles multiple selections by passing control to <see cref="T:System.Linq.Expressions.SwitchCase" />.</summary>
	[DebuggerTypeProxy(typeof(SwitchExpressionProxy))]
	public sealed class SwitchExpression : Expression
	{
		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.SwitchExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type { get; }

		/// <summary>Returns the node type of this Expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> when overriding this method.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> of the expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Switch;

		/// <summary>Gets the test for the switch.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.Expression" /> object representing the test for the switch.</returns>
		public Expression SwitchValue { get; }

		/// <summary>Gets the collection of <see cref="T:System.Linq.Expressions.SwitchCase" /> objects for the switch.</summary>
		/// <returns>The collection of <see cref="T:System.Linq.Expressions.SwitchCase" /> objects.</returns>
		public ReadOnlyCollection<SwitchCase> Cases { get; }

		/// <summary>Gets the test for the switch.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.Expression" /> object representing the test for the switch.</returns>
		public Expression DefaultBody { get; }

		/// <summary>Gets the equality comparison method, if any.</summary>
		/// <returns>The <see cref="T:System.Reflection.MethodInfo" /> object representing the equality comparison method.</returns>
		public MethodInfo Comparison { get; }

		internal bool IsLifted
		{
			get
			{
				if (SwitchValue.Type.IsNullableType())
				{
					if (!(Comparison == null))
					{
						return !TypeUtils.AreEquivalent(SwitchValue.Type, Comparison.GetParametersCached()[0].ParameterType.GetNonRefType());
					}
					return true;
				}
				return false;
			}
		}

		internal SwitchExpression(Type type, Expression switchValue, Expression defaultBody, MethodInfo comparison, ReadOnlyCollection<SwitchCase> cases)
		{
			Type = type;
			SwitchValue = switchValue;
			DefaultBody = defaultBody;
			Comparison = comparison;
			Cases = cases;
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitSwitch(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="switchValue">The <see cref="P:System.Linq.Expressions.SwitchExpression.SwitchValue" /> property of the result.</param>
		/// <param name="cases">The <see cref="P:System.Linq.Expressions.SwitchExpression.Cases" /> property of the result.</param>
		/// <param name="defaultBody">The <see cref="P:System.Linq.Expressions.SwitchExpression.DefaultBody" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public SwitchExpression Update(Expression switchValue, IEnumerable<SwitchCase> cases, Expression defaultBody)
		{
			if (((switchValue == SwitchValue) & (defaultBody == DefaultBody)) && cases != null && ExpressionUtils.SameElements(ref cases, Cases))
			{
				return this;
			}
			return Expression.Switch(Type, switchValue, defaultBody, Comparison, cases);
		}

		internal SwitchExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Stores information necessary to emit debugging symbol information for a source file, in particular the file name and unique language identifier.</summary>
	public class SymbolDocumentInfo
	{
		internal static readonly Guid DocumentType_Text = new Guid(1518771467, 26129, 4563, 189, 42, 0, 0, 248, 8, 73, 189);

		/// <summary>The source file name.</summary>
		/// <returns>The string representing the source file name.</returns>
		public string FileName { get; }

		/// <summary>Returns the language's unique identifier, if any.</summary>
		/// <returns>The language's unique identifier</returns>
		public virtual Guid Language => Guid.Empty;

		/// <summary>Returns the language vendor's unique identifier, if any.</summary>
		/// <returns>The language vendor's unique identifier.</returns>
		public virtual Guid LanguageVendor => Guid.Empty;

		/// <summary>Returns the document type's unique identifier, if any. Defaults to the GUID for a text file.</summary>
		/// <returns>The document type's unique identifier.</returns>
		public virtual Guid DocumentType => DocumentType_Text;

		internal SymbolDocumentInfo(string fileName)
		{
			ContractUtils.RequiresNotNull(fileName, "fileName");
			FileName = fileName;
		}

		internal SymbolDocumentInfo()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal sealed class SymbolDocumentWithGuids : SymbolDocumentInfo
	{
		public override Guid Language { get; }

		public override Guid LanguageVendor { get; }

		public override Guid DocumentType { get; }

		internal SymbolDocumentWithGuids(string fileName, ref Guid language)
			: base(fileName)
		{
			Language = language;
			DocumentType = SymbolDocumentInfo.DocumentType_Text;
		}

		internal SymbolDocumentWithGuids(string fileName, ref Guid language, ref Guid vendor)
			: base(fileName)
		{
			Language = language;
			LanguageVendor = vendor;
			DocumentType = SymbolDocumentInfo.DocumentType_Text;
		}

		internal SymbolDocumentWithGuids(string fileName, ref Guid language, ref Guid vendor, ref Guid documentType)
			: base(fileName)
		{
			Language = language;
			LanguageVendor = vendor;
			DocumentType = documentType;
		}
	}
	/// <summary>Represents a try/catch/finally/fault block.</summary>
	[DebuggerTypeProxy(typeof(TryExpressionProxy))]
	public sealed class TryExpression : Expression
	{
		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.TryExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type { get; }

		/// <summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> that represents this expression.</returns>
		public sealed override ExpressionType NodeType => ExpressionType.Try;

		/// <summary>Gets the <see cref="T:System.Linq.Expressions.Expression" /> representing the body of the try block.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.Expression" /> representing the body of the try block.</returns>
		public Expression Body { get; }

		/// <summary>Gets the collection of <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions associated with the try block.</summary>
		/// <returns>The collection of <see cref="T:System.Linq.Expressions.CatchBlock" /> expressions associated with the try block.</returns>
		public ReadOnlyCollection<CatchBlock> Handlers { get; }

		/// <summary>Gets the <see cref="T:System.Linq.Expressions.Expression" /> representing the finally block.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.Expression" /> representing the finally block.</returns>
		public Expression Finally { get; }

		/// <summary>Gets the <see cref="T:System.Linq.Expressions.Expression" /> representing the fault block.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.Expression" /> representing the fault block.</returns>
		public Expression Fault { get; }

		internal TryExpression(Type type, Expression body, Expression @finally, Expression fault, ReadOnlyCollection<CatchBlock> handlers)
		{
			Type = type;
			Body = body;
			Handlers = handlers;
			Finally = @finally;
			Fault = fault;
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitTry(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="body">The <see cref="P:System.Linq.Expressions.TryExpression.Body" /> property of the result.</param>
		/// <param name="handlers">The <see cref="P:System.Linq.Expressions.TryExpression.Handlers" /> property of the result.</param>
		/// <param name="finally">The <see cref="P:System.Linq.Expressions.TryExpression.Finally" /> property of the result.</param>
		/// <param name="fault">The <see cref="P:System.Linq.Expressions.TryExpression.Fault" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public TryExpression Update(Expression body, IEnumerable<CatchBlock> handlers, Expression @finally, Expression fault)
		{
			if (((body == Body) & (@finally == Finally) & (fault == Fault)) && ExpressionUtils.SameElements(ref handlers, Handlers))
			{
				return this;
			}
			return Expression.MakeTry(Type, body, @finally, fault, handlers);
		}

		internal TryExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents an operation between an expression and a type.</summary>
	[DebuggerTypeProxy(typeof(TypeBinaryExpressionProxy))]
	public sealed class TypeBinaryExpression : Expression
	{
		/// <summary>Gets the static type of the expression that this <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type => typeof(bool);

		/// <summary>Returns the node type of this Expression. Extension nodes should return <see cref="F:System.Linq.Expressions.ExpressionType.Extension" /> when overriding this method.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> of the expression.</returns>
		public sealed override ExpressionType NodeType { get; }

		/// <summary>Gets the expression operand of a type test operation.</summary>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression" /> that represents the expression operand of a type test operation.</returns>
		public Expression Expression { get; }

		/// <summary>Gets the type operand of a type test operation.</summary>
		/// <returns>A <see cref="T:System.Type" /> that represents the type operand of a type test operation.</returns>
		public Type TypeOperand { get; }

		internal TypeBinaryExpression(Expression expression, Type typeOperand, ExpressionType nodeType)
		{
			Expression = expression;
			TypeOperand = typeOperand;
			NodeType = nodeType;
		}

		internal Expression ReduceTypeEqual()
		{
			Type type = Expression.Type;
			if (type.IsValueType || TypeOperand.IsPointer)
			{
				if (type.IsNullableType())
				{
					if (type.GetNonNullableType() != TypeOperand.GetNonNullableType())
					{
						return Expression.Block(Expression, Utils.Constant(value: false));
					}
					return Expression.NotEqual(Expression, Expression.Constant(null, Expression.Type));
				}
				return Expression.Block(Expression, Utils.Constant(type == TypeOperand.GetNonNullableType()));
			}
			if (Expression.NodeType == ExpressionType.Constant)
			{
				return ReduceConstantTypeEqual();
			}
			if (Expression is ParameterExpression { IsByRef: false } parameterExpression)
			{
				return ByValParameterTypeEqual(parameterExpression);
			}
			ParameterExpression parameterExpression2 = Expression.Parameter(typeof(object));
			return Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(parameterExpression2), new TrueReadOnlyCollection<Expression>(Expression.Assign(parameterExpression2, Expression), ByValParameterTypeEqual(parameterExpression2)));
		}

		private Expression ByValParameterTypeEqual(ParameterExpression value)
		{
			Expression expression = Expression.Call(value, CachedReflectionInfo.Object_GetType);
			if (TypeOperand.IsInterface)
			{
				ParameterExpression parameterExpression = Expression.Parameter(typeof(Type));
				expression = Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(parameterExpression), new TrueReadOnlyCollection<Expression>(Expression.Assign(parameterExpression, expression), parameterExpression));
			}
			return Expression.AndAlso(Expression.ReferenceNotEqual(value, Utils.Null), Expression.ReferenceEqual(expression, Expression.Constant(TypeOperand.GetNonNullableType(), typeof(Type))));
		}

		private Expression ReduceConstantTypeEqual()
		{
			ConstantExpression constantExpression = Expression as ConstantExpression;
			if (constantExpression.Value == null)
			{
				return Utils.Constant(value: false);
			}
			return Utils.Constant(TypeOperand.GetNonNullableType() == constantExpression.Value.GetType());
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitTypeBinary(this);
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="expression">The <see cref="P:System.Linq.Expressions.TypeBinaryExpression.Expression" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public TypeBinaryExpression Update(Expression expression)
		{
			if (expression == Expression)
			{
				return this;
			}
			if (NodeType == ExpressionType.TypeIs)
			{
				return Expression.TypeIs(expression, TypeOperand);
			}
			return Expression.TypeEqual(expression, TypeOperand);
		}

		internal TypeBinaryExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents an expression that has a unary operator.</summary>
	[DebuggerTypeProxy(typeof(UnaryExpressionProxy))]
	public sealed class UnaryExpression : Expression
	{
		/// <summary>Gets the static type of the expression that this <see cref="T:System.Linq.Expressions.Expression" /> represents.</summary>
		/// <returns>The <see cref="P:System.Linq.Expressions.UnaryExpression.Type" /> that represents the static type of the expression.</returns>
		public sealed override Type Type { get; }

		/// <summary>Returns the node type of this <see cref="T:System.Linq.Expressions.Expression" />.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> that represents this expression.</returns>
		public sealed override ExpressionType NodeType { get; }

		/// <summary>Gets the operand of the unary operation.</summary>
		/// <returns>An <see cref="T:System.Linq.Expressions.Expression" /> that represents the operand of the unary operation.</returns>
		public Expression Operand { get; }

		/// <summary>Gets the implementing method for the unary operation.</summary>
		/// <returns>The <see cref="T:System.Reflection.MethodInfo" /> that represents the implementing method.</returns>
		public MethodInfo Method { get; }

		/// <summary>Gets a value that indicates whether the expression tree node represents a lifted call to an operator.</summary>
		/// <returns>
		///     <see langword="true" /> if the node represents a lifted call; otherwise, <see langword="false" />.</returns>
		public bool IsLifted
		{
			get
			{
				if (NodeType == ExpressionType.TypeAs || NodeType == ExpressionType.Quote || NodeType == ExpressionType.Throw)
				{
					return false;
				}
				bool flag = Operand.Type.IsNullableType();
				bool flag2 = Type.IsNullableType();
				if (Method != null)
				{
					if (!flag || TypeUtils.AreEquivalent(Method.GetParametersCached()[0].ParameterType, Operand.Type))
					{
						if (flag2)
						{
							return !TypeUtils.AreEquivalent(Method.ReturnType, Type);
						}
						return false;
					}
					return true;
				}
				return flag || flag2;
			}
		}

		/// <summary>Gets a value that indicates whether the expression tree node represents a lifted call to an operator whose return type is lifted to a nullable type.</summary>
		/// <returns>
		///     <see langword="true" /> if the operator's return type is lifted to a nullable type; otherwise, <see langword="false" />.</returns>
		public bool IsLiftedToNull
		{
			get
			{
				if (IsLifted)
				{
					return Type.IsNullableType();
				}
				return false;
			}
		}

		/// <summary>Gets a value that indicates whether the expression tree node can be reduced.</summary>
		/// <returns>True if a node can be reduced, otherwise false.</returns>
		public override bool CanReduce
		{
			get
			{
				ExpressionType nodeType = NodeType;
				if ((uint)(nodeType - 77) <= 3u)
				{
					return true;
				}
				return false;
			}
		}

		private bool IsPrefix
		{
			get
			{
				if (NodeType != ExpressionType.PreIncrementAssign)
				{
					return NodeType == ExpressionType.PreDecrementAssign;
				}
				return true;
			}
		}

		internal UnaryExpression(ExpressionType nodeType, Expression expression, Type type, MethodInfo method)
		{
			Operand = expression;
			Method = method;
			NodeType = nodeType;
			Type = type;
		}

		protected internal override Expression Accept(ExpressionVisitor visitor)
		{
			return visitor.VisitUnary(this);
		}

		/// <summary>Reduces the expression node to a simpler expression. </summary>
		/// <returns>The reduced expression.</returns>
		public override Expression Reduce()
		{
			if (CanReduce)
			{
				return Operand.NodeType switch
				{
					ExpressionType.Index => ReduceIndex(), 
					ExpressionType.MemberAccess => ReduceMember(), 
					_ => ReduceVariable(), 
				};
			}
			return this;
		}

		private UnaryExpression FunctionalOp(Expression operand)
		{
			ExpressionType nodeType = ((NodeType != ExpressionType.PreIncrementAssign && NodeType != ExpressionType.PostIncrementAssign) ? ExpressionType.Decrement : ExpressionType.Increment);
			return new UnaryExpression(nodeType, operand, operand.Type, Method);
		}

		private Expression ReduceVariable()
		{
			if (IsPrefix)
			{
				return Expression.Assign(Operand, FunctionalOp(Operand));
			}
			ParameterExpression parameterExpression = Expression.Parameter(Operand.Type, null);
			return Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(parameterExpression), new TrueReadOnlyCollection<Expression>(Expression.Assign(parameterExpression, Operand), Expression.Assign(Operand, FunctionalOp(parameterExpression)), parameterExpression));
		}

		private Expression ReduceMember()
		{
			MemberExpression memberExpression = (MemberExpression)Operand;
			if (memberExpression.Expression == null)
			{
				return ReduceVariable();
			}
			ParameterExpression parameterExpression = Expression.Parameter(memberExpression.Expression.Type, null);
			BinaryExpression binaryExpression = Expression.Assign(parameterExpression, memberExpression.Expression);
			memberExpression = Expression.MakeMemberAccess(parameterExpression, memberExpression.Member);
			if (IsPrefix)
			{
				return Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(parameterExpression), new TrueReadOnlyCollection<Expression>(binaryExpression, Expression.Assign(memberExpression, FunctionalOp(memberExpression))));
			}
			ParameterExpression parameterExpression2 = Expression.Parameter(memberExpression.Type, null);
			return Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(parameterExpression, parameterExpression2), new TrueReadOnlyCollection<Expression>(binaryExpression, Expression.Assign(parameterExpression2, memberExpression), Expression.Assign(memberExpression, FunctionalOp(parameterExpression2)), parameterExpression2));
		}

		private Expression ReduceIndex()
		{
			bool isPrefix = IsPrefix;
			IndexExpression indexExpression = (IndexExpression)Operand;
			int argumentCount = indexExpression.ArgumentCount;
			Expression[] array = new Expression[argumentCount + (isPrefix ? 2 : 4)];
			ParameterExpression[] array2 = new ParameterExpression[argumentCount + (isPrefix ? 1 : 2)];
			ParameterExpression[] array3 = new ParameterExpression[argumentCount];
			int num = 0;
			array2[num] = Expression.Parameter(indexExpression.Object.Type, null);
			array[num] = Expression.Assign(array2[num], indexExpression.Object);
			for (num++; num <= argumentCount; num++)
			{
				Expression argument = indexExpression.GetArgument(num - 1);
				array3[num - 1] = (array2[num] = Expression.Parameter(argument.Type, null));
				array[num] = Expression.Assign(array2[num], argument);
			}
			ParameterExpression instance = array2[0];
			PropertyInfo indexer = indexExpression.Indexer;
			Expression[] list = array3;
			indexExpression = Expression.MakeIndex(instance, indexer, new TrueReadOnlyCollection<Expression>(list));
			if (!isPrefix)
			{
				ParameterExpression parameterExpression = (array2[num] = Expression.Parameter(indexExpression.Type, null));
				array[num] = Expression.Assign(array2[num], indexExpression);
				num++;
				array[num++] = Expression.Assign(indexExpression, FunctionalOp(parameterExpression));
				array[num++] = parameterExpression;
			}
			else
			{
				array[num++] = Expression.Assign(indexExpression, FunctionalOp(indexExpression));
			}
			return Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(array2), new TrueReadOnlyCollection<Expression>(array));
		}

		/// <summary>Creates a new expression that is like this one, but using the supplied children. If all of the children are the same, it will return this expression.</summary>
		/// <param name="operand">The <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> property of the result.</param>
		/// <returns>This expression if no children are changed or an expression with the updated children.</returns>
		public UnaryExpression Update(Expression operand)
		{
			if (operand == Operand)
			{
				return this;
			}
			return Expression.MakeUnary(NodeType, operand, Type, Method);
		}

		internal UnaryExpression()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal static class Utils
	{
		public static readonly object BoxedFalse = false;

		public static readonly object BoxedTrue = true;

		public static readonly object BoxedIntM1 = -1;

		public static readonly object BoxedInt0 = 0;

		public static readonly object BoxedInt1 = 1;

		public static readonly object BoxedInt2 = 2;

		public static readonly object BoxedInt3 = 3;

		public static readonly object BoxedDefaultSByte = (sbyte)0;

		public static readonly object BoxedDefaultChar = '\0';

		public static readonly object BoxedDefaultInt16 = (short)0;

		public static readonly object BoxedDefaultInt64 = 0L;

		public static readonly object BoxedDefaultByte = (byte)0;

		public static readonly object BoxedDefaultUInt16 = (ushort)0;

		public static readonly object BoxedDefaultUInt32 = 0u;

		public static readonly object BoxedDefaultUInt64 = 0uL;

		public static readonly object BoxedDefaultSingle = 0f;

		public static readonly object BoxedDefaultDouble = 0.0;

		public static readonly object BoxedDefaultDecimal = 0m;

		public static readonly object BoxedDefaultDateTime = default(DateTime);

		private static readonly ConstantExpression s_true = Expression.Constant(BoxedTrue);

		private static readonly ConstantExpression s_false = Expression.Constant(BoxedFalse);

		private static readonly ConstantExpression s_m1 = Expression.Constant(BoxedIntM1);

		private static readonly ConstantExpression s_0 = Expression.Constant(BoxedInt0);

		private static readonly ConstantExpression s_1 = Expression.Constant(BoxedInt1);

		private static readonly ConstantExpression s_2 = Expression.Constant(BoxedInt2);

		private static readonly ConstantExpression s_3 = Expression.Constant(BoxedInt3);

		public static readonly DefaultExpression Empty = Expression.Empty();

		public static readonly ConstantExpression Null = Expression.Constant(null);

		public static ConstantExpression Constant(bool value)
		{
			if (!value)
			{
				return s_false;
			}
			return s_true;
		}

		public static ConstantExpression Constant(int value)
		{
			return value switch
			{
				-1 => s_m1, 
				0 => s_0, 
				1 => s_1, 
				2 => s_2, 
				3 => s_3, 
				_ => Expression.Constant(value), 
			};
		}
	}
}
namespace System.Linq.Expressions.Compiler
{
	internal sealed class AnalyzedTree
	{
		internal readonly Dictionary<object, CompilerScope> Scopes = new Dictionary<object, CompilerScope>();

		internal readonly Dictionary<LambdaExpression, BoundConstants> Constants = new Dictionary<LambdaExpression, BoundConstants>();
	}
	internal sealed class AssemblyGen
	{
		private static AssemblyGen s_assembly;

		private readonly ModuleBuilder _myModule;

		private int _index;

		private static AssemblyGen Assembly
		{
			get
			{
				if (s_assembly == null)
				{
					Interlocked.CompareExchange(ref s_assembly, new AssemblyGen(), null);
				}
				return s_assembly;
			}
		}

		private AssemblyGen()
		{
			AssemblyName assemblyName = new AssemblyName("Snippets");
			AssemblyBuilder assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
			_myModule = assemblyBuilder.DefineDynamicModule(assemblyName.Name);
		}

		private TypeBuilder DefineType(string name, Type parent, TypeAttributes attr)
		{
			ContractUtils.RequiresNotNull(name, "name");
			ContractUtils.RequiresNotNull(parent, "parent");
			StringBuilder stringBuilder = new StringBuilder(name);
			int value = Interlocked.Increment(ref _index);
			stringBuilder.Append("$");
			stringBuilder.Append(value);
			stringBuilder.Replace('+', '_').Replace('[', '_').Replace(']', '_')
				.Replace('*', '_')
				.Replace('&', '_')
				.Replace(',', '_')
				.Replace('\\', '_');
			name = stringBuilder.ToString();
			return _myModule.DefineType(name, attr, parent);
		}

		internal static TypeBuilder DefineDelegateType(string name)
		{
			return Assembly.DefineType(name, typeof(MulticastDelegate), TypeAttributes.Public | TypeAttributes.Sealed | TypeAttributes.AutoClass);
		}
	}
	internal sealed class BoundConstants
	{
		private readonly struct TypedConstant : IEquatable<TypedConstant>
		{
			internal readonly object Value;

			internal readonly Type Type;

			internal TypedConstant(object value, Type type)
			{
				Value = value;
				Type = type;
			}

			public override int GetHashCode()
			{
				return RuntimeHelpers.GetHashCode(Value) ^ Type.GetHashCode();
			}

			public bool Equals(TypedConstant other)
			{
				if (Value == other.Value)
				{
					return Type.Equals(other.Type);
				}
				return false;
			}

			public override bool Equals(object obj)
			{
				if (obj is TypedConstant)
				{
					return Equals((TypedConstant)obj);
				}
				return false;
			}
		}

		private readonly List<object> _values = new List<object>();

		private readonly Dictionary<object, int> _indexes = new Dictionary<object, int>(ReferenceEqualityComparer<object>.Instance);

		private readonly Dictionary<TypedConstant, int> _references = new Dictionary<TypedConstant, int>();

		private readonly Dictionary<TypedConstant, LocalBuilder> _cache = new Dictionary<TypedConstant, LocalBuilder>();

		internal int Count => _values.Count;

		internal object[] ToArray()
		{
			return _values.ToArray();
		}

		internal void AddReference(object value, Type type)
		{
			if (_indexes.TryAdd(value, _values.Count))
			{
				_values.Add(value);
			}
			Helpers.IncrementCount(new TypedConstant(value, type), _references);
		}

		internal void EmitConstant(LambdaCompiler lc, object value, Type type)
		{
			if (!lc.CanEmitBoundConstants)
			{
				throw Error.CannotCompileConstant(value);
			}
			if (_cache.TryGetValue(new TypedConstant(value, type), out var value2))
			{
				lc.IL.Emit(OpCodes.Ldloc, value2);
				return;
			}
			EmitConstantsArray(lc);
			EmitConstantFromArray(lc, value, type);
		}

		internal void EmitCacheConstants(LambdaCompiler lc)
		{
			int num = 0;
			foreach (KeyValuePair<TypedConstant, int> reference in _references)
			{
				if (!lc.CanEmitBoundConstants)
				{
					throw Error.CannotCompileConstant(reference.Key.Value);
				}
				if (ShouldCache(reference.Value))
				{
					num++;
				}
			}
			if (num == 0)
			{
				return;
			}
			EmitConstantsArray(lc);
			_cache.Clear();
			foreach (KeyValuePair<TypedConstant, int> reference2 in _references)
			{
				if (ShouldCache(reference2.Value))
				{
					if (--num > 0)
					{
						lc.IL.Emit(OpCodes.Dup);
					}
					LocalBuilder localBuilder = lc.IL.DeclareLocal(reference2.Key.Type);
					EmitConstantFromArray(lc, reference2.Key.Value, localBuilder.LocalType);
					lc.IL.Emit(OpCodes.Stloc, localBuilder);
					_cache.Add(reference2.Key, localBuilder);
				}
			}
		}

		private static bool ShouldCache(int refCount)
		{
			return refCount > 2;
		}

		private static void EmitConstantsArray(LambdaCompiler lc)
		{
			lc.EmitClosureArgument();
			lc.IL.Emit(OpCodes.Ldfld, CachedReflectionInfo.Closure_Constants);
		}

		private void EmitConstantFromArray(LambdaCompiler lc, object value, Type type)
		{
			if (!_indexes.TryGetValue(value, out var value2))
			{
				_indexes.Add(value, value2 = _values.Count);
				_values.Add(value);
			}
			lc.IL.EmitPrimitive(value2);
			lc.IL.Emit(OpCodes.Ldelem_Ref);
			if (type.IsValueType)
			{
				lc.IL.Emit(OpCodes.Unbox_Any, type);
			}
			else if (type != typeof(object))
			{
				lc.IL.Emit(OpCodes.Castclass, type);
			}
		}
	}
	internal sealed class CompilerScope
	{
		private abstract class Storage
		{
			internal readonly LambdaCompiler Compiler;

			internal readonly ParameterExpression Variable;

			internal Storage(LambdaCompiler compiler, ParameterExpression variable)
			{
				Compiler = compiler;
				Variable = variable;
			}

			internal abstract void EmitLoad();

			internal abstract void EmitAddress();

			internal abstract void EmitStore();

			internal virtual void EmitStore(Storage value)
			{
				value.EmitLoad();
				EmitStore();
			}

			internal virtual void FreeLocal()
			{
			}
		}

		private sealed class LocalStorage : Storage
		{
			private readonly LocalBuilder _local;

			internal LocalStorage(LambdaCompiler compiler, ParameterExpression variable)
				: base(compiler, variable)
			{
				_local = compiler.GetLocal(variable.IsByRef ? variable.Type.MakeByRefType() : variable.Type);
			}

			internal override void EmitLoad()
			{
				Compiler.IL.Emit(OpCodes.Ldloc, _local);
			}

			internal override void EmitStore()
			{
				Compiler.IL.Emit(OpCodes.Stloc, _local);
			}

			internal override void EmitAddress()
			{
				Compiler.IL.Emit(OpCodes.Ldloca, _local);
			}

			internal override void FreeLocal()
			{
				Compiler.FreeLocal(_local);
			}
		}

		private sealed class ArgumentStorage : Storage
		{
			private readonly int _argument;

			internal ArgumentStorage(LambdaCompiler compiler, ParameterExpression p)
				: base(compiler, p)
			{
				_argument = compiler.GetLambdaArgument(compiler.Parameters.IndexOf(p));
			}

			internal override void EmitLoad()
			{
				Compiler.IL.EmitLoadArg(_argument);
			}

			internal override void EmitStore()
			{
				Compiler.IL.EmitStoreArg(_argument);
			}

			internal override void EmitAddress()
			{
				Compiler.IL.EmitLoadArgAddress(_argument);
			}
		}

		private sealed class ElementBoxStorage : Storage
		{
			private readonly int _index;

			private readonly Storage _array;

			private readonly Type _boxType;

			private readonly FieldInfo _boxValueField;

			internal ElementBoxStorage(Storage array, int index, ParameterExpression variable)
				: base(array.Compiler, variable)
			{
				_array = array;
				_index = index;
				_boxType = typeof(StrongBox<>).MakeGenericType(variable.Type);
				_boxValueField = _boxType.GetField("Value");
			}

			internal override void EmitLoad()
			{
				EmitLoadBox();
				Compiler.IL.Emit(OpCodes.Ldfld, _boxValueField);
			}

			internal override void EmitStore()
			{
				LocalBuilder local = Compiler.GetLocal(Variable.Type);
				Compiler.IL.Emit(OpCodes.Stloc, local);
				EmitLoadBox();
				Compiler.IL.Emit(OpCodes.Ldloc, local);
				Compiler.FreeLocal(local);
				Compiler.IL.Emit(OpCodes.Stfld, _boxValueField);
			}

			internal override void EmitStore(Storage value)
			{
				EmitLoadBox();
				value.EmitLoad();
				Compiler.IL.Emit(OpCodes.Stfld, _boxValueField);
			}

			internal override void EmitAddress()
			{
				EmitLoadBox();
				Compiler.IL.Emit(OpCodes.Ldflda, _boxValueField);
			}

			internal void EmitLoadBox()
			{
				_array.EmitLoad();
				Compiler.IL.EmitPrimitive(_index);
				Compiler.IL.Emit(OpCodes.Ldelem_Ref);
				Compiler.IL.Emit(OpCodes.Castclass, _boxType);
			}
		}

		private sealed class LocalBoxStorage : Storage
		{
			private readonly LocalBuilder _boxLocal;

			private readonly FieldInfo _boxValueField;

			internal LocalBoxStorage(LambdaCompiler compiler, ParameterExpression variable)
				: base(compiler, variable)
			{
				Type type = typeof(StrongBox<>).MakeGenericType(variable.Type);
				_boxValueField = type.GetField("Value");
				_boxLocal = compiler.GetLocal(type);
			}

			internal override void EmitLoad()
			{
				Compiler.IL.Emit(OpCodes.Ldloc, _boxLocal);
				Compiler.IL.Emit(OpCodes.Ldfld, _boxValueField);
			}

			internal override void EmitAddress()
			{
				Compiler.IL.Emit(OpCodes.Ldloc, _boxLocal);
				Compiler.IL.Emit(OpCodes.Ldflda, _boxValueField);
			}

			internal override void EmitStore()
			{
				LocalBuilder local = Compiler.GetLocal(Variable.Type);
				Compiler.IL.Emit(OpCodes.Stloc, local);
				Compiler.IL.Emit(OpCodes.Ldloc, _boxLocal);
				Compiler.IL.Emit(OpCodes.Ldloc, local);
				Compiler.FreeLocal(local);
				Compiler.IL.Emit(OpCodes.Stfld, _boxValueField);
			}

			internal override void EmitStore(Storage value)
			{
				Compiler.IL.Emit(OpCodes.Ldloc, _boxLocal);
				value.EmitLoad();
				Compiler.IL.Emit(OpCodes.Stfld, _boxValueField);
			}

			internal void EmitStoreBox()
			{
				Compiler.IL.Emit(OpCodes.Stloc, _boxLocal);
			}

			internal override void FreeLocal()
			{
				Compiler.FreeLocal(_boxLocal);
			}
		}

		private CompilerScope _parent;

		internal readonly object Node;

		internal readonly bool IsMethod;

		internal bool NeedsClosure;

		internal readonly Dictionary<ParameterExpression, VariableStorageKind> Definitions = new Dictionary<ParameterExpression, VariableStorageKind>();

		internal Dictionary<ParameterExpression, int> ReferenceCount;

		internal HashSet<BlockExpression> MergedScopes;

		private HoistedLocals _hoistedLocals;

		private HoistedLocals _closureHoistedLocals;

		private readonly Dictionary<ParameterExpression, Storage> _locals = new Dictionary<ParameterExpression, Storage>();

		internal HoistedLocals NearestHoistedLocals => _hoistedLocals ?? _closureHoistedLocals;

		private string CurrentLambdaName
		{
			get
			{
				for (CompilerScope compilerScope = this; compilerScope != null; compilerScope = compilerScope._parent)
				{
					if (compilerScope.Node is LambdaExpression lambdaExpression)
					{
						return lambdaExpression.Name;
					}
				}
				throw ContractUtils.Unreachable;
			}
		}

		internal CompilerScope(object node, bool isMethod)
		{
			Node = node;
			IsMethod = isMethod;
			IReadOnlyList<ParameterExpression> variables = GetVariables(node);
			Definitions = new Dictionary<ParameterExpression, VariableStorageKind>(variables.Count);
			foreach (ParameterExpression item in variables)
			{
				Definitions.Add(item, VariableStorageKind.Local);
			}
		}

		internal CompilerScope Enter(LambdaCompiler lc, CompilerScope parent)
		{
			SetParent(lc, parent);
			AllocateLocals(lc);
			if (IsMethod && _closureHoistedLocals != null)
			{
				EmitClosureAccess(lc, _closureHoistedLocals);
			}
			EmitNewHoistedLocals(lc);
			if (IsMethod)
			{
				EmitCachedVariables();
			}
			return this;
		}

		internal CompilerScope Exit()
		{
			if (!IsMethod)
			{
				foreach (Storage value in _locals.Values)
				{
					value.FreeLocal();
				}
			}
			CompilerScope parent = _parent;
			_parent = null;
			_hoistedLocals = null;
			_closureHoistedLocals = null;
			_locals.Clear();
			return parent;
		}

		internal void EmitVariableAccess(LambdaCompiler lc, ReadOnlyCollection<ParameterExpression> vars)
		{
			if (NearestHoistedLocals != null && vars.Count > 0)
			{
				ArrayBuilder<long> arrayBuilder = new ArrayBuilder<long>(vars.Count);
				foreach (ParameterExpression var in vars)
				{
					ulong num = 0uL;
					HoistedLocals hoistedLocals = NearestHoistedLocals;
					while (!hoistedLocals.Indexes.ContainsKey(var))
					{
						num++;
						hoistedLocals = hoistedLocals.Parent;
					}
					ulong item = (num << 32) | (uint)hoistedLocals.Indexes[var];
					arrayBuilder.UncheckedAdd((long)item);
				}
				EmitGet(NearestHoistedLocals.SelfVariable);
				lc.EmitConstantArray(arrayBuilder.ToArray());
				lc.IL.Emit(OpCodes.Call, CachedReflectionInfo.RuntimeOps_CreateRuntimeVariables_ObjectArray_Int64Array);
			}
			else
			{
				lc.IL.Emit(OpCodes.Call, CachedReflectionInfo.RuntimeOps_CreateRuntimeVariables);
			}
		}

		internal void AddLocal(LambdaCompiler gen, ParameterExpression variable)
		{
			_locals.Add(variable, new LocalStorage(gen, variable));
		}

		internal void EmitGet(ParameterExpression variable)
		{
			ResolveVariable(variable).EmitLoad();
		}

		internal void EmitSet(ParameterExpression variable)
		{
			ResolveVariable(variable).EmitStore();
		}

		internal void EmitAddressOf(ParameterExpression variable)
		{
			ResolveVariable(variable).EmitAddress();
		}

		private Storage ResolveVariable(ParameterExpression variable)
		{
			return ResolveVariable(variable, NearestHoistedLocals);
		}

		private Storage ResolveVariable(ParameterExpression variable, HoistedLocals hoistedLocals)
		{
			for (CompilerScope compilerScope = this; compilerScope != null; compilerScope = compilerScope._parent)
			{
				if (compilerScope._locals.TryGetValue(variable, out var value))
				{
					return value;
				}
				if (compilerScope.IsMethod)
				{
					break;
				}
			}
			for (HoistedLocals hoistedLocals2 = hoistedLocals; hoistedLocals2 != null; hoistedLocals2 = hoistedLocals2.Parent)
			{
				if (hoistedLocals2.Indexes.TryGetValue(variable, out var value2))
				{
					return new ElementBoxStorage(ResolveVariable(hoistedLocals2.SelfVariable, hoistedLocals), value2, variable);
				}
			}
			throw Error.UndefinedVariable(variable.Name, variable.Type, CurrentLambdaName);
		}

		private void SetParent(LambdaCompiler lc, CompilerScope parent)
		{
			_parent = parent;
			if (NeedsClosure && _parent != null)
			{
				_closureHoistedLocals = _parent.NearestHoistedLocals;
			}
			ReadOnlyCollection<ParameterExpression> readOnlyCollection = (from p in GetVariables()
				where Definitions[p] == VariableStorageKind.Hoisted
				select p).ToReadOnly();
			if (readOnlyCollection.Count > 0)
			{
				_hoistedLocals = new HoistedLocals(_closureHoistedLocals, readOnlyCollection);
				AddLocal(lc, _hoistedLocals.SelfVariable);
			}
		}

		private void EmitNewHoistedLocals(LambdaCompiler lc)
		{
			if (_hoistedLocals == null)
			{
				return;
			}
			lc.IL.EmitPrimitive(_hoistedLocals.Variables.Count);
			lc.IL.Emit(OpCodes.Newarr, typeof(object));
			int num = 0;
			foreach (ParameterExpression variable in _hoistedLocals.Variables)
			{
				lc.IL.Emit(OpCodes.Dup);
				lc.IL.EmitPrimitive(num++);
				Type type = typeof(StrongBox<>).MakeGenericType(variable.Type);
				int index;
				if (IsMethod && (index = lc.Parameters.IndexOf(variable)) >= 0)
				{
					lc.EmitLambdaArgument(index);
					lc.IL.Emit(OpCodes.Newobj, type.GetConstructor(new Type[1] { variable.Type }));
				}
				else if (variable == _hoistedLocals.ParentVariable)
				{
					ResolveVariable(variable, _closureHoistedLocals).EmitLoad();
					lc.IL.Emit(OpCodes.Newobj, type.GetConstructor(new Type[1] { variable.Type }));
				}
				else
				{
					lc.IL.Emit(OpCodes.Newobj, type.GetConstructor(Type.EmptyTypes));
				}
				if (ShouldCache(variable))
				{
					lc.IL.Emit(OpCodes.Dup);
					CacheBoxToLocal(lc, variable);
				}
				lc.IL.Emit(OpCodes.Stelem_Ref);
			}
			EmitSet(_hoistedLocals.SelfVariable);
		}

		private void EmitCachedVariables()
		{
			if (ReferenceCount == null)
			{
				return;
			}
			foreach (KeyValuePair<ParameterExpression, int> item in ReferenceCount)
			{
				if (ShouldCache(item.Key, item.Value) && ResolveVariable(item.Key) is ElementBoxStorage elementBoxStorage)
				{
					elementBoxStorage.EmitLoadBox();
					CacheBoxToLocal(elementBoxStorage.Compiler, item.Key);
				}
			}
		}

		private bool ShouldCache(ParameterExpression v, int refCount)
		{
			if (refCount > 2)
			{
				return !_locals.ContainsKey(v);
			}
			return false;
		}

		private bool ShouldCache(ParameterExpression v)
		{
			if (ReferenceCount == null)
			{
				return false;
			}
			if (ReferenceCount.TryGetValue(v, out var value))
			{
				return ShouldCache(v, value);
			}
			return false;
		}

		private void CacheBoxToLocal(LambdaCompiler lc, ParameterExpression v)
		{
			LocalBoxStorage localBoxStorage = new LocalBoxStorage(lc, v);
			localBoxStorage.EmitStoreBox();
			_locals.Add(v, localBoxStorage);
		}

		private void EmitClosureAccess(LambdaCompiler lc, HoistedLocals locals)
		{
			if (locals != null)
			{
				EmitClosureToVariable(lc, locals);
				while ((locals = locals.Parent) != null)
				{
					ParameterExpression selfVariable = locals.SelfVariable;
					LocalStorage localStorage = new LocalStorage(lc, selfVariable);
					localStorage.EmitStore(ResolveVariable(selfVariable));
					_locals.Add(selfVariable, localStorage);
				}
			}
		}

		private void EmitClosureToVariable(LambdaCompiler lc, HoistedLocals locals)
		{
			lc.EmitClosureArgument();
			lc.IL.Emit(OpCodes.Ldfld, CachedReflectionInfo.Closure_Locals);
			AddLocal(lc, locals.SelfVariable);
			EmitSet(locals.SelfVariable);
		}

		private void AllocateLocals(LambdaCompiler lc)
		{
			foreach (ParameterExpression variable in GetVariables())
			{
				if (Definitions[variable] == VariableStorageKind.Local)
				{
					Storage value = ((!IsMethod || !lc.Parameters.Contains(variable)) ? ((Storage)new LocalStorage(lc, variable)) : ((Storage)new ArgumentStorage(lc, variable)));
					_locals.Add(variable, value);
				}
			}
		}

		private IEnumerable<ParameterExpression> GetVariables()
		{
			if (MergedScopes != null)
			{
				return GetVariablesIncludingMerged();
			}
			return GetVariables(Node);
		}

		private IEnumerable<ParameterExpression> GetVariablesIncludingMerged()
		{
			foreach (ParameterExpression variable in GetVariables(Node))
			{
				yield return variable;
			}
			foreach (BlockExpression mergedScope in MergedScopes)
			{
				foreach (ParameterExpression variable2 in mergedScope.Variables)
				{
					yield return variable2;
				}
			}
		}

		private static IReadOnlyList<ParameterExpression> GetVariables(object scope)
		{
			if (scope is LambdaExpression provider)
			{
				return new ParameterList(provider);
			}
			if (!(scope is BlockExpression blockExpression))
			{
				return new ParameterExpression[1] { ((CatchBlock)scope).Variable };
			}
			return blockExpression.Variables;
		}
	}
	internal enum VariableStorageKind
	{
		Local,
		Hoisted
	}
	internal static class ParameterProviderExtensions
	{
		public static int IndexOf(this IParameterProvider provider, ParameterExpression parameter)
		{
			int i = 0;
			for (int parameterCount = provider.ParameterCount; i < parameterCount; i++)
			{
				if (provider.GetParameter(i) == parameter)
				{
					return i;
				}
			}
			return -1;
		}

		public static bool Contains(this IParameterProvider provider, ParameterExpression parameter)
		{
			return provider.IndexOf(parameter) >= 0;
		}
	}
	internal sealed class ParameterList : IReadOnlyList<ParameterExpression>, IReadOnlyCollection<ParameterExpression>, IEnumerable<ParameterExpression>, IEnumerable
	{
		private readonly IParameterProvider _provider;

		public ParameterExpression this[int index] => _provider.GetParameter(index);

		public int Count => _provider.ParameterCount;

		public ParameterList(IParameterProvider provider)
		{
			_provider = provider;
		}

		public IEnumerator<ParameterExpression> GetEnumerator()
		{
			int i = 0;
			for (int n = _provider.ParameterCount; i < n; i++)
			{
				yield return _provider.GetParameter(i);
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	internal static class DelegateHelpers
	{
		internal class TypeInfo
		{
			public Type DelegateType;

			public Dictionary<Type, TypeInfo> TypeChain;
		}

		private static TypeInfo _DelegateCache = new TypeInfo();

		private const int MaximumArity = 17;

		private const MethodAttributes CtorAttributes = MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.RTSpecialName;

		private const MethodImplAttributes ImplAttributes = MethodImplAttributes.CodeTypeMask;

		private const MethodAttributes InvokeAttributes = MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.VtableLayoutMask;

		private static readonly Type[] s_delegateCtorSignature = new Type[2]
		{
			typeof(object),
			typeof(IntPtr)
		};

		internal static Type MakeDelegateType(Type[] types)
		{
			lock (_DelegateCache)
			{
				TypeInfo typeInfo = _DelegateCache;
				for (int i = 0; i < types.Length; i++)
				{
					typeInfo = NextTypeInfo(types[i], typeInfo);
				}
				if (typeInfo.DelegateType == null)
				{
					typeInfo.DelegateType = MakeNewDelegate((Type[])types.Clone());
				}
				return typeInfo.DelegateType;
			}
		}

		internal static TypeInfo NextTypeInfo(Type initialArg)
		{
			lock (_DelegateCache)
			{
				return NextTypeInfo(initialArg, _DelegateCache);
			}
		}

		internal static TypeInfo GetNextTypeInfo(Type initialArg, TypeInfo curTypeInfo)
		{
			lock (_DelegateCache)
			{
				return NextTypeInfo(initialArg, curTypeInfo);
			}
		}

		private static TypeInfo NextTypeInfo(Type initialArg, TypeInfo curTypeInfo)
		{
			if (curTypeInfo.TypeChain == null)
			{
				curTypeInfo.TypeChain = new Dictionary<Type, TypeInfo>();
			}
			if (!curTypeInfo.TypeChain.TryGetValue(initialArg, out var value))
			{
				value = new TypeInfo();
				if (!initialArg.IsCollectible)
				{
					curTypeInfo.TypeChain[initialArg] = value;
				}
			}
			return value;
		}

		internal static Type MakeNewDelegate(Type[] types)
		{
			bool flag;
			if (types.Length > 17)
			{
				flag = true;
			}
			else
			{
				flag = false;
				foreach (Type type in types)
				{
					if (type.IsByRef || type.IsPointer)
					{
						flag = true;
						break;
					}
				}
			}
			if (flag)
			{
				return MakeNewCustomDelegate(types);
			}
			if (types[^1] == typeof(void))
			{
				return GetActionType(types.RemoveLast());
			}
			return GetFuncType(types);
		}

		internal static Type GetFuncType(Type[] types)
		{
			return types.Length switch
			{
				1 => typeof(Func<>).MakeGenericType(types), 
				2 => typeof(Func<, >).MakeGenericType(types), 
				3 => typeof(Func<, , >).MakeGenericType(types), 
				4 => typeof(Func<, , , >).MakeGenericType(types), 
				5 => typeof(Func<, , , , >).MakeGenericType(types), 
				6 => typeof(Func<, , , , , >).MakeGenericType(types), 
				7 => typeof(Func<, , , , , , >).MakeGenericType(types), 
				8 => typeof(Func<, , , , , , , >).MakeGenericType(types), 
				9 => typeof(Func<, , , , , , , , >).MakeGenericType(types), 
				10 => typeof(Func<, , , , , , , , , >).MakeGenericType(types), 
				11 => typeof(Func<, , , , , , , , , , >).MakeGenericType(types), 
				12 => typeof(Func<, , , , , , , , , , , >).MakeGenericType(types), 
				13 => typeof(Func<, , , , , , , , , , , , >).MakeGenericType(types), 
				14 => typeof(Func<, , , , , , , , , , , , , >).MakeGenericType(types), 
				15 => typeof(Func<, , , , , , , , , , , , , , >).MakeGenericType(types), 
				16 => typeof(Func<, , , , , , , , , , , , , , , >).MakeGenericType(types), 
				17 => typeof(Func<, , , , , , , , , , , , , , , , >).MakeGenericType(types), 
				_ => null, 
			};
		}

		internal static Type GetActionType(Type[] types)
		{
			return types.Length switch
			{
				0 => typeof(Action), 
				1 => typeof(Action<>).MakeGenericType(types), 
				2 => typeof(Action<, >).MakeGenericType(types), 
				3 => typeof(Action<, , >).MakeGenericType(types), 
				4 => typeof(Action<, , , >).MakeGenericType(types), 
				5 => typeof(Action<, , , , >).MakeGenericType(types), 
				6 => typeof(Action<, , , , , >).MakeGenericType(types), 
				7 => typeof(Action<, , , , , , >).MakeGenericType(types), 
				8 => typeof(Action<, , , , , , , >).MakeGenericType(types), 
				9 => typeof(Action<, , , , , , , , >).MakeGenericType(types), 
				10 => typeof(Action<, , , , , , , , , >).MakeGenericType(types), 
				11 => typeof(Action<, , , , , , , , , , >).MakeGenericType(types), 
				12 => typeof(Action<, , , , , , , , , , , >).MakeGenericType(types), 
				13 => typeof(Action<, , , , , , , , , , , , >).MakeGenericType(types), 
				14 => typeof(Action<, , , , , , , , , , , , , >).MakeGenericType(types), 
				15 => typeof(Action<, , , , , , , , , , , , , , >).MakeGenericType(types), 
				16 => typeof(Action<, , , , , , , , , , , , , , , >).MakeGenericType(types), 
				_ => null, 
			};
		}

		internal static Type MakeCallSiteDelegate(ReadOnlyCollection<Expression> types, Type returnType)
		{
			lock (_DelegateCache)
			{
				TypeInfo delegateCache = _DelegateCache;
				delegateCache = NextTypeInfo(typeof(CallSite), delegateCache);
				for (int i = 0; i < types.Count; i++)
				{
					delegateCache = NextTypeInfo(types[i].Type, delegateCache);
				}
				delegateCache = NextTypeInfo(returnType, delegateCache);
				if (delegateCache.DelegateType == null)
				{
					delegateCache.MakeDelegateType(returnType, types);
				}
				return delegateCache.DelegateType;
			}
		}

		internal static Type MakeDeferredSiteDelegate(DynamicMetaObject[] args, Type returnType)
		{
			lock (_DelegateCache)
			{
				TypeInfo delegateCache = _DelegateCache;
				delegateCache = NextTypeInfo(typeof(CallSite), delegateCache);
				foreach (DynamicMetaObject obj in args)
				{
					Type type = obj.Expression.Type;
					if (IsByRef(obj))
					{
						type = type.MakeByRefType();
					}
					delegateCache = NextTypeInfo(type, delegateCache);
				}
				delegateCache = NextTypeInfo(returnType, delegateCache);
				if (delegateCache.DelegateType == null)
				{
					Type[] array = new Type[args.Length + 2];
					array[0] = typeof(CallSite);
					array[^1] = returnType;
					for (int j = 0; j < args.Length; j++)
					{
						DynamicMetaObject obj2 = args[j];
						Type type2 = obj2.Expression.Type;
						if (IsByRef(obj2))
						{
							type2 = type2.MakeByRefType();
						}
						array[j + 1] = type2;
					}
					delegateCache.DelegateType = MakeNewDelegate(array);
				}
				return delegateCache.DelegateType;
			}
		}

		private static bool IsByRef(DynamicMetaObject mo)
		{
			if (mo.Expression is ParameterExpression parameterExpression)
			{
				return parameterExpression.IsByRef;
			}
			return false;
		}

		private static Type MakeNewCustomDelegate(Type[] types)
		{
			Type returnType = types[^1];
			Type[] parameterTypes = types.RemoveLast();
			TypeBuilder typeBuilder = AssemblyGen.DefineDelegateType("Delegate" + types.Length);
			typeBuilder.DefineConstructor(MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.RTSpecialName, CallingConventions.Standard, s_delegateCtorSignature).SetImplementationFlags(MethodImplAttributes.CodeTypeMask);
			typeBuilder.DefineMethod("Invoke", MethodAttributes.Public | MethodAttributes.Virtual | MethodAttributes.HideBySig | MethodAttributes.VtableLayoutMask, returnType, parameterTypes).SetImplementationFlags(MethodImplAttributes.CodeTypeMask);
			return typeBuilder.CreateTypeInfo();
		}
	}
	internal sealed class HoistedLocals
	{
		internal readonly HoistedLocals Parent;

		internal readonly ReadOnlyDictionary<Expression, int> Indexes;

		internal readonly ReadOnlyCollection<ParameterExpression> Variables;

		internal readonly ParameterExpression SelfVariable;

		internal ParameterExpression ParentVariable => Parent?.SelfVariable;

		internal HoistedLocals(HoistedLocals parent, ReadOnlyCollection<ParameterExpression> vars)
		{
			if (parent != null)
			{
				vars = vars.AddFirst(parent.SelfVariable);
			}
			Dictionary<Expression, int> dictionary = new Dictionary<Expression, int>(vars.Count);
			for (int i = 0; i < vars.Count; i++)
			{
				dictionary.Add(vars[i], i);
			}
			SelfVariable = Expression.Variable(typeof(object[]), null);
			Parent = parent;
			Variables = vars;
			Indexes = new ReadOnlyDictionary<Expression, int>(dictionary);
		}

		internal static object[] GetParent(object[] locals)
		{
			return ((StrongBox<object[]>)locals[0]).Value;
		}
	}
	internal static class ILGen
	{
		internal static void Emit(this ILGenerator il, OpCode opcode, MethodBase methodBase)
		{
			if (methodBase is ConstructorInfo con)
			{
				il.Emit(opcode, con);
			}
			else
			{
				il.Emit(opcode, (MethodInfo)methodBase);
			}
		}

		internal static void EmitLoadArg(this ILGenerator il, int index)
		{
			switch (index)
			{
			case 0:
				il.Emit(OpCodes.Ldarg_0);
				return;
			case 1:
				il.Emit(OpCodes.Ldarg_1);
				return;
			case 2:
				il.Emit(OpCodes.Ldarg_2);
				return;
			case 3:
				il.Emit(OpCodes.Ldarg_3);
				return;
			}
			if (index <= 255)
			{
				il.Emit(OpCodes.Ldarg_S, (byte)index);
			}
			else
			{
				il.Emit(OpCodes.Ldarg, (short)index);
			}
		}

		internal static void EmitLoadArgAddress(this ILGenerator il, int index)
		{
			if (index <= 255)
			{
				il.Emit(OpCodes.Ldarga_S, (byte)index);
			}
			else
			{
				il.Emit(OpCodes.Ldarga, (short)index);
			}
		}

		internal static void EmitStoreArg(this ILGenerator il, int index)
		{
			if (index <= 255)
			{
				il.Emit(OpCodes.Starg_S, (byte)index);
			}
			else
			{
				il.Emit(OpCodes.Starg, (short)index);
			}
		}

		internal static void EmitLoadValueIndirect(this ILGenerator il, Type type)
		{
			switch (type.GetTypeCode())
			{
			case TypeCode.Byte:
				il.Emit(OpCodes.Ldind_I1);
				return;
			case TypeCode.Boolean:
			case TypeCode.SByte:
				il.Emit(OpCodes.Ldind_U1);
				return;
			case TypeCode.Int16:
				il.Emit(OpCodes.Ldind_I2);
				return;
			case TypeCode.Char:
			case TypeCode.UInt16:
				il.Emit(OpCodes.Ldind_U2);
				return;
			case TypeCode.Int32:
				il.Emit(OpCodes.Ldind_I4);
				return;
			case TypeCode.UInt32:
				il.Emit(OpCodes.Ldind_U4);
				return;
			case TypeCode.Int64:
			case TypeCode.UInt64:
				il.Emit(OpCodes.Ldind_I8);
				return;
			case TypeCode.Single:
				il.Emit(OpCodes.Ldind_R4);
				return;
			case TypeCode.Double:
				il.Emit(OpCodes.Ldind_R8);
				return;
			}
			if (type.IsValueType)
			{
				il.Emit(OpCodes.Ldobj, type);
			}
			else
			{
				il.Emit(OpCodes.Ldind_Ref);
			}
		}

		internal static void EmitStoreValueIndirect(this ILGenerator il, Type type)
		{
			switch (type.GetTypeCode())
			{
			case TypeCode.Boolean:
			case TypeCode.SByte:
			case TypeCode.Byte:
				il.Emit(OpCodes.Stind_I1);
				return;
			case TypeCode.Char:
			case TypeCode.Int16:
			case TypeCode.UInt16:
				il.Emit(OpCodes.Stind_I2);
				return;
			case TypeCode.Int32:
			case TypeCode.UInt32:
				il.Emit(OpCodes.Stind_I4);
				return;
			case TypeCode.Int64:
			case TypeCode.UInt64:
				il.Emit(OpCodes.Stind_I8);
				return;
			case TypeCode.Single:
				il.Emit(OpCodes.Stind_R4);
				return;
			case TypeCode.Double:
				il.Emit(OpCodes.Stind_R8);
				return;
			}
			if (type.IsValueType)
			{
				il.Emit(OpCodes.Stobj, type);
			}
			else
			{
				il.Emit(OpCodes.Stind_Ref);
			}
		}

		internal static void EmitLoadElement(this ILGenerator il, Type type)
		{
			if (!type.IsValueType)
			{
				il.Emit(OpCodes.Ldelem_Ref);
				return;
			}
			switch (type.GetTypeCode())
			{
			case TypeCode.Boolean:
			case TypeCode.SByte:
				il.Emit(OpCodes.Ldelem_I1);
				break;
			case TypeCode.Byte:
				il.Emit(OpCodes.Ldelem_U1);
				break;
			case TypeCode.Int16:
				il.Emit(OpCodes.Ldelem_I2);
				break;
			case TypeCode.Char:
			case TypeCode.UInt16:
				il.Emit(OpCodes.Ldelem_U2);
				break;
			case TypeCode.Int32:
				il.Emit(OpCodes.Ldelem_I4);
				break;
			case TypeCode.UInt32:
				il.Emit(OpCodes.Ldelem_U4);
				break;
			case TypeCode.Int64:
			case TypeCode.UInt64:
				il.Emit(OpCodes.Ldelem_I8);
				break;
			case TypeCode.Single:
				il.Emit(OpCodes.Ldelem_R4);
				break;
			case TypeCode.Double:
				il.Emit(OpCodes.Ldelem_R8);
				break;
			default:
				il.Emit(OpCodes.Ldelem, type);
				break;
			}
		}

		internal static void EmitStoreElement(this ILGenerator il, Type type)
		{
			switch (type.GetTypeCode())
			{
			case TypeCode.Boolean:
			case TypeCode.SByte:
			case TypeCode.Byte:
				il.Emit(OpCodes.Stelem_I1);
				return;
			case TypeCode.Char:
			case TypeCode.Int16:
			case TypeCode.UInt16:
				il.Emit(OpCodes.Stelem_I2);
				return;
			case TypeCode.Int32:
			case TypeCode.UInt32:
				il.Emit(OpCodes.Stelem_I4);
				return;
			case TypeCode.Int64:
			case TypeCode.UInt64:
				il.Emit(OpCodes.Stelem_I8);
				return;
			case TypeCode.Single:
				il.Emit(OpCodes.Stelem_R4);
				return;
			case TypeCode.Double:
				il.Emit(OpCodes.Stelem_R8);
				return;
			}
			if (type.IsValueType)
			{
				il.Emit(OpCodes.Stelem, type);
			}
			else
			{
				il.Emit(OpCodes.Stelem_Ref);
			}
		}

		internal static void EmitType(this ILGenerator il, Type type)
		{
			il.Emit(OpCodes.Ldtoken, type);
			il.Emit(OpCodes.Call, CachedReflectionInfo.Type_GetTypeFromHandle);
		}

		internal static void EmitFieldAddress(this ILGenerator il, FieldInfo fi)
		{
			il.Emit(fi.IsStatic ? OpCodes.Ldsflda : OpCodes.Ldflda, fi);
		}

		internal static void EmitFieldGet(this ILGenerator il, FieldInfo fi)
		{
			il.Emit(fi.IsStatic ? OpCodes.Ldsfld : OpCodes.Ldfld, fi);
		}

		internal static void EmitFieldSet(this ILGenerator il, FieldInfo fi)
		{
			il.Emit(fi.IsStatic ? OpCodes.Stsfld : OpCodes.Stfld, fi);
		}

		internal static void EmitNew(this ILGenerator il, ConstructorInfo ci)
		{
			il.Emit(OpCodes.Newobj, ci);
		}

		internal static void EmitNull(this ILGenerator il)
		{
			il.Emit(OpCodes.Ldnull);
		}

		internal static void EmitString(this ILGenerator il, string value)
		{
			il.Emit(OpCodes.Ldstr, value);
		}

		internal static void EmitPrimitive(this ILGenerator il, bool value)
		{
			il.Emit(value ? OpCodes.Ldc_I4_1 : OpCodes.Ldc_I4_0);
		}

		internal static void EmitPrimitive(this ILGenerator il, int value)
		{
			OpCode opcode;
			switch (value)
			{
			case -1:
				opcode = OpCodes.Ldc_I4_M1;
				break;
			case 0:
				opcode = OpCodes.Ldc_I4_0;
				break;
			case 1:
				opcode = OpCodes.Ldc_I4_1;
				break;
			case 2:
				opcode = OpCodes.Ldc_I4_2;
				break;
			case 3:
				opcode = OpCodes.Ldc_I4_3;
				break;
			case 4:
				opcode = OpCodes.Ldc_I4_4;
				break;
			case 5:
				opcode = OpCodes.Ldc_I4_5;
				break;
			case 6:
				opcode = OpCodes.Ldc_I4_6;
				break;
			case 7:
				opcode = OpCodes.Ldc_I4_7;
				break;
			case 8:
				opcode = OpCodes.Ldc_I4_8;
				break;
			default:
				if (value >= -128 && value <= 127)
				{
					il.Emit(OpCodes.Ldc_I4_S, (sbyte)value);
				}
				else
				{
					il.Emit(OpCodes.Ldc_I4, value);
				}
				return;
			}
			il.Emit(opcode);
		}

		private static void EmitPrimitive(this ILGenerator il, uint value)
		{
			il.EmitPrimitive((int)value);
		}

		private static void EmitPrimitive(this ILGenerator il, long value)
		{
			if (int.MinValue <= value && value <= uint.MaxValue)
			{
				il.EmitPrimitive((int)value);
				il.Emit((value > 0) ? OpCodes.Conv_U8 : OpCodes.Conv_I8);
			}
			else
			{
				il.Emit(OpCodes.Ldc_I8, value);
			}
		}

		private static void EmitPrimitive(this ILGenerator il, ulong value)
		{
			il.EmitPrimitive((long)value);
		}

		private static void EmitPrimitive(this ILGenerator il, double value)
		{
			il.Emit(OpCodes.Ldc_R8, value);
		}

		private static void EmitPrimitive(this ILGenerator il, float value)
		{
			il.Emit(OpCodes.Ldc_R4, value);
		}

		internal static bool CanEmitConstant(object value, Type type)
		{
			if (value == null || CanEmitILConstant(type))
			{
				return true;
			}
			Type type2 = value as Type;
			if (type2 != null)
			{
				return ShouldLdtoken(type2);
			}
			MethodBase methodBase = value as MethodBase;
			if (methodBase != null)
			{
				return ShouldLdtoken(methodBase);
			}
			return false;
		}

		private static bool CanEmitILConstant(Type type)
		{
			TypeCode typeCode = type.GetNonNullableType().GetTypeCode();
			if ((uint)(typeCode - 3) <= 12u || typeCode == TypeCode.String)
			{
				return true;
			}
			return false;
		}

		internal static bool TryEmitConstant(this ILGenerator il, object value, Type type, ILocalCache locals)
		{
			if (value == null)
			{
				il.EmitDefault(type, locals);
				return true;
			}
			if (il.TryEmitILConstant(value, type))
			{
				return true;
			}
			Type type2 = value as Type;
			if (type2 != null)
			{
				if (ShouldLdtoken(type2))
				{
					il.EmitType(type2);
					if (type != typeof(Type))
					{
						il.Emit(OpCodes.Castclass, type);
					}
					return true;
				}
				return false;
			}
			MethodBase methodBase = value as MethodBase;
			if (methodBase != null && ShouldLdtoken(methodBase))
			{
				il.Emit(OpCodes.Ldtoken, methodBase);
				Type declaringType = methodBase.DeclaringType;
				if (declaringType != null && declaringType.IsGenericType)
				{
					il.Emit(OpCodes.Ldtoken, declaringType);
					il.Emit(OpCodes.Call, CachedReflectionInfo.MethodBase_GetMethodFromHandle_RuntimeMethodHandle_RuntimeTypeHandle);
				}
				else
				{
					il.Emit(OpCodes.Call, CachedReflectionInfo.MethodBase_GetMethodFromHandle_RuntimeMethodHandle);
				}
				if (type != typeof(MethodBase))
				{
					il.Emit(OpCodes.Castclass, type);
				}
				return true;
			}
			return false;
		}

		private static bool ShouldLdtoken(Type t)
		{
			if (!t.IsGenericParameter)
			{
				return t.IsVisible;
			}
			return true;
		}

		internal static bool ShouldLdtoken(MethodBase mb)
		{
			if (mb is DynamicMethod)
			{
				return false;
			}
			Type declaringType = mb.DeclaringType;
			if (!(declaringType == null))
			{
				return ShouldLdtoken(declaringType);
			}
			return true;
		}

		private static bool TryEmitILConstant(this ILGenerator il, object value, Type type)
		{
			if (type.IsNullableType())
			{
				Type nonNullableType = type.GetNonNullableType();
				if (il.TryEmitILConstant(value, nonNullableType))
				{
					il.Emit(OpCodes.Newobj, type.GetConstructor(new Type[1] { nonNullableType }));
					return true;
				}
				return false;
			}
			switch (type.GetTypeCode())
			{
			case TypeCode.Boolean:
				il.EmitPrimitive((bool)value);
				return true;
			case TypeCode.SByte:
				il.EmitPrimitive((sbyte)value);
				return true;
			case TypeCode.Int16:
				il.EmitPrimitive((short)value);
				return true;
			case TypeCode.Int32:
				il.EmitPrimitive((int)value);
				return true;
			case TypeCode.Int64:
				il.EmitPrimitive((long)value);
				return true;
			case TypeCode.Single:
				il.EmitPrimitive((float)value);
				return true;
			case TypeCode.Double:
				il.EmitPrimitive((double)value);
				return true;
			case TypeCode.Char:
				il.EmitPrimitive((char)value);
				return true;
			case TypeCode.Byte:
				il.EmitPrimitive((byte)value);
				return true;
			case TypeCode.UInt16:
				il.EmitPrimitive((ushort)value);
				return true;
			case TypeCode.UInt32:
				il.EmitPrimitive((uint)value);
				return true;
			case TypeCode.UInt64:
				il.EmitPrimitive((ulong)value);
				return true;
			case TypeCode.Decimal:
				il.EmitDecimal((decimal)value);
				return true;
			case TypeCode.String:
				il.EmitString((string)value);
				return true;
			default:
				return false;
			}
		}

		internal static void EmitConvertToType(this ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals)
		{
			if (!TypeUtils.AreEquivalent(typeFrom, typeTo))
			{
				bool flag = typeFrom.IsNullableType();
				bool flag2 = typeTo.IsNullableType();
				Type nonNullableType = typeFrom.GetNonNullableType();
				Type nonNullableType2 = typeTo.GetNonNullableType();
				if (typeFrom.IsInterface || typeTo.IsInterface || typeFrom == typeof(object) || typeTo == typeof(object) || typeFrom == typeof(Enum) || typeFrom == typeof(ValueType) || TypeUtils.IsLegalExplicitVariantDelegateConversion(typeFrom, typeTo))
				{
					il.EmitCastToType(typeFrom, typeTo);
				}
				else if (flag || flag2)
				{
					il.EmitNullableConversion(typeFrom, typeTo, isChecked, locals);
				}
				else if ((!typeFrom.IsConvertible() || !typeTo.IsConvertible()) && (nonNullableType.IsAssignableFrom(nonNullableType2) || nonNullableType2.IsAssignableFrom(nonNullableType)))
				{
					il.EmitCastToType(typeFrom, typeTo);
				}
				else if (typeFrom.IsArray && typeTo.IsArray)
				{
					il.EmitCastToType(typeFrom, typeTo);
				}
				else
				{
					il.EmitNumericConversion(typeFrom, typeTo, isChecked);
				}
			}
		}

		private static void EmitCastToType(this ILGenerator il, Type typeFrom, Type typeTo)
		{
			if (typeFrom.IsValueType)
			{
				il.Emit(OpCodes.Box, typeFrom);
				if (typeTo != typeof(object))
				{
					il.Emit(OpCodes.Castclass, typeTo);
				}
			}
			else
			{
				il.Emit(typeTo.IsValueType ? OpCodes.Unbox_Any : OpCodes.Castclass, typeTo);
			}
		}

		private static void EmitNumericConversion(this ILGenerator il, Type typeFrom, Type typeTo, bool isChecked)
		{
			TypeCode typeCode = typeTo.GetTypeCode();
			TypeCode typeCode2 = typeFrom.GetTypeCode();
			if (typeCode == typeCode2)
			{
				return;
			}
			bool flag = typeCode2.IsUnsigned();
			OpCode opcode;
			switch (typeCode)
			{
			case TypeCode.Single:
				if (flag)
				{
					il.Emit(OpCodes.Conv_R_Un);
				}
				opcode = OpCodes.Conv_R4;
				break;
			case TypeCode.Double:
				if (flag)
				{
					il.Emit(OpCodes.Conv_R_Un);
				}
				opcode = OpCodes.Conv_R8;
				break;
			case TypeCode.Decimal:
				il.Emit(meth: typeCode2 switch
				{
					TypeCode.Byte => CachedReflectionInfo.Decimal_op_Implicit_Byte, 
					TypeCode.SByte => CachedReflectionInfo.Decimal_op_Implicit_SByte, 
					TypeCode.Int16 => CachedReflectionInfo.Decimal_op_Implicit_Int16, 
					TypeCode.UInt16 => CachedReflectionInfo.Decimal_op_Implicit_UInt16, 
					TypeCode.Int32 => CachedReflectionInfo.Decimal_op_Implicit_Int32, 
					TypeCode.UInt32 => CachedReflectionInfo.Decimal_op_Implicit_UInt32, 
					TypeCode.Int64 => CachedReflectionInfo.Decimal_op_Implicit_Int64, 
					TypeCode.UInt64 => CachedReflectionInfo.Decimal_op_Implicit_UInt64, 
					TypeCode.Char => CachedReflectionInfo.Decimal_op_Implicit_Char, 
					_ => throw ContractUtils.Unreachable, 
				}, opcode: OpCodes.Call);
				return;
			case TypeCode.SByte:
				if (isChecked)
				{
					opcode = (flag ? OpCodes.Conv_Ovf_I1_Un : OpCodes.Conv_Ovf_I1);
					break;
				}
				if (typeCode2 == TypeCode.Byte)
				{
					return;
				}
				opcode = OpCodes.Conv_I1;
				break;
			case TypeCode.Byte:
				if (isChecked)
				{
					opcode = (flag ? OpCodes.Conv_Ovf_U1_Un : OpCodes.Conv_Ovf_U1);
					break;
				}
				if (typeCode2 == TypeCode.SByte)
				{
					return;
				}
				opcode = OpCodes.Conv_U1;
				break;
			case TypeCode.Int16:
				switch (typeCode2)
				{
				case TypeCode.SByte:
				case TypeCode.Byte:
					return;
				case TypeCode.Char:
				case TypeCode.UInt16:
					if (!isChecked)
					{
						return;
					}
					break;
				}
				opcode = ((!isChecked) ? OpCodes.Conv_I2 : (flag ? OpCodes.Conv_Ovf_I2_Un : OpCodes.Conv_Ovf_I2));
				break;
			case TypeCode.Char:
			case TypeCode.UInt16:
				switch (typeCode2)
				{
				case TypeCode.Char:
				case TypeCode.Byte:
				case TypeCode.UInt16:
					return;
				case TypeCode.SByte:
				case TypeCode.Int16:
					if (!isChecked)
					{
						return;
					}
					break;
				}
				opcode = ((!isChecked) ? OpCodes.Conv_U2 : (flag ? OpCodes.Conv_Ovf_U2_Un : OpCodes.Conv_Ovf_U2));
				break;
			case TypeCode.Int32:
				switch (typeCode2)
				{
				case TypeCode.SByte:
				case TypeCode.Byte:
				case TypeCode.Int16:
				case TypeCode.UInt16:
					return;
				case TypeCode.UInt32:
					if (!isChecked)
					{
						return;
					}
					break;
				}
				opcode = ((!isChecked) ? OpCodes.Conv_I4 : (flag ? OpCodes.Conv_Ovf_I4_Un : OpCodes.Conv_Ovf_I4));
				break;
			case TypeCode.UInt32:
				switch (typeCode2)
				{
				case TypeCode.Char:
				case TypeCode.Byte:
				case TypeCode.UInt16:
					return;
				case TypeCode.SByte:
				case TypeCode.Int16:
				case TypeCode.Int32:
					if (!isChecked)
					{
						return;
					}
					break;
				}
				opcode = ((!isChecked) ? OpCodes.Conv_U4 : (flag ? OpCodes.Conv_Ovf_U4_Un : OpCodes.Conv_Ovf_U4));
				break;
			case TypeCode.Int64:
				if (!isChecked && typeCode2 == TypeCode.UInt64)
				{
					return;
				}
				opcode = ((!isChecked) ? (flag ? OpCodes.Conv_U8 : OpCodes.Conv_I8) : (flag ? OpCodes.Conv_Ovf_I8_Un : OpCodes.Conv_Ovf_I8));
				break;
			case TypeCode.UInt64:
				if (!isChecked && typeCode2 == TypeCode.Int64)
				{
					return;
				}
				opcode = ((!isChecked) ? ((flag || typeCode2.IsFloatingPoint()) ? OpCodes.Conv_U8 : OpCodes.Conv_I8) : ((flag || typeCode2.IsFloatingPoint()) ? OpCodes.Conv_Ovf_U8_Un : OpCodes.Conv_Ovf_U8));
				break;
			default:
				throw ContractUtils.Unreachable;
			}
			il.Emit(opcode);
		}

		private static void EmitNullableToNullableConversion(this ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals)
		{
			LocalBuilder local = locals.GetLocal(typeFrom);
			il.Emit(OpCodes.Stloc, local);
			il.Emit(OpCodes.Ldloca, local);
			il.EmitHasValue(typeFrom);
			Label label = il.DefineLabel();
			il.Emit(OpCodes.Brfalse_S, label);
			il.Emit(OpCodes.Ldloca, local);
			locals.FreeLocal(local);
			il.EmitGetValueOrDefault(typeFrom);
			Type nonNullableType = typeFrom.GetNonNullableType();
			Type nonNullableType2 = typeTo.GetNonNullableType();
			il.EmitConvertToType(nonNullableType, nonNullableType2, isChecked, locals);
			ConstructorInfo constructor = typeTo.GetConstructor(new Type[1] { nonNullableType2 });
			il.Emit(OpCodes.Newobj, constructor);
			Label label2 = il.DefineLabel();
			il.Emit(OpCodes.Br_S, label2);
			il.MarkLabel(label);
			LocalBuilder local2 = locals.GetLocal(typeTo);
			il.Emit(OpCodes.Ldloca, local2);
			il.Emit(OpCodes.Initobj, typeTo);
			il.Emit(OpCodes.Ldloc, local2);
			locals.FreeLocal(local2);
			il.MarkLabel(label2);
		}

		private static void EmitNonNullableToNullableConversion(this ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals)
		{
			Type nonNullableType = typeTo.GetNonNullableType();
			il.EmitConvertToType(typeFrom, nonNullableType, isChecked, locals);
			ConstructorInfo constructor = typeTo.GetConstructor(new Type[1] { nonNullableType });
			il.Emit(OpCodes.Newobj, constructor);
		}

		private static void EmitNullableToNonNullableConversion(this ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals)
		{
			if (typeTo.IsValueType)
			{
				il.EmitNullableToNonNullableStructConversion(typeFrom, typeTo, isChecked, locals);
			}
			else
			{
				il.EmitNullableToReferenceConversion(typeFrom);
			}
		}

		private static void EmitNullableToNonNullableStructConversion(this ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals)
		{
			LocalBuilder local = locals.GetLocal(typeFrom);
			il.Emit(OpCodes.Stloc, local);
			il.Emit(OpCodes.Ldloca, local);
			locals.FreeLocal(local);
			il.EmitGetValue(typeFrom);
			Type nonNullableType = typeFrom.GetNonNullableType();
			il.EmitConvertToType(nonNullableType, typeTo, isChecked, locals);
		}

		private static void EmitNullableToReferenceConversion(this ILGenerator il, Type typeFrom)
		{
			il.Emit(OpCodes.Box, typeFrom);
		}

		private static void EmitNullableConversion(this ILGenerator il, Type typeFrom, Type typeTo, bool isChecked, ILocalCache locals)
		{
			bool flag = typeFrom.IsNullableType();
			bool flag2 = typeTo.IsNullableType();
			if (flag && flag2)
			{
				il.EmitNullableToNullableConversion(typeFrom, typeTo, isChecked, locals);
			}
			else if (flag)
			{
				il.EmitNullableToNonNullableConversion(typeFrom, typeTo, isChecked, locals);
			}
			else
			{
				il.EmitNonNullableToNullableConversion(typeFrom, typeTo, isChecked, locals);
			}
		}

		internal static void EmitHasValue(this ILGenerator il, Type nullableType)
		{
			MethodInfo method = nullableType.GetMethod("get_HasValue", BindingFlags.Instance | BindingFlags.Public);
			il.Emit(OpCodes.Call, method);
		}

		internal static void EmitGetValue(this ILGenerator il, Type nullableType)
		{
			MethodInfo method = nullableType.GetMethod("get_Value", BindingFlags.Instance | BindingFlags.Public);
			il.Emit(OpCodes.Call, method);
		}

		internal static void EmitGetValueOrDefault(this ILGenerator il, Type nullableType)
		{
			MethodInfo method = nullableType.GetMethod("GetValueOrDefault", Type.EmptyTypes);
			il.Emit(OpCodes.Call, method);
		}

		internal static void EmitArray<T>(this ILGenerator il, T[] items, ILocalCache locals)
		{
			il.EmitPrimitive(items.Length);
			il.Emit(OpCodes.Newarr, typeof(T));
			for (int i = 0; i < items.Length; i++)
			{
				il.Emit(OpCodes.Dup);
				il.EmitPrimitive(i);
				il.TryEmitConstant(items[i], typeof(T), locals);
				il.EmitStoreElement(typeof(T));
			}
		}

		internal static void EmitArray(this ILGenerator il, Type elementType, int count)
		{
			il.EmitPrimitive(count);
			il.Emit(OpCodes.Newarr, elementType);
		}

		internal static void EmitArray(this ILGenerator il, Type arrayType)
		{
			if (arrayType.IsSZArray)
			{
				il.Emit(OpCodes.Newarr, arrayType.GetElementType());
				return;
			}
			Type[] array = new Type[arrayType.GetArrayRank()];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = typeof(int);
			}
			ConstructorInfo constructor = arrayType.GetConstructor(array);
			il.EmitNew(constructor);
		}

		private static void EmitDecimal(this ILGenerator il, decimal value)
		{
			int[] bits = decimal.GetBits(value);
			int num = (bits[3] & 0x7FFFFFFF) >> 16;
			if (num == 0)
			{
				if (-2147483648m <= value)
				{
					if (value <= 2147483647m)
					{
						int num2 = decimal.ToInt32(value);
						switch (num2)
						{
						case -1:
							il.Emit(OpCodes.Ldsfld, CachedReflectionInfo.Decimal_MinusOne);
							break;
						case 0:
							il.EmitDefault(typeof(decimal), null);
							break;
						case 1:
							il.Emit(OpCodes.Ldsfld, CachedReflectionInfo.Decimal_One);
							break;
						default:
							il.EmitPrimitive(num2);
							il.EmitNew(CachedReflectionInfo.Decimal_Ctor_Int32);
							break;
						}
						return;
					}
					if (value <= 4294967295m)
					{
						il.EmitPrimitive(decimal.ToUInt32(value));
						il.EmitNew(CachedReflectionInfo.Decimal_Ctor_UInt32);
						return;
					}
				}
				if (-9223372036854775808m <= value)
				{
					if (value <= 9223372036854775807m)
					{
						il.EmitPrimitive(decimal.ToInt64(value));
						il.EmitNew(CachedReflectionInfo.Decimal_Ctor_Int64);
						return;
					}
					if (value <= 18446744073709551615m)
					{
						il.EmitPrimitive(decimal.ToUInt64(value));
						il.EmitNew(CachedReflectionInfo.Decimal_Ctor_UInt64);
						return;
					}
					if (value == decimal.MaxValue)
					{
						il.Emit(OpCodes.Ldsfld, CachedReflectionInfo.Decimal_MaxValue);
						return;
					}
				}
				else if (value == decimal.MinValue)
				{
					il.Emit(OpCodes.Ldsfld, CachedReflectionInfo.Decimal_MinValue);
					return;
				}
			}
			il.EmitPrimitive(bits[0]);
			il.EmitPrimitive(bits[1]);
			il.EmitPrimitive(bits[2]);
			il.EmitPrimitive((bits[3] & 0x80000000u) != 0);
			il.EmitPrimitive((byte)num);
			il.EmitNew(CachedReflectionInfo.Decimal_Ctor_Int32_Int32_Int32_Bool_Byte);
		}

		internal static void EmitDefault(this ILGenerator il, Type type, ILocalCache locals)
		{
			switch (type.GetTypeCode())
			{
			case TypeCode.DateTime:
				il.Emit(OpCodes.Ldsfld, CachedReflectionInfo.DateTime_MinValue);
				break;
			case TypeCode.Object:
				if (type.IsValueType)
				{
					LocalBuilder local = locals.GetLocal(type);
					il.Emit(OpCodes.Ldloca, local);
					il.Emit(OpCodes.Initobj, type);
					il.Emit(OpCodes.Ldloc, local);
					locals.FreeLocal(local);
					break;
				}
				goto case TypeCode.Empty;
			case TypeCode.Empty:
			case TypeCode.DBNull:
			case TypeCode.String:
				il.Emit(OpCodes.Ldnull);
				break;
			case TypeCode.Boolean:
			case TypeCode.Char:
			case TypeCode.SByte:
			case TypeCode.Byte:
			case TypeCode.Int16:
			case TypeCode.UInt16:
			case TypeCode.Int32:
			case TypeCode.UInt32:
				il.Emit(OpCodes.Ldc_I4_0);
				break;
			case TypeCode.Int64:
			case TypeCode.UInt64:
				il.Emit(OpCodes.Ldc_I4_0);
				il.Emit(OpCodes.Conv_I8);
				break;
			case TypeCode.Single:
				il.Emit(OpCodes.Ldc_R4, 0f);
				break;
			case TypeCode.Double:
				il.Emit(OpCodes.Ldc_R8, 0.0);
				break;
			case TypeCode.Decimal:
				il.Emit(OpCodes.Ldsfld, CachedReflectionInfo.Decimal_Zero);
				break;
			default:
				throw ContractUtils.Unreachable;
			}
		}
	}
	internal sealed class KeyedStack<TKey, TValue> where TValue : class
	{
		private readonly Dictionary<TKey, Stack<TValue>> _data = new Dictionary<TKey, Stack<TValue>>();

		internal void Push(TKey key, TValue value)
		{
			if (!_data.TryGetValue(key, out var value2))
			{
				_data.Add(key, value2 = new Stack<TValue>());
			}
			value2.Push(value);
		}

		internal TValue TryPop(TKey key)
		{
			if (!_data.TryGetValue(key, out var value) || !value.TryPop(out var result))
			{
				return null;
			}
			return result;
		}
	}
	internal sealed class LabelInfo
	{
		private readonly LabelTarget _node;

		private Label _label;

		private bool _labelDefined;

		private LocalBuilder _value;

		private readonly HashSet<LabelScopeInfo> _definitions = new HashSet<LabelScopeInfo>();

		private readonly List<LabelScopeInfo> _references = new List<LabelScopeInfo>();

		private readonly bool _canReturn;

		private bool _acrossBlockJump;

		private OpCode _opCode = OpCodes.Leave;

		private readonly ILGenerator _ilg;

		internal Label Label
		{
			get
			{
				EnsureLabelAndValue();
				return _label;
			}
		}

		internal bool CanReturn => _canReturn;

		internal bool CanBranch => _opCode != OpCodes.Leave;

		internal LabelInfo(ILGenerator il, LabelTarget node, bool canReturn)
		{
			_ilg = il;
			_node = node;
			_canReturn = canReturn;
		}

		internal void Reference(LabelScopeInfo block)
		{
			_references.Add(block);
			if (_definitions.Count > 0)
			{
				ValidateJump(block);
			}
		}

		internal void Define(LabelScopeInfo block)
		{
			for (LabelScopeInfo labelScopeInfo = block; labelScopeInfo != null; labelScopeInfo = labelScopeInfo.Parent)
			{
				if (labelScopeInfo.ContainsTarget(_node))
				{
					throw Error.LabelTargetAlreadyDefined(_node.Name);
				}
			}
			_definitions.Add(block);
			block.AddLabelInfo(_node, this);
			if (_definitions.Count == 1)
			{
				foreach (LabelScopeInfo reference in _references)
				{
					ValidateJump(reference);
				}
				return;
			}
			if (_acrossBlockJump)
			{
				throw Error.AmbiguousJump(_node.Name);
			}
			_labelDefined = false;
		}

		private void ValidateJump(LabelScopeInfo reference)
		{
			_opCode = (_canReturn ? OpCodes.Ret : OpCodes.Br);
			for (LabelScopeInfo labelScopeInfo = reference; labelScopeInfo != null; labelScopeInfo = labelScopeInfo.Parent)
			{
				if (_definitions.Contains(labelScopeInfo))
				{
					return;
				}
				if (labelScopeInfo.Kind == LabelScopeKind.Finally || labelScopeInfo.Kind == LabelScopeKind.Filter)
				{
					break;
				}
				if (labelScopeInfo.Kind == LabelScopeKind.Try || labelScopeInfo.Kind == LabelScopeKind.Catch)
				{
					_opCode = OpCodes.Leave;
				}
			}
			_acrossBlockJump = true;
			if (_node != null && _node.Type != typeof(void))
			{
				throw Error.NonLocalJumpWithValue(_node.Name);
			}
			if (_definitions.Count > 1)
			{
				throw Error.AmbiguousJump(_node.Name);
			}
			LabelScopeInfo labelScopeInfo2 = _definitions.First();
			LabelScopeInfo labelScopeInfo3 = Helpers.CommonNode(labelScopeInfo2, reference, (LabelScopeInfo b) => b.Parent);
			_opCode = (_canReturn ? OpCodes.Ret : OpCodes.Br);
			for (LabelScopeInfo labelScopeInfo4 = reference; labelScopeInfo4 != labelScopeInfo3; labelScopeInfo4 = labelScopeInfo4.Parent)
			{
				if (labelScopeInfo4.Kind == LabelScopeKind.Finally)
				{
					throw Error.ControlCannotLeaveFinally();
				}
				if (labelScopeInfo4.Kind == LabelScopeKind.Filter)
				{
					throw Error.ControlCannotLeaveFilterTest();
				}
				if (labelScopeInfo4.Kind == LabelScopeKind.Try || labelScopeInfo4.Kind == LabelScopeKind.Catch)
				{
					_opCode = OpCodes.Leave;
				}
			}
			for (LabelScopeInfo labelScopeInfo5 = labelScopeInfo2; labelScopeInfo5 != labelScopeInfo3; labelScopeInfo5 = labelScopeInfo5.Parent)
			{
				if (!labelScopeInfo5.CanJumpInto)
				{
					if (labelScopeInfo5.Kind == LabelScopeKind.Expression)
					{
						throw Error.ControlCannotEnterExpression();
					}
					throw Error.ControlCannotEnterTry();
				}
			}
		}

		internal void ValidateFinish()
		{
			if (_references.Count > 0 && _definitions.Count == 0)
			{
				throw Error.LabelTargetUndefined(_node.Name);
			}
		}

		internal void EmitJump()
		{
			if (_opCode == OpCodes.Ret)
			{
				_ilg.Emit(OpCodes.Ret);
				return;
			}
			StoreValue();
			_ilg.Emit(_opCode, Label);
		}

		private void StoreValue()
		{
			EnsureLabelAndValue();
			if (_value != null)
			{
				_ilg.Emit(OpCodes.Stloc, _value);
			}
		}

		internal void Mark()
		{
			if (_canReturn)
			{
				if (!_labelDefined)
				{
					return;
				}
				_ilg.Emit(OpCodes.Ret);
			}
			else
			{
				StoreValue();
			}
			MarkWithEmptyStack();
		}

		internal void MarkWithEmptyStack()
		{
			_ilg.MarkLabel(Label);
			if (_value != null)
			{
				_ilg.Emit(OpCodes.Ldloc, _value);
			}
		}

		private void EnsureLabelAndValue()
		{
			if (!_labelDefined)
			{
				_labelDefined = true;
				_label = _ilg.DefineLabel();
				if (_node != null && _node.Type != typeof(void))
				{
					_value = _ilg.DeclareLocal(_node.Type);
				}
			}
		}
	}
	internal enum LabelScopeKind
	{
		Statement,
		Block,
		Switch,
		Lambda,
		Try,
		Catch,
		Finally,
		Filter,
		Expression
	}
	internal sealed class LabelScopeInfo
	{
		private Dictionary<LabelTarget, LabelInfo> _labels;

		internal readonly LabelScopeKind Kind;

		internal readonly LabelScopeInfo Parent;

		internal bool CanJumpInto
		{
			get
			{
				LabelScopeKind kind = Kind;
				if ((uint)kind <= 3u)
				{
					return true;
				}
				return false;
			}
		}

		internal LabelScopeInfo(LabelScopeInfo parent, LabelScopeKind kind)
		{
			Parent = parent;
			Kind = kind;
		}

		internal bool ContainsTarget(LabelTarget target)
		{
			if (_labels == null)
			{
				return false;
			}
			return _labels.ContainsKey(target);
		}

		internal bool TryGetLabelInfo(LabelTarget target, out LabelInfo info)
		{
			if (_labels == null)
			{
				info = null;
				return false;
			}
			return _labels.TryGetValue(target, out info);
		}

		internal void AddLabelInfo(LabelTarget target, LabelInfo info)
		{
			if (_labels == null)
			{
				_labels = new Dictionary<LabelTarget, LabelInfo>();
			}
			_labels.Add(target, info);
		}
	}
	internal sealed class LambdaCompiler : ILocalCache
	{
		[Flags]
		internal enum CompilationFlags
		{
			EmitExpressionStart = 1,
			EmitNoExpressionStart = 2,
			EmitAsDefaultType = 0x10,
			EmitAsVoidType = 0x20,
			EmitAsTail = 0x100,
			EmitAsMiddle = 0x200,
			EmitAsNoTail = 0x400,
			EmitExpressionStartMask = 0xF,
			EmitAsTypeMask = 0xF0,
			EmitAsTailCallMask = 0xF00
		}

		private sealed class SwitchLabel
		{
			internal readonly decimal Key;

			internal readonly Label Label;

			internal readonly object Constant;

			internal SwitchLabel(decimal key, object constant, Label label)
			{
				Key = key;
				Constant = constant;
				Label = label;
			}
		}

		private sealed class SwitchInfo
		{
			internal readonly SwitchExpression Node;

			internal readonly LocalBuilder Value;

			internal readonly Label Default;

			internal readonly Type Type;

			internal readonly bool IsUnsigned;

			internal readonly bool Is64BitSwitch;

			internal SwitchInfo(SwitchExpression node, LocalBuilder value, Label @default)
			{
				Node = node;
				Value = value;
				Default = @default;
				Type = Node.SwitchValue.Type;
				IsUnsigned = Type.IsUnsigned();
				TypeCode typeCode = Type.GetTypeCode();
				Is64BitSwitch = typeCode == TypeCode.UInt64 || typeCode == TypeCode.Int64;
			}
		}

		private delegate void WriteBack(LambdaCompiler compiler);

		private readonly StackGuard _guard = new StackGuard();

		private static int s_counter;

		private readonly AnalyzedTree _tree;

		private readonly ILGenerator _ilg;

		private readonly TypeBuilder _typeBuilder;

		private readonly MethodInfo _method;

		private LabelScopeInfo _labelBlock = new LabelScopeInfo(null, LabelScopeKind.Lambda);

		private readonly Dictionary<LabelTarget, LabelInfo> _labelInfo = new Dictionary<LabelTarget, LabelInfo>();

		private CompilerScope _scope;

		private readonly LambdaExpression _lambda;

		private readonly bool _hasClosureArgument;

		private readonly BoundConstants _boundConstants;

		private readonly KeyedStack<Type, LocalBuilder> _freeLocals = new KeyedStack<Type, LocalBuilder>();

		internal ILGenerator IL => _ilg;

		internal IParameterProvider Parameters => _lambda;

		internal bool CanEmitBoundConstants => _method is DynamicMethod;

		private void EmitAddress(Expression node, Type type)
		{
			EmitAddress(node, type, CompilationFlags.EmitExpressionStart);
		}

		private void EmitAddress(Expression node, Type type, CompilationFlags flags)
		{
			bool flag = (flags & CompilationFlags.EmitExpressionStartMask) == CompilationFlags.EmitExpressionStart;
			CompilationFlags flags2 = (flag ? EmitExpressionStart(node) : CompilationFlags.EmitNoExpressionStart);
			switch (node.NodeType)
			{
			default:
				EmitExpressionAddress(node, type);
				break;
			case ExpressionType.ArrayIndex:
				AddressOf((BinaryExpression)node, type);
				break;
			case ExpressionType.Parameter:
				AddressOf((ParameterExpression)node, type);
				break;
			case ExpressionType.MemberAccess:
				AddressOf((MemberExpression)node, type);
				break;
			case ExpressionType.Unbox:
				AddressOf((UnaryExpression)node, type);
				break;
			case ExpressionType.Call:
				AddressOf((MethodCallExpression)node, type);
				break;
			case ExpressionType.Index:
				AddressOf((IndexExpression)node, type);
				break;
			}
			if (flag)
			{
				EmitExpressionEnd(flags2);
			}
		}

		private void AddressOf(BinaryExpression node, Type type)
		{
			if (TypeUtils.AreEquivalent(type, node.Type))
			{
				EmitExpression(node.Left);
				EmitExpression(node.Right);
				_ilg.Emit(OpCodes.Ldelema, node.Type);
			}
			else
			{
				EmitExpressionAddress(node, type);
			}
		}

		private void AddressOf(ParameterExpression node, Type type)
		{
			if (TypeUtils.AreEquivalent(type, node.Type))
			{
				if (node.IsByRef)
				{
					_scope.EmitGet(node);
				}
				else
				{
					_scope.EmitAddressOf(node);
				}
			}
			else if (node.Type.IsByRef && node.Type.GetElementType() == type)
			{
				EmitExpression(node);
			}
			else
			{
				EmitExpressionAddress(node, type);
			}
		}

		private void AddressOf(MemberExpression node, Type type)
		{
			if (TypeUtils.AreEquivalent(type, node.Type))
			{
				Type type2 = null;
				if (node.Expression != null)
				{
					EmitInstance(node.Expression, out type2);
				}
				EmitMemberAddress(node.Member, type2);
			}
			else
			{
				EmitExpressionAddress(node, type);
			}
		}

		private void EmitMemberAddress(MemberInfo member, Type objectType)
		{
			if (member is FieldInfo { IsLiteral: false, IsInitOnly: false } fieldInfo)
			{
				_ilg.EmitFieldAddress(fieldInfo);
				return;
			}
			EmitMemberGet(member, objectType);
			LocalBuilder local = GetLocal(GetMemberType(member));
			_ilg.Emit(OpCodes.Stloc, local);
			_ilg.Emit(OpCodes.Ldloca, local);
		}

		private void AddressOf(MethodCallExpression node, Type type)
		{
			if (!node.Method.IsStatic && node.Object.Type.IsArray && node.Method == node.Object.Type.GetMethod("Get", BindingFlags.Instance | BindingFlags.Public))
			{
				MethodInfo method = node.Object.Type.GetMethod("Address", BindingFlags.Instance | BindingFlags.Public);
				EmitMethodCall(node.Object, method, node);
			}
			else
			{
				EmitExpressionAddress(node, type);
			}
		}

		private void AddressOf(IndexExpression node, Type type)
		{
			if (!TypeUtils.AreEquivalent(type, node.Type) || node.Indexer != null)
			{
				EmitExpressionAddress(node, type);
			}
			else if (node.ArgumentCount == 1)
			{
				EmitExpression(node.Object);
				EmitExpression(node.GetArgument(0));
				_ilg.Emit(OpCodes.Ldelema, node.Type);
			}
			else
			{
				MethodInfo method = node.Object.Type.GetMethod("Address", BindingFlags.Instance | BindingFlags.Public);
				EmitMethodCall(node.Object, method, node);
			}
		}

		private void AddressOf(UnaryExpression node, Type type)
		{
			EmitExpression(node.Operand);
			_ilg.Emit(OpCodes.Unbox, type);
		}

		private void EmitExpressionAddress(Expression node, Type type)
		{
			EmitExpression(node, CompilationFlags.EmitNoExpressionStart | CompilationFlags.EmitAsNoTail);
			LocalBuilder local = GetLocal(type);
			_ilg.Emit(OpCodes.Stloc, local);
			_ilg.Emit(OpCodes.Ldloca, local);
		}

		private WriteBack EmitAddressWriteBack(Expression node, Type type)
		{
			CompilationFlags flags = EmitExpressionStart(node);
			WriteBack writeBack = null;
			if (TypeUtils.AreEquivalent(type, node.Type))
			{
				switch (node.NodeType)
				{
				case ExpressionType.MemberAccess:
					writeBack = AddressOfWriteBack((MemberExpression)node);
					break;
				case ExpressionType.Index:
					writeBack = AddressOfWriteBack((IndexExpression)node);
					break;
				}
			}
			if (writeBack == null)
			{
				EmitAddress(node, type, CompilationFlags.EmitNoExpressionStart | CompilationFlags.EmitAsNoTail);
			}
			EmitExpressionEnd(flags);
			return writeBack;
		}

		private WriteBack AddressOfWriteBack(MemberExpression node)
		{
			if (!(node.Member is PropertyInfo { CanWrite: not false }))
			{
				return null;
			}
			return AddressOfWriteBackCore(node);
		}

		private WriteBack AddressOfWriteBackCore(MemberExpression node)
		{
			LocalBuilder instanceLocal = null;
			Type type = null;
			if (node.Expression != null)
			{
				EmitInstance(node.Expression, out type);
				_ilg.Emit(OpCodes.Dup);
				_ilg.Emit(OpCodes.Stloc, instanceLocal = GetInstanceLocal(type));
			}
			PropertyInfo pi = (PropertyInfo)node.Member;
			EmitCall(type, pi.GetGetMethod(nonPublic: true));
			LocalBuilder valueLocal = GetLocal(node.Type);
			_ilg.Emit(OpCodes.Stloc, valueLocal);
			_ilg.Emit(OpCodes.Ldloca, valueLocal);
			return delegate(LambdaCompiler @this)
			{
				if (instanceLocal != null)
				{
					@this._ilg.Emit(OpCodes.Ldloc, instanceLocal);
					@this.FreeLocal(instanceLocal);
				}
				@this._ilg.Emit(OpCodes.Ldloc, valueLocal);
				@this.FreeLocal(valueLocal);
				@this.EmitCall(instanceLocal?.LocalType, pi.GetSetMethod(nonPublic: true));
			};
		}

		private WriteBack AddressOfWriteBack(IndexExpression node)
		{
			if (node.Indexer == null || !node.Indexer.CanWrite)
			{
				return null;
			}
			return AddressOfWriteBackCore(node);
		}

		private WriteBack AddressOfWriteBackCore(IndexExpression node)
		{
			LocalBuilder instanceLocal = null;
			Type type = null;
			if (node.Object != null)
			{
				EmitInstance(node.Object, out type);
				_ilg.Emit(OpCodes.Dup);
				_ilg.Emit(OpCodes.Stloc, instanceLocal = GetInstanceLocal(type));
			}
			int argumentCount = node.ArgumentCount;
			LocalBuilder[] args = new LocalBuilder[argumentCount];
			for (int i = 0; i < argumentCount; i++)
			{
				Expression argument = node.GetArgument(i);
				EmitExpression(argument);
				LocalBuilder local = GetLocal(argument.Type);
				_ilg.Emit(OpCodes.Dup);
				_ilg.Emit(OpCodes.Stloc, local);
				args[i] = local;
			}
			EmitGetIndexCall(node, type);
			LocalBuilder valueLocal = GetLocal(node.Type);
			_ilg.Emit(OpCodes.Stloc, valueLocal);
			_ilg.Emit(OpCodes.Ldloca, valueLocal);
			return delegate(LambdaCompiler @this)
			{
				if (instanceLocal != null)
				{
					@this._ilg.Emit(OpCodes.Ldloc, instanceLocal);
					@this.FreeLocal(instanceLocal);
				}
				LocalBuilder[] array = args;
				foreach (LocalBuilder local2 in array)
				{
					@this._ilg.Emit(OpCodes.Ldloc, local2);
					@this.FreeLocal(local2);
				}
				@this._ilg.Emit(OpCodes.Ldloc, valueLocal);
				@this.FreeLocal(valueLocal);
				@this.EmitSetIndexCall(node, instanceLocal?.LocalType);
			};
		}

		private LocalBuilder GetInstanceLocal(Type type)
		{
			Type type2 = (type.IsValueType ? type.MakeByRefType() : type);
			return GetLocal(type2);
		}

		private void EmitBinaryExpression(Expression expr)
		{
			EmitBinaryExpression(expr, CompilationFlags.EmitAsNoTail);
		}

		private void EmitBinaryExpression(Expression expr, CompilationFlags flags)
		{
			BinaryExpression binaryExpression = (BinaryExpression)expr;
			if (binaryExpression.Method != null)
			{
				EmitBinaryMethod(binaryExpression, flags);
				return;
			}
			if ((binaryExpression.NodeType == ExpressionType.Equal || binaryExpression.NodeType == ExpressionType.NotEqual) && (binaryExpression.Type == typeof(bool) || binaryExpression.Type == typeof(bool?)))
			{
				if (ConstantCheck.IsNull(binaryExpression.Left) && !ConstantCheck.IsNull(binaryExpression.Right) && binaryExpression.Right.Type.IsNullableType())
				{
					EmitNullEquality(binaryExpression.NodeType, binaryExpression.Right, binaryExpression.IsLiftedToNull);
					return;
				}
				if (ConstantCheck.IsNull(binaryExpression.Right) && !ConstantCheck.IsNull(binaryExpression.Left) && binaryExpression.Left.Type.IsNullableType())
				{
					EmitNullEquality(binaryExpression.NodeType, binaryExpression.Left, binaryExpression.IsLiftedToNull);
					return;
				}
				EmitExpression(GetEqualityOperand(binaryExpression.Left));
				EmitExpression(GetEqualityOperand(binaryExpression.Right));
			}
			else
			{
				EmitExpression(binaryExpression.Left);
				EmitExpression(binaryExpression.Right);
			}
			EmitBinaryOperator(binaryExpression.NodeType, binaryExpression.Left.Type, binaryExpression.Right.Type, binaryExpression.Type, binaryExpression.IsLiftedToNull);
		}

		private void EmitNullEquality(ExpressionType op, Expression e, bool isLiftedToNull)
		{
			if (isLiftedToNull)
			{
				EmitExpressionAsVoid(e);
				_ilg.EmitDefault(typeof(bool?), this);
				return;
			}
			EmitAddress(e, e.Type);
			_ilg.EmitHasValue(e.Type);
			if (op == ExpressionType.Equal)
			{
				_ilg.Emit(OpCodes.Ldc_I4_0);
				_ilg.Emit(OpCodes.Ceq);
			}
		}

		private void EmitBinaryMethod(BinaryExpression b, CompilationFlags flags)
		{
			if (b.IsLifted)
			{
				ParameterExpression parameterExpression = Expression.Variable(b.Left.Type.GetNonNullableType(), null);
				ParameterExpression parameterExpression2 = Expression.Variable(b.Right.Type.GetNonNullableType(), null);
				MethodCallExpression methodCallExpression = Expression.Call(null, b.Method, parameterExpression, parameterExpression2);
				EmitLift(resultType: (!b.IsLiftedToNull) ? typeof(bool) : methodCallExpression.Type.GetNullableType(), nodeType: b.NodeType, mc: methodCallExpression, paramList: new ParameterExpression[2] { parameterExpression, parameterExpression2 }, argList: new Expression[2] { b.Left, b.Right });
			}
			else
			{
				EmitMethodCallExpression(Expression.Call(null, b.Method, b.Left, b.Right), flags);
			}
		}

		private void EmitBinaryOperator(ExpressionType op, Type leftType, Type rightType, Type resultType, bool liftedToNull)
		{
			if (op == ExpressionType.ArrayIndex)
			{
				EmitGetArrayElement(leftType);
			}
			else if (leftType.IsNullableType() || rightType.IsNullableType())
			{
				EmitLiftedBinaryOp(op, leftType, rightType, resultType, liftedToNull);
			}
			else
			{
				EmitUnliftedBinaryOp(op, leftType, rightType);
			}
		}

		private void EmitUnliftedBinaryOp(ExpressionType op, Type leftType, Type rightType)
		{
			switch (op)
			{
			case ExpressionType.NotEqual:
				if (leftType.GetTypeCode() != TypeCode.Boolean)
				{
					_ilg.Emit(OpCodes.Ceq);
					_ilg.Emit(OpCodes.Ldc_I4_0);
					goto case ExpressionType.Equal;
				}
				goto case ExpressionType.ExclusiveOr;
			case ExpressionType.Equal:
				_ilg.Emit(OpCodes.Ceq);
				return;
			case ExpressionType.Add:
				_ilg.Emit(OpCodes.Add);
				break;
			case ExpressionType.AddChecked:
				_ilg.Emit(leftType.IsFloatingPoint() ? OpCodes.Add : (leftType.IsUnsigned() ? OpCodes.Add_Ovf_Un : OpCodes.Add_Ovf));
				break;
			case ExpressionType.Subtract:
				_ilg.Emit(OpCodes.Sub);
				break;
			case ExpressionType.SubtractChecked:
				if (leftType.IsUnsigned())
				{
					_ilg.Emit(OpCodes.Sub_Ovf_Un);
					return;
				}
				_ilg.Emit(leftType.IsFloatingPoint() ? OpCodes.Sub : OpCodes.Sub_Ovf);
				break;
			case ExpressionType.Multiply:
				_ilg.Emit(OpCodes.Mul);
				break;
			case ExpressionType.MultiplyChecked:
				_ilg.Emit(leftType.IsFloatingPoint() ? OpCodes.Mul : (leftType.IsUnsigned() ? OpCodes.Mul_Ovf_Un : OpCodes.Mul_Ovf));
				break;
			case ExpressionType.Divide:
				_ilg.Emit(leftType.IsUnsigned() ? OpCodes.Div_Un : OpCodes.Div);
				break;
			case ExpressionType.Modulo:
				_ilg.Emit(leftType.IsUnsigned() ? OpCodes.Rem_Un : OpCodes.Rem);
				return;
			case ExpressionType.And:
			case ExpressionType.AndAlso:
				_ilg.Emit(OpCodes.And);
				return;
			case ExpressionType.Or:
			case ExpressionType.OrElse:
				_ilg.Emit(OpCodes.Or);
				return;
			case ExpressionType.LessThan:
				_ilg.Emit(leftType.IsUnsigned() ? OpCodes.Clt_Un : OpCodes.Clt);
				return;
			case ExpressionType.LessThanOrEqual:
				_ilg.Emit((leftType.IsUnsigned() || leftType.IsFloatingPoint()) ? OpCodes.Cgt_Un : OpCodes.Cgt);
				_ilg.Emit(OpCodes.Ldc_I4_0);
				_ilg.Emit(OpCodes.Ceq);
				return;
			case ExpressionType.GreaterThan:
				_ilg.Emit(leftType.IsUnsigned() ? OpCodes.Cgt_Un : OpCodes.Cgt);
				return;
			case ExpressionType.GreaterThanOrEqual:
				_ilg.Emit((leftType.IsUnsigned() || leftType.IsFloatingPoint()) ? OpCodes.Clt_Un : OpCodes.Clt);
				_ilg.Emit(OpCodes.Ldc_I4_0);
				_ilg.Emit(OpCodes.Ceq);
				return;
			case ExpressionType.ExclusiveOr:
				_ilg.Emit(OpCodes.Xor);
				return;
			case ExpressionType.LeftShift:
				EmitShiftMask(leftType);
				_ilg.Emit(OpCodes.Shl);
				break;
			case ExpressionType.RightShift:
				EmitShiftMask(leftType);
				_ilg.Emit(leftType.IsUnsigned() ? OpCodes.Shr_Un : OpCodes.Shr);
				return;
			}
			EmitConvertArithmeticResult(op, leftType);
		}

		private void EmitShiftMask(Type leftType)
		{
			int value = (leftType.IsInteger64() ? 63 : 31);
			_ilg.EmitPrimitive(value);
			_ilg.Emit(OpCodes.And);
		}

		private void EmitConvertArithmeticResult(ExpressionType op, Type resultType)
		{
			switch (resultType.GetTypeCode())
			{
			case TypeCode.Byte:
				_ilg.Emit(IsChecked(op) ? OpCodes.Conv_Ovf_U1 : OpCodes.Conv_U1);
				break;
			case TypeCode.SByte:
				_ilg.Emit(IsChecked(op) ? OpCodes.Conv_Ovf_I1 : OpCodes.Conv_I1);
				break;
			case TypeCode.UInt16:
				_ilg.Emit(IsChecked(op) ? OpCodes.Conv_Ovf_U2 : OpCodes.Conv_U2);
				break;
			case TypeCode.Int16:
				_ilg.Emit(IsChecked(op) ? OpCodes.Conv_Ovf_I2 : OpCodes.Conv_I2);
				break;
			}
		}

		private void EmitLiftedBinaryOp(ExpressionType op, Type leftType, Type rightType, Type resultType, bool liftedToNull)
		{
			switch (op)
			{
			case ExpressionType.And:
				if (leftType == typeof(bool?))
				{
					EmitLiftedBooleanAnd();
				}
				else
				{
					EmitLiftedBinaryArithmetic(op, leftType, rightType, resultType);
				}
				break;
			case ExpressionType.Or:
				if (leftType == typeof(bool?))
				{
					EmitLiftedBooleanOr();
				}
				else
				{
					EmitLiftedBinaryArithmetic(op, leftType, rightType, resultType);
				}
				break;
			case ExpressionType.Add:
			case ExpressionType.AddChecked:
			case ExpressionType.Divide:
			case ExpressionType.ExclusiveOr:
			case ExpressionType.LeftShift:
			case ExpressionType.Modulo:
			case ExpressionType.Multiply:
			case ExpressionType.MultiplyChecked:
			case ExpressionType.RightShift:
			case ExpressionType.Subtract:
			case ExpressionType.SubtractChecked:
				EmitLiftedBinaryArithmetic(op, leftType, rightType, resultType);
				break;
			case ExpressionType.Equal:
			case ExpressionType.GreaterThan:
			case ExpressionType.GreaterThanOrEqual:
			case ExpressionType.LessThan:
			case ExpressionType.LessThanOrEqual:
			case ExpressionType.NotEqual:
				if (liftedToNull)
				{
					EmitLiftedToNullRelational(op, leftType);
				}
				else
				{
					EmitLiftedRelational(op, leftType);
				}
				break;
			}
		}

		private void EmitLiftedRelational(ExpressionType op, Type type)
		{
			bool num = op == ExpressionType.NotEqual;
			if (num)
			{
				op = ExpressionType.Equal;
			}
			LocalBuilder local = GetLocal(type);
			LocalBuilder local2 = GetLocal(type);
			_ilg.Emit(OpCodes.Stloc, local2);
			_ilg.Emit(OpCodes.Stloc, local);
			_ilg.Emit(OpCodes.Ldloca, local);
			_ilg.EmitGetValueOrDefault(type);
			_ilg.Emit(OpCodes.Ldloca, local2);
			_ilg.EmitGetValueOrDefault(type);
			Type nonNullableType = type.GetNonNullableType();
			EmitUnliftedBinaryOp(op, nonNullableType, nonNullableType);
			_ilg.Emit(OpCodes.Ldloca, local);
			_ilg.EmitHasValue(type);
			_ilg.Emit(OpCodes.Ldloca, local2);
			_ilg.EmitHasValue(type);
			FreeLocal(local);
			FreeLocal(local2);
			_ilg.Emit((op == ExpressionType.Equal) ? OpCodes.Ceq : OpCodes.And);
			_ilg.Emit(OpCodes.And);
			if (num)
			{
				_ilg.Emit(OpCodes.Ldc_I4_0);
				_ilg.Emit(OpCodes.Ceq);
			}
		}

		private void EmitLiftedToNullRelational(ExpressionType op, Type type)
		{
			Label label = _ilg.DefineLabel();
			Label label2 = _ilg.DefineLabel();
			LocalBuilder local = GetLocal(type);
			LocalBuilder local2 = GetLocal(type);
			_ilg.Emit(OpCodes.Stloc, local2);
			_ilg.Emit(OpCodes.Stloc, local);
			_ilg.Emit(OpCodes.Ldloca, local);
			_ilg.EmitHasValue(type);
			_ilg.Emit(OpCodes.Ldloca, local2);
			_ilg.EmitHasValue(type);
			_ilg.Emit(OpCodes.And);
			_ilg.Emit(OpCodes.Brtrue_S, label);
			_ilg.EmitDefault(typeof(bool?), this);
			_ilg.Emit(OpCodes.Br_S, label2);
			_ilg.MarkLabel(label);
			_ilg.Emit(OpCodes.Ldloca, local);
			_ilg.EmitGetValueOrDefault(type);
			_ilg.Emit(OpCodes.Ldloca, local2);
			_ilg.EmitGetValueOrDefault(type);
			FreeLocal(local);
			FreeLocal(local2);
			Type nonNullableType = type.GetNonNullableType();
			EmitUnliftedBinaryOp(op, nonNullableType, nonNullableType);
			_ilg.Emit(OpCodes.Newobj, CachedReflectionInfo.Nullable_Boolean_Ctor);
			_ilg.MarkLabel(label2);
		}

		private void EmitLiftedBinaryArithmetic(ExpressionType op, Type leftType, Type rightType, Type resultType)
		{
			bool flag = leftType.IsNullableType();
			bool num = rightType.IsNullableType();
			Label label = _ilg.DefineLabel();
			Label label2 = _ilg.DefineLabel();
			LocalBuilder local = GetLocal(leftType);
			LocalBuilder local2 = GetLocal(rightType);
			LocalBuilder local3 = GetLocal(resultType);
			_ilg.Emit(OpCodes.Stloc, local2);
			_ilg.Emit(OpCodes.Stloc, local);
			if (flag)
			{
				_ilg.Emit(OpCodes.Ldloca, local);
				_ilg.EmitHasValue(leftType);
			}
			if (num)
			{
				_ilg.Emit(OpCodes.Ldloca, local2);
				_ilg.EmitHasValue(rightType);
				if (flag)
				{
					_ilg.Emit(OpCodes.And);
				}
			}
			_ilg.Emit(OpCodes.Brfalse_S, label);
			if (flag)
			{
				_ilg.Emit(OpCodes.Ldloca, local);
				_ilg.EmitGetValueOrDefault(leftType);
			}
			else
			{
				_ilg.Emit(OpCodes.Ldloc, local);
			}
			if (num)
			{
				_ilg.Emit(OpCodes.Ldloca, local2);
				_ilg.EmitGetValueOrDefault(rightType);
			}
			else
			{
				_ilg.Emit(OpCodes.Ldloc, local2);
			}
			FreeLocal(local);
			FreeLocal(local2);
			EmitBinaryOperator(op, leftType.GetNonNullableType(), rightType.GetNonNullableType(), resultType.GetNonNullableType(), liftedToNull: false);
			ConstructorInfo constructor = resultType.GetConstructor(new Type[1] { resultType.GetNonNullableType() });
			_ilg.Emit(OpCodes.Newobj, constructor);
			_ilg.Emit(OpCodes.Stloc, local3);
			_ilg.Emit(OpCodes.Br_S, label2);
			_ilg.MarkLabel(label);
			_ilg.Emit(OpCodes.Ldloca, local3);
			_ilg.Emit(OpCodes.Initobj, resultType);
			_ilg.MarkLabel(label2);
			_ilg.Emit(OpCodes.Ldloc, local3);
			FreeLocal(local3);
		}

		private void EmitLiftedBooleanAnd()
		{
			Type typeFromHandle = typeof(bool?);
			Label label = _ilg.DefineLabel();
			Label label2 = _ilg.DefineLabel();
			LocalBuilder local = GetLocal(typeFromHandle);
			LocalBuilder local2 = GetLocal(typeFromHandle);
			_ilg.Emit(OpCodes.Stloc, local2);
			_ilg.Emit(OpCodes.Stloc, local);
			_ilg.Emit(OpCodes.Ldloca, local);
			_ilg.EmitGetValueOrDefault(typeFromHandle);
			_ilg.Emit(OpCodes.Brtrue_S, label);
			_ilg.Emit(OpCodes.Ldloca, local);
			_ilg.EmitHasValue(typeFromHandle);
			_ilg.Emit(OpCodes.Ldloca, local2);
			_ilg.EmitGetValueOrDefault(typeFromHandle);
			_ilg.Emit(OpCodes.Or);
			_ilg.Emit(OpCodes.Brfalse_S, label);
			_ilg.Emit(OpCodes.Ldloc, local);
			FreeLocal(local);
			_ilg.Emit(OpCodes.Br_S, label2);
			_ilg.MarkLabel(label);
			_ilg.Emit(OpCodes.Ldloc, local2);
			FreeLocal(local2);
			_ilg.MarkLabel(label2);
		}

		private void EmitLiftedBooleanOr()
		{
			Type typeFromHandle = typeof(bool?);
			Label label = _ilg.DefineLabel();
			Label label2 = _ilg.DefineLabel();
			LocalBuilder local = GetLocal(typeFromHandle);
			LocalBuilder local2 = GetLocal(typeFromHandle);
			_ilg.Emit(OpCodes.Stloc, local2);
			_ilg.Emit(OpCodes.Stloc, local);
			_ilg.Emit(OpCodes.Ldloca, local);
			_ilg.EmitGetValueOrDefault(typeFromHandle);
			_ilg.Emit(OpCodes.Brtrue_S, label);
			_ilg.Emit(OpCodes.Ldloca, local2);
			_ilg.EmitGetValueOrDefault(typeFromHandle);
			_ilg.Emit(OpCodes.Ldloca, local);
			_ilg.EmitHasValue(typeFromHandle);
			_ilg.Emit(OpCodes.Or);
			_ilg.Emit(OpCodes.Brfalse_S, label);
			_ilg.Emit(OpCodes.Ldloc, local2);
			FreeLocal(local2);
			_ilg.Emit(OpCodes.Br_S, label2);
			_ilg.MarkLabel(label);
			_ilg.Emit(OpCodes.Ldloc, local);
			FreeLocal(local);
			_ilg.MarkLabel(label2);
		}

		private LabelInfo EnsureLabel(LabelTarget node)
		{
			if (!_labelInfo.TryGetValue(node, out var value))
			{
				_labelInfo.Add(node, value = new LabelInfo(_ilg, node, canReturn: false));
			}
			return value;
		}

		private LabelInfo ReferenceLabel(LabelTarget node)
		{
			LabelInfo labelInfo = EnsureLabel(node);
			labelInfo.Reference(_labelBlock);
			return labelInfo;
		}

		private LabelInfo DefineLabel(LabelTarget node)
		{
			if (node == null)
			{
				return new LabelInfo(_ilg, null, canReturn: false);
			}
			LabelInfo labelInfo = EnsureLabel(node);
			labelInfo.Define(_labelBlock);
			return labelInfo;
		}

		private void PushLabelBlock(LabelScopeKind type)
		{
			_labelBlock = new LabelScopeInfo(_labelBlock, type);
		}

		private void PopLabelBlock(LabelScopeKind kind)
		{
			_labelBlock = _labelBlock.Parent;
		}

		private void EmitLabelExpression(Expression expr, CompilationFlags flags)
		{
			LabelExpression labelExpression = (LabelExpression)expr;
			LabelInfo info = null;
			if (_labelBlock.Kind == LabelScopeKind.Block)
			{
				_labelBlock.TryGetLabelInfo(labelExpression.Target, out info);
				if (info == null && _labelBlock.Parent.Kind == LabelScopeKind.Switch)
				{
					_labelBlock.Parent.TryGetLabelInfo(labelExpression.Target, out info);
				}
			}
			if (info == null)
			{
				info = DefineLabel(labelExpression.Target);
			}
			if (labelExpression.DefaultValue != null)
			{
				if (labelExpression.Target.Type == typeof(void))
				{
					EmitExpressionAsVoid(labelExpression.DefaultValue, flags);
				}
				else
				{
					flags = UpdateEmitExpressionStartFlag(flags, CompilationFlags.EmitExpressionStart);
					EmitExpression(labelExpression.DefaultValue, flags);
				}
			}
			info.Mark();
		}

		private void EmitGotoExpression(Expression expr, CompilationFlags flags)
		{
			GotoExpression gotoExpression = (GotoExpression)expr;
			LabelInfo labelInfo = ReferenceLabel(gotoExpression.Target);
			CompilationFlags compilationFlags = flags & CompilationFlags.EmitAsTailCallMask;
			if (compilationFlags != CompilationFlags.EmitAsNoTail)
			{
				compilationFlags = (labelInfo.CanReturn ? CompilationFlags.EmitAsTail : CompilationFlags.EmitAsNoTail);
				flags = UpdateEmitAsTailCallFlag(flags, compilationFlags);
			}
			if (gotoExpression.Value != null)
			{
				if (gotoExpression.Target.Type == typeof(void))
				{
					EmitExpressionAsVoid(gotoExpression.Value, flags);
				}
				else
				{
					flags = UpdateEmitExpressionStartFlag(flags, CompilationFlags.EmitExpressionStart);
					EmitExpression(gotoExpression.Value, flags);
				}
			}
			labelInfo.EmitJump();
			EmitUnreachable(gotoExpression, flags);
		}

		private void EmitUnreachable(Expression node, CompilationFlags flags)
		{
			if (node.Type != typeof(void) && (flags & CompilationFlags.EmitAsVoidType) == 0)
			{
				_ilg.EmitDefault(node.Type, this);
			}
		}

		private bool TryPushLabelBlock(Expression node)
		{
			switch (node.NodeType)
			{
			default:
				if (_labelBlock.Kind != LabelScopeKind.Expression)
				{
					PushLabelBlock(LabelScopeKind.Expression);
					return true;
				}
				return false;
			case ExpressionType.Label:
				if (_labelBlock.Kind == LabelScopeKind.Block)
				{
					LabelTarget target = ((LabelExpression)node).Target;
					if (_labelBlock.ContainsTarget(target))
					{
						return false;
					}
					if (_labelBlock.Parent.Kind == LabelScopeKind.Switch && _labelBlock.Parent.ContainsTarget(target))
					{
						return false;
					}
				}
				PushLabelBlock(LabelScopeKind.Statement);
				return true;
			case ExpressionType.Block:
				if (!(node is SpilledExpressionBlock))
				{
					PushLabelBlock(LabelScopeKind.Block);
					if (_labelBlock.Parent.Kind != LabelScopeKind.Switch)
					{
						DefineBlockLabels(node);
					}
					return true;
				}
				goto default;
			case ExpressionType.Switch:
			{
				PushLabelBlock(LabelScopeKind.Switch);
				SwitchExpression switchExpression = (SwitchExpression)node;
				foreach (SwitchCase @case in switchExpression.Cases)
				{
					DefineBlockLabels(@case.Body);
				}
				DefineBlockLabels(switchExpression.DefaultBody);
				return true;
			}
			case ExpressionType.Convert:
				if (!(node.Type != typeof(void)))
				{
					PushLabelBlock(LabelScopeKind.Statement);
					return true;
				}
				goto default;
			case ExpressionType.Conditional:
			case ExpressionType.Goto:
			case ExpressionType.Loop:
				PushLabelBlock(LabelScopeKind.Statement);
				return true;
			}
		}

		private void DefineBlockLabels(Expression node)
		{
			if (!(node is BlockExpression blockExpression) || blockExpression is SpilledExpressionBlock)
			{
				return;
			}
			int i = 0;
			for (int expressionCount = blockExpression.ExpressionCount; i < expressionCount; i++)
			{
				if (blockExpression.GetExpression(i) is LabelExpression labelExpression)
				{
					DefineLabel(labelExpression.Target);
				}
			}
		}

		private void AddReturnLabel(LambdaExpression lambda)
		{
			Expression expression = lambda.Body;
			while (true)
			{
				switch (expression.NodeType)
				{
				default:
					return;
				case ExpressionType.Label:
				{
					LabelTarget target = ((LabelExpression)expression).Target;
					_labelInfo.Add(target, new LabelInfo(_ilg, target, TypeUtils.AreReferenceAssignable(lambda.ReturnType, target.Type)));
					return;
				}
				case ExpressionType.Block:
				{
					BlockExpression blockExpression = (BlockExpression)expression;
					if (blockExpression.ExpressionCount == 0)
					{
						return;
					}
					for (int num = blockExpression.ExpressionCount - 1; num >= 0; num--)
					{
						expression = blockExpression.GetExpression(num);
						if (Significant(expression))
						{
							break;
						}
					}
					break;
				}
				}
			}
		}

		private static CompilationFlags UpdateEmitAsTailCallFlag(CompilationFlags flags, CompilationFlags newValue)
		{
			CompilationFlags compilationFlags = flags & CompilationFlags.EmitAsTailCallMask;
			return (flags ^ compilationFlags) | newValue;
		}

		private static CompilationFlags UpdateEmitExpressionStartFlag(CompilationFlags flags, CompilationFlags newValue)
		{
			CompilationFlags compilationFlags = flags & CompilationFlags.EmitExpressionStartMask;
			return (flags ^ compilationFlags) | newValue;
		}

		private static CompilationFlags UpdateEmitAsTypeFlag(CompilationFlags flags, CompilationFlags newValue)
		{
			CompilationFlags compilationFlags = flags & CompilationFlags.EmitAsTypeMask;
			return (flags ^ compilationFlags) | newValue;
		}

		internal void EmitExpression(Expression node)
		{
			EmitExpression(node, CompilationFlags.EmitExpressionStart | CompilationFlags.EmitAsNoTail);
		}

		private void EmitExpressionAsVoid(Expression node)
		{
			EmitExpressionAsVoid(node, CompilationFlags.EmitAsNoTail);
		}

		private void EmitExpressionAsVoid(Expression node, CompilationFlags flags)
		{
			CompilationFlags flags2 = EmitExpressionStart(node);
			switch (node.NodeType)
			{
			case ExpressionType.Assign:
				EmitAssign((AssignBinaryExpression)node, CompilationFlags.EmitAsVoidType);
				break;
			case ExpressionType.Block:
				Emit((BlockExpression)node, UpdateEmitAsTypeFlag(flags, CompilationFlags.EmitAsVoidType));
				break;
			case ExpressionType.Throw:
				EmitThrow((UnaryExpression)node, CompilationFlags.EmitAsVoidType);
				break;
			case ExpressionType.Goto:
				EmitGotoExpression(node, UpdateEmitAsTypeFlag(flags, CompilationFlags.EmitAsVoidType));
				break;
			default:
				if (node.Type == typeof(void))
				{
					EmitExpression(node, UpdateEmitExpressionStartFlag(flags, CompilationFlags.EmitNoExpressionStart));
					break;
				}
				EmitExpression(node, CompilationFlags.EmitNoExpressionStart | CompilationFlags.EmitAsNoTail);
				_ilg.Emit(OpCodes.Pop);
				break;
			case ExpressionType.Constant:
			case ExpressionType.Parameter:
			case ExpressionType.Default:
				break;
			}
			EmitExpressionEnd(flags2);
		}

		private void EmitExpressionAsType(Expression node, Type type, CompilationFlags flags)
		{
			if (type == typeof(void))
			{
				EmitExpressionAsVoid(node, flags);
			}
			else if (!TypeUtils.AreEquivalent(node.Type, type))
			{
				EmitExpression(node);
				_ilg.Emit(OpCodes.Castclass, type);
			}
			else
			{
				EmitExpression(node, UpdateEmitExpressionStartFlag(flags, CompilationFlags.EmitExpressionStart));
			}
		}

		private CompilationFlags EmitExpressionStart(Expression node)
		{
			if (TryPushLabelBlock(node))
			{
				return CompilationFlags.EmitExpressionStart;
			}
			return CompilationFlags.EmitNoExpressionStart;
		}

		private void EmitExpressionEnd(CompilationFlags flags)
		{
			if ((flags & CompilationFlags.EmitExpressionStartMask) == CompilationFlags.EmitExpressionStart)
			{
				PopLabelBlock(_labelBlock.Kind);
			}
		}

		private void EmitInvocationExpression(Expression expr, CompilationFlags flags)
		{
			InvocationExpression invocationExpression = (InvocationExpression)expr;
			if (invocationExpression.LambdaOperand != null)
			{
				EmitInlinedInvoke(invocationExpression, flags);
				return;
			}
			expr = invocationExpression.Expression;
			EmitMethodCall(expr, expr.Type.GetInvokeMethod(), invocationExpression, CompilationFlags.EmitExpressionStart | CompilationFlags.EmitAsNoTail);
		}

		private void EmitInlinedInvoke(InvocationExpression invoke, CompilationFlags flags)
		{
			LambdaExpression lambdaOperand = invoke.LambdaOperand;
			List<WriteBack> list = EmitArguments(lambdaOperand.Type.GetInvokeMethod(), invoke);
			LambdaCompiler lambdaCompiler = new LambdaCompiler(this, lambdaOperand, invoke);
			if (list != null)
			{
				flags = UpdateEmitAsTailCallFlag(flags, CompilationFlags.EmitAsNoTail);
			}
			lambdaCompiler.EmitLambdaBody(_scope, inlined: true, flags);
			EmitWriteBack(list);
		}

		private void EmitIndexExpression(Expression expr)
		{
			IndexExpression indexExpression = (IndexExpression)expr;
			Type type = null;
			if (indexExpression.Object != null)
			{
				EmitInstance(indexExpression.Object, out type);
			}
			int i = 0;
			for (int argumentCount = indexExpression.ArgumentCount; i < argumentCount; i++)
			{
				Expression argument = indexExpression.GetArgument(i);
				EmitExpression(argument);
			}
			EmitGetIndexCall(indexExpression, type);
		}

		private void EmitIndexAssignment(AssignBinaryExpression node, CompilationFlags flags)
		{
			IndexExpression indexExpression = (IndexExpression)node.Left;
			CompilationFlags compilationFlags = flags & CompilationFlags.EmitAsTypeMask;
			Type type = null;
			if (indexExpression.Object != null)
			{
				EmitInstance(indexExpression.Object, out type);
			}
			int i = 0;
			for (int argumentCount = indexExpression.ArgumentCount; i < argumentCount; i++)
			{
				Expression argument = indexExpression.GetArgument(i);
				EmitExpression(argument);
			}
			EmitExpression(node.Right);
			LocalBuilder local = null;
			if (compilationFlags != CompilationFlags.EmitAsVoidType)
			{
				_ilg.Emit(OpCodes.Dup);
				_ilg.Emit(OpCodes.Stloc, local = GetLocal(node.Type));
			}
			EmitSetIndexCall(indexExpression, type);
			if (compilationFlags != CompilationFlags.EmitAsVoidType)
			{
				_ilg.Emit(OpCodes.Ldloc, local);
				FreeLocal(local);
			}
		}

		private void EmitGetIndexCall(IndexExpression node, Type objectType)
		{
			if (node.Indexer != null)
			{
				MethodInfo getMethod = node.Indexer.GetGetMethod(nonPublic: true);
				EmitCall(objectType, getMethod);
			}
			else
			{
				EmitGetArrayElement(objectType);
			}
		}

		private void EmitGetArrayElement(Type arrayType)
		{
			if (arrayType.IsSZArray)
			{
				_ilg.EmitLoadElement(arrayType.GetElementType());
			}
			else
			{
				_ilg.Emit(OpCodes.Call, arrayType.GetMethod("Get", BindingFlags.Instance | BindingFlags.Public));
			}
		}

		private void EmitSetIndexCall(IndexExpression node, Type objectType)
		{
			if (node.Indexer != null)
			{
				MethodInfo setMethod = node.Indexer.GetSetMethod(nonPublic: true);
				EmitCall(objectType, setMethod);
			}
			else
			{
				EmitSetArrayElement(objectType);
			}
		}

		private void EmitSetArrayElement(Type arrayType)
		{
			if (arrayType.IsSZArray)
			{
				_ilg.EmitStoreElement(arrayType.GetElementType());
			}
			else
			{
				_ilg.Emit(OpCodes.Call, arrayType.GetMethod("Set", BindingFlags.Instance | BindingFlags.Public));
			}
		}

		private void EmitMethodCallExpression(Expression expr, CompilationFlags flags)
		{
			MethodCallExpression methodCallExpression = (MethodCallExpression)expr;
			EmitMethodCall(methodCallExpression.Object, methodCallExpression.Method, methodCallExpression, flags);
		}

		private void EmitMethodCallExpression(Expression expr)
		{
			EmitMethodCallExpression(expr, CompilationFlags.EmitAsNoTail);
		}

		private void EmitMethodCall(Expression obj, MethodInfo method, IArgumentProvider methodCallExpr)
		{
			EmitMethodCall(obj, method, methodCallExpr, CompilationFlags.EmitAsNoTail);
		}

		private void EmitMethodCall(Expression obj, MethodInfo method, IArgumentProvider methodCallExpr, CompilationFlags flags)
		{
			Type type = null;
			if (!method.IsStatic)
			{
				EmitInstance(obj, out type);
			}
			if (obj != null && obj.Type.IsValueType)
			{
				EmitMethodCall(method, methodCallExpr, type);
			}
			else
			{
				EmitMethodCall(method, methodCallExpr, type, flags);
			}
		}

		private void EmitMethodCall(MethodInfo mi, IArgumentProvider args, Type objectType)
		{
			EmitMethodCall(mi, args, objectType, CompilationFlags.EmitAsNoTail);
		}

		private void EmitMethodCall(MethodInfo mi, IArgumentProvider args, Type objectType, CompilationFlags flags)
		{
			List<WriteBack> writeBacks = EmitArguments(mi, args);
			OpCode opCode = (UseVirtual(mi) ? OpCodes.Callvirt : OpCodes.Call);
			if (opCode == OpCodes.Callvirt && objectType.IsValueType)
			{
				_ilg.Emit(OpCodes.Constrained, objectType);
			}
			if ((flags & CompilationFlags.EmitAsTailCallMask) == CompilationFlags.EmitAsTail && !MethodHasByRefParameter(mi))
			{
				_ilg.Emit(OpCodes.Tailcall);
			}
			if (mi.CallingConvention == CallingConventions.VarArgs)
			{
				int argumentCount = args.ArgumentCount;
				Type[] array = new Type[argumentCount];
				for (int i = 0; i < argumentCount; i++)
				{
					array[i] = args.GetArgument(i).Type;
				}
				_ilg.EmitCall(opCode, mi, array);
			}
			else
			{
				_ilg.Emit(opCode, mi);
			}
			EmitWriteBack(writeBacks);
		}

		private static bool MethodHasByRefParameter(MethodInfo mi)
		{
			ParameterInfo[] parametersCached = mi.GetParametersCached();
			for (int i = 0; i < parametersCached.Length; i++)
			{
				if (parametersCached[i].IsByRefParameter())
				{
					return true;
				}
			}
			return false;
		}

		private void EmitCall(Type objectType, MethodInfo method)
		{
			if (method.CallingConvention == CallingConventions.VarArgs)
			{
				throw Error.UnexpectedVarArgsCall(method);
			}
			OpCode opCode = (UseVirtual(method) ? OpCodes.Callvirt : OpCodes.Call);
			if (opCode == OpCodes.Callvirt && objectType.IsValueType)
			{
				_ilg.Emit(OpCodes.Constrained, objectType);
			}
			_ilg.Emit(opCode, method);
		}

		private static bool UseVirtual(MethodInfo mi)
		{
			if (mi.IsStatic)
			{
				return false;
			}
			if (mi.DeclaringType.IsValueType)
			{
				return false;
			}
			return true;
		}

		private List<WriteBack> EmitArguments(MethodBase method, IArgumentProvider args)
		{
			return EmitArguments(method, args, 0);
		}

		private List<WriteBack> EmitArguments(MethodBase method, IArgumentProvider args, int skipParameters)
		{
			ParameterInfo[] parametersCached = method.GetParametersCached();
			List<WriteBack> list = null;
			int i = skipParameters;
			for (int num = parametersCached.Length; i < num; i++)
			{
				ParameterInfo obj = parametersCached[i];
				Expression argument = args.GetArgument(i - skipParameters);
				Type parameterType = obj.ParameterType;
				if (parameterType.IsByRef)
				{
					parameterType = parameterType.GetElementType();
					WriteBack writeBack = EmitAddressWriteBack(argument, parameterType);
					if (writeBack != null)
					{
						if (list == null)
						{
							list = new List<WriteBack>();
						}
						list.Add(writeBack);
					}
				}
				else
				{
					EmitExpression(argument);
				}
			}
			return list;
		}

		private void EmitWriteBack(List<WriteBack> writeBacks)
		{
			if (writeBacks == null)
			{
				return;
			}
			foreach (WriteBack writeBack in writeBacks)
			{
				writeBack(this);
			}
		}

		private void EmitConstantExpression(Expression expr)
		{
			ConstantExpression constantExpression = (ConstantExpression)expr;
			EmitConstant(constantExpression.Value, constantExpression.Type);
		}

		private void EmitConstant(object value)
		{
			EmitConstant(value, value.GetType());
		}

		private void EmitConstant(object value, Type type)
		{
			if (!_ilg.TryEmitConstant(value, type, this))
			{
				_boundConstants.EmitConstant(this, value, type);
			}
		}

		private void EmitDynamicExpression(Expression expr)
		{
			if (!(_method is DynamicMethod))
			{
				throw Error.CannotCompileDynamic();
			}
			IDynamicExpression dynamicExpression = (IDynamicExpression)expr;
			object obj = dynamicExpression.CreateCallSite();
			Type type = obj.GetType();
			MethodInfo invokeMethod = dynamicExpression.DelegateType.GetInvokeMethod();
			EmitConstant(obj, type);
			_ilg.Emit(OpCodes.Dup);
			LocalBuilder local = GetLocal(type);
			_ilg.Emit(OpCodes.Stloc, local);
			_ilg.Emit(OpCodes.Ldfld, type.GetField("Target"));
			_ilg.Emit(OpCodes.Ldloc, local);
			FreeLocal(local);
			List<WriteBack> writeBacks = EmitArguments(invokeMethod, dynamicExpression, 1);
			_ilg.Emit(OpCodes.Callvirt, invokeMethod);
			EmitWriteBack(writeBacks);
		}

		private void EmitNewExpression(Expression expr)
		{
			NewExpression newExpression = (NewExpression)expr;
			if (newExpression.Constructor != null)
			{
				if (newExpression.Constructor.DeclaringType.IsAbstract)
				{
					throw Error.NonAbstractConstructorRequired();
				}
				List<WriteBack> writeBacks = EmitArguments(newExpression.Constructor, newExpression);
				_ilg.Emit(OpCodes.Newobj, newExpression.Constructor);
				EmitWriteBack(writeBacks);
			}
			else
			{
				LocalBuilder local = GetLocal(newExpression.Type);
				_ilg.Emit(OpCodes.Ldloca, local);
				_ilg.Emit(OpCodes.Initobj, newExpression.Type);
				_ilg.Emit(OpCodes.Ldloc, local);
				FreeLocal(local);
			}
		}

		private void EmitTypeBinaryExpression(Expression expr)
		{
			TypeBinaryExpression typeBinaryExpression = (TypeBinaryExpression)expr;
			if (typeBinaryExpression.NodeType == ExpressionType.TypeEqual)
			{
				EmitExpression(typeBinaryExpression.ReduceTypeEqual());
				return;
			}
			Type type = typeBinaryExpression.Expression.Type;
			AnalyzeTypeIsResult analyzeTypeIsResult = ConstantCheck.AnalyzeTypeIs(typeBinaryExpression);
			switch (analyzeTypeIsResult)
			{
			case AnalyzeTypeIsResult.KnownFalse:
			case AnalyzeTypeIsResult.KnownTrue:
				EmitExpressionAsVoid(typeBinaryExpression.Expression);
				_ilg.EmitPrimitive(analyzeTypeIsResult == AnalyzeTypeIsResult.KnownTrue);
				return;
			case AnalyzeTypeIsResult.KnownAssignable:
				if (type.IsNullableType())
				{
					EmitAddress(typeBinaryExpression.Expression, type);
					_ilg.EmitHasValue(type);
				}
				else
				{
					EmitExpression(typeBinaryExpression.Expression);
					_ilg.Emit(OpCodes.Ldnull);
					_ilg.Emit(OpCodes.Cgt_Un);
				}
				return;
			}
			EmitExpression(typeBinaryExpression.Expression);
			if (type.IsValueType)
			{
				_ilg.Emit(OpCodes.Box, type);
			}
			_ilg.Emit(OpCodes.Isinst, typeBinaryExpression.TypeOperand);
			_ilg.Emit(OpCodes.Ldnull);
			_ilg.Emit(OpCodes.Cgt_Un);
		}

		private void EmitVariableAssignment(AssignBinaryExpression node, CompilationFlags flags)
		{
			ParameterExpression parameterExpression = (ParameterExpression)node.Left;
			CompilationFlags num = flags & CompilationFlags.EmitAsTypeMask;
			if (node.IsByRef)
			{
				EmitAddress(node.Right, node.Right.Type);
			}
			else
			{
				EmitExpression(node.Right);
			}
			if (num != CompilationFlags.EmitAsVoidType)
			{
				_ilg.Emit(OpCodes.Dup);
			}
			if (parameterExpression.IsByRef)
			{
				LocalBuilder local = GetLocal(parameterExpression.Type);
				_ilg.Emit(OpCodes.Stloc, local);
				_scope.EmitGet(parameterExpression);
				_ilg.Emit(OpCodes.Ldloc, local);
				FreeLocal(local);
				_ilg.EmitStoreValueIndirect(parameterExpression.Type);
			}
			else
			{
				_scope.EmitSet(parameterExpression);
			}
		}

		private void EmitAssignBinaryExpression(Expression expr)
		{
			EmitAssign((AssignBinaryExpression)expr, CompilationFlags.EmitAsDefaultType);
		}

		private void EmitAssign(AssignBinaryExpression node, CompilationFlags emitAs)
		{
			switch (node.Left.NodeType)
			{
			case ExpressionType.Index:
				EmitIndexAssignment(node, emitAs);
				break;
			case ExpressionType.MemberAccess:
				EmitMemberAssignment(node, emitAs);
				break;
			case ExpressionType.Parameter:
				EmitVariableAssignment(node, emitAs);
				break;
			default:
				throw ContractUtils.Unreachable;
			}
		}

		private void EmitParameterExpression(Expression expr)
		{
			ParameterExpression parameterExpression = (ParameterExpression)expr;
			_scope.EmitGet(parameterExpression);
			if (parameterExpression.IsByRef)
			{
				_ilg.EmitLoadValueIndirect(parameterExpression.Type);
			}
		}

		private void EmitLambdaExpression(Expression expr)
		{
			LambdaExpression lambda = (LambdaExpression)expr;
			EmitDelegateConstruction(lambda);
		}

		private void EmitRuntimeVariablesExpression(Expression expr)
		{
			RuntimeVariablesExpression runtimeVariablesExpression = (RuntimeVariablesExpression)expr;
			_scope.EmitVariableAccess(this, runtimeVariablesExpression.Variables);
		}

		private void EmitMemberAssignment(AssignBinaryExpression node, CompilationFlags flags)
		{
			MemberExpression memberExpression = (MemberExpression)node.Left;
			MemberInfo member = memberExpression.Member;
			Type type = null;
			if (memberExpression.Expression != null)
			{
				EmitInstance(memberExpression.Expression, out type);
			}
			EmitExpression(node.Right);
			LocalBuilder local = null;
			CompilationFlags num = flags & CompilationFlags.EmitAsTypeMask;
			if (num != CompilationFlags.EmitAsVoidType)
			{
				_ilg.Emit(OpCodes.Dup);
				_ilg.Emit(OpCodes.Stloc, local = GetLocal(node.Type));
			}
			if (member is FieldInfo)
			{
				_ilg.EmitFieldSet((FieldInfo)member);
			}
			else
			{
				PropertyInfo propertyInfo = (PropertyInfo)member;
				EmitCall(type, propertyInfo.GetSetMethod(nonPublic: true));
			}
			if (num != CompilationFlags.EmitAsVoidType)
			{
				_ilg.Emit(OpCodes.Ldloc, local);
				FreeLocal(local);
			}
		}

		private void EmitMemberExpression(Expression expr)
		{
			MemberExpression memberExpression = (MemberExpression)expr;
			Type type = null;
			if (memberExpression.Expression != null)
			{
				EmitInstance(memberExpression.Expression, out type);
			}
			EmitMemberGet(memberExpression.Member, type);
		}

		private void EmitMemberGet(MemberInfo member, Type objectType)
		{
			if (member is FieldInfo fieldInfo)
			{
				if (fieldInfo.IsLiteral)
				{
					EmitConstant(fieldInfo.GetRawConstantValue(), fieldInfo.FieldType);
				}
				else
				{
					_ilg.EmitFieldGet(fieldInfo);
				}
			}
			else
			{
				PropertyInfo propertyInfo = (PropertyInfo)member;
				EmitCall(objectType, propertyInfo.GetGetMethod(nonPublic: true));
			}
		}

		private void EmitInstance(Expression instance, out Type type)
		{
			type = instance.Type;
			if (type.IsByRef)
			{
				type = type.GetElementType();
				EmitExpression(instance);
			}
			else if (type.IsValueType)
			{
				EmitAddress(instance, type);
			}
			else
			{
				EmitExpression(instance);
			}
		}

		private void EmitNewArrayExpression(Expression expr)
		{
			NewArrayExpression newArrayExpression = (NewArrayExpression)expr;
			ReadOnlyCollection<Expression> expressions = newArrayExpression.Expressions;
			int count = expressions.Count;
			if (newArrayExpression.NodeType == ExpressionType.NewArrayInit)
			{
				Type elementType = newArrayExpression.Type.GetElementType();
				_ilg.EmitArray(elementType, count);
				for (int i = 0; i < count; i++)
				{
					_ilg.Emit(OpCodes.Dup);
					_ilg.EmitPrimitive(i);
					EmitExpression(expressions[i]);
					_ilg.EmitStoreElement(elementType);
				}
			}
			else
			{
				for (int j = 0; j < count; j++)
				{
					Expression expression = expressions[j];
					EmitExpression(expression);
					_ilg.EmitConvertToType(expression.Type, typeof(int), isChecked: true, this);
				}
				_ilg.EmitArray(newArrayExpression.Type);
			}
		}

		private void EmitDebugInfoExpression(Expression expr)
		{
		}

		private void EmitListInitExpression(Expression expr)
		{
			EmitListInit((ListInitExpression)expr);
		}

		private void EmitMemberInitExpression(Expression expr)
		{
			EmitMemberInit((MemberInitExpression)expr);
		}

		private void EmitBinding(MemberBinding binding, Type objectType)
		{
			switch (binding.BindingType)
			{
			case MemberBindingType.Assignment:
				EmitMemberAssignment((MemberAssignment)binding, objectType);
				break;
			case MemberBindingType.ListBinding:
				EmitMemberListBinding((MemberListBinding)binding);
				break;
			case MemberBindingType.MemberBinding:
				EmitMemberMemberBinding((MemberMemberBinding)binding);
				break;
			}
		}

		private void EmitMemberAssignment(MemberAssignment binding, Type objectType)
		{
			EmitExpression(binding.Expression);
			if (binding.Member is FieldInfo field)
			{
				_ilg.Emit(OpCodes.Stfld, field);
			}
			else
			{
				EmitCall(objectType, (binding.Member as PropertyInfo).GetSetMethod(nonPublic: true));
			}
		}

		private void EmitMemberMemberBinding(MemberMemberBinding binding)
		{
			Type memberType = GetMemberType(binding.Member);
			if (binding.Member is PropertyInfo && memberType.IsValueType)
			{
				throw Error.CannotAutoInitializeValueTypeMemberThroughProperty(binding.Member);
			}
			if (memberType.IsValueType)
			{
				EmitMemberAddress(binding.Member, binding.Member.DeclaringType);
			}
			else
			{
				EmitMemberGet(binding.Member, binding.Member.DeclaringType);
			}
			EmitMemberInit(binding.Bindings, keepOnStack: false, memberType);
		}

		private void EmitMemberListBinding(MemberListBinding binding)
		{
			Type memberType = GetMemberType(binding.Member);
			if (binding.Member is PropertyInfo && memberType.IsValueType)
			{
				throw Error.CannotAutoInitializeValueTypeElementThroughProperty(binding.Member);
			}
			if (memberType.IsValueType)
			{
				EmitMemberAddress(binding.Member, binding.Member.DeclaringType);
			}
			else
			{
				EmitMemberGet(binding.Member, binding.Member.DeclaringType);
			}
			EmitListInit(binding.Initializers, keepOnStack: false, memberType);
		}

		private void EmitMemberInit(MemberInitExpression init)
		{
			EmitExpression(init.NewExpression);
			LocalBuilder localBuilder = null;
			if (init.NewExpression.Type.IsValueType && init.Bindings.Count > 0)
			{
				localBuilder = GetLocal(init.NewExpression.Type);
				_ilg.Emit(OpCodes.Stloc, localBuilder);
				_ilg.Emit(OpCodes.Ldloca, localBuilder);
			}
			EmitMemberInit(init.Bindings, localBuilder == null, init.NewExpression.Type);
			if (localBuilder != null)
			{
				_ilg.Emit(OpCodes.Ldloc, localBuilder);
				FreeLocal(localBuilder);
			}
		}

		private void EmitMemberInit(ReadOnlyCollection<MemberBinding> bindings, bool keepOnStack, Type objectType)
		{
			int count = bindings.Count;
			if (count == 0)
			{
				if (!keepOnStack)
				{
					_ilg.Emit(OpCodes.Pop);
				}
				return;
			}
			for (int i = 0; i < count; i++)
			{
				if (keepOnStack || i < count - 1)
				{
					_ilg.Emit(OpCodes.Dup);
				}
				EmitBinding(bindings[i], objectType);
			}
		}

		private void EmitListInit(ListInitExpression init)
		{
			EmitExpression(init.NewExpression);
			LocalBuilder localBuilder = null;
			if (init.NewExpression.Type.IsValueType)
			{
				localBuilder = GetLocal(init.NewExpression.Type);
				_ilg.Emit(OpCodes.Stloc, localBuilder);
				_ilg.Emit(OpCodes.Ldloca, localBuilder);
			}
			EmitListInit(init.Initializers, localBuilder == null, init.NewExpression.Type);
			if (localBuilder != null)
			{
				_ilg.Emit(OpCodes.Ldloc, localBuilder);
				FreeLocal(localBuilder);
			}
		}

		private void EmitListInit(ReadOnlyCollection<ElementInit> initializers, bool keepOnStack, Type objectType)
		{
			int count = initializers.Count;
			if (count == 0)
			{
				if (!keepOnStack)
				{
					_ilg.Emit(OpCodes.Pop);
				}
				return;
			}
			for (int i = 0; i < count; i++)
			{
				if (keepOnStack || i < count - 1)
				{
					_ilg.Emit(OpCodes.Dup);
				}
				EmitMethodCall(initializers[i].AddMethod, initializers[i], objectType);
				if (initializers[i].AddMethod.ReturnType != typeof(void))
				{
					_ilg.Emit(OpCodes.Pop);
				}
			}
		}

		private static Type GetMemberType(MemberInfo member)
		{
			if (!(member is FieldInfo fieldInfo))
			{
				return (member as PropertyInfo).PropertyType;
			}
			return fieldInfo.FieldType;
		}

		private void EmitLift(ExpressionType nodeType, Type resultType, MethodCallExpression mc, ParameterExpression[] paramList, Expression[] argList)
		{
			switch (nodeType)
			{
			default:
			{
				Label label4 = _ilg.DefineLabel();
				Label label5 = _ilg.DefineLabel();
				LocalBuilder local3 = GetLocal(typeof(bool));
				int j = 0;
				for (int num2 = paramList.Length; j < num2; j++)
				{
					ParameterExpression variable2 = paramList[j];
					Expression expression2 = argList[j];
					if (expression2.Type.IsNullableType())
					{
						_scope.AddLocal(this, variable2);
						EmitAddress(expression2, expression2.Type);
						_ilg.Emit(OpCodes.Dup);
						_ilg.EmitHasValue(expression2.Type);
						_ilg.Emit(OpCodes.Ldc_I4_0);
						_ilg.Emit(OpCodes.Ceq);
						_ilg.Emit(OpCodes.Stloc, local3);
						_ilg.EmitGetValueOrDefault(expression2.Type);
						_scope.EmitSet(variable2);
					}
					else
					{
						_scope.AddLocal(this, variable2);
						EmitExpression(expression2);
						if (!expression2.Type.IsValueType)
						{
							_ilg.Emit(OpCodes.Dup);
							_ilg.Emit(OpCodes.Ldnull);
							_ilg.Emit(OpCodes.Ceq);
							_ilg.Emit(OpCodes.Stloc, local3);
						}
						_scope.EmitSet(variable2);
					}
					_ilg.Emit(OpCodes.Ldloc, local3);
					_ilg.Emit(OpCodes.Brtrue, label5);
				}
				EmitMethodCallExpression(mc);
				if (resultType.IsNullableType() && !TypeUtils.AreEquivalent(resultType, mc.Type))
				{
					ConstructorInfo constructor2 = resultType.GetConstructor(new Type[1] { mc.Type });
					_ilg.Emit(OpCodes.Newobj, constructor2);
				}
				_ilg.Emit(OpCodes.Br_S, label4);
				_ilg.MarkLabel(label5);
				if (TypeUtils.AreEquivalent(resultType, mc.Type.GetNullableType()))
				{
					if (resultType.IsValueType)
					{
						LocalBuilder local4 = GetLocal(resultType);
						_ilg.Emit(OpCodes.Ldloca, local4);
						_ilg.Emit(OpCodes.Initobj, resultType);
						_ilg.Emit(OpCodes.Ldloc, local4);
						FreeLocal(local4);
					}
					else
					{
						_ilg.Emit(OpCodes.Ldnull);
					}
				}
				else
				{
					_ilg.Emit(OpCodes.Ldc_I4_0);
				}
				_ilg.MarkLabel(label4);
				FreeLocal(local3);
				break;
			}
			case ExpressionType.Equal:
			case ExpressionType.NotEqual:
				if (!TypeUtils.AreEquivalent(resultType, mc.Type.GetNullableType()))
				{
					Label label = _ilg.DefineLabel();
					Label label2 = _ilg.DefineLabel();
					Label label3 = _ilg.DefineLabel();
					LocalBuilder local = GetLocal(typeof(bool));
					LocalBuilder local2 = GetLocal(typeof(bool));
					_ilg.Emit(OpCodes.Ldc_I4_0);
					_ilg.Emit(OpCodes.Stloc, local);
					_ilg.Emit(OpCodes.Ldc_I4_1);
					_ilg.Emit(OpCodes.Stloc, local2);
					int i = 0;
					for (int num = paramList.Length; i < num; i++)
					{
						ParameterExpression variable = paramList[i];
						Expression expression = argList[i];
						_scope.AddLocal(this, variable);
						if (expression.Type.IsNullableType())
						{
							EmitAddress(expression, expression.Type);
							_ilg.Emit(OpCodes.Dup);
							_ilg.EmitHasValue(expression.Type);
							_ilg.Emit(OpCodes.Ldc_I4_0);
							_ilg.Emit(OpCodes.Ceq);
							_ilg.Emit(OpCodes.Dup);
							_ilg.Emit(OpCodes.Ldloc, local);
							_ilg.Emit(OpCodes.Or);
							_ilg.Emit(OpCodes.Stloc, local);
							_ilg.Emit(OpCodes.Ldloc, local2);
							_ilg.Emit(OpCodes.And);
							_ilg.Emit(OpCodes.Stloc, local2);
							_ilg.EmitGetValueOrDefault(expression.Type);
						}
						else
						{
							EmitExpression(expression);
							if (!expression.Type.IsValueType)
							{
								_ilg.Emit(OpCodes.Dup);
								_ilg.Emit(OpCodes.Ldnull);
								_ilg.Emit(OpCodes.Ceq);
								_ilg.Emit(OpCodes.Dup);
								_ilg.Emit(OpCodes.Ldloc, local);
								_ilg.Emit(OpCodes.Or);
								_ilg.Emit(OpCodes.Stloc, local);
								_ilg.Emit(OpCodes.Ldloc, local2);
								_ilg.Emit(OpCodes.And);
								_ilg.Emit(OpCodes.Stloc, local2);
							}
							else
							{
								_ilg.Emit(OpCodes.Ldc_I4_0);
								_ilg.Emit(OpCodes.Stloc, local2);
							}
						}
						_scope.EmitSet(variable);
					}
					_ilg.Emit(OpCodes.Ldloc, local2);
					_ilg.Emit(OpCodes.Brtrue, label2);
					_ilg.Emit(OpCodes.Ldloc, local);
					_ilg.Emit(OpCodes.Brtrue, label3);
					EmitMethodCallExpression(mc);
					if (resultType.IsNullableType() && !TypeUtils.AreEquivalent(resultType, mc.Type))
					{
						ConstructorInfo constructor = resultType.GetConstructor(new Type[1] { mc.Type });
						_ilg.Emit(OpCodes.Newobj, constructor);
					}
					_ilg.Emit(OpCodes.Br_S, label);
					_ilg.MarkLabel(label2);
					_ilg.EmitPrimitive(nodeType == ExpressionType.Equal);
					_ilg.Emit(OpCodes.Br_S, label);
					_ilg.MarkLabel(label3);
					_ilg.EmitPrimitive(nodeType == ExpressionType.NotEqual);
					_ilg.MarkLabel(label);
					FreeLocal(local);
					FreeLocal(local2);
					break;
				}
				goto default;
			}
		}

		private void EmitExpression(Expression node, CompilationFlags flags)
		{
			if (!_guard.TryEnterOnCurrentStack())
			{
				_guard.RunOnEmptyStack(delegate(LambdaCompiler @this, Expression n, CompilationFlags f)
				{
					@this.EmitExpression(n, f);
				}, this, node, flags);
				return;
			}
			bool flag = (flags & CompilationFlags.EmitExpressionStartMask) == CompilationFlags.EmitExpressionStart;
			CompilationFlags flags2 = (flag ? EmitExpressionStart(node) : CompilationFlags.EmitNoExpressionStart);
			flags &= CompilationFlags.EmitAsTailCallMask;
			switch (node.NodeType)
			{
			case ExpressionType.Add:
			case ExpressionType.AddChecked:
			case ExpressionType.And:
			case ExpressionType.ArrayIndex:
			case ExpressionType.Divide:
			case ExpressionType.Equal:
			case ExpressionType.ExclusiveOr:
			case ExpressionType.GreaterThan:
			case ExpressionType.GreaterThanOrEqual:
			case ExpressionType.LeftShift:
			case ExpressionType.LessThan:
			case ExpressionType.LessThanOrEqual:
			case ExpressionType.Modulo:
			case ExpressionType.Multiply:
			case ExpressionType.MultiplyChecked:
			case ExpressionType.NotEqual:
			case ExpressionType.Or:
			case ExpressionType.Power:
			case ExpressionType.RightShift:
			case ExpressionType.Subtract:
			case ExpressionType.SubtractChecked:
				EmitBinaryExpression(node, flags);
				break;
			case ExpressionType.AndAlso:
				EmitAndAlsoBinaryExpression(node, flags);
				break;
			case ExpressionType.OrElse:
				EmitOrElseBinaryExpression(node, flags);
				break;
			case ExpressionType.Coalesce:
				EmitCoalesceBinaryExpression(node);
				break;
			case ExpressionType.Assign:
				EmitAssignBinaryExpression(node);
				break;
			case ExpressionType.ArrayLength:
			case ExpressionType.Negate:
			case ExpressionType.UnaryPlus:
			case ExpressionType.NegateChecked:
			case ExpressionType.Not:
			case ExpressionType.TypeAs:
			case ExpressionType.Decrement:
			case ExpressionType.Increment:
			case ExpressionType.OnesComplement:
			case ExpressionType.IsTrue:
			case ExpressionType.IsFalse:
				EmitUnaryExpression(node, flags);
				break;
			case ExpressionType.Convert:
			case ExpressionType.ConvertChecked:
				EmitConvertUnaryExpression(node, flags);
				break;
			case ExpressionType.Quote:
				EmitQuoteUnaryExpression(node);
				break;
			case ExpressionType.Throw:
				EmitThrowUnaryExpression(node);
				break;
			case ExpressionType.Unbox:
				EmitUnboxUnaryExpression(node);
				break;
			case ExpressionType.Call:
				EmitMethodCallExpression(node, flags);
				break;
			case ExpressionType.Conditional:
				EmitConditionalExpression(node, flags);
				break;
			case ExpressionType.Constant:
				EmitConstantExpression(node);
				break;
			case ExpressionType.Invoke:
				EmitInvocationExpression(node, flags);
				break;
			case ExpressionType.Lambda:
				EmitLambdaExpression(node);
				break;
			case ExpressionType.ListInit:
				EmitListInitExpression(node);
				break;
			case ExpressionType.MemberAccess:
				EmitMemberExpression(node);
				break;
			case ExpressionType.MemberInit:
				EmitMemberInitExpression(node);
				break;
			case ExpressionType.New:
				EmitNewExpression(node);
				break;
			case ExpressionType.NewArrayInit:
			case ExpressionType.NewArrayBounds:
				EmitNewArrayExpression(node);
				break;
			case ExpressionType.Parameter:
				EmitParameterExpression(node);
				break;
			case ExpressionType.TypeIs:
			case ExpressionType.TypeEqual:
				EmitTypeBinaryExpression(node);
				break;
			case ExpressionType.Block:
				EmitBlockExpression(node, flags);
				break;
			case ExpressionType.DebugInfo:
				EmitDebugInfoExpression(node);
				break;
			case ExpressionType.Dynamic:
				EmitDynamicExpression(node);
				break;
			case ExpressionType.Default:
				EmitDefaultExpression(node);
				break;
			case ExpressionType.Goto:
				EmitGotoExpression(node, flags);
				break;
			case ExpressionType.Index:
				EmitIndexExpression(node);
				break;
			case ExpressionType.Label:
				EmitLabelExpression(node, flags);
				break;
			case ExpressionType.RuntimeVariables:
				EmitRuntimeVariablesExpression(node);
				break;
			case ExpressionType.Loop:
				EmitLoopExpression(node);
				break;
			case ExpressionType.Switch:
				EmitSwitchExpression(node, flags);
				break;
			case ExpressionType.Try:
				EmitTryExpression(node);
				break;
			}
			if (flag)
			{
				EmitExpressionEnd(flags2);
			}
		}

		private static bool IsChecked(ExpressionType op)
		{
			switch (op)
			{
			case ExpressionType.AddChecked:
			case ExpressionType.ConvertChecked:
			case ExpressionType.MultiplyChecked:
			case ExpressionType.NegateChecked:
			case ExpressionType.SubtractChecked:
			case ExpressionType.AddAssignChecked:
			case ExpressionType.MultiplyAssignChecked:
			case ExpressionType.SubtractAssignChecked:
				return true;
			default:
				return false;
			}
		}

		internal void EmitConstantArray<T>(T[] array)
		{
			if (_method is DynamicMethod)
			{
				EmitConstant(array, typeof(T[]));
			}
			else if (_typeBuilder != null)
			{
				FieldBuilder field = CreateStaticField("ConstantArray", typeof(T[]));
				Label label = _ilg.DefineLabel();
				_ilg.Emit(OpCodes.Ldsfld, field);
				_ilg.Emit(OpCodes.Ldnull);
				_ilg.Emit(OpCodes.Bne_Un, label);
				_ilg.EmitArray(array, this);
				_ilg.Emit(OpCodes.Stsfld, field);
				_ilg.MarkLabel(label);
				_ilg.Emit(OpCodes.Ldsfld, field);
			}
			else
			{
				_ilg.EmitArray(array, this);
			}
		}

		private void EmitClosureCreation(LambdaCompiler inner)
		{
			bool needsClosure = inner._scope.NeedsClosure;
			bool flag = inner._boundConstants.Count > 0;
			if (!needsClosure && !flag)
			{
				_ilg.EmitNull();
				return;
			}
			if (flag)
			{
				_boundConstants.EmitConstant(this, inner._boundConstants.ToArray(), typeof(object[]));
			}
			else
			{
				_ilg.EmitNull();
			}
			if (needsClosure)
			{
				_scope.EmitGet(_scope.NearestHoistedLocals.SelfVariable);
			}
			else
			{
				_ilg.EmitNull();
			}
			_ilg.EmitNew(CachedReflectionInfo.Closure_ObjectArray_ObjectArray);
		}

		private void EmitDelegateConstruction(LambdaCompiler inner)
		{
			Type type = inner._lambda.Type;
			DynamicMethod dynamicMethod = inner._method as DynamicMethod;
			if (dynamicMethod != null)
			{
				_boundConstants.EmitConstant(this, dynamicMethod, typeof(MethodInfo));
				_ilg.EmitType(type);
				EmitClosureCreation(inner);
				_ilg.Emit(OpCodes.Callvirt, CachedReflectionInfo.MethodInfo_CreateDelegate_Type_Object);
				_ilg.Emit(OpCodes.Castclass, type);
			}
			else
			{
				EmitClosureCreation(inner);
				_ilg.Emit(OpCodes.Ldftn, inner._method);
				_ilg.Emit(OpCodes.Newobj, (ConstructorInfo)type.GetMember(".ctor")[0]);
			}
		}

		private void EmitDelegateConstruction(LambdaExpression lambda)
		{
			LambdaCompiler lambdaCompiler;
			if (_method is DynamicMethod)
			{
				lambdaCompiler = new LambdaCompiler(_tree, lambda);
			}
			else
			{
				string name = (string.IsNullOrEmpty(lambda.Name) ? GetUniqueMethodName() : lambda.Name);
				MethodBuilder method = _typeBuilder.DefineMethod(name, MethodAttributes.Private | MethodAttributes.Static);
				lambdaCompiler = new LambdaCompiler(_tree, lambda, method);
			}
			lambdaCompiler.EmitLambdaBody(_scope, inlined: false, CompilationFlags.EmitAsNoTail);
			EmitDelegateConstruction(lambdaCompiler);
		}

		private static Type[] GetParameterTypes(LambdaExpression lambda, Type firstType)
		{
			int parameterCount = lambda.ParameterCount;
			Type[] array;
			int num;
			if (firstType != null)
			{
				array = new Type[parameterCount + 1];
				array[0] = firstType;
				num = 1;
			}
			else
			{
				array = new Type[parameterCount];
				num = 0;
			}
			int num2 = 0;
			while (num2 < parameterCount)
			{
				ParameterExpression parameter = lambda.GetParameter(num2);
				array[num] = (parameter.IsByRef ? parameter.Type.MakeByRefType() : parameter.Type);
				num2++;
				num++;
			}
			return array;
		}

		private static string GetUniqueMethodName()
		{
			return "<ExpressionCompilerImplementationDetails>{" + Interlocked.Increment(ref s_counter) + "}lambda_method";
		}

		private void EmitLambdaBody()
		{
			CompilationFlags flags = (_lambda.TailCall ? CompilationFlags.EmitAsTail : CompilationFlags.EmitAsNoTail);
			EmitLambdaBody(null, inlined: false, flags);
		}

		private void EmitLambdaBody(CompilerScope parent, bool inlined, CompilationFlags flags)
		{
			_scope.Enter(this, parent);
			if (inlined)
			{
				for (int num = _lambda.ParameterCount - 1; num >= 0; num--)
				{
					_scope.EmitSet(_lambda.GetParameter(num));
				}
			}
			flags = UpdateEmitExpressionStartFlag(flags, CompilationFlags.EmitExpressionStart);
			if (_lambda.ReturnType == typeof(void))
			{
				EmitExpressionAsVoid(_lambda.Body, flags);
			}
			else
			{
				EmitExpression(_lambda.Body, flags);
			}
			if (!inlined)
			{
				_ilg.Emit(OpCodes.Ret);
			}
			_scope.Exit();
			foreach (LabelInfo value in _labelInfo.Values)
			{
				value.ValidateFinish();
			}
		}

		private void EmitConditionalExpression(Expression expr, CompilationFlags flags)
		{
			ConditionalExpression conditionalExpression = (ConditionalExpression)expr;
			Label label = _ilg.DefineLabel();
			EmitExpressionAndBranch(branchValue: false, conditionalExpression.Test, label);
			EmitExpressionAsType(conditionalExpression.IfTrue, conditionalExpression.Type, flags);
			if (NotEmpty(conditionalExpression.IfFalse))
			{
				Label label2 = _ilg.DefineLabel();
				if ((flags & CompilationFlags.EmitAsTailCallMask) == CompilationFlags.EmitAsTail)
				{
					_ilg.Emit(OpCodes.Ret);
				}
				else
				{
					_ilg.Emit(OpCodes.Br, label2);
				}
				_ilg.MarkLabel(label);
				EmitExpressionAsType(conditionalExpression.IfFalse, conditionalExpression.Type, flags);
				_ilg.MarkLabel(label2);
			}
			else
			{
				_ilg.MarkLabel(label);
			}
		}

		private static bool NotEmpty(Expression node)
		{
			if (!(node is DefaultExpression defaultExpression) || defaultExpression.Type != typeof(void))
			{
				return true;
			}
			return false;
		}

		private static bool Significant(Expression node)
		{
			if (node is BlockExpression blockExpression)
			{
				for (int i = 0; i < blockExpression.ExpressionCount; i++)
				{
					if (Significant(blockExpression.GetExpression(i)))
					{
						return true;
					}
				}
				return false;
			}
			if (NotEmpty(node))
			{
				return !(node is DebugInfoExpression);
			}
			return false;
		}

		private void EmitCoalesceBinaryExpression(Expression expr)
		{
			BinaryExpression binaryExpression = (BinaryExpression)expr;
			if (binaryExpression.Left.Type.IsNullableType())
			{
				EmitNullableCoalesce(binaryExpression);
			}
			else if (binaryExpression.Conversion != null)
			{
				EmitLambdaReferenceCoalesce(binaryExpression);
			}
			else
			{
				EmitReferenceCoalesceWithoutConversion(binaryExpression);
			}
		}

		private void EmitNullableCoalesce(BinaryExpression b)
		{
			LocalBuilder local = GetLocal(b.Left.Type);
			Label label = _ilg.DefineLabel();
			Label label2 = _ilg.DefineLabel();
			EmitExpression(b.Left);
			_ilg.Emit(OpCodes.Stloc, local);
			_ilg.Emit(OpCodes.Ldloca, local);
			_ilg.EmitHasValue(b.Left.Type);
			_ilg.Emit(OpCodes.Brfalse, label);
			Type nonNullableType = b.Left.Type.GetNonNullableType();
			if (b.Conversion != null)
			{
				ParameterExpression parameter = b.Conversion.GetParameter(0);
				EmitLambdaExpression(b.Conversion);
				if (!parameter.Type.IsAssignableFrom(b.Left.Type))
				{
					_ilg.Emit(OpCodes.Ldloca, local);
					_ilg.EmitGetValueOrDefault(b.Left.Type);
				}
				else
				{
					_ilg.Emit(OpCodes.Ldloc, local);
				}
				_ilg.Emit(OpCodes.Callvirt, b.Conversion.Type.GetInvokeMethod());
			}
			else if (TypeUtils.AreEquivalent(b.Type, b.Left.Type))
			{
				_ilg.Emit(OpCodes.Ldloc, local);
			}
			else
			{
				_ilg.Emit(OpCodes.Ldloca, local);
				_ilg.EmitGetValueOrDefault(b.Left.Type);
				if (!TypeUtils.AreEquivalent(b.Type, nonNullableType))
				{
					_ilg.EmitConvertToType(nonNullableType, b.Type, isChecked: true, this);
				}
			}
			FreeLocal(local);
			_ilg.Emit(OpCodes.Br, label2);
			_ilg.MarkLabel(label);
			EmitExpression(b.Right);
			if (!TypeUtils.AreEquivalent(b.Right.Type, b.Type))
			{
				_ilg.EmitConvertToType(b.Right.Type, b.Type, isChecked: true, this);
			}
			_ilg.MarkLabel(label2);
		}

		private void EmitLambdaReferenceCoalesce(BinaryExpression b)
		{
			LocalBuilder local = GetLocal(b.Left.Type);
			Label label = _ilg.DefineLabel();
			Label label2 = _ilg.DefineLabel();
			EmitExpression(b.Left);
			_ilg.Emit(OpCodes.Dup);
			_ilg.Emit(OpCodes.Stloc, local);
			_ilg.Emit(OpCodes.Brtrue, label2);
			EmitExpression(b.Right);
			_ilg.Emit(OpCodes.Br, label);
			_ilg.MarkLabel(label2);
			EmitLambdaExpression(b.Conversion);
			_ilg.Emit(OpCodes.Ldloc, local);
			FreeLocal(local);
			_ilg.Emit(OpCodes.Callvirt, b.Conversion.Type.GetInvokeMethod());
			_ilg.MarkLabel(label);
		}

		private void EmitReferenceCoalesceWithoutConversion(BinaryExpression b)
		{
			Label label = _ilg.DefineLabel();
			Label label2 = _ilg.DefineLabel();
			EmitExpression(b.Left);
			_ilg.Emit(OpCodes.Dup);
			_ilg.Emit(OpCodes.Brtrue, label2);
			_ilg.Emit(OpCodes.Pop);
			EmitExpression(b.Right);
			if (!TypeUtils.AreEquivalent(b.Right.Type, b.Type))
			{
				if (b.Right.Type.IsValueType)
				{
					_ilg.Emit(OpCodes.Box, b.Right.Type);
				}
				_ilg.Emit(OpCodes.Castclass, b.Type);
			}
			_ilg.Emit(OpCodes.Br_S, label);
			_ilg.MarkLabel(label2);
			if (!TypeUtils.AreEquivalent(b.Left.Type, b.Type))
			{
				_ilg.Emit(OpCodes.Castclass, b.Type);
			}
			_ilg.MarkLabel(label);
		}

		private void EmitLiftedAndAlso(BinaryExpression b)
		{
			Type typeFromHandle = typeof(bool?);
			Label label = _ilg.DefineLabel();
			Label label2 = _ilg.DefineLabel();
			Label label3 = _ilg.DefineLabel();
			EmitExpression(b.Left);
			LocalBuilder local = GetLocal(typeFromHandle);
			_ilg.Emit(OpCodes.Stloc, local);
			_ilg.Emit(OpCodes.Ldloca, local);
			_ilg.EmitHasValue(typeFromHandle);
			_ilg.Emit(OpCodes.Ldloca, local);
			_ilg.EmitGetValueOrDefault(typeFromHandle);
			_ilg.Emit(OpCodes.Not);
			_ilg.Emit(OpCodes.And);
			_ilg.Emit(OpCodes.Brtrue, label);
			EmitExpression(b.Right);
			LocalBuilder local2 = GetLocal(typeFromHandle);
			_ilg.Emit(OpCodes.Stloc, local2);
			_ilg.Emit(OpCodes.Ldloca, local);
			_ilg.EmitGetValueOrDefault(typeFromHandle);
			_ilg.Emit(OpCodes.Brtrue_S, label2);
			_ilg.Emit(OpCodes.Ldloca, local2);
			_ilg.EmitGetValueOrDefault(typeFromHandle);
			_ilg.Emit(OpCodes.Brtrue_S, label);
			_ilg.MarkLabel(label2);
			_ilg.Emit(OpCodes.Ldloc, local2);
			FreeLocal(local2);
			_ilg.Emit(OpCodes.Br_S, label3);
			_ilg.MarkLabel(label);
			_ilg.Emit(OpCodes.Ldloc, local);
			FreeLocal(local);
			_ilg.MarkLabel(label3);
		}

		private void EmitMethodAndAlso(BinaryExpression b, CompilationFlags flags)
		{
			Label label = _ilg.DefineLabel();
			EmitExpression(b.Left);
			_ilg.Emit(OpCodes.Dup);
			MethodInfo booleanOperator = TypeUtils.GetBooleanOperator(b.Method.DeclaringType, "op_False");
			_ilg.Emit(OpCodes.Call, booleanOperator);
			_ilg.Emit(OpCodes.Brtrue, label);
			EmitExpression(b.Right);
			if ((flags & CompilationFlags.EmitAsTailCallMask) == CompilationFlags.EmitAsTail)
			{
				_ilg.Emit(OpCodes.Tailcall);
			}
			_ilg.Emit(OpCodes.Call, b.Method);
			_ilg.MarkLabel(label);
		}

		private void EmitUnliftedAndAlso(BinaryExpression b)
		{
			Label label = _ilg.DefineLabel();
			Label label2 = _ilg.DefineLabel();
			EmitExpressionAndBranch(branchValue: false, b.Left, label);
			EmitExpression(b.Right);
			_ilg.Emit(OpCodes.Br, label2);
			_ilg.MarkLabel(label);
			_ilg.Emit(OpCodes.Ldc_I4_0);
			_ilg.MarkLabel(label2);
		}

		private void EmitAndAlsoBinaryExpression(Expression expr, CompilationFlags flags)
		{
			BinaryExpression binaryExpression = (BinaryExpression)expr;
			if (binaryExpression.Method != null)
			{
				if (binaryExpression.IsLiftedLogical)
				{
					EmitExpression(binaryExpression.ReduceUserdefinedLifted());
				}
				else
				{
					EmitMethodAndAlso(binaryExpression, flags);
				}
			}
			else if (binaryExpression.Left.Type == typeof(bool?))
			{
				EmitLiftedAndAlso(binaryExpression);
			}
			else
			{
				EmitUnliftedAndAlso(binaryExpression);
			}
		}

		private void EmitLiftedOrElse(BinaryExpression b)
		{
			Type typeFromHandle = typeof(bool?);
			Label label = _ilg.DefineLabel();
			Label label2 = _ilg.DefineLabel();
			LocalBuilder local = GetLocal(typeFromHandle);
			EmitExpression(b.Left);
			_ilg.Emit(OpCodes.Stloc, local);
			_ilg.Emit(OpCodes.Ldloca, local);
			_ilg.EmitGetValueOrDefault(typeFromHandle);
			_ilg.Emit(OpCodes.Brtrue, label);
			EmitExpression(b.Right);
			LocalBuilder local2 = GetLocal(typeFromHandle);
			_ilg.Emit(OpCodes.Stloc, local2);
			_ilg.Emit(OpCodes.Ldloca, local2);
			_ilg.EmitGetValueOrDefault(typeFromHandle);
			_ilg.Emit(OpCodes.Ldloca, local);
			_ilg.EmitHasValue(typeFromHandle);
			_ilg.Emit(OpCodes.Or);
			_ilg.Emit(OpCodes.Brfalse_S, label);
			_ilg.Emit(OpCodes.Ldloc, local2);
			FreeLocal(local2);
			_ilg.Emit(OpCodes.Br_S, label2);
			_ilg.MarkLabel(label);
			_ilg.Emit(OpCodes.Ldloc, local);
			FreeLocal(local);
			_ilg.MarkLabel(label2);
		}

		private void EmitUnliftedOrElse(BinaryExpression b)
		{
			Label label = _ilg.DefineLabel();
			Label label2 = _ilg.DefineLabel();
			EmitExpressionAndBranch(branchValue: false, b.Left, label);
			_ilg.Emit(OpCodes.Ldc_I4_1);
			_ilg.Emit(OpCodes.Br, label2);
			_ilg.MarkLabel(label);
			EmitExpression(b.Right);
			_ilg.MarkLabel(label2);
		}

		private void EmitMethodOrElse(BinaryExpression b, CompilationFlags flags)
		{
			Label label = _ilg.DefineLabel();
			EmitExpression(b.Left);
			_ilg.Emit(OpCodes.Dup);
			MethodInfo booleanOperator = TypeUtils.GetBooleanOperator(b.Method.DeclaringType, "op_True");
			_ilg.Emit(OpCodes.Call, booleanOperator);
			_ilg.Emit(OpCodes.Brtrue, label);
			EmitExpression(b.Right);
			if ((flags & CompilationFlags.EmitAsTailCallMask) == CompilationFlags.EmitAsTail)
			{
				_ilg.Emit(OpCodes.Tailcall);
			}
			_ilg.Emit(OpCodes.Call, b.Method);
			_ilg.MarkLabel(label);
		}

		private void EmitOrElseBinaryExpression(Expression expr, CompilationFlags flags)
		{
			BinaryExpression binaryExpression = (BinaryExpression)expr;
			if (binaryExpression.Method != null)
			{
				if (binaryExpression.IsLiftedLogical)
				{
					EmitExpression(binaryExpression.ReduceUserdefinedLifted());
				}
				else
				{
					EmitMethodOrElse(binaryExpression, flags);
				}
			}
			else if (binaryExpression.Left.Type == typeof(bool?))
			{
				EmitLiftedOrElse(binaryExpression);
			}
			else
			{
				EmitUnliftedOrElse(binaryExpression);
			}
		}

		private void EmitExpressionAndBranch(bool branchValue, Expression node, Label label)
		{
			CompilationFlags flags = EmitExpressionStart(node);
			switch (node.NodeType)
			{
			case ExpressionType.Not:
				EmitBranchNot(branchValue, (UnaryExpression)node, label);
				break;
			case ExpressionType.AndAlso:
			case ExpressionType.OrElse:
				EmitBranchLogical(branchValue, (BinaryExpression)node, label);
				break;
			case ExpressionType.Block:
				EmitBranchBlock(branchValue, (BlockExpression)node, label);
				break;
			case ExpressionType.Equal:
			case ExpressionType.NotEqual:
				EmitBranchComparison(branchValue, (BinaryExpression)node, label);
				break;
			default:
				EmitExpression(node, CompilationFlags.EmitNoExpressionStart | CompilationFlags.EmitAsNoTail);
				EmitBranchOp(branchValue, label);
				break;
			}
			EmitExpressionEnd(flags);
		}

		private void EmitBranchOp(bool branch, Label label)
		{
			_ilg.Emit(branch ? OpCodes.Brtrue : OpCodes.Brfalse, label);
		}

		private void EmitBranchNot(bool branch, UnaryExpression node, Label label)
		{
			if (node.Method != null)
			{
				EmitExpression(node, CompilationFlags.EmitNoExpressionStart | CompilationFlags.EmitAsNoTail);
				EmitBranchOp(branch, label);
			}
			else
			{
				EmitExpressionAndBranch(!branch, node.Operand, label);
			}
		}

		private void EmitBranchComparison(bool branch, BinaryExpression node, Label label)
		{
			bool flag = branch == (node.NodeType == ExpressionType.Equal);
			if (node.Method != null)
			{
				EmitBinaryMethod(node, CompilationFlags.EmitAsNoTail);
				EmitBranchOp(branch, label);
			}
			else if (ConstantCheck.IsNull(node.Left))
			{
				if (node.Right.Type.IsNullableType())
				{
					EmitAddress(node.Right, node.Right.Type);
					_ilg.EmitHasValue(node.Right.Type);
				}
				else
				{
					EmitExpression(GetEqualityOperand(node.Right));
				}
				EmitBranchOp(!flag, label);
			}
			else if (ConstantCheck.IsNull(node.Right))
			{
				if (node.Left.Type.IsNullableType())
				{
					EmitAddress(node.Left, node.Left.Type);
					_ilg.EmitHasValue(node.Left.Type);
				}
				else
				{
					EmitExpression(GetEqualityOperand(node.Left));
				}
				EmitBranchOp(!flag, label);
			}
			else if (node.Left.Type.IsNullableType() || node.Right.Type.IsNullableType())
			{
				EmitBinaryExpression(node);
				EmitBranchOp(branch, label);
			}
			else
			{
				EmitExpression(GetEqualityOperand(node.Left));
				EmitExpression(GetEqualityOperand(node.Right));
				_ilg.Emit(flag ? OpCodes.Beq : OpCodes.Bne_Un, label);
			}
		}

		private static Expression GetEqualityOperand(Expression expression)
		{
			if (expression.NodeType == ExpressionType.Convert)
			{
				UnaryExpression unaryExpression = (UnaryExpression)expression;
				if (TypeUtils.AreReferenceAssignable(unaryExpression.Type, unaryExpression.Operand.Type))
				{
					return unaryExpression.Operand;
				}
			}
			return expression;
		}

		private void EmitBranchLogical(bool branch, BinaryExpression node, Label label)
		{
			if (node.Method != null || node.IsLifted)
			{
				EmitExpression(node);
				EmitBranchOp(branch, label);
				return;
			}
			bool flag = node.NodeType == ExpressionType.AndAlso;
			if (branch == flag)
			{
				EmitBranchAnd(branch, node, label);
			}
			else
			{
				EmitBranchOr(branch, node, label);
			}
		}

		private void EmitBranchAnd(bool branch, BinaryExpression node, Label label)
		{
			Label label2 = _ilg.DefineLabel();
			EmitExpressionAndBranch(!branch, node.Left, label2);
			EmitExpressionAndBranch(branch, node.Right, label);
			_ilg.MarkLabel(label2);
		}

		private void EmitBranchOr(bool branch, BinaryExpression node, Label label)
		{
			EmitExpressionAndBranch(branch, node.Left, label);
			EmitExpressionAndBranch(branch, node.Right, label);
		}

		private void EmitBranchBlock(bool branch, BlockExpression node, Label label)
		{
			EnterScope(node);
			int expressionCount = node.ExpressionCount;
			for (int i = 0; i < expressionCount - 1; i++)
			{
				EmitExpressionAsVoid(node.GetExpression(i));
			}
			EmitExpressionAndBranch(branch, node.GetExpression(expressionCount - 1), label);
			ExitScope(node);
		}

		private void EmitBlockExpression(Expression expr, CompilationFlags flags)
		{
			Emit((BlockExpression)expr, UpdateEmitAsTypeFlag(flags, CompilationFlags.EmitAsDefaultType));
		}

		private void Emit(BlockExpression node, CompilationFlags flags)
		{
			int expressionCount = node.ExpressionCount;
			if (expressionCount != 0)
			{
				EnterScope(node);
				CompilationFlags compilationFlags = flags & CompilationFlags.EmitAsTypeMask;
				CompilationFlags compilationFlags2 = flags & CompilationFlags.EmitAsTailCallMask;
				for (int i = 0; i < expressionCount - 1; i++)
				{
					Expression expression = node.GetExpression(i);
					Expression expression2 = node.GetExpression(i + 1);
					CompilationFlags newValue = ((compilationFlags2 == CompilationFlags.EmitAsNoTail) ? CompilationFlags.EmitAsNoTail : ((!(expression2 is GotoExpression gotoExpression) || (gotoExpression.Value != null && Significant(gotoExpression.Value)) || !ReferenceLabel(gotoExpression.Target).CanReturn) ? CompilationFlags.EmitAsMiddle : CompilationFlags.EmitAsTail));
					flags = UpdateEmitAsTailCallFlag(flags, newValue);
					EmitExpressionAsVoid(expression, flags);
				}
				if (compilationFlags == CompilationFlags.EmitAsVoidType || node.Type == typeof(void))
				{
					EmitExpressionAsVoid(node.GetExpression(expressionCount - 1), compilationFlags2);
				}
				else
				{
					EmitExpressionAsType(node.GetExpression(expressionCount - 1), node.Type, compilationFlags2);
				}
				ExitScope(node);
			}
		}

		private void EnterScope(object node)
		{
			if (HasVariables(node) && (_scope.MergedScopes == null || !_scope.MergedScopes.Contains(node)))
			{
				if (!_tree.Scopes.TryGetValue(node, out var value))
				{
					value = new CompilerScope(node, isMethod: false)
					{
						NeedsClosure = _scope.NeedsClosure
					};
				}
				_scope = value.Enter(this, _scope);
			}
		}

		private static bool HasVariables(object node)
		{
			if (node is BlockExpression blockExpression)
			{
				return blockExpression.Variables.Count > 0;
			}
			return ((CatchBlock)node).Variable != null;
		}

		private void ExitScope(object node)
		{
			if (_scope.Node == node)
			{
				_scope = _scope.Exit();
			}
		}

		private void EmitDefaultExpression(Expression expr)
		{
			DefaultExpression defaultExpression = (DefaultExpression)expr;
			if (defaultExpression.Type != typeof(void))
			{
				_ilg.EmitDefault(defaultExpression.Type, this);
			}
		}

		private void EmitLoopExpression(Expression expr)
		{
			LoopExpression loopExpression = (LoopExpression)expr;
			PushLabelBlock(LabelScopeKind.Statement);
			LabelInfo labelInfo = DefineLabel(loopExpression.BreakLabel);
			LabelInfo labelInfo2 = DefineLabel(loopExpression.ContinueLabel);
			labelInfo2.MarkWithEmptyStack();
			EmitExpressionAsVoid(loopExpression.Body);
			_ilg.Emit(OpCodes.Br, labelInfo2.Label);
			PopLabelBlock(LabelScopeKind.Statement);
			labelInfo.MarkWithEmptyStack();
		}

		private void EmitSwitchExpression(Expression expr, CompilationFlags flags)
		{
			SwitchExpression switchExpression = (SwitchExpression)expr;
			if (switchExpression.Cases.Count == 0)
			{
				EmitExpressionAsVoid(switchExpression.SwitchValue);
				if (switchExpression.DefaultBody != null)
				{
					EmitExpressionAsType(switchExpression.DefaultBody, switchExpression.Type, flags);
				}
			}
			else
			{
				if (TryEmitSwitchInstruction(switchExpression, flags) || TryEmitHashtableSwitch(switchExpression, flags))
				{
					return;
				}
				ParameterExpression parameterExpression = Expression.Parameter(switchExpression.SwitchValue.Type, "switchValue");
				ParameterExpression parameterExpression2 = Expression.Parameter(GetTestValueType(switchExpression), "testValue");
				_scope.AddLocal(this, parameterExpression);
				_scope.AddLocal(this, parameterExpression2);
				EmitExpression(switchExpression.SwitchValue);
				_scope.EmitSet(parameterExpression);
				Label[] array = new Label[switchExpression.Cases.Count];
				bool[] array2 = new bool[switchExpression.Cases.Count];
				int i = 0;
				for (int count = switchExpression.Cases.Count; i < count; i++)
				{
					DefineSwitchCaseLabel(switchExpression.Cases[i], out array[i], out array2[i]);
					foreach (Expression testValue in switchExpression.Cases[i].TestValues)
					{
						EmitExpression(testValue);
						_scope.EmitSet(parameterExpression2);
						EmitExpressionAndBranch(branchValue: true, Expression.Equal(parameterExpression, parameterExpression2, liftToNull: false, switchExpression.Comparison), array[i]);
					}
				}
				Label label = _ilg.DefineLabel();
				Label label2 = ((switchExpression.DefaultBody == null) ? label : _ilg.DefineLabel());
				EmitSwitchCases(switchExpression, array, array2, label2, label, flags);
			}
		}

		private static Type GetTestValueType(SwitchExpression node)
		{
			if (node.Comparison == null)
			{
				return node.Cases[0].TestValues[0].Type;
			}
			Type type = node.Comparison.GetParametersCached()[1].ParameterType.GetNonRefType();
			if (node.IsLifted)
			{
				type = type.GetNullableType();
			}
			return type;
		}

		private static bool FitsInBucket(List<SwitchLabel> buckets, decimal key, int count)
		{
			decimal num = key - buckets[0].Key + 1m;
			if (num > 2147483647m)
			{
				return false;
			}
			return (decimal)((buckets.Count + count) * 2) > num;
		}

		private static void MergeBuckets(List<List<SwitchLabel>> buckets)
		{
			while (buckets.Count > 1)
			{
				List<SwitchLabel> list = buckets[buckets.Count - 2];
				List<SwitchLabel> list2 = buckets[buckets.Count - 1];
				if (!FitsInBucket(list, list2[list2.Count - 1].Key, list2.Count))
				{
					break;
				}
				list.AddRange(list2);
				buckets.RemoveAt(buckets.Count - 1);
			}
		}

		private static void AddToBuckets(List<List<SwitchLabel>> buckets, SwitchLabel key)
		{
			if (buckets.Count > 0)
			{
				List<SwitchLabel> list = buckets[buckets.Count - 1];
				if (FitsInBucket(list, key.Key, 1))
				{
					list.Add(key);
					MergeBuckets(buckets);
					return;
				}
			}
			buckets.Add(new List<SwitchLabel> { key });
		}

		private static bool CanOptimizeSwitchType(Type valueType)
		{
			TypeCode typeCode = valueType.GetTypeCode();
			if ((uint)(typeCode - 4) <= 8u)
			{
				return true;
			}
			return false;
		}

		private bool TryEmitSwitchInstruction(SwitchExpression node, CompilationFlags flags)
		{
			if (node.Comparison != null)
			{
				return false;
			}
			Type type = node.SwitchValue.Type;
			if (!CanOptimizeSwitchType(type) || !TypeUtils.AreEquivalent(type, node.Cases[0].TestValues[0].Type))
			{
				return false;
			}
			if (!node.Cases.All((SwitchCase c) => c.TestValues.All((Expression t) => t is ConstantExpression)))
			{
				return false;
			}
			Label[] array = new Label[node.Cases.Count];
			bool[] array2 = new bool[node.Cases.Count];
			HashSet<decimal> hashSet = new HashSet<decimal>();
			List<SwitchLabel> list = new List<SwitchLabel>();
			for (int num = 0; num < node.Cases.Count; num++)
			{
				DefineSwitchCaseLabel(node.Cases[num], out array[num], out array2[num]);
				foreach (ConstantExpression testValue in node.Cases[num].TestValues)
				{
					decimal num2 = ConvertSwitchValue(testValue.Value);
					if (hashSet.Add(num2))
					{
						list.Add(new SwitchLabel(num2, testValue.Value, array[num]));
					}
				}
			}
			list.Sort((SwitchLabel x, SwitchLabel y) => Math.Sign(x.Key - y.Key));
			List<List<SwitchLabel>> list2 = new List<List<SwitchLabel>>();
			foreach (SwitchLabel item in list)
			{
				AddToBuckets(list2, item);
			}
			LocalBuilder local = GetLocal(node.SwitchValue.Type);
			EmitExpression(node.SwitchValue);
			_ilg.Emit(OpCodes.Stloc, local);
			Label label = _ilg.DefineLabel();
			Label label2 = ((node.DefaultBody == null) ? label : _ilg.DefineLabel());
			SwitchInfo info = new SwitchInfo(node, local, label2);
			EmitSwitchBuckets(info, list2, 0, list2.Count - 1);
			EmitSwitchCases(node, array, array2, label2, label, flags);
			FreeLocal(local);
			return true;
		}

		private static decimal ConvertSwitchValue(object value)
		{
			if (value is char)
			{
				return (int)(char)value;
			}
			return Convert.ToDecimal(value, CultureInfo.InvariantCulture);
		}

		private void DefineSwitchCaseLabel(SwitchCase @case, out Label label, out bool isGoto)
		{
			if (@case.Body is GotoExpression { Value: null } gotoExpression)
			{
				LabelInfo labelInfo = ReferenceLabel(gotoExpression.Target);
				if (labelInfo.CanBranch)
				{
					label = labelInfo.Label;
					isGoto = true;
					return;
				}
			}
			label = _ilg.DefineLabel();
			isGoto = false;
		}

		private void EmitSwitchCases(SwitchExpression node, Label[] labels, bool[] isGoto, Label @default, Label end, CompilationFlags flags)
		{
			_ilg.Emit(OpCodes.Br, @default);
			int i = 0;
			for (int count = node.Cases.Count; i < count; i++)
			{
				if (isGoto[i])
				{
					continue;
				}
				_ilg.MarkLabel(labels[i]);
				EmitExpressionAsType(node.Cases[i].Body, node.Type, flags);
				if (node.DefaultBody != null || i < count - 1)
				{
					if ((flags & CompilationFlags.EmitAsTailCallMask) == CompilationFlags.EmitAsTail)
					{
						_ilg.Emit(OpCodes.Ret);
					}
					else
					{
						_ilg.Emit(OpCodes.Br, end);
					}
				}
			}
			if (node.DefaultBody != null)
			{
				_ilg.MarkLabel(@default);
				EmitExpressionAsType(node.DefaultBody, node.Type, flags);
			}
			_ilg.MarkLabel(end);
		}

		private void EmitSwitchBuckets(SwitchInfo info, List<List<SwitchLabel>> buckets, int first, int last)
		{
			while (first != last)
			{
				int num = (int)(((long)first + (long)last + 1) / 2);
				if (first == num - 1)
				{
					EmitSwitchBucket(info, buckets[first]);
				}
				else
				{
					Label label = _ilg.DefineLabel();
					_ilg.Emit(OpCodes.Ldloc, info.Value);
					EmitConstant(buckets[num - 1].Last().Constant);
					_ilg.Emit(info.IsUnsigned ? OpCodes.Bgt_Un : OpCodes.Bgt, label);
					EmitSwitchBuckets(info, buckets, first, num - 1);
					_ilg.MarkLabel(label);
				}
				first = num;
			}
			EmitSwitchBucket(info, buckets[first]);
		}

		private void EmitSwitchBucket(SwitchInfo info, List<SwitchLabel> bucket)
		{
			if (bucket.Count == 1)
			{
				_ilg.Emit(OpCodes.Ldloc, info.Value);
				EmitConstant(bucket[0].Constant);
				_ilg.Emit(OpCodes.Beq, bucket[0].Label);
				return;
			}
			Label? label = null;
			if (info.Is64BitSwitch)
			{
				label = _ilg.DefineLabel();
				_ilg.Emit(OpCodes.Ldloc, info.Value);
				EmitConstant(bucket.Last().Constant);
				_ilg.Emit(info.IsUnsigned ? OpCodes.Bgt_Un : OpCodes.Bgt, label.Value);
				_ilg.Emit(OpCodes.Ldloc, info.Value);
				EmitConstant(bucket[0].Constant);
				_ilg.Emit(info.IsUnsigned ? OpCodes.Blt_Un : OpCodes.Blt, label.Value);
			}
			_ilg.Emit(OpCodes.Ldloc, info.Value);
			decimal key = bucket[0].Key;
			if (key != 0m)
			{
				EmitConstant(bucket[0].Constant);
				_ilg.Emit(OpCodes.Sub);
			}
			if (info.Is64BitSwitch)
			{
				_ilg.Emit(OpCodes.Conv_I4);
			}
			Label[] array = new Label[(int)(bucket[bucket.Count - 1].Key - bucket[0].Key + 1m)];
			int num = 0;
			foreach (SwitchLabel item in bucket)
			{
				while (key++ != item.Key)
				{
					array[num++] = info.Default;
				}
				array[num++] = item.Label;
			}
			_ilg.Emit(OpCodes.Switch, array);
			if (info.Is64BitSwitch)
			{
				_ilg.MarkLabel(label.Value);
			}
		}

		private bool TryEmitHashtableSwitch(SwitchExpression node, CompilationFlags flags)
		{
			if (node.Comparison != CachedReflectionInfo.String_op_Equality_String_String && node.Comparison != CachedReflectionInfo.String_Equals_String_String)
			{
				return false;
			}
			int num = 0;
			foreach (SwitchCase @case in node.Cases)
			{
				foreach (Expression testValue in @case.TestValues)
				{
					if (!(testValue is ConstantExpression))
					{
						return false;
					}
					num++;
				}
			}
			if (num < 7)
			{
				return false;
			}
			List<ElementInit> list = new List<ElementInit>(num);
			ArrayBuilder<SwitchCase> builder = new ArrayBuilder<SwitchCase>(node.Cases.Count);
			int value = -1;
			MethodInfo dictionaryOfStringInt32_Add_String_Int = CachedReflectionInfo.DictionaryOfStringInt32_Add_String_Int32;
			int i = 0;
			for (int count = node.Cases.Count; i < count; i++)
			{
				foreach (ConstantExpression testValue2 in node.Cases[i].TestValues)
				{
					if (testValue2.Value != null)
					{
						list.Add(Expression.ElementInit(dictionaryOfStringInt32_Add_String_Int, new TrueReadOnlyCollection<Expression>(testValue2, Utils.Constant(i))));
					}
					else
					{
						value = i;
					}
				}
				builder.UncheckedAdd(Expression.SwitchCase(node.Cases[i].Body, new TrueReadOnlyCollection<Expression>(Utils.Constant(i))));
			}
			MemberExpression memberExpression = CreateLazyInitializedField<Dictionary<string, int>>("dictionarySwitch");
			Expression instance = Expression.Condition(Expression.Equal(memberExpression, Expression.Constant(null, memberExpression.Type)), Expression.Assign(memberExpression, Expression.ListInit(Expression.New(CachedReflectionInfo.DictionaryOfStringInt32_Ctor_Int32, new TrueReadOnlyCollection<Expression>(Utils.Constant(list.Count))), list)), memberExpression);
			ParameterExpression parameterExpression = Expression.Variable(typeof(string), "switchValue");
			ParameterExpression parameterExpression2 = Expression.Variable(typeof(int), "switchIndex");
			BlockExpression node2 = Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(parameterExpression2, parameterExpression), new TrueReadOnlyCollection<Expression>(Expression.Assign(parameterExpression, node.SwitchValue), Expression.IfThenElse(Expression.Equal(parameterExpression, Expression.Constant(null, typeof(string))), Expression.Assign(parameterExpression2, Utils.Constant(value)), Expression.IfThenElse(Expression.Call(instance, "TryGetValue", null, parameterExpression, parameterExpression2), Utils.Empty, Expression.Assign(parameterExpression2, Utils.Constant(-1)))), Expression.Switch(node.Type, parameterExpression2, node.DefaultBody, null, builder.ToReadOnly())));
			EmitExpression(node2, flags);
			return true;
		}

		private void CheckRethrow()
		{
			for (LabelScopeInfo labelScopeInfo = _labelBlock; labelScopeInfo != null; labelScopeInfo = labelScopeInfo.Parent)
			{
				if (labelScopeInfo.Kind == LabelScopeKind.Catch)
				{
					return;
				}
				if (labelScopeInfo.Kind == LabelScopeKind.Finally)
				{
					break;
				}
			}
			throw Error.RethrowRequiresCatch();
		}

		private void CheckTry()
		{
			for (LabelScopeInfo labelScopeInfo = _labelBlock; labelScopeInfo != null; labelScopeInfo = labelScopeInfo.Parent)
			{
				if (labelScopeInfo.Kind == LabelScopeKind.Filter)
				{
					throw Error.TryNotAllowedInFilter();
				}
			}
		}

		private void EmitSaveExceptionOrPop(CatchBlock cb)
		{
			if (cb.Variable != null)
			{
				_scope.EmitSet(cb.Variable);
			}
			else
			{
				_ilg.Emit(OpCodes.Pop);
			}
		}

		private void EmitTryExpression(Expression expr)
		{
			TryExpression tryExpression = (TryExpression)expr;
			CheckTry();
			PushLabelBlock(LabelScopeKind.Try);
			_ilg.BeginExceptionBlock();
			EmitExpression(tryExpression.Body);
			Type type = tryExpression.Type;
			LocalBuilder local = null;
			if (type != typeof(void))
			{
				local = GetLocal(type);
				_ilg.Emit(OpCodes.Stloc, local);
			}
			foreach (CatchBlock handler in tryExpression.Handlers)
			{
				PushLabelBlock(LabelScopeKind.Catch);
				if (handler.Filter == null)
				{
					_ilg.BeginCatchBlock(handler.Test);
				}
				else
				{
					_ilg.BeginExceptFilterBlock();
				}
				EnterScope(handler);
				EmitCatchStart(handler);
				EmitExpression(handler.Body);
				if (type != typeof(void))
				{
					_ilg.Emit(OpCodes.Stloc, local);
				}
				ExitScope(handler);
				PopLabelBlock(LabelScopeKind.Catch);
			}
			if (tryExpression.Finally != null || tryExpression.Fault != null)
			{
				PushLabelBlock(LabelScopeKind.Finally);
				if (tryExpression.Finally != null)
				{
					_ilg.BeginFinallyBlock();
				}
				else
				{
					_ilg.BeginFaultBlock();
				}
				EmitExpressionAsVoid(tryExpression.Finally ?? tryExpression.Fault);
				_ilg.EndExceptionBlock();
				PopLabelBlock(LabelScopeKind.Finally);
			}
			else
			{
				_ilg.EndExceptionBlock();
			}
			if (type != typeof(void))
			{
				_ilg.Emit(OpCodes.Ldloc, local);
				FreeLocal(local);
			}
			PopLabelBlock(LabelScopeKind.Try);
		}

		private void EmitCatchStart(CatchBlock cb)
		{
			if (cb.Filter == null)
			{
				EmitSaveExceptionOrPop(cb);
				return;
			}
			Label label = _ilg.DefineLabel();
			Label label2 = _ilg.DefineLabel();
			_ilg.Emit(OpCodes.Isinst, cb.Test);
			_ilg.Emit(OpCodes.Dup);
			_ilg.Emit(OpCodes.Brtrue, label2);
			_ilg.Emit(OpCodes.Pop);
			_ilg.Emit(OpCodes.Ldc_I4_0);
			_ilg.Emit(OpCodes.Br, label);
			_ilg.MarkLabel(label2);
			EmitSaveExceptionOrPop(cb);
			PushLabelBlock(LabelScopeKind.Filter);
			EmitExpression(cb.Filter);
			PopLabelBlock(LabelScopeKind.Filter);
			_ilg.MarkLabel(label);
			_ilg.BeginCatchBlock(null);
			_ilg.Emit(OpCodes.Pop);
		}

		private void EmitQuoteUnaryExpression(Expression expr)
		{
			EmitQuote((UnaryExpression)expr);
		}

		private void EmitQuote(UnaryExpression quote)
		{
			EmitConstant(quote.Operand, quote.Type);
			if (_scope.NearestHoistedLocals != null)
			{
				EmitConstant(_scope.NearestHoistedLocals, typeof(object));
				_scope.EmitGet(_scope.NearestHoistedLocals.SelfVariable);
				_ilg.Emit(OpCodes.Call, CachedReflectionInfo.RuntimeOps_Quote);
				_ilg.Emit(OpCodes.Castclass, quote.Type);
			}
		}

		private void EmitThrowUnaryExpression(Expression expr)
		{
			EmitThrow((UnaryExpression)expr, CompilationFlags.EmitAsDefaultType);
		}

		private void EmitThrow(UnaryExpression expr, CompilationFlags flags)
		{
			if (expr.Operand == null)
			{
				CheckRethrow();
				_ilg.Emit(OpCodes.Rethrow);
			}
			else
			{
				EmitExpression(expr.Operand);
				_ilg.Emit(OpCodes.Throw);
			}
			EmitUnreachable(expr, flags);
		}

		private void EmitUnaryExpression(Expression expr, CompilationFlags flags)
		{
			EmitUnary((UnaryExpression)expr, flags);
		}

		private void EmitUnary(UnaryExpression node, CompilationFlags flags)
		{
			if (node.Method != null)
			{
				EmitUnaryMethod(node, flags);
			}
			else if (node.NodeType == ExpressionType.NegateChecked && node.Operand.Type.IsInteger())
			{
				Type type = node.Type;
				if (type.IsNullableType())
				{
					Label label = _ilg.DefineLabel();
					Label label2 = _ilg.DefineLabel();
					EmitExpression(node.Operand);
					LocalBuilder local = GetLocal(type);
					_ilg.Emit(OpCodes.Stloc, local);
					_ilg.Emit(OpCodes.Ldloca, local);
					_ilg.EmitGetValueOrDefault(type);
					_ilg.Emit(OpCodes.Brfalse_S, label);
					Type nonNullableType = type.GetNonNullableType();
					_ilg.EmitDefault(nonNullableType, null);
					_ilg.Emit(OpCodes.Ldloca, local);
					_ilg.EmitGetValueOrDefault(type);
					EmitBinaryOperator(ExpressionType.SubtractChecked, nonNullableType, nonNullableType, nonNullableType, liftedToNull: false);
					_ilg.Emit(OpCodes.Newobj, type.GetConstructor(new Type[1] { nonNullableType }));
					_ilg.Emit(OpCodes.Br_S, label2);
					_ilg.MarkLabel(label);
					_ilg.Emit(OpCodes.Ldloc, local);
					FreeLocal(local);
					_ilg.MarkLabel(label2);
				}
				else
				{
					_ilg.EmitDefault(type, null);
					EmitExpression(node.Operand);
					EmitBinaryOperator(ExpressionType.SubtractChecked, type, type, type, liftedToNull: false);
				}
			}
			else
			{
				EmitExpression(node.Operand);
				EmitUnaryOperator(node.NodeType, node.Operand.Type, node.Type);
			}
		}

		private void EmitUnaryOperator(ExpressionType op, Type operandType, Type resultType)
		{
			bool flag = operandType.IsNullableType();
			if (op == ExpressionType.ArrayLength)
			{
				_ilg.Emit(OpCodes.Ldlen);
				return;
			}
			if (flag)
			{
				switch (op)
				{
				case ExpressionType.UnaryPlus:
					return;
				case ExpressionType.TypeAs:
					if (operandType != resultType)
					{
						_ilg.Emit(OpCodes.Box, operandType);
						_ilg.Emit(OpCodes.Isinst, resultType);
						if (resultType.IsNullableType())
						{
							_ilg.Emit(OpCodes.Unbox_Any, resultType);
						}
					}
					return;
				}
				Label label = _ilg.DefineLabel();
				Label label2 = _ilg.DefineLabel();
				LocalBuilder local = GetLocal(operandType);
				_ilg.Emit(OpCodes.Stloc, local);
				_ilg.Emit(OpCodes.Ldloca, local);
				_ilg.EmitHasValue(operandType);
				_ilg.Emit(OpCodes.Brfalse_S, label);
				_ilg.Emit(OpCodes.Ldloca, local);
				_ilg.EmitGetValueOrDefault(operandType);
				Type nonNullableType = resultType.GetNonNullableType();
				EmitUnaryOperator(op, nonNullableType, nonNullableType);
				ConstructorInfo constructor = resultType.GetConstructor(new Type[1] { nonNullableType });
				_ilg.Emit(OpCodes.Newobj, constructor);
				_ilg.Emit(OpCodes.Br_S, label2);
				_ilg.MarkLabel(label);
				_ilg.Emit(OpCodes.Ldloc, local);
				FreeLocal(local);
				_ilg.MarkLabel(label2);
				return;
			}
			switch (op)
			{
			case ExpressionType.Not:
				if (operandType == typeof(bool))
				{
					_ilg.Emit(OpCodes.Ldc_I4_0);
					_ilg.Emit(OpCodes.Ceq);
					return;
				}
				goto case ExpressionType.OnesComplement;
			case ExpressionType.OnesComplement:
				_ilg.Emit(OpCodes.Not);
				if (!operandType.IsUnsigned())
				{
					return;
				}
				break;
			case ExpressionType.IsFalse:
				_ilg.Emit(OpCodes.Ldc_I4_0);
				_ilg.Emit(OpCodes.Ceq);
				return;
			case ExpressionType.IsTrue:
				_ilg.Emit(OpCodes.Ldc_I4_1);
				_ilg.Emit(OpCodes.Ceq);
				return;
			case ExpressionType.UnaryPlus:
				return;
			case ExpressionType.Negate:
			case ExpressionType.NegateChecked:
				_ilg.Emit(OpCodes.Neg);
				return;
			case ExpressionType.TypeAs:
				if (operandType != resultType)
				{
					if (operandType.IsValueType)
					{
						_ilg.Emit(OpCodes.Box, operandType);
					}
					_ilg.Emit(OpCodes.Isinst, resultType);
					if (resultType.IsNullableType())
					{
						_ilg.Emit(OpCodes.Unbox_Any, resultType);
					}
				}
				return;
			case ExpressionType.Increment:
				EmitConstantOne(resultType);
				_ilg.Emit(OpCodes.Add);
				break;
			case ExpressionType.Decrement:
				EmitConstantOne(resultType);
				_ilg.Emit(OpCodes.Sub);
				break;
			}
			EmitConvertArithmeticResult(op, resultType);
		}

		private void EmitConstantOne(Type type)
		{
			switch (type.GetTypeCode())
			{
			case TypeCode.Int64:
			case TypeCode.UInt64:
				_ilg.Emit(OpCodes.Ldc_I4_1);
				_ilg.Emit(OpCodes.Conv_I8);
				break;
			case TypeCode.Single:
				_ilg.Emit(OpCodes.Ldc_R4, 1f);
				break;
			case TypeCode.Double:
				_ilg.Emit(OpCodes.Ldc_R8, 1.0);
				break;
			default:
				_ilg.Emit(OpCodes.Ldc_I4_1);
				break;
			}
		}

		private void EmitUnboxUnaryExpression(Expression expr)
		{
			UnaryExpression unaryExpression = (UnaryExpression)expr;
			EmitExpression(unaryExpression.Operand);
			_ilg.Emit(OpCodes.Unbox_Any, unaryExpression.Type);
		}

		private void EmitConvertUnaryExpression(Expression expr, CompilationFlags flags)
		{
			EmitConvert((UnaryExpression)expr, flags);
		}

		private void EmitConvert(UnaryExpression node, CompilationFlags flags)
		{
			if (node.Method != null)
			{
				if (!node.IsLifted || (node.Type.IsValueType && node.Operand.Type.IsValueType))
				{
					EmitUnaryMethod(node, flags);
					return;
				}
				Type type = node.Method.GetParametersCached()[0].ParameterType;
				if (type.IsByRef)
				{
					type = type.GetElementType();
				}
				UnaryExpression arg = Expression.Convert(node.Operand, type);
				node = Expression.Convert(Expression.Call(node.Method, arg), node.Type);
			}
			if (node.Type == typeof(void))
			{
				EmitExpressionAsVoid(node.Operand, flags);
				return;
			}
			if (TypeUtils.AreEquivalent(node.Operand.Type, node.Type))
			{
				EmitExpression(node.Operand, flags);
				return;
			}
			EmitExpression(node.Operand);
			_ilg.EmitConvertToType(node.Operand.Type, node.Type, node.NodeType == ExpressionType.ConvertChecked, this);
		}

		private void EmitUnaryMethod(UnaryExpression node, CompilationFlags flags)
		{
			if (node.IsLifted)
			{
				ParameterExpression parameterExpression = Expression.Variable(node.Operand.Type.GetNonNullableType(), null);
				MethodCallExpression methodCallExpression = Expression.Call(node.Method, parameterExpression);
				Type nullableType = methodCallExpression.Type.GetNullableType();
				EmitLift(node.NodeType, nullableType, methodCallExpression, new ParameterExpression[1] { parameterExpression }, new Expression[1] { node.Operand });
				_ilg.EmitConvertToType(nullableType, node.Type, isChecked: false, this);
			}
			else
			{
				EmitMethodCallExpression(Expression.Call(node.Method, node.Operand), flags);
			}
		}

		private LambdaCompiler(AnalyzedTree tree, LambdaExpression lambda)
		{
			Type[] parameterTypes = GetParameterTypes(lambda, typeof(Closure));
			DynamicMethod dynamicMethod = new DynamicMethod(lambda.Name ?? "lambda_method", lambda.ReturnType, parameterTypes, restrictedSkipVisibility: true);
			_tree = tree;
			_lambda = lambda;
			_method = dynamicMethod;
			_ilg = dynamicMethod.GetILGenerator();
			_hasClosureArgument = true;
			_scope = tree.Scopes[lambda];
			_boundConstants = tree.Constants[lambda];
			InitializeMethod();
		}

		private LambdaCompiler(AnalyzedTree tree, LambdaExpression lambda, MethodBuilder method)
		{
			CompilerScope compilerScope = tree.Scopes[lambda];
			bool needsClosure = compilerScope.NeedsClosure;
			Type[] parameterTypes = GetParameterTypes(lambda, needsClosure ? typeof(Closure) : null);
			method.SetReturnType(lambda.ReturnType);
			method.SetParameters(parameterTypes);
			ReadOnlyCollection<ParameterExpression> parameters = lambda.Parameters;
			int num = ((!needsClosure) ? 1 : 2);
			int i = 0;
			for (int count = parameters.Count; i < count; i++)
			{
				method.DefineParameter(i + num, ParameterAttributes.None, parameters[i].Name);
			}
			_tree = tree;
			_lambda = lambda;
			_typeBuilder = (TypeBuilder)method.DeclaringType;
			_method = method;
			_hasClosureArgument = needsClosure;
			_ilg = method.GetILGenerator();
			_scope = compilerScope;
			_boundConstants = tree.Constants[lambda];
			InitializeMethod();
		}

		private LambdaCompiler(LambdaCompiler parent, LambdaExpression lambda, InvocationExpression invocation)
		{
			_tree = parent._tree;
			_lambda = lambda;
			_method = parent._method;
			_ilg = parent._ilg;
			_hasClosureArgument = parent._hasClosureArgument;
			_typeBuilder = parent._typeBuilder;
			_scope = _tree.Scopes[invocation];
			_boundConstants = parent._boundConstants;
		}

		private void InitializeMethod()
		{
			AddReturnLabel(_lambda);
			_boundConstants.EmitCacheConstants(this);
		}

		internal static Delegate Compile(LambdaExpression lambda)
		{
			lambda.ValidateArgumentCount();
			LambdaCompiler lambdaCompiler = new LambdaCompiler(AnalyzeLambda(ref lambda), lambda);
			lambdaCompiler.EmitLambdaBody();
			return lambdaCompiler.CreateDelegate();
		}

		internal static void Compile(LambdaExpression lambda, MethodBuilder method)
		{
			new LambdaCompiler(AnalyzeLambda(ref lambda), lambda, method).EmitLambdaBody();
		}

		private static AnalyzedTree AnalyzeLambda(ref LambdaExpression lambda)
		{
			lambda = StackSpiller.AnalyzeLambda(lambda);
			return VariableBinder.Bind(lambda);
		}

		public LocalBuilder GetLocal(Type type)
		{
			return _freeLocals.TryPop(type) ?? _ilg.DeclareLocal(type);
		}

		public void FreeLocal(LocalBuilder local)
		{
			_freeLocals.Push(local.LocalType, local);
		}

		internal int GetLambdaArgument(int index)
		{
			return index + (_hasClosureArgument ? 1 : 0) + ((!_method.IsStatic) ? 1 : 0);
		}

		internal void EmitLambdaArgument(int index)
		{
			_ilg.EmitLoadArg(GetLambdaArgument(index));
		}

		internal void EmitClosureArgument()
		{
			_ilg.EmitLoadArg(0);
		}

		private Delegate CreateDelegate()
		{
			return _method.CreateDelegate(_lambda.Type, new Closure(_boundConstants.ToArray(), null));
		}

		private FieldBuilder CreateStaticField(string name, Type type)
		{
			return _typeBuilder.DefineField("<ExpressionCompilerImplementationDetails>{" + Interlocked.Increment(ref s_counter) + "}" + name, type, FieldAttributes.Private | FieldAttributes.Static);
		}

		private MemberExpression CreateLazyInitializedField<T>(string name)
		{
			if (_method is DynamicMethod)
			{
				return Expression.Field(Expression.Constant(new StrongBox<T>(default(T))), "Value");
			}
			return Expression.Field(null, CreateStaticField(name, typeof(T)));
		}
	}
	internal interface ILocalCache
	{
		LocalBuilder GetLocal(Type type);

		void FreeLocal(LocalBuilder local);
	}
	internal sealed class StackSpiller
	{
		private abstract class BindingRewriter
		{
			protected readonly MemberBinding _binding;

			protected readonly StackSpiller _spiller;

			protected RewriteAction _action;

			internal RewriteAction Action => _action;

			internal BindingRewriter(MemberBinding binding, StackSpiller spiller)
			{
				_binding = binding;
				_spiller = spiller;
			}

			internal abstract MemberBinding AsBinding();

			internal abstract Expression AsExpression(Expression target);

			internal static BindingRewriter Create(MemberBinding binding, StackSpiller spiller, Stack stack)
			{
				return binding.BindingType switch
				{
					MemberBindingType.Assignment => new MemberAssignmentRewriter((MemberAssignment)binding, spiller, stack), 
					MemberBindingType.ListBinding => new ListBindingRewriter((MemberListBinding)binding, spiller, stack), 
					MemberBindingType.MemberBinding => new MemberMemberBindingRewriter((MemberMemberBinding)binding, spiller, stack), 
					_ => throw Error.UnhandledBinding(), 
				};
			}

			protected void RequireNoValueProperty()
			{
				PropertyInfo propertyInfo = _binding.Member as PropertyInfo;
				if (propertyInfo != null && propertyInfo.PropertyType.IsValueType)
				{
					throw Error.CannotAutoInitializeValueTypeMemberThroughProperty(propertyInfo);
				}
			}
		}

		private sealed class MemberMemberBindingRewriter : BindingRewriter
		{
			private readonly ReadOnlyCollection<MemberBinding> _bindings;

			private readonly BindingRewriter[] _bindingRewriters;

			internal MemberMemberBindingRewriter(MemberMemberBinding binding, StackSpiller spiller, Stack stack)
				: base(binding, spiller)
			{
				_bindings = binding.Bindings;
				int count = _bindings.Count;
				_bindingRewriters = new BindingRewriter[count];
				for (int i = 0; i < count; i++)
				{
					BindingRewriter bindingRewriter = BindingRewriter.Create(_bindings[i], spiller, stack);
					_action |= bindingRewriter.Action;
					_bindingRewriters[i] = bindingRewriter;
				}
			}

			internal override MemberBinding AsBinding()
			{
				switch (_action)
				{
				case RewriteAction.None:
					return _binding;
				case RewriteAction.Copy:
				{
					int count = _bindings.Count;
					MemberBinding[] array = new MemberBinding[count];
					for (int i = 0; i < count; i++)
					{
						array[i] = _bindingRewriters[i].AsBinding();
					}
					return new MemberMemberBinding(_binding.Member, new TrueReadOnlyCollection<MemberBinding>(array));
				}
				default:
					throw ContractUtils.Unreachable;
				}
			}

			internal override Expression AsExpression(Expression target)
			{
				RequireNoValueProperty();
				Expression expression = MemberExpression.Make(target, _binding.Member);
				Expression expression2 = _spiller.MakeTemp(expression.Type);
				int count = _bindings.Count;
				Expression[] array = new Expression[count + 2];
				array[0] = new AssignBinaryExpression(expression2, expression);
				for (int i = 0; i < count; i++)
				{
					BindingRewriter bindingRewriter = _bindingRewriters[i];
					array[i + 1] = bindingRewriter.AsExpression(expression2);
				}
				if (expression2.Type.IsValueType)
				{
					array[count + 1] = Expression.Block(typeof(void), new AssignBinaryExpression(MemberExpression.Make(target, _binding.Member), expression2));
				}
				else
				{
					array[count + 1] = Utils.Empty;
				}
				return MakeBlock(array);
			}
		}

		private sealed class ListBindingRewriter : BindingRewriter
		{
			private readonly ReadOnlyCollection<ElementInit> _inits;

			private readonly ChildRewriter[] _childRewriters;

			internal ListBindingRewriter(MemberListBinding binding, StackSpiller spiller, Stack stack)
				: base(binding, spiller)
			{
				_inits = binding.Initializers;
				int count = _inits.Count;
				_childRewriters = new ChildRewriter[count];
				for (int i = 0; i < count; i++)
				{
					ElementInit elementInit = _inits[i];
					ChildRewriter childRewriter = new ChildRewriter(spiller, stack, elementInit.Arguments.Count);
					childRewriter.Add(elementInit.Arguments);
					_action |= childRewriter.Action;
					_childRewriters[i] = childRewriter;
				}
			}

			internal override MemberBinding AsBinding()
			{
				switch (_action)
				{
				case RewriteAction.None:
					return _binding;
				case RewriteAction.Copy:
				{
					int count = _inits.Count;
					ElementInit[] array = new ElementInit[count];
					for (int i = 0; i < count; i++)
					{
						ChildRewriter childRewriter = _childRewriters[i];
						if (childRewriter.Action == RewriteAction.None)
						{
							array[i] = _inits[i];
						}
						else
						{
							array[i] = new ElementInit(_inits[i].AddMethod, new TrueReadOnlyCollection<Expression>(childRewriter[0, -1]));
						}
					}
					return new MemberListBinding(_binding.Member, new TrueReadOnlyCollection<ElementInit>(array));
				}
				default:
					throw ContractUtils.Unreachable;
				}
			}

			internal override Expression AsExpression(Expression target)
			{
				RequireNoValueProperty();
				Expression expression = MemberExpression.Make(target, _binding.Member);
				Expression expression2 = _spiller.MakeTemp(expression.Type);
				int count = _inits.Count;
				Expression[] array = new Expression[count + 2];
				array[0] = new AssignBinaryExpression(expression2, expression);
				for (int i = 0; i < count; i++)
				{
					ChildRewriter childRewriter = _childRewriters[i];
					array[i + 1] = childRewriter.Finish(new InstanceMethodCallExpressionN(_inits[i].AddMethod, expression2, childRewriter[0, -1])).Node;
				}
				if (expression2.Type.IsValueType)
				{
					array[count + 1] = Expression.Block(typeof(void), new AssignBinaryExpression(MemberExpression.Make(target, _binding.Member), expression2));
				}
				else
				{
					array[count + 1] = Utils.Empty;
				}
				return MakeBlock(array);
			}
		}

		private sealed class MemberAssignmentRewriter : BindingRewriter
		{
			private readonly Expression _rhs;

			internal MemberAssignmentRewriter(MemberAssignment binding, StackSpiller spiller, Stack stack)
				: base(binding, spiller)
			{
				Result result = spiller.RewriteExpression(binding.Expression, stack);
				_action = result.Action;
				_rhs = result.Node;
			}

			internal override MemberBinding AsBinding()
			{
				return _action switch
				{
					RewriteAction.None => _binding, 
					RewriteAction.Copy => new MemberAssignment(_binding.Member, _rhs), 
					_ => throw ContractUtils.Unreachable, 
				};
			}

			internal override Expression AsExpression(Expression target)
			{
				Expression expression = MemberExpression.Make(target, _binding.Member);
				Expression expression2 = _spiller.MakeTemp(expression.Type);
				return MakeBlock(new AssignBinaryExpression(expression2, _rhs), new AssignBinaryExpression(expression, expression2), Utils.Empty);
			}
		}

		private sealed class ChildRewriter
		{
			private readonly StackSpiller _self;

			private readonly Expression[] _expressions;

			private int _expressionsCount;

			private int _lastSpillIndex;

			private List<Expression> _comma;

			private RewriteAction _action;

			private Stack _stack;

			private bool _done;

			private bool[] _byRefs;

			internal bool Rewrite => _action != RewriteAction.None;

			internal RewriteAction Action => _action;

			internal Expression this[int index]
			{
				get
				{
					EnsureDone();
					if (index < 0)
					{
						index += _expressions.Length;
					}
					return _expressions[index];
				}
			}

			internal Expression[] this[int first, int last]
			{
				get
				{
					EnsureDone();
					if (last < 0)
					{
						last += _expressions.Length;
					}
					int num = last - first + 1;
					ContractUtils.RequiresArrayRange(_expressions, first, num, "first", "last");
					if (num == _expressions.Length)
					{
						return _expressions;
					}
					Expression[] array = new Expression[num];
					Array.Copy(_expressions, first, array, 0, num);
					return array;
				}
			}

			internal ChildRewriter(StackSpiller self, Stack stack, int count)
			{
				_self = self;
				_stack = stack;
				_expressions = new Expression[count];
			}

			internal void Add(Expression expression)
			{
				if (expression == null)
				{
					_expressions[_expressionsCount++] = null;
					return;
				}
				Result result = _self.RewriteExpression(expression, _stack);
				_action |= result.Action;
				_stack = Stack.NonEmpty;
				if (result.Action == RewriteAction.SpillStack)
				{
					_lastSpillIndex = _expressionsCount;
				}
				_expressions[_expressionsCount++] = result.Node;
			}

			internal void Add(ReadOnlyCollection<Expression> expressions)
			{
				int i = 0;
				for (int count = expressions.Count; i < count; i++)
				{
					Add(expressions[i]);
				}
			}

			internal void AddArguments(IArgumentProvider expressions)
			{
				int i = 0;
				for (int argumentCount = expressions.ArgumentCount; i < argumentCount; i++)
				{
					Add(expressions.GetArgument(i));
				}
			}

			private void EnsureDone()
			{
				if (_done)
				{
					return;
				}
				_done = true;
				if (_action != RewriteAction.SpillStack)
				{
					return;
				}
				Expression[] expressions = _expressions;
				int num = _lastSpillIndex + 1;
				List<Expression> list = new List<Expression>(num + 1);
				for (int i = 0; i < num; i++)
				{
					Expression expression = expressions[i];
					if (ShouldSaveToTemp(expression))
					{
						int num2 = i;
						StackSpiller self = _self;
						bool[] byRefs = _byRefs;
						expressions[num2] = self.ToTemp(expression, out var save, byRefs != null && byRefs[i]);
						list.Add(save);
					}
				}
				list.Capacity = list.Count + 1;
				_comma = list;
			}

			private static bool ShouldSaveToTemp(Expression expression)
			{
				if (expression == null)
				{
					return false;
				}
				switch (expression.NodeType)
				{
				case ExpressionType.Constant:
				case ExpressionType.Default:
					return false;
				case ExpressionType.RuntimeVariables:
					return false;
				case ExpressionType.MemberAccess:
				{
					FieldInfo fieldInfo = ((MemberExpression)expression).Member as FieldInfo;
					if (fieldInfo != null)
					{
						if (fieldInfo.IsLiteral)
						{
							return false;
						}
						if (fieldInfo.IsInitOnly && fieldInfo.IsStatic)
						{
							return false;
						}
					}
					break;
				}
				}
				return true;
			}

			internal void MarkRefInstance(Expression expr)
			{
				if (IsRefInstance(expr))
				{
					MarkRef(0);
				}
			}

			internal void MarkRefArgs(MethodBase method, int startIndex)
			{
				ParameterInfo[] parametersCached = method.GetParametersCached();
				int i = 0;
				for (int num = parametersCached.Length; i < num; i++)
				{
					if (parametersCached[i].ParameterType.IsByRef)
					{
						MarkRef(startIndex + i);
					}
				}
			}

			private void MarkRef(int index)
			{
				if (_byRefs == null)
				{
					_byRefs = new bool[_expressions.Length];
				}
				_byRefs[index] = true;
			}

			internal Result Finish(Expression expression)
			{
				EnsureDone();
				if (_action == RewriteAction.SpillStack)
				{
					_comma.Add(expression);
					expression = MakeBlock(_comma);
				}
				return new Result(_action, expression);
			}
		}

		private sealed class TempMaker
		{
			private int _temp;

			private List<ParameterExpression> _freeTemps;

			private Stack<ParameterExpression> _usedTemps;

			internal List<ParameterExpression> Temps { get; } = new List<ParameterExpression>();

			internal ParameterExpression Temp(Type type)
			{
				ParameterExpression parameterExpression;
				if (_freeTemps != null)
				{
					for (int num = _freeTemps.Count - 1; num >= 0; num--)
					{
						parameterExpression = _freeTemps[num];
						if (parameterExpression.Type == type)
						{
							_freeTemps.RemoveAt(num);
							return UseTemp(parameterExpression);
						}
					}
				}
				parameterExpression = ParameterExpression.Make(type, "$temp$" + _temp++, isByRef: false);
				Temps.Add(parameterExpression);
				return UseTemp(parameterExpression);
			}

			private ParameterExpression UseTemp(ParameterExpression temp)
			{
				if (_usedTemps == null)
				{
					_usedTemps = new Stack<ParameterExpression>();
				}
				_usedTemps.Push(temp);
				return temp;
			}

			private void FreeTemp(ParameterExpression temp)
			{
				if (_freeTemps == null)
				{
					_freeTemps = new List<ParameterExpression>();
				}
				_freeTemps.Add(temp);
			}

			internal int Mark()
			{
				return _usedTemps?.Count ?? 0;
			}

			internal void Free(int mark)
			{
				if (_usedTemps != null)
				{
					while (mark < _usedTemps.Count)
					{
						FreeTemp(_usedTemps.Pop());
					}
				}
			}

			[Conditional("DEBUG")]
			internal void VerifyTemps()
			{
			}
		}

		private enum Stack
		{
			Empty,
			NonEmpty
		}

		[Flags]
		private enum RewriteAction
		{
			None = 0,
			Copy = 1,
			SpillStack = 3
		}

		private readonly struct Result
		{
			internal readonly RewriteAction Action;

			internal readonly Expression Node;

			internal Result(RewriteAction action, Expression node)
			{
				Action = action;
				Node = node;
			}
		}

		private readonly StackGuard _guard = new StackGuard();

		private readonly TempMaker _tm = new TempMaker();

		private readonly Stack _startingStack;

		private RewriteAction _lambdaRewrite;

		private Result RewriteExpression(Expression node, Stack stack)
		{
			if (node == null)
			{
				return new Result(RewriteAction.None, null);
			}
			if (!_guard.TryEnterOnCurrentStack())
			{
				return _guard.RunOnEmptyStack((StackSpiller @this, Expression n, Stack s) => @this.RewriteExpression(n, s), this, node, stack);
			}
			Result result;
			switch (node.NodeType)
			{
			case ExpressionType.Add:
			case ExpressionType.AddChecked:
			case ExpressionType.And:
			case ExpressionType.ArrayIndex:
			case ExpressionType.Divide:
			case ExpressionType.Equal:
			case ExpressionType.ExclusiveOr:
			case ExpressionType.GreaterThan:
			case ExpressionType.GreaterThanOrEqual:
			case ExpressionType.LeftShift:
			case ExpressionType.LessThan:
			case ExpressionType.LessThanOrEqual:
			case ExpressionType.Modulo:
			case ExpressionType.Multiply:
			case ExpressionType.MultiplyChecked:
			case ExpressionType.NotEqual:
			case ExpressionType.Or:
			case ExpressionType.Power:
			case ExpressionType.RightShift:
			case ExpressionType.Subtract:
			case ExpressionType.SubtractChecked:
				result = RewriteBinaryExpression(node, stack);
				break;
			case ExpressionType.AndAlso:
			case ExpressionType.Coalesce:
			case ExpressionType.OrElse:
				result = RewriteLogicalBinaryExpression(node, stack);
				break;
			case ExpressionType.Assign:
				result = RewriteAssignBinaryExpression(node, stack);
				break;
			case ExpressionType.ArrayLength:
			case ExpressionType.Convert:
			case ExpressionType.ConvertChecked:
			case ExpressionType.Negate:
			case ExpressionType.UnaryPlus:
			case ExpressionType.NegateChecked:
			case ExpressionType.Not:
			case ExpressionType.TypeAs:
			case ExpressionType.Decrement:
			case ExpressionType.Increment:
			case ExpressionType.Unbox:
			case ExpressionType.OnesComplement:
			case ExpressionType.IsTrue:
			case ExpressionType.IsFalse:
				result = RewriteUnaryExpression(node, stack);
				break;
			case ExpressionType.Throw:
				result = RewriteThrowUnaryExpression(node, stack);
				break;
			case ExpressionType.Call:
				result = RewriteMethodCallExpression(node, stack);
				break;
			case ExpressionType.Conditional:
				result = RewriteConditionalExpression(node, stack);
				break;
			case ExpressionType.Invoke:
				result = RewriteInvocationExpression(node, stack);
				break;
			case ExpressionType.Lambda:
				result = RewriteLambdaExpression(node);
				break;
			case ExpressionType.ListInit:
				result = RewriteListInitExpression(node, stack);
				break;
			case ExpressionType.MemberAccess:
				result = RewriteMemberExpression(node, stack);
				break;
			case ExpressionType.MemberInit:
				result = RewriteMemberInitExpression(node, stack);
				break;
			case ExpressionType.New:
				result = RewriteNewExpression(node, stack);
				break;
			case ExpressionType.NewArrayInit:
			case ExpressionType.NewArrayBounds:
				result = RewriteNewArrayExpression(node, stack);
				break;
			case ExpressionType.TypeIs:
			case ExpressionType.TypeEqual:
				result = RewriteTypeBinaryExpression(node, stack);
				break;
			case ExpressionType.Block:
				result = RewriteBlockExpression(node, stack);
				break;
			case ExpressionType.Dynamic:
				result = RewriteDynamicExpression(node);
				break;
			case ExpressionType.Extension:
				result = RewriteExtensionExpression(node, stack);
				break;
			case ExpressionType.Goto:
				result = RewriteGotoExpression(node, stack);
				break;
			case ExpressionType.Index:
				result = RewriteIndexExpression(node, stack);
				break;
			case ExpressionType.Label:
				result = RewriteLabelExpression(node, stack);
				break;
			case ExpressionType.Loop:
				result = RewriteLoopExpression(node, stack);
				break;
			case ExpressionType.Switch:
				result = RewriteSwitchExpression(node, stack);
				break;
			case ExpressionType.Try:
				result = RewriteTryExpression(node, stack);
				break;
			case ExpressionType.AddAssign:
			case ExpressionType.AndAssign:
			case ExpressionType.DivideAssign:
			case ExpressionType.ExclusiveOrAssign:
			case ExpressionType.LeftShiftAssign:
			case ExpressionType.ModuloAssign:
			case ExpressionType.MultiplyAssign:
			case ExpressionType.OrAssign:
			case ExpressionType.PowerAssign:
			case ExpressionType.RightShiftAssign:
			case ExpressionType.SubtractAssign:
			case ExpressionType.AddAssignChecked:
			case ExpressionType.MultiplyAssignChecked:
			case ExpressionType.SubtractAssignChecked:
			case ExpressionType.PreIncrementAssign:
			case ExpressionType.PreDecrementAssign:
			case ExpressionType.PostIncrementAssign:
			case ExpressionType.PostDecrementAssign:
				result = RewriteReducibleExpression(node, stack);
				break;
			case ExpressionType.Constant:
			case ExpressionType.Parameter:
			case ExpressionType.Quote:
			case ExpressionType.DebugInfo:
			case ExpressionType.Default:
			case ExpressionType.RuntimeVariables:
				result = new Result(RewriteAction.None, node);
				break;
			default:
				result = RewriteExpression(node.ReduceAndCheck(), stack);
				if (result.Action == RewriteAction.None)
				{
					result = new Result(result.Action | RewriteAction.Copy, result.Node);
				}
				break;
			}
			return result;
		}

		private static Expression MakeBlock(ArrayBuilder<Expression> expressions)
		{
			return new SpilledExpressionBlock(expressions.ToArray());
		}

		private static Expression MakeBlock(params Expression[] expressions)
		{
			return new SpilledExpressionBlock(expressions);
		}

		private static Expression MakeBlock(IReadOnlyList<Expression> expressions)
		{
			return new SpilledExpressionBlock(expressions);
		}

		private ParameterExpression MakeTemp(Type type)
		{
			return _tm.Temp(type);
		}

		private int Mark()
		{
			return _tm.Mark();
		}

		private void Free(int mark)
		{
			_tm.Free(mark);
		}

		[Conditional("DEBUG")]
		private void VerifyTemps()
		{
		}

		private ParameterExpression ToTemp(Expression expression, out Expression save, bool byRef)
		{
			Type type = (byRef ? expression.Type.MakeByRefType() : expression.Type);
			ParameterExpression parameterExpression = MakeTemp(type);
			save = AssignBinaryExpression.Make(parameterExpression, expression, byRef);
			return parameterExpression;
		}

		internal static LambdaExpression AnalyzeLambda(LambdaExpression lambda)
		{
			return lambda.Accept(new StackSpiller(Stack.Empty));
		}

		private StackSpiller(Stack stack)
		{
			_startingStack = stack;
		}

		internal Expression<T> Rewrite<T>(Expression<T> lambda)
		{
			Result result = RewriteExpressionFreeTemps(lambda.Body, _startingStack);
			_lambdaRewrite = result.Action;
			if (result.Action != RewriteAction.None)
			{
				Expression expression = result.Node;
				if (_tm.Temps.Count > 0)
				{
					expression = Expression.Block(_tm.Temps, new TrueReadOnlyCollection<Expression>(expression));
				}
				return Expression<T>.Create(expression, lambda.Name, lambda.TailCall, new ParameterList(lambda));
			}
			return lambda;
		}

		[Conditional("DEBUG")]
		private static void VerifyRewrite(Result result, Expression node)
		{
		}

		private Result RewriteExpressionFreeTemps(Expression expression, Stack stack)
		{
			int mark = Mark();
			Result result = RewriteExpression(expression, stack);
			Free(mark);
			return result;
		}

		private Result RewriteDynamicExpression(Expression expr)
		{
			IDynamicExpression dynamicExpression = (IDynamicExpression)expr;
			ChildRewriter childRewriter = new ChildRewriter(this, Stack.NonEmpty, dynamicExpression.ArgumentCount);
			childRewriter.AddArguments(dynamicExpression);
			if (childRewriter.Action == RewriteAction.SpillStack)
			{
				RequireNoRefArgs(dynamicExpression.DelegateType.GetInvokeMethod());
			}
			return childRewriter.Finish(childRewriter.Rewrite ? dynamicExpression.Rewrite(childRewriter[0, -1]) : expr);
		}

		private Result RewriteIndexAssignment(BinaryExpression node, Stack stack)
		{
			IndexExpression indexExpression = (IndexExpression)node.Left;
			ChildRewriter childRewriter = new ChildRewriter(this, stack, 2 + indexExpression.ArgumentCount);
			childRewriter.Add(indexExpression.Object);
			childRewriter.AddArguments(indexExpression);
			childRewriter.Add(node.Right);
			if (childRewriter.Action == RewriteAction.SpillStack)
			{
				childRewriter.MarkRefInstance(indexExpression.Object);
			}
			if (childRewriter.Rewrite)
			{
				node = new AssignBinaryExpression(new IndexExpression(childRewriter[0], indexExpression.Indexer, childRewriter[1, -2]), childRewriter[-1]);
			}
			return childRewriter.Finish(node);
		}

		private Result RewriteLogicalBinaryExpression(Expression expr, Stack stack)
		{
			BinaryExpression binaryExpression = (BinaryExpression)expr;
			Result result = RewriteExpression(binaryExpression.Left, stack);
			Result result2 = RewriteExpression(binaryExpression.Right, stack);
			Result result3 = RewriteExpression(binaryExpression.Conversion, stack);
			RewriteAction num = result.Action | result2.Action | result3.Action;
			if (num != RewriteAction.None)
			{
				expr = BinaryExpression.Create(binaryExpression.NodeType, result.Node, result2.Node, binaryExpression.Type, binaryExpression.Method, (LambdaExpression)result3.Node);
			}
			return new Result(num, expr);
		}

		private Result RewriteReducibleExpression(Expression expr, Stack stack)
		{
			Result result = RewriteExpression(expr.Reduce(), stack);
			return new Result(result.Action | RewriteAction.Copy, result.Node);
		}

		private Result RewriteBinaryExpression(Expression expr, Stack stack)
		{
			BinaryExpression binaryExpression = (BinaryExpression)expr;
			ChildRewriter childRewriter = new ChildRewriter(this, stack, 3);
			childRewriter.Add(binaryExpression.Left);
			childRewriter.Add(binaryExpression.Right);
			childRewriter.Add(binaryExpression.Conversion);
			if (childRewriter.Action == RewriteAction.SpillStack)
			{
				RequireNoRefArgs(binaryExpression.Method);
			}
			return childRewriter.Finish(childRewriter.Rewrite ? BinaryExpression.Create(binaryExpression.NodeType, childRewriter[0], childRewriter[1], binaryExpression.Type, binaryExpression.Method, (LambdaExpression)childRewriter[2]) : expr);
		}

		private Result RewriteVariableAssignment(BinaryExpression node, Stack stack)
		{
			Result result = RewriteExpression(node.Right, stack);
			if (result.Action != RewriteAction.None)
			{
				node = new AssignBinaryExpression(node.Left, result.Node);
			}
			return new Result(result.Action, node);
		}

		private Result RewriteAssignBinaryExpression(Expression expr, Stack stack)
		{
			BinaryExpression binaryExpression = (BinaryExpression)expr;
			return binaryExpression.Left.NodeType switch
			{
				ExpressionType.Index => RewriteIndexAssignment(binaryExpression, stack), 
				ExpressionType.MemberAccess => RewriteMemberAssignment(binaryExpression, stack), 
				ExpressionType.Parameter => RewriteVariableAssignment(binaryExpression, stack), 
				ExpressionType.Extension => RewriteExtensionAssignment(binaryExpression, stack), 
				_ => throw Error.InvalidLvalue(binaryExpression.Left.NodeType), 
			};
		}

		private Result RewriteExtensionAssignment(BinaryExpression node, Stack stack)
		{
			node = new AssignBinaryExpression(node.Left.ReduceExtensions(), node.Right);
			Result result = RewriteAssignBinaryExpression(node, stack);
			return new Result(result.Action | RewriteAction.Copy, result.Node);
		}

		private static Result RewriteLambdaExpression(Expression expr)
		{
			LambdaExpression lambdaExpression = (LambdaExpression)expr;
			expr = AnalyzeLambda(lambdaExpression);
			return new Result((expr != lambdaExpression) ? RewriteAction.Copy : RewriteAction.None, expr);
		}

		private Result RewriteConditionalExpression(Expression expr, Stack stack)
		{
			ConditionalExpression conditionalExpression = (ConditionalExpression)expr;
			Result result = RewriteExpression(conditionalExpression.Test, stack);
			Result result2 = RewriteExpression(conditionalExpression.IfTrue, stack);
			Result result3 = RewriteExpression(conditionalExpression.IfFalse, stack);
			RewriteAction num = result.Action | result2.Action | result3.Action;
			if (num != RewriteAction.None)
			{
				expr = ConditionalExpression.Make(result.Node, result2.Node, result3.Node, conditionalExpression.Type);
			}
			return new Result(num, expr);
		}

		private Result RewriteMemberAssignment(BinaryExpression node, Stack stack)
		{
			MemberExpression memberExpression = (MemberExpression)node.Left;
			ChildRewriter childRewriter = new ChildRewriter(this, stack, 2);
			childRewriter.Add(memberExpression.Expression);
			childRewriter.Add(node.Right);
			if (childRewriter.Action == RewriteAction.SpillStack)
			{
				childRewriter.MarkRefInstance(memberExpression.Expression);
			}
			if (childRewriter.Rewrite)
			{
				return childRewriter.Finish(new AssignBinaryExpression(MemberExpression.Make(childRewriter[0], memberExpression.Member), childRewriter[1]));
			}
			return new Result(RewriteAction.None, node);
		}

		private Result RewriteMemberExpression(Expression expr, Stack stack)
		{
			MemberExpression memberExpression = (MemberExpression)expr;
			Result result = RewriteExpression(memberExpression.Expression, stack);
			if (result.Action != RewriteAction.None)
			{
				if (result.Action == RewriteAction.SpillStack && memberExpression.Member is PropertyInfo)
				{
					RequireNotRefInstance(memberExpression.Expression);
				}
				expr = MemberExpression.Make(result.Node, memberExpression.Member);
			}
			return new Result(result.Action, expr);
		}

		private Result RewriteIndexExpression(Expression expr, Stack stack)
		{
			IndexExpression indexExpression = (IndexExpression)expr;
			ChildRewriter childRewriter = new ChildRewriter(this, stack, indexExpression.ArgumentCount + 1);
			childRewriter.Add(indexExpression.Object);
			childRewriter.AddArguments(indexExpression);
			if (childRewriter.Action == RewriteAction.SpillStack)
			{
				childRewriter.MarkRefInstance(indexExpression.Object);
			}
			if (childRewriter.Rewrite)
			{
				expr = new IndexExpression(childRewriter[0], indexExpression.Indexer, childRewriter[1, -1]);
			}
			return childRewriter.Finish(expr);
		}

		private Result RewriteMethodCallExpression(Expression expr, Stack stack)
		{
			MethodCallExpression methodCallExpression = (MethodCallExpression)expr;
			ChildRewriter childRewriter = new ChildRewriter(this, stack, methodCallExpression.ArgumentCount + 1);
			childRewriter.Add(methodCallExpression.Object);
			childRewriter.AddArguments(methodCallExpression);
			if (childRewriter.Action == RewriteAction.SpillStack)
			{
				childRewriter.MarkRefInstance(methodCallExpression.Object);
				childRewriter.MarkRefArgs(methodCallExpression.Method, 1);
			}
			if (childRewriter.Rewrite)
			{
				expr = ((methodCallExpression.Object == null) ? ((MethodCallExpression)new MethodCallExpressionN(methodCallExpression.Method, childRewriter[1, -1])) : ((MethodCallExpression)new InstanceMethodCallExpressionN(methodCallExpression.Method, childRewriter[0], childRewriter[1, -1])));
			}
			return childRewriter.Finish(expr);
		}

		private Result RewriteNewArrayExpression(Expression expr, Stack stack)
		{
			NewArrayExpression newArrayExpression = (NewArrayExpression)expr;
			if (newArrayExpression.NodeType == ExpressionType.NewArrayInit)
			{
				stack = Stack.NonEmpty;
			}
			ChildRewriter childRewriter = new ChildRewriter(this, stack, newArrayExpression.Expressions.Count);
			childRewriter.Add(newArrayExpression.Expressions);
			if (childRewriter.Rewrite)
			{
				expr = NewArrayExpression.Make(newArrayExpression.NodeType, newArrayExpression.Type, new TrueReadOnlyCollection<Expression>(childRewriter[0, -1]));
			}
			return childRewriter.Finish(expr);
		}

		private Result RewriteInvocationExpression(Expression expr, Stack stack)
		{
			InvocationExpression invocationExpression = (InvocationExpression)expr;
			LambdaExpression lambdaOperand = invocationExpression.LambdaOperand;
			ChildRewriter childRewriter;
			if (lambdaOperand != null)
			{
				childRewriter = new ChildRewriter(this, stack, invocationExpression.ArgumentCount);
				childRewriter.AddArguments(invocationExpression);
				if (childRewriter.Action == RewriteAction.SpillStack)
				{
					childRewriter.MarkRefArgs(Expression.GetInvokeMethod(invocationExpression.Expression), 0);
				}
				StackSpiller stackSpiller = new StackSpiller(stack);
				lambdaOperand = lambdaOperand.Accept(stackSpiller);
				if (childRewriter.Rewrite || stackSpiller._lambdaRewrite != RewriteAction.None)
				{
					invocationExpression = new InvocationExpressionN(lambdaOperand, childRewriter[0, -1], invocationExpression.Type);
				}
				Result result = childRewriter.Finish(invocationExpression);
				return new Result(result.Action | stackSpiller._lambdaRewrite, result.Node);
			}
			childRewriter = new ChildRewriter(this, stack, invocationExpression.ArgumentCount + 1);
			childRewriter.Add(invocationExpression.Expression);
			childRewriter.AddArguments(invocationExpression);
			if (childRewriter.Action == RewriteAction.SpillStack)
			{
				childRewriter.MarkRefArgs(Expression.GetInvokeMethod(invocationExpression.Expression), 1);
			}
			return childRewriter.Finish(childRewriter.Rewrite ? new InvocationExpressionN(childRewriter[0], childRewriter[1, -1], invocationExpression.Type) : expr);
		}

		private Result RewriteNewExpression(Expression expr, Stack stack)
		{
			NewExpression newExpression = (NewExpression)expr;
			ChildRewriter childRewriter = new ChildRewriter(this, stack, newExpression.ArgumentCount);
			childRewriter.AddArguments(newExpression);
			if (childRewriter.Action == RewriteAction.SpillStack)
			{
				childRewriter.MarkRefArgs(newExpression.Constructor, 0);
			}
			return childRewriter.Finish(childRewriter.Rewrite ? new NewExpression(newExpression.Constructor, childRewriter[0, -1], newExpression.Members) : expr);
		}

		private Result RewriteTypeBinaryExpression(Expression expr, Stack stack)
		{
			TypeBinaryExpression typeBinaryExpression = (TypeBinaryExpression)expr;
			Result result = RewriteExpression(typeBinaryExpression.Expression, stack);
			if (result.Action != RewriteAction.None)
			{
				expr = new TypeBinaryExpression(result.Node, typeBinaryExpression.TypeOperand, typeBinaryExpression.NodeType);
			}
			return new Result(result.Action, expr);
		}

		private Result RewriteThrowUnaryExpression(Expression expr, Stack stack)
		{
			UnaryExpression unaryExpression = (UnaryExpression)expr;
			Result result = RewriteExpressionFreeTemps(unaryExpression.Operand, Stack.Empty);
			RewriteAction rewriteAction = result.Action;
			if (stack != Stack.Empty)
			{
				rewriteAction = RewriteAction.SpillStack;
			}
			if (rewriteAction != RewriteAction.None)
			{
				expr = new UnaryExpression(ExpressionType.Throw, result.Node, unaryExpression.Type, null);
			}
			return new Result(rewriteAction, expr);
		}

		private Result RewriteUnaryExpression(Expression expr, Stack stack)
		{
			UnaryExpression unaryExpression = (UnaryExpression)expr;
			Result result = RewriteExpression(unaryExpression.Operand, stack);
			if (result.Action == RewriteAction.SpillStack)
			{
				RequireNoRefArgs(unaryExpression.Method);
			}
			if (result.Action != RewriteAction.None)
			{
				expr = new UnaryExpression(unaryExpression.NodeType, result.Node, unaryExpression.Type, unaryExpression.Method);
			}
			return new Result(result.Action, expr);
		}

		private Result RewriteListInitExpression(Expression expr, Stack stack)
		{
			ListInitExpression listInitExpression = (ListInitExpression)expr;
			Result result = RewriteExpression(listInitExpression.NewExpression, stack);
			Expression node = result.Node;
			RewriteAction rewriteAction = result.Action;
			ReadOnlyCollection<ElementInit> initializers = listInitExpression.Initializers;
			int count = initializers.Count;
			ChildRewriter[] array = new ChildRewriter[count];
			for (int i = 0; i < count; i++)
			{
				ElementInit elementInit = initializers[i];
				ChildRewriter childRewriter = new ChildRewriter(this, Stack.NonEmpty, elementInit.Arguments.Count);
				childRewriter.Add(elementInit.Arguments);
				rewriteAction |= childRewriter.Action;
				array[i] = childRewriter;
			}
			switch (rewriteAction)
			{
			case RewriteAction.Copy:
			{
				ElementInit[] array2 = new ElementInit[count];
				for (int k = 0; k < count; k++)
				{
					ChildRewriter childRewriter3 = array[k];
					if (childRewriter3.Action == RewriteAction.None)
					{
						array2[k] = initializers[k];
					}
					else
					{
						array2[k] = new ElementInit(initializers[k].AddMethod, new TrueReadOnlyCollection<Expression>(childRewriter3[0, -1]));
					}
				}
				expr = new ListInitExpression((NewExpression)node, new TrueReadOnlyCollection<ElementInit>(array2));
				break;
			}
			case RewriteAction.SpillStack:
			{
				bool flag = IsRefInstance(listInitExpression.NewExpression);
				ArrayBuilder<Expression> expressions = new ArrayBuilder<Expression>(count + 2 + (flag ? 1 : 0));
				ParameterExpression parameterExpression = MakeTemp(node.Type);
				expressions.UncheckedAdd(new AssignBinaryExpression(parameterExpression, node));
				ParameterExpression parameterExpression2 = parameterExpression;
				if (flag)
				{
					parameterExpression2 = MakeTemp(parameterExpression.Type.MakeByRefType());
					expressions.UncheckedAdd(new ByRefAssignBinaryExpression(parameterExpression2, parameterExpression));
				}
				for (int j = 0; j < count; j++)
				{
					ChildRewriter childRewriter2 = array[j];
					expressions.UncheckedAdd(childRewriter2.Finish(new InstanceMethodCallExpressionN(initializers[j].AddMethod, parameterExpression2, childRewriter2[0, -1])).Node);
				}
				expressions.UncheckedAdd(parameterExpression);
				expr = MakeBlock(expressions);
				break;
			}
			default:
				throw ContractUtils.Unreachable;
			case RewriteAction.None:
				break;
			}
			return new Result(rewriteAction, expr);
		}

		private Result RewriteMemberInitExpression(Expression expr, Stack stack)
		{
			MemberInitExpression memberInitExpression = (MemberInitExpression)expr;
			Result result = RewriteExpression(memberInitExpression.NewExpression, stack);
			Expression node = result.Node;
			RewriteAction rewriteAction = result.Action;
			ReadOnlyCollection<MemberBinding> bindings = memberInitExpression.Bindings;
			int count = bindings.Count;
			BindingRewriter[] array = new BindingRewriter[count];
			for (int i = 0; i < count; i++)
			{
				rewriteAction |= (array[i] = BindingRewriter.Create(bindings[i], this, Stack.NonEmpty)).Action;
			}
			switch (rewriteAction)
			{
			case RewriteAction.Copy:
			{
				MemberBinding[] array2 = new MemberBinding[count];
				for (int k = 0; k < count; k++)
				{
					array2[k] = array[k].AsBinding();
				}
				expr = new MemberInitExpression((NewExpression)node, new TrueReadOnlyCollection<MemberBinding>(array2));
				break;
			}
			case RewriteAction.SpillStack:
			{
				bool flag = IsRefInstance(memberInitExpression.NewExpression);
				ArrayBuilder<Expression> expressions = new ArrayBuilder<Expression>(count + 2 + (flag ? 1 : 0));
				ParameterExpression parameterExpression = MakeTemp(node.Type);
				expressions.UncheckedAdd(new AssignBinaryExpression(parameterExpression, node));
				ParameterExpression parameterExpression2 = parameterExpression;
				if (flag)
				{
					parameterExpression2 = MakeTemp(parameterExpression.Type.MakeByRefType());
					expressions.UncheckedAdd(new ByRefAssignBinaryExpression(parameterExpression2, parameterExpression));
				}
				for (int j = 0; j < count; j++)
				{
					Expression item = array[j].AsExpression(parameterExpression2);
					expressions.UncheckedAdd(item);
				}
				expressions.UncheckedAdd(parameterExpression);
				expr = MakeBlock(expressions);
				break;
			}
			default:
				throw ContractUtils.Unreachable;
			case RewriteAction.None:
				break;
			}
			return new Result(rewriteAction, expr);
		}

		private Result RewriteBlockExpression(Expression expr, Stack stack)
		{
			BlockExpression blockExpression = (BlockExpression)expr;
			int expressionCount = blockExpression.ExpressionCount;
			RewriteAction rewriteAction = RewriteAction.None;
			Expression[] array = null;
			for (int i = 0; i < expressionCount; i++)
			{
				Expression expression = blockExpression.GetExpression(i);
				Result result = RewriteExpression(expression, stack);
				rewriteAction |= result.Action;
				if (array == null && result.Action != RewriteAction.None)
				{
					array = Clone(blockExpression.Expressions, i);
				}
				if (array != null)
				{
					array[i] = result.Node;
				}
			}
			if (rewriteAction != RewriteAction.None)
			{
				expr = blockExpression.Rewrite(null, array);
			}
			return new Result(rewriteAction, expr);
		}

		private Result RewriteLabelExpression(Expression expr, Stack stack)
		{
			LabelExpression labelExpression = (LabelExpression)expr;
			Result result = RewriteExpression(labelExpression.DefaultValue, stack);
			if (result.Action != RewriteAction.None)
			{
				expr = new LabelExpression(labelExpression.Target, result.Node);
			}
			return new Result(result.Action, expr);
		}

		private Result RewriteLoopExpression(Expression expr, Stack stack)
		{
			LoopExpression loopExpression = (LoopExpression)expr;
			Result result = RewriteExpression(loopExpression.Body, Stack.Empty);
			RewriteAction rewriteAction = result.Action;
			if (stack != Stack.Empty)
			{
				rewriteAction = RewriteAction.SpillStack;
			}
			if (rewriteAction != RewriteAction.None)
			{
				expr = new LoopExpression(result.Node, loopExpression.BreakLabel, loopExpression.ContinueLabel);
			}
			return new Result(rewriteAction, expr);
		}

		private Result RewriteGotoExpression(Expression expr, Stack stack)
		{
			GotoExpression gotoExpression = (GotoExpression)expr;
			Result result = RewriteExpressionFreeTemps(gotoExpression.Value, Stack.Empty);
			RewriteAction rewriteAction = result.Action;
			if (stack != Stack.Empty)
			{
				rewriteAction = RewriteAction.SpillStack;
			}
			if (rewriteAction != RewriteAction.None)
			{
				expr = Expression.MakeGoto(gotoExpression.Kind, gotoExpression.Target, result.Node, gotoExpression.Type);
			}
			return new Result(rewriteAction, expr);
		}

		private Result RewriteSwitchExpression(Expression expr, Stack stack)
		{
			SwitchExpression switchExpression = (SwitchExpression)expr;
			Result result = RewriteExpressionFreeTemps(switchExpression.SwitchValue, stack);
			RewriteAction rewriteAction = result.Action;
			ReadOnlyCollection<SwitchCase> readOnlyCollection = switchExpression.Cases;
			SwitchCase[] array = null;
			for (int i = 0; i < readOnlyCollection.Count; i++)
			{
				SwitchCase switchCase = readOnlyCollection[i];
				Expression[] array2 = null;
				ReadOnlyCollection<Expression> readOnlyCollection2 = switchCase.TestValues;
				for (int j = 0; j < readOnlyCollection2.Count; j++)
				{
					Result result2 = RewriteExpression(readOnlyCollection2[j], stack);
					rewriteAction |= result2.Action;
					if (array2 == null && result2.Action != RewriteAction.None)
					{
						array2 = Clone(readOnlyCollection2, j);
					}
					if (array2 != null)
					{
						array2[j] = result2.Node;
					}
				}
				Result result3 = RewriteExpression(switchCase.Body, stack);
				rewriteAction |= result3.Action;
				if (result3.Action != RewriteAction.None || array2 != null)
				{
					if (array2 != null)
					{
						readOnlyCollection2 = new ReadOnlyCollection<Expression>(array2);
					}
					switchCase = new SwitchCase(result3.Node, readOnlyCollection2);
					if (array == null)
					{
						array = Clone(readOnlyCollection, i);
					}
				}
				if (array != null)
				{
					array[i] = switchCase;
				}
			}
			Result result4 = RewriteExpression(switchExpression.DefaultBody, stack);
			rewriteAction |= result4.Action;
			if (rewriteAction != RewriteAction.None)
			{
				if (array != null)
				{
					readOnlyCollection = new ReadOnlyCollection<SwitchCase>(array);
				}
				expr = new SwitchExpression(switchExpression.Type, result.Node, result4.Node, switchExpression.Comparison, readOnlyCollection);
			}
			return new Result(rewriteAction, expr);
		}

		private Result RewriteTryExpression(Expression expr, Stack stack)
		{
			TryExpression tryExpression = (TryExpression)expr;
			Result result = RewriteExpression(tryExpression.Body, Stack.Empty);
			ReadOnlyCollection<CatchBlock> readOnlyCollection = tryExpression.Handlers;
			CatchBlock[] array = null;
			RewriteAction rewriteAction = result.Action;
			if (readOnlyCollection != null)
			{
				for (int i = 0; i < readOnlyCollection.Count; i++)
				{
					RewriteAction rewriteAction2 = result.Action;
					CatchBlock catchBlock = readOnlyCollection[i];
					Expression filter = catchBlock.Filter;
					if (catchBlock.Filter != null)
					{
						Result result2 = RewriteExpression(catchBlock.Filter, Stack.Empty);
						rewriteAction |= result2.Action;
						rewriteAction2 |= result2.Action;
						filter = result2.Node;
					}
					Result result3 = RewriteExpression(catchBlock.Body, Stack.Empty);
					rewriteAction |= result3.Action;
					if ((rewriteAction2 | result3.Action) != RewriteAction.None)
					{
						catchBlock = Expression.MakeCatchBlock(catchBlock.Test, catchBlock.Variable, result3.Node, filter);
						if (array == null)
						{
							array = Clone(readOnlyCollection, i);
						}
					}
					if (array != null)
					{
						array[i] = catchBlock;
					}
				}
			}
			Result result4 = RewriteExpression(tryExpression.Fault, Stack.Empty);
			rewriteAction |= result4.Action;
			Result result5 = RewriteExpression(tryExpression.Finally, Stack.Empty);
			rewriteAction |= result5.Action;
			if (stack != Stack.Empty)
			{
				rewriteAction = RewriteAction.SpillStack;
			}
			if (rewriteAction != RewriteAction.None)
			{
				if (array != null)
				{
					readOnlyCollection = new ReadOnlyCollection<CatchBlock>(array);
				}
				expr = new TryExpression(tryExpression.Type, result.Node, result5.Node, result4.Node, readOnlyCollection);
			}
			return new Result(rewriteAction, expr);
		}

		private Result RewriteExtensionExpression(Expression expr, Stack stack)
		{
			Result result = RewriteExpression(expr.ReduceExtensions(), stack);
			return new Result(result.Action | RewriteAction.Copy, result.Node);
		}

		private static T[] Clone<T>(ReadOnlyCollection<T> original, int max)
		{
			T[] array = new T[original.Count];
			for (int i = 0; i < max; i++)
			{
				array[i] = original[i];
			}
			return array;
		}

		private static void RequireNoRefArgs(MethodBase method)
		{
			if (method != null && method.GetParametersCached().Any((ParameterInfo p) => p.ParameterType.IsByRef))
			{
				throw Error.TryNotSupportedForMethodsWithRefArgs(method);
			}
		}

		private static void RequireNotRefInstance(Expression instance)
		{
			if (IsRefInstance(instance))
			{
				throw Error.TryNotSupportedForValueTypeInstances(instance.Type);
			}
		}

		private static bool IsRefInstance(Expression instance)
		{
			if (instance != null && instance.Type.IsValueType)
			{
				return instance.Type.GetTypeCode() == TypeCode.Object;
			}
			return false;
		}
	}
	internal sealed class SpilledExpressionBlock : BlockN
	{
		internal SpilledExpressionBlock(IReadOnlyList<Expression> expressions)
			: base(expressions)
		{
		}

		[ExcludeFromCodeCoverage]
		internal override BlockExpression Rewrite(ReadOnlyCollection<ParameterExpression> variables, Expression[] args)
		{
			throw ContractUtils.Unreachable;
		}
	}
	internal static class TypeInfoExtensions
	{
		public static Type MakeDelegateType(this DelegateHelpers.TypeInfo info, Type retType, params Expression[] args)
		{
			return info.MakeDelegateType(retType, (IList<Expression>)args);
		}

		public static Type MakeDelegateType(this DelegateHelpers.TypeInfo info, Type retType, IList<Expression> args)
		{
			Type[] array = new Type[args.Count + 2];
			array[0] = typeof(CallSite);
			array[^1] = retType;
			for (int i = 0; i < args.Count; i++)
			{
				array[i + 1] = args[i].Type;
			}
			return info.DelegateType = DelegateHelpers.MakeNewDelegate(array);
		}
	}
	internal sealed class VariableBinder : ExpressionVisitor
	{
		private readonly AnalyzedTree _tree = new AnalyzedTree();

		private readonly Stack<CompilerScope> _scopes = new Stack<CompilerScope>();

		private readonly Stack<BoundConstants> _constants = new Stack<BoundConstants>();

		private readonly StackGuard _guard = new StackGuard();

		private bool _inQuote;

		private string CurrentLambdaName
		{
			get
			{
				foreach (CompilerScope scope in _scopes)
				{
					if (scope.Node is LambdaExpression lambdaExpression)
					{
						return lambdaExpression.Name;
					}
				}
				throw ContractUtils.Unreachable;
			}
		}

		internal static AnalyzedTree Bind(LambdaExpression lambda)
		{
			VariableBinder variableBinder = new VariableBinder();
			variableBinder.Visit(lambda);
			return variableBinder._tree;
		}

		private VariableBinder()
		{
		}

		public override Expression Visit(Expression node)
		{
			if (!_guard.TryEnterOnCurrentStack())
			{
				return _guard.RunOnEmptyStack((VariableBinder @this, Expression e) => @this.Visit(e), this, node);
			}
			return base.Visit(node);
		}

		protected internal override Expression VisitConstant(ConstantExpression node)
		{
			if (_inQuote)
			{
				return node;
			}
			if (ILGen.CanEmitConstant(node.Value, node.Type))
			{
				return node;
			}
			_constants.Peek().AddReference(node.Value, node.Type);
			return node;
		}

		protected internal override Expression VisitUnary(UnaryExpression node)
		{
			if (node.NodeType == ExpressionType.Quote)
			{
				bool inQuote = _inQuote;
				_inQuote = true;
				Visit(node.Operand);
				_inQuote = inQuote;
			}
			else
			{
				Visit(node.Operand);
			}
			return node;
		}

		protected internal override Expression VisitLambda<T>(Expression<T> node)
		{
			Stack<CompilerScope> scopes = _scopes;
			CompilerScope item = (_tree.Scopes[node] = new CompilerScope(node, isMethod: true));
			scopes.Push(item);
			Stack<BoundConstants> constants = _constants;
			BoundConstants item2 = (_tree.Constants[node] = new BoundConstants());
			constants.Push(item2);
			Visit(MergeScopes(node));
			_constants.Pop();
			_scopes.Pop();
			return node;
		}

		protected internal override Expression VisitInvocation(InvocationExpression node)
		{
			LambdaExpression lambdaOperand = node.LambdaOperand;
			if (lambdaOperand != null)
			{
				Stack<CompilerScope> scopes = _scopes;
				CompilerScope item = (_tree.Scopes[node] = new CompilerScope(lambdaOperand, isMethod: false));
				scopes.Push(item);
				Visit(MergeScopes(lambdaOperand));
				_scopes.Pop();
				int i = 0;
				for (int argumentCount = node.ArgumentCount; i < argumentCount; i++)
				{
					Visit(node.GetArgument(i));
				}
				return node;
			}
			return base.VisitInvocation(node);
		}

		protected internal override Expression VisitBlock(BlockExpression node)
		{
			if (node.Variables.Count == 0)
			{
				Visit(node.Expressions);
				return node;
			}
			Stack<CompilerScope> scopes = _scopes;
			CompilerScope item = (_tree.Scopes[node] = new CompilerScope(node, isMethod: false));
			scopes.Push(item);
			Visit(MergeScopes(node));
			_scopes.Pop();
			return node;
		}

		protected override CatchBlock VisitCatchBlock(CatchBlock node)
		{
			if (node.Variable == null)
			{
				Visit(node.Filter);
				Visit(node.Body);
				return node;
			}
			Stack<CompilerScope> scopes = _scopes;
			CompilerScope item = (_tree.Scopes[node] = new CompilerScope(node, isMethod: false));
			scopes.Push(item);
			Visit(node.Filter);
			Visit(node.Body);
			_scopes.Pop();
			return node;
		}

		private ReadOnlyCollection<Expression> MergeScopes(Expression node)
		{
			ReadOnlyCollection<Expression> readOnlyCollection = ((!(node is LambdaExpression lambdaExpression)) ? ((BlockExpression)node).Expressions : new ReadOnlyCollection<Expression>(new Expression[1] { lambdaExpression.Body }));
			CompilerScope compilerScope = _scopes.Peek();
			while (readOnlyCollection.Count == 1 && readOnlyCollection[0].NodeType == ExpressionType.Block)
			{
				BlockExpression blockExpression = (BlockExpression)readOnlyCollection[0];
				if (blockExpression.Variables.Count > 0)
				{
					foreach (ParameterExpression variable in blockExpression.Variables)
					{
						if (compilerScope.Definitions.ContainsKey(variable))
						{
							return readOnlyCollection;
						}
					}
					if (compilerScope.MergedScopes == null)
					{
						compilerScope.MergedScopes = new HashSet<BlockExpression>(ReferenceEqualityComparer<object>.Instance);
					}
					compilerScope.MergedScopes.Add(blockExpression);
					foreach (ParameterExpression variable2 in blockExpression.Variables)
					{
						compilerScope.Definitions.Add(variable2, VariableStorageKind.Local);
					}
				}
				readOnlyCollection = blockExpression.Expressions;
			}
			return readOnlyCollection;
		}

		protected internal override Expression VisitParameter(ParameterExpression node)
		{
			Reference(node, VariableStorageKind.Local);
			CompilerScope compilerScope = null;
			foreach (CompilerScope scope in _scopes)
			{
				if (scope.IsMethod || scope.Definitions.ContainsKey(node))
				{
					compilerScope = scope;
					break;
				}
			}
			if (compilerScope.ReferenceCount == null)
			{
				compilerScope.ReferenceCount = new Dictionary<ParameterExpression, int>();
			}
			Helpers.IncrementCount(node, compilerScope.ReferenceCount);
			return node;
		}

		protected internal override Expression VisitRuntimeVariables(RuntimeVariablesExpression node)
		{
			foreach (ParameterExpression variable in node.Variables)
			{
				Reference(variable, VariableStorageKind.Hoisted);
			}
			return node;
		}

		private void Reference(ParameterExpression node, VariableStorageKind storage)
		{
			CompilerScope compilerScope = null;
			foreach (CompilerScope scope in _scopes)
			{
				if (scope.Definitions.ContainsKey(node))
				{
					compilerScope = scope;
					break;
				}
				scope.NeedsClosure = true;
				if (scope.IsMethod)
				{
					storage = VariableStorageKind.Hoisted;
				}
			}
			if (compilerScope == null)
			{
				throw Error.UndefinedVariable(node.Name, node.Type, CurrentLambdaName);
			}
			if (storage == VariableStorageKind.Hoisted)
			{
				if (node.IsByRef)
				{
					throw Error.CannotCloseOverByRef(node.Name, CurrentLambdaName);
				}
				compilerScope.Definitions[node] = VariableStorageKind.Hoisted;
			}
		}
	}
}
namespace System.Runtime.InteropServices
{
	/// <summary>Permits late-bound registration of an event handler.</summary>
	public class ComAwareEventInfo : EventInfo
	{
		/// <summary>Gets the attributes for this event.</summary>
		/// <returns>The read-only attributes for this event.</returns>
		[MonoTODO]
		public override EventAttributes Attributes
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets the class that declares this member.</summary>
		/// <returns>The <see cref="T:System.Type" /> object for the class that declares this member.</returns>
		[MonoTODO]
		public override Type DeclaringType
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets the name of the current member.</summary>
		/// <returns>The name of this member.</returns>
		[MonoTODO]
		public override string Name
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Gets the class object that was used to initialize this instance.</summary>
		/// <returns>The <see cref="T:System.Type" /> object that was used to initialize the current object.</returns>
		[MonoTODO]
		public override Type ReflectedType
		{
			get
			{
				throw new NotImplementedException();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.ComAwareEventInfo" /> class by using the specified type and a name of the event on the type.</summary>
		/// <param name="type">The type of object.</param>
		/// <param name="eventName">The name of an event on <paramref name="type" />.</param>
		[MonoTODO]
		public ComAwareEventInfo(Type type, string eventName)
		{
			throw new NotImplementedException();
		}

		/// <summary>Attaches an event handler to a COM object.</summary>
		/// <param name="target">The target object that the event delegate should bind to.</param>
		/// <param name="handler">The event delegate.</param>
		[MonoTODO]
		public override void AddEventHandler(object target, Delegate handler)
		{
			throw new NotImplementedException();
		}

		/// <summary>Detaches an event handler from a COM object.</summary>
		/// <param name="target">The target object that the event delegate is bound to.</param>
		/// <param name="handler">The event delegate.</param>
		/// <exception cref="T:System.InvalidOperationException">The event does not have a public <see langword="remove" /> accessor.</exception>
		/// <exception cref="T:System.ArgumentException">The handler that was passed in cannot be used.</exception>
		/// <exception cref="T:System.Reflection.TargetException">
		///           In the .NET for Windows Store apps or the Portable Class Library, catch <see cref="T:System.Exception" /> instead.The <paramref name="target" /> parameter is <see langword="null" /> and the event is not static.-or- The <see cref="T:System.Reflection.EventInfo" /> is not declared on the target.</exception>
		/// <exception cref="T:System.MethodAccessException">
		///           In the .NET for Windows Store apps or the Portable Class Library, catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.The caller does not have access permission to the member.</exception>
		[MonoTODO]
		public override void RemoveEventHandler(object target, Delegate handler)
		{
			throw new NotImplementedException();
		}

		/// <summary>Gets the method that was used to add an event handler delegate to the event source.</summary>
		/// <param name="nonPublic">
		///       <see langword="true" /> to return non-public methods; otherwise, <see langword="false" />.</param>
		/// <returns>The method that was used to add an event handler delegate to the event source.</returns>
		/// <exception cref="T:System.MethodAccessException">
		///         <paramref name="nonPublic" /> is <see langword="true" /> and the method used to add an event handler delegate is non-public, but the caller does not have permission to reflect on non-public methods.</exception>
		[MonoTODO]
		public override MethodInfo GetAddMethod(bool nonPublic)
		{
			throw new NotImplementedException();
		}

		/// <summary>When overridden in a derived class, returns the method that was called when the event was raised.</summary>
		/// <param name="nonPublic">
		///       <see langword="true" /> to return non-public methods; otherwise, <see langword="false" />. </param>
		/// <returns>The object that was called when the event was raised.</returns>
		/// <exception cref="T:System.MethodAccessException">
		///         <paramref name="nonPublic" /> is <see langword="true" /> and the method used to add an event handler delegate is non-public, but the caller does not have permission to reflect on non-public methods. </exception>
		[MonoTODO]
		public override MethodInfo GetRaiseMethod(bool nonPublic)
		{
			throw new NotImplementedException();
		}

		/// <summary>When overridden in a derived class, retrieves the <see cref="T:System.Reflection.MethodInfo" /> object for removing a method of the event.</summary>
		/// <param name="nonPublic">
		///       <see langword="true" /> to return non-public methods; otherwise, <see langword="false" />. </param>
		/// <returns>The method that was used to remove an event handler delegate from the event source.</returns>
		/// <exception cref="T:System.MethodAccessException">
		///         <paramref name="nonPublic" /> is <see langword="true" /> and the method used to add an event handler delegate is non-public, but the caller does not have permission to reflect on non-public methods. </exception>
		[MonoTODO]
		public override MethodInfo GetRemoveMethod(bool nonPublic)
		{
			throw new NotImplementedException();
		}

		/// <summary>When overridden in a derived class, gets an array that contains all the custom attributes of the specified type that are applied to this member.</summary>
		/// <param name="attributeType">The attribute type to search for. Only attributes that are assignable to this type can be returned.</param>
		/// <param name="inherit">
		///       <see langword="true" /> to search this member's inheritance chain to find the attributes; otherwise, <see langword="false" />.</param>
		/// <returns>An array that contains all the custom attributes of the specified type, or an array that has no elements if no attributes were defined.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="attributeType" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">This member belongs to a type that is loaded into the reflection-only context. See How to: Load Assemblies into the Reflection-Only Context</exception>
		/// <exception cref="T:System.TypeLoadException">A custom attribute type cannot be loaded.</exception>
		[MonoTODO]
		public override object[] GetCustomAttributes(Type attributeType, bool inherit)
		{
			throw new NotImplementedException();
		}

		/// <summary>When overridden in a derived class, gets an array that contains all the custom attributes that are applied to this member.</summary>
		/// <param name="inherit">
		///       <see langword="true" /> to search this member's inheritance chain to find the attributes; otherwise, <see langword="false" />.</param>
		/// <returns>An array that contains all the custom attributes, or an array that has no elements if no attributes were defined.</returns>
		/// <exception cref="T:System.InvalidOperationException">This member belongs to a type that is loaded into the reflection-only context. See How to: Load Assemblies into the Reflection-Only Context.</exception>
		/// <exception cref="T:System.TypeLoadException">A custom attribute type cannot be loaded.</exception>
		[MonoTODO]
		public override object[] GetCustomAttributes(bool inherit)
		{
			throw new NotImplementedException();
		}

		/// <summary>Indicates whether one or more instances of the specified attribute are applied to this member.</summary>
		/// <param name="attributeType">The attribute type to search for.</param>
		/// <param name="inherit">
		///       <see langword="true" /> to search this member's inheritance chain to find the attributes; otherwise, <see langword="false" />.</param>
		/// <returns>
		///     <see langword="true" /> if the specified attribute has been applied to this member; otherwise, <see langword="false" />.</returns>
		[MonoTODO]
		public override bool IsDefined(Type attributeType, bool inherit)
		{
			throw new NotImplementedException();
		}
	}
}
namespace System.Runtime.CompilerServices
{
	/// <summary>Contains helper methods called from dynamically generated methods.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	[DebuggerStepThrough]
	public static class RuntimeOps
	{
		private sealed class ExpressionQuoter : ExpressionVisitor
		{
			private readonly HoistedLocals _scope;

			private readonly object[] _locals;

			private readonly Stack<HashSet<ParameterExpression>> _shadowedVars = new Stack<HashSet<ParameterExpression>>();

			internal ExpressionQuoter(HoistedLocals scope, object[] locals)
			{
				_scope = scope;
				_locals = locals;
			}

			protected internal override Expression VisitLambda<T>(Expression<T> node)
			{
				if (node.ParameterCount > 0)
				{
					HashSet<ParameterExpression> hashSet = new HashSet<ParameterExpression>();
					int i = 0;
					for (int parameterCount = node.ParameterCount; i < parameterCount; i++)
					{
						hashSet.Add(node.GetParameter(i));
					}
					_shadowedVars.Push(hashSet);
				}
				Expression expression = Visit(node.Body);
				if (node.ParameterCount > 0)
				{
					_shadowedVars.Pop();
				}
				if (expression == node.Body)
				{
					return node;
				}
				return node.Rewrite(expression, null);
			}

			protected internal override Expression VisitBlock(BlockExpression node)
			{
				if (node.Variables.Count > 0)
				{
					_shadowedVars.Push(new HashSet<ParameterExpression>(node.Variables));
				}
				Expression[] array = ExpressionVisitorUtils.VisitBlockExpressions(this, node);
				if (node.Variables.Count > 0)
				{
					_shadowedVars.Pop();
				}
				if (array == null)
				{
					return node;
				}
				return node.Rewrite(node.Variables, array);
			}

			protected override CatchBlock VisitCatchBlock(CatchBlock node)
			{
				if (node.Variable != null)
				{
					_shadowedVars.Push(new HashSet<ParameterExpression> { node.Variable });
				}
				Expression expression = Visit(node.Body);
				Expression expression2 = Visit(node.Filter);
				if (node.Variable != null)
				{
					_shadowedVars.Pop();
				}
				if (expression == node.Body && expression2 == node.Filter)
				{
					return node;
				}
				return Expression.MakeCatchBlock(node.Test, node.Variable, expression, expression2);
			}

			protected internal override Expression VisitRuntimeVariables(RuntimeVariablesExpression node)
			{
				int count = node.Variables.Count;
				List<IStrongBox> list = new List<IStrongBox>();
				List<ParameterExpression> list2 = new List<ParameterExpression>();
				int[] array = new int[count];
				for (int i = 0; i < array.Length; i++)
				{
					IStrongBox box = GetBox(node.Variables[i]);
					if (box == null)
					{
						array[i] = list2.Count;
						list2.Add(node.Variables[i]);
					}
					else
					{
						array[i] = -1 - list.Count;
						list.Add(box);
					}
				}
				if (list.Count == 0)
				{
					return node;
				}
				ConstantExpression constantExpression = Expression.Constant(new RuntimeVariables(list.ToArray()), typeof(IRuntimeVariables));
				if (list2.Count == 0)
				{
					return constantExpression;
				}
				return Expression.Call(System.Linq.Expressions.CachedReflectionInfo.RuntimeOps_MergeRuntimeVariables, Expression.RuntimeVariables(new TrueReadOnlyCollection<ParameterExpression>(list2.ToArray())), constantExpression, Expression.Constant(array));
			}

			protected internal override Expression VisitParameter(ParameterExpression node)
			{
				IStrongBox box = GetBox(node);
				if (box == null)
				{
					return node;
				}
				return Expression.Field(Expression.Constant(box), "Value");
			}

			private IStrongBox GetBox(ParameterExpression variable)
			{
				foreach (HashSet<ParameterExpression> shadowedVar in _shadowedVars)
				{
					if (shadowedVar.Contains(variable))
					{
						return null;
					}
				}
				HoistedLocals hoistedLocals = _scope;
				object[] array = _locals;
				while (true)
				{
					if (hoistedLocals.Indexes.TryGetValue(variable, out var value))
					{
						return (IStrongBox)array[value];
					}
					hoistedLocals = hoistedLocals.Parent;
					if (hoistedLocals == null)
					{
						break;
					}
					array = HoistedLocals.GetParent(array);
				}
				throw ContractUtils.Unreachable;
			}
		}

		internal sealed class MergedRuntimeVariables : IRuntimeVariables
		{
			private readonly IRuntimeVariables _first;

			private readonly IRuntimeVariables _second;

			private readonly int[] _indexes;

			public int Count => _indexes.Length;

			public object this[int index]
			{
				get
				{
					index = _indexes[index];
					if (index < 0)
					{
						return _second[-1 - index];
					}
					return _first[index];
				}
				set
				{
					index = _indexes[index];
					if (index >= 0)
					{
						_first[index] = value;
					}
					else
					{
						_second[-1 - index] = value;
					}
				}
			}

			internal MergedRuntimeVariables(IRuntimeVariables first, IRuntimeVariables second, int[] indexes)
			{
				_first = first;
				_second = second;
				_indexes = indexes;
			}
		}

		private sealed class EmptyRuntimeVariables : IRuntimeVariables
		{
			int IRuntimeVariables.Count => 0;

			object IRuntimeVariables.this[int index]
			{
				get
				{
					throw new IndexOutOfRangeException();
				}
				set
				{
					throw new IndexOutOfRangeException();
				}
			}
		}

		private sealed class RuntimeVariableList : IRuntimeVariables
		{
			private readonly object[] _data;

			private readonly long[] _indexes;

			public int Count => _indexes.Length;

			public object this[int index]
			{
				get
				{
					return GetStrongBox(index).Value;
				}
				set
				{
					GetStrongBox(index).Value = value;
				}
			}

			internal RuntimeVariableList(object[] data, long[] indexes)
			{
				_data = data;
				_indexes = indexes;
			}

			private IStrongBox GetStrongBox(int index)
			{
				long num = _indexes[index];
				object[] array = _data;
				for (int num2 = (int)(num >> 32); num2 > 0; num2--)
				{
					array = HoistedLocals.GetParent(array);
				}
				return (IStrongBox)array[(int)num];
			}
		}

		internal sealed class RuntimeVariables : IRuntimeVariables
		{
			private readonly IStrongBox[] _boxes;

			int IRuntimeVariables.Count => _boxes.Length;

			object IRuntimeVariables.this[int index]
			{
				get
				{
					return _boxes[index].Value;
				}
				set
				{
					_boxes[index].Value = value;
				}
			}

			internal RuntimeVariables(IStrongBox[] boxes)
			{
				_boxes = boxes;
			}
		}

		/// <summary>Gets the value of an item in an expando object.</summary>
		/// <param name="expando">The expando object.</param>
		/// <param name="indexClass">The class of the expando object.</param>
		/// <param name="index">The index of the member.</param>
		/// <param name="name">The name of the member.</param>
		/// <param name="ignoreCase">true if the name should be matched ignoring case; false otherwise.</param>
		/// <param name="value">The out parameter containing the value of the member.</param>
		/// <returns>True if the member exists in the expando object, otherwise false.</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("do not use this method", true)]
		public static bool ExpandoTryGetValue(ExpandoObject expando, object indexClass, int index, string name, bool ignoreCase, out object value)
		{
			return expando.TryGetValue(indexClass, index, name, ignoreCase, out value);
		}

		/// <summary>Sets the value of an item in an expando object.</summary>
		/// <param name="expando">The expando object.</param>
		/// <param name="indexClass">The class of the expando object.</param>
		/// <param name="index">The index of the member.</param>
		/// <param name="value">The value of the member.</param>
		/// <param name="name">The name of the member.</param>
		/// <param name="ignoreCase">true if the name should be matched ignoring case; false otherwise.</param>
		/// <returns>Returns the index for the set member.</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("do not use this method", true)]
		public static object ExpandoTrySetValue(ExpandoObject expando, object indexClass, int index, object value, string name, bool ignoreCase)
		{
			expando.TrySetValue(indexClass, index, value, name, ignoreCase, add: false);
			return value;
		}

		/// <summary>Deletes the value of an item in an expando object.</summary>
		/// <param name="expando">The expando object.</param>
		/// <param name="indexClass">The class of the expando object.</param>
		/// <param name="index">The index of the member.</param>
		/// <param name="name">The name of the member.</param>
		/// <param name="ignoreCase">true if the name should be matched ignoring case; false otherwise.</param>
		/// <returns>true if the item was successfully removed; otherwise, false.</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("do not use this method", true)]
		public static bool ExpandoTryDeleteValue(ExpandoObject expando, object indexClass, int index, string name, bool ignoreCase)
		{
			return expando.TryDeleteValue(indexClass, index, name, ignoreCase, ExpandoObject.Uninitialized);
		}

		/// <summary>Checks the version of the Expando object.</summary>
		/// <param name="expando">The Expando object.</param>
		/// <param name="version">The version to check.</param>
		/// <returns>Returns true if the version is equal; otherwise, false.</returns>
		[Obsolete("do not use this method", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static bool ExpandoCheckVersion(ExpandoObject expando, object version)
		{
			return expando.Class == version;
		}

		/// <summary>Promotes an Expando object from one class to a new class.</summary>
		/// <param name="expando">The Expando object.</param>
		/// <param name="oldClass">The old class of the Expando object.</param>
		/// <param name="newClass">The new class of the Expando object.</param>
		[Obsolete("do not use this method", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static void ExpandoPromoteClass(ExpandoObject expando, object oldClass, object newClass)
		{
			expando.PromoteClass(oldClass, newClass);
		}

		/// <summary>Quotes the provided expression tree.</summary>
		/// <param name="expression">The expression to quote.</param>
		/// <param name="hoistedLocals">The hoisted local state provided by the compiler.</param>
		/// <param name="locals">The actual hoisted local values.</param>
		/// <returns>The quoted expression.</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("do not use this method", true)]
		public static Expression Quote(Expression expression, object hoistedLocals, object[] locals)
		{
			return new ExpressionQuoter((HoistedLocals)hoistedLocals, locals).Visit(expression);
		}

		/// <summary>Combines two runtime variable lists and returns a new list.</summary>
		/// <param name="first">The first list.</param>
		/// <param name="second">The second list.</param>
		/// <param name="indexes">The index array indicating which list to get variables from.</param>
		/// <returns>The merged runtime variables.</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("do not use this method", true)]
		public static IRuntimeVariables MergeRuntimeVariables(IRuntimeVariables first, IRuntimeVariables second, int[] indexes)
		{
			return new MergedRuntimeVariables(first, second, indexes);
		}

		/// <summary>Creates an interface that can be used to modify closed over variables at runtime.</summary>
		/// <param name="data">The closure array.</param>
		/// <param name="indexes">An array of indicies into the closure array where variables are found.</param>
		/// <returns>An interface to access variables.</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("do not use this method", true)]
		public static IRuntimeVariables CreateRuntimeVariables(object[] data, long[] indexes)
		{
			return new RuntimeVariableList(data, indexes);
		}

		/// <summary>Creates an interface that can be used to modify closed over variables at runtime.</summary>
		/// <returns>An interface to access variables.</returns>
		[Obsolete("do not use this method", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static IRuntimeVariables CreateRuntimeVariables()
		{
			return new EmptyRuntimeVariables();
		}
	}
	/// <summary>A dynamic call site base class. This type is used as a parameter type to the dynamic site targets.</summary>
	public class CallSite
	{
		internal const string CallSiteTargetMethodName = "CallSite.Target";

		private static volatile CacheDict<Type, Func<CallSiteBinder, CallSite>> s_siteCtors;

		internal readonly CallSiteBinder _binder;

		internal bool _match;

		/// <summary>Class responsible for binding dynamic operations on the dynamic site.</summary>
		/// <returns>The <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> object responsible for binding dynamic operations.</returns>
		public CallSiteBinder Binder => _binder;

		internal CallSite(CallSiteBinder binder)
		{
			_binder = binder;
		}

		/// <summary>Creates a call site with the given delegate type and binder.</summary>
		/// <param name="delegateType">The call site delegate type.</param>
		/// <param name="binder">The call site binder.</param>
		/// <returns>The new call site.</returns>
		public static CallSite Create(Type delegateType, CallSiteBinder binder)
		{
			ContractUtils.RequiresNotNull(delegateType, "delegateType");
			ContractUtils.RequiresNotNull(binder, "binder");
			if (!delegateType.IsSubclassOf(typeof(MulticastDelegate)))
			{
				throw System.Linq.Expressions.Error.TypeMustBeDerivedFromSystemDelegate();
			}
			CacheDict<Type, Func<CallSiteBinder, CallSite>> cacheDict = s_siteCtors;
			if (cacheDict == null)
			{
				cacheDict = (s_siteCtors = new CacheDict<Type, Func<CallSiteBinder, CallSite>>(100));
			}
			if (!cacheDict.TryGetValue(delegateType, out var value))
			{
				MethodInfo method = typeof(CallSite<>).MakeGenericType(delegateType).GetMethod("Create");
				if (delegateType.IsCollectible)
				{
					return (CallSite)method.Invoke(null, new object[1] { binder });
				}
				value = (Func<CallSiteBinder, CallSite>)method.CreateDelegate(typeof(Func<CallSiteBinder, CallSite>));
				cacheDict.Add(delegateType, value);
			}
			return value(binder);
		}

		internal CallSite()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Dynamic site type.</summary>
	/// <typeparam name="T">The delegate type.</typeparam>
	public class CallSite<T> : CallSite where T : class
	{
		/// <summary>The Level 0 cache - a delegate specialized based on the site history.</summary>
		public T Target;

		internal T[] Rules;

		internal CallSite _cachedMatchmaker;

		private static T s_cachedUpdate;

		private static volatile T s_cachedNoMatch;

		private const int MaxRules = 10;

		/// <summary>The update delegate. Called when the dynamic site experiences cache miss.</summary>
		/// <returns>The update delegate.</returns>
		public T Update
		{
			get
			{
				if (_match)
				{
					return s_cachedNoMatch;
				}
				return s_cachedUpdate;
			}
		}

		private CallSite(CallSiteBinder binder)
			: base(binder)
		{
			Target = GetUpdateDelegate();
		}

		private CallSite()
			: base(null)
		{
		}

		internal CallSite<T> CreateMatchMaker()
		{
			return new CallSite<T>();
		}

		internal CallSite GetMatchmaker()
		{
			CallSite callSite = _cachedMatchmaker;
			if (callSite != null)
			{
				callSite = Interlocked.Exchange(ref _cachedMatchmaker, null);
			}
			return callSite ?? new CallSite<T>
			{
				_match = true
			};
		}

		internal void ReleaseMatchmaker(CallSite matchMaker)
		{
			if (Rules != null)
			{
				_cachedMatchmaker = matchMaker;
			}
		}

		/// <summary>Creates an instance of the dynamic call site, initialized with the binder responsible for the runtime binding of the dynamic operations at this call site.</summary>
		/// <param name="binder">The binder responsible for the runtime binding of the dynamic operations at this call site.</param>
		/// <returns>The new instance of dynamic call site.</returns>
		public static CallSite<T> Create(CallSiteBinder binder)
		{
			if (!typeof(T).IsSubclassOf(typeof(MulticastDelegate)))
			{
				throw System.Linq.Expressions.Error.TypeMustBeDerivedFromSystemDelegate();
			}
			ContractUtils.RequiresNotNull(binder, "binder");
			return new CallSite<T>(binder);
		}

		private T GetUpdateDelegate()
		{
			return GetUpdateDelegate(ref s_cachedUpdate);
		}

		private T GetUpdateDelegate(ref T addr)
		{
			if (addr == null)
			{
				addr = MakeUpdateDelegate();
			}
			return addr;
		}

		private void ClearRuleCache()
		{
			base.Binder.GetRuleCache<T>();
			Dictionary<Type, object> cache = base.Binder.Cache;
			if (cache != null)
			{
				lock (cache)
				{
					cache.Clear();
				}
			}
		}

		internal void AddRule(T newRule)
		{
			T[] rules = Rules;
			if (rules == null)
			{
				Rules = new T[1] { newRule };
				return;
			}
			T[] array;
			if (rules.Length < 9)
			{
				array = new T[rules.Length + 1];
				Array.Copy(rules, 0, array, 1, rules.Length);
			}
			else
			{
				array = new T[10];
				Array.Copy(rules, 0, array, 1, 9);
			}
			array[0] = newRule;
			Rules = array;
		}

		internal void MoveRule(int i)
		{
			if (i > 1)
			{
				T[] rules = Rules;
				T val = rules[i];
				rules[i] = rules[i - 1];
				rules[i - 1] = rules[i - 2];
				rules[i - 2] = val;
			}
		}

		internal T MakeUpdateDelegate()
		{
			Type typeFromHandle = typeof(T);
			MethodInfo invokeMethod = typeFromHandle.GetInvokeMethod();
			if (typeFromHandle.IsGenericType && IsSimpleSignature(invokeMethod, out var sig))
			{
				MethodInfo methodInfo = null;
				MethodInfo methodInfo2 = null;
				if (invokeMethod.ReturnType == typeof(void))
				{
					if (typeFromHandle == DelegateHelpers.GetActionType(sig.AddFirst(typeof(CallSite))))
					{
						methodInfo = typeof(UpdateDelegates).GetMethod("UpdateAndExecuteVoid" + sig.Length, BindingFlags.Static | BindingFlags.NonPublic);
						methodInfo2 = typeof(UpdateDelegates).GetMethod("NoMatchVoid" + sig.Length, BindingFlags.Static | BindingFlags.NonPublic);
					}
				}
				else if (typeFromHandle == DelegateHelpers.GetFuncType(sig.AddFirst(typeof(CallSite))))
				{
					methodInfo = typeof(UpdateDelegates).GetMethod("UpdateAndExecute" + (sig.Length - 1), BindingFlags.Static | BindingFlags.NonPublic);
					methodInfo2 = typeof(UpdateDelegates).GetMethod("NoMatch" + (sig.Length - 1), BindingFlags.Static | BindingFlags.NonPublic);
				}
				if (methodInfo != null)
				{
					s_cachedNoMatch = (T)(object)methodInfo2.MakeGenericMethod(sig).CreateDelegate(typeFromHandle);
					return (T)(object)methodInfo.MakeGenericMethod(sig).CreateDelegate(typeFromHandle);
				}
			}
			s_cachedNoMatch = CreateCustomNoMatchDelegate(invokeMethod);
			return CreateCustomUpdateDelegate(invokeMethod);
		}

		private static bool IsSimpleSignature(MethodInfo invoke, out Type[] sig)
		{
			ParameterInfo[] parametersCached = invoke.GetParametersCached();
			ContractUtils.Requires(parametersCached.Length != 0 && parametersCached[0].ParameterType == typeof(CallSite), "T");
			Type[] array = new Type[(invoke.ReturnType != typeof(void)) ? parametersCached.Length : (parametersCached.Length - 1)];
			bool result = true;
			for (int i = 1; i < parametersCached.Length; i++)
			{
				ParameterInfo parameterInfo = parametersCached[i];
				if (parameterInfo.IsByRefParameter())
				{
					result = false;
				}
				array[i - 1] = parameterInfo.ParameterType;
			}
			if (invoke.ReturnType != typeof(void))
			{
				array[^1] = invoke.ReturnType;
			}
			sig = array;
			return result;
		}

		private T CreateCustomUpdateDelegate(MethodInfo invoke)
		{
			Type returnType = invoke.GetReturnType();
			bool flag = returnType == typeof(void);
			ArrayBuilder<Expression> builder = new ArrayBuilder<Expression>(13);
			ArrayBuilder<ParameterExpression> builder2 = new ArrayBuilder<ParameterExpression>(8 + ((!flag) ? 1 : 0));
			ParameterExpression[] array = Array.ConvertAll(invoke.GetParametersCached(), (ParameterInfo p) => Expression.Parameter(p.ParameterType, p.Name));
			LabelTarget labelTarget = Expression.Label(returnType);
			Type[] typeArguments = new Type[1] { typeof(T) };
			ParameterExpression parameterExpression = array[0];
			ParameterExpression[] array2 = array.RemoveFirst();
			ParameterExpression parameterExpression2 = Expression.Variable(typeof(CallSite<T>), "this");
			builder2.UncheckedAdd(parameterExpression2);
			builder.UncheckedAdd(Expression.Assign(parameterExpression2, Expression.Convert(parameterExpression, parameterExpression2.Type)));
			ParameterExpression parameterExpression3 = Expression.Variable(typeof(T[]), "applicable");
			builder2.UncheckedAdd(parameterExpression3);
			ParameterExpression parameterExpression4 = Expression.Variable(typeof(T), "rule");
			builder2.UncheckedAdd(parameterExpression4);
			ParameterExpression parameterExpression5 = Expression.Variable(typeof(T), "originalRule");
			builder2.UncheckedAdd(parameterExpression5);
			Expression expression = Expression.Field(parameterExpression2, "Target");
			builder.UncheckedAdd(Expression.Assign(parameterExpression5, expression));
			ParameterExpression parameterExpression6 = null;
			if (!flag)
			{
				builder2.UncheckedAdd(parameterExpression6 = Expression.Variable(labelTarget.Type, "result"));
			}
			ParameterExpression parameterExpression7 = Expression.Variable(typeof(int), "count");
			builder2.UncheckedAdd(parameterExpression7);
			ParameterExpression parameterExpression8 = Expression.Variable(typeof(int), "index");
			builder2.UncheckedAdd(parameterExpression8);
			builder.UncheckedAdd(Expression.Assign(parameterExpression, Expression.Call(System.Linq.Expressions.CachedReflectionInfo.CallSiteOps_CreateMatchmaker.MakeGenericMethod(typeArguments), parameterExpression2)));
			Expression test = Expression.Call(System.Linq.Expressions.CachedReflectionInfo.CallSiteOps_GetMatch, parameterExpression);
			Expression expression2 = Expression.Call(System.Linq.Expressions.CachedReflectionInfo.CallSiteOps_ClearMatch, parameterExpression);
			Expression[] list = array;
			Expression expression3 = Expression.Invoke(parameterExpression4, new TrueReadOnlyCollection<Expression>(list));
			Expression arg = Expression.Call(System.Linq.Expressions.CachedReflectionInfo.CallSiteOps_UpdateRules.MakeGenericMethod(typeArguments), parameterExpression2, parameterExpression8);
			Expression arg2 = ((!flag) ? Expression.Block(Expression.Assign(parameterExpression6, expression3), Expression.IfThen(test, Expression.Block(arg, Expression.Return(labelTarget, parameterExpression6)))) : Expression.Block(expression3, Expression.IfThen(test, Expression.Block(arg, Expression.Return(labelTarget)))));
			Expression expression4 = Expression.Assign(parameterExpression4, Expression.ArrayAccess(parameterExpression3, new TrueReadOnlyCollection<Expression>(parameterExpression8)));
			Expression arg3 = expression4;
			LabelTarget labelTarget2 = Expression.Label();
			Expression arg4 = Expression.IfThen(Expression.Equal(parameterExpression8, parameterExpression7), Expression.Break(labelTarget2));
			Expression expression5 = Expression.PreIncrementAssign(parameterExpression8);
			builder.UncheckedAdd(Expression.IfThen(Expression.NotEqual(Expression.Assign(parameterExpression3, Expression.Call(System.Linq.Expressions.CachedReflectionInfo.CallSiteOps_GetRules.MakeGenericMethod(typeArguments), parameterExpression2)), Expression.Constant(null, parameterExpression3.Type)), Expression.Block(Expression.Assign(parameterExpression7, Expression.ArrayLength(parameterExpression3)), Expression.Assign(parameterExpression8, System.Linq.Expressions.Utils.Constant(0)), Expression.Loop(Expression.Block(arg4, arg3, Expression.IfThen(Expression.NotEqual(Expression.Convert(parameterExpression4, typeof(object)), Expression.Convert(parameterExpression5, typeof(object))), Expression.Block(Expression.Assign(expression, parameterExpression4), arg2, expression2)), expression5), labelTarget2, null))));
			ParameterExpression parameterExpression9 = Expression.Variable(typeof(RuleCache<T>), "cache");
			builder2.UncheckedAdd(parameterExpression9);
			builder.UncheckedAdd(Expression.Assign(parameterExpression9, Expression.Call(System.Linq.Expressions.CachedReflectionInfo.CallSiteOps_GetRuleCache.MakeGenericMethod(typeArguments), parameterExpression2)));
			builder.UncheckedAdd(Expression.Assign(parameterExpression3, Expression.Call(System.Linq.Expressions.CachedReflectionInfo.CallSiteOps_GetCachedRules.MakeGenericMethod(typeArguments), parameterExpression9)));
			arg2 = ((!flag) ? Expression.Block(Expression.Assign(parameterExpression6, expression3), Expression.IfThen(test, Expression.Return(labelTarget, parameterExpression6))) : Expression.Block(expression3, Expression.IfThen(test, Expression.Return(labelTarget))));
			Expression arg5 = Expression.TryFinally(arg2, Expression.IfThen(test, Expression.Block(Expression.Call(System.Linq.Expressions.CachedReflectionInfo.CallSiteOps_AddRule.MakeGenericMethod(typeArguments), parameterExpression2, parameterExpression4), Expression.Call(System.Linq.Expressions.CachedReflectionInfo.CallSiteOps_MoveRule.MakeGenericMethod(typeArguments), parameterExpression9, parameterExpression4, parameterExpression8))));
			arg3 = Expression.Assign(expression, expression4);
			builder.UncheckedAdd(Expression.Assign(parameterExpression8, System.Linq.Expressions.Utils.Constant(0)));
			builder.UncheckedAdd(Expression.Assign(parameterExpression7, Expression.ArrayLength(parameterExpression3)));
			builder.UncheckedAdd(Expression.Loop(Expression.Block(arg4, arg3, arg5, expression2, expression5), labelTarget2, null));
			builder.UncheckedAdd(Expression.Assign(parameterExpression4, Expression.Constant(null, parameterExpression4.Type)));
			ParameterExpression parameterExpression10 = Expression.Variable(typeof(object[]), "args");
			Expression[] list2 = Array.ConvertAll(array2, (ParameterExpression p) => Convert(p, typeof(object)));
			builder2.UncheckedAdd(parameterExpression10);
			builder.UncheckedAdd(Expression.Assign(parameterExpression10, Expression.NewArrayInit(typeof(object), new TrueReadOnlyCollection<Expression>(list2))));
			Expression arg6 = Expression.Assign(expression, parameterExpression5);
			arg3 = Expression.Assign(expression, Expression.Assign(parameterExpression4, Expression.Call(System.Linq.Expressions.CachedReflectionInfo.CallSiteOps_Bind.MakeGenericMethod(typeArguments), Expression.Property(parameterExpression2, "Binder"), parameterExpression2, parameterExpression10)));
			arg5 = Expression.TryFinally(arg2, Expression.IfThen(test, Expression.Call(System.Linq.Expressions.CachedReflectionInfo.CallSiteOps_AddRule.MakeGenericMethod(typeArguments), parameterExpression2, parameterExpression4)));
			builder.UncheckedAdd(Expression.Loop(Expression.Block(arg6, arg3, arg5, expression2), null, null));
			builder.UncheckedAdd(Expression.Default(labelTarget.Type));
			return Expression.Lambda<T>(Expression.Label(labelTarget, Expression.Block(builder2.ToReadOnly(), builder.ToReadOnly())), "CallSite.Target", tailCall: true, new TrueReadOnlyCollection<ParameterExpression>(array)).Compile();
		}

		private T CreateCustomNoMatchDelegate(MethodInfo invoke)
		{
			ParameterExpression[] array = Array.ConvertAll(invoke.GetParametersCached(), (ParameterInfo p) => Expression.Parameter(p.ParameterType, p.Name));
			return Expression.Lambda<T>(Expression.Block(Expression.Call(typeof(CallSiteOps).GetMethod("SetNotMatched"), array[0]), Expression.Default(invoke.GetReturnType())), new TrueReadOnlyCollection<ParameterExpression>(array)).Compile();
		}

		private static Expression Convert(Expression arg, Type type)
		{
			if (TypeUtils.AreReferenceAssignable(type, arg.Type))
			{
				return arg;
			}
			return Expression.Convert(arg, type);
		}
	}
	/// <summary>Class responsible for runtime binding of the dynamic operations on the dynamic call site.</summary>
	public abstract class CallSiteBinder
	{
		private sealed class LambdaSignature<T> where T : class
		{
			private static LambdaSignature<T> s_instance;

			internal readonly ReadOnlyCollection<ParameterExpression> Parameters;

			internal readonly LabelTarget ReturnLabel;

			internal static LambdaSignature<T> Instance
			{
				get
				{
					if (s_instance == null)
					{
						s_instance = new LambdaSignature<T>();
					}
					return s_instance;
				}
			}

			private LambdaSignature()
			{
				Type typeFromHandle = typeof(T);
				if (!typeFromHandle.IsSubclassOf(typeof(MulticastDelegate)))
				{
					throw System.Linq.Expressions.Error.TypeParameterIsNotDelegate(typeFromHandle);
				}
				MethodInfo invokeMethod = typeFromHandle.GetInvokeMethod();
				ParameterInfo[] parametersCached = invokeMethod.GetParametersCached();
				if (parametersCached[0].ParameterType != typeof(CallSite))
				{
					throw System.Linq.Expressions.Error.FirstArgumentMustBeCallSite();
				}
				ParameterExpression[] array = new ParameterExpression[parametersCached.Length - 1];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = Expression.Parameter(parametersCached[i + 1].ParameterType, "$arg" + i);
				}
				Parameters = new TrueReadOnlyCollection<ParameterExpression>(array);
				ReturnLabel = Expression.Label(invokeMethod.GetReturnType());
			}
		}

		internal Dictionary<Type, object> Cache;

		/// <summary>Gets a label that can be used to cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.LabelTarget" /> object representing a label that can be used to trigger the binding update.</returns>
		public static LabelTarget UpdateLabel { get; } = Expression.Label("CallSiteBinder.UpdateLabel");

		/// <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CallSiteBinder" /> class.</summary>
		protected CallSiteBinder()
		{
		}

		/// <summary>Performs the runtime binding of the dynamic operation on a set of arguments.</summary>
		/// <param name="args">An array of arguments to the dynamic operation.</param>
		/// <param name="parameters">The array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> instances that represent the parameters of the call site in the binding process.</param>
		/// <param name="returnLabel">A LabelTarget used to return the result of the dynamic binding.</param>
		/// <returns>An Expression that performs tests on the dynamic operation arguments, and performs the dynamic operation if the tests are valid. If the tests fail on subsequent occurrences of the dynamic operation, Bind will be called again to produce a new <see cref="T:System.Linq.Expressions.Expression" /> for the new argument types.</returns>
		public abstract Expression Bind(object[] args, ReadOnlyCollection<ParameterExpression> parameters, LabelTarget returnLabel);

		/// <summary>Provides low-level runtime binding support. Classes can override this and provide a direct delegate for the implementation of rule. This can enable saving rules to disk, having specialized rules available at runtime, or providing a different caching policy.</summary>
		/// <param name="site">The CallSite the bind is being performed for.</param>
		/// <param name="args">The arguments for the binder.</param>
		/// <typeparam name="T">The target type of the CallSite.</typeparam>
		/// <returns>A new delegate which replaces the CallSite Target.</returns>
		public virtual T BindDelegate<T>(CallSite<T> site, object[] args) where T : class
		{
			return null;
		}

		internal T BindCore<T>(CallSite<T> site, object[] args) where T : class
		{
			T val = BindDelegate(site, args);
			if (val != null)
			{
				return val;
			}
			LambdaSignature<T> instance = LambdaSignature<T>.Instance;
			T val2 = Stitch(Bind(args, instance.Parameters, instance.ReturnLabel) ?? throw System.Linq.Expressions.Error.NoOrInvalidRuleProduced(), instance).Compile();
			CacheTarget(val2);
			return val2;
		}

		/// <summary>Adds a target to the cache of known targets. The cached targets will be scanned before calling BindDelegate to produce the new rule.</summary>
		/// <param name="target">The target delegate to be added to the cache.</param>
		/// <typeparam name="T">The type of target being added.</typeparam>
		protected void CacheTarget<T>(T target) where T : class
		{
			GetRuleCache<T>().AddRule(target);
		}

		private static Expression<T> Stitch<T>(Expression binding, LambdaSignature<T> signature) where T : class
		{
			Type typeFromHandle = typeof(CallSite<T>);
			ReadOnlyCollectionBuilder<Expression> obj = new ReadOnlyCollectionBuilder<Expression>(3) { binding };
			ParameterExpression parameterExpression = Expression.Parameter(typeof(CallSite), "$site");
			TrueReadOnlyCollection<ParameterExpression> trueReadOnlyCollection = signature.Parameters.AddFirst(parameterExpression);
			Expression item = Expression.Label(UpdateLabel);
			obj.Add(item);
			obj.Add(Expression.Label(signature.ReturnLabel, Expression.Condition(Expression.Call(System.Linq.Expressions.CachedReflectionInfo.CallSiteOps_SetNotMatched, parameterExpression), Expression.Default(signature.ReturnLabel.Type), Expression.Invoke(Expression.Property(Expression.Convert(parameterExpression, typeFromHandle), typeof(CallSite<T>).GetProperty("Update")), trueReadOnlyCollection))));
			return Expression.Lambda<T>(Expression.Block(obj), "CallSite.Target", tailCall: true, trueReadOnlyCollection);
		}

		internal RuleCache<T> GetRuleCache<T>() where T : class
		{
			if (Cache == null)
			{
				Interlocked.CompareExchange(ref Cache, new Dictionary<Type, object>(), null);
			}
			Dictionary<Type, object> cache = Cache;
			object value;
			lock (cache)
			{
				if (!cache.TryGetValue(typeof(T), out value))
				{
					value = (cache[typeof(T)] = new RuleCache<T>());
				}
			}
			return value as RuleCache<T>;
		}
	}
	/// <summary>Class that contains helper methods for DLR CallSites.</summary>
	public static class CallSiteHelpers
	{
		private static readonly Type s_knownNonDynamicMethodType = typeof(object).GetMethod("ToString").GetType();

		/// <summary>Checks if a <see cref="T:System.Reflection.MethodBase" /> is internally used by DLR and should not be displayed on the language code's stack.</summary>
		/// <param name="mb">The input <see cref="T:System.Reflection.MethodBase" /></param>
		/// <returns>True if the input <see cref="T:System.Reflection.MethodBase" /> is internally used by DLR and should not be displayed on the language code's stack. Otherwise, false.</returns>
		public static bool IsInternalFrame(MethodBase mb)
		{
			if (mb.Name == "CallSite.Target" && mb.GetType() != s_knownNonDynamicMethodType)
			{
				return true;
			}
			if (mb.DeclaringType == typeof(UpdateDelegates))
			{
				return true;
			}
			return false;
		}
	}
	/// <summary>Creates and caches binding rules.</summary>
	[DebuggerStepThrough]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static class CallSiteOps
	{
		/// <summary>Creates an instance of a dynamic call site used for cache lookup.</summary>
		/// <param name="site">An instance of the dynamic call site.</param>
		/// <typeparam name="T">The type of the delegate of the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</typeparam>
		/// <returns>The new call site.</returns>
		[Obsolete("do not use this method", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static CallSite<T> CreateMatchmaker<T>(CallSite<T> site) where T : class
		{
			CallSite<T> callSite = site.CreateMatchMaker();
			callSite._match = true;
			return callSite;
		}

		/// <summary>Checks if a dynamic site requires an update.</summary>
		/// <param name="site">An instance of the dynamic call site.</param>
		/// <returns>true if rule does not need updating, false otherwise.</returns>
		[Obsolete("do not use this method", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static bool SetNotMatched(CallSite site)
		{
			bool match = site._match;
			site._match = false;
			return match;
		}

		/// <summary>Checks whether the executed rule matched</summary>
		/// <param name="site">An instance of the dynamic call site.</param>
		/// <returns>true if rule matched, false otherwise.</returns>
		[Obsolete("do not use this method", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static bool GetMatch(CallSite site)
		{
			return site._match;
		}

		/// <summary>Clears the match flag on the matchmaker call site.</summary>
		/// <param name="site">An instance of the dynamic call site.</param>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("do not use this method", true)]
		public static void ClearMatch(CallSite site)
		{
			site._match = true;
		}

		/// <summary>Adds a rule to the cache maintained on the dynamic call site.</summary>
		/// <param name="site">An instance of the dynamic call site.</param>
		/// <param name="rule">An instance of the call site rule.</param>
		/// <typeparam name="T">The type of the delegate of the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</typeparam>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("do not use this method", true)]
		public static void AddRule<T>(CallSite<T> site, T rule) where T : class
		{
			site.AddRule(rule);
		}

		/// <summary>Updates rules in the cache.</summary>
		/// <param name="this">An instance of the dynamic call site.</param>
		/// <param name="matched">The matched rule index.</param>
		/// <typeparam name="T">The type of the delegate of the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</typeparam>
		[Obsolete("do not use this method", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static void UpdateRules<T>(CallSite<T> @this, int matched) where T : class
		{
			if (matched > 1)
			{
				@this.MoveRule(matched);
			}
		}

		/// <summary>Gets the dynamic binding rules from the call site.</summary>
		/// <param name="site">An instance of the dynamic call site.</param>
		/// <typeparam name="T">The type of the delegate of the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</typeparam>
		/// <returns>An array of dynamic binding rules.</returns>
		[EditorBrowsable(EditorBrowsableState.Never)]
		[Obsolete("do not use this method", true)]
		public static T[] GetRules<T>(CallSite<T> site) where T : class
		{
			return site.Rules;
		}

		/// <summary>Retrieves binding rule cache.</summary>
		/// <param name="site">An instance of the dynamic call site.</param>
		/// <typeparam name="T">The type of the delegate of the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</typeparam>
		/// <returns>The cache.</returns>
		[Obsolete("do not use this method", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static RuleCache<T> GetRuleCache<T>(CallSite<T> site) where T : class
		{
			return site.Binder.GetRuleCache<T>();
		}

		/// <summary>Moves the binding rule within the cache.</summary>
		/// <param name="cache">The call site rule cache.</param>
		/// <param name="rule">An instance of the call site rule.</param>
		/// <param name="i">An index of the call site rule.</param>
		/// <typeparam name="T">The type of the delegate of the <see cref="T:System.Runtime.CompilerServices.CallSite" />. </typeparam>
		[Obsolete("do not use this method", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static void MoveRule<T>(RuleCache<T> cache, T rule, int i) where T : class
		{
			if (i > 1)
			{
				cache.MoveRule(rule, i);
			}
		}

		/// <summary>Searches the dynamic rule cache for rules applicable to the dynamic operation.</summary>
		/// <param name="cache">The cache.</param>
		/// <typeparam name="T">The type of the delegate of the <see cref="T:System.Runtime.CompilerServices.CallSite" />. </typeparam>
		/// <returns>The collection of applicable rules.</returns>
		[Obsolete("do not use this method", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static T[] GetCachedRules<T>(RuleCache<T> cache) where T : class
		{
			return cache.GetRules();
		}

		/// <summary>Updates the call site target with a new rule based on the arguments.</summary>
		/// <param name="binder">The call site binder.</param>
		/// <param name="site">An instance of the dynamic call site.</param>
		/// <param name="args">Arguments to the call site.</param>
		/// <typeparam name="T">The type of the delegate of the <see cref="T:System.Runtime.CompilerServices.CallSite" />.</typeparam>
		/// <returns>The new call site target.</returns>
		[Obsolete("do not use this method", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public static T Bind<T>(CallSiteBinder binder, CallSite<T> site, object[] args) where T : class
		{
			return binder.BindCore(site, args);
		}
	}
	/// <summary>Represents the runtime state of a dynamically generated method.</summary>
	[EditorBrowsable(EditorBrowsableState.Never)]
	[DebuggerStepThrough]
	public sealed class Closure
	{
		/// <summary>Represents the non-trivial constants and locally executable expressions that are referenced by a dynamically generated method.</summary>
		public readonly object[] Constants;

		/// <summary>Represents the hoisted local variables from the parent context.</summary>
		public readonly object[] Locals;

		/// <summary>Creates an object to hold state of a dynamically generated method.</summary>
		/// <param name="constants">The constant values that are used by the method.</param>
		/// <param name="locals">The hoisted local variables from the parent context.</param>
		public Closure(object[] constants, object[] locals)
		{
			Constants = constants;
			Locals = locals;
		}
	}
	/// <summary>Generates debug information for lambda expressions in an expression tree.</summary>
	public abstract class DebugInfoGenerator
	{
		/// <summary>Creates a program database (PDB) symbol generator.</summary>
		/// <returns>A PDB symbol generator.</returns>
		public static DebugInfoGenerator CreatePdbGenerator()
		{
			throw new PlatformNotSupportedException();
		}

		/// <summary>Marks a sequence point in Microsoft intermediate language (MSIL) code.</summary>
		/// <param name="method">The lambda expression that is generated.</param>
		/// <param name="ilOffset">The offset within MSIL code at which to mark the sequence point.</param>
		/// <param name="sequencePoint">Debug information that corresponds to the sequence point.</param>
		public abstract void MarkSequencePoint(LambdaExpression method, int ilOffset, DebugInfoExpression sequencePoint);

		internal virtual void MarkSequencePoint(LambdaExpression method, MethodBase methodBase, ILGenerator ilg, DebugInfoExpression sequencePoint)
		{
			MarkSequencePoint(method, ilg.ILOffset, sequencePoint);
		}

		internal virtual void SetLocalName(LocalBuilder localBuilder, string name)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.DebugInfoGenerator" /> class.</summary>
		protected DebugInfoGenerator()
		{
		}
	}
	/// <summary>Represents the values of run-time variables.</summary>
	public interface IRuntimeVariables
	{
		/// <summary>Gets a count of the run-time variables.</summary>
		/// <returns>The number of run-time variables.</returns>
		int Count { get; }

		/// <summary>Gets the value of the run-time variable at the specified index.</summary>
		/// <param name="index">The zero-based index of the run-time variable whose value is to be returned.</param>
		/// <returns>The value of the run-time variable.</returns>
		object this[int index] { get; set; }
	}
	/// <summary>The builder for read only collection.</summary>
	/// <typeparam name="T">The type of the collection element.</typeparam>
	[Serializable]
	public sealed class ReadOnlyCollectionBuilder<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IList, ICollection
	{
		[Serializable]
		private class Enumerator : IEnumerator<T>, IDisposable, IEnumerator
		{
			private readonly ReadOnlyCollectionBuilder<T> _builder;

			private readonly int _version;

			private int _index;

			private T _current;

			public T Current => _current;

			object IEnumerator.Current
			{
				get
				{
					if (_index == 0 || _index > _builder._size)
					{
						throw System.Linq.Expressions.Error.EnumerationIsDone();
					}
					return _current;
				}
			}

			internal Enumerator(ReadOnlyCollectionBuilder<T> builder)
			{
				_builder = builder;
				_version = builder._version;
				_index = 0;
				_current = default(T);
			}

			public void Dispose()
			{
			}

			public bool MoveNext()
			{
				if (_version == _builder._version)
				{
					if (_index < _builder._size)
					{
						_current = _builder._items[_index++];
						return true;
					}
					_index = _builder._size + 1;
					_current = default(T);
					return false;
				}
				throw System.Linq.Expressions.Error.CollectionModifiedWhileEnumerating();
			}

			void IEnumerator.Reset()
			{
				if (_version != _builder._version)
				{
					throw System.Linq.Expressions.Error.CollectionModifiedWhileEnumerating();
				}
				_index = 0;
				_current = default(T);
			}
		}

		private const int DefaultCapacity = 4;

		private T[] _items;

		private int _size;

		private int _version;

		/// <summary>Gets and sets the capacity of this ReadOnlyCollectionBuilder.</summary>
		/// <returns>The capacity of this ReadOnlyCollectionBuilder.</returns>
		public int Capacity
		{
			get
			{
				return _items.Length;
			}
			set
			{
				if (value < _size)
				{
					throw new ArgumentOutOfRangeException("value");
				}
				if (value == _items.Length)
				{
					return;
				}
				if (value > 0)
				{
					T[] array = new T[value];
					if (_size > 0)
					{
						Array.Copy(_items, 0, array, 0, _size);
					}
					_items = array;
				}
				else
				{
					_items = Array.Empty<T>();
				}
			}
		}

		/// <summary>Returns number of elements in the ReadOnlyCollectionBuilder.</summary>
		/// <returns>The number of elements in the ReadOnlyCollectionBuilder.</returns>
		public int Count => _size;

		/// <summary>Gets or sets the element at the specified index.</summary>
		/// <param name="index">The zero-based index of the element to get or set.</param>
		/// <returns>The element at the specified index.</returns>
		public T this[int index]
		{
			get
			{
				if (index >= _size)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				return _items[index];
			}
			set
			{
				if (index >= _size)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				_items[index] = value;
				_version++;
			}
		}

		/// <summary>Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</summary>
		/// <returns>
		///     <see langword="true" /> if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, <see langword="false" />.</returns>
		bool ICollection<T>.IsReadOnly => false;

		/// <summary>Gets a value indicating whether the <see cref="T:System.Collections.IList" /> is read-only.</summary>
		/// <returns>
		///     <see langword="true" /> if the <see cref="T:System.Collections.IList" /> is read-only; otherwise, <see langword="false" />.</returns>
		bool IList.IsReadOnly => false;

		/// <summary>Gets a value indicating whether the <see cref="T:System.Collections.IList" /> has a fixed size.</summary>
		/// <returns>
		///     <see langword="true" /> if the <see cref="T:System.Collections.IList" /> has a fixed size; otherwise, <see langword="false" />.</returns>
		bool IList.IsFixedSize => false;

		/// <summary>Gets or sets the element at the specified index.</summary>
		/// <param name="index">The zero-based index of the element to get or set.</param>
		/// <returns>The element at the specified index.</returns>
		object IList.this[int index]
		{
			get
			{
				return this[index];
			}
			set
			{
				ValidateNullValue(value, "value");
				try
				{
					this[index] = (T)value;
				}
				catch (InvalidCastException)
				{
					throw System.Linq.Expressions.Error.InvalidTypeException(value, typeof(T), "value");
				}
			}
		}

		/// <summary>Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe).</summary>
		/// <returns>
		///     <see langword="true" /> if access to the <see cref="T:System.Collections.ICollection" /> is synchronized (thread safe); otherwise, <see langword="false" />.</returns>
		bool ICollection.IsSynchronized => false;

		/// <summary>Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</summary>
		/// <returns>An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection" />.</returns>
		object ICollection.SyncRoot => this;

		/// <summary>Constructs a ReadOnlyCollectionBuilder.</summary>
		public ReadOnlyCollectionBuilder()
		{
			_items = Array.Empty<T>();
		}

		/// <summary>Constructs a ReadOnlyCollectionBuilder with a given initial capacity. The contents are empty but builder will have reserved room for the given number of elements before any reallocations are required.</summary>
		/// <param name="capacity">Initial capacity.</param>
		public ReadOnlyCollectionBuilder(int capacity)
		{
			if (capacity < 0)
			{
				throw new ArgumentOutOfRangeException("capacity");
			}
			_items = new T[capacity];
		}

		/// <summary>Constructs a ReadOnlyCollectionBuilder, copying contents of the given collection.</summary>
		/// <param name="collection">Collection to copy elements from.</param>
		public ReadOnlyCollectionBuilder(IEnumerable<T> collection)
		{
			if (collection == null)
			{
				throw new ArgumentNullException("collection");
			}
			if (collection is ICollection<T> { Count: var count } collection2)
			{
				_items = new T[count];
				collection2.CopyTo(_items, 0);
				_size = count;
				return;
			}
			_size = 0;
			_items = new T[4];
			foreach (T item in collection)
			{
				Add(item);
			}
		}

		/// <summary>Returns the index of the first occurrence of a given value in the builder.</summary>
		/// <param name="item">An item to search for.</param>
		/// <returns>The index of the first occurrence of an item.</returns>
		public int IndexOf(T item)
		{
			return Array.IndexOf(_items, item, 0, _size);
		}

		/// <summary>Inserts an item to the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> at the specified index.</summary>
		/// <param name="index">The zero-based index at which item should be inserted.</param>
		/// <param name="item">The object to insert into the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
		public void Insert(int index, T item)
		{
			if (index > _size)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (_size == _items.Length)
			{
				EnsureCapacity(_size + 1);
			}
			if (index < _size)
			{
				Array.Copy(_items, index, _items, index + 1, _size - index);
			}
			_items[index] = item;
			_size++;
			_version++;
		}

		/// <summary>Removes the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> item at the specified index.</summary>
		/// <param name="index">The zero-based index of the item to remove.</param>
		public void RemoveAt(int index)
		{
			if (index < 0 || index >= _size)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			_size--;
			if (index < _size)
			{
				Array.Copy(_items, index + 1, _items, index, _size - index);
			}
			_items[_size] = default(T);
			_version++;
		}

		/// <summary>Adds an item to the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
		/// <param name="item">The object to add to the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
		public void Add(T item)
		{
			if (_size == _items.Length)
			{
				EnsureCapacity(_size + 1);
			}
			_items[_size++] = item;
			_version++;
		}

		/// <summary>Removes all items from the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
		public void Clear()
		{
			if (_size > 0)
			{
				Array.Clear(_items, 0, _size);
				_size = 0;
			}
			_version++;
		}

		/// <summary>Determines whether the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> contains a specific value</summary>
		/// <param name="item">the object to locate in the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
		/// <returns>true if item is found in the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />; otherwise, false.</returns>
		public bool Contains(T item)
		{
			if (item == null)
			{
				for (int i = 0; i < _size; i++)
				{
					if (_items[i] == null)
					{
						return true;
					}
				}
				return false;
			}
			EqualityComparer<T> equalityComparer = EqualityComparer<T>.Default;
			for (int j = 0; j < _size; j++)
			{
				if (equalityComparer.Equals(_items[j], item))
				{
					return true;
				}
			}
			return false;
		}

		/// <summary>Copies the elements of the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> to an <see cref="T:System.Array" />, starting at particular <see cref="T:System.Array" /> index.</summary>
		/// <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
		/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
		public void CopyTo(T[] array, int arrayIndex)
		{
			Array.Copy(_items, 0, array, arrayIndex, _size);
		}

		/// <summary>Removes the first occurrence of a specific object from the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
		/// <param name="item">The object to remove from the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</param>
		/// <returns>true if item was successfully removed from the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />; otherwise, false. This method also returns false if item is not found in the original <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
		public bool Remove(T item)
		{
			int num = IndexOf(item);
			if (num >= 0)
			{
				RemoveAt(num);
				return true;
			}
			return false;
		}

		/// <summary>Returns an enumerator that iterates through the collection.</summary>
		/// <returns>A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.</returns>
		public IEnumerator<T> GetEnumerator()
		{
			return new Enumerator(this);
		}

		/// <summary>Returns an enumerator that iterates through the collection.</summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator" /> that can be used to iterate through the collection.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		/// <summary>Adds an item to the <see cref="T:System.Collections.IList" />.</summary>
		/// <param name="value">The <see cref="T:System.Object" /> to add to the <see cref="T:System.Collections.IList" />.</param>
		/// <returns>The position into which the new element was inserted.</returns>
		int IList.Add(object value)
		{
			ValidateNullValue(value, "value");
			try
			{
				Add((T)value);
			}
			catch (InvalidCastException)
			{
				throw System.Linq.Expressions.Error.InvalidTypeException(value, typeof(T), "value");
			}
			return Count - 1;
		}

		/// <summary>Determines whether the <see cref="T:System.Collections.IList" /> contains a specific value.</summary>
		/// <param name="value">The <see cref="T:System.Object" /> to locate in the <see cref="T:System.Collections.IList" />.</param>
		/// <returns>
		///     <see langword="true" /> if <paramref name="item" /> is found in the <see cref="T:System.Collections.IList" />; otherwise, <see langword="false" />.</returns>
		bool IList.Contains(object value)
		{
			if (IsCompatibleObject(value))
			{
				return Contains((T)value);
			}
			return false;
		}

		/// <summary>Determines the index of a specific item in the <see cref="T:System.Collections.IList" />.</summary>
		/// <param name="value">The object to locate in the <see cref="T:System.Collections.IList" />.</param>
		/// <returns>The index of <paramref name="item" /> if found in the list; otherwise, 1.</returns>
		int IList.IndexOf(object value)
		{
			if (IsCompatibleObject(value))
			{
				return IndexOf((T)value);
			}
			return -1;
		}

		/// <summary>Inserts an item to the <see cref="T:System.Collections.IList" /> at the specified index.</summary>
		/// <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
		/// <param name="value">The object to insert into the <see cref="T:System.Collections.IList" />.</param>
		void IList.Insert(int index, object value)
		{
			ValidateNullValue(value, "value");
			try
			{
				Insert(index, (T)value);
			}
			catch (InvalidCastException)
			{
				throw System.Linq.Expressions.Error.InvalidTypeException(value, typeof(T), "value");
			}
		}

		/// <summary>Removes the first occurrence of a specific object from the <see cref="T:System.Collections.IList" />.</summary>
		/// <param name="value">The object to remove from the <see cref="T:System.Collections.IList" />.</param>
		void IList.Remove(object value)
		{
			if (IsCompatibleObject(value))
			{
				Remove((T)value);
			}
		}

		/// <summary>Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an array, starting at the specified array index.</summary>
		/// <param name="array">The one-dimensional array that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1" />. The array must have zero-based indexing.</param>
		/// <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
		void ICollection.CopyTo(Array array, int index)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (array.Rank != 1)
			{
				throw new ArgumentException("array");
			}
			Array.Copy(_items, 0, array, index, _size);
		}

		/// <summary>Reverses the order of the elements in the entire <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</summary>
		public void Reverse()
		{
			Reverse(0, Count);
		}

		/// <summary>Reverses the order of the elements in the specified range.</summary>
		/// <param name="index">The zero-based starting index of the range to reverse.</param>
		/// <param name="count">The number of elements in the range to reverse.</param>
		public void Reverse(int index, int count)
		{
			if (index < 0)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count");
			}
			Array.Reverse(_items, index, count);
			_version++;
		}

		/// <summary>Copies the elements of the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> to a new array.</summary>
		/// <returns>An array containing copies of the elements of the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />.</returns>
		public T[] ToArray()
		{
			T[] array = new T[_size];
			Array.Copy(_items, 0, array, 0, _size);
			return array;
		}

		/// <summary>Creates a <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> containing all of the elements of the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" />, avoiding copying the elements to the new array if possible. Resets the <see cref="T:System.Runtime.CompilerServices.ReadOnlyCollectionBuilder`1" /> after the <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> has been created.</summary>
		/// <returns>A new instance of <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" />.</returns>
		public ReadOnlyCollection<T> ToReadOnlyCollection()
		{
			T[] list = ((_size != _items.Length) ? ToArray() : _items);
			_items = Array.Empty<T>();
			_size = 0;
			_version++;
			return new TrueReadOnlyCollection<T>(list);
		}

		private void EnsureCapacity(int min)
		{
			if (_items.Length < min)
			{
				int num = 4;
				if (_items.Length != 0)
				{
					num = _items.Length * 2;
				}
				if (num < min)
				{
					num = min;
				}
				Capacity = num;
			}
		}

		private static bool IsCompatibleObject(object value)
		{
			if (!(value is T))
			{
				if (value == null)
				{
					return default(T) == null;
				}
				return false;
			}
			return true;
		}

		private static void ValidateNullValue(object value, string argument)
		{
			if (value == null && default(T) != null)
			{
				throw System.Linq.Expressions.Error.InvalidNullValue(typeof(T), argument);
			}
		}
	}
	/// <summary>Represents a cache of runtime binding rules.</summary>
	/// <typeparam name="T">The delegate type.</typeparam>
	[DebuggerStepThrough]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public class RuleCache<T> where T : class
	{
		private T[] _rules = Array.Empty<T>();

		private readonly object _cacheLock = new object();

		private const int MaxRules = 128;

		private const int InsertPosition = 64;

		internal RuleCache()
		{
		}

		internal T[] GetRules()
		{
			return _rules;
		}

		internal void MoveRule(T rule, int i)
		{
			lock (_cacheLock)
			{
				int num = _rules.Length - i;
				if (num > 8)
				{
					num = 8;
				}
				int num2 = -1;
				int num3 = Math.Min(_rules.Length, i + num);
				for (int j = i; j < num3; j++)
				{
					if (_rules[j] == rule)
					{
						num2 = j;
						break;
					}
				}
				if (num2 >= 2)
				{
					T val = _rules[num2];
					_rules[num2] = _rules[num2 - 1];
					_rules[num2 - 1] = _rules[num2 - 2];
					_rules[num2 - 2] = val;
				}
			}
		}

		internal void AddRule(T newRule)
		{
			lock (_cacheLock)
			{
				_rules = AddOrInsert(_rules, newRule);
			}
		}

		internal void ReplaceRule(T oldRule, T newRule)
		{
			lock (_cacheLock)
			{
				int num = Array.IndexOf(_rules, oldRule);
				if (num >= 0)
				{
					_rules[num] = newRule;
				}
				else
				{
					_rules = AddOrInsert(_rules, newRule);
				}
			}
		}

		private static T[] AddOrInsert(T[] rules, T item)
		{
			if (rules.Length < 64)
			{
				return rules.AddLast(item);
			}
			int num = rules.Length + 1;
			T[] array;
			if (num > 128)
			{
				num = 128;
				array = rules;
			}
			else
			{
				array = new T[num];
				Array.Copy(rules, 0, array, 0, 64);
			}
			array[64] = item;
			Array.Copy(rules, 64, array, 65, num - 64 - 1);
			return array;
		}
	}
	internal sealed class TrueReadOnlyCollection<T> : ReadOnlyCollection<T>
	{
		public TrueReadOnlyCollection(params T[] list)
			: base((IList<T>)list)
		{
		}
	}
	internal class FriendAccessAllowedAttribute : Attribute
	{
	}
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Field, AllowMultiple = true)]
	internal sealed class PreserveDependencyAttribute : Attribute
	{
		public string Condition { get; set; }

		public PreserveDependencyAttribute(string memberSignature)
		{
		}

		public PreserveDependencyAttribute(string memberSignature, string typeName)
		{
		}

		public PreserveDependencyAttribute(string memberSignature, string typeName, string assembly)
		{
		}
	}
	/// <summary>Holds a reference to a value.</summary>
	/// <typeparam name="T">The type of the value that the <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> references.</typeparam>
	public class StrongBox<T> : IStrongBox
	{
		/// <summary>Represents the value that the <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> references.</summary>
		public T Value;

		/// <summary>Gets or sets the value that the <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> references.</summary>
		/// <returns>The value that the <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> references.</returns>
		object IStrongBox.Value
		{
			get
			{
				return Value;
			}
			set
			{
				Value = (T)value;
			}
		}

		/// <summary>Initializes a new StrongBox which can receive a value when used in a reference call.</summary>
		public StrongBox()
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> class by using the supplied value. </summary>
		/// <param name="value">A value that the <see cref="T:System.Runtime.CompilerServices.StrongBox`1" /> will reference.</param>
		public StrongBox(T value)
		{
			Value = value;
		}
	}
	/// <summary>Defines a property for accessing the value that an object references.</summary>
	public interface IStrongBox
	{
		/// <summary>Gets or sets the value that an object references.</summary>
		/// <returns>The value that the object references.</returns>
		object Value { get; set; }
	}
	/// <summary>Indicates that the use of <see cref="T:System.Object" /> on a member is meant to be treated as a dynamically dispatched type.</summary>
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter | AttributeTargets.ReturnValue)]
	public sealed class DynamicAttribute : Attribute
	{
		private readonly bool[] _transformFlags;

		/// <summary>Specifies, in a prefix traversal of a type's construction, which <see cref="T:System.Object" /> occurrences are meant to be treated as a dynamically dispatched type.</summary>
		/// <returns>The list of <see cref="T:System.Object" /> occurrences that are meant to be treated as a dynamically dispatched type.</returns>
		public IList<bool> TransformFlags => Array.AsReadOnly(_transformFlags);

		/// <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" /> class.</summary>
		public DynamicAttribute()
		{
			_transformFlags = new bool[1] { true };
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.DynamicAttribute" /> class.</summary>
		/// <param name="transformFlags">Specifies, in a prefix traversal of a type's construction, which <see cref="T:System.Object" /> occurrences are meant to be treated as a dynamically dispatched type.</param>
		public DynamicAttribute(bool[] transformFlags)
		{
			if (transformFlags == null)
			{
				throw new ArgumentNullException("transformFlags");
			}
			_transformFlags = transformFlags;
		}
	}
	/// <summary>Represents the runtime state of a dynamically generated method.</summary>
	[Obsolete("do not use this type", true)]
	public class ExecutionScope
	{
		/// <summary>Represents the execution scope of the calling delegate.</summary>
		public ExecutionScope Parent;

		/// <summary>Represents the non-trivial constants and locally executable expressions that are referenced by a dynamically generated method.</summary>
		public object[] Globals;

		/// <summary>Represents the hoisted local variables from the parent context.</summary>
		public object[] Locals;

		internal ExecutionScope()
		{
			Parent = null;
			Globals = null;
			Locals = null;
		}

		/// <summary>Creates an array to store the hoisted local variables.</summary>
		/// <returns>An array to store hoisted local variables.</returns>
		public object[] CreateHoistedLocals()
		{
			throw new NotSupportedException();
		}

		/// <summary>Creates a delegate that can be used to execute a dynamically generated method.</summary>
		/// <param name="indexLambda">The index of the object that stores information about associated lambda expression of the dynamic method.</param>
		/// <param name="locals">An array that contains the hoisted local variables from the parent context.</param>
		/// <returns>A <see cref="T:System.Delegate" /> that can execute a dynamically generated method.</returns>
		public Delegate CreateDelegate(int indexLambda, object[] locals)
		{
			throw new NotSupportedException();
		}

		/// <summary>Frees a specified expression tree of external parameter references by replacing the parameter with its current value.</summary>
		/// <param name="expression">An expression tree to free of external parameter references.</param>
		/// <param name="locals">An array that contains the hoisted local variables.</param>
		/// <returns>An expression tree that does not contain external parameter references.</returns>
		public Expression IsolateExpression(Expression expression, object[] locals)
		{
			throw new NotSupportedException();
		}
	}
}
namespace System.Dynamic
{
	/// <summary>Represents the binary dynamic operation at the call site, providing the binding semantic and the details about the operation.</summary>
	public abstract class BinaryOperationBinder : DynamicMetaObjectBinder
	{
		/// <summary>The result type of the operation.</summary>
		/// <returns>The result type of the operation.</returns>
		public sealed override Type ReturnType => typeof(object);

		/// <summary>The binary operation kind.</summary>
		/// <returns>The <see cref="T:System.Linq.Expressions.ExpressionType" /> object representing the kind of binary operation.</returns>
		public ExpressionType Operation { get; }

		internal sealed override bool IsStandardBinder => true;

		/// <summary>Initializes a new instance of the <see cref="T:System.Dynamic.BinaryOperationBinder" /> class.</summary>
		/// <param name="operation">The binary operation kind.</param>
		protected BinaryOperationBinder(ExpressionType operation)
		{
			ContractUtils.Requires(OperationIsValid(operation), "operation");
			Operation = operation;
		}

		/// <summary>Performs the binding of the binary dynamic operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic binary operation.</param>
		/// <param name="arg">The right hand side operand of the dynamic binary operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg)
		{
			return FallbackBinaryOperation(target, arg, null);
		}

		/// <summary>When overridden in the derived class, performs the binding of the binary dynamic operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic binary operation.</param>
		/// <param name="arg">The right hand side operand of the dynamic binary operation.</param>
		/// <param name="errorSuggestion">The binding result if the binding fails, or null.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public abstract DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);

		/// <summary>Performs the binding of the dynamic binary operation.</summary>
		/// <param name="target">The target of the dynamic operation.</param>
		/// <param name="args">An array of arguments of the dynamic operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(target, "target");
			ContractUtils.RequiresNotNull(args, "args");
			ContractUtils.Requires(args.Length == 1, "args");
			DynamicMetaObject dynamicMetaObject = args[0];
			ContractUtils.RequiresNotNull(dynamicMetaObject, "args");
			return target.BindBinaryOperation(this, dynamicMetaObject);
		}

		internal static bool OperationIsValid(ExpressionType operation)
		{
			switch (operation)
			{
			case ExpressionType.Add:
			case ExpressionType.And:
			case ExpressionType.Divide:
			case ExpressionType.Equal:
			case ExpressionType.ExclusiveOr:
			case ExpressionType.GreaterThan:
			case ExpressionType.GreaterThanOrEqual:
			case ExpressionType.LeftShift:
			case ExpressionType.LessThan:
			case ExpressionType.LessThanOrEqual:
			case ExpressionType.Modulo:
			case ExpressionType.Multiply:
			case ExpressionType.NotEqual:
			case ExpressionType.Or:
			case ExpressionType.Power:
			case ExpressionType.RightShift:
			case ExpressionType.Subtract:
			case ExpressionType.Extension:
			case ExpressionType.AddAssign:
			case ExpressionType.AndAssign:
			case ExpressionType.DivideAssign:
			case ExpressionType.ExclusiveOrAssign:
			case ExpressionType.LeftShiftAssign:
			case ExpressionType.ModuloAssign:
			case ExpressionType.MultiplyAssign:
			case ExpressionType.OrAssign:
			case ExpressionType.PowerAssign:
			case ExpressionType.RightShiftAssign:
			case ExpressionType.SubtractAssign:
				return true;
			default:
				return false;
			}
		}
	}
	/// <summary>Represents a set of binding restrictions on the <see cref="T:System.Dynamic.DynamicMetaObject" /> under which the dynamic binding is valid.</summary>
	[DebuggerTypeProxy(typeof(BindingRestrictionsProxy))]
	[DebuggerDisplay("{DebugView}")]
	public abstract class BindingRestrictions
	{
		private sealed class TestBuilder
		{
			private struct AndNode
			{
				internal int Depth;

				internal Expression Node;
			}

			private readonly HashSet<BindingRestrictions> _unique = new HashSet<BindingRestrictions>();

			private readonly Stack<AndNode> _tests = new Stack<AndNode>();

			internal void Append(BindingRestrictions restrictions)
			{
				if (_unique.Add(restrictions))
				{
					Push(restrictions.GetExpression(), 0);
				}
			}

			internal Expression ToExpression()
			{
				Expression expression = _tests.Pop().Node;
				while (_tests.Count > 0)
				{
					expression = Expression.AndAlso(_tests.Pop().Node, expression);
				}
				return expression;
			}

			private void Push(Expression node, int depth)
			{
				while (_tests.Count > 0 && _tests.Peek().Depth == depth)
				{
					node = Expression.AndAlso(_tests.Pop().Node, node);
					depth++;
				}
				_tests.Push(new AndNode
				{
					Node = node,
					Depth = depth
				});
			}
		}

		private sealed class MergedRestriction : BindingRestrictions
		{
			internal readonly BindingRestrictions Left;

			internal readonly BindingRestrictions Right;

			internal MergedRestriction(BindingRestrictions left, BindingRestrictions right)
			{
				Left = left;
				Right = right;
			}

			internal override Expression GetExpression()
			{
				TestBuilder testBuilder = new TestBuilder();
				Stack<BindingRestrictions> stack = new Stack<BindingRestrictions>();
				BindingRestrictions bindingRestrictions = this;
				while (true)
				{
					if (bindingRestrictions is MergedRestriction mergedRestriction)
					{
						stack.Push(mergedRestriction.Right);
						bindingRestrictions = mergedRestriction.Left;
						continue;
					}
					testBuilder.Append(bindingRestrictions);
					if (stack.Count == 0)
					{
						break;
					}
					bindingRestrictions = stack.Pop();
				}
				return testBuilder.ToExpression();
			}
		}

		private sealed class CustomRestriction : BindingRestrictions
		{
			private readonly Expression _expression;

			internal CustomRestriction(Expression expression)
			{
				_expression = expression;
			}

			public override bool Equals(object obj)
			{
				return (obj as CustomRestriction)?._expression == _expression;
			}

			public override int GetHashCode()
			{
				return 0x24924924 ^ _expression.GetHashCode();
			}

			internal override Expression GetExpression()
			{
				return _expression;
			}
		}

		private sealed class TypeRestriction : BindingRestrictions
		{
			private readonly Expression _expression;

			private readonly Type _type;

			internal TypeRestriction(Expression parameter, Type type)
			{
				_expression = parameter;
				_type = type;
			}

			public override bool Equals(object obj)
			{
				TypeRestriction typeRestriction = obj as TypeRestriction;
				if (typeRestriction?._expression == _expression)
				{
					return TypeUtils.AreEquivalent(typeRestriction._type, _type);
				}
				return false;
			}

			public override int GetHashCode()
			{
				return 0x49249249 ^ _expression.GetHashCode() ^ _type.GetHashCode();
			}

			internal override Expression GetExpression()
			{
				return Expression.TypeEqual(_expression, _type);
			}
		}

		private sealed class InstanceRestriction : BindingRestrictions
		{
			private readonly Expression _expression;

			private readonly object _instance;

			internal InstanceRestriction(Expression parameter, object instance)
			{
				_expression = parameter;
				_instance = instance;
			}

			public override bool Equals(object obj)
			{
				InstanceRestriction instanceRestriction = obj as InstanceRestriction;
				if (instanceRestriction?._expression == _expression)
				{
					return instanceRestriction._instance == _instance;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return -1840700270 ^ RuntimeHelpers.GetHashCode(_instance) ^ _expression.GetHashCode();
			}

			internal override Expression GetExpression()
			{
				if (_instance == null)
				{
					return Expression.Equal(Expression.Convert(_expression, typeof(object)), System.Linq.Expressions.Utils.Null);
				}
				ParameterExpression parameterExpression = Expression.Parameter(typeof(object), null);
				return Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(parameterExpression), new TrueReadOnlyCollection<Expression>(Expression.Assign(parameterExpression, Expression.Constant(_instance, typeof(object))), Expression.AndAlso(Expression.NotEqual(parameterExpression, System.Linq.Expressions.Utils.Null), Expression.Equal(Expression.Convert(_expression, typeof(object)), parameterExpression))));
			}
		}

		private sealed class BindingRestrictionsProxy
		{
			private readonly BindingRestrictions _node;

			public bool IsEmpty => _node == Empty;

			public Expression Test => _node.ToExpression();

			public BindingRestrictions[] Restrictions
			{
				get
				{
					List<BindingRestrictions> list = new List<BindingRestrictions>();
					Stack<BindingRestrictions> stack = new Stack<BindingRestrictions>();
					BindingRestrictions bindingRestrictions = _node;
					while (true)
					{
						if (bindingRestrictions is MergedRestriction mergedRestriction)
						{
							stack.Push(mergedRestriction.Right);
							bindingRestrictions = mergedRestriction.Left;
							continue;
						}
						list.Add(bindingRestrictions);
						if (stack.Count == 0)
						{
							break;
						}
						bindingRestrictions = stack.Pop();
					}
					return list.ToArray();
				}
			}

			public BindingRestrictionsProxy(BindingRestrictions node)
			{
				ContractUtils.RequiresNotNull(node, "node");
				_node = node;
			}

			public override string ToString()
			{
				return _node.DebugView;
			}
		}

		/// <summary>Represents an empty set of binding restrictions. This field is read only.</summary>
		public static readonly BindingRestrictions Empty = new CustomRestriction(System.Linq.Expressions.Utils.Constant(value: true));

		private const int TypeRestrictionHash = 1227133513;

		private const int InstanceRestrictionHash = -1840700270;

		private const int CustomRestrictionHash = 613566756;

		private string DebugView => ToExpression().ToString();

		private BindingRestrictions()
		{
		}

		internal abstract Expression GetExpression();

		/// <summary>Merges the set of binding restrictions with the current binding restrictions.</summary>
		/// <param name="restrictions">The set of restrictions with which to merge the current binding restrictions.</param>
		/// <returns>The new set of binding restrictions.</returns>
		public BindingRestrictions Merge(BindingRestrictions restrictions)
		{
			ContractUtils.RequiresNotNull(restrictions, "restrictions");
			if (this == Empty)
			{
				return restrictions;
			}
			if (restrictions == Empty)
			{
				return this;
			}
			return new MergedRestriction(this, restrictions);
		}

		/// <summary>Creates the binding restriction that check the expression for runtime type identity.</summary>
		/// <param name="expression">The expression to test.</param>
		/// <param name="type">The exact type to test.</param>
		/// <returns>The new binding restrictions.</returns>
		public static BindingRestrictions GetTypeRestriction(Expression expression, Type type)
		{
			ContractUtils.RequiresNotNull(expression, "expression");
			ContractUtils.RequiresNotNull(type, "type");
			return new TypeRestriction(expression, type);
		}

		internal static BindingRestrictions GetTypeRestriction(DynamicMetaObject obj)
		{
			if (obj.Value == null && obj.HasValue)
			{
				return GetInstanceRestriction(obj.Expression, null);
			}
			return GetTypeRestriction(obj.Expression, obj.LimitType);
		}

		/// <summary>Creates the binding restriction that checks the expression for object instance identity.</summary>
		/// <param name="expression">The expression to test.</param>
		/// <param name="instance">The exact object instance to test.</param>
		/// <returns>The new binding restrictions.</returns>
		public static BindingRestrictions GetInstanceRestriction(Expression expression, object instance)
		{
			ContractUtils.RequiresNotNull(expression, "expression");
			return new InstanceRestriction(expression, instance);
		}

		/// <summary>Creates the binding restriction that checks the expression for arbitrary immutable properties.</summary>
		/// <param name="expression">The expression representing the restrictions.</param>
		/// <returns>The new binding restrictions.</returns>
		public static BindingRestrictions GetExpressionRestriction(Expression expression)
		{
			ContractUtils.RequiresNotNull(expression, "expression");
			ContractUtils.Requires(expression.Type == typeof(bool), "expression");
			return new CustomRestriction(expression);
		}

		/// <summary>Combines binding restrictions from the list of <see cref="T:System.Dynamic.DynamicMetaObject" /> instances into one set of restrictions.</summary>
		/// <param name="contributingObjects">The list of <see cref="T:System.Dynamic.DynamicMetaObject" /> instances from which to combine restrictions.</param>
		/// <returns>The new set of binding restrictions.</returns>
		public static BindingRestrictions Combine(IList<DynamicMetaObject> contributingObjects)
		{
			BindingRestrictions bindingRestrictions = Empty;
			if (contributingObjects != null)
			{
				foreach (DynamicMetaObject contributingObject in contributingObjects)
				{
					if (contributingObject != null)
					{
						bindingRestrictions = bindingRestrictions.Merge(contributingObject.Restrictions);
					}
				}
			}
			return bindingRestrictions;
		}

		/// <summary>Creates the <see cref="T:System.Linq.Expressions.Expression" /> representing the binding restrictions.</summary>
		/// <returns>The expression tree representing the restrictions.</returns>
		public Expression ToExpression()
		{
			return GetExpression();
		}
	}
	/// <summary>Describes arguments in the dynamic binding process.</summary>
	public sealed class CallInfo
	{
		/// <summary>The number of arguments.</summary>
		/// <returns>The number of arguments.</returns>
		public int ArgumentCount { get; }

		/// <summary>The argument names.</summary>
		/// <returns>The read-only collection of argument names.</returns>
		public ReadOnlyCollection<string> ArgumentNames { get; }

		/// <summary>Creates a new PositionalArgumentInfo.</summary>
		/// <param name="argCount">The number of arguments.</param>
		/// <param name="argNames">The argument names.</param>
		public CallInfo(int argCount, params string[] argNames)
			: this(argCount, (IEnumerable<string>)argNames)
		{
		}

		/// <summary>Creates a new CallInfo that represents arguments in the dynamic binding process.</summary>
		/// <param name="argCount">The number of arguments.</param>
		/// <param name="argNames">The argument names.</param>
		public CallInfo(int argCount, IEnumerable<string> argNames)
		{
			ContractUtils.RequiresNotNull(argNames, "argNames");
			ReadOnlyCollection<string> readOnlyCollection = argNames.ToReadOnly();
			if (argCount < readOnlyCollection.Count)
			{
				throw System.Linq.Expressions.Error.ArgCntMustBeGreaterThanNameCnt();
			}
			ContractUtils.RequiresNotNullItems(readOnlyCollection, "argNames");
			ArgumentCount = argCount;
			ArgumentNames = readOnlyCollection;
		}

		/// <summary>Serves as a hash function for the current <see cref="T:System.Dynamic.CallInfo" />.</summary>
		/// <returns>A hash code for the current <see cref="T:System.Dynamic.CallInfo" />.</returns>
		public override int GetHashCode()
		{
			return ArgumentCount ^ ArgumentNames.ListHashCode();
		}

		/// <summary>Determines whether the specified CallInfo instance is considered equal to the current.</summary>
		/// <param name="obj">The instance of <see cref="T:System.Dynamic.CallInfo" /> to compare with the current instance.</param>
		/// <returns>true if the specified instance is equal to the current one otherwise, false.</returns>
		public override bool Equals(object obj)
		{
			if (obj is CallInfo callInfo && ArgumentCount == callInfo.ArgumentCount)
			{
				return ArgumentNames.ListEquals(callInfo.ArgumentNames);
			}
			return false;
		}
	}
	/// <summary>Represents the convert dynamic operation at the call site, providing the binding semantic and the details about the operation.</summary>
	public abstract class ConvertBinder : DynamicMetaObjectBinder
	{
		/// <summary>The type to convert to.</summary>
		/// <returns>The <see cref="T:System.Type" /> object that represents the type to convert to.</returns>
		public Type Type { get; }

		/// <summary>Gets the value indicating if the conversion should consider explicit conversions.</summary>
		/// <returns>
		///     <see langword="True" /> if there is an explicit conversion, otherwise <see langword="false" />.</returns>
		public bool Explicit { get; }

		internal sealed override bool IsStandardBinder => true;

		/// <summary>The result type of the operation.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the result type of the operation.</returns>
		public sealed override Type ReturnType => Type;

		/// <summary>Initializes a new instance of the <see cref="T:System.Dynamic.ConvertBinder" />.</summary>
		/// <param name="type">The type to convert to.</param>
		/// <param name="explicit">Is true if the conversion should consider explicit conversions; otherwise, false.</param>
		protected ConvertBinder(Type type, bool @explicit)
		{
			ContractUtils.RequiresNotNull(type, "type");
			Type = type;
			Explicit = @explicit;
		}

		/// <summary>Performs the binding of the dynamic convert operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic convert operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public DynamicMetaObject FallbackConvert(DynamicMetaObject target)
		{
			return FallbackConvert(target, null);
		}

		/// <summary>When overridden in the derived class, performs the binding of the dynamic convert operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic convert operation.</param>
		/// <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public abstract DynamicMetaObject FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion);

		/// <summary>Performs the binding of the dynamic convert operation.</summary>
		/// <param name="target">The target of the dynamic convert operation.</param>
		/// <param name="args">An array of arguments of the dynamic convert operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(target, "target");
			ContractUtils.Requires(args == null || args.Length == 0, "args");
			return target.BindConvert(this);
		}
	}
	/// <summary>Represents the dynamic create operation at the call site, providing the binding semantic and the details about the operation.</summary>
	public abstract class CreateInstanceBinder : DynamicMetaObjectBinder
	{
		/// <summary>The result type of the operation.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the result type of the operation.</returns>
		public sealed override Type ReturnType => typeof(object);

		/// <summary>Gets the signature of the arguments at the call site.</summary>
		/// <returns>The signature of the arguments at the call site.</returns>
		public CallInfo CallInfo { get; }

		internal sealed override bool IsStandardBinder => true;

		/// <summary>Initializes a new intsance of the <see cref="T:System.Dynamic.CreateInstanceBinder" />.</summary>
		/// <param name="callInfo">The signature of the arguments at the call site.</param>
		protected CreateInstanceBinder(CallInfo callInfo)
		{
			ContractUtils.RequiresNotNull(callInfo, "callInfo");
			CallInfo = callInfo;
		}

		/// <summary>Performs the binding of the dynamic create operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic create operation.</param>
		/// <param name="args">The arguments of the dynamic create operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			return FallbackCreateInstance(target, args, null);
		}

		/// <summary>When overridden in the derived class, performs the binding of the dynamic create operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic create operation.</param>
		/// <param name="args">The arguments of the dynamic create operation.</param>
		/// <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public abstract DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);

		/// <summary>Performs the binding of the dynamic create operation.</summary>
		/// <param name="target">The target of the dynamic create operation.</param>
		/// <param name="args">An array of arguments of the dynamic create operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(target, "target");
			ContractUtils.RequiresNotNullItems(args, "args");
			return target.BindCreateInstance(this, args);
		}
	}
	/// <summary>Represents the dynamic delete index operation at the call site, providing the binding semantic and the details about the operation.</summary>
	public abstract class DeleteIndexBinder : DynamicMetaObjectBinder
	{
		/// <summary>The result type of the operation.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the result type of the operation.</returns>
		public sealed override Type ReturnType => typeof(void);

		/// <summary>Gets the signature of the arguments at the call site.</summary>
		/// <returns>The signature of the arguments at the call site.</returns>
		public CallInfo CallInfo { get; }

		internal sealed override bool IsStandardBinder => true;

		/// <summary>Initializes a new instance of the <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
		/// <param name="callInfo">The signature of the arguments at the call site.</param>
		protected DeleteIndexBinder(CallInfo callInfo)
		{
			ContractUtils.RequiresNotNull(callInfo, "callInfo");
			CallInfo = callInfo;
		}

		/// <summary>Performs the binding of the dynamic delete index operation.</summary>
		/// <param name="target">The target of the dynamic delete index operation.</param>
		/// <param name="args">An array of arguments of the dynamic delete index operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(target, "target");
			ContractUtils.RequiresNotNullItems(args, "args");
			return target.BindDeleteIndex(this, args);
		}

		/// <summary>Performs the binding of the dynamic delete index operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic delete index operation.</param>
		/// <param name="indexes">The arguments of the dynamic delete index operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes)
		{
			return FallbackDeleteIndex(target, indexes, null);
		}

		/// <summary>When overridden in the derived class, performs the binding of the dynamic delete index operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic delete index operation.</param>
		/// <param name="indexes">The arguments of the dynamic delete index operation.</param>
		/// <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public abstract DynamicMetaObject FallbackDeleteIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
	}
	/// <summary>Represents the dynamic delete member operation at the call site, providing the binding semantic and the details about the operation.</summary>
	public abstract class DeleteMemberBinder : DynamicMetaObjectBinder
	{
		/// <summary>Gets the name of the member to delete.</summary>
		/// <returns>The name of the member to delete.</returns>
		public string Name { get; }

		/// <summary>Gets the value indicating if the string comparison should ignore the case of the member name.</summary>
		/// <returns>True if the string comparison should ignore the case, otherwise false.</returns>
		public bool IgnoreCase { get; }

		/// <summary>The result type of the operation.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the result type of the operation.</returns>
		public sealed override Type ReturnType => typeof(void);

		internal sealed override bool IsStandardBinder => true;

		/// <summary>Initializes a new instance of the <see cref="T:System.Dynamic.DeleteIndexBinder" />.</summary>
		/// <param name="name">The name of the member to delete.</param>
		/// <param name="ignoreCase">Is true if the name should be matched ignoring case; false otherwise.</param>
		protected DeleteMemberBinder(string name, bool ignoreCase)
		{
			ContractUtils.RequiresNotNull(name, "name");
			Name = name;
			IgnoreCase = ignoreCase;
		}

		/// <summary>Performs the binding of the dynamic delete member operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic delete member operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target)
		{
			return FallbackDeleteMember(target, null);
		}

		/// <summary>When overridden in the derived class, performs the binding of the dynamic delete member operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic delete member operation.</param>
		/// <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public abstract DynamicMetaObject FallbackDeleteMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);

		/// <summary>Performs the binding of the dynamic delete member operation.</summary>
		/// <param name="target">The target of the dynamic delete member operation.</param>
		/// <param name="args">An array of arguments of the dynamic delete member operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(target, "target");
			ContractUtils.Requires(args == null || args.Length == 0, "args");
			return target.BindDeleteMember(this);
		}
	}
	/// <summary>Represents the dynamic binding and a binding logic of an object participating in the dynamic binding.</summary>
	public class DynamicMetaObject
	{
		/// <summary>Represents an empty array of type <see cref="T:System.Dynamic.DynamicMetaObject" />. This field is read only.</summary>
		public static readonly DynamicMetaObject[] EmptyMetaObjects = Array.Empty<DynamicMetaObject>();

		private static readonly object s_noValueSentinel = new object();

		private readonly object _value = s_noValueSentinel;

		/// <summary>The expression representing the <see cref="T:System.Dynamic.DynamicMetaObject" /> during the dynamic binding process.</summary>
		/// <returns>The expression representing the <see cref="T:System.Dynamic.DynamicMetaObject" /> during the dynamic binding process.</returns>
		public Expression Expression { get; }

		/// <summary>The set of binding restrictions under which the binding is valid.</summary>
		/// <returns>The set of binding restrictions.</returns>
		public BindingRestrictions Restrictions { get; }

		/// <summary>The runtime value represented by this <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
		/// <returns>The runtime value represented by this <see cref="T:System.Dynamic.DynamicMetaObject" />.</returns>
		public object Value
		{
			get
			{
				if (!HasValue)
				{
					return null;
				}
				return _value;
			}
		}

		/// <summary>Gets a value indicating whether the <see cref="T:System.Dynamic.DynamicMetaObject" /> has the runtime value.</summary>
		/// <returns>True if the <see cref="T:System.Dynamic.DynamicMetaObject" /> has the runtime value, otherwise false.</returns>
		public bool HasValue => _value != s_noValueSentinel;

		/// <summary>Gets the <see cref="T:System.Type" /> of the runtime value or null if the <see cref="T:System.Dynamic.DynamicMetaObject" /> has no value associated with it.</summary>
		/// <returns>The <see cref="T:System.Type" /> of the runtime value or null.</returns>
		public Type RuntimeType
		{
			get
			{
				if (HasValue)
				{
					Type type = Expression.Type;
					if (type.IsValueType)
					{
						return type;
					}
					return Value?.GetType();
				}
				return null;
			}
		}

		/// <summary>Gets the limit type of the <see cref="T:System.Dynamic.DynamicMetaObject" />.</summary>
		/// <returns>
		///     <see cref="P:System.Dynamic.DynamicMetaObject.RuntimeType" /> if runtime value is available, a type of the <see cref="P:System.Dynamic.DynamicMetaObject.Expression" /> otherwise.</returns>
		public Type LimitType => RuntimeType ?? Expression.Type;

		/// <summary>Initializes a new instance of the <see cref="T:System.Dynamic.DynamicMetaObject" /> class.</summary>
		/// <param name="expression">The expression representing this <see cref="T:System.Dynamic.DynamicMetaObject" /> during the dynamic binding process.</param>
		/// <param name="restrictions">The set of binding restrictions under which the binding is valid.</param>
		public DynamicMetaObject(Expression expression, BindingRestrictions restrictions)
		{
			ContractUtils.RequiresNotNull(expression, "expression");
			ContractUtils.RequiresNotNull(restrictions, "restrictions");
			Expression = expression;
			Restrictions = restrictions;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Dynamic.DynamicMetaObject" /> class.</summary>
		/// <param name="expression">The expression representing this <see cref="T:System.Dynamic.DynamicMetaObject" /> during the dynamic binding process.</param>
		/// <param name="restrictions">The set of binding restrictions under which the binding is valid.</param>
		/// <param name="value">The runtime value represented by the <see cref="T:System.Dynamic.DynamicMetaObject" />.</param>
		public DynamicMetaObject(Expression expression, BindingRestrictions restrictions, object value)
			: this(expression, restrictions)
		{
			_value = value;
		}

		/// <summary>Performs the binding of the dynamic conversion operation.</summary>
		/// <param name="binder">An instance of the <see cref="T:System.Dynamic.ConvertBinder" /> that represents the details of the dynamic operation.</param>
		/// <returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public virtual DynamicMetaObject BindConvert(ConvertBinder binder)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			return binder.FallbackConvert(this);
		}

		/// <summary>Performs the binding of the dynamic get member operation.</summary>
		/// <param name="binder">An instance of the <see cref="T:System.Dynamic.GetMemberBinder" /> that represents the details of the dynamic operation.</param>
		/// <returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			return binder.FallbackGetMember(this);
		}

		/// <summary>Performs the binding of the dynamic set member operation.</summary>
		/// <param name="binder">An instance of the <see cref="T:System.Dynamic.SetMemberBinder" /> that represents the details of the dynamic operation.</param>
		/// <param name="value">The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the value for the set member operation.</param>
		/// <returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			return binder.FallbackSetMember(this, value);
		}

		/// <summary>Performs the binding of the dynamic delete member operation.</summary>
		/// <param name="binder">An instance of the <see cref="T:System.Dynamic.DeleteMemberBinder" /> that represents the details of the dynamic operation.</param>
		/// <returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			return binder.FallbackDeleteMember(this);
		}

		/// <summary>Performs the binding of the dynamic get index operation.</summary>
		/// <param name="binder">An instance of the <see cref="T:System.Dynamic.GetIndexBinder" /> that represents the details of the dynamic operation.</param>
		/// <param name="indexes">An array of <see cref="T:System.Dynamic.DynamicMetaObject" /> instances - indexes for the get index operation.</param>
		/// <returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			return binder.FallbackGetIndex(this, indexes);
		}

		/// <summary>Performs the binding of the dynamic set index operation.</summary>
		/// <param name="binder">An instance of the <see cref="T:System.Dynamic.SetIndexBinder" /> that represents the details of the dynamic operation.</param>
		/// <param name="indexes">An array of <see cref="T:System.Dynamic.DynamicMetaObject" /> instances - indexes for the set index operation.</param>
		/// <param name="value">The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the value for the set index operation.</param>
		/// <returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			return binder.FallbackSetIndex(this, indexes, value);
		}

		/// <summary>Performs the binding of the dynamic delete index operation.</summary>
		/// <param name="binder">An instance of the <see cref="T:System.Dynamic.DeleteIndexBinder" /> that represents the details of the dynamic operation.</param>
		/// <param name="indexes">An array of <see cref="T:System.Dynamic.DynamicMetaObject" /> instances - indexes for the delete index operation.</param>
		/// <returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			return binder.FallbackDeleteIndex(this, indexes);
		}

		/// <summary>Performs the binding of the dynamic invoke member operation.</summary>
		/// <param name="binder">An instance of the <see cref="T:System.Dynamic.InvokeMemberBinder" /> that represents the details of the dynamic operation.</param>
		/// <param name="args">An array of <see cref="T:System.Dynamic.DynamicMetaObject" /> instances - arguments to the invoke member operation.</param>
		/// <returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			return binder.FallbackInvokeMember(this, args);
		}

		/// <summary>Performs the binding of the dynamic invoke operation.</summary>
		/// <param name="binder">An instance of the <see cref="T:System.Dynamic.InvokeBinder" /> that represents the details of the dynamic operation.</param>
		/// <param name="args">An array of <see cref="T:System.Dynamic.DynamicMetaObject" /> instances - arguments to the invoke operation.</param>
		/// <returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			return binder.FallbackInvoke(this, args);
		}

		/// <summary>Performs the binding of the dynamic create instance operation.</summary>
		/// <param name="binder">An instance of the <see cref="T:System.Dynamic.CreateInstanceBinder" /> that represents the details of the dynamic operation.</param>
		/// <param name="args">An array of <see cref="T:System.Dynamic.DynamicMetaObject" /> instances - arguments to the create instance operation.</param>
		/// <returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			return binder.FallbackCreateInstance(this, args);
		}

		/// <summary>Performs the binding of the dynamic unary operation.</summary>
		/// <param name="binder">An instance of the <see cref="T:System.Dynamic.UnaryOperationBinder" /> that represents the details of the dynamic operation.</param>
		/// <returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			return binder.FallbackUnaryOperation(this);
		}

		/// <summary>Performs the binding of the dynamic binary operation.</summary>
		/// <param name="binder">An instance of the <see cref="T:System.Dynamic.BinaryOperationBinder" /> that represents the details of the dynamic operation.</param>
		/// <param name="arg">An instance of the <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the right hand side of the binary operation.</param>
		/// <returns>The new <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg)
		{
			ContractUtils.RequiresNotNull(binder, "binder");
			return binder.FallbackBinaryOperation(this, arg);
		}

		/// <summary>Returns the enumeration of all dynamic member names.</summary>
		/// <returns>The list of dynamic member names.</returns>
		public virtual IEnumerable<string> GetDynamicMemberNames()
		{
			return Array.Empty<string>();
		}

		internal static Expression[] GetExpressions(DynamicMetaObject[] objects)
		{
			ContractUtils.RequiresNotNull(objects, "objects");
			Expression[] array = new Expression[objects.Length];
			for (int i = 0; i < objects.Length; i++)
			{
				DynamicMetaObject obj = objects[i];
				ContractUtils.RequiresNotNull(obj, "objects");
				Expression expression = obj.Expression;
				array[i] = expression;
			}
			return array;
		}

		/// <summary>Creates a meta-object for the specified object.</summary>
		/// <param name="value">The object to get a meta-object for.</param>
		/// <param name="expression">The expression representing this <see cref="T:System.Dynamic.DynamicMetaObject" /> during the dynamic binding process.</param>
		/// <returns>If the given object implements <see cref="T:System.Dynamic.IDynamicMetaObjectProvider" /> and is not a remote object from outside the current AppDomain, returns the object's specific meta-object returned by <see cref="M:System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(System.Linq.Expressions.Expression)" />. Otherwise a plain new meta-object with no restrictions is created and returned.</returns>
		public static DynamicMetaObject Create(object value, Expression expression)
		{
			ContractUtils.RequiresNotNull(expression, "expression");
			if (value is IDynamicMetaObjectProvider dynamicMetaObjectProvider)
			{
				DynamicMetaObject metaObject = dynamicMetaObjectProvider.GetMetaObject(expression);
				if (metaObject == null || !metaObject.HasValue || metaObject.Value == null || metaObject.Expression != expression)
				{
					throw System.Linq.Expressions.Error.InvalidMetaObjectCreated(dynamicMetaObjectProvider.GetType());
				}
				return metaObject;
			}
			return new DynamicMetaObject(expression, BindingRestrictions.Empty, value);
		}
	}
	/// <summary>The dynamic call site binder that participates in the <see cref="T:System.Dynamic.DynamicMetaObject" /> binding protocol.</summary>
	public abstract class DynamicMetaObjectBinder : CallSiteBinder
	{
		/// <summary>The result type of the operation.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the result type of the operation.</returns>
		public virtual Type ReturnType => typeof(object);

		internal virtual bool IsStandardBinder => false;

		/// <summary>Initializes a new instance of the <see cref="T:System.Dynamic.DynamicMetaObjectBinder" /> class.</summary>
		protected DynamicMetaObjectBinder()
		{
		}

		/// <summary>Performs the runtime binding of the dynamic operation on a set of arguments.</summary>
		/// <param name="args">An array of arguments to the dynamic operation.</param>
		/// <param name="parameters">The array of <see cref="T:System.Linq.Expressions.ParameterExpression" /> instances that represent the parameters of the call site in the binding process.</param>
		/// <param name="returnLabel">A LabelTarget used to return the result of the dynamic binding.</param>
		/// <returns>An Expression that performs tests on the dynamic operation arguments, and performs the dynamic operation if the tests are valid. If the tests fail on subsequent occurrences of the dynamic operation, Bind will be called again to produce a new <see cref="T:System.Linq.Expressions.Expression" /> for the new argument types.</returns>
		public sealed override Expression Bind(object[] args, ReadOnlyCollection<ParameterExpression> parameters, LabelTarget returnLabel)
		{
			ContractUtils.RequiresNotNull(args, "args");
			ContractUtils.RequiresNotNull(parameters, "parameters");
			ContractUtils.RequiresNotNull(returnLabel, "returnLabel");
			if (args.Length == 0)
			{
				throw System.Linq.Expressions.Error.OutOfRange("args.Length", 1);
			}
			if (parameters.Count == 0)
			{
				throw System.Linq.Expressions.Error.OutOfRange("parameters.Count", 1);
			}
			if (args.Length != parameters.Count)
			{
				throw new ArgumentOutOfRangeException("args");
			}
			Type type;
			if (IsStandardBinder)
			{
				type = ReturnType;
				if (returnLabel.Type != typeof(void) && !TypeUtils.AreReferenceAssignable(returnLabel.Type, type))
				{
					throw System.Linq.Expressions.Error.BinderNotCompatibleWithCallSite(type, this, returnLabel.Type);
				}
			}
			else
			{
				type = returnLabel.Type;
			}
			DynamicMetaObject dynamicMetaObject = DynamicMetaObject.Create(args[0], parameters[0]);
			DynamicMetaObject[] args2 = CreateArgumentMetaObjects(args, parameters);
			DynamicMetaObject obj = Bind(dynamicMetaObject, args2) ?? throw System.Linq.Expressions.Error.BindingCannotBeNull();
			Expression expression = obj.Expression;
			BindingRestrictions restrictions = obj.Restrictions;
			if (type != typeof(void) && !TypeUtils.AreReferenceAssignable(type, expression.Type))
			{
				if (dynamicMetaObject.Value is IDynamicMetaObjectProvider)
				{
					throw System.Linq.Expressions.Error.DynamicObjectResultNotAssignable(expression.Type, dynamicMetaObject.Value.GetType(), this, type);
				}
				throw System.Linq.Expressions.Error.DynamicBinderResultNotAssignable(expression.Type, this, type);
			}
			if (IsStandardBinder && args[0] is IDynamicMetaObjectProvider && restrictions == BindingRestrictions.Empty)
			{
				throw System.Linq.Expressions.Error.DynamicBindingNeedsRestrictions(dynamicMetaObject.Value.GetType(), this);
			}
			if (expression.NodeType != ExpressionType.Goto)
			{
				expression = Expression.Return(returnLabel, expression);
			}
			if (restrictions != BindingRestrictions.Empty)
			{
				expression = Expression.IfThen(restrictions.ToExpression(), expression);
			}
			return expression;
		}

		private static DynamicMetaObject[] CreateArgumentMetaObjects(object[] args, ReadOnlyCollection<ParameterExpression> parameters)
		{
			DynamicMetaObject[] array;
			if (args.Length != 1)
			{
				array = new DynamicMetaObject[args.Length - 1];
				for (int i = 1; i < args.Length; i++)
				{
					array[i - 1] = DynamicMetaObject.Create(args[i], parameters[i]);
				}
			}
			else
			{
				array = DynamicMetaObject.EmptyMetaObjects;
			}
			return array;
		}

		/// <summary>When overridden in the derived class, performs the binding of the dynamic operation.</summary>
		/// <param name="target">The target of the dynamic operation.</param>
		/// <param name="args">An array of arguments of the dynamic operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public abstract DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);

		/// <summary>Gets an expression that will cause the binding to be updated. It indicates that the expression's binding is no longer valid. This is typically used when the "version" of a dynamic object has changed.</summary>
		/// <param name="type">The <see cref="P:System.Linq.Expressions.Expression.Type" /> property of the resulting expression; any type is allowed.</param>
		/// <returns>The update expression.</returns>
		public Expression GetUpdateExpression(Type type)
		{
			return Expression.Goto(CallSiteBinder.UpdateLabel, type);
		}

		/// <summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
		/// <param name="target">The target of the dynamic operation.</param>
		/// <param name="args">An array of arguments of the dynamic operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public DynamicMetaObject Defer(DynamicMetaObject target, params DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(target, "target");
			if (args == null)
			{
				return MakeDeferred(target.Restrictions, target);
			}
			return MakeDeferred(target.Restrictions.Merge(BindingRestrictions.Combine(args)), args.AddFirst(target));
		}

		/// <summary>Defers the binding of the operation until later time when the runtime values of all dynamic operation arguments have been computed.</summary>
		/// <param name="args">An array of arguments of the dynamic operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public DynamicMetaObject Defer(params DynamicMetaObject[] args)
		{
			return MakeDeferred(BindingRestrictions.Combine(args), args);
		}

		private DynamicMetaObject MakeDeferred(BindingRestrictions rs, params DynamicMetaObject[] args)
		{
			Expression[] expressions = DynamicMetaObject.GetExpressions(args);
			Type delegateType = DelegateHelpers.MakeDeferredSiteDelegate(args, ReturnType);
			return new DynamicMetaObject(DynamicExpression.Make(ReturnType, delegateType, this, new TrueReadOnlyCollection<Expression>(expressions)), rs);
		}
	}
	/// <summary>Provides a base class for specifying dynamic behavior at run time. This class must be inherited from; you cannot instantiate it directly.</summary>
	[Serializable]
	public class DynamicObject : IDynamicMetaObjectProvider
	{
		private sealed class MetaDynamic : DynamicMetaObject
		{
			private delegate DynamicMetaObject Fallback<TBinder>(MetaDynamic @this, TBinder binder, DynamicMetaObject errorSuggestion);

			private sealed class GetBinderAdapter : GetMemberBinder
			{
				internal GetBinderAdapter(InvokeMemberBinder binder)
					: base(binder.Name, binder.IgnoreCase)
				{
				}

				public override DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion)
				{
					throw new NotSupportedException();
				}
			}

			private static readonly Expression[] s_noArgs = new Expression[0];

			private new DynamicObject Value => (DynamicObject)base.Value;

			internal MetaDynamic(Expression expression, DynamicObject value)
				: base(expression, BindingRestrictions.Empty, value)
			{
			}

			public override IEnumerable<string> GetDynamicMemberNames()
			{
				return Value.GetDynamicMemberNames();
			}

			public override DynamicMetaObject BindGetMember(GetMemberBinder binder)
			{
				if (IsOverridden(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryGetMember))
				{
					return CallMethodWithResult(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryGetMember, binder, s_noArgs, (MetaDynamic @this, GetMemberBinder b, DynamicMetaObject e) => b.FallbackGetMember(@this, e));
				}
				return base.BindGetMember(binder);
			}

			public override DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value)
			{
				if (IsOverridden(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TrySetMember))
				{
					DynamicMetaObject localValue = value;
					return CallMethodReturnLast(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TrySetMember, binder, s_noArgs, value.Expression, (MetaDynamic @this, SetMemberBinder b, DynamicMetaObject e) => b.FallbackSetMember(@this, localValue, e));
				}
				return base.BindSetMember(binder, value);
			}

			public override DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder)
			{
				if (IsOverridden(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryDeleteMember))
				{
					return CallMethodNoResult(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryDeleteMember, binder, s_noArgs, (MetaDynamic @this, DeleteMemberBinder b, DynamicMetaObject e) => b.FallbackDeleteMember(@this, e));
				}
				return base.BindDeleteMember(binder);
			}

			public override DynamicMetaObject BindConvert(ConvertBinder binder)
			{
				if (IsOverridden(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryConvert))
				{
					return CallMethodWithResult(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryConvert, binder, s_noArgs, (MetaDynamic @this, ConvertBinder b, DynamicMetaObject e) => b.FallbackConvert(@this, e));
				}
				return base.BindConvert(binder);
			}

			public override DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args)
			{
				DynamicMetaObject errorSuggestion = BuildCallMethodWithResult(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryInvokeMember, binder, DynamicMetaObject.GetExpressions(args), BuildCallMethodWithResult(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryGetMember, new GetBinderAdapter(binder), s_noArgs, binder.FallbackInvokeMember(this, args, null), (MetaDynamic @this, GetMemberBinder ignored, DynamicMetaObject e) => binder.FallbackInvoke(e, args, null)), null);
				return binder.FallbackInvokeMember(this, args, errorSuggestion);
			}

			public override DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args)
			{
				if (IsOverridden(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryCreateInstance))
				{
					DynamicMetaObject[] localArgs = args;
					return CallMethodWithResult(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryCreateInstance, binder, DynamicMetaObject.GetExpressions(args), (MetaDynamic @this, CreateInstanceBinder b, DynamicMetaObject e) => b.FallbackCreateInstance(@this, localArgs, e));
				}
				return base.BindCreateInstance(binder, args);
			}

			public override DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args)
			{
				if (IsOverridden(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryInvoke))
				{
					DynamicMetaObject[] localArgs = args;
					return CallMethodWithResult(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryInvoke, binder, DynamicMetaObject.GetExpressions(args), (MetaDynamic @this, InvokeBinder b, DynamicMetaObject e) => b.FallbackInvoke(@this, localArgs, e));
				}
				return base.BindInvoke(binder, args);
			}

			public override DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg)
			{
				if (IsOverridden(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryBinaryOperation))
				{
					DynamicMetaObject localArg = arg;
					return CallMethodWithResult(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryBinaryOperation, binder, new Expression[1] { arg.Expression }, (MetaDynamic @this, BinaryOperationBinder b, DynamicMetaObject e) => b.FallbackBinaryOperation(@this, localArg, e));
				}
				return base.BindBinaryOperation(binder, arg);
			}

			public override DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder)
			{
				if (IsOverridden(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryUnaryOperation))
				{
					return CallMethodWithResult(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryUnaryOperation, binder, s_noArgs, (MetaDynamic @this, UnaryOperationBinder b, DynamicMetaObject e) => b.FallbackUnaryOperation(@this, e));
				}
				return base.BindUnaryOperation(binder);
			}

			public override DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes)
			{
				if (IsOverridden(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryGetIndex))
				{
					DynamicMetaObject[] localIndexes = indexes;
					return CallMethodWithResult(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryGetIndex, binder, DynamicMetaObject.GetExpressions(indexes), (MetaDynamic @this, GetIndexBinder b, DynamicMetaObject e) => b.FallbackGetIndex(@this, localIndexes, e));
				}
				return base.BindGetIndex(binder, indexes);
			}

			public override DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value)
			{
				if (IsOverridden(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TrySetIndex))
				{
					DynamicMetaObject[] localIndexes = indexes;
					DynamicMetaObject localValue = value;
					return CallMethodReturnLast(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TrySetIndex, binder, DynamicMetaObject.GetExpressions(indexes), value.Expression, (MetaDynamic @this, SetIndexBinder b, DynamicMetaObject e) => b.FallbackSetIndex(@this, localIndexes, localValue, e));
				}
				return base.BindSetIndex(binder, indexes, value);
			}

			public override DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes)
			{
				if (IsOverridden(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryDeleteIndex))
				{
					DynamicMetaObject[] localIndexes = indexes;
					return CallMethodNoResult(System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryDeleteIndex, binder, DynamicMetaObject.GetExpressions(indexes), (MetaDynamic @this, DeleteIndexBinder b, DynamicMetaObject e) => b.FallbackDeleteIndex(@this, localIndexes, e));
				}
				return base.BindDeleteIndex(binder, indexes);
			}

			private static ReadOnlyCollection<Expression> GetConvertedArgs(params Expression[] args)
			{
				Expression[] array = new Expression[args.Length];
				for (int i = 0; i < args.Length; i++)
				{
					array[i] = Expression.Convert(args[i], typeof(object));
				}
				return new TrueReadOnlyCollection<Expression>(array);
			}

			private static Expression ReferenceArgAssign(Expression callArgs, Expression[] args)
			{
				ReadOnlyCollectionBuilder<Expression> readOnlyCollectionBuilder = null;
				for (int i = 0; i < args.Length; i++)
				{
					ParameterExpression parameterExpression = args[i] as ParameterExpression;
					ContractUtils.Requires(parameterExpression != null, "args");
					if (parameterExpression.IsByRef)
					{
						if (readOnlyCollectionBuilder == null)
						{
							readOnlyCollectionBuilder = new ReadOnlyCollectionBuilder<Expression>();
						}
						readOnlyCollectionBuilder.Add(Expression.Assign(parameterExpression, Expression.Convert(Expression.ArrayIndex(callArgs, System.Linq.Expressions.Utils.Constant(i)), parameterExpression.Type)));
					}
				}
				if (readOnlyCollectionBuilder != null)
				{
					return Expression.Block(readOnlyCollectionBuilder);
				}
				return System.Linq.Expressions.Utils.Empty;
			}

			private static Expression[] BuildCallArgs<TBinder>(TBinder binder, Expression[] parameters, Expression arg0, Expression arg1) where TBinder : DynamicMetaObjectBinder
			{
				if (parameters != s_noArgs)
				{
					if (arg1 != null)
					{
						return new Expression[3]
						{
							Constant(binder),
							arg0,
							arg1
						};
					}
					return new Expression[2]
					{
						Constant(binder),
						arg0
					};
				}
				if (arg1 != null)
				{
					return new Expression[2]
					{
						Constant(binder),
						arg1
					};
				}
				return new Expression[1] { Constant(binder) };
			}

			private static ConstantExpression Constant<TBinder>(TBinder binder)
			{
				return Expression.Constant(binder, typeof(TBinder));
			}

			private DynamicMetaObject CallMethodWithResult<TBinder>(MethodInfo method, TBinder binder, Expression[] args, Fallback<TBinder> fallback) where TBinder : DynamicMetaObjectBinder
			{
				return CallMethodWithResult(method, binder, args, fallback, null);
			}

			private DynamicMetaObject CallMethodWithResult<TBinder>(MethodInfo method, TBinder binder, Expression[] args, Fallback<TBinder> fallback, Fallback<TBinder> fallbackInvoke) where TBinder : DynamicMetaObjectBinder
			{
				DynamicMetaObject fallbackResult = fallback(this, binder, null);
				DynamicMetaObject errorSuggestion = BuildCallMethodWithResult(method, binder, args, fallbackResult, fallbackInvoke);
				return fallback(this, binder, errorSuggestion);
			}

			private DynamicMetaObject BuildCallMethodWithResult<TBinder>(MethodInfo method, TBinder binder, Expression[] args, DynamicMetaObject fallbackResult, Fallback<TBinder> fallbackInvoke) where TBinder : DynamicMetaObjectBinder
			{
				if (!IsOverridden(method))
				{
					return fallbackResult;
				}
				ParameterExpression parameterExpression = Expression.Parameter(typeof(object), null);
				ParameterExpression parameterExpression2 = ((method != System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryBinaryOperation) ? Expression.Parameter(typeof(object[]), null) : Expression.Parameter(typeof(object), null));
				ReadOnlyCollection<Expression> convertedArgs = GetConvertedArgs(args);
				DynamicMetaObject dynamicMetaObject = new DynamicMetaObject(parameterExpression, BindingRestrictions.Empty);
				if (binder.ReturnType != typeof(object))
				{
					UnaryExpression ifTrue = Expression.Convert(dynamicMetaObject.Expression, binder.ReturnType);
					string value = System.Linq.Expressions.Strings.DynamicObjectResultNotAssignable("{0}", Value.GetType(), binder.GetType(), binder.ReturnType);
					Expression test = ((!binder.ReturnType.IsValueType || !(Nullable.GetUnderlyingType(binder.ReturnType) == null)) ? ((Expression)Expression.OrElse(Expression.Equal(dynamicMetaObject.Expression, System.Linq.Expressions.Utils.Null), Expression.TypeIs(dynamicMetaObject.Expression, binder.ReturnType))) : ((Expression)Expression.TypeIs(dynamicMetaObject.Expression, binder.ReturnType)));
					dynamicMetaObject = new DynamicMetaObject(Expression.Condition(test, ifTrue, Expression.Throw(Expression.New(System.Linq.Expressions.CachedReflectionInfo.InvalidCastException_Ctor_String, new TrueReadOnlyCollection<Expression>(Expression.Call(System.Linq.Expressions.CachedReflectionInfo.String_Format_String_ObjectArray, Expression.Constant(value), Expression.NewArrayInit(typeof(object), new TrueReadOnlyCollection<Expression>(Expression.Condition(Expression.Equal(dynamicMetaObject.Expression, System.Linq.Expressions.Utils.Null), Expression.Constant("null"), Expression.Call(dynamicMetaObject.Expression, System.Linq.Expressions.CachedReflectionInfo.Object_GetType), typeof(object))))))), binder.ReturnType), binder.ReturnType), dynamicMetaObject.Restrictions);
				}
				if (fallbackInvoke != null)
				{
					dynamicMetaObject = fallbackInvoke(this, binder, dynamicMetaObject);
				}
				return new DynamicMetaObject(Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(parameterExpression, parameterExpression2), new TrueReadOnlyCollection<Expression>((method != System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryBinaryOperation) ? Expression.Assign(parameterExpression2, Expression.NewArrayInit(typeof(object), convertedArgs)) : Expression.Assign(parameterExpression2, convertedArgs[0]), Expression.Condition(Expression.Call(GetLimitedSelf(), method, BuildCallArgs(binder, args, parameterExpression2, parameterExpression)), Expression.Block((method != System.Linq.Expressions.CachedReflectionInfo.DynamicObject_TryBinaryOperation) ? ReferenceArgAssign(parameterExpression2, args) : System.Linq.Expressions.Utils.Empty, dynamicMetaObject.Expression), fallbackResult.Expression, binder.ReturnType))), GetRestrictions().Merge(dynamicMetaObject.Restrictions).Merge(fallbackResult.Restrictions));
			}

			private DynamicMetaObject CallMethodReturnLast<TBinder>(MethodInfo method, TBinder binder, Expression[] args, Expression value, Fallback<TBinder> fallback) where TBinder : DynamicMetaObjectBinder
			{
				DynamicMetaObject dynamicMetaObject = fallback(this, binder, null);
				ParameterExpression parameterExpression = Expression.Parameter(typeof(object), null);
				ParameterExpression parameterExpression2 = Expression.Parameter(typeof(object[]), null);
				ReadOnlyCollection<Expression> convertedArgs = GetConvertedArgs(args);
				DynamicMetaObject errorSuggestion = new DynamicMetaObject(Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(parameterExpression, parameterExpression2), new TrueReadOnlyCollection<Expression>(Expression.Assign(parameterExpression2, Expression.NewArrayInit(typeof(object), convertedArgs)), Expression.Condition(Expression.Call(GetLimitedSelf(), method, BuildCallArgs(binder, args, parameterExpression2, Expression.Assign(parameterExpression, Expression.Convert(value, typeof(object))))), Expression.Block(ReferenceArgAssign(parameterExpression2, args), parameterExpression), dynamicMetaObject.Expression, typeof(object)))), GetRestrictions().Merge(dynamicMetaObject.Restrictions));
				return fallback(this, binder, errorSuggestion);
			}

			private DynamicMetaObject CallMethodNoResult<TBinder>(MethodInfo method, TBinder binder, Expression[] args, Fallback<TBinder> fallback) where TBinder : DynamicMetaObjectBinder
			{
				DynamicMetaObject dynamicMetaObject = fallback(this, binder, null);
				ParameterExpression parameterExpression = Expression.Parameter(typeof(object[]), null);
				ReadOnlyCollection<Expression> convertedArgs = GetConvertedArgs(args);
				DynamicMetaObject errorSuggestion = new DynamicMetaObject(Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(parameterExpression), new TrueReadOnlyCollection<Expression>(Expression.Assign(parameterExpression, Expression.NewArrayInit(typeof(object), convertedArgs)), Expression.Condition(Expression.Call(GetLimitedSelf(), method, BuildCallArgs(binder, args, parameterExpression, null)), Expression.Block(ReferenceArgAssign(parameterExpression, args), System.Linq.Expressions.Utils.Empty), dynamicMetaObject.Expression, typeof(void)))), GetRestrictions().Merge(dynamicMetaObject.Restrictions));
				return fallback(this, binder, errorSuggestion);
			}

			private bool IsOverridden(MethodInfo method)
			{
				MemberInfo[] member = Value.GetType().GetMember(method.Name, MemberTypes.Method, BindingFlags.Instance | BindingFlags.Public);
				for (int i = 0; i < member.Length; i++)
				{
					MethodInfo methodInfo = (MethodInfo)member[i];
					if (methodInfo.DeclaringType != typeof(DynamicObject) && methodInfo.GetBaseDefinition() == method)
					{
						return true;
					}
				}
				return false;
			}

			private BindingRestrictions GetRestrictions()
			{
				return BindingRestrictions.GetTypeRestriction(this);
			}

			private Expression GetLimitedSelf()
			{
				if (TypeUtils.AreEquivalent(base.Expression.Type, typeof(DynamicObject)))
				{
					return base.Expression;
				}
				return Expression.Convert(base.Expression, typeof(DynamicObject));
			}
		}

		/// <summary>Enables derived types to initialize a new instance of the <see cref="T:System.Dynamic.DynamicObject" /> type.</summary>
		protected DynamicObject()
		{
		}

		/// <summary>Provides the implementation for operations that get member values. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations such as getting a value for a property.</summary>
		/// <param name="binder">Provides information about the object that called the dynamic operation. The binder.Name property provides the name of the member on which the dynamic operation is performed. For example, for the Console.WriteLine(sampleObject.SampleProperty) statement, where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, binder.Name returns "SampleProperty". The binder.IgnoreCase property specifies whether the member name is case-sensitive.</param>
		/// <param name="result">The result of the get operation. For example, if the method is called for a property, you can assign the property value to <paramref name="result" />.</param>
		/// <returns>
		///     <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a run-time exception is thrown.)</returns>
		public virtual bool TryGetMember(GetMemberBinder binder, out object result)
		{
			result = null;
			return false;
		}

		/// <summary>Provides the implementation for operations that set member values. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations such as setting a value for a property.</summary>
		/// <param name="binder">Provides information about the object that called the dynamic operation. The binder.Name property provides the name of the member to which the value is being assigned. For example, for the statement sampleObject.SampleProperty = "Test", where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, binder.Name returns "SampleProperty". The binder.IgnoreCase property specifies whether the member name is case-sensitive.</param>
		/// <param name="value">The value to set to the member. For example, for sampleObject.SampleProperty = "Test", where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, the <paramref name="value" /> is "Test".</param>
		/// <returns>
		///     <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
		public virtual bool TrySetMember(SetMemberBinder binder, object value)
		{
			return false;
		}

		/// <summary>Provides the implementation for operations that delete an object member. This method is not intended for use in C# or Visual Basic.</summary>
		/// <param name="binder">Provides information about the deletion.</param>
		/// <returns>
		///     <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
		public virtual bool TryDeleteMember(DeleteMemberBinder binder)
		{
			return false;
		}

		/// <summary>Provides the implementation for operations that invoke a member. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations such as calling a method.</summary>
		/// <param name="binder">Provides information about the dynamic operation. The binder.Name property provides the name of the member on which the dynamic operation is performed. For example, for the statement sampleObject.SampleMethod(100), where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, binder.Name returns "SampleMethod". The binder.IgnoreCase property specifies whether the member name is case-sensitive.</param>
		/// <param name="args">The arguments that are passed to the object member during the invoke operation. For example, for the statement sampleObject.SampleMethod(100), where sampleObject is derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <paramref name="args[0]" /> is equal to 100.</param>
		/// <param name="result">The result of the member invocation.</param>
		/// <returns>
		///     <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
		public virtual bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)
		{
			result = null;
			return false;
		}

		/// <summary>Provides implementation for type conversion operations. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations that convert an object from one type to another.</summary>
		/// <param name="binder">Provides information about the conversion operation. The binder.Type property provides the type to which the object must be converted. For example, for the statement (String)sampleObject in C# (CType(sampleObject, Type) in Visual Basic), where sampleObject is an instance of the class derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, binder.Type returns the <see cref="T:System.String" /> type. The binder.Explicit property provides information about the kind of conversion that occurs. It returns <see langword="true" /> for explicit conversion and <see langword="false" /> for implicit conversion.</param>
		/// <param name="result">The result of the type conversion operation.</param>
		/// <returns>
		///     <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
		public virtual bool TryConvert(ConvertBinder binder, out object result)
		{
			result = null;
			return false;
		}

		/// <summary>Provides the implementation for operations that initialize a new instance of a dynamic object. This method is not intended for use in C# or Visual Basic.</summary>
		/// <param name="binder">Provides information about the initialization operation.</param>
		/// <param name="args">The arguments that are passed to the object during initialization. For example, for the new SampleType(100) operation, where SampleType is the type derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <paramref name="args[0]" /> is equal to 100.</param>
		/// <param name="result">The result of the initialization.</param>
		/// <returns>
		///     <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
		public virtual bool TryCreateInstance(CreateInstanceBinder binder, object[] args, out object result)
		{
			result = null;
			return false;
		}

		/// <summary>Provides the implementation for operations that invoke an object. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations such as invoking an object or a delegate.</summary>
		/// <param name="binder">Provides information about the invoke operation.</param>
		/// <param name="args">The arguments that are passed to the object during the invoke operation. For example, for the sampleObject(100) operation, where sampleObject is derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <paramref name="args[0]" /> is equal to 100.</param>
		/// <param name="result">The result of the object invocation.</param>
		/// <returns>
		///     <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.</returns>
		public virtual bool TryInvoke(InvokeBinder binder, object[] args, out object result)
		{
			result = null;
			return false;
		}

		/// <summary>Provides implementation for binary operations. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations such as addition and multiplication.</summary>
		/// <param name="binder">Provides information about the binary operation. The binder.Operation property returns an <see cref="T:System.Linq.Expressions.ExpressionType" /> object. For example, for the sum = first + second statement, where first and second are derived from the <see langword="DynamicObject" /> class, binder.Operation returns ExpressionType.Add.</param>
		/// <param name="arg">The right operand for the binary operation. For example, for the sum = first + second statement, where first and second are derived from the <see langword="DynamicObject" /> class, <paramref name="arg" /> is equal to second.</param>
		/// <param name="result">The result of the binary operation.</param>
		/// <returns>
		///     <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
		public virtual bool TryBinaryOperation(BinaryOperationBinder binder, object arg, out object result)
		{
			result = null;
			return false;
		}

		/// <summary>Provides implementation for unary operations. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations such as negation, increment, or decrement.</summary>
		/// <param name="binder">Provides information about the unary operation. The binder.Operation property returns an <see cref="T:System.Linq.Expressions.ExpressionType" /> object. For example, for the negativeNumber = -number statement, where number is derived from the <see langword="DynamicObject" /> class, binder.Operation returns "Negate".</param>
		/// <param name="result">The result of the unary operation.</param>
		/// <returns>
		///     <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
		public virtual bool TryUnaryOperation(UnaryOperationBinder binder, out object result)
		{
			result = null;
			return false;
		}

		/// <summary>Provides the implementation for operations that get a value by index. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for indexing operations.</summary>
		/// <param name="binder">Provides information about the operation. </param>
		/// <param name="indexes">The indexes that are used in the operation. For example, for the sampleObject[3] operation in C# (sampleObject(3) in Visual Basic), where sampleObject is derived from the <see langword="DynamicObject" /> class, <paramref name="indexes[0]" /> is equal to 3.</param>
		/// <param name="result">The result of the index operation.</param>
		/// <returns>
		///     <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a run-time exception is thrown.)</returns>
		public virtual bool TryGetIndex(GetIndexBinder binder, object[] indexes, out object result)
		{
			result = null;
			return false;
		}

		/// <summary>Provides the implementation for operations that set a value by index. Classes derived from the <see cref="T:System.Dynamic.DynamicObject" /> class can override this method to specify dynamic behavior for operations that access objects by a specified index.</summary>
		/// <param name="binder">Provides information about the operation. </param>
		/// <param name="indexes">The indexes that are used in the operation. For example, for the sampleObject[3] = 10 operation in C# (sampleObject(3) = 10 in Visual Basic), where sampleObject is derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <paramref name="indexes[0]" /> is equal to 3.</param>
		/// <param name="value">The value to set to the object that has the specified index. For example, for the sampleObject[3] = 10 operation in C# (sampleObject(3) = 10 in Visual Basic), where sampleObject is derived from the <see cref="T:System.Dynamic.DynamicObject" /> class, <paramref name="value" /> is equal to 10.</param>
		/// <returns>
		///     <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.</returns>
		public virtual bool TrySetIndex(SetIndexBinder binder, object[] indexes, object value)
		{
			return false;
		}

		/// <summary>Provides the implementation for operations that delete an object by index. This method is not intended for use in C# or Visual Basic.</summary>
		/// <param name="binder">Provides information about the deletion.</param>
		/// <param name="indexes">The indexes to be deleted.</param>
		/// <returns>
		///     <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />. If this method returns <see langword="false" />, the run-time binder of the language determines the behavior. (In most cases, a language-specific run-time exception is thrown.)</returns>
		public virtual bool TryDeleteIndex(DeleteIndexBinder binder, object[] indexes)
		{
			return false;
		}

		/// <summary>Returns the enumeration of all dynamic member names. </summary>
		/// <returns>A sequence that contains dynamic member names.</returns>
		public virtual IEnumerable<string> GetDynamicMemberNames()
		{
			return Array.Empty<string>();
		}

		/// <summary>Provides a <see cref="T:System.Dynamic.DynamicMetaObject" /> that dispatches to the dynamic virtual methods. The object can be encapsulated inside another <see cref="T:System.Dynamic.DynamicMetaObject" /> to provide custom behavior for individual actions. This method supports the Dynamic Language Runtime infrastructure for language implementers and it is not intended to be used directly from your code.</summary>
		/// <param name="parameter">The expression that represents <see cref="T:System.Dynamic.DynamicMetaObject" /> to dispatch to the dynamic virtual methods.</param>
		/// <returns>An object of the <see cref="T:System.Dynamic.DynamicMetaObject" /> type.</returns>
		public virtual DynamicMetaObject GetMetaObject(Expression parameter)
		{
			return new MetaDynamic(parameter, this);
		}
	}
	internal class ExpandoClass
	{
		private readonly string[] _keys;

		private readonly int _hashCode;

		private Dictionary<int, List<WeakReference>> _transitions;

		private const int EmptyHashCode = 6551;

		internal static readonly ExpandoClass Empty = new ExpandoClass();

		internal string[] Keys => _keys;

		internal ExpandoClass()
		{
			_hashCode = 6551;
			_keys = Array.Empty<string>();
		}

		internal ExpandoClass(string[] keys, int hashCode)
		{
			_hashCode = hashCode;
			_keys = keys;
		}

		internal ExpandoClass FindNewClass(string newKey)
		{
			int hashCode = _hashCode ^ newKey.GetHashCode();
			lock (this)
			{
				List<WeakReference> transitionList = GetTransitionList(hashCode);
				for (int i = 0; i < transitionList.Count; i++)
				{
					if (!(transitionList[i].Target is ExpandoClass expandoClass))
					{
						transitionList.RemoveAt(i);
						i--;
					}
					else if (string.Equals(expandoClass._keys[expandoClass._keys.Length - 1], newKey, StringComparison.Ordinal))
					{
						return expandoClass;
					}
				}
				string[] array = new string[_keys.Length + 1];
				Array.Copy(_keys, 0, array, 0, _keys.Length);
				array[_keys.Length] = newKey;
				ExpandoClass expandoClass2 = new ExpandoClass(array, hashCode);
				transitionList.Add(new WeakReference(expandoClass2));
				return expandoClass2;
			}
		}

		private List<WeakReference> GetTransitionList(int hashCode)
		{
			if (_transitions == null)
			{
				_transitions = new Dictionary<int, List<WeakReference>>();
			}
			if (!_transitions.TryGetValue(hashCode, out var value))
			{
				value = (_transitions[hashCode] = new List<WeakReference>());
			}
			return value;
		}

		internal int GetValueIndex(string name, bool caseInsensitive, ExpandoObject obj)
		{
			if (caseInsensitive)
			{
				return GetValueIndexCaseInsensitive(name, obj);
			}
			return GetValueIndexCaseSensitive(name);
		}

		internal int GetValueIndexCaseSensitive(string name)
		{
			for (int i = 0; i < _keys.Length; i++)
			{
				if (string.Equals(_keys[i], name, StringComparison.Ordinal))
				{
					return i;
				}
			}
			return -1;
		}

		private int GetValueIndexCaseInsensitive(string name, ExpandoObject obj)
		{
			int num = -1;
			lock (obj.LockObject)
			{
				for (int num2 = _keys.Length - 1; num2 >= 0; num2--)
				{
					if (string.Equals(_keys[num2], name, StringComparison.OrdinalIgnoreCase) && !obj.IsDeletedMember(num2))
					{
						if (num != -1)
						{
							return -2;
						}
						num = num2;
					}
				}
				return num;
			}
		}
	}
	/// <summary>Represents an object whose members can be dynamically added and removed at run time.</summary>
	public sealed class ExpandoObject : IDynamicMetaObjectProvider, IDictionary<string, object>, ICollection<KeyValuePair<string, object>>, IEnumerable<KeyValuePair<string, object>>, IEnumerable, INotifyPropertyChanged
	{
		private sealed class KeyCollectionDebugView
		{
			private readonly ICollection<string> _collection;

			[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
			public string[] Items
			{
				get
				{
					string[] array = new string[_collection.Count];
					_collection.CopyTo(array, 0);
					return array;
				}
			}

			public KeyCollectionDebugView(ICollection<string> collection)
			{
				ContractUtils.RequiresNotNull(collection, "collection");
				_collection = collection;
			}
		}

		[DebuggerTypeProxy(typeof(KeyCollectionDebugView))]
		[DebuggerDisplay("Count = {Count}")]
		private class KeyCollection : ICollection<string>, IEnumerable<string>, IEnumerable
		{
			private readonly ExpandoObject _expando;

			private readonly int _expandoVersion;

			private readonly int _expandoCount;

			private readonly ExpandoData _expandoData;

			public int Count
			{
				get
				{
					CheckVersion();
					return _expandoCount;
				}
			}

			public bool IsReadOnly => true;

			internal KeyCollection(ExpandoObject expando)
			{
				lock (expando.LockObject)
				{
					_expando = expando;
					_expandoVersion = expando._data.Version;
					_expandoCount = expando._count;
					_expandoData = expando._data;
				}
			}

			private void CheckVersion()
			{
				if (_expando._data.Version != _expandoVersion || _expandoData != _expando._data)
				{
					throw System.Linq.Expressions.Error.CollectionModifiedWhileEnumerating();
				}
			}

			public void Add(string item)
			{
				throw System.Linq.Expressions.Error.CollectionReadOnly();
			}

			public void Clear()
			{
				throw System.Linq.Expressions.Error.CollectionReadOnly();
			}

			public bool Contains(string item)
			{
				lock (_expando.LockObject)
				{
					CheckVersion();
					return _expando.ExpandoContainsKey(item);
				}
			}

			public void CopyTo(string[] array, int arrayIndex)
			{
				ContractUtils.RequiresNotNull(array, "array");
				ContractUtils.RequiresArrayRange(array, arrayIndex, _expandoCount, "arrayIndex", "Count");
				lock (_expando.LockObject)
				{
					CheckVersion();
					ExpandoData data = _expando._data;
					for (int i = 0; i < data.Class.Keys.Length; i++)
					{
						if (data[i] != Uninitialized)
						{
							array[arrayIndex++] = data.Class.Keys[i];
						}
					}
				}
			}

			public bool Remove(string item)
			{
				throw System.Linq.Expressions.Error.CollectionReadOnly();
			}

			public IEnumerator<string> GetEnumerator()
			{
				int i = 0;
				for (int n = _expandoData.Class.Keys.Length; i < n; i++)
				{
					CheckVersion();
					if (_expandoData[i] != Uninitialized)
					{
						yield return _expandoData.Class.Keys[i];
					}
				}
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		private sealed class ValueCollectionDebugView
		{
			private readonly ICollection<object> _collection;

			[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
			public object[] Items
			{
				get
				{
					object[] array = new object[_collection.Count];
					_collection.CopyTo(array, 0);
					return array;
				}
			}

			public ValueCollectionDebugView(ICollection<object> collection)
			{
				ContractUtils.RequiresNotNull(collection, "collection");
				_collection = collection;
			}
		}

		[DebuggerTypeProxy(typeof(ValueCollectionDebugView))]
		[DebuggerDisplay("Count = {Count}")]
		private class ValueCollection : ICollection<object>, IEnumerable<object>, IEnumerable
		{
			private readonly ExpandoObject _expando;

			private readonly int _expandoVersion;

			private readonly int _expandoCount;

			private readonly ExpandoData _expandoData;

			public int Count
			{
				get
				{
					CheckVersion();
					return _expandoCount;
				}
			}

			public bool IsReadOnly => true;

			internal ValueCollection(ExpandoObject expando)
			{
				lock (expando.LockObject)
				{
					_expando = expando;
					_expandoVersion = expando._data.Version;
					_expandoCount = expando._count;
					_expandoData = expando._data;
				}
			}

			private void CheckVersion()
			{
				if (_expando._data.Version != _expandoVersion || _expandoData != _expando._data)
				{
					throw System.Linq.Expressions.Error.CollectionModifiedWhileEnumerating();
				}
			}

			public void Add(object item)
			{
				throw System.Linq.Expressions.Error.CollectionReadOnly();
			}

			public void Clear()
			{
				throw System.Linq.Expressions.Error.CollectionReadOnly();
			}

			public bool Contains(object item)
			{
				lock (_expando.LockObject)
				{
					CheckVersion();
					ExpandoData data = _expando._data;
					for (int i = 0; i < data.Class.Keys.Length; i++)
					{
						if (object.Equals(data[i], item))
						{
							return true;
						}
					}
					return false;
				}
			}

			public void CopyTo(object[] array, int arrayIndex)
			{
				ContractUtils.RequiresNotNull(array, "array");
				ContractUtils.RequiresArrayRange(array, arrayIndex, _expandoCount, "arrayIndex", "Count");
				lock (_expando.LockObject)
				{
					CheckVersion();
					ExpandoData data = _expando._data;
					for (int i = 0; i < data.Class.Keys.Length; i++)
					{
						if (data[i] != Uninitialized)
						{
							array[arrayIndex++] = data[i];
						}
					}
				}
			}

			public bool Remove(object item)
			{
				throw System.Linq.Expressions.Error.CollectionReadOnly();
			}

			public IEnumerator<object> GetEnumerator()
			{
				ExpandoData data = _expando._data;
				for (int i = 0; i < data.Class.Keys.Length; i++)
				{
					CheckVersion();
					object obj = data[i];
					if (obj != Uninitialized)
					{
						yield return obj;
					}
				}
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		private class MetaExpando : DynamicMetaObject
		{
			public new ExpandoObject Value => (ExpandoObject)base.Value;

			public MetaExpando(Expression expression, ExpandoObject value)
				: base(expression, BindingRestrictions.Empty, value)
			{
			}

			private DynamicMetaObject BindGetOrInvokeMember(DynamicMetaObjectBinder binder, string name, bool ignoreCase, DynamicMetaObject fallback, Func<DynamicMetaObject, DynamicMetaObject> fallbackInvoke)
			{
				ExpandoClass expandoClass = Value.Class;
				int valueIndex = expandoClass.GetValueIndex(name, ignoreCase, Value);
				ParameterExpression parameterExpression = Expression.Parameter(typeof(object), "value");
				Expression test = Expression.Call(s_expandoTryGetValue, GetLimitedSelf(), Expression.Constant(expandoClass, typeof(object)), System.Linq.Expressions.Utils.Constant(valueIndex), Expression.Constant(name), System.Linq.Expressions.Utils.Constant(ignoreCase), parameterExpression);
				DynamicMetaObject dynamicMetaObject = new DynamicMetaObject(parameterExpression, BindingRestrictions.Empty);
				if (fallbackInvoke != null)
				{
					dynamicMetaObject = fallbackInvoke(dynamicMetaObject);
				}
				dynamicMetaObject = new DynamicMetaObject(Expression.Block(new TrueReadOnlyCollection<ParameterExpression>(parameterExpression), new TrueReadOnlyCollection<Expression>(Expression.Condition(test, dynamicMetaObject.Expression, fallback.Expression, typeof(object)))), dynamicMetaObject.Restrictions.Merge(fallback.Restrictions));
				return AddDynamicTestAndDefer(binder, Value.Class, null, dynamicMetaObject);
			}

			public override DynamicMetaObject BindGetMember(GetMemberBinder binder)
			{
				ContractUtils.RequiresNotNull(binder, "binder");
				return BindGetOrInvokeMember(binder, binder.Name, binder.IgnoreCase, binder.FallbackGetMember(this), null);
			}

			public override DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args)
			{
				ContractUtils.RequiresNotNull(binder, "binder");
				return BindGetOrInvokeMember(binder, binder.Name, binder.IgnoreCase, binder.FallbackInvokeMember(this, args), (DynamicMetaObject value) => binder.FallbackInvoke(value, args, null));
			}

			public override DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value)
			{
				ContractUtils.RequiresNotNull(binder, "binder");
				ContractUtils.RequiresNotNull(value, "value");
				ExpandoClass klass;
				int index;
				ExpandoClass classEnsureIndex = GetClassEnsureIndex(binder.Name, binder.IgnoreCase, Value, out klass, out index);
				return AddDynamicTestAndDefer(binder, klass, classEnsureIndex, new DynamicMetaObject(Expression.Call(s_expandoTrySetValue, GetLimitedSelf(), Expression.Constant(klass, typeof(object)), System.Linq.Expressions.Utils.Constant(index), Expression.Convert(value.Expression, typeof(object)), Expression.Constant(binder.Name), System.Linq.Expressions.Utils.Constant(binder.IgnoreCase)), BindingRestrictions.Empty));
			}

			public override DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder)
			{
				ContractUtils.RequiresNotNull(binder, "binder");
				int valueIndex = Value.Class.GetValueIndex(binder.Name, binder.IgnoreCase, Value);
				MethodCallExpression expression = Expression.Call(s_expandoTryDeleteValue, GetLimitedSelf(), Expression.Constant(Value.Class, typeof(object)), System.Linq.Expressions.Utils.Constant(valueIndex), Expression.Constant(binder.Name), System.Linq.Expressions.Utils.Constant(binder.IgnoreCase));
				DynamicMetaObject dynamicMetaObject = binder.FallbackDeleteMember(this);
				DynamicMetaObject succeeds = new DynamicMetaObject(Expression.IfThen(Expression.Not(expression), dynamicMetaObject.Expression), dynamicMetaObject.Restrictions);
				return AddDynamicTestAndDefer(binder, Value.Class, null, succeeds);
			}

			public override IEnumerable<string> GetDynamicMemberNames()
			{
				ExpandoData expandoData = Value._data;
				ExpandoClass klass = expandoData.Class;
				for (int i = 0; i < klass.Keys.Length; i++)
				{
					if (expandoData[i] != Uninitialized)
					{
						yield return klass.Keys[i];
					}
				}
			}

			private DynamicMetaObject AddDynamicTestAndDefer(DynamicMetaObjectBinder binder, ExpandoClass klass, ExpandoClass originalClass, DynamicMetaObject succeeds)
			{
				Expression expression = succeeds.Expression;
				if (originalClass != null)
				{
					expression = Expression.Block(Expression.Call(null, s_expandoPromoteClass, GetLimitedSelf(), Expression.Constant(originalClass, typeof(object)), Expression.Constant(klass, typeof(object))), succeeds.Expression);
				}
				return new DynamicMetaObject(Expression.Condition(Expression.Call(null, s_expandoCheckVersion, GetLimitedSelf(), Expression.Constant(originalClass ?? klass, typeof(object))), expression, binder.GetUpdateExpression(expression.Type)), GetRestrictions().Merge(succeeds.Restrictions));
			}

			private ExpandoClass GetClassEnsureIndex(string name, bool caseInsensitive, ExpandoObject obj, out ExpandoClass klass, out int index)
			{
				ExpandoClass expandoClass = Value.Class;
				index = expandoClass.GetValueIndex(name, caseInsensitive, obj);
				if (index == -2)
				{
					klass = expandoClass;
					return null;
				}
				if (index == -1)
				{
					index = (klass = expandoClass.FindNewClass(name)).GetValueIndexCaseSensitive(name);
					return expandoClass;
				}
				klass = expandoClass;
				return null;
			}

			private Expression GetLimitedSelf()
			{
				if (TypeUtils.AreEquivalent(base.Expression.Type, base.LimitType))
				{
					return base.Expression;
				}
				return Expression.Convert(base.Expression, base.LimitType);
			}

			private BindingRestrictions GetRestrictions()
			{
				return BindingRestrictions.GetTypeRestriction(this);
			}
		}

		private class ExpandoData
		{
			internal static ExpandoData Empty = new ExpandoData();

			internal readonly ExpandoClass Class;

			private readonly object[] _dataArray;

			private int _version;

			internal object this[int index]
			{
				get
				{
					return _dataArray[index];
				}
				set
				{
					_version++;
					_dataArray[index] = value;
				}
			}

			internal int Version => _version;

			internal int Length => _dataArray.Length;

			private ExpandoData()
			{
				Class = ExpandoClass.Empty;
				_dataArray = Array.Empty<object>();
			}

			internal ExpandoData(ExpandoClass klass, object[] data, int version)
			{
				Class = klass;
				_dataArray = data;
				_version = version;
			}

			internal ExpandoData UpdateClass(ExpandoClass newClass)
			{
				if (_dataArray.Length >= newClass.Keys.Length)
				{
					this[newClass.Keys.Length - 1] = Uninitialized;
					return new ExpandoData(newClass, _dataArray, _version);
				}
				int index = _dataArray.Length;
				object[] array = new object[GetAlignedSize(newClass.Keys.Length)];
				Array.Copy(_dataArray, 0, array, 0, _dataArray.Length);
				return new ExpandoData(newClass, array, _version) { [index] = Uninitialized };
			}

			private static int GetAlignedSize(int len)
			{
				return (len + 7) & -8;
			}
		}

		private static readonly MethodInfo s_expandoTryGetValue = typeof(RuntimeOps).GetMethod("ExpandoTryGetValue");

		private static readonly MethodInfo s_expandoTrySetValue = typeof(RuntimeOps).GetMethod("ExpandoTrySetValue");

		private static readonly MethodInfo s_expandoTryDeleteValue = typeof(RuntimeOps).GetMethod("ExpandoTryDeleteValue");

		private static readonly MethodInfo s_expandoPromoteClass = typeof(RuntimeOps).GetMethod("ExpandoPromoteClass");

		private static readonly MethodInfo s_expandoCheckVersion = typeof(RuntimeOps).GetMethod("ExpandoCheckVersion");

		internal readonly object LockObject;

		private ExpandoData _data;

		private int _count;

		internal static readonly object Uninitialized = new object();

		internal const int AmbiguousMatchFound = -2;

		internal const int NoMatch = -1;

		private PropertyChangedEventHandler _propertyChanged;

		internal ExpandoClass Class => _data.Class;

		ICollection<string> IDictionary<string, object>.Keys => new KeyCollection(this);

		ICollection<object> IDictionary<string, object>.Values => new ValueCollection(this);

		object IDictionary<string, object>.this[string key]
		{
			get
			{
				if (!TryGetValueForKey(key, out var value))
				{
					throw System.Linq.Expressions.Error.KeyDoesNotExistInExpando(key);
				}
				return value;
			}
			set
			{
				ContractUtils.RequiresNotNull(key, "key");
				TrySetValue(null, -1, value, key, ignoreCase: false, add: false);
			}
		}

		int ICollection<KeyValuePair<string, object>>.Count => _count;

		bool ICollection<KeyValuePair<string, object>>.IsReadOnly => false;

		/// <summary>Occurs when a property value changes.</summary>
		event PropertyChangedEventHandler INotifyPropertyChanged.PropertyChanged
		{
			add
			{
				_propertyChanged = (PropertyChangedEventHandler)Delegate.Combine(_propertyChanged, value);
			}
			remove
			{
				_propertyChanged = (PropertyChangedEventHandler)Delegate.Remove(_propertyChanged, value);
			}
		}

		/// <summary>Initializes a new <see langword="ExpandoObject" /> that does not have members.</summary>
		public ExpandoObject()
		{
			_data = ExpandoData.Empty;
			LockObject = new object();
		}

		internal bool TryGetValue(object indexClass, int index, string name, bool ignoreCase, out object value)
		{
			ExpandoData data = _data;
			if (data.Class != indexClass || ignoreCase)
			{
				index = data.Class.GetValueIndex(name, ignoreCase, this);
				if (index == -2)
				{
					throw System.Linq.Expressions.Error.AmbiguousMatchInExpandoObject(name);
				}
			}
			if (index == -1)
			{
				value = null;
				return false;
			}
			object obj = data[index];
			if (obj == Uninitialized)
			{
				value = null;
				return false;
			}
			value = obj;
			return true;
		}

		internal void TrySetValue(object indexClass, int index, object value, string name, bool ignoreCase, bool add)
		{
			ExpandoData expandoData;
			object obj;
			lock (LockObject)
			{
				expandoData = _data;
				if (expandoData.Class != indexClass || ignoreCase)
				{
					index = expandoData.Class.GetValueIndex(name, ignoreCase, this);
					switch (index)
					{
					case -2:
						throw System.Linq.Expressions.Error.AmbiguousMatchInExpandoObject(name);
					case -1:
					{
						int num = (ignoreCase ? expandoData.Class.GetValueIndexCaseSensitive(name) : index);
						if (num != -1)
						{
							index = num;
							break;
						}
						ExpandoClass newClass = expandoData.Class.FindNewClass(name);
						expandoData = PromoteClassCore(expandoData.Class, newClass);
						index = expandoData.Class.GetValueIndexCaseSensitive(name);
						break;
					}
					}
				}
				obj = expandoData[index];
				if (obj == Uninitialized)
				{
					_count++;
				}
				else if (add)
				{
					throw System.Linq.Expressions.Error.SameKeyExistsInExpando(name);
				}
				expandoData[index] = value;
			}
			PropertyChangedEventHandler propertyChanged = _propertyChanged;
			if (propertyChanged != null && value != obj)
			{
				propertyChanged(this, new PropertyChangedEventArgs(expandoData.Class.Keys[index]));
			}
		}

		internal bool TryDeleteValue(object indexClass, int index, string name, bool ignoreCase, object deleteValue)
		{
			ExpandoData data;
			lock (LockObject)
			{
				data = _data;
				if (data.Class != indexClass || ignoreCase)
				{
					index = data.Class.GetValueIndex(name, ignoreCase, this);
					if (index == -2)
					{
						throw System.Linq.Expressions.Error.AmbiguousMatchInExpandoObject(name);
					}
				}
				if (index == -1)
				{
					return false;
				}
				object obj = data[index];
				if (obj == Uninitialized)
				{
					return false;
				}
				if (deleteValue != Uninitialized && !object.Equals(obj, deleteValue))
				{
					return false;
				}
				data[index] = Uninitialized;
				_count--;
			}
			_propertyChanged?.Invoke(this, new PropertyChangedEventArgs(data.Class.Keys[index]));
			return true;
		}

		internal bool IsDeletedMember(int index)
		{
			if (index == _data.Length)
			{
				return false;
			}
			return _data[index] == Uninitialized;
		}

		private ExpandoData PromoteClassCore(ExpandoClass oldClass, ExpandoClass newClass)
		{
			if (_data.Class == oldClass)
			{
				_data = _data.UpdateClass(newClass);
			}
			return _data;
		}

		internal void PromoteClass(object oldClass, object newClass)
		{
			lock (LockObject)
			{
				PromoteClassCore((ExpandoClass)oldClass, (ExpandoClass)newClass);
			}
		}

		/// <summary>The provided MetaObject will dispatch to the dynamic virtual methods. The object can be encapsulated inside another MetaObject to provide custom behavior for individual actions.</summary>
		/// <param name="parameter">The expression that represents the MetaObject to dispatch to the Dynamic virtual methods.</param>
		/// <returns>The object of the <see cref="T:System.Dynamic.DynamicMetaObject" /> type.</returns>
		DynamicMetaObject IDynamicMetaObjectProvider.GetMetaObject(Expression parameter)
		{
			return new MetaExpando(parameter, this);
		}

		private void TryAddMember(string key, object value)
		{
			ContractUtils.RequiresNotNull(key, "key");
			TrySetValue(null, -1, value, key, ignoreCase: false, add: true);
		}

		private bool TryGetValueForKey(string key, out object value)
		{
			return TryGetValue(null, -1, key, ignoreCase: false, out value);
		}

		private bool ExpandoContainsKey(string key)
		{
			return _data.Class.GetValueIndexCaseSensitive(key) >= 0;
		}

		void IDictionary<string, object>.Add(string key, object value)
		{
			TryAddMember(key, value);
		}

		bool IDictionary<string, object>.ContainsKey(string key)
		{
			ContractUtils.RequiresNotNull(key, "key");
			ExpandoData data = _data;
			int valueIndexCaseSensitive = data.Class.GetValueIndexCaseSensitive(key);
			if (valueIndexCaseSensitive >= 0)
			{
				return data[valueIndexCaseSensitive] != Uninitialized;
			}
			return false;
		}

		bool IDictionary<string, object>.Remove(string key)
		{
			ContractUtils.RequiresNotNull(key, "key");
			return TryDeleteValue(null, -1, key, ignoreCase: false, Uninitialized);
		}

		bool IDictionary<string, object>.TryGetValue(string key, out object value)
		{
			return TryGetValueForKey(key, out value);
		}

		void ICollection<KeyValuePair<string, object>>.Add(KeyValuePair<string, object> item)
		{
			TryAddMember(item.Key, item.Value);
		}

		void ICollection<KeyValuePair<string, object>>.Clear()
		{
			ExpandoData data;
			lock (LockObject)
			{
				data = _data;
				_data = ExpandoData.Empty;
				_count = 0;
			}
			PropertyChangedEventHandler propertyChanged = _propertyChanged;
			if (propertyChanged == null)
			{
				return;
			}
			int i = 0;
			for (int num = data.Class.Keys.Length; i < num; i++)
			{
				if (data[i] != Uninitialized)
				{
					propertyChanged(this, new PropertyChangedEventArgs(data.Class.Keys[i]));
				}
			}
		}

		bool ICollection<KeyValuePair<string, object>>.Contains(KeyValuePair<string, object> item)
		{
			if (!TryGetValueForKey(item.Key, out var value))
			{
				return false;
			}
			return object.Equals(value, item.Value);
		}

		void ICollection<KeyValuePair<string, object>>.CopyTo(KeyValuePair<string, object>[] array, int arrayIndex)
		{
			ContractUtils.RequiresNotNull(array, "array");
			lock (LockObject)
			{
				ContractUtils.RequiresArrayRange(array, arrayIndex, _count, "arrayIndex", "Count");
				foreach (KeyValuePair<string, object> item in (IEnumerable<KeyValuePair<string, object>>)this)
				{
					array[arrayIndex++] = item;
				}
			}
		}

		bool ICollection<KeyValuePair<string, object>>.Remove(KeyValuePair<string, object> item)
		{
			return TryDeleteValue(null, -1, item.Key, ignoreCase: false, item.Value);
		}

		IEnumerator<KeyValuePair<string, object>> IEnumerable<KeyValuePair<string, object>>.GetEnumerator()
		{
			ExpandoData data = _data;
			return GetExpandoEnumerator(data, data.Version);
		}

		/// <summary>Returns an enumerator that iterates through the collection.</summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator" /> that can be used to iterate through the collection.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			ExpandoData data = _data;
			return GetExpandoEnumerator(data, data.Version);
		}

		private IEnumerator<KeyValuePair<string, object>> GetExpandoEnumerator(ExpandoData data, int version)
		{
			for (int i = 0; i < data.Class.Keys.Length; i++)
			{
				if (_data.Version != version || data != _data)
				{
					throw System.Linq.Expressions.Error.CollectionModifiedWhileEnumerating();
				}
				object obj = data[i];
				if (obj != Uninitialized)
				{
					yield return new KeyValuePair<string, object>(data.Class.Keys[i], obj);
				}
			}
		}
	}
	/// <summary>Represents the dynamic get index operation at the call site, providing the binding semantic and the details about the operation.</summary>
	public abstract class GetIndexBinder : DynamicMetaObjectBinder
	{
		/// <summary>The result type of the operation.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the result type of the operation.</returns>
		public sealed override Type ReturnType => typeof(object);

		/// <summary>Gets the signature of the arguments at the call site.</summary>
		/// <returns>The signature of the arguments at the call site.</returns>
		public CallInfo CallInfo { get; }

		internal sealed override bool IsStandardBinder => true;

		/// <summary>Initializes a new instance of the <see cref="T:System.Dynamic.GetIndexBinder" />.</summary>
		/// <param name="callInfo">The signature of the arguments at the call site.</param>
		protected GetIndexBinder(CallInfo callInfo)
		{
			ContractUtils.RequiresNotNull(callInfo, "callInfo");
			CallInfo = callInfo;
		}

		/// <summary>Performs the binding of the dynamic get index operation.</summary>
		/// <param name="target">The target of the dynamic get index operation.</param>
		/// <param name="args">An array of arguments of the dynamic get index operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(target, "target");
			ContractUtils.RequiresNotNullItems(args, "args");
			return target.BindGetIndex(this, args);
		}

		/// <summary>Performs the binding of the dynamic get index operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic get index operation.</param>
		/// <param name="indexes">The arguments of the dynamic get index operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes)
		{
			return FallbackGetIndex(target, indexes, null);
		}

		/// <summary>When overridden in the derived class, performs the binding of the dynamic get index operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic get index operation.</param>
		/// <param name="indexes">The arguments of the dynamic get index operation.</param>
		/// <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public abstract DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
	}
	/// <summary>Represents the dynamic get member operation at the call site, providing the binding semantic and the details about the operation.</summary>
	public abstract class GetMemberBinder : DynamicMetaObjectBinder
	{
		/// <summary>The result type of the operation.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the result type of the operation.</returns>
		public sealed override Type ReturnType => typeof(object);

		/// <summary>Gets the name of the member to obtain.</summary>
		/// <returns>The name of the member to obtain.</returns>
		public string Name { get; }

		/// <summary>Gets the value indicating if the string comparison should ignore the case of the member name.</summary>
		/// <returns>True if the case is ignored, otherwise false.</returns>
		public bool IgnoreCase { get; }

		internal sealed override bool IsStandardBinder => true;

		/// <summary>Initializes a new instance of the <see cref="T:System.Dynamic.GetMemberBinder" />.</summary>
		/// <param name="name">The name of the member to obtain.</param>
		/// <param name="ignoreCase">Is true if the name should be matched ignoring case; false otherwise.</param>
		protected GetMemberBinder(string name, bool ignoreCase)
		{
			ContractUtils.RequiresNotNull(name, "name");
			Name = name;
			IgnoreCase = ignoreCase;
		}

		/// <summary>Performs the binding of the dynamic get member operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic get member operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public DynamicMetaObject FallbackGetMember(DynamicMetaObject target)
		{
			return FallbackGetMember(target, null);
		}

		/// <summary>When overridden in the derived class, performs the binding of the dynamic get member operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic get member operation.</param>
		/// <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public abstract DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);

		/// <summary>Performs the binding of the dynamic get member operation.</summary>
		/// <param name="target">The target of the dynamic get member operation.</param>
		/// <param name="args">An array of arguments of the dynamic get member operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(target, "target");
			ContractUtils.Requires(args == null || args.Length == 0, "args");
			return target.BindGetMember(this);
		}
	}
	/// <summary>Represents a dynamic object, that can have its operations bound at runtime.</summary>
	public interface IDynamicMetaObjectProvider
	{
		/// <summary>Returns the <see cref="T:System.Dynamic.DynamicMetaObject" /> responsible for binding operations performed on this object.</summary>
		/// <param name="parameter">The expression tree representation of the runtime value.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> to bind this object.</returns>
		DynamicMetaObject GetMetaObject(Expression parameter);
	}
	/// <summary>Represents information about a dynamic get member operation that indicates if the get member should invoke properties when they perform the get operation.</summary>
	public interface IInvokeOnGetBinder
	{
		/// <summary>Gets the value indicating if this get member operation should invoke properties when they perform the get operation. The default value when this interface is not present is true.</summary>
		/// <returns>True if this get member operation should invoke properties when they perform the get operation; otherwise false.</returns>
		bool InvokeOnGet { get; }
	}
	/// <summary>Represents the invoke dynamic operation at the call site, providing the binding semantic and the details about the operation.</summary>
	public abstract class InvokeBinder : DynamicMetaObjectBinder
	{
		/// <summary>The result type of the operation.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the result type of the operation.</returns>
		public sealed override Type ReturnType => typeof(object);

		/// <summary>Gets the signature of the arguments at the call site.</summary>
		/// <returns>The signature of the arguments at the call site.</returns>
		public CallInfo CallInfo { get; }

		internal sealed override bool IsStandardBinder => true;

		/// <summary>Initializes a new instance of the <see cref="T:System.Dynamic.InvokeBinder" />.</summary>
		/// <param name="callInfo">The signature of the arguments at the call site.</param>
		protected InvokeBinder(CallInfo callInfo)
		{
			ContractUtils.RequiresNotNull(callInfo, "callInfo");
			CallInfo = callInfo;
		}

		/// <summary>Performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic invoke operation.</param>
		/// <param name="args">The arguments of the dynamic invoke operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			return FallbackInvoke(target, args, null);
		}

		/// <summary>Performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic invoke operation.</param>
		/// <param name="args">The arguments of the dynamic invoke operation.</param>
		/// <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public abstract DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);

		/// <summary>Performs the binding of the dynamic invoke operation.</summary>
		/// <param name="target">The target of the dynamic invoke operation.</param>
		/// <param name="args">An array of arguments of the dynamic invoke operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(target, "target");
			ContractUtils.RequiresNotNullItems(args, "args");
			return target.BindInvoke(this, args);
		}
	}
	/// <summary>Represents the invoke member dynamic operation at the call site, providing the binding semantic and the details about the operation.</summary>
	public abstract class InvokeMemberBinder : DynamicMetaObjectBinder
	{
		/// <summary>The result type of the operation.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the result type of the operation.</returns>
		public sealed override Type ReturnType => typeof(object);

		/// <summary>Gets the name of the member to invoke.</summary>
		/// <returns>The name of the member to invoke.</returns>
		public string Name { get; }

		/// <summary>Gets the value indicating if the string comparison should ignore the case of the member name.</summary>
		/// <returns>True if the case is ignored, otherwise false.</returns>
		public bool IgnoreCase { get; }

		/// <summary>Gets the signature of the arguments at the call site.</summary>
		/// <returns>The signature of the arguments at the call site.</returns>
		public CallInfo CallInfo { get; }

		internal sealed override bool IsStandardBinder => true;

		/// <summary>Initializes a new instance of the <see cref="T:System.Dynamic.InvokeMemberBinder" />.</summary>
		/// <param name="name">The name of the member to invoke.</param>
		/// <param name="ignoreCase">true if the name should be matched ignoring case; false otherwise.</param>
		/// <param name="callInfo">The signature of the arguments at the call site.</param>
		protected InvokeMemberBinder(string name, bool ignoreCase, CallInfo callInfo)
		{
			ContractUtils.RequiresNotNull(name, "name");
			ContractUtils.RequiresNotNull(callInfo, "callInfo");
			Name = name;
			IgnoreCase = ignoreCase;
			CallInfo = callInfo;
		}

		/// <summary>Performs the binding of the dynamic invoke member operation.</summary>
		/// <param name="target">The target of the dynamic invoke member operation.</param>
		/// <param name="args">An array of arguments of the dynamic invoke member operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(target, "target");
			ContractUtils.RequiresNotNullItems(args, "args");
			return target.BindInvokeMember(this, args);
		}

		/// <summary>Performs the binding of the dynamic invoke member operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic invoke member operation.</param>
		/// <param name="args">The arguments of the dynamic invoke member operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			return FallbackInvokeMember(target, args, null);
		}

		/// <summary>When overridden in the derived class, performs the binding of the dynamic invoke member operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic invoke member operation.</param>
		/// <param name="args">The arguments of the dynamic invoke member operation.</param>
		/// <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public abstract DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);

		/// <summary>When overridden in the derived class, performs the binding of the dynamic invoke operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic invoke operation.</param>
		/// <param name="args">The arguments of the dynamic invoke operation.</param>
		/// <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public abstract DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
	}
	/// <summary>Represents the dynamic set index operation at the call site, providing the binding semantic and the details about the operation.</summary>
	public abstract class SetIndexBinder : DynamicMetaObjectBinder
	{
		/// <summary>The result type of the operation.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the result type of the operation.</returns>
		public sealed override Type ReturnType => typeof(object);

		/// <summary>Gets the signature of the arguments at the call site.</summary>
		/// <returns>The signature of the arguments at the call site.</returns>
		public CallInfo CallInfo { get; }

		internal sealed override bool IsStandardBinder => true;

		/// <summary>Initializes a new instance of the <see cref="T:System.Dynamic.SetIndexBinder" />.</summary>
		/// <param name="callInfo">The signature of the arguments at the call site.</param>
		protected SetIndexBinder(CallInfo callInfo)
		{
			ContractUtils.RequiresNotNull(callInfo, "callInfo");
			CallInfo = callInfo;
		}

		/// <summary>Performs the binding of the dynamic set index operation.</summary>
		/// <param name="target">The target of the dynamic set index operation.</param>
		/// <param name="args">An array of arguments of the dynamic set index operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(target, "target");
			ContractUtils.RequiresNotNull(args, "args");
			ContractUtils.Requires(args.Length >= 2, "args");
			DynamicMetaObject value = args[^1];
			DynamicMetaObject[] array = args.RemoveLast();
			ContractUtils.RequiresNotNull(value, "args");
			ContractUtils.RequiresNotNullItems(array, "args");
			return target.BindSetIndex(this, array, value);
		}

		/// <summary>Performs the binding of the dynamic set index operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic set index operation.</param>
		/// <param name="indexes">The arguments of the dynamic set index operation.</param>
		/// <param name="value">The value to set to the collection.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value)
		{
			return FallbackSetIndex(target, indexes, value, null);
		}

		/// <summary>When overridden in the derived class, performs the binding of the dynamic set index operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic set index operation.</param>
		/// <param name="indexes">The arguments of the dynamic set index operation.</param>
		/// <param name="value">The value to set to the collection.</param>
		/// <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public abstract DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
	}
	/// <summary>Represents the dynamic set member operation at the call site, providing the binding semantic and the details about the operation.</summary>
	public abstract class SetMemberBinder : DynamicMetaObjectBinder
	{
		/// <summary>The result type of the operation.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the result type of the operation.</returns>
		public sealed override Type ReturnType => typeof(object);

		/// <summary>Gets the name of the member to obtain.</summary>
		/// <returns>The name of the member to obtain.</returns>
		public string Name { get; }

		/// <summary>Gets the value indicating if the string comparison should ignore the case of the member name.</summary>
		/// <returns>True if the case is ignored, otherwise false.</returns>
		public bool IgnoreCase { get; }

		internal sealed override bool IsStandardBinder => true;

		/// <summary>Initializes a new instance of the <see cref="T:System.Dynamic.SetMemberBinder" />.</summary>
		/// <param name="name">The name of the member to obtain.</param>
		/// <param name="ignoreCase">Is true if the name should be matched ignoring case; false otherwise.</param>
		protected SetMemberBinder(string name, bool ignoreCase)
		{
			ContractUtils.RequiresNotNull(name, "name");
			Name = name;
			IgnoreCase = ignoreCase;
		}

		/// <summary>Performs the binding of the dynamic set member operation.</summary>
		/// <param name="target">The target of the dynamic set member operation.</param>
		/// <param name="args">An array of arguments of the dynamic set member operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(target, "target");
			ContractUtils.RequiresNotNull(args, "args");
			ContractUtils.Requires(args.Length == 1, "args");
			DynamicMetaObject value = args[0];
			ContractUtils.RequiresNotNull(value, "args");
			return target.BindSetMember(this, value);
		}

		/// <summary>Performs the binding of the dynamic set member operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic set member operation.</param>
		/// <param name="value">The value to set to the member.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value)
		{
			return FallbackSetMember(target, value, null);
		}

		/// <summary>Performs the binding of the dynamic set member operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic set member operation.</param>
		/// <param name="value">The value to set to the member.</param>
		/// <param name="errorSuggestion">The binding result to use if binding fails, or null.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public abstract DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
	}
	/// <summary>Represents the unary dynamic operation at the call site, providing the binding semantic and the details about the operation.</summary>
	public abstract class UnaryOperationBinder : DynamicMetaObjectBinder
	{
		/// <summary>The result type of the operation.</summary>
		/// <returns>The <see cref="T:System.Type" /> object representing the result type of the operation.</returns>
		public sealed override Type ReturnType
		{
			get
			{
				ExpressionType operation = Operation;
				if ((uint)(operation - 83) <= 1u)
				{
					return typeof(bool);
				}
				return typeof(object);
			}
		}

		/// <summary>The unary operation kind.</summary>
		/// <returns>The object of the <see cref="T:System.Linq.Expressions.ExpressionType" /> that represents the unary operation kind.</returns>
		public ExpressionType Operation { get; }

		internal sealed override bool IsStandardBinder => true;

		/// <summary>Initializes a new instance of the <see cref="T:System.Dynamic.BinaryOperationBinder" /> class.</summary>
		/// <param name="operation">The unary operation kind.</param>
		protected UnaryOperationBinder(ExpressionType operation)
		{
			ContractUtils.Requires(OperationIsValid(operation), "operation");
			Operation = operation;
		}

		/// <summary>Performs the binding of the unary dynamic operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic unary operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target)
		{
			return FallbackUnaryOperation(target, null);
		}

		/// <summary>Performs the binding of the unary dynamic operation if the target dynamic object cannot bind.</summary>
		/// <param name="target">The target of the dynamic unary operation.</param>
		/// <param name="errorSuggestion">The binding result in case the binding fails, or null.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public abstract DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target, DynamicMetaObject errorSuggestion);

		/// <summary>Performs the binding of the dynamic unary operation.</summary>
		/// <param name="target">The target of the dynamic operation.</param>
		/// <param name="args">An array of arguments of the dynamic operation.</param>
		/// <returns>The <see cref="T:System.Dynamic.DynamicMetaObject" /> representing the result of the binding.</returns>
		public sealed override DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args)
		{
			ContractUtils.RequiresNotNull(target, "target");
			ContractUtils.Requires(args == null || args.Length == 0, "args");
			return target.BindUnaryOperation(this);
		}

		internal static bool OperationIsValid(ExpressionType operation)
		{
			switch (operation)
			{
			case ExpressionType.Negate:
			case ExpressionType.UnaryPlus:
			case ExpressionType.Not:
			case ExpressionType.Decrement:
			case ExpressionType.Extension:
			case ExpressionType.Increment:
			case ExpressionType.OnesComplement:
			case ExpressionType.IsTrue:
			case ExpressionType.IsFalse:
				return true;
			default:
				return false;
			}
		}
	}
	internal static class UpdateDelegates
	{
		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet UpdateAndExecute1<T0, TRet>(CallSite site, T0 arg0)
		{
			CallSite<Func<CallSite, T0, TRet>> callSite = (CallSite<Func<CallSite, T0, TRet>>)site;
			Func<CallSite, T0, TRet> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Func<CallSite, T0, TRet>[] rules;
			Func<CallSite, T0, TRet> func;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					func = rules[i];
					if ((object)func != target)
					{
						callSite.Target = func;
						TRet result = func(site, arg0);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return result;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Func<CallSite, T0, TRet>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				func = (callSite.Target = rules[j]);
				try
				{
					TRet result = func(site, arg0);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
						CallSiteOps.MoveRule(ruleCache, func, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			func = null;
			object[] args = new object[1] { arg0 };
			while (true)
			{
				callSite.Target = target;
				func = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					TRet result = func(site, arg0);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet NoMatch1<T0, TRet>(CallSite site, T0 arg0)
		{
			site._match = false;
			return default(TRet);
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet UpdateAndExecute2<T0, T1, TRet>(CallSite site, T0 arg0, T1 arg1)
		{
			CallSite<Func<CallSite, T0, T1, TRet>> callSite = (CallSite<Func<CallSite, T0, T1, TRet>>)site;
			Func<CallSite, T0, T1, TRet> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Func<CallSite, T0, T1, TRet>[] rules;
			Func<CallSite, T0, T1, TRet> func;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					func = rules[i];
					if ((object)func != target)
					{
						callSite.Target = func;
						TRet result = func(site, arg0, arg1);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return result;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Func<CallSite, T0, T1, TRet>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				func = (callSite.Target = rules[j]);
				try
				{
					TRet result = func(site, arg0, arg1);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
						CallSiteOps.MoveRule(ruleCache, func, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			func = null;
			object[] args = new object[2] { arg0, arg1 };
			while (true)
			{
				callSite.Target = target;
				func = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					TRet result = func(site, arg0, arg1);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet NoMatch2<T0, T1, TRet>(CallSite site, T0 arg0, T1 arg1)
		{
			site._match = false;
			return default(TRet);
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet UpdateAndExecute3<T0, T1, T2, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2)
		{
			CallSite<Func<CallSite, T0, T1, T2, TRet>> callSite = (CallSite<Func<CallSite, T0, T1, T2, TRet>>)site;
			Func<CallSite, T0, T1, T2, TRet> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Func<CallSite, T0, T1, T2, TRet>[] rules;
			Func<CallSite, T0, T1, T2, TRet> func;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					func = rules[i];
					if ((object)func != target)
					{
						callSite.Target = func;
						TRet result = func(site, arg0, arg1, arg2);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return result;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Func<CallSite, T0, T1, T2, TRet>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				func = (callSite.Target = rules[j]);
				try
				{
					TRet result = func(site, arg0, arg1, arg2);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
						CallSiteOps.MoveRule(ruleCache, func, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			func = null;
			object[] args = new object[3] { arg0, arg1, arg2 };
			while (true)
			{
				callSite.Target = target;
				func = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					TRet result = func(site, arg0, arg1, arg2);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet NoMatch3<T0, T1, T2, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2)
		{
			site._match = false;
			return default(TRet);
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet UpdateAndExecute4<T0, T1, T2, T3, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
		{
			CallSite<Func<CallSite, T0, T1, T2, T3, TRet>> callSite = (CallSite<Func<CallSite, T0, T1, T2, T3, TRet>>)site;
			Func<CallSite, T0, T1, T2, T3, TRet> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Func<CallSite, T0, T1, T2, T3, TRet>[] rules;
			Func<CallSite, T0, T1, T2, T3, TRet> func;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					func = rules[i];
					if ((object)func != target)
					{
						callSite.Target = func;
						TRet result = func(site, arg0, arg1, arg2, arg3);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return result;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Func<CallSite, T0, T1, T2, T3, TRet>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				func = (callSite.Target = rules[j]);
				try
				{
					TRet result = func(site, arg0, arg1, arg2, arg3);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
						CallSiteOps.MoveRule(ruleCache, func, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			func = null;
			object[] args = new object[4] { arg0, arg1, arg2, arg3 };
			while (true)
			{
				callSite.Target = target;
				func = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					TRet result = func(site, arg0, arg1, arg2, arg3);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet NoMatch4<T0, T1, T2, T3, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
		{
			site._match = false;
			return default(TRet);
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet UpdateAndExecute5<T0, T1, T2, T3, T4, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			CallSite<Func<CallSite, T0, T1, T2, T3, T4, TRet>> callSite = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, TRet>>)site;
			Func<CallSite, T0, T1, T2, T3, T4, TRet> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Func<CallSite, T0, T1, T2, T3, T4, TRet>[] rules;
			Func<CallSite, T0, T1, T2, T3, T4, TRet> func;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					func = rules[i];
					if ((object)func != target)
					{
						callSite.Target = func;
						TRet result = func(site, arg0, arg1, arg2, arg3, arg4);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return result;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Func<CallSite, T0, T1, T2, T3, T4, TRet>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				func = (callSite.Target = rules[j]);
				try
				{
					TRet result = func(site, arg0, arg1, arg2, arg3, arg4);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
						CallSiteOps.MoveRule(ruleCache, func, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			func = null;
			object[] args = new object[5] { arg0, arg1, arg2, arg3, arg4 };
			while (true)
			{
				callSite.Target = target;
				func = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					TRet result = func(site, arg0, arg1, arg2, arg3, arg4);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet NoMatch5<T0, T1, T2, T3, T4, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			site._match = false;
			return default(TRet);
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet UpdateAndExecute6<T0, T1, T2, T3, T4, T5, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
		{
			CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>> callSite = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>>)site;
			Func<CallSite, T0, T1, T2, T3, T4, T5, TRet> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>[] rules;
			Func<CallSite, T0, T1, T2, T3, T4, T5, TRet> func;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					func = rules[i];
					if ((object)func != target)
					{
						callSite.Target = func;
						TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return result;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				func = (callSite.Target = rules[j]);
				try
				{
					TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
						CallSiteOps.MoveRule(ruleCache, func, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			func = null;
			object[] args = new object[6] { arg0, arg1, arg2, arg3, arg4, arg5 };
			while (true)
			{
				callSite.Target = target;
				func = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet NoMatch6<T0, T1, T2, T3, T4, T5, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
		{
			site._match = false;
			return default(TRet);
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet UpdateAndExecute7<T0, T1, T2, T3, T4, T5, T6, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
		{
			CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>> callSite = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>>)site;
			Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>[] rules;
			Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet> func;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					func = rules[i];
					if ((object)func != target)
					{
						callSite.Target = func;
						TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return result;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				func = (callSite.Target = rules[j]);
				try
				{
					TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
						CallSiteOps.MoveRule(ruleCache, func, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			func = null;
			object[] args = new object[7] { arg0, arg1, arg2, arg3, arg4, arg5, arg6 };
			while (true)
			{
				callSite.Target = target;
				func = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet NoMatch7<T0, T1, T2, T3, T4, T5, T6, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
		{
			site._match = false;
			return default(TRet);
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet UpdateAndExecute8<T0, T1, T2, T3, T4, T5, T6, T7, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
		{
			CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>> callSite = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>>)site;
			Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>[] rules;
			Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet> func;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					func = rules[i];
					if ((object)func != target)
					{
						callSite.Target = func;
						TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return result;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				func = (callSite.Target = rules[j]);
				try
				{
					TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
						CallSiteOps.MoveRule(ruleCache, func, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			func = null;
			object[] args = new object[8] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7 };
			while (true)
			{
				callSite.Target = target;
				func = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet NoMatch8<T0, T1, T2, T3, T4, T5, T6, T7, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
		{
			site._match = false;
			return default(TRet);
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet UpdateAndExecute9<T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
		{
			CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>> callSite = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>>)site;
			Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>[] rules;
			Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet> func;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					func = rules[i];
					if ((object)func != target)
					{
						callSite.Target = func;
						TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return result;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				func = (callSite.Target = rules[j]);
				try
				{
					TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
						CallSiteOps.MoveRule(ruleCache, func, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			func = null;
			object[] args = new object[9] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 };
			while (true)
			{
				callSite.Target = target;
				func = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet NoMatch9<T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
		{
			site._match = false;
			return default(TRet);
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet UpdateAndExecute10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
		{
			CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>> callSite = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>>)site;
			Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>[] rules;
			Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet> func;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					func = rules[i];
					if ((object)func != target)
					{
						callSite.Target = func;
						TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return result;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				func = (callSite.Target = rules[j]);
				try
				{
					TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
						CallSiteOps.MoveRule(ruleCache, func, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			func = null;
			object[] args = new object[10] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 };
			while (true)
			{
				callSite.Target = target;
				func = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					TRet result = func(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return result;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, func);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static TRet NoMatch10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
		{
			site._match = false;
			return default(TRet);
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void UpdateAndExecuteVoid1<T0>(CallSite site, T0 arg0)
		{
			CallSite<Action<CallSite, T0>> callSite = (CallSite<Action<CallSite, T0>>)site;
			Action<CallSite, T0> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Action<CallSite, T0>[] rules;
			Action<CallSite, T0> action;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					action = rules[i];
					if ((object)action != target)
					{
						callSite.Target = action;
						action(site, arg0);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Action<CallSite, T0>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				action = (callSite.Target = rules[j]);
				try
				{
					action(site, arg0);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
						CallSiteOps.MoveRule(ruleCache, action, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			action = null;
			object[] args = new object[1] { arg0 };
			while (true)
			{
				callSite.Target = target;
				action = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					action(site, arg0);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						break;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void NoMatchVoid1<T0>(CallSite site, T0 arg0)
		{
			site._match = false;
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void UpdateAndExecuteVoid2<T0, T1>(CallSite site, T0 arg0, T1 arg1)
		{
			CallSite<Action<CallSite, T0, T1>> callSite = (CallSite<Action<CallSite, T0, T1>>)site;
			Action<CallSite, T0, T1> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Action<CallSite, T0, T1>[] rules;
			Action<CallSite, T0, T1> action;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					action = rules[i];
					if ((object)action != target)
					{
						callSite.Target = action;
						action(site, arg0, arg1);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Action<CallSite, T0, T1>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				action = (callSite.Target = rules[j]);
				try
				{
					action(site, arg0, arg1);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
						CallSiteOps.MoveRule(ruleCache, action, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			action = null;
			object[] args = new object[2] { arg0, arg1 };
			while (true)
			{
				callSite.Target = target;
				action = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					action(site, arg0, arg1);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						break;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void NoMatchVoid2<T0, T1>(CallSite site, T0 arg0, T1 arg1)
		{
			site._match = false;
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void UpdateAndExecuteVoid3<T0, T1, T2>(CallSite site, T0 arg0, T1 arg1, T2 arg2)
		{
			CallSite<Action<CallSite, T0, T1, T2>> callSite = (CallSite<Action<CallSite, T0, T1, T2>>)site;
			Action<CallSite, T0, T1, T2> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Action<CallSite, T0, T1, T2>[] rules;
			Action<CallSite, T0, T1, T2> action;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					action = rules[i];
					if ((object)action != target)
					{
						callSite.Target = action;
						action(site, arg0, arg1, arg2);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Action<CallSite, T0, T1, T2>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				action = (callSite.Target = rules[j]);
				try
				{
					action(site, arg0, arg1, arg2);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
						CallSiteOps.MoveRule(ruleCache, action, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			action = null;
			object[] args = new object[3] { arg0, arg1, arg2 };
			while (true)
			{
				callSite.Target = target;
				action = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					action(site, arg0, arg1, arg2);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						break;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void NoMatchVoid3<T0, T1, T2>(CallSite site, T0 arg0, T1 arg1, T2 arg2)
		{
			site._match = false;
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void UpdateAndExecuteVoid4<T0, T1, T2, T3>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
		{
			CallSite<Action<CallSite, T0, T1, T2, T3>> callSite = (CallSite<Action<CallSite, T0, T1, T2, T3>>)site;
			Action<CallSite, T0, T1, T2, T3> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Action<CallSite, T0, T1, T2, T3>[] rules;
			Action<CallSite, T0, T1, T2, T3> action;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					action = rules[i];
					if ((object)action != target)
					{
						callSite.Target = action;
						action(site, arg0, arg1, arg2, arg3);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Action<CallSite, T0, T1, T2, T3>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				action = (callSite.Target = rules[j]);
				try
				{
					action(site, arg0, arg1, arg2, arg3);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
						CallSiteOps.MoveRule(ruleCache, action, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			action = null;
			object[] args = new object[4] { arg0, arg1, arg2, arg3 };
			while (true)
			{
				callSite.Target = target;
				action = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					action(site, arg0, arg1, arg2, arg3);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						break;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void NoMatchVoid4<T0, T1, T2, T3>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3)
		{
			site._match = false;
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void UpdateAndExecuteVoid5<T0, T1, T2, T3, T4>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			CallSite<Action<CallSite, T0, T1, T2, T3, T4>> callSite = (CallSite<Action<CallSite, T0, T1, T2, T3, T4>>)site;
			Action<CallSite, T0, T1, T2, T3, T4> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Action<CallSite, T0, T1, T2, T3, T4>[] rules;
			Action<CallSite, T0, T1, T2, T3, T4> action;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					action = rules[i];
					if ((object)action != target)
					{
						callSite.Target = action;
						action(site, arg0, arg1, arg2, arg3, arg4);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Action<CallSite, T0, T1, T2, T3, T4>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				action = (callSite.Target = rules[j]);
				try
				{
					action(site, arg0, arg1, arg2, arg3, arg4);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
						CallSiteOps.MoveRule(ruleCache, action, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			action = null;
			object[] args = new object[5] { arg0, arg1, arg2, arg3, arg4 };
			while (true)
			{
				callSite.Target = target;
				action = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					action(site, arg0, arg1, arg2, arg3, arg4);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						break;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void NoMatchVoid5<T0, T1, T2, T3, T4>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
		{
			site._match = false;
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void UpdateAndExecuteVoid6<T0, T1, T2, T3, T4, T5>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
		{
			CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5>> callSite = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5>>)site;
			Action<CallSite, T0, T1, T2, T3, T4, T5> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Action<CallSite, T0, T1, T2, T3, T4, T5>[] rules;
			Action<CallSite, T0, T1, T2, T3, T4, T5> action;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					action = rules[i];
					if ((object)action != target)
					{
						callSite.Target = action;
						action(site, arg0, arg1, arg2, arg3, arg4, arg5);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				action = (callSite.Target = rules[j]);
				try
				{
					action(site, arg0, arg1, arg2, arg3, arg4, arg5);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
						CallSiteOps.MoveRule(ruleCache, action, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			action = null;
			object[] args = new object[6] { arg0, arg1, arg2, arg3, arg4, arg5 };
			while (true)
			{
				callSite.Target = target;
				action = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					action(site, arg0, arg1, arg2, arg3, arg4, arg5);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						break;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void NoMatchVoid6<T0, T1, T2, T3, T4, T5>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
		{
			site._match = false;
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void UpdateAndExecuteVoid7<T0, T1, T2, T3, T4, T5, T6>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
		{
			CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>> callSite = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>>)site;
			Action<CallSite, T0, T1, T2, T3, T4, T5, T6> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Action<CallSite, T0, T1, T2, T3, T4, T5, T6>[] rules;
			Action<CallSite, T0, T1, T2, T3, T4, T5, T6> action;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					action = rules[i];
					if ((object)action != target)
					{
						callSite.Target = action;
						action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				action = (callSite.Target = rules[j]);
				try
				{
					action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
						CallSiteOps.MoveRule(ruleCache, action, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			action = null;
			object[] args = new object[7] { arg0, arg1, arg2, arg3, arg4, arg5, arg6 };
			while (true)
			{
				callSite.Target = target;
				action = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						break;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void NoMatchVoid7<T0, T1, T2, T3, T4, T5, T6>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
		{
			site._match = false;
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void UpdateAndExecuteVoid8<T0, T1, T2, T3, T4, T5, T6, T7>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
		{
			CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>> callSite = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>>)site;
			Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>[] rules;
			Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7> action;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					action = rules[i];
					if ((object)action != target)
					{
						callSite.Target = action;
						action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				action = (callSite.Target = rules[j]);
				try
				{
					action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
						CallSiteOps.MoveRule(ruleCache, action, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			action = null;
			object[] args = new object[8] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7 };
			while (true)
			{
				callSite.Target = target;
				action = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						break;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void NoMatchVoid8<T0, T1, T2, T3, T4, T5, T6, T7>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
		{
			site._match = false;
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void UpdateAndExecuteVoid9<T0, T1, T2, T3, T4, T5, T6, T7, T8>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
		{
			CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>> callSite = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>>)site;
			Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>[] rules;
			Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8> action;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					action = rules[i];
					if ((object)action != target)
					{
						callSite.Target = action;
						action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				action = (callSite.Target = rules[j]);
				try
				{
					action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
						CallSiteOps.MoveRule(ruleCache, action, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			action = null;
			object[] args = new object[9] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 };
			while (true)
			{
				callSite.Target = target;
				action = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						break;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void NoMatchVoid9<T0, T1, T2, T3, T4, T5, T6, T7, T8>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8)
		{
			site._match = false;
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void UpdateAndExecuteVoid10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
		{
			CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>> callSite = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>)site;
			Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> target = callSite.Target;
			site = callSite.GetMatchmaker();
			Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>[] rules;
			Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> action;
			if ((rules = CallSiteOps.GetRules(callSite)) != null)
			{
				for (int i = 0; i < rules.Length; i++)
				{
					action = rules[i];
					if ((object)action != target)
					{
						callSite.Target = action;
						action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
						if (CallSiteOps.GetMatch(site))
						{
							CallSiteOps.UpdateRules(callSite, i);
							callSite.ReleaseMatchmaker(site);
							return;
						}
						CallSiteOps.ClearMatch(site);
					}
				}
			}
			RuleCache<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>> ruleCache = CallSiteOps.GetRuleCache(callSite);
			rules = ruleCache.GetRules();
			for (int j = 0; j < rules.Length; j++)
			{
				action = (callSite.Target = rules[j]);
				try
				{
					action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						return;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
						CallSiteOps.MoveRule(ruleCache, action, j);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
			action = null;
			object[] args = new object[10] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 };
			while (true)
			{
				callSite.Target = target;
				action = (callSite.Target = callSite.Binder.BindCore(callSite, args));
				try
				{
					action(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
					if (CallSiteOps.GetMatch(site))
					{
						callSite.ReleaseMatchmaker(site);
						break;
					}
				}
				finally
				{
					if (CallSiteOps.GetMatch(site))
					{
						CallSiteOps.AddRule(callSite, action);
					}
				}
				CallSiteOps.ClearMatch(site);
			}
		}

		[Obsolete("pregenerated CallSite<T>.Update delegate", true)]
		internal static void NoMatchVoid10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9)
		{
			site._match = false;
		}
	}
}
namespace System.Dynamic.Utils
{
	internal sealed class CacheDict<TKey, TValue>
	{
		private sealed class Entry
		{
			internal readonly int _hash;

			internal readonly TKey _key;

			internal readonly TValue _value;

			internal Entry(int hash, TKey key, TValue value)
			{
				_hash = hash;
				_key = key;
				_value = value;
			}
		}

		private readonly int _mask;

		private readonly Entry[] _entries;

		internal TValue this[TKey key]
		{
			set
			{
				Add(key, value);
			}
		}

		internal CacheDict(int size)
		{
			int num = AlignSize(size);
			_mask = num - 1;
			_entries = new Entry[num];
		}

		private static int AlignSize(int size)
		{
			size--;
			size |= size >> 1;
			size |= size >> 2;
			size |= size >> 4;
			size |= size >> 8;
			size |= size >> 16;
			size++;
			return size;
		}

		internal bool TryGetValue(TKey key, out TValue value)
		{
			int hashCode = key.GetHashCode();
			int num = hashCode & _mask;
			Entry entry = Volatile.Read(ref _entries[num]);
			if (entry != null && entry._hash == hashCode && entry._key.Equals(key))
			{
				value = entry._value;
				return true;
			}
			value = default(TValue);
			return false;
		}

		internal void Add(TKey key, TValue value)
		{
			int hashCode = key.GetHashCode();
			int num = hashCode & _mask;
			Entry entry = Volatile.Read(ref _entries[num]);
			if (entry == null || entry._hash != hashCode || !entry._key.Equals(key))
			{
				Volatile.Write(ref _entries[num], new Entry(hashCode, key, value));
			}
		}
	}
	internal static class CollectionExtensions
	{
		public static TrueReadOnlyCollection<T> AddFirst<T>(this ReadOnlyCollection<T> list, T item)
		{
			T[] array = new T[list.Count + 1];
			array[0] = item;
			list.CopyTo(array, 1);
			return new TrueReadOnlyCollection<T>(array);
		}

		public static T[] AddFirst<T>(this T[] array, T item)
		{
			T[] array2 = new T[array.Length + 1];
			array2[0] = item;
			array.CopyTo(array2, 1);
			return array2;
		}

		public static T[] AddLast<T>(this T[] array, T item)
		{
			T[] array2 = new T[array.Length + 1];
			array.CopyTo(array2, 0);
			array2[array.Length] = item;
			return array2;
		}

		public static T[] RemoveFirst<T>(this T[] array)
		{
			T[] array2 = new T[array.Length - 1];
			Array.Copy(array, 1, array2, 0, array2.Length);
			return array2;
		}

		public static T[] RemoveLast<T>(this T[] array)
		{
			T[] array2 = new T[array.Length - 1];
			Array.Copy(array, 0, array2, 0, array2.Length);
			return array2;
		}

		public static ReadOnlyCollection<T> ToReadOnly<T>(this IEnumerable<T> enumerable)
		{
			if (enumerable == null)
			{
				return EmptyReadOnlyCollection<T>.Instance;
			}
			if (enumerable is TrueReadOnlyCollection<T> result)
			{
				return result;
			}
			if (enumerable is ReadOnlyCollectionBuilder<T> readOnlyCollectionBuilder)
			{
				return readOnlyCollectionBuilder.ToReadOnlyCollection();
			}
			T[] array = Enumerable.ToArray(enumerable);
			if (array.Length != 0)
			{
				return new TrueReadOnlyCollection<T>(array);
			}
			return EmptyReadOnlyCollection<T>.Instance;
		}

		public static int ListHashCode<T>(this ReadOnlyCollection<T> list)
		{
			EqualityComparer<T> equalityComparer = EqualityComparer<T>.Default;
			int num = 6551;
			foreach (T item in list)
			{
				num ^= (num << 5) ^ equalityComparer.GetHashCode(item);
			}
			return num;
		}

		public static bool ListEquals<T>(this ReadOnlyCollection<T> first, ReadOnlyCollection<T> second)
		{
			if (first == second)
			{
				return true;
			}
			int count = first.Count;
			if (count != second.Count)
			{
				return false;
			}
			EqualityComparer<T> equalityComparer = EqualityComparer<T>.Default;
			for (int i = 0; i != count; i++)
			{
				if (!equalityComparer.Equals(first[i], second[i]))
				{
					return false;
				}
			}
			return true;
		}
	}
	internal static class ContractUtils
	{
		[ExcludeFromCodeCoverage]
		public static Exception Unreachable => new InvalidOperationException("Code supposed to be unreachable");

		public static void Requires(bool precondition, string paramName)
		{
			if (!precondition)
			{
				throw System.Linq.Expressions.Error.InvalidArgumentValue(paramName);
			}
		}

		public static void RequiresNotNull(object value, string paramName)
		{
			if (value == null)
			{
				throw new ArgumentNullException(paramName);
			}
		}

		public static void RequiresNotNull(object value, string paramName, int index)
		{
			if (value == null)
			{
				throw new ArgumentNullException(GetParamName(paramName, index));
			}
		}

		public static void RequiresNotEmpty<T>(ICollection<T> collection, string paramName)
		{
			RequiresNotNull(collection, paramName);
			if (collection.Count == 0)
			{
				throw System.Linq.Expressions.Error.NonEmptyCollectionRequired(paramName);
			}
		}

		public static void RequiresNotNullItems<T>(IList<T> array, string arrayName)
		{
			RequiresNotNull(array, arrayName);
			int i = 0;
			for (int count = array.Count; i < count; i++)
			{
				if (array[i] == null)
				{
					throw new ArgumentNullException(GetParamName(arrayName, i));
				}
			}
		}

		[Conditional("DEBUG")]
		public static void AssertLockHeld(object lockObject)
		{
		}

		private static string GetParamName(string paramName, int index)
		{
			if (index < 0)
			{
				return paramName;
			}
			return $"{paramName}[{index}]";
		}

		public static void RequiresArrayRange<T>(IList<T> array, int offset, int count, string offsetName, string countName)
		{
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException(countName);
			}
			if (offset < 0 || array.Count - offset < count)
			{
				throw new ArgumentOutOfRangeException(offsetName);
			}
		}
	}
	internal static class EmptyReadOnlyCollection<T>
	{
		public static readonly ReadOnlyCollection<T> Instance = new TrueReadOnlyCollection<T>();
	}
	internal static class ExpressionUtils
	{
		public static ReadOnlyCollection<ParameterExpression> ReturnReadOnly(IParameterProvider provider, ref object collection)
		{
			if (collection is ParameterExpression parameterExpression)
			{
				Interlocked.CompareExchange(ref collection, new ReadOnlyCollection<ParameterExpression>(new ListParameterProvider(provider, parameterExpression)), parameterExpression);
			}
			return (ReadOnlyCollection<ParameterExpression>)collection;
		}

		public static ReadOnlyCollection<T> ReturnReadOnly<T>(ref IReadOnlyList<T> collection)
		{
			IReadOnlyList<T> readOnlyList = collection;
			if (readOnlyList is ReadOnlyCollection<T> result)
			{
				return result;
			}
			Interlocked.CompareExchange(ref collection, readOnlyList.ToReadOnly(), readOnlyList);
			return (ReadOnlyCollection<T>)collection;
		}

		public static ReadOnlyCollection<Expression> ReturnReadOnly(IArgumentProvider provider, ref object collection)
		{
			if (collection is Expression expression)
			{
				Interlocked.CompareExchange(ref collection, new ReadOnlyCollection<Expression>(new ListArgumentProvider(provider, expression)), expression);
			}
			return (ReadOnlyCollection<Expression>)collection;
		}

		public static T ReturnObject<T>(object collectionOrT) where T : class
		{
			if (collectionOrT is T result)
			{
				return result;
			}
			return ((ReadOnlyCollection<T>)collectionOrT)[0];
		}

		public static void ValidateArgumentTypes(MethodBase method, ExpressionType nodeKind, ref ReadOnlyCollection<Expression> arguments, string methodParamName)
		{
			ParameterInfo[] parametersForValidation = GetParametersForValidation(method, nodeKind);
			ValidateArgumentCount(method, nodeKind, arguments.Count, parametersForValidation);
			Expression[] array = null;
			int i = 0;
			for (int num = parametersForValidation.Length; i < num; i++)
			{
				Expression arguments2 = arguments[i];
				ParameterInfo pi = parametersForValidation[i];
				arguments2 = ValidateOneArgument(method, nodeKind, arguments2, pi, methodParamName, "arguments", i);
				if (array == null && arguments2 != arguments[i])
				{
					array = new Expression[arguments.Count];
					for (int j = 0; j < i; j++)
					{
						array[j] = arguments[j];
					}
				}
				if (array != null)
				{
					array[i] = arguments2;
				}
			}
			if (array != null)
			{
				arguments = new TrueReadOnlyCollection<Expression>(array);
			}
		}

		public static void ValidateArgumentCount(MethodBase method, ExpressionType nodeKind, int count, ParameterInfo[] pis)
		{
			if (pis.Length != count)
			{
				switch (nodeKind)
				{
				case ExpressionType.New:
					throw System.Linq.Expressions.Error.IncorrectNumberOfConstructorArguments();
				case ExpressionType.Invoke:
					throw System.Linq.Expressions.Error.IncorrectNumberOfLambdaArguments();
				case ExpressionType.Call:
				case ExpressionType.Dynamic:
					throw System.Linq.Expressions.Error.IncorrectNumberOfMethodCallArguments(method, "method");
				default:
					throw ContractUtils.Unreachable;
				}
			}
		}

		public static Expression ValidateOneArgument(MethodBase method, ExpressionType nodeKind, Expression arguments, ParameterInfo pi, string methodParamName, string argumentParamName, int index = -1)
		{
			RequiresCanRead(arguments, argumentParamName, index);
			Type type = pi.ParameterType;
			if (type.IsByRef)
			{
				type = type.GetElementType();
			}
			TypeUtils.ValidateType(type, methodParamName, allowByRef: true, allowPointer: true);
			if (!TypeUtils.AreReferenceAssignable(type, arguments.Type) && !TryQuote(type, ref arguments))
			{
				switch (nodeKind)
				{
				case ExpressionType.New:
					throw System.Linq.Expressions.Error.ExpressionTypeDoesNotMatchConstructorParameter(arguments.Type, type, argumentParamName, index);
				case ExpressionType.Invoke:
					throw System.Linq.Expressions.Error.ExpressionTypeDoesNotMatchParameter(arguments.Type, type, argumentParamName, index);
				case ExpressionType.Call:
				case ExpressionType.Dynamic:
					throw System.Linq.Expressions.Error.ExpressionTypeDoesNotMatchMethodParameter(arguments.Type, type, method, argumentParamName, index);
				default:
					throw ContractUtils.Unreachable;
				}
			}
			return arguments;
		}

		public static void RequiresCanRead(Expression expression, string paramName)
		{
			RequiresCanRead(expression, paramName, -1);
		}

		public static void RequiresCanRead(Expression expression, string paramName, int idx)
		{
			ContractUtils.RequiresNotNull(expression, paramName, idx);
			switch (expression.NodeType)
			{
			case ExpressionType.Index:
			{
				IndexExpression indexExpression = (IndexExpression)expression;
				if (indexExpression.Indexer != null && !indexExpression.Indexer.CanRead)
				{
					throw System.Linq.Expressions.Error.ExpressionMustBeReadable(paramName, idx);
				}
				break;
			}
			case ExpressionType.MemberAccess:
			{
				PropertyInfo propertyInfo = ((MemberExpression)expression).Member as PropertyInfo;
				if (propertyInfo != null && !propertyInfo.CanRead)
				{
					throw System.Linq.Expressions.Error.ExpressionMustBeReadable(paramName, idx);
				}
				break;
			}
			}
		}

		public static bool TryQuote(Type parameterType, ref Expression argument)
		{
			if (TypeUtils.IsSameOrSubclass(typeof(LambdaExpression), parameterType) && parameterType.IsInstanceOfType(argument))
			{
				argument = Expression.Quote(argument);
				return true;
			}
			return false;
		}

		internal static ParameterInfo[] GetParametersForValidation(MethodBase method, ExpressionType nodeKind)
		{
			ParameterInfo[] array = method.GetParametersCached();
			if (nodeKind == ExpressionType.Dynamic)
			{
				array = array.RemoveFirst();
			}
			return array;
		}

		internal static bool SameElements<T>(ICollection<T> replacement, IReadOnlyList<T> current) where T : class
		{
			if (replacement == current)
			{
				return true;
			}
			if (replacement == null)
			{
				return current.Count == 0;
			}
			return SameElementsInCollection(replacement, current);
		}

		internal static bool SameElements<T>(ref IEnumerable<T> replacement, IReadOnlyList<T> current) where T : class
		{
			if (replacement == current)
			{
				return true;
			}
			if (replacement == null)
			{
				return current.Count == 0;
			}
			ICollection<T> collection = replacement as ICollection<T>;
			if (collection == null)
			{
				collection = (ICollection<T>)(replacement = replacement.ToReadOnly());
			}
			return SameElementsInCollection(collection, current);
		}

		private static bool SameElementsInCollection<T>(ICollection<T> replacement, IReadOnlyList<T> current) where T : class
		{
			int count = current.Count;
			if (replacement.Count != count)
			{
				return false;
			}
			if (count != 0)
			{
				int num = 0;
				foreach (T item in replacement)
				{
					if (item != current[num])
					{
						return false;
					}
					num++;
				}
			}
			return true;
		}

		public static void ValidateArgumentCount(this LambdaExpression lambda)
		{
			if (((IParameterProvider)lambda).ParameterCount >= 65535)
			{
				throw System.Linq.Expressions.Error.InvalidProgram();
			}
		}
	}
	internal static class ExpressionVisitorUtils
	{
		public static Expression[] VisitBlockExpressions(ExpressionVisitor visitor, BlockExpression block)
		{
			Expression[] array = null;
			int i = 0;
			for (int expressionCount = block.ExpressionCount; i < expressionCount; i++)
			{
				Expression expression = block.GetExpression(i);
				Expression expression2 = visitor.Visit(expression);
				if (array != null)
				{
					array[i] = expression2;
				}
				else if (expression2 != expression)
				{
					array = new Expression[expressionCount];
					for (int j = 0; j < i; j++)
					{
						array[j] = block.GetExpression(j);
					}
					array[i] = expression2;
				}
			}
			return array;
		}

		public static ParameterExpression[] VisitParameters(ExpressionVisitor visitor, IParameterProvider nodes, string callerName)
		{
			ParameterExpression[] array = null;
			int i = 0;
			for (int parameterCount = nodes.ParameterCount; i < parameterCount; i++)
			{
				ParameterExpression parameter = nodes.GetParameter(i);
				ParameterExpression parameterExpression = visitor.VisitAndConvert(parameter, callerName);
				if (array != null)
				{
					array[i] = parameterExpression;
				}
				else if (parameterExpression != parameter)
				{
					array = new ParameterExpression[parameterCount];
					for (int j = 0; j < i; j++)
					{
						array[j] = nodes.GetParameter(j);
					}
					array[i] = parameterExpression;
				}
			}
			return array;
		}

		public static Expression[] VisitArguments(ExpressionVisitor visitor, IArgumentProvider nodes)
		{
			Expression[] array = null;
			int i = 0;
			for (int argumentCount = nodes.ArgumentCount; i < argumentCount; i++)
			{
				Expression argument = nodes.GetArgument(i);
				Expression expression = visitor.Visit(argument);
				if (array != null)
				{
					array[i] = expression;
				}
				else if (expression != argument)
				{
					array = new Expression[argumentCount];
					for (int j = 0; j < i; j++)
					{
						array[j] = nodes.GetArgument(j);
					}
					array[i] = expression;
				}
			}
			return array;
		}
	}
	internal static class Helpers
	{
		internal static T CommonNode<T>(T first, T second, Func<T, T> parent) where T : class
		{
			EqualityComparer<T> equalityComparer = EqualityComparer<T>.Default;
			if (equalityComparer.Equals(first, second))
			{
				return first;
			}
			HashSet<T> hashSet = new HashSet<T>(equalityComparer);
			for (T val = first; val != null; val = parent(val))
			{
				hashSet.Add(val);
			}
			for (T val2 = second; val2 != null; val2 = parent(val2))
			{
				if (hashSet.Contains(val2))
				{
					return val2;
				}
			}
			return null;
		}

		internal static void IncrementCount<T>(T key, Dictionary<T, int> dict)
		{
			dict.TryGetValue(key, out var value);
			dict[key] = value + 1;
		}
	}
	internal abstract class ListProvider<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable where T : class
	{
		protected abstract T First { get; }

		protected abstract int ElementCount { get; }

		public T this[int index]
		{
			get
			{
				if (index == 0)
				{
					return First;
				}
				return GetElement(index);
			}
			[ExcludeFromCodeCoverage]
			set
			{
				throw ContractUtils.Unreachable;
			}
		}

		public int Count => ElementCount;

		[ExcludeFromCodeCoverage]
		public bool IsReadOnly => true;

		protected abstract T GetElement(int index);

		public int IndexOf(T item)
		{
			if (First == item)
			{
				return 0;
			}
			int i = 1;
			for (int elementCount = ElementCount; i < elementCount; i++)
			{
				if (GetElement(i) == item)
				{
					return i;
				}
			}
			return -1;
		}

		[ExcludeFromCodeCoverage]
		public void Insert(int index, T item)
		{
			throw ContractUtils.Unreachable;
		}

		[ExcludeFromCodeCoverage]
		public void RemoveAt(int index)
		{
			throw ContractUtils.Unreachable;
		}

		[ExcludeFromCodeCoverage]
		public void Add(T item)
		{
			throw ContractUtils.Unreachable;
		}

		[ExcludeFromCodeCoverage]
		public void Clear()
		{
			throw ContractUtils.Unreachable;
		}

		public bool Contains(T item)
		{
			return IndexOf(item) != -1;
		}

		public void CopyTo(T[] array, int index)
		{
			ContractUtils.RequiresNotNull(array, "array");
			if (index < 0)
			{
				throw System.Linq.Expressions.Error.ArgumentOutOfRange("index");
			}
			int elementCount = ElementCount;
			if (index + elementCount > array.Length)
			{
				throw new ArgumentException();
			}
			array[index++] = First;
			for (int i = 1; i < elementCount; i++)
			{
				array[index++] = GetElement(i);
			}
		}

		[ExcludeFromCodeCoverage]
		public bool Remove(T item)
		{
			throw ContractUtils.Unreachable;
		}

		public IEnumerator<T> GetEnumerator()
		{
			yield return First;
			int i = 1;
			for (int n = ElementCount; i < n; i++)
			{
				yield return GetElement(i);
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}
	internal sealed class ListArgumentProvider : ListProvider<Expression>
	{
		private readonly IArgumentProvider _provider;

		private readonly Expression _arg0;

		protected override Expression First => _arg0;

		protected override int ElementCount => _provider.ArgumentCount;

		internal ListArgumentProvider(IArgumentProvider provider, Expression arg0)
		{
			_provider = provider;
			_arg0 = arg0;
		}

		protected override Expression GetElement(int index)
		{
			return _provider.GetArgument(index);
		}
	}
	internal sealed class ListParameterProvider : ListProvider<ParameterExpression>
	{
		private readonly IParameterProvider _provider;

		private readonly ParameterExpression _arg0;

		protected override ParameterExpression First => _arg0;

		protected override int ElementCount => _provider.ParameterCount;

		internal ListParameterProvider(IParameterProvider provider, ParameterExpression arg0)
		{
			_provider = provider;
			_arg0 = arg0;
		}

		protected override ParameterExpression GetElement(int index)
		{
			return _provider.GetParameter(index);
		}
	}
	internal static class TypeExtensions
	{
		private static readonly CacheDict<MethodBase, ParameterInfo[]> s_paramInfoCache = new CacheDict<MethodBase, ParameterInfo[]>(75);

		public static MethodInfo GetAnyStaticMethodValidated(this Type type, string name, Type[] types)
		{
			MethodInfo method = type.GetMethod(name, BindingFlags.DeclaredOnly | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, types, null);
			if (!method.MatchesArgumentTypes(types))
			{
				return null;
			}
			return method;
		}

		private static bool MatchesArgumentTypes(this MethodInfo mi, Type[] argTypes)
		{
			if (mi == null)
			{
				return false;
			}
			ParameterInfo[] parametersCached = mi.GetParametersCached();
			if (parametersCached.Length != argTypes.Length)
			{
				return false;
			}
			for (int i = 0; i < parametersCached.Length; i++)
			{
				if (!TypeUtils.AreReferenceAssignable(parametersCached[i].ParameterType, argTypes[i]))
				{
					return false;
				}
			}
			return true;
		}

		public static Type GetReturnType(this MethodBase mi)
		{
			if (!mi.IsConstructor)
			{
				return ((MethodInfo)mi).ReturnType;
			}
			return mi.DeclaringType;
		}

		public static TypeCode GetTypeCode(this Type type)
		{
			return Type.GetTypeCode(type);
		}

		internal static ParameterInfo[] GetParametersCached(this MethodBase method)
		{
			CacheDict<MethodBase, ParameterInfo[]> cacheDict = s_paramInfoCache;
			if (!cacheDict.TryGetValue(method, out var value))
			{
				value = method.GetParameters();
				Type declaringType = method.DeclaringType;
				if ((object)declaringType != null && !declaringType.IsCollectible)
				{
					cacheDict[method] = value;
				}
			}
			return value;
		}

		internal static bool IsByRefParameter(this ParameterInfo pi)
		{
			if (pi.ParameterType.IsByRef)
			{
				return true;
			}
			return (pi.Attributes & ParameterAttributes.Out) == ParameterAttributes.Out;
		}
	}
	internal static class TypeUtils
	{
		private static readonly Type[] s_arrayAssignableInterfaces = Enumerable.ToArray(from i in typeof(int[]).GetInterfaces()
			where i.IsGenericType
			select i.GetGenericTypeDefinition());

		public static Type GetNonNullableType(this Type type)
		{
			if (!type.IsNullableType())
			{
				return type;
			}
			return type.GetGenericArguments()[0];
		}

		public static Type GetNullableType(this Type type)
		{
			if (type.IsValueType && !type.IsNullableType())
			{
				return typeof(Nullable<>).MakeGenericType(type);
			}
			return type;
		}

		public static bool IsNullableType(this Type type)
		{
			if (type.IsConstructedGenericType)
			{
				return type.GetGenericTypeDefinition() == typeof(Nullable<>);
			}
			return false;
		}

		public static bool IsNullableOrReferenceType(this Type type)
		{
			if (type.IsValueType)
			{
				return type.IsNullableType();
			}
			return true;
		}

		public static bool IsBool(this Type type)
		{
			return type.GetNonNullableType() == typeof(bool);
		}

		public static bool IsNumeric(this Type type)
		{
			type = type.GetNonNullableType();
			if (!type.IsEnum)
			{
				TypeCode typeCode = type.GetTypeCode();
				if ((uint)(typeCode - 4) <= 10u)
				{
					return true;
				}
			}
			return false;
		}

		public static bool IsInteger(this Type type)
		{
			type = type.GetNonNullableType();
			if (!type.IsEnum)
			{
				TypeCode typeCode = type.GetTypeCode();
				if ((uint)(typeCode - 5) <= 7u)
				{
					return true;
				}
			}
			return false;
		}

		public static bool IsInteger64(this Type type)
		{
			type = type.GetNonNullableType();
			if (!type.IsEnum)
			{
				TypeCode typeCode = type.GetTypeCode();
				if ((uint)(typeCode - 11) <= 1u)
				{
					return true;
				}
			}
			return false;
		}

		public static bool IsArithmetic(this Type type)
		{
			type = type.GetNonNullableType();
			if (!type.IsEnum)
			{
				TypeCode typeCode = type.GetTypeCode();
				if ((uint)(typeCode - 7) <= 7u)
				{
					return true;
				}
			}
			return false;
		}

		public static bool IsUnsignedInt(this Type type)
		{
			type = type.GetNonNullableType();
			if (!type.IsEnum)
			{
				switch (type.GetTypeCode())
				{
				case TypeCode.UInt16:
				case TypeCode.UInt32:
				case TypeCode.UInt64:
					return true;
				}
			}
			return false;
		}

		public static bool IsIntegerOrBool(this Type type)
		{
			type = type.GetNonNullableType();
			if (!type.IsEnum)
			{
				TypeCode typeCode = type.GetTypeCode();
				if (typeCode == TypeCode.Boolean || (uint)(typeCode - 5) <= 7u)
				{
					return true;
				}
			}
			return false;
		}

		public static bool IsNumericOrBool(this Type type)
		{
			if (!type.IsNumeric())
			{
				return type.IsBool();
			}
			return true;
		}

		public static bool IsValidInstanceType(MemberInfo member, Type instanceType)
		{
			Type declaringType = member.DeclaringType;
			if (AreReferenceAssignable(declaringType, instanceType))
			{
				return true;
			}
			if (declaringType == null)
			{
				return false;
			}
			if (instanceType.IsValueType)
			{
				if (AreReferenceAssignable(declaringType, typeof(object)))
				{
					return true;
				}
				if (AreReferenceAssignable(declaringType, typeof(ValueType)))
				{
					return true;
				}
				if (instanceType.IsEnum && AreReferenceAssignable(declaringType, typeof(Enum)))
				{
					return true;
				}
				if (declaringType.IsInterface)
				{
					foreach (Type implementedInterface in instanceType.GetTypeInfo().ImplementedInterfaces)
					{
						if (AreReferenceAssignable(declaringType, implementedInterface))
						{
							return true;
						}
					}
				}
			}
			return false;
		}

		public static bool HasIdentityPrimitiveOrNullableConversionTo(this Type source, Type dest)
		{
			if (AreEquivalent(source, dest))
			{
				return true;
			}
			if (source.IsNullableType() && AreEquivalent(dest, source.GetNonNullableType()))
			{
				return true;
			}
			if (dest.IsNullableType() && AreEquivalent(source, dest.GetNonNullableType()))
			{
				return true;
			}
			if (source.IsConvertible() && dest.IsConvertible())
			{
				if (!(dest.GetNonNullableType() != typeof(bool)))
				{
					if (source.IsEnum)
					{
						return source.GetEnumUnderlyingType() == typeof(bool);
					}
					return false;
				}
				return true;
			}
			return false;
		}

		public static bool HasReferenceConversionTo(this Type source, Type dest)
		{
			if (source == typeof(void) || dest == typeof(void))
			{
				return false;
			}
			Type nonNullableType = source.GetNonNullableType();
			Type nonNullableType2 = dest.GetNonNullableType();
			if (nonNullableType.IsAssignableFrom(nonNullableType2))
			{
				return true;
			}
			if (nonNullableType2.IsAssignableFrom(nonNullableType))
			{
				return true;
			}
			if (source.IsInterface || dest.IsInterface)
			{
				return true;
			}
			if (IsLegalExplicitVariantDelegateConversion(source, dest))
			{
				return true;
			}
			if (source.IsArray || dest.IsArray)
			{
				return source.StrictHasReferenceConversionTo(dest, skipNonArray: true);
			}
			return false;
		}

		private static bool StrictHasReferenceConversionTo(this Type source, Type dest, bool skipNonArray)
		{
			while (true)
			{
				if (!skipNonArray)
				{
					if (source.IsValueType | dest.IsValueType)
					{
						return false;
					}
					if (source.IsAssignableFrom(dest) || dest.IsAssignableFrom(source))
					{
						return true;
					}
					if (source.IsInterface)
					{
						if (dest.IsInterface || (dest.IsClass && !dest.IsSealed))
						{
							return true;
						}
					}
					else if (dest.IsInterface && source.IsClass && !source.IsSealed)
					{
						return true;
					}
				}
				if (!source.IsArray)
				{
					break;
				}
				if (dest.IsArray)
				{
					if (source.GetArrayRank() != dest.GetArrayRank() || source.IsSZArray != dest.IsSZArray)
					{
						return false;
					}
					source = source.GetElementType();
					dest = dest.GetElementType();
					skipNonArray = false;
					continue;
				}
				return HasArrayToInterfaceConversion(source, dest);
			}
			if (dest.IsArray)
			{
				if (HasInterfaceToArrayConversion(source, dest))
				{
					return true;
				}
				return IsImplicitReferenceConversion(typeof(Array), source);
			}
			return IsLegalExplicitVariantDelegateConversion(source, dest);
		}

		private static bool HasArrayToInterfaceConversion(Type source, Type dest)
		{
			if (!source.IsSZArray || !dest.IsInterface || !dest.IsGenericType)
			{
				return false;
			}
			Type[] genericArguments = dest.GetGenericArguments();
			if (genericArguments.Length != 1)
			{
				return false;
			}
			Type genericTypeDefinition = dest.GetGenericTypeDefinition();
			Type[] array = s_arrayAssignableInterfaces;
			foreach (Type t in array)
			{
				if (AreEquivalent(genericTypeDefinition, t))
				{
					return source.GetElementType().StrictHasReferenceConversionTo(genericArguments[0], skipNonArray: false);
				}
			}
			return false;
		}

		private static bool HasInterfaceToArrayConversion(Type source, Type dest)
		{
			if (!dest.IsSZArray || !source.IsInterface || !source.IsGenericType)
			{
				return false;
			}
			Type[] genericArguments = source.GetGenericArguments();
			if (genericArguments.Length != 1)
			{
				return false;
			}
			Type genericTypeDefinition = source.GetGenericTypeDefinition();
			Type[] array = s_arrayAssignableInterfaces;
			foreach (Type t in array)
			{
				if (AreEquivalent(genericTypeDefinition, t))
				{
					return genericArguments[0].StrictHasReferenceConversionTo(dest.GetElementType(), skipNonArray: false);
				}
			}
			return false;
		}

		private static bool IsCovariant(Type t)
		{
			return (t.GenericParameterAttributes & GenericParameterAttributes.Covariant) != 0;
		}

		private static bool IsContravariant(Type t)
		{
			return (t.GenericParameterAttributes & GenericParameterAttributes.Contravariant) != 0;
		}

		private static bool IsInvariant(Type t)
		{
			return (t.GenericParameterAttributes & GenericParameterAttributes.VarianceMask) == 0;
		}

		private static bool IsDelegate(Type t)
		{
			return t.IsSubclassOf(typeof(MulticastDelegate));
		}

		public static bool IsLegalExplicitVariantDelegateConversion(Type source, Type dest)
		{
			if (!IsDelegate(source) || !IsDelegate(dest) || !source.IsGenericType || !dest.IsGenericType)
			{
				return false;
			}
			Type genericTypeDefinition = source.GetGenericTypeDefinition();
			if (dest.GetGenericTypeDefinition() != genericTypeDefinition)
			{
				return false;
			}
			Type[] genericArguments = genericTypeDefinition.GetGenericArguments();
			Type[] genericArguments2 = source.GetGenericArguments();
			Type[] genericArguments3 = dest.GetGenericArguments();
			for (int i = 0; i < genericArguments.Length; i++)
			{
				Type type = genericArguments2[i];
				Type type2 = genericArguments3[i];
				if (AreEquivalent(type, type2))
				{
					continue;
				}
				Type t = genericArguments[i];
				if (IsInvariant(t))
				{
					return false;
				}
				if (IsCovariant(t))
				{
					if (!type.HasReferenceConversionTo(type2))
					{
						return false;
					}
				}
				else if (IsContravariant(t) && (type.IsValueType || type2.IsValueType))
				{
					return false;
				}
			}
			return true;
		}

		public static bool IsConvertible(this Type type)
		{
			type = type.GetNonNullableType();
			if (type.IsEnum)
			{
				return true;
			}
			TypeCode typeCode = type.GetTypeCode();
			if ((uint)(typeCode - 3) <= 11u)
			{
				return true;
			}
			return false;
		}

		public static bool HasReferenceEquality(Type left, Type right)
		{
			if (left.IsValueType || right.IsValueType)
			{
				return false;
			}
			if (!left.IsInterface && !right.IsInterface && !AreReferenceAssignable(left, right))
			{
				return AreReferenceAssignable(right, left);
			}
			return true;
		}

		public static bool HasBuiltInEqualityOperator(Type left, Type right)
		{
			if (left.IsInterface && !right.IsValueType)
			{
				return true;
			}
			if (right.IsInterface && !left.IsValueType)
			{
				return true;
			}
			if (!left.IsValueType && !right.IsValueType && (AreReferenceAssignable(left, right) || AreReferenceAssignable(right, left)))
			{
				return true;
			}
			if (!AreEquivalent(left, right))
			{
				return false;
			}
			Type nonNullableType = left.GetNonNullableType();
			if (!(nonNullableType == typeof(bool)) && !nonNullableType.IsNumeric())
			{
				return nonNullableType.IsEnum;
			}
			return true;
		}

		public static bool IsImplicitlyConvertibleTo(this Type source, Type destination)
		{
			if (!AreEquivalent(source, destination) && !IsImplicitNumericConversion(source, destination) && !IsImplicitReferenceConversion(source, destination) && !IsImplicitBoxingConversion(source, destination))
			{
				return IsImplicitNullableConversion(source, destination);
			}
			return true;
		}

		public static MethodInfo GetUserDefinedCoercionMethod(Type convertFrom, Type convertToType)
		{
			Type nonNullableType = convertFrom.GetNonNullableType();
			Type nonNullableType2 = convertToType.GetNonNullableType();
			MethodInfo[] methods = nonNullableType.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			MethodInfo methodInfo = FindConversionOperator(methods, convertFrom, convertToType);
			if (methodInfo != null)
			{
				return methodInfo;
			}
			MethodInfo[] methods2 = nonNullableType2.GetMethods(BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
			methodInfo = FindConversionOperator(methods2, convertFrom, convertToType);
			if (methodInfo != null)
			{
				return methodInfo;
			}
			if (AreEquivalent(nonNullableType, convertFrom) && AreEquivalent(nonNullableType2, convertToType))
			{
				return null;
			}
			return FindConversionOperator(methods, nonNullableType, nonNullableType2) ?? FindConversionOperator(methods2, nonNullableType, nonNullableType2) ?? FindConversionOperator(methods, nonNullableType, convertToType) ?? FindConversionOperator(methods2, nonNullableType, convertToType);
		}

		private static MethodInfo FindConversionOperator(MethodInfo[] methods, Type typeFrom, Type typeTo)
		{
			foreach (MethodInfo methodInfo in methods)
			{
				if ((methodInfo.Name == "op_Implicit" || methodInfo.Name == "op_Explicit") && AreEquivalent(methodInfo.ReturnType, typeTo))
				{
					ParameterInfo[] parametersCached = methodInfo.GetParametersCached();
					if (parametersCached.Length == 1 && AreEquivalent(parametersCached[0].ParameterType, typeFrom))
					{
						return methodInfo;
					}
				}
			}
			return null;
		}

		private static bool IsImplicitNumericConversion(Type source, Type destination)
		{
			TypeCode typeCode = source.GetTypeCode();
			TypeCode typeCode2 = destination.GetTypeCode();
			switch (typeCode)
			{
			case TypeCode.SByte:
				switch (typeCode2)
				{
				case TypeCode.Int16:
				case TypeCode.Int32:
				case TypeCode.Int64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
					return true;
				}
				break;
			case TypeCode.Byte:
				if ((uint)(typeCode2 - 7) <= 8u)
				{
					return true;
				}
				break;
			case TypeCode.Int16:
				switch (typeCode2)
				{
				case TypeCode.Int32:
				case TypeCode.Int64:
				case TypeCode.Single:
				case TypeCode.Double:
				case TypeCode.Decimal:
					return true;
				}
				break;
			case TypeCode.UInt16:
				if ((uint)(typeCode2 - 9) <= 6u)
				{
					return true;
				}
				break;
			case TypeCode.Int32:
				if (typeCode2 == TypeCode.Int64 || (uint)(typeCode2 - 13) <= 2u)
				{
					return true;
				}
				break;
			case TypeCode.UInt32:
				if ((uint)(typeCode2 - 11) <= 4u)
				{
					return true;
				}
				break;
			case TypeCode.Int64:
			case TypeCode.UInt64:
				if ((uint)(typeCode2 - 13) <= 2u)
				{
					return true;
				}
				break;
			case TypeCode.Char:
				if ((uint)(typeCode2 - 8) <= 7u)
				{
					return true;
				}
				break;
			case TypeCode.Single:
				return typeCode2 == TypeCode.Double;
			}
			return false;
		}

		private static bool IsImplicitReferenceConversion(Type source, Type destination)
		{
			return destination.IsAssignableFrom(source);
		}

		private static bool IsImplicitBoxingConversion(Type source, Type destination)
		{
			if (!source.IsValueType || (!(destination == typeof(object)) && !(destination == typeof(ValueType))))
			{
				if (source.IsEnum)
				{
					return destination == typeof(Enum);
				}
				return false;
			}
			return true;
		}

		private static bool IsImplicitNullableConversion(Type source, Type destination)
		{
			if (destination.IsNullableType())
			{
				return source.GetNonNullableType().IsImplicitlyConvertibleTo(destination.GetNonNullableType());
			}
			return false;
		}

		public static Type FindGenericType(Type definition, Type type)
		{
			while ((object)type != null && type != typeof(object))
			{
				if (type.IsConstructedGenericType && AreEquivalent(type.GetGenericTypeDefinition(), definition))
				{
					return type;
				}
				if (definition.IsInterface)
				{
					foreach (Type implementedInterface in type.GetTypeInfo().ImplementedInterfaces)
					{
						Type type2 = FindGenericType(definition, implementedInterface);
						if (type2 != null)
						{
							return type2;
						}
					}
				}
				type = type.BaseType;
			}
			return null;
		}

		public static MethodInfo GetBooleanOperator(Type type, string name)
		{
			do
			{
				MethodInfo anyStaticMethodValidated = type.GetAnyStaticMethodValidated(name, new Type[1] { type });
				if (anyStaticMethodValidated != null && anyStaticMethodValidated.IsSpecialName && !anyStaticMethodValidated.ContainsGenericParameters)
				{
					return anyStaticMethodValidated;
				}
				type = type.BaseType;
			}
			while (type != null);
			return null;
		}

		public static Type GetNonRefType(this Type type)
		{
			if (!type.IsByRef)
			{
				return type;
			}
			return type.GetElementType();
		}

		public static bool AreEquivalent(Type t1, Type t2)
		{
			if (t1 != null)
			{
				return t1.IsEquivalentTo(t2);
			}
			return false;
		}

		public static bool AreReferenceAssignable(Type dest, Type src)
		{
			if (AreEquivalent(dest, src))
			{
				return true;
			}
			if (!dest.IsValueType && !src.IsValueType)
			{
				return dest.IsAssignableFrom(src);
			}
			return false;
		}

		public static bool IsSameOrSubclass(Type type, Type subType)
		{
			if (!AreEquivalent(type, subType))
			{
				return subType.IsSubclassOf(type);
			}
			return true;
		}

		public static void ValidateType(Type type, string paramName)
		{
			ValidateType(type, paramName, allowByRef: false, allowPointer: false);
		}

		public static void ValidateType(Type type, string paramName, bool allowByRef, bool allowPointer)
		{
			if (ValidateType(type, paramName, -1))
			{
				if (!allowByRef && type.IsByRef)
				{
					throw System.Linq.Expressions.Error.TypeMustNotBeByRef(paramName);
				}
				if (!allowPointer && type.IsPointer)
				{
					throw System.Linq.Expressions.Error.TypeMustNotBePointer(paramName);
				}
			}
		}

		public static bool ValidateType(Type type, string paramName, int index)
		{
			if (type == typeof(void))
			{
				return false;
			}
			if (type.ContainsGenericParameters)
			{
				throw type.IsGenericTypeDefinition ? System.Linq.Expressions.Error.TypeIsGeneric(type, paramName, index) : System.Linq.Expressions.Error.TypeContainsGenericParameters(type, paramName, index);
			}
			return true;
		}

		public static MethodInfo GetInvokeMethod(this Type delegateType)
		{
			return delegateType.GetMethod("Invoke", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
		}

		internal static bool IsUnsigned(this Type type)
		{
			return type.GetNonNullableType().GetTypeCode().IsUnsigned();
		}

		internal static bool IsUnsigned(this TypeCode typeCode)
		{
			switch (typeCode)
			{
			case TypeCode.Char:
			case TypeCode.Byte:
			case TypeCode.UInt16:
			case TypeCode.UInt32:
			case TypeCode.UInt64:
				return true;
			default:
				return false;
			}
		}

		internal static bool IsFloatingPoint(this Type type)
		{
			return type.GetNonNullableType().GetTypeCode().IsFloatingPoint();
		}

		internal static bool IsFloatingPoint(this TypeCode typeCode)
		{
			if ((uint)(typeCode - 13) <= 1u)
			{
				return true;
			}
			return false;
		}
	}
}
namespace System.IO
{
	internal static class Error
	{
		internal static Exception GetEndOfFile()
		{
			return new EndOfStreamException("Unable to read beyond the end of the stream.");
		}

		internal static Exception GetPipeNotOpen()
		{
			return new ObjectDisposedException(null, "Cannot access a closed pipe.");
		}

		internal static Exception GetReadNotSupported()
		{
			return new NotSupportedException("Stream does not support reading.");
		}

		internal static Exception GetSeekNotSupported()
		{
			return new NotSupportedException("Stream does not support seeking.");
		}

		internal static Exception GetWriteNotSupported()
		{
			return new NotSupportedException("Stream does not support writing.");
		}

		internal static Exception GetOperationAborted()
		{
			return new IOException("IO operation was aborted unexpectedly.");
		}
	}
	/// <summary>Specifies whether the underlying handle is inheritable by child processes.</summary>
	[Serializable]
	public enum HandleInheritability
	{
		/// <summary>Specifies that the handle is not inheritable by child processes.</summary>
		None,
		/// <summary>Specifies that the handle is inheritable by child processes.</summary>
		Inheritable
	}
}
namespace System.IO.MemoryMappedFiles
{
	/// <summary>Specifies access capabilities and restrictions for a memory-mapped file or view. </summary>
	[Serializable]
	public enum MemoryMappedFileAccess
	{
		/// <summary>Read and write access to the file.</summary>
		ReadWrite,
		/// <summary>Read-only access to the file.</summary>
		Read,
		/// <summary>Write-only access to file.</summary>
		Write,
		/// <summary>Read and write access to the file, with the restriction that any write operations will not be seen by other processes. </summary>
		CopyOnWrite,
		/// <summary>Read access to the file that can store and run executable code.</summary>
		ReadExecute,
		/// <summary>Read and write access to the file that can can store and run executable code.</summary>
		ReadWriteExecute
	}
	/// <summary>Provides memory allocation options for memory-mapped files.</summary>
	[Serializable]
	[Flags]
	public enum MemoryMappedFileOptions
	{
		/// <summary>No memory allocation options are applied.</summary>
		None = 0,
		/// <summary>Memory allocation is delayed until a view is created with either the <see cref="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor" /> or <see cref="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream" /> method.</summary>
		DelayAllocatePages = 0x4000000
	}
	/// <summary>Specifies access rights to a memory-mapped file that is not associated with a file on disk.</summary>
	[Flags]
	public enum MemoryMappedFileRights
	{
		/// <summary>The right to read and write to a file with the restriction that write operations will not be seen by other processes.</summary>
		CopyOnWrite = 1,
		/// <summary>The right to add data to a file or remove data from a file.</summary>
		Write = 2,
		/// <summary>The right to open and copy a file as read-only.</summary>
		Read = 4,
		/// <summary>The right to run an application file.</summary>
		Execute = 8,
		/// <summary>The right to delete a file.</summary>
		Delete = 0x10000,
		/// <summary>The right to open and copy access and audit rules from a file. This does not include the right to read data, file system attributes, or extended file system attributes.</summary>
		ReadPermissions = 0x20000,
		/// <summary>The right to change the security and audit rules associated with a file.</summary>
		ChangePermissions = 0x40000,
		/// <summary>The right to change the owner of a file.</summary>
		TakeOwnership = 0x80000,
		/// <summary>The right to open and copy a file, and the right to add data to a file or remove data from a file.</summary>
		ReadWrite = 6,
		/// <summary>The right to open and copy a folder or file as read-only, and to run application files. This right includes the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileRights.Read" /> right and the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileRights.Execute" /> right.</summary>
		ReadExecute = 0xC,
		/// <summary>The right to open and copy a file, the right to add data to a file or remove data from a file, and the right to run an application file.</summary>
		ReadWriteExecute = 0xE,
		/// <summary>The right to exert full control over a file, and to modify access control and audit rules. This value represents the right to do anything with a file and is the combination of all rights in this enumeration.</summary>
		FullControl = 0xF000F,
		/// <summary>The right to get or set permissions on a file.</summary>
		AccessSystemSecurity = 0x1000000
	}
	/// <summary>Represents the permissions that can be granted for file access and operations on memory-mapped files. </summary>
	public class MemoryMappedFileSecurity : ObjectSecurity<MemoryMappedFileRights>
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileSecurity" /> class. </summary>
		public MemoryMappedFileSecurity()
			: base(isContainer: false, ResourceType.KernelObject)
		{
		}

		[SecuritySafeCritical]
		internal MemoryMappedFileSecurity(SafeMemoryMappedFileHandle safeHandle, AccessControlSections includeSections)
			: base(isContainer: false, ResourceType.KernelObject, (SafeHandle)safeHandle, includeSections)
		{
		}

		[SecuritySafeCritical]
		internal void PersistHandle(SafeHandle handle)
		{
			Persist(handle);
		}
	}
	/// <summary>Represents a randomly accessed view of a memory-mapped file.</summary>
	public sealed class MemoryMappedViewAccessor : UnmanagedMemoryAccessor
	{
		private MemoryMappedView m_view;

		/// <summary>Gets a handle to the view of a memory-mapped file.</summary>
		/// <returns>A wrapper for the operating system's handle to the view of the file. </returns>
		public SafeMemoryMappedViewHandle SafeMemoryMappedViewHandle
		{
			[SecurityCritical]
			[SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]
			get
			{
				if (m_view == null)
				{
					return null;
				}
				return m_view.ViewHandle;
			}
		}

		/// <summary>[Supported in the .NET Framework 4.5.1 and later versions] Gets the number of bytes by which the starting position of this view is offset from the beginning of the memory-mapped file. </summary>
		/// <returns>The number of bytes between the starting position of this view and the beginning of the memory-mapped file. </returns>
		/// <exception cref="T:System.InvalidOperationException">The object from which this instance was created is <see langword="null" />. </exception>
		public long PointerOffset
		{
			get
			{
				if (m_view == null)
				{
					throw new InvalidOperationException(SR.GetString("The underlying MemoryMappedView object is null."));
				}
				return m_view.PointerOffset;
			}
		}

		[SecurityCritical]
		internal MemoryMappedViewAccessor(MemoryMappedView view)
		{
			m_view = view;
			Initialize(m_view.ViewHandle, m_view.PointerOffset, m_view.Size, MemoryMappedFile.GetFileAccess(m_view.Access));
		}

		[SecuritySafeCritical]
		protected override void Dispose(bool disposing)
		{
			try
			{
				if (disposing && m_view != null && !m_view.IsClosed)
				{
					Flush();
				}
			}
			finally
			{
				try
				{
					if (m_view != null)
					{
						m_view.Dispose();
					}
				}
				finally
				{
					base.Dispose(disposing);
				}
			}
		}

		/// <summary>Clears all buffers for this view and causes any buffered data to be written to the underlying file.</summary>
		/// <exception cref="T:System.ObjectDisposedException">Methods were called after the accessor was closed.</exception>
		[SecurityCritical]
		public void Flush()
		{
			if (!base.IsOpen)
			{
				throw new ObjectDisposedException("MemoryMappedViewAccessor", SR.GetString("Cannot access a closed accessor."));
			}
			if (m_view != null)
			{
				m_view.Flush((IntPtr)base.Capacity);
			}
		}

		internal MemoryMappedViewAccessor()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents a view of a memory-mapped file as a sequentially accessed stream.</summary>
	public sealed class MemoryMappedViewStream : UnmanagedMemoryStream
	{
		private MemoryMappedView m_view;

		/// <summary>Gets a handle to the view of a memory-mapped file.</summary>
		/// <returns>A wrapper for the operating system's handle to the view of the file. </returns>
		public SafeMemoryMappedViewHandle SafeMemoryMappedViewHandle
		{
			[SecurityCritical]
			[SecurityPermission(SecurityAction.Demand, Flags = SecurityPermissionFlag.UnmanagedCode)]
			get
			{
				if (m_view == null)
				{
					return null;
				}
				return m_view.ViewHandle;
			}
		}

		/// <summary>[Supported in the .NET Framework 4.5.1 and later versions] Gets the number of bytes by which the starting position of this view is offset from the beginning of the memory-mapped file.</summary>
		/// <returns>The number of bytes between the starting position of this view and the beginning of the memory-mapped file. </returns>
		/// <exception cref="T:System.InvalidOperationException">The object from which this instance was created is <see langword="null" />. </exception>
		public long PointerOffset
		{
			get
			{
				if (m_view == null)
				{
					throw new InvalidOperationException(SR.GetString("The underlying MemoryMappedView object is null."));
				}
				return m_view.PointerOffset;
			}
		}

		[SecurityCritical]
		internal MemoryMappedViewStream(MemoryMappedView view)
		{
			m_view = view;
			Initialize(m_view.ViewHandle, m_view.PointerOffset, m_view.Size, MemoryMappedFile.GetFileAccess(m_view.Access));
		}

		/// <summary>Sets the length of the current stream.</summary>
		/// <param name="value">The desired length of the current stream in bytes.</param>
		/// <exception cref="T:System.NotSupportedException">This method is not supported.</exception>
		public override void SetLength(long value)
		{
			throw new NotSupportedException(SR.GetString("MemoryMappedViewStreams are fixed length."));
		}

		[SecuritySafeCritical]
		protected override void Dispose(bool disposing)
		{
			try
			{
				if (disposing && m_view != null && !m_view.IsClosed)
				{
					Flush();
				}
			}
			finally
			{
				try
				{
					if (m_view != null)
					{
						m_view.Dispose();
					}
				}
				finally
				{
					base.Dispose(disposing);
				}
			}
		}

		/// <summary>Clears all buffers for this stream and causes any buffered data to be written to the underlying file.</summary>
		[SecurityCritical]
		public override void Flush()
		{
			if (!CanSeek)
			{
				__Error.StreamIsClosed();
			}
			if (m_view != null)
			{
				m_view.Flush((IntPtr)base.Capacity);
			}
		}

		internal MemoryMappedViewStream()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	internal static class MemoryMapImpl
	{
		[MethodImpl(MethodImplOptions.InternalCall)]
		private unsafe static extern IntPtr OpenFileInternal(char* path, int path_length, FileMode mode, char* mapName, int mapName_length, out long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, out int error);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private unsafe static extern IntPtr OpenHandleInternal(IntPtr handle, char* mapName, int mapName_length, out long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, out int error);

		[MethodImpl(MethodImplOptions.InternalCall)]
		internal static extern void CloseMapping(IntPtr handle);

		[MethodImpl(MethodImplOptions.InternalCall)]
		internal static extern void Flush(IntPtr file_handle);

		[MethodImpl(MethodImplOptions.InternalCall)]
		internal static extern void ConfigureHandleInheritability(IntPtr handle, HandleInheritability inheritability);

		[MethodImpl(MethodImplOptions.InternalCall)]
		internal static extern bool Unmap(IntPtr mmap_handle);

		[MethodImpl(MethodImplOptions.InternalCall)]
		private static extern int MapInternal(IntPtr handle, long offset, ref long size, MemoryMappedFileAccess access, out IntPtr mmap_handle, out IntPtr base_address);

		internal static void Map(IntPtr handle, long offset, ref long size, MemoryMappedFileAccess access, out IntPtr mmap_handle, out IntPtr base_address)
		{
			int num = MapInternal(handle, offset, ref size, access, out mmap_handle, out base_address);
			if (num != 0)
			{
				throw CreateException(num, "<none>");
			}
		}

		private static Exception CreateException(int error, string path)
		{
			return error switch
			{
				1 => new ArgumentException("A positive capacity must be specified for a Memory Mapped File backed by an empty file."), 
				2 => new ArgumentOutOfRangeException("capacity", "The capacity may not be smaller than the file size."), 
				3 => new FileNotFoundException(path), 
				4 => new IOException("The file already exists"), 
				5 => new PathTooLongException(), 
				6 => new IOException("Could not open file"), 
				7 => new ArgumentException("Capacity must be bigger than zero for non-file mappings"), 
				8 => new ArgumentException("Invalid FileMode value."), 
				9 => new IOException("Could not map file"), 
				10 => new UnauthorizedAccessException("Access to the path is denied."), 
				11 => new ArgumentOutOfRangeException("capacity", "The capacity cannot be greater than the size of the system's logical address space."), 
				_ => new IOException("Failed with unknown error code " + error), 
			};
		}

		private static int StringLength(string a)
		{
			return a?.Length ?? 0;
		}

		private static void CheckString(string name, string value)
		{
			if (value != null && value.IndexOf('\0') >= 0)
			{
				throw new ArgumentException("String must not contain embedded NULs.", name);
			}
		}

		internal unsafe static IntPtr OpenFile(string path, FileMode mode, string mapName, out long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options)
		{
			CheckString("path", path);
			CheckString("mapName", mapName);
			fixed (char* path2 = path)
			{
				fixed (char* mapName2 = mapName)
				{
					int error = 0;
					IntPtr result = OpenFileInternal(path2, StringLength(path), mode, mapName2, StringLength(mapName), out capacity, access, options, out error);
					if (error != 0)
					{
						throw CreateException(error, path);
					}
					return result;
				}
			}
		}

		internal unsafe static IntPtr OpenHandle(IntPtr handle, string mapName, out long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options)
		{
			CheckString("mapName", mapName);
			fixed (char* mapName2 = mapName)
			{
				int error = 0;
				IntPtr result = OpenHandleInternal(handle, mapName2, StringLength(mapName), out capacity, access, options, out error);
				if (error != 0)
				{
					throw CreateException(error, "<none>");
				}
				return result;
			}
		}
	}
	/// <summary>Represents a memory-mapped file. </summary>
	public class MemoryMappedFile : IDisposable
	{
		private FileStream stream;

		private bool keepOpen;

		private SafeMemoryMappedFileHandle handle;

		/// <summary>Gets the file handle of a memory-mapped file.</summary>
		/// <returns>The handle to the memory-mapped file.</returns>
		public SafeMemoryMappedFileHandle SafeMemoryMappedFileHandle => handle;

		/// <summary>Creates a memory-mapped file from a file on disk.</summary>
		/// <param name="path">The path to file to map.</param>
		/// <returns>A memory-mapped file.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="path" /> is an empty string, contains only white space, or has one or more invalid characters, as defined by the <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> method. -or-
		///         <paramref name="path" /> refers to an invalid device. </exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="path" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
		/// <exception cref="T:System.IO.PathTooLongException">
		///         <paramref name="path" /> exceeds the maximum length defined by the operating system. In Windows, paths must contain fewer than 248 characters, and file names must contain fewer than 260 characters.</exception>
		/// <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions for the file.</exception>
		public static MemoryMappedFile CreateFromFile(string path)
		{
			return CreateFromFile(path, FileMode.Open, null, 0L, MemoryMappedFileAccess.ReadWrite);
		}

		/// <summary>Creates a memory-mapped file that has the specified access mode from a file on disk. </summary>
		/// <param name="path">The path to file to map.</param>
		/// <param name="mode">Access mode; must be <see cref="F:System.IO.FileMode.Open" />.</param>
		/// <returns>A memory-mapped file that has the specified access mode.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="path" /> is an empty string, contains only white space, or has one or more invalid characters, as defined by the <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> method. -or-
		///         <paramref name="path" /> refers to an invalid device.-or-
		///         <paramref name="mode" /> is <see cref="F:System.IO.FileMode.Append" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="path" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.IO.IOException">
		///         <paramref name="mode" /> is <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" />, or <see cref="F:System.IO.FileMode.Truncate" />.-or-
		///         <paramref name="mode" /> is <see cref="F:System.IO.FileMode.OpenOrCreate" /> and the file on disk does not exist.-or-An I/O error occurred.</exception>
		/// <exception cref="T:System.IO.PathTooLongException">
		///         <paramref name="path" /> exceeds the maximum length defined by the operating system. In Windows, paths must contain fewer than 248 characters, and file names must contain fewer than 260 characters. </exception>
		/// <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions for the file.</exception>
		public static MemoryMappedFile CreateFromFile(string path, FileMode mode)
		{
			long capacity = 0L;
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			if (path.Length == 0)
			{
				throw new ArgumentException("path");
			}
			if (mode == FileMode.Append)
			{
				throw new ArgumentException("mode");
			}
			IntPtr preexistingHandle = MemoryMapImpl.OpenFile(path, mode, null, out capacity, MemoryMappedFileAccess.ReadWrite, MemoryMappedFileOptions.None);
			return new MemoryMappedFile
			{
				handle = new SafeMemoryMappedFileHandle(preexistingHandle, ownsHandle: true)
			};
		}

		/// <summary>Creates a memory-mapped file that has the specified access mode and name from a file on disk.</summary>
		/// <param name="path">The path to the file to map.</param>
		/// <param name="mode">Access mode; must be <see cref="F:System.IO.FileMode.Open" />.</param>
		/// <param name="mapName">A name to assign to the memory-mapped file. </param>
		/// <returns>A memory-mapped file that has the specified name and access mode.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="path" /> is an empty string, contains only white space, or has one or more invalid characters, as defined by the <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> method. -or-
		///         <paramref name="path" /> refers to an invalid device.-or-
		///         <paramref name="mapName" /> is an empty string.-or-
		///         <paramref name="mode" /> is <see cref="F:System.IO.FileMode.Append" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="path" /> or <paramref name="mapName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.IO.IOException">
		///         <paramref name="mode" /> is <see cref="F:System.IO.FileMode.Create" />, <see cref="F:System.IO.FileMode.CreateNew" />, or <see cref="F:System.IO.FileMode.Truncate" />.-or-
		///         <paramref name="mode" /> is <see cref="F:System.IO.FileMode.OpenOrCreate" /> and the file on disk does not exist.-or-An I/O error occurred.</exception>
		/// <exception cref="T:System.IO.PathTooLongException">
		///         <paramref name="path" /> exceeds the maximum length defined by the operating system. In Windows, paths must contain fewer than 248 characters, and file names must contain fewer than 260 characters.</exception>
		/// <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions for the file.</exception>
		public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName)
		{
			return CreateFromFile(path, mode, mapName, 0L, MemoryMappedFileAccess.ReadWrite);
		}

		/// <summary>Creates a memory-mapped file that has the specified access mode, name, and capacity from a file on disk.</summary>
		/// <param name="path">The path to the file to map.</param>
		/// <param name="mode">Access mode; can be any of the <see cref="T:System.IO.FileMode" /> enumeration values except <see cref="F:System.IO.FileMode.Append" />.</param>
		/// <param name="mapName">A name to assign to the memory-mapped file. </param>
		/// <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file. Specify 0 to set the capacity to the size of the file on disk.</param>
		/// <returns>A memory-mapped file that has the specified characteristics.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="path" /> is an empty string, contains only white space, or has one or more invalid characters, as defined by the <see cref="M:System.IO.Path.GetInvalidFileNameChars" /> method. -or-
		///         <paramref name="path" /> refers to an invalid device.-or-
		///         <paramref name="mapName" /> is an empty string.-or-
		///         <paramref name="mode" /> is <see cref="F:System.IO.FileMode.Append" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="path" /> or <paramref name="mapName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="capacity" /> is greater than the size of the logical address space.-or-
		///         <paramref name="capacity" /> is less than zero.-or-
		///         <paramref name="capacity" /> is less than the file size (but not zero).-or-
		///         <paramref name="capacity" /> is zero, and the size of the file on disk is also zero.</exception>
		/// <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
		/// <exception cref="T:System.IO.PathTooLongException">
		///         <paramref name="path" /> exceeds the maximum length defined by the operating system. In Windows, paths must contain fewer than 248 characters, and file names must contain fewer than 260 characters.</exception>
		/// <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions for the file.</exception>
		public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName, long capacity)
		{
			return CreateFromFile(path, mode, mapName, capacity, MemoryMappedFileAccess.ReadWrite);
		}

		/// <summary>Creates a memory-mapped file that has the specified access mode, name, capacity, and access type from a file on disk.</summary>
		/// <param name="path">The path to the file to map.</param>
		/// <param name="mode">Access mode; can be any of the <see cref="T:System.IO.FileMode" /> enumeration values except <see cref="F:System.IO.FileMode.Append" />.</param>
		/// <param name="mapName">A name to assign to the memory-mapped file. </param>
		/// <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file. Specify 0 to set the capacity to the size of the file on disk.</param>
		/// <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file.</param>
		/// <returns>A memory-mapped file that has the specified characteristics.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mapName" /> is an empty string.-or-
		///         <paramref name="access" /> is not an allowed value.-or-
		///         <paramref name="path" /> specifies an empty file.-or-
		///         <paramref name="access" /> is specified as <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> and capacity is greater than the size of the file indicated by <paramref name="path" />.-or-
		///         <paramref name="mode" /> is <see cref="F:System.IO.FileMode.Append" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="path" /> or <paramref name="mapName" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="capacity" /> is greater than the size of the logical address space.-or-
		///         <paramref name="capacity" /> is less than zero.-or-
		///         <paramref name="capacity" /> is less than the file size (but not zero).-or-
		///         <paramref name="capacity" /> is zero, and the size of the file on disk is also zero.-or-
		///         <paramref name="access" /> is not a defined <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> value.-or-The size of the file indicated by <paramref name="path" /> is greater than <paramref name="capacity" />.</exception>
		/// <exception cref="T:System.IO.IOException">-or-An I/O error occurred.</exception>
		/// <exception cref="T:System.IO.PathTooLongException">
		///         <paramref name="path" /> exceeds the maximum length defined by the operating system. In Windows, paths must contain fewer than 248 characters, and file names must contain fewer than 260 characters.</exception>
		/// <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions for the file.</exception>
		public static MemoryMappedFile CreateFromFile(string path, FileMode mode, string mapName, long capacity, MemoryMappedFileAccess access)
		{
			if (path == null)
			{
				throw new ArgumentNullException("path");
			}
			if (path.Length == 0)
			{
				throw new ArgumentException("path");
			}
			if (mapName != null && mapName.Length == 0)
			{
				throw new ArgumentException("mapName");
			}
			if (mode == FileMode.Append)
			{
				throw new ArgumentException("mode");
			}
			if (capacity < 0)
			{
				throw new ArgumentOutOfRangeException("capacity");
			}
			IntPtr preexistingHandle = MemoryMapImpl.OpenFile(path, mode, mapName, out capacity, access, MemoryMappedFileOptions.None);
			return new MemoryMappedFile
			{
				handle = new SafeMemoryMappedFileHandle(preexistingHandle, ownsHandle: true)
			};
		}

		/// <summary>Creates a memory-mapped file from an existing file with the specified access mode, name, inheritability, and capacity.</summary>
		/// <param name="fileStream">The file stream of the existing file.</param>
		/// <param name="mapName">A name to assign to the memory-mapped file.</param>
		/// <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file. Specify 0 to set the capacity to the size of <paramref name="filestream" />.</param>
		/// <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. This parameter cant be set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />. </param>
		/// <param name="inheritability">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is <see cref="F:System.IO.HandleInheritability.None" />.</param>
		/// <param name="leaveOpen">A value that indicates whether to close the source file stream when the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> is disposed. </param>
		/// <returns>A memory-mapped file that has the specified characteristics.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mapName" /> is <see langword="null" /> or an empty string.-or-
		///         <paramref name="capacity" /> and the length of the file are zero.-or-
		///         <paramref name="access" /> is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value, which is not allowed.-or-
		///         <paramref name="access" /> is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> and <paramref name="capacity" /> is larger than the length of <see langword="filestream" />.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="fileStream" />  is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="capacity" /> is less than zero.-or-
		///         <paramref name="capacity" /> is less than the file size.-or-
		///         <paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.-or-
		///         <paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> enumeration value.</exception>
		public static MemoryMappedFile CreateFromFile(FileStream fileStream, string mapName, long capacity, MemoryMappedFileAccess access, HandleInheritability inheritability, bool leaveOpen)
		{
			if (fileStream == null)
			{
				throw new ArgumentNullException("fileStream");
			}
			if (mapName != null && mapName.Length == 0)
			{
				throw new ArgumentException("mapName");
			}
			if ((!MonoUtil.IsUnix && capacity == 0L && fileStream.Length == 0L) || capacity > fileStream.Length)
			{
				throw new ArgumentException("capacity");
			}
			IntPtr preexistingHandle = MemoryMapImpl.OpenHandle(fileStream.SafeFileHandle.DangerousGetHandle(), mapName, out capacity, access, MemoryMappedFileOptions.None);
			MemoryMapImpl.ConfigureHandleInheritability(preexistingHandle, inheritability);
			return new MemoryMappedFile
			{
				handle = new SafeMemoryMappedFileHandle(preexistingHandle, ownsHandle: true),
				stream = fileStream,
				keepOpen = leaveOpen
			};
		}

		/// <summary>Creates a memory-mapped file that has the specified name, capacity, access type, security permissions, inheritability, and disposal requirement from a file on disk. </summary>
		/// <param name="fileStream">The <paramref name="fileStream" /> to the file to map.</param>
		/// <param name="mapName">A name to assign to the memory-mapped file.</param>
		/// <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file. Specify 0 to set the capacity to the size of the file on disk.</param>
		/// <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. This parameter cant be set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" />. </param>
		/// <param name="memoryMappedFileSecurity">The permissions that can be granted for file access and operations on memory-mapped files.This parameter can be <see langword="null" />.</param>
		/// <param name="inheritability">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is <see cref="F:System.IO.HandleInheritability.None" />.</param>
		/// <param name="leaveOpen">
		///       <see langword="true" /> to not dispose <paramref name="fileStream" /> after the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> is closed; <see langword="false" /> to dispose <paramref name="fileStream" />.</param>
		/// <returns>A memory-mapped file that has the specified characteristics.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mapName" /> is an empty string.-or-
		///         <paramref name="capacity" /> and the length of the file are zero.-or-
		///         <paramref name="access" /> is set to the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Read" /> or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value, which is not allowed.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="fileStream" /> or <paramref name="mapname" />  is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="capacity" /> is less than zero.-or-
		///         <paramref name="capacity" /> is less than the file size.-or-
		///         <paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.-or-
		///         <paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> enumeration value.</exception>
		/// <exception cref="T:System.ObjectDisposedException">
		///         <paramref name="fileStream" /> was closed.</exception>
		/// <exception cref="T:System.UnauthorizedAccessException">
		///         <paramref name="access" /> is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" /> when <paramref name="fileStream" />'s access is set to <see cref="F:System.IO.FileAccess.Read" /> or <see cref="F:System.IO.FileAccess.Write" />. </exception>
		/// <exception cref="T:System.IO.IOException">
		///         <paramref name="mapName" /> already exists.</exception>
		[MonoLimitation("memoryMappedFileSecurity is currently ignored")]
		public static MemoryMappedFile CreateFromFile(FileStream fileStream, string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability, bool leaveOpen)
		{
			if (fileStream == null)
			{
				throw new ArgumentNullException("fileStream");
			}
			if (mapName != null && mapName.Length == 0)
			{
				throw new ArgumentException("mapName");
			}
			if ((!MonoUtil.IsUnix && capacity == 0L && fileStream.Length == 0L) || capacity > fileStream.Length)
			{
				throw new ArgumentException("capacity");
			}
			IntPtr preexistingHandle = MemoryMapImpl.OpenHandle(fileStream.SafeFileHandle.DangerousGetHandle(), mapName, out capacity, access, MemoryMappedFileOptions.None);
			MemoryMapImpl.ConfigureHandleInheritability(preexistingHandle, inheritability);
			return new MemoryMappedFile
			{
				handle = new SafeMemoryMappedFileHandle(preexistingHandle, ownsHandle: true),
				stream = fileStream,
				keepOpen = leaveOpen
			};
		}

		private static MemoryMappedFile CoreShmCreate(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability, FileMode mode)
		{
			if (mapName != null && mapName.Length == 0)
			{
				throw new ArgumentException("mapName");
			}
			if (capacity < 0)
			{
				throw new ArgumentOutOfRangeException("capacity");
			}
			IntPtr preexistingHandle = MemoryMapImpl.OpenFile(null, mode, mapName, out capacity, access, options);
			return new MemoryMappedFile
			{
				handle = new SafeMemoryMappedFileHandle(preexistingHandle, ownsHandle: true)
			};
		}

		/// <summary>Creates a memory-mapped file that has the specified capacity in system memory. </summary>
		/// <param name="mapName">A name to assign to the memory-mapped file.</param>
		/// <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
		/// <returns>A memory-mapped file that has the specified name and capacity.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mapName" /> is an empty string. </exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="mapName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="capacity" /> is less than or equal to zero.</exception>
		[MonoLimitation("Named mappings scope is process local")]
		public static MemoryMappedFile CreateNew(string mapName, long capacity)
		{
			return CreateNew(mapName, capacity, MemoryMappedFileAccess.ReadWrite, MemoryMappedFileOptions.None, null, HandleInheritability.None);
		}

		/// <summary>Creates a memory-mapped file that has the specified capacity and access type in system memory. </summary>
		/// <param name="mapName">A name to assign to the memory-mapped file.</param>
		/// <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
		/// <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />. </param>
		/// <returns>A memory-mapped file that has the specified characteristics.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mapName" /> is an empty string.-or-
		///         <paramref name="access" /> is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value. </exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="mapName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="capacity" /> is less than or equal to zero.-or-
		///         <paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.</exception>
		[MonoLimitation("Named mappings scope is process local")]
		public static MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access)
		{
			return CreateNew(mapName, capacity, access, MemoryMappedFileOptions.None, null, HandleInheritability.None);
		}

		/// <summary>Creates a memory-mapped file that has the specified name, capacity, access type, memory allocation options and inheritability.</summary>
		/// <param name="mapName">A name to assign to the memory-mapped file.</param>
		/// <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
		/// <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
		/// <param name="options">A bitwise combination of enumeration values that specifies memory allocation options for the memory-mapped file.</param>
		/// <param name="inheritability">A value that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is <see cref="F:System.IO.HandleInheritability.None" />.</param>
		/// <returns>A memory-mapped file that has the specified characteristics.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mapName" /> is an empty string.-or-
		///         <paramref name="access" /> is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value. </exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="mapName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="capacity" /> is less than or equal to zero.-or-
		///         <paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.-or-
		///         <paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> value.</exception>
		[MonoLimitation("Named mappings scope is process local; options is ignored")]
		public static MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, HandleInheritability inheritability)
		{
			return CreateNew(mapName, capacity, access, options, null, inheritability);
		}

		/// <summary>Creates a memory-mapped file that has the specified capacity, access type, memory allocation, security permissions, and inheritability in system memory.</summary>
		/// <param name="mapName">A name to assign to the memory-mapped file.</param>
		/// <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
		/// <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />. </param>
		/// <param name="options">A bitwise combination of enumeration values that specifies memory allocation options for the memory-mapped file.</param>
		/// <param name="memoryMappedFileSecurity">The permissions that can be granted for file access and operations on memory-mapped files.This parameter can be <see langword="null" />.</param>
		/// <param name="inheritability">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is <see cref="F:System.IO.HandleInheritability.None" />.</param>
		/// <returns>A memory-mapped file that has the specified characteristics.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mapName" /> is an empty string.-or-
		///         <paramref name="access" /> is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="mapName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="capacity" /> is less than or equal to zero.-or-
		///         <paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.-or-
		///         <paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> enumeration value.</exception>
		[MonoLimitation("Named mappings scope is process local; options and memoryMappedFileSecurity are ignored")]
		public static MemoryMappedFile CreateNew(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability)
		{
			return CoreShmCreate(mapName, capacity, access, options, memoryMappedFileSecurity, inheritability, FileMode.CreateNew);
		}

		/// <summary>Creates or opens a memory-mapped file that has the specified capacity in system memory.</summary>
		/// <param name="mapName">A name to assign to the memory-mapped file.</param>
		/// <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
		/// <returns>A memory-mapped file that has the specified name and size.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mapName" /> is an empty string.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="mapName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="capacity" /> is greater than the size of the logical address space.-or-
		///         <paramref name="capacity" /> is less than or equal to zero.</exception>
		[MonoLimitation("Named mappings scope is process local")]
		public static MemoryMappedFile CreateOrOpen(string mapName, long capacity)
		{
			return CreateOrOpen(mapName, capacity, MemoryMappedFileAccess.ReadWrite);
		}

		/// <summary>Creates or opens a memory-mapped file that has the specified capacity and access type in system memory. </summary>
		/// <param name="mapName">A name to assign to the memory-mapped file.</param>
		/// <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
		/// <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />. </param>
		/// <returns>A memory-mapped file that has the specified characteristics.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mapName" /> is an empty string.-or-
		///         <paramref name="access" /> is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="mapName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="capacity" /> is greater than the size of the logical address space.-or-
		///         <paramref name="capacity" /> is less than or equal to zero.-or-
		///         <paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.</exception>
		/// <exception cref="T:System.UnauthorizedAccessException">The operating system denied the specified access to the file; for example, access is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, but the file or directory is read-only. </exception>
		[MonoLimitation("Named mappings scope is process local")]
		public static MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access)
		{
			return CreateOrOpen(mapName, capacity, access, MemoryMappedFileOptions.None, null, HandleInheritability.None);
		}

		/// <summary>Creates a new empty memory mapped file or opens an existing memory mapped file if one exists with the same name. If opening an existing file, the capacity, options, and memory arguments will be ignored. </summary>
		/// <param name="mapName">A name to assign to the memory-mapped file.</param>
		/// <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
		/// <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />. </param>
		/// <param name="options">A bitwise combination of values that indicate the memory allocation options to apply to the file.</param>
		/// <param name="inheritability">A value that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is <see cref="F:System.IO.HandleInheritability.None" />.</param>
		/// <returns>A memory-mapped file that has the specified characteristics.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mapName" /> is an empty string.-or-
		///         <paramref name="access" /> is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="mapName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="capacity" /> is greater than the size of the logical address space.-or-
		///         <paramref name="capacity" /> is less than or equal to zero.-or-
		///         <paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.-or-
		///         <paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> enumeration value.</exception>
		/// <exception cref="T:System.UnauthorizedAccessException">The operating system denied the specified access to the file; for example, access is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, but the file or directory is read-only. </exception>
		[MonoLimitation("Named mappings scope is process local")]
		public static MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, HandleInheritability inheritability)
		{
			return CreateOrOpen(mapName, capacity, access, options, null, inheritability);
		}

		/// <summary>Creates or opens a memory-mapped file that has the specified capacity, access type, memory allocation, security permissions, and inheritability in system memory.</summary>
		/// <param name="mapName">A name to assign to the memory-mapped file.</param>
		/// <param name="capacity">The maximum size, in bytes, to allocate to the memory-mapped file.</param>
		/// <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />. </param>
		/// <param name="options">A bitwise combination of enumeration values that specifies memory allocation options for the memory-mapped file.</param>
		/// <param name="memoryMappedFileSecurity">The permissions that can be granted for file access and operations on memory-mapped files.This parameter can be <see langword="null" />.</param>
		/// <param name="inheritability">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is <see cref="F:System.IO.HandleInheritability.None" />.</param>
		/// <returns>A memory-mapped file that has the specified characteristics.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mapName" /> is an empty string. -or-
		///         <paramref name="access" /> is set to write-only with the <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> enumeration value.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="mapName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="capacity" /> is greater than the size of the logical address space.-or-
		///         <paramref name="capacity" /> is less than or equal to zero.-or-
		///         <paramref name="access" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.-or-
		///         <paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> enumeration value.</exception>
		/// <exception cref="T:System.UnauthorizedAccessException">The operating system denied the specified <paramref name="access" /> to the file; for example, <paramref name="access" /> is set to <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> or <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />, but the file or directory is read-only. </exception>
		[MonoLimitation("Named mappings scope is process local")]
		public static MemoryMappedFile CreateOrOpen(string mapName, long capacity, MemoryMappedFileAccess access, MemoryMappedFileOptions options, MemoryMappedFileSecurity memoryMappedFileSecurity, HandleInheritability inheritability)
		{
			return CoreShmCreate(mapName, capacity, access, options, memoryMappedFileSecurity, inheritability, FileMode.OpenOrCreate);
		}

		/// <summary>Opens an existing memory-mapped file that has the specified name in system memory.</summary>
		/// <param name="mapName">The name of the memory-mapped file to open.</param>
		/// <returns>A memory-mapped file that has the specified name. </returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mapName" /> is an empty string.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="mapName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.IO.FileNotFoundException">The file specified for <paramref name="mapName" /> does not exist.</exception>
		[MonoLimitation("Named mappings scope is process local")]
		public static MemoryMappedFile OpenExisting(string mapName)
		{
			return OpenExisting(mapName, MemoryMappedFileRights.ReadWrite);
		}

		/// <summary>Opens an existing memory-mapped file that has the specified name and access rights in system memory.</summary>
		/// <param name="mapName">The name of the memory-mapped file to open.</param>
		/// <param name="desiredAccessRights">One of the enumeration values that specifies the access rights to apply to the memory-mapped file.</param>
		/// <returns>A memory-mapped file that has the specified characteristics.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mapName" /> is an empty string.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="mapName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="desiredAccessRights" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> enumeration value.</exception>
		/// <exception cref="T:System.IO.FileNotFoundException">The file specified for <paramref name="mapName" /> does not exist.</exception>
		[MonoLimitation("Named mappings scope is process local")]
		public static MemoryMappedFile OpenExisting(string mapName, MemoryMappedFileRights desiredAccessRights)
		{
			return OpenExisting(mapName, desiredAccessRights, HandleInheritability.None);
		}

		/// <summary>Opens an existing memory-mapped file that has the specified name, access rights, and inheritability in system memory.</summary>
		/// <param name="mapName">The name of the memory-mapped file to open.</param>
		/// <param name="desiredAccessRights">One of the enumeration values that specifies the access rights to apply to the memory-mapped file.</param>
		/// <param name="inheritability">One of the enumeration values that specifies whether a handle to the memory-mapped file can be inherited by a child process. The default is <see cref="F:System.IO.HandleInheritability.None" />.</param>
		/// <returns>A memory-mapped file that has the specified characteristics.</returns>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="mapName" /> is an empty string.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="mapName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="desiredAccessRights" /> is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileRights" /> enumeration value.-or-
		///         <paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> enumeration value.</exception>
		/// <exception cref="T:System.UnauthorizedAccessException">The requested access is invalid for the memory-mapped file.</exception>
		/// <exception cref="T:System.IO.FileNotFoundException">The file specified for <paramref name="mapName" /> does not exist.</exception>
		[MonoLimitation("Named mappings scope is process local")]
		public static MemoryMappedFile OpenExisting(string mapName, MemoryMappedFileRights desiredAccessRights, HandleInheritability inheritability)
		{
			return CoreShmCreate(mapName, 0L, MemoryMappedFileAccess.ReadWrite, MemoryMappedFileOptions.None, null, inheritability, FileMode.Open);
		}

		/// <summary>Creates a stream that maps to a view of the memory-mapped file.  </summary>
		/// <returns>A stream of memory.</returns>
		/// <exception cref="T:System.UnauthorizedAccessException">Access to the memory-mapped file is unauthorized.</exception>
		public MemoryMappedViewStream CreateViewStream()
		{
			return CreateViewStream(0L, 0L);
		}

		/// <summary>Creates a stream that maps to a view of the memory-mapped file, and that has the specified offset and size.</summary>
		/// <param name="offset">The byte at which to start the view.</param>
		/// <param name="size">The size of the view. Specify 0 (zero) to create a view that starts at <paramref name="offset" /> and ends approximately at the end of the memory-mapped file.</param>
		/// <returns>A stream of memory that has the specified offset and size.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="offset" /> or <paramref name="size" /> is a negative value.-or-
		///         <paramref name="size" /> is greater than the logical address space.</exception>
		/// <exception cref="T:System.UnauthorizedAccessException">Access to the memory-mapped file is unauthorized.</exception>
		/// <exception cref="T:System.IO.IOException">
		///         <paramref name="size" /> is greater than the total virtual memory.</exception>
		public MemoryMappedViewStream CreateViewStream(long offset, long size)
		{
			return CreateViewStream(offset, size, MemoryMappedFileAccess.ReadWrite);
		}

		/// <summary>Creates a stream that maps to a view of the memory-mapped file, and that has the specified offset, size, and access type.</summary>
		/// <param name="offset">The byte at which to start the view.</param>
		/// <param name="size">The size of the view. Specify 0 (zero) to create a view that starts at <paramref name="offset" /> and ends approximately at the end of the memory-mapped file.</param>
		/// <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
		/// <returns>A stream of memory that has the specified characteristics.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="offset" /> or <paramref name="size" /> is a negative value.-or-
		///         <paramref name="size" /> is greater than the logical address space.-or-
		///         <paramref name="access " />is not a valid <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFileAccess" /> enumeration value.</exception>
		/// <exception cref="T:System.UnauthorizedAccessException">
		///         <paramref name="access" /> is invalid for the memory-mapped file.</exception>
		/// <exception cref="T:System.IO.IOException">
		///         <paramref name="size" /> is greater than the total virtual memory.-or-
		///         <paramref name="access" /> is invalid for the memory-mapped file.</exception>
		public MemoryMappedViewStream CreateViewStream(long offset, long size, MemoryMappedFileAccess access)
		{
			return new MemoryMappedViewStream(MemoryMappedView.Create(handle.DangerousGetHandle(), offset, size, access));
		}

		/// <summary>Creates a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> that maps to a view of the memory-mapped file.</summary>
		/// <returns>A randomly accessible block of memory.</returns>
		/// <exception cref="T:System.UnauthorizedAccessException">Access to the memory-mapped file is unauthorized.</exception>
		public MemoryMappedViewAccessor CreateViewAccessor()
		{
			return CreateViewAccessor(0L, 0L);
		}

		/// <summary>Creates a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> that maps to a view of the memory-mapped file, and that has the specified offset and size.</summary>
		/// <param name="offset">The byte at which to start the view.</param>
		/// <param name="size">The size of the view. Specify 0 (zero) to create a view that starts at <paramref name="offset" /> and ends approximately at the end of the memory-mapped file.</param>
		/// <returns>A randomly accessible block of memory.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="offset" /> or <paramref name="size" /> is a negative value.-or-
		///         <paramref name="size" /> is greater than the logical address space.</exception>
		/// <exception cref="T:System.UnauthorizedAccessException">Access to the memory-mapped file is unauthorized.</exception>
		/// <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
		public MemoryMappedViewAccessor CreateViewAccessor(long offset, long size)
		{
			return CreateViewAccessor(offset, size, MemoryMappedFileAccess.ReadWrite);
		}

		/// <summary>Creates a <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor" /> that maps to a view of the memory-mapped file, and that has the specified offset, size, and access restrictions.</summary>
		/// <param name="offset">The byte at which to start the view.</param>
		/// <param name="size">The size of the view. Specify 0 (zero) to create a view that starts at <paramref name="offset" /> and ends approximately at the end of the memory-mapped file.</param>
		/// <param name="access">One of the enumeration values that specifies the type of access allowed to the memory-mapped file. The default is <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.ReadWrite" />.</param>
		/// <returns>A randomly accessible block of memory.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="offset" /> or <paramref name="size" /> is a negative value.-or-
		///         <paramref name="size" /> is greater than the logical address space.</exception>
		/// <exception cref="T:System.UnauthorizedAccessException">
		///         <paramref name="access" /> is invalid for the memory-mapped file.</exception>
		/// <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
		public MemoryMappedViewAccessor CreateViewAccessor(long offset, long size, MemoryMappedFileAccess access)
		{
			return new MemoryMappedViewAccessor(MemoryMappedView.Create(handle.DangerousGetHandle(), offset, size, access));
		}

		private MemoryMappedFile()
		{
		}

		/// <summary>Releases all resources used by the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" />. </summary>
		public void Dispose()
		{
			Dispose(disposing: true);
		}

		/// <summary>Releases the unmanaged resources used by the <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile" /> and optionally releases the managed resources. </summary>
		/// <param name="disposing">
		///       <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources. </param>
		protected virtual void Dispose(bool disposing)
		{
			if (disposing && stream != null)
			{
				if (!keepOpen)
				{
					stream.Close();
				}
				stream = null;
			}
			if (handle != null)
			{
				handle.Dispose();
				handle = null;
			}
		}

		/// <summary>Gets the access control to the memory-mapped file resource.</summary>
		/// <returns>The permissions that can be granted for file access and operations on memory-mapped files.</returns>
		/// <exception cref="T:System.InvalidOperationException">An underlying call to set security information failed.</exception>
		/// <exception cref="T:System.NotSupportedException">An underlying call to set security information failed.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The memory-mapped file is closed.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">The current platform is Windows 98 or earlier.</exception>
		/// <exception cref="T:System.UnauthorizedAccessException">An underlying call to set security information failed.-or-The memory-mapped file was opened as <see cref="F:System.IO.MemoryMappedFiles.MemoryMappedFileAccess.Write" /> only.</exception>
		[MonoTODO]
		public MemoryMappedFileSecurity GetAccessControl()
		{
			throw new NotImplementedException();
		}

		/// <summary>Sets the access control to the memory-mapped file resource.</summary>
		/// <param name="memoryMappedFileSecurity">The permissions that can be granted for file access and operations on memory-mapped files.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="memoryMappedFileSecurity" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">An underlying call to set security information failed.</exception>
		/// <exception cref="T:System.NotSupportedException">An underlying call to set security information failed.</exception>
		/// <exception cref="T:System.UnauthorizedAccessException">An underlying call to set security information failed.</exception>
		[MonoTODO]
		public void SetAccessControl(MemoryMappedFileSecurity memoryMappedFileSecurity)
		{
			throw new NotImplementedException();
		}

		internal static FileAccess GetFileAccess(MemoryMappedFileAccess access)
		{
			return access switch
			{
				MemoryMappedFileAccess.Read => FileAccess.Read, 
				MemoryMappedFileAccess.Write => FileAccess.Write, 
				MemoryMappedFileAccess.ReadWrite => FileAccess.ReadWrite, 
				MemoryMappedFileAccess.CopyOnWrite => FileAccess.ReadWrite, 
				MemoryMappedFileAccess.ReadExecute => FileAccess.Read, 
				MemoryMappedFileAccess.ReadWriteExecute => FileAccess.ReadWrite, 
				_ => throw new ArgumentOutOfRangeException("access"), 
			};
		}
	}
	internal class MemoryMappedView : IDisposable
	{
		private SafeMemoryMappedViewHandle m_viewHandle;

		private long m_pointerOffset;

		private long m_size;

		private MemoryMappedFileAccess m_access;

		internal SafeMemoryMappedViewHandle ViewHandle
		{
			[SecurityCritical]
			get
			{
				return m_viewHandle;
			}
		}

		internal long PointerOffset => m_pointerOffset;

		internal long Size => m_size;

		internal MemoryMappedFileAccess Access => m_access;

		internal bool IsClosed
		{
			get
			{
				if (m_viewHandle != null)
				{
					return m_viewHandle.IsClosed;
				}
				return true;
			}
		}

		[SecurityCritical]
		private MemoryMappedView(SafeMemoryMappedViewHandle viewHandle, long pointerOffset, long size, MemoryMappedFileAccess access)
		{
			m_viewHandle = viewHandle;
			m_pointerOffset = pointerOffset;
			m_size = size;
			m_access = access;
		}

		internal static MemoryMappedView Create(IntPtr handle, long offset, long size, MemoryMappedFileAccess access)
		{
			MemoryMapImpl.Map(handle, offset, ref size, access, out var mmap_handle, out var base_address);
			return new MemoryMappedView(new SafeMemoryMappedViewHandle(mmap_handle, base_address, size), 0L, size, access);
		}

		public void Flush(IntPtr capacity)
		{
			m_viewHandle.Flush();
		}

		protected virtual void Dispose(bool disposing)
		{
			if (m_viewHandle != null && !m_viewHandle.IsClosed)
			{
				m_viewHandle.Dispose();
			}
		}

		public void Dispose()
		{
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}
	}
}
namespace System.IO.Pipes
{
	/// <summary>Exposes the client side of an anonymous pipe stream, which supports both synchronous and asynchronous read and write operations.</summary>
	public sealed class AnonymousPipeClientStream : PipeStream
	{
		/// <summary>Gets the pipe transmission mode supported by the current pipe.</summary>
		/// <returns>The <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> supported by the current pipe.</returns>
		public override PipeTransmissionMode TransmissionMode => PipeTransmissionMode.Byte;

		/// <summary>Sets the reading mode for the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> object.</summary>
		/// <returns>The <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> for the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> object.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The transmission mode is not valid. For anonymous pipes, only <see cref="F:System.IO.Pipes.PipeTransmissionMode.Byte" /> is supported.</exception>
		/// <exception cref="T:System.NotSupportedException">The transmission mode is <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />.</exception>
		/// <exception cref="T:System.IO.IOException">The connection is broken or another I/O error occurs.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		public override PipeTransmissionMode ReadMode
		{
			set
			{
				CheckPipePropertyOperations();
				switch (value)
				{
				default:
					throw new ArgumentOutOfRangeException("value", "For named pipes, transmission mode can be TransmissionMode.Byte or PipeTransmissionMode.Message. For anonymous pipes, transmission mode can be TransmissionMode.Byte.");
				case PipeTransmissionMode.Message:
					throw new NotSupportedException("Anonymous pipes do not support PipeTransmissionMode.Message ReadMode.");
				case PipeTransmissionMode.Byte:
					break;
				}
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> class with the specified string representation of the pipe handle.</summary>
		/// <param name="pipeHandleAsString">A string that represents the pipe handle.</param>
		/// <exception cref="T:System.IO.IOException">
		///         <paramref name="pipeHandleAsString" /> is not a valid pipe handle.</exception>
		public AnonymousPipeClientStream(string pipeHandleAsString)
			: this(PipeDirection.In, pipeHandleAsString)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> class with the specified pipe direction and a string representation of the pipe handle.</summary>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.Anonymous pipes can only be in one direction, so <paramref name="direction" /> cannot be set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</param>
		/// <param name="pipeHandleAsString">A string that represents the pipe handle.</param>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeHandleAsString" /> is an invalid handle.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeHandleAsString" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="direction" /> is set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</exception>
		public AnonymousPipeClientStream(PipeDirection direction, string pipeHandleAsString)
			: base(direction, 0)
		{
			if (direction == PipeDirection.InOut)
			{
				throw new NotSupportedException("Anonymous pipes can only be in one direction.");
			}
			if (pipeHandleAsString == null)
			{
				throw new ArgumentNullException("pipeHandleAsString");
			}
			long result = 0L;
			if (!long.TryParse(pipeHandleAsString, out result))
			{
				throw new ArgumentException("Invalid handle.", "pipeHandleAsString");
			}
			SafePipeHandle safePipeHandle = new SafePipeHandle((IntPtr)result, ownsHandle: true);
			if (safePipeHandle.IsInvalid)
			{
				throw new ArgumentException("Invalid handle.", "pipeHandleAsString");
			}
			Init(direction, safePipeHandle);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> class from the specified handle.</summary>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.Anonymous pipes can only be in one direction, so <paramref name="direction" /> cannot be set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</param>
		/// <param name="safePipeHandle">A safe handle for the pipe that this <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> object will encapsulate.</param>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="safePipeHandle " />is not a valid handle.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="safePipeHandle" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="direction" /> is set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</exception>
		/// <exception cref="T:System.IO.IOException">An I/O error, such as a disk error, has occurred.-or-The stream has been closed.</exception>
		public AnonymousPipeClientStream(PipeDirection direction, SafePipeHandle safePipeHandle)
			: base(direction, 0)
		{
			if (direction == PipeDirection.InOut)
			{
				throw new NotSupportedException("Anonymous pipes can only be in one direction.");
			}
			if (safePipeHandle == null)
			{
				throw new ArgumentNullException("safePipeHandle");
			}
			if (safePipeHandle.IsInvalid)
			{
				throw new ArgumentException("Invalid handle.", "safePipeHandle");
			}
			Init(direction, safePipeHandle);
		}

		private void Init(PipeDirection direction, SafePipeHandle safePipeHandle)
		{
			ValidateHandleIsPipe(safePipeHandle);
			InitializeHandle(safePipeHandle, isExposed: true, isAsync: false);
			base.State = PipeState.Connected;
		}

		/// <summary>Releases unmanaged resources and performs other cleanup operations before the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> instance is reclaimed by garbage collection.</summary>
		~AnonymousPipeClientStream()
		{
			Dispose(disposing: false);
		}
	}
	/// <summary>Exposes a stream around an anonymous pipe, which supports both synchronous and asynchronous read and write operations.</summary>
	public sealed class AnonymousPipeServerStream : PipeStream
	{
		private SafePipeHandle _clientHandle;

		private bool _clientHandleExposed;

		/// <summary>Gets the safe handle for the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> object that is currently connected to the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> object.</summary>
		/// <returns>A handle for the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> object that is currently connected to the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> object.</returns>
		public SafePipeHandle ClientSafePipeHandle
		{
			get
			{
				_clientHandleExposed = true;
				return _clientHandle;
			}
		}

		/// <summary>Gets the pipe transmission mode that is supported by the current pipe.</summary>
		/// <returns>The <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> that is supported by the current pipe.</returns>
		public override PipeTransmissionMode TransmissionMode => PipeTransmissionMode.Byte;

		/// <summary>Sets the reading mode for the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> object. For anonymous pipes, transmission mode must be <see cref="F:System.IO.Pipes.PipeTransmissionMode.Byte" />.</summary>
		/// <returns>The reading mode for the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> object.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The transmission mode is not valid. For anonymous pipes, only <see cref="F:System.IO.Pipes.PipeTransmissionMode.Byte" /> is supported. </exception>
		/// <exception cref="T:System.NotSupportedException">The property is set to <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />, which is not supported for anonymous pipes.</exception>
		/// <exception cref="T:System.IO.IOException">The connection is broken or another I/O error occurs.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		public override PipeTransmissionMode ReadMode
		{
			set
			{
				CheckPipePropertyOperations();
				switch (value)
				{
				default:
					throw new ArgumentOutOfRangeException("value", "For named pipes, transmission mode can be TransmissionMode.Byte or PipeTransmissionMode.Message. For anonymous pipes, transmission mode can be TransmissionMode.Byte.");
				case PipeTransmissionMode.Message:
					throw new NotSupportedException("Anonymous pipes do not support PipeTransmissionMode.Message ReadMode.");
				case PipeTransmissionMode.Byte:
					break;
				}
			}
		}

		private void Create(PipeDirection direction, HandleInheritability inheritability, int bufferSize)
		{
			Create(direction, inheritability, bufferSize, null);
		}

		private void Create(PipeDirection direction, HandleInheritability inheritability, int bufferSize, PipeSecurity pipeSecurity)
		{
			GCHandle pinningHandle = default(GCHandle);
			bool flag;
			SafePipeHandle hWritePipe;
			try
			{
				global::Interop.Kernel32.SECURITY_ATTRIBUTES lpPipeAttributes = PipeStream.GetSecAttrs(inheritability, pipeSecurity, ref pinningHandle);
				flag = ((direction != PipeDirection.In) ? global::Interop.Kernel32.CreatePipe(out _clientHandle, out hWritePipe, ref lpPipeAttributes, bufferSize) : global::Interop.Kernel32.CreatePipe(out hWritePipe, out _clientHandle, ref lpPipeAttributes, bufferSize));
			}
			finally
			{
				if (pinningHandle.IsAllocated)
				{
					pinningHandle.Free();
				}
			}
			if (!flag)
			{
				throw Win32Marshal.GetExceptionForLastWin32Error();
			}
			if (!global::Interop.Kernel32.DuplicateHandle(global::Interop.Kernel32.GetCurrentProcess(), hWritePipe, global::Interop.Kernel32.GetCurrentProcess(), out var lpTargetHandle, 0u, bInheritHandle: false, 2u))
			{
				throw Win32Marshal.GetExceptionForLastWin32Error();
			}
			hWritePipe.Dispose();
			InitializeHandle(lpTargetHandle, isExposed: false, isAsync: false);
			base.State = PipeState.Connected;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> class.</summary>
		public AnonymousPipeServerStream()
			: this(PipeDirection.Out, HandleInheritability.None, 0)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> class with the specified pipe direction.</summary>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.Anonymous pipes can only be in one direction, so <paramref name="direction" /> cannot be set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</param>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="direction" /> is set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</exception>
		public AnonymousPipeServerStream(PipeDirection direction)
			: this(direction, HandleInheritability.None, 0)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> class with the specified pipe direction and inheritability mode.</summary>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.Anonymous pipes can only be in one direction, so <paramref name="direction" /> cannot be set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</param>
		/// <param name="inheritability">One of the enumeration values that determines whether the underlying handle can be inherited by child processes. Must be set to either <see cref="F:System.IO.HandleInheritability.None" /> or <see cref="F:System.IO.HandleInheritability.Inheritable" />. </param>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="inheritability" /> is not set to either <see cref="F:System.IO.HandleInheritability.None" /> or <see cref="F:System.IO.HandleInheritability.Inheritable" />.</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="direction" /> is set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</exception>
		public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability)
			: this(direction, inheritability, 0)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> class from the specified pipe handles.</summary>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.Anonymous pipes can only be in one direction, so <paramref name="direction" /> cannot be set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</param>
		/// <param name="serverSafePipeHandle">A safe handle for the pipe that this <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> object will encapsulate.</param>
		/// <param name="clientSafePipeHandle">A safe handle for the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> object.</param>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="serverSafePipeHandle" /> or <paramref name="clientSafePipeHandle" /> is an invalid handle.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="serverSafePipeHandle" /> or <paramref name="clientSafePipeHandle" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="direction" /> is set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</exception>
		/// <exception cref="T:System.IO.IOException">An I/O error, such as a disk error, has occurred.-or-The stream has been closed.</exception>
		public AnonymousPipeServerStream(PipeDirection direction, SafePipeHandle serverSafePipeHandle, SafePipeHandle clientSafePipeHandle)
			: base(direction, 0)
		{
			if (direction == PipeDirection.InOut)
			{
				throw new NotSupportedException("Anonymous pipes can only be in one direction.");
			}
			if (serverSafePipeHandle == null)
			{
				throw new ArgumentNullException("serverSafePipeHandle");
			}
			if (clientSafePipeHandle == null)
			{
				throw new ArgumentNullException("clientSafePipeHandle");
			}
			if (serverSafePipeHandle.IsInvalid)
			{
				throw new ArgumentException("Invalid handle.", "serverSafePipeHandle");
			}
			if (clientSafePipeHandle.IsInvalid)
			{
				throw new ArgumentException("Invalid handle.", "clientSafePipeHandle");
			}
			ValidateHandleIsPipe(serverSafePipeHandle);
			ValidateHandleIsPipe(clientSafePipeHandle);
			InitializeHandle(serverSafePipeHandle, isExposed: true, isAsync: false);
			_clientHandle = clientSafePipeHandle;
			_clientHandleExposed = true;
			base.State = PipeState.Connected;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> class with the specified pipe direction, inheritability mode, and buffer size.</summary>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.Anonymous pipes can only be in one direction, so <paramref name="direction" /> cannot be set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</param>
		/// <param name="inheritability">One of the enumeration values that determines whether the underlying handle can be inherited by child processes. Must be set to either <see cref="F:System.IO.HandleInheritability.None" /> or <see cref="F:System.IO.HandleInheritability.Inheritable" />.</param>
		/// <param name="bufferSize">The size of the buffer. This value must be greater than or equal to 0. </param>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="inheritability" /> is not set to either <see cref="F:System.IO.HandleInheritability.None" /> or <see cref="F:System.IO.HandleInheritability.Inheritable" />.-or-
		///         <paramref name="bufferSize" /> is less than 0.</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="direction" /> is set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</exception>
		public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability, int bufferSize)
			: base(direction, bufferSize)
		{
			if (direction == PipeDirection.InOut)
			{
				throw new NotSupportedException("Anonymous pipes can only be in one direction.");
			}
			if (inheritability < HandleInheritability.None || inheritability > HandleInheritability.Inheritable)
			{
				throw new ArgumentOutOfRangeException("inheritability", "HandleInheritability.None or HandleInheritability.Inheritable required.");
			}
			Create(direction, inheritability, bufferSize);
		}

		/// <summary>Releases unmanaged resources and performs other cleanup operations before the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> instance is reclaimed by garbage collection.</summary>
		~AnonymousPipeServerStream()
		{
			Dispose(disposing: false);
		}

		/// <summary>Gets the connected <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> object's handle as a string.</summary>
		/// <returns>A string that represents the connected <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> object's handle.</returns>
		public string GetClientHandleAsString()
		{
			_clientHandleExposed = true;
			GC.SuppressFinalize(_clientHandle);
			return _clientHandle.DangerousGetHandle().ToString();
		}

		/// <summary>Closes the local copy of the <see cref="T:System.IO.Pipes.AnonymousPipeClientStream" /> object's handle.</summary>
		public void DisposeLocalCopyOfClientHandle()
		{
			if (_clientHandle != null && !_clientHandle.IsClosed)
			{
				_clientHandle.Dispose();
			}
		}

		protected override void Dispose(bool disposing)
		{
			try
			{
				if (!_clientHandleExposed && _clientHandle != null && !_clientHandle.IsClosed)
				{
					_clientHandle.Dispose();
				}
			}
			finally
			{
				base.Dispose(disposing);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.AnonymousPipeServerStream" /> class with the specified pipe direction, inheritability mode, buffer size, and pipe security.</summary>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.Anonymous pipes can only be in one direction, so <paramref name="direction" /> cannot be set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</param>
		/// <param name="inheritability">One of the enumeration values that determines whether the underlying handle can be inherited by child processes.</param>
		/// <param name="bufferSize">The size of the buffer. This value must be greater than or equal to 0. </param>
		/// <param name="pipeSecurity">An object that determines the access control and audit security for the pipe.</param>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="inheritability" /> is not set to either <see cref="F:System.IO.HandleInheritability.None" /> or <see cref="F:System.IO.HandleInheritability.Inheritable" />.-or-
		///         <paramref name="bufferSize" /> is less than 0.</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="direction" /> is set to <see cref="F:System.IO.Pipes.PipeDirection.InOut" />.</exception>
		public AnonymousPipeServerStream(PipeDirection direction, HandleInheritability inheritability, int bufferSize, PipeSecurity pipeSecurity)
			: base(direction, bufferSize)
		{
			if (direction == PipeDirection.InOut)
			{
				throw new NotSupportedException("Anonymous pipes can only be in one direction.");
			}
			if (inheritability < HandleInheritability.None || inheritability > HandleInheritability.Inheritable)
			{
				throw new ArgumentOutOfRangeException("inheritability", "HandleInheritability.None or HandleInheritability.Inheritable required.");
			}
			Create(direction, inheritability, bufferSize, pipeSecurity);
		}
	}
	internal sealed class ConnectionCompletionSource : PipeCompletionSource<VoidResult>
	{
		private readonly NamedPipeServerStream _serverStream;

		internal ConnectionCompletionSource(NamedPipeServerStream server)
			: base(server._threadPoolBinding, ReadOnlyMemory<byte>.Empty)
		{
			_serverStream = server;
		}

		internal override void SetCompletedSynchronously()
		{
			_serverStream.State = PipeState.Connected;
			TrySetResult(default(VoidResult));
		}

		protected override void AsyncCallback(uint errorCode, uint numBytes)
		{
			if (errorCode == 535)
			{
				errorCode = 0u;
			}
			base.AsyncCallback(errorCode, numBytes);
		}

		protected override void HandleError(int errorCode)
		{
			TrySetException(Win32Marshal.GetExceptionForWin32Error(errorCode));
		}

		protected override void HandleUnexpectedCancellation()
		{
			TrySetException(Error.GetOperationAborted());
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	internal struct VoidResult
	{
	}
	/// <summary>Exposes a <see cref="T:System.IO.Stream" /> around a named pipe, which supports both synchronous and asynchronous read and write operations.</summary>
	public sealed class NamedPipeClientStream : PipeStream
	{
		private const int CancellationCheckInterval = 50;

		private readonly string _normalizedPipePath;

		private readonly TokenImpersonationLevel _impersonationLevel;

		private readonly PipeOptions _pipeOptions;

		private readonly HandleInheritability _inheritability;

		private readonly PipeDirection _direction;

		private int _access;

		/// <summary>Gets the number of server instances that share the same pipe name.</summary>
		/// <returns>The number of server instances that share the same pipe name.</returns>
		/// <exception cref="T:System.InvalidOperationException">The pipe handle has not been set.-or-The current <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> object has not yet connected to a <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> object.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe is broken or an I/O error occurred.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The underlying pipe handle is closed.</exception>
		public int NumberOfServerInstances
		{
			get
			{
				CheckPipePropertyOperations();
				if (!global::Interop.Kernel32.GetNamedPipeHandleState(base.InternalHandle, IntPtr.Zero, out var lpCurInstances, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, 0))
				{
					throw WinIOError(Marshal.GetLastWin32Error());
				}
				return lpCurInstances;
			}
		}

		private bool TryConnect(int timeout, CancellationToken cancellationToken)
		{
			global::Interop.Kernel32.SECURITY_ATTRIBUTES secAttrs = PipeStream.GetSecAttrs(_inheritability);
			int num = (int)(_pipeOptions & ~PipeOptions.CurrentUserOnly);
			if (_impersonationLevel != TokenImpersonationLevel.None)
			{
				num |= 0x100000;
				num |= (int)(_impersonationLevel - 1) << 16;
			}
			int num2 = _access;
			if ((PipeDirection.In & _direction) != 0)
			{
				num2 |= int.MinValue;
			}
			if ((PipeDirection.Out & _direction) != 0)
			{
				num2 |= 0x40000000;
			}
			SafePipeHandle safePipeHandle = global::Interop.Kernel32.CreateNamedPipeClient(_normalizedPipePath, num2, FileShare.None, ref secAttrs, FileMode.Open, num, IntPtr.Zero);
			if (safePipeHandle.IsInvalid)
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (lastWin32Error != 231 && lastWin32Error != 2)
				{
					throw Win32Marshal.GetExceptionForWin32Error(lastWin32Error);
				}
				if (!global::Interop.Kernel32.WaitNamedPipe(_normalizedPipePath, timeout))
				{
					lastWin32Error = Marshal.GetLastWin32Error();
					if (lastWin32Error == 2 || lastWin32Error == 121)
					{
						return false;
					}
					throw Win32Marshal.GetExceptionForWin32Error(lastWin32Error);
				}
				safePipeHandle = global::Interop.Kernel32.CreateNamedPipeClient(_normalizedPipePath, num2, FileShare.None, ref secAttrs, FileMode.Open, num, IntPtr.Zero);
				if (safePipeHandle.IsInvalid)
				{
					lastWin32Error = Marshal.GetLastWin32Error();
					if (lastWin32Error == 231)
					{
						return false;
					}
					throw Win32Marshal.GetExceptionForWin32Error(lastWin32Error);
				}
			}
			InitializeHandle(safePipeHandle, isExposed: false, (_pipeOptions & PipeOptions.Asynchronous) != 0);
			base.State = PipeState.Connected;
			ValidateRemotePipeUser();
			return true;
		}

		private void ValidateRemotePipeUser()
		{
			if (!base.IsCurrentUserOnly)
			{
				return;
			}
			IdentityReference owner = GetAccessControl().GetOwner(typeof(SecurityIdentifier));
			using WindowsIdentity windowsIdentity = WindowsIdentity.GetCurrent();
			SecurityIdentifier owner2 = windowsIdentity.Owner;
			if (owner != owner2)
			{
				base.State = PipeState.Closed;
				throw new UnauthorizedAccessException("Could not connect to the pipe because it was not owned by the current user.");
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> class with the specified pipe name.</summary>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".</exception>
		public NamedPipeClientStream(string pipeName)
			: this(".", pipeName, PipeDirection.InOut, PipeOptions.None, TokenImpersonationLevel.None, HandleInheritability.None)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> class with the specified pipe and server names.</summary>
		/// <param name="serverName">The name of the remote computer to connect to, or "." to specify the local computer.</param>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> or <paramref name="serverName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> or <paramref name="serverName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".</exception>
		public NamedPipeClientStream(string serverName, string pipeName)
			: this(serverName, pipeName, PipeDirection.InOut, PipeOptions.None, TokenImpersonationLevel.None, HandleInheritability.None)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> class with the specified pipe and server names, and the specified pipe direction.</summary>
		/// <param name="serverName">The name of the remote computer to connect to, or "." to specify the local computer.</param>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> or <paramref name="serverName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> or <paramref name="serverName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".-or-
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.</exception>
		public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction)
			: this(serverName, pipeName, direction, PipeOptions.None, TokenImpersonationLevel.None, HandleInheritability.None)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> class with the specified pipe and server names, and the specified pipe direction and pipe options.</summary>
		/// <param name="serverName">The name of the remote computer to connect to, or "." to specify the local computer.</param>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
		/// <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> or <paramref name="serverName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> or <paramref name="serverName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".-or-
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.-or-
		///         <paramref name="options" /> is not a valid <see cref="T:System.IO.Pipes.PipeOptions" /> value.</exception>
		public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options)
			: this(serverName, pipeName, direction, options, TokenImpersonationLevel.None, HandleInheritability.None)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> class with the specified pipe and server names, and the specified pipe direction, pipe options, and security impersonation level.</summary>
		/// <param name="serverName">The name of the remote computer to connect to, or "." to specify the local computer.</param>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
		/// <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
		/// <param name="impersonationLevel">One of the enumeration values that determines the security impersonation level.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> or <paramref name="serverName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> or <paramref name="serverName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".-or-
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.-or-
		///         <paramref name="options" /> is not a valid <see cref="T:System.IO.Pipes.PipeOptions" /> value.-or-
		///         <paramref name="impersonationLevel" /> is not a valid <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> value.</exception>
		public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel)
			: this(serverName, pipeName, direction, options, impersonationLevel, HandleInheritability.None)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> class with the specified pipe and server names, and the specified pipe direction, pipe options, security impersonation level, and inheritability mode.</summary>
		/// <param name="serverName">The name of the remote computer to connect to, or "." to specify the local computer.</param>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
		/// <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
		/// <param name="impersonationLevel">One of the enumeration values that determines the security impersonation level.</param>
		/// <param name="inheritability">One of the enumeration values that determines whether the underlying handle will be inheritable by child processes.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> or <paramref name="serverName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> or <paramref name="serverName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".-or-
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.-or-
		///         <paramref name="options" /> is not a valid <see cref="T:System.IO.Pipes.PipeOptions" /> value.-or-
		///         <paramref name="impersonationLevel" /> is not a valid <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> value.-or-
		///         <paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> value.</exception>
		public NamedPipeClientStream(string serverName, string pipeName, PipeDirection direction, PipeOptions options, TokenImpersonationLevel impersonationLevel, HandleInheritability inheritability)
			: base(direction, 0)
		{
			if (pipeName == null)
			{
				throw new ArgumentNullException("pipeName");
			}
			if (serverName == null)
			{
				throw new ArgumentNullException("serverName", "serverName cannot be null. Use \\\".\\\" for current machine.");
			}
			if (pipeName.Length == 0)
			{
				throw new ArgumentException("pipeName cannot be an empty string.");
			}
			if (serverName.Length == 0)
			{
				throw new ArgumentException("serverName cannot be an empty string.  Use \\\\\\\".\\\\\\\" for current machine.");
			}
			if ((options & (PipeOptions)536870911) != PipeOptions.None)
			{
				throw new ArgumentOutOfRangeException("options", "options contains an invalid flag.");
			}
			if (impersonationLevel < TokenImpersonationLevel.None || impersonationLevel > TokenImpersonationLevel.Delegation)
			{
				throw new ArgumentOutOfRangeException("impersonationLevel", "TokenImpersonationLevel.None, TokenImpersonationLevel.Anonymous, TokenImpersonationLevel.Identification, TokenImpersonationLevel.Impersonation or TokenImpersonationLevel.Delegation required.");
			}
			if (inheritability < HandleInheritability.None || inheritability > HandleInheritability.Inheritable)
			{
				throw new ArgumentOutOfRangeException("inheritability", "HandleInheritability.None or HandleInheritability.Inheritable required.");
			}
			if ((options & PipeOptions.CurrentUserOnly) != PipeOptions.None)
			{
				base.IsCurrentUserOnly = true;
			}
			_normalizedPipePath = PipeStream.GetPipePath(serverName, pipeName);
			_direction = direction;
			_inheritability = inheritability;
			_impersonationLevel = impersonationLevel;
			_pipeOptions = options;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> class for the specified pipe handle with the specified pipe direction.</summary>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
		/// <param name="isAsync">
		///       <see langword="true" /> to indicate that the handle was opened asynchronously; otherwise, <see langword="false" />.</param>
		/// <param name="isConnected">
		///       <see langword="true" /> to indicate that the pipe is connected; otherwise, <see langword="false" />.</param>
		/// <param name="safePipeHandle">A safe handle for the pipe that this <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> object will encapsulate.</param>
		/// <exception cref="T:System.IO.IOException">
		///         <paramref name="safePipeHandle" /> is not a valid handle.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="safePipeHandle" /> is not a valid handle.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="safePipeHandle" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.</exception>
		/// <exception cref="T:System.IO.IOException">The stream has been closed. </exception>
		public NamedPipeClientStream(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle)
			: base(direction, 0)
		{
			if (safePipeHandle == null)
			{
				throw new ArgumentNullException("safePipeHandle");
			}
			if (safePipeHandle.IsInvalid)
			{
				throw new ArgumentException("Invalid handle.", "safePipeHandle");
			}
			ValidateHandleIsPipe(safePipeHandle);
			InitializeHandle(safePipeHandle, isExposed: true, isAsync);
			if (isConnected)
			{
				base.State = PipeState.Connected;
			}
		}

		/// <summary>Releases unmanaged resources and performs other cleanup operations before the <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> instance is reclaimed by garbage collection.</summary>
		~NamedPipeClientStream()
		{
			Dispose(disposing: false);
		}

		/// <summary>Connects to a waiting server with an infinite time-out value.</summary>
		/// <exception cref="T:System.InvalidOperationException">The client is already connected.</exception>
		public void Connect()
		{
			Connect(-1);
		}

		/// <summary>Connects to a waiting server within the specified time-out period.</summary>
		/// <param name="timeout">The number of milliseconds to wait for the server to respond before the connection times out.</param>
		/// <exception cref="T:System.TimeoutException">Could not connect to the server within the specified <paramref name="timeout" /> period.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="timeout" /> is less than 0 and not set to <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The client is already connected.</exception>
		/// <exception cref="T:System.IO.IOException">The server is connected to another client and the time-out period has expired.</exception>
		public void Connect(int timeout)
		{
			CheckConnectOperationsClient();
			if (timeout < 0 && timeout != -1)
			{
				throw new ArgumentOutOfRangeException("timeout", "Timeout must be non-negative or equal to -1 (Timeout.Infinite)");
			}
			ConnectInternal(timeout, CancellationToken.None, Environment.TickCount);
		}

		private void ConnectInternal(int timeout, CancellationToken cancellationToken, int startTime)
		{
			int num = 0;
			SpinWait spinWait = default(SpinWait);
			do
			{
				cancellationToken.ThrowIfCancellationRequested();
				int num2 = timeout - num;
				if (cancellationToken.CanBeCanceled && num2 > 50)
				{
					num2 = 50;
				}
				if (TryConnect(num2, cancellationToken))
				{
					return;
				}
				spinWait.SpinOnce();
			}
			while (timeout == -1 || (num = Environment.TickCount - startTime) < timeout);
			throw new TimeoutException();
		}

		/// <summary>Asynchronously connects to a waiting server with an infinite timeout period.</summary>
		/// <returns>A task that represents the asynchronous connect operation.</returns>
		public Task ConnectAsync()
		{
			return ConnectAsync(-1, CancellationToken.None);
		}

		/// <summary>Asynchronously connects to a waiting server within the specified timeout period.</summary>
		/// <param name="timeout">The number of milliseconds to wait for the server to respond before the connection times out.</param>
		/// <returns>A task that represents the asynchronous connect operation.</returns>
		public Task ConnectAsync(int timeout)
		{
			return ConnectAsync(timeout, CancellationToken.None);
		}

		/// <summary>Asynchronously connects to a waiting server and monitors cancellation requests.</summary>
		/// <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />.</param>
		/// <returns>A task that represents the asynchronous connect operation.</returns>
		public Task ConnectAsync(CancellationToken cancellationToken)
		{
			return ConnectAsync(-1, cancellationToken);
		}

		/// <summary>Asynchronously connects to a waiting server within the specified timeout period and monitors cancellation requests.</summary>
		/// <param name="timeout">The number of milliseconds to wait for the server to respond before the connection times out.</param>
		/// <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />.</param>
		/// <returns>A task that represents the asynchronous connect operation.</returns>
		public Task ConnectAsync(int timeout, CancellationToken cancellationToken)
		{
			CheckConnectOperationsClient();
			if (timeout < 0 && timeout != -1)
			{
				throw new ArgumentOutOfRangeException("timeout", "Timeout must be non-negative or equal to -1 (Timeout.Infinite)");
			}
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled(cancellationToken);
			}
			int startTime = Environment.TickCount;
			return Task.Run(delegate
			{
				ConnectInternal(timeout, cancellationToken, startTime);
			}, cancellationToken);
		}

		protected internal override void CheckPipePropertyOperations()
		{
			base.CheckPipePropertyOperations();
			if (base.State == PipeState.WaitingToConnect)
			{
				throw new InvalidOperationException("Pipe hasn't been connected yet.");
			}
			if (base.State == PipeState.Broken)
			{
				throw new IOException("Pipe is broken.");
			}
		}

		private void CheckConnectOperationsClient()
		{
			if (base.State == PipeState.Connected)
			{
				throw new InvalidOperationException("Already in a connected state.");
			}
			if (base.State == PipeState.Closed)
			{
				throw Error.GetPipeNotOpen();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeClientStream" /> class with the specified pipe and server names, and the specified pipe options, security impersonation level, and inheritability mode.</summary>
		/// <param name="serverName">The name of the remote computer to connect to, or "." to specify the local computer.</param>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <param name="desiredAccessRights">One of the enumeration values that specifies the desired access rights of the pipe.</param>
		/// <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
		/// <param name="impersonationLevel">One of the enumeration values that determines the security impersonation level.</param>
		/// <param name="inheritability">One of the enumeration values that determines whether the underlying handle will be inheritable by child processes.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> or <paramref name="serverName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> or <paramref name="serverName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".-or-
		///         <paramref name="options" /> is not a valid <see cref="T:System.IO.Pipes.PipeOptions" /> value.-or-
		///         <paramref name="impersonationLevel" /> is not a valid <see cref="T:System.Security.Principal.TokenImpersonationLevel" /> value.-or-
		///         <paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> value.</exception>
		public NamedPipeClientStream(string serverName, string pipeName, PipeAccessRights desiredAccessRights, PipeOptions options, TokenImpersonationLevel impersonationLevel, HandleInheritability inheritability)
			: this(serverName, pipeName, (PipeDirection)(desiredAccessRights & (PipeAccessRights.ReadData | PipeAccessRights.WriteData)), options, impersonationLevel, inheritability)
		{
			if ((desiredAccessRights & ~(PipeAccessRights.FullControl | PipeAccessRights.AccessSystemSecurity)) != 0)
			{
				throw new ArgumentOutOfRangeException("desiredAccessRights", "Invalid PipeAccessRights flag.");
			}
			_access = (int)desiredAccessRights;
		}
	}
	/// <summary>Exposes a <see cref="T:System.IO.Stream" /> around a named pipe, supporting both synchronous and asynchronous read and write operations.</summary>
	public sealed class NamedPipeServerStream : PipeStream
	{
		internal class ExecuteHelper
		{
			internal PipeStreamImpersonationWorker _userCode;

			internal SafePipeHandle _handle;

			internal bool _mustRevert;

			internal int _impersonateErrorCode;

			internal int _revertImpersonateErrorCode;

			internal ExecuteHelper(PipeStreamImpersonationWorker userCode, SafePipeHandle handle)
			{
				_userCode = userCode;
				_handle = handle;
			}
		}

		private static RuntimeHelpers.TryCode tryCode = ImpersonateAndTryCode;

		private static RuntimeHelpers.CleanupCode cleanupCode = RevertImpersonationOnBackout;

		/// <summary>Represents the maximum number of server instances that the system resources allow.</summary>
		public const int MaxAllowedServerInstances = -1;

		private void Create(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, HandleInheritability inheritability)
		{
			Create(pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, null, inheritability, (PipeAccessRights)0);
		}

		private void Create(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability, PipeAccessRights additionalAccessRights)
		{
			string fullPath = Path.GetFullPath("\\\\.\\pipe\\" + pipeName);
			if (string.Equals(fullPath, "\\\\.\\pipe\\anonymous", StringComparison.OrdinalIgnoreCase))
			{
				throw new ArgumentOutOfRangeException("pipeName", "The pipeName \\\"anonymous\\\" is reserved.");
			}
			if (base.IsCurrentUserOnly)
			{
				using (WindowsIdentity windowsIdentity = WindowsIdentity.GetCurrent())
				{
					SecurityIdentifier owner = windowsIdentity.Owner;
					PipeAccessRule rule = new PipeAccessRule(owner, PipeAccessRights.FullControl, AccessControlType.Allow);
					pipeSecurity = new PipeSecurity();
					pipeSecurity.AddAccessRule(rule);
					pipeSecurity.SetOwner(owner);
				}
				options &= ~PipeOptions.CurrentUserOnly;
			}
			int openMode = (int)((uint)direction | (uint)((maxNumberOfServerInstances == 1) ? 524288 : 0) | (uint)options) | (int)additionalAccessRights;
			int pipeMode = ((int)transmissionMode << 2) | ((int)transmissionMode << 1);
			if (maxNumberOfServerInstances == -1)
			{
				maxNumberOfServerInstances = 255;
			}
			GCHandle pinningHandle = default(GCHandle);
			try
			{
				global::Interop.Kernel32.SECURITY_ATTRIBUTES securityAttributes = PipeStream.GetSecAttrs(inheritability, pipeSecurity, ref pinningHandle);
				SafePipeHandle safePipeHandle = global::Interop.Kernel32.CreateNamedPipe(fullPath, openMode, pipeMode, maxNumberOfServerInstances, outBufferSize, inBufferSize, 0, ref securityAttributes);
				if (safePipeHandle.IsInvalid)
				{
					throw Win32Marshal.GetExceptionForLastWin32Error();
				}
				InitializeHandle(safePipeHandle, isExposed: false, (options & PipeOptions.Asynchronous) != 0);
			}
			finally
			{
				if (pinningHandle.IsAllocated)
				{
					pinningHandle.Free();
				}
			}
		}

		/// <summary>Waits for a client to connect to this <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> object.</summary>
		/// <exception cref="T:System.InvalidOperationException">A pipe connection has already been established.-or-The pipe handle has not been set.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe connection has been broken.</exception>
		public void WaitForConnection()
		{
			CheckConnectOperationsServerWithHandle();
			if (base.IsAsync)
			{
				WaitForConnectionCoreAsync(CancellationToken.None).GetAwaiter().GetResult();
				return;
			}
			if (!global::Interop.Kernel32.ConnectNamedPipe(base.InternalHandle, IntPtr.Zero))
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				if (lastWin32Error != 535)
				{
					throw Win32Marshal.GetExceptionForWin32Error(lastWin32Error);
				}
				if (lastWin32Error == 535 && base.State == PipeState.Connected)
				{
					throw new InvalidOperationException("Already in a connected state.");
				}
			}
			base.State = PipeState.Connected;
		}

		/// <summary>Asynchronously waits for a client to connect to this <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> object and monitors cancellation requests.</summary>
		/// <param name="cancellationToken">The token to monitor for cancellation requests.</param>
		/// <returns>A task that represents the asynchronous wait operation.</returns>
		public Task WaitForConnectionAsync(CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled(cancellationToken);
			}
			if (!base.IsAsync)
			{
				return Task.Factory.StartNew(delegate(object s)
				{
					((NamedPipeServerStream)s).WaitForConnection();
				}, this, cancellationToken, TaskCreationOptions.DenyChildAttach, TaskScheduler.Default);
			}
			return WaitForConnectionCoreAsync(cancellationToken);
		}

		/// <summary>Disconnects the current connection.</summary>
		/// <exception cref="T:System.InvalidOperationException">No pipe connections have been made yet.-or-The connected pipe has already disconnected.-or-The pipe handle has not been set.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		public void Disconnect()
		{
			CheckDisconnectOperations();
			if (!global::Interop.Kernel32.DisconnectNamedPipe(base.InternalHandle))
			{
				throw Win32Marshal.GetExceptionForLastWin32Error();
			}
			base.State = PipeState.Disconnected;
		}

		/// <summary>Gets the user name of the client on the other end of the pipe.</summary>
		/// <returns>The user name of the client on the other end of the pipe.</returns>
		/// <exception cref="T:System.InvalidOperationException">No pipe connections have been made yet.-or-The connected pipe has already disconnected.-or-The pipe handle has not been set.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe connection has been broken.-or-The user name of the client is longer than 19 characters.</exception>
		public string GetImpersonationUserName()
		{
			CheckWriteOperations();
			StringBuilder stringBuilder = new StringBuilder(514);
			if (!global::Interop.Kernel32.GetNamedPipeHandleState(base.InternalHandle, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, stringBuilder, stringBuilder.Capacity))
			{
				throw WinIOError(Marshal.GetLastWin32Error());
			}
			return stringBuilder.ToString();
		}

		/// <summary>Calls a delegate while impersonating the client.</summary>
		/// <param name="impersonationWorker">The delegate that specifies a method to call.</param>
		/// <exception cref="T:System.InvalidOperationException">No pipe connections have been made yet.-or-The connected pipe has already disconnected.-or-The pipe handle has not been set.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe connection has been broken.-or-An I/O error occurred.</exception>
		public void RunAsClient(PipeStreamImpersonationWorker impersonationWorker)
		{
			CheckWriteOperations();
			ExecuteHelper executeHelper = new ExecuteHelper(impersonationWorker, base.InternalHandle);
			RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(tryCode, cleanupCode, executeHelper);
			if (executeHelper._impersonateErrorCode != 0)
			{
				throw WinIOError(executeHelper._impersonateErrorCode);
			}
			if (executeHelper._revertImpersonateErrorCode != 0)
			{
				throw WinIOError(executeHelper._revertImpersonateErrorCode);
			}
		}

		private static void ImpersonateAndTryCode(object helper)
		{
			ExecuteHelper executeHelper = (ExecuteHelper)helper;
			RuntimeHelpers.PrepareConstrainedRegions();
			try
			{
			}
			finally
			{
				if (global::Interop.Advapi32.ImpersonateNamedPipeClient(executeHelper._handle))
				{
					executeHelper._mustRevert = true;
				}
				else
				{
					executeHelper._impersonateErrorCode = Marshal.GetLastWin32Error();
				}
			}
			if (executeHelper._mustRevert)
			{
				executeHelper._userCode();
			}
		}

		private static void RevertImpersonationOnBackout(object helper, bool exceptionThrown)
		{
			ExecuteHelper executeHelper = (ExecuteHelper)helper;
			if (executeHelper._mustRevert && !global::Interop.Advapi32.RevertToSelf())
			{
				executeHelper._revertImpersonateErrorCode = Marshal.GetLastWin32Error();
			}
		}

		private unsafe Task WaitForConnectionCoreAsync(CancellationToken cancellationToken)
		{
			CheckConnectOperationsServerWithHandle();
			if (!base.IsAsync)
			{
				throw new InvalidOperationException("Pipe is not opened in asynchronous mode.");
			}
			ConnectionCompletionSource connectionCompletionSource = new ConnectionCompletionSource(this);
			if (!global::Interop.Kernel32.ConnectNamedPipe(base.InternalHandle, connectionCompletionSource.Overlapped))
			{
				int lastWin32Error = Marshal.GetLastWin32Error();
				switch (lastWin32Error)
				{
				case 535:
					connectionCompletionSource.ReleaseResources();
					if (base.State == PipeState.Connected)
					{
						throw new InvalidOperationException("Already in a connected state.");
					}
					connectionCompletionSource.SetCompletedSynchronously();
					return Task.CompletedTask;
				default:
					connectionCompletionSource.ReleaseResources();
					throw Win32Marshal.GetExceptionForWin32Error(lastWin32Error);
				case 997:
					break;
				}
			}
			connectionCompletionSource.RegisterForCancellation(cancellationToken);
			return connectionCompletionSource.Task;
		}

		private void CheckConnectOperationsServerWithHandle()
		{
			if (base.InternalHandle == null)
			{
				throw new InvalidOperationException("Pipe handle has not been set.  Did your PipeStream implementation call InitializeHandle?");
			}
			CheckConnectOperationsServer();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> class with the specified pipe name.</summary>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="pipeName" /> contains a colon (":").</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported. </exception>
		/// <exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
		public NamedPipeServerStream(string pipeName)
			: this(pipeName, PipeDirection.InOut, 1, PipeTransmissionMode.Byte, PipeOptions.None, 0, 0, HandleInheritability.None)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> class with the specified pipe name and pipe direction.</summary>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".-or-
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="pipeName" /> contains a colon (":").</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception>
		/// <exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
		public NamedPipeServerStream(string pipeName, PipeDirection direction)
			: this(pipeName, direction, 1, PipeTransmissionMode.Byte, PipeOptions.None, 0, 0, HandleInheritability.None)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> class with the specified pipe name, pipe direction, and maximum number of server instances.</summary>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
		/// <param name="maxNumberOfServerInstances">The maximum number of server instances that share the same name. You can pass <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" /> for this value.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".-or-
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.-or-A non-negative number is required.-or-
		///         <paramref name="maxNumberofServerInstances" /> is less than -1 or greater than 254 (-1 indicates <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />)-or-
		///
		///         <see cref="F:System.IO.HandleInheritability.None" /> or <see cref="F:System.IO.HandleInheritability.Inheritable" /> is required.-or-Access rights is limited to the <see cref="F:System.IO.Pipes.PipeAccessRights.ChangePermissions" /> , <see cref="F:System.IO.Pipes.PipeAccessRights.TakeOwnership" /> , and <see cref="F:System.IO.Pipes.PipeAccessRights.AccessSystemSecurity" /> flags.</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="pipeName" /> contains a colon (":").</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception>
		/// <exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
		public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances)
			: this(pipeName, direction, maxNumberOfServerInstances, PipeTransmissionMode.Byte, PipeOptions.None, 0, 0, HandleInheritability.None)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> class with the specified pipe name, pipe direction, maximum number of server instances, and transmission mode.</summary>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
		/// <param name="maxNumberOfServerInstances">The maximum number of server instances that share the same name. You can pass <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" /> for this value.</param>
		/// <param name="transmissionMode">One of the enumeration values that determines the transmission mode of the pipe.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".-or-
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.-or-
		///         <paramref name="maxNumberofServerInstances" /> is less than -1 or greater than 254 (-1 indicates <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />)</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="pipeName" /> contains a colon (":").</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception>
		/// <exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
		public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode)
			: this(pipeName, direction, maxNumberOfServerInstances, transmissionMode, PipeOptions.None, 0, 0, HandleInheritability.None)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> class with the specified pipe name, pipe direction, maximum number of server instances, transmission mode, and pipe options.</summary>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
		/// <param name="maxNumberOfServerInstances">The maximum number of server instances that share the same name. You can pass <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" /> for this value.</param>
		/// <param name="transmissionMode">One of the enumeration values that determines the transmission mode of the pipe.</param>
		/// <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".-or-
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.-or-
		///         <paramref name="maxNumberofServerInstances" /> is less than -1 or greater than 254 (-1 indicates <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />)-or-
		///         <paramref name="options" /> is not a valid <see cref="T:System.IO.Pipes.PipeOptions" /> value.</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="pipeName" /> contains a colon (":").</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception>
		/// <exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
		public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options)
			: this(pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, 0, 0, HandleInheritability.None)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> class with the specified pipe name, pipe direction, maximum number of server instances, transmission mode, pipe options, and recommended in and out buffer sizes.</summary>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
		/// <param name="maxNumberOfServerInstances">The maximum number of server instances that share the same name. You can pass <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" /> for this value.</param>
		/// <param name="transmissionMode">One of the enumeration values that determines the transmission mode of the pipe.</param>
		/// <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
		/// <param name="inBufferSize">A positive value greater than 0 that indicates the input buffer size.</param>
		/// <param name="outBufferSize">A positive value greater than 0 that indicates the output buffer size.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".-or-
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.-or-
		///         <paramref name="maxNumberofServerInstances" /> is less than -1 or greater than 254 (-1 indicates <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />)-or-
		///         <paramref name="options" /> is not a valid <see cref="T:System.IO.Pipes.PipeOptions" /> value.-or-
		///         <paramref name="inBufferSize" /> is negative.</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="pipeName" /> contains a colon (":").</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception>
		/// <exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
		public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize)
			: this(pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, HandleInheritability.None)
		{
		}

		private NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, HandleInheritability inheritability)
			: base(direction, transmissionMode, outBufferSize)
		{
			if (pipeName == null)
			{
				throw new ArgumentNullException("pipeName");
			}
			if (pipeName.Length == 0)
			{
				throw new ArgumentException("pipeName cannot be an empty string.");
			}
			if ((options & (PipeOptions)536870911) != PipeOptions.None)
			{
				throw new ArgumentOutOfRangeException("options", "options contains an invalid flag.");
			}
			if (inBufferSize < 0)
			{
				throw new ArgumentOutOfRangeException("inBufferSize", "Non negative number is required.");
			}
			if ((maxNumberOfServerInstances < 1 || maxNumberOfServerInstances > 254) && maxNumberOfServerInstances != -1)
			{
				throw new ArgumentOutOfRangeException("maxNumberOfServerInstances", "maxNumberOfServerInstances must either be a value between 1 and 254, or NamedPipeServerStream.MaxAllowedServerInstances (to obtain the maximum number allowed by system resources).");
			}
			if (inheritability < HandleInheritability.None || inheritability > HandleInheritability.Inheritable)
			{
				throw new ArgumentOutOfRangeException("inheritability", "HandleInheritability.None or HandleInheritability.Inheritable required.");
			}
			if ((options & PipeOptions.CurrentUserOnly) != PipeOptions.None)
			{
				base.IsCurrentUserOnly = true;
			}
			Create(pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, inheritability);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> class from the specified pipe handle.</summary>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
		/// <param name="isAsync">
		///       <see langword="true" /> to indicate that the handle was opened asynchronously; otherwise, <see langword="false" />.</param>
		/// <param name="isConnected">
		///       <see langword="true" /> to indicate that the pipe is connected; otherwise, <see langword="false" />.</param>
		/// <param name="safePipeHandle">A safe handle for the pipe that this <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> object will encapsulate.</param>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="safePipeHandle" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="safePipeHandle" /> is an invalid handle.</exception>
		/// <exception cref="T:System.IO.IOException">
		///         <paramref name="safePipeHandle" /> is not a valid pipe handle.-or-The maximum number of server instances has been exceeded.</exception>
		public NamedPipeServerStream(PipeDirection direction, bool isAsync, bool isConnected, SafePipeHandle safePipeHandle)
			: base(direction, PipeTransmissionMode.Byte, 0)
		{
			if (safePipeHandle == null)
			{
				throw new ArgumentNullException("safePipeHandle");
			}
			if (safePipeHandle.IsInvalid)
			{
				throw new ArgumentException("Invalid handle.", "safePipeHandle");
			}
			ValidateHandleIsPipe(safePipeHandle);
			InitializeHandle(safePipeHandle, isExposed: true, isAsync);
			if (isConnected)
			{
				base.State = PipeState.Connected;
			}
		}

		/// <summary>Releases unmanaged resources and performs other cleanup operations before the <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> instance is reclaimed by garbage collection.</summary>
		~NamedPipeServerStream()
		{
			Dispose(disposing: false);
		}

		/// <summary>Asynchronously waits for a client to connect to this <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> object.</summary>
		/// <returns>A task that represents the asynchronous wait operation.</returns>
		public Task WaitForConnectionAsync()
		{
			return WaitForConnectionAsync(CancellationToken.None);
		}

		/// <summary>Begins an asynchronous operation to wait for a client to connect.</summary>
		/// <param name="callback">The method to call when a client connects to the <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> object.</param>
		/// <param name="state">A user-provided object that distinguishes this particular asynchronous request from other requests.</param>
		/// <returns>An object that references the asynchronous request.</returns>
		/// <exception cref="T:System.InvalidOperationException">The pipe was not opened asynchronously.-or-A pipe connection has already been established.-or-The pipe handle has not been set.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe connection has been broken.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		public IAsyncResult BeginWaitForConnection(AsyncCallback callback, object state)
		{
			return TaskToApm.Begin(WaitForConnectionAsync(), callback, state);
		}

		/// <summary>Ends an asynchronous operation to wait for a client to connect.</summary>
		/// <param name="asyncResult">The pending asynchronous request.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="asyncResult" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.InvalidOperationException">The pipe was not opened asynchronously.-or-The pipe handle has not been set.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe connection has been broken.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		public void EndWaitForConnection(IAsyncResult asyncResult)
		{
			TaskToApm.End(asyncResult);
		}

		private void CheckConnectOperationsServer()
		{
			if (base.State == PipeState.Closed)
			{
				throw Error.GetPipeNotOpen();
			}
			if (base.InternalHandle != null && base.InternalHandle.IsClosed)
			{
				throw Error.GetPipeNotOpen();
			}
			if (base.State == PipeState.Broken)
			{
				throw new IOException("Pipe is broken.");
			}
		}

		private void CheckDisconnectOperations()
		{
			if (base.State == PipeState.WaitingToConnect)
			{
				throw new InvalidOperationException("Pipe hasn't been connected yet.");
			}
			if (base.State == PipeState.Disconnected)
			{
				throw new InvalidOperationException("Already in a disconnected state.");
			}
			if (base.InternalHandle == null)
			{
				throw new InvalidOperationException("Pipe handle has not been set.  Did your PipeStream implementation call InitializeHandle?");
			}
			if (base.State == PipeState.Closed || (base.InternalHandle != null && base.InternalHandle.IsClosed))
			{
				throw Error.GetPipeNotOpen();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> class with the specified pipe name, pipe direction, maximum number of server instances, transmission mode, pipe options, recommended in and out buffer sizes, and pipe security.</summary>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
		/// <param name="maxNumberOfServerInstances">The maximum number of server instances that share the same name. You can pass <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" /> for this value.</param>
		/// <param name="transmissionMode">One of the enumeration values that determines the transmission mode of the pipe.</param>
		/// <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
		/// <param name="inBufferSize">A positive value greater than 0 that indicates the input buffer size.</param>
		/// <param name="outBufferSize">A positive value greater than 0 that indicates the output buffer size.</param>
		/// <param name="pipeSecurity">An object that determines the access control and audit security for the pipe.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".-or-
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.-or-
		///         <paramref name="maxNumberofServerInstances" />  is less than -1 or greater than 254 (-1 indicates <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />)-or-
		///         <paramref name="options" /> is not a valid <see cref="T:System.IO.Pipes.PipeOptions" /> value.-or-
		///         <paramref name="inBufferSize" /> is negative.</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="pipeName" /> contains a colon (":").</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception>
		/// <exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
		public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity)
			: this(pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, HandleInheritability.None)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> class with the specified pipe name, pipe direction, maximum number of server instances, transmission mode, pipe options, recommended in and out buffer sizes, pipe security, and inheritability mode.</summary>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
		/// <param name="maxNumberOfServerInstances">The maximum number of server instances that share the same name. You can pass <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" /> for this value.</param>
		/// <param name="transmissionMode">One of the enumeration values that determines the transmission mode of the pipe.</param>
		/// <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
		/// <param name="inBufferSize">A positive value greater than 0 that indicates the input buffer size.</param>
		/// <param name="outBufferSize">A positive value greater than 0 that indicates the output buffer size.</param>
		/// <param name="pipeSecurity">An object that determines the access control and audit security for the pipe.</param>
		/// <param name="inheritability">One of the enumeration values that determines whether the underlying handle can be inherited by child processes.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".-or-
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.-or-
		///         <paramref name="maxNumberofServerInstances" /> is less than -1 or greater than 254 (-1 indicates <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />)-or-
		///         <paramref name="options" /> is not a valid <see cref="T:System.IO.Pipes.PipeOptions" /> value.-or-
		///         <paramref name="inBufferSize" /> is negative.-or-
		///         <paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> value.</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="pipeName" /> contains a colon (":").</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception>
		/// <exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
		public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability)
			: this(pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, inheritability)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.NamedPipeServerStream" /> class with the specified pipe name, pipe direction, maximum number of server instances, transmission mode, pipe options, recommended in and out buffer sizes, pipe security, inheritability mode, and pipe access rights.</summary>
		/// <param name="pipeName">The name of the pipe.</param>
		/// <param name="direction">One of the enumeration values that determines the direction of the pipe.</param>
		/// <param name="maxNumberOfServerInstances">The maximum number of server instances that share the same name. You can pass <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" /> for this value.</param>
		/// <param name="transmissionMode">One of the enumeration values that determines the transmission mode of the pipe.</param>
		/// <param name="options">One of the enumeration values that determines how to open or create the pipe.</param>
		/// <param name="inBufferSize">The input buffer size.</param>
		/// <param name="outBufferSize">The output buffer size.</param>
		/// <param name="pipeSecurity">An object that determines the access control and audit security for the pipe.</param>
		/// <param name="inheritability">One of the enumeration values that determines whether the underlying handle can be inherited by child processes.</param>
		/// <param name="additionalAccessRights">One of the enumeration values that specifies the access rights of the pipe.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeName" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="pipeName" /> is a zero-length string.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="pipeName" /> is set to "anonymous".-or-
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.-or-
		///         <paramref name="maxNumberofServerInstances" /> is less than -1 or greater than 254 (-1 indicates <see cref="F:System.IO.Pipes.NamedPipeServerStream.MaxAllowedServerInstances" />)-or-
		///         <paramref name="options" /> is not a valid <see cref="T:System.IO.Pipes.PipeOptions" /> value.-or-
		///         <paramref name="inBufferSize" /> is negative.-or-
		///         <paramref name="inheritability" /> is not a valid <see cref="T:System.IO.HandleInheritability" /> value.-or-
		///         <paramref name="additionalAccessRights" /> is not a valid <see cref="T:System.IO.Pipes.PipeAccessRights" /> value.</exception>
		/// <exception cref="T:System.NotSupportedException">
		///         <paramref name="pipeName" /> contains a colon (":").</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">The operating system is Windows Millennium Edition, Windows 98, or Windows 95, which are not supported.</exception>
		/// <exception cref="T:System.IO.IOException">The maximum number of server instances has been exceeded.</exception>
		public NamedPipeServerStream(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize, PipeSecurity pipeSecurity, HandleInheritability inheritability, PipeAccessRights additionalAccessRights)
			: base(direction, transmissionMode, outBufferSize)
		{
			if (pipeName == null)
			{
				throw new ArgumentNullException("pipeName");
			}
			if (pipeName.Length == 0)
			{
				throw new ArgumentException("pipeName cannot be an empty string.");
			}
			if ((options & (PipeOptions)1073741823) != PipeOptions.None)
			{
				throw new ArgumentOutOfRangeException("options", "options contains an invalid flag.");
			}
			if (inBufferSize < 0)
			{
				throw new ArgumentOutOfRangeException("inBufferSize", "Non negative number is required.");
			}
			if ((maxNumberOfServerInstances < 1 || maxNumberOfServerInstances > 254) && maxNumberOfServerInstances != -1)
			{
				throw new ArgumentOutOfRangeException("maxNumberOfServerInstances", "maxNumberOfServerInstances must either be a value between 1 and 254, or NamedPipeServerStream.MaxAllowedServerInstances (to obtain the maximum number allowed by system resources).");
			}
			if (inheritability < HandleInheritability.None || inheritability > HandleInheritability.Inheritable)
			{
				throw new ArgumentOutOfRangeException("inheritability", "HandleInheritability.None or HandleInheritability.Inheritable required.");
			}
			if ((additionalAccessRights & ~(PipeAccessRights.ChangePermissions | PipeAccessRights.TakeOwnership | PipeAccessRights.AccessSystemSecurity)) != 0)
			{
				throw new ArgumentOutOfRangeException("additionalAccessRights", "additionalAccessRights is limited to the PipeAccessRights.ChangePermissions, PipeAccessRights.TakeOwnership, and PipeAccessRights.AccessSystemSecurity flags when creating NamedPipeServerStreams.");
			}
			Create(pipeName, direction, maxNumberOfServerInstances, transmissionMode, options, inBufferSize, outBufferSize, pipeSecurity, inheritability, additionalAccessRights);
		}
	}
	/// <summary>Represents the method to call as the client.</summary>
	public delegate void PipeStreamImpersonationWorker();
	/// <summary>Defines the access rights to use when you create access and audit rules.</summary>
	[Flags]
	public enum PipeAccessRights
	{
		/// <summary>Specifies the right to read data from the pipe. This does not include the right to read file system attributes, extended file system attributes, or access and audit rules.</summary>
		ReadData = 1,
		/// <summary>Specifies the right to write data to a pipe. This does not include the right to write file system attributes or extended file system attributes.</summary>
		WriteData = 2,
		/// <summary>Specifies the right to read file system attributes from a pipe. This does not include the right to read data, extended file system attributes, or access and audit rules.</summary>
		ReadAttributes = 0x80,
		/// <summary>Specifies the right to write file system attributes to a pipe. This does not include the right to write data or extended file system attributes.</summary>
		WriteAttributes = 0x100,
		/// <summary>Specifies the right to read extended file system attributes from a pipe. This does not include the right to read data, file system attributes, or access and audit rules.</summary>
		ReadExtendedAttributes = 8,
		/// <summary>Specifies the right to write extended file system attributes to a pipe. This does not include the right to write file attributes or data.</summary>
		WriteExtendedAttributes = 0x10,
		/// <summary>Specifies the right to create a new pipe. Setting this right also sets the <see cref="F:System.IO.Pipes.PipeAccessRights.Synchronize" /> right.</summary>
		CreateNewInstance = 4,
		/// <summary>Specifies the right to delete a pipe.</summary>
		Delete = 0x10000,
		/// <summary>Specifies the right to read access and audit rules from the pipe. This does not include the right to read data, file system attributes, or extended file system attributes.</summary>
		ReadPermissions = 0x20000,
		/// <summary>Specifies the right to change the security and audit rules that are associated with a pipe.</summary>
		ChangePermissions = 0x40000,
		/// <summary>Specifies the right to change the owner of a pipe. Note that owners of a pipe have full access to that resource.</summary>
		TakeOwnership = 0x80000,
		/// <summary>Specifies whether the application can wait for a pipe handle to synchronize with the completion of an I/O operation.</summary>
		Synchronize = 0x100000,
		/// <summary>Specifies the right to exert full control over a pipe, and to modify access control and audit rules. This value represents the combination of all rights in this enumeration.</summary>
		FullControl = 0x1F019F,
		/// <summary>Specifies the right to read from the pipe. This right includes the <see cref="F:System.IO.Pipes.PipeAccessRights.ReadAttributes" />, <see cref="F:System.IO.Pipes.PipeAccessRights.ReadData" />, <see cref="F:System.IO.Pipes.PipeAccessRights.ReadExtendedAttributes" />, and <see cref="F:System.IO.Pipes.PipeAccessRights.ReadPermissions" /> rights.</summary>
		Read = 0x20089,
		/// <summary>Specifies the right to write to the pipe. This right includes the <see cref="F:System.IO.Pipes.PipeAccessRights.WriteAttributes" />, <see cref="F:System.IO.Pipes.PipeAccessRights.WriteData" />, and <see cref="F:System.IO.Pipes.PipeAccessRights.WriteExtendedAttributes" /> rights.</summary>
		Write = 0x112,
		/// <summary>Specifies the right to read and write from the pipe. This right includes the <see cref="F:System.IO.Pipes.PipeAccessRights.ReadAttributes" />, <see cref="F:System.IO.Pipes.PipeAccessRights.ReadData" />, <see cref="F:System.IO.Pipes.PipeAccessRights.ReadExtendedAttributes" />, <see cref="F:System.IO.Pipes.PipeAccessRights.ReadPermissions" />, <see cref="F:System.IO.Pipes.PipeAccessRights.WriteAttributes" />, <see cref="F:System.IO.Pipes.PipeAccessRights.WriteData" />, and <see cref="F:System.IO.Pipes.PipeAccessRights.WriteExtendedAttributes" /> rights.</summary>
		ReadWrite = 0x2019B,
		/// <summary>Specifies the right to make changes to the system access control list (SACL).</summary>
		AccessSystemSecurity = 0x1000000
	}
	/// <summary>Represents an abstraction of an access control entry (ACE) that defines an access rule for a pipe.</summary>
	public sealed class PipeAccessRule : AccessRule
	{
		/// <summary>Gets the <see cref="T:System.IO.Pipes.PipeAccessRights" /> flags that are associated with the current <see cref="T:System.IO.Pipes.PipeAccessRule" /> object.</summary>
		/// <returns>A bitwise combination of the <see cref="T:System.IO.Pipes.PipeAccessRights" /> values.</returns>
		public PipeAccessRights PipeAccessRights => RightsFromAccessMask(base.AccessMask);

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeAccessRule" /> class with the specified identity, pipe access rights, and access control type.</summary>
		/// <param name="identity">The name of the user account.</param>
		/// <param name="rights">One of the <see cref="T:System.IO.Pipes.PipeAccessRights" /> values that specifies the type of operation associated with the access rule.</param>
		/// <param name="type">One of the <see cref="T:System.Security.AccessControl.AccessControlType" /> values that specifies whether to allow or deny the operation.</param>
		public PipeAccessRule(string identity, PipeAccessRights rights, AccessControlType type)
			: this(new NTAccount(identity), AccessMaskFromRights(rights, type), isInherited: false, type)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeAccessRule" /> class with the specified identity, pipe access rights, and access control type.</summary>
		/// <param name="identity">An <see cref="T:System.Security.Principal.IdentityReference" /> object that encapsulates a reference to a user account.</param>
		/// <param name="rights">One of the <see cref="T:System.IO.Pipes.PipeAccessRights" /> values that specifies the type of operation associated with the access rule.</param>
		/// <param name="type">One of the <see cref="T:System.Security.AccessControl.AccessControlType" /> values that specifies whether to allow or deny the operation.</param>
		public PipeAccessRule(IdentityReference identity, PipeAccessRights rights, AccessControlType type)
			: this(identity, AccessMaskFromRights(rights, type), isInherited: false, type)
		{
		}

		internal PipeAccessRule(IdentityReference identity, int accessMask, bool isInherited, AccessControlType type)
			: base(identity, accessMask, isInherited, InheritanceFlags.None, PropagationFlags.None, type)
		{
		}

		internal static int AccessMaskFromRights(PipeAccessRights rights, AccessControlType controlType)
		{
			if (rights < (PipeAccessRights)0 || rights > (PipeAccessRights.FullControl | PipeAccessRights.AccessSystemSecurity))
			{
				throw new ArgumentOutOfRangeException("rights", "Invalid PipeAccessRights value.");
			}
			switch (controlType)
			{
			case AccessControlType.Allow:
				rights |= PipeAccessRights.Synchronize;
				break;
			case AccessControlType.Deny:
				if (rights != PipeAccessRights.FullControl)
				{
					rights &= ~PipeAccessRights.Synchronize;
				}
				break;
			}
			return (int)rights;
		}

		internal static PipeAccessRights RightsFromAccessMask(int accessMask)
		{
			return (PipeAccessRights)accessMask;
		}
	}
	/// <summary>Represents an abstraction of an access control entry (ACE) that defines an audit rule for a pipe.</summary>
	public sealed class PipeAuditRule : AuditRule
	{
		/// <summary>Gets the <see cref="T:System.IO.Pipes.PipeAccessRights" /> flags that are associated with the current <see cref="T:System.IO.Pipes.PipeAuditRule" /> object.</summary>
		/// <returns>A bitwise combination of the <see cref="T:System.IO.Pipes.PipeAccessRights" /> values. </returns>
		public PipeAccessRights PipeAccessRights => PipeAccessRule.RightsFromAccessMask(base.AccessMask);

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeAuditRule" /> class for a user account specified in a <see cref="T:System.Security.Principal.IdentityReference" /> object.</summary>
		/// <param name="identity">An <see cref="T:System.Security.Principal.IdentityReference" /> object that encapsulates a reference to a user account.</param>
		/// <param name="rights">One of the <see cref="T:System.IO.Pipes.PipeAccessRights" /> values that specifies the type of operation associated with the access rule.</param>
		/// <param name="flags">One of the <see cref="T:System.Security.AccessControl.AuditFlags" /> values that specifies when to perform auditing.</param>
		public PipeAuditRule(IdentityReference identity, PipeAccessRights rights, AuditFlags flags)
			: this(identity, AccessMaskFromRights(rights), isInherited: false, flags)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeAuditRule" /> class for a named user account.</summary>
		/// <param name="identity">The name of the user account.</param>
		/// <param name="rights">One of the <see cref="T:System.IO.Pipes.PipeAccessRights" /> values that specifies the type of operation associated with the access rule.</param>
		/// <param name="flags">One of the <see cref="T:System.Security.AccessControl.AuditFlags" /> values that specifies when to perform auditing.</param>
		public PipeAuditRule(string identity, PipeAccessRights rights, AuditFlags flags)
			: this(new NTAccount(identity), AccessMaskFromRights(rights), isInherited: false, flags)
		{
		}

		internal PipeAuditRule(IdentityReference identity, int accessMask, bool isInherited, AuditFlags flags)
			: base(identity, accessMask, isInherited, InheritanceFlags.None, PropagationFlags.None, flags)
		{
		}

		private static int AccessMaskFromRights(PipeAccessRights rights)
		{
			if (rights < (PipeAccessRights)0 || rights > (PipeAccessRights.FullControl | PipeAccessRights.AccessSystemSecurity))
			{
				throw new ArgumentOutOfRangeException("rights", "Invalid PipeAccessRights value.");
			}
			return (int)rights;
		}
	}
	internal abstract class PipeCompletionSource<TResult> : TaskCompletionSource<TResult>
	{
		private const int NoResult = 0;

		private const int ResultSuccess = 1;

		private const int ResultError = 2;

		private const int RegisteringCancellation = 4;

		private const int CompletedCallback = 8;

		private readonly ThreadPoolBoundHandle _threadPoolBinding;

		private CancellationTokenRegistration _cancellationRegistration;

		private int _errorCode;

		private unsafe NativeOverlapped* _overlapped;

		private MemoryHandle _pinnedMemory;

		private int _state;

		internal unsafe NativeOverlapped* Overlapped => _overlapped;

		protected unsafe PipeCompletionSource(ThreadPoolBoundHandle handle, ReadOnlyMemory<byte> bufferToPin)
			: base(TaskCreationOptions.RunContinuationsAsynchronously)
		{
			_threadPoolBinding = handle;
			_state = 0;
			_pinnedMemory = bufferToPin.Pin();
			_overlapped = _threadPoolBinding.AllocateNativeOverlapped(delegate(uint errorCode, uint numBytes, NativeOverlapped* pOverlapped)
			{
				((PipeCompletionSource<TResult>)ThreadPoolBoundHandle.GetNativeOverlappedState(pOverlapped)).AsyncCallback(errorCode, numBytes);
			}, this, null);
		}

		internal unsafe void RegisterForCancellation(CancellationToken cancellationToken)
		{
			if (!cancellationToken.CanBeCanceled || Overlapped == null)
			{
				return;
			}
			int num = Interlocked.CompareExchange(ref _state, 4, 0);
			switch (num)
			{
			case 0:
				_cancellationRegistration = cancellationToken.Register(delegate(object thisRef)
				{
					((PipeCompletionSource<TResult>)thisRef).Cancel();
				}, this);
				num = Interlocked.Exchange(ref _state, 0);
				break;
			default:
				num = Interlocked.Exchange(ref _state, 0);
				break;
			case 8:
				break;
			}
			if ((num & 3) != 0)
			{
				CompleteCallback(num);
			}
		}

		internal unsafe void ReleaseResources()
		{
			_cancellationRegistration.Dispose();
			if (_overlapped != null)
			{
				_threadPoolBinding.FreeNativeOverlapped(Overlapped);
				_overlapped = null;
			}
			_pinnedMemory.Dispose();
		}

		internal abstract void SetCompletedSynchronously();

		protected virtual void AsyncCallback(uint errorCode, uint numBytes)
		{
			int num;
			if (errorCode == 0)
			{
				num = 1;
			}
			else
			{
				num = 2;
				_errorCode = (int)errorCode;
			}
			if (Interlocked.Exchange(ref _state, num) == 0 && Interlocked.Exchange(ref _state, 8) != 0)
			{
				CompleteCallback(num);
			}
		}

		protected abstract void HandleError(int errorCode);

		private unsafe void Cancel()
		{
			SafeHandle handle = _threadPoolBinding.Handle;
			NativeOverlapped* overlapped = Overlapped;
			if (!handle.IsInvalid && !global::Interop.Kernel32.CancelIoEx(handle, overlapped))
			{
				Marshal.GetLastWin32Error();
			}
		}

		protected virtual void HandleUnexpectedCancellation()
		{
			TrySetCanceled();
		}

		private void CompleteCallback(int resultState)
		{
			CancellationToken token = _cancellationRegistration.Token;
			ReleaseResources();
			if (resultState == 2)
			{
				if (_errorCode == 995)
				{
					if (token.CanBeCanceled && !token.IsCancellationRequested)
					{
						HandleUnexpectedCancellation();
					}
					else
					{
						TrySetCanceled(token);
					}
				}
				else
				{
					HandleError(_errorCode);
				}
			}
			else
			{
				SetCompletedSynchronously();
			}
		}
	}
	/// <summary>Specifies the direction of the pipe.</summary>
	public enum PipeDirection
	{
		/// <summary>Specifies that the pipe direction is in.</summary>
		In = 1,
		/// <summary>Specifies that the pipe direction is out.</summary>
		Out,
		/// <summary>Specifies that the pipe direction is two-way.</summary>
		InOut
	}
	/// <summary>Provides options for creating a <see cref="T:System.IO.Pipes.PipeStream" /> object. This enumeration has a <see cref="T:System.FlagsAttribute" /> attribute that allows a bitwise combination of its member values.</summary>
	[Flags]
	public enum PipeOptions
	{
		/// <summary>Indicates that there are no additional parameters.</summary>
		None = 0,
		/// <summary>Indicates that the system should write through any intermediate cache and go directly to the pipe.</summary>
		WriteThrough = int.MinValue,
		/// <summary>Indicates that the pipe can be used for asynchronous reading and writing.</summary>
		Asynchronous = 0x40000000,
		CurrentUserOnly = 0x20000000
	}
	/// <summary>Represents the access control and audit security for a pipe.</summary>
	public class PipeSecurity : NativeObjectSecurity
	{
		/// <summary>Gets the <see cref="T:System.Type" /> of the securable object that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
		/// <returns>The type of the securable object that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</returns>
		public override Type AccessRightType => typeof(PipeAccessRights);

		/// <summary>Gets the <see cref="T:System.Type" /> of the object that is associated with the access rules of the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
		/// <returns>The type of the object that is associated with the access rules of the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</returns>
		public override Type AccessRuleType => typeof(PipeAccessRule);

		/// <summary>Gets the <see cref="T:System.Type" /> object associated with the audit rules of the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
		/// <returns>The type of the object that is associated with the audit rules of the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</returns>
		public override Type AuditRuleType => typeof(PipeAuditRule);

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeSecurity" /> class.</summary>
		public PipeSecurity()
			: base(isContainer: false, ResourceType.KernelObject)
		{
		}

		internal PipeSecurity(SafePipeHandle safeHandle, AccessControlSections includeSections)
			: base(isContainer: false, ResourceType.KernelObject, safeHandle, includeSections)
		{
		}

		/// <summary>Adds an access rule to the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
		/// <param name="rule">The access rule to add.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
		public void AddAccessRule(PipeAccessRule rule)
		{
			if (rule == null)
			{
				throw new ArgumentNullException("rule");
			}
			AddAccessRule((AccessRule)rule);
		}

		/// <summary>Sets an access rule in the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
		/// <param name="rule">The rule to set.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
		public void SetAccessRule(PipeAccessRule rule)
		{
			if (rule == null)
			{
				throw new ArgumentNullException("rule");
			}
			SetAccessRule((AccessRule)rule);
		}

		/// <summary>Removes all access rules in the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object and then adds the specified access rule.</summary>
		/// <param name="rule">The access rule to add.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
		public void ResetAccessRule(PipeAccessRule rule)
		{
			if (rule == null)
			{
				throw new ArgumentNullException("rule");
			}
			ResetAccessRule((AccessRule)rule);
		}

		/// <summary>Removes an access rule from the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
		/// <param name="rule">The access rule to remove.</param>
		/// <returns>
		///     <see langword="true" /> if the operation is successful; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
		public bool RemoveAccessRule(PipeAccessRule rule)
		{
			if (rule == null)
			{
				throw new ArgumentNullException("rule");
			}
			AuthorizationRuleCollection accessRules = GetAccessRules(includeExplicit: true, includeInherited: true, rule.IdentityReference.GetType());
			for (int i = 0; i < accessRules.Count; i++)
			{
				if (accessRules[i] is PipeAccessRule pipeAccessRule && pipeAccessRule.PipeAccessRights == rule.PipeAccessRights && pipeAccessRule.IdentityReference == rule.IdentityReference && pipeAccessRule.AccessControlType == rule.AccessControlType)
				{
					return RemoveAccessRule((AccessRule)rule);
				}
			}
			if (rule.PipeAccessRights != PipeAccessRights.FullControl)
			{
				return RemoveAccessRule((AccessRule)new PipeAccessRule(rule.IdentityReference, PipeAccessRule.AccessMaskFromRights(rule.PipeAccessRights, AccessControlType.Deny), isInherited: false, rule.AccessControlType));
			}
			return RemoveAccessRule((AccessRule)rule);
		}

		/// <summary>Removes the specified access rule from the Discretionary Access Control List (DACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
		/// <param name="rule">The access rule to remove.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
		public void RemoveAccessRuleSpecific(PipeAccessRule rule)
		{
			if (rule == null)
			{
				throw new ArgumentNullException("rule");
			}
			AuthorizationRuleCollection accessRules = GetAccessRules(includeExplicit: true, includeInherited: true, rule.IdentityReference.GetType());
			for (int i = 0; i < accessRules.Count; i++)
			{
				if (accessRules[i] is PipeAccessRule pipeAccessRule && pipeAccessRule.PipeAccessRights == rule.PipeAccessRights && pipeAccessRule.IdentityReference == rule.IdentityReference && pipeAccessRule.AccessControlType == rule.AccessControlType)
				{
					RemoveAccessRuleSpecific((AccessRule)rule);
					return;
				}
			}
			if (rule.PipeAccessRights != PipeAccessRights.FullControl)
			{
				RemoveAccessRuleSpecific((AccessRule)new PipeAccessRule(rule.IdentityReference, PipeAccessRule.AccessMaskFromRights(rule.PipeAccessRights, AccessControlType.Deny), isInherited: false, rule.AccessControlType));
			}
			else
			{
				RemoveAccessRuleSpecific((AccessRule)rule);
			}
		}

		/// <summary>Adds an audit rule to the System Access Control List (SACL)that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
		/// <param name="rule">The audit rule to add.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
		public void AddAuditRule(PipeAuditRule rule)
		{
			AddAuditRule((AuditRule)rule);
		}

		/// <summary>Sets an audit rule in the System Access Control List (SACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
		/// <param name="rule">The rule to set.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
		public void SetAuditRule(PipeAuditRule rule)
		{
			SetAuditRule((AuditRule)rule);
		}

		/// <summary>Removes an audit rule from the System Access Control List (SACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
		/// <param name="rule">The audit rule to remove.</param>
		/// <returns>
		///     <see langword="true" /> if the audit rule was removed; otherwise, <see langword="false" /></returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
		public bool RemoveAuditRule(PipeAuditRule rule)
		{
			return RemoveAuditRule((AuditRule)rule);
		}

		/// <summary>Removes all audit rules that have the same security identifier as the specified audit rule from the System Access Control List (SACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
		/// <param name="rule">The audit rule to remove.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
		public void RemoveAuditRuleAll(PipeAuditRule rule)
		{
			RemoveAuditRuleAll((AuditRule)rule);
		}

		/// <summary>Removes the specified audit rule from the System Access Control List (SACL) that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object.</summary>
		/// <param name="rule">The audit rule to remove.</param>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="rule" /> parameter is <see langword="null" />.</exception>
		public void RemoveAuditRuleSpecific(PipeAuditRule rule)
		{
			RemoveAuditRuleSpecific((AuditRule)rule);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.AccessControl.AccessRule" /> class with the specified values.</summary>
		/// <param name="identityReference">The identity that the access rule applies to. It must be an object that can be cast as a <see cref="T:System.Security.Principal.SecurityIdentifier" /> object.</param>
		/// <param name="accessMask">The access mask of this rule. The access mask is a 32-bit collection of anonymous bits, the meaning of which is defined by the individual integrators</param>
		/// <param name="isInherited">
		///       <see langword="true" /> if this rule is inherited from a parent container; otherwise false.</param>
		/// <param name="inheritanceFlags">One of the <see cref="T:System.Security.AccessControl.InheritanceFlags" /> values that specifies the inheritance properties of the access rule.</param>
		/// <param name="propagationFlags">One of the <see cref="T:System.Security.AccessControl.PropagationFlags" /> values that specifies whether inherited access rules are automatically propagated. The propagation flags are ignored if <paramref name="inheritanceFlags" /> is set to <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
		/// <param name="type">Specifies the valid access control type.</param>
		/// <returns>The <see cref="T:System.Security.AccessControl.AccessRule" /> object that this method creates.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" />, or <paramref name="type" /> specifies an invalid value.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="identityReference" /> is <see langword="null" />. -or-
		///         <paramref name="accessMask" /> is zero.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="identityReference" /> is neither of type <see cref="T:System.Security.Principal.SecurityIdentifier" /> nor of a type, such as <see cref="T:System.Security.Principal.NTAccount" />, that can be converted to type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
		public override AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type)
		{
			if (inheritanceFlags != InheritanceFlags.None)
			{
				throw new ArgumentException("This flag may not be set on a pipe.", "inheritanceFlags");
			}
			if (propagationFlags != PropagationFlags.None)
			{
				throw new ArgumentException("This flag may not be set on a pipe.", "propagationFlags");
			}
			return new PipeAccessRule(identityReference, accessMask, isInherited, type);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.AccessControl.AuditRule" /> class with the specified values.</summary>
		/// <param name="identityReference">The identity that the access rule applies to. It must be an object that can be cast as a <see cref="T:System.Security.Principal.SecurityIdentifier" /> object.</param>
		/// <param name="accessMask">The access mask of this rule. The access mask is a 32-bit collection of anonymous bits, the meaning of which is defined by the individual integrators</param>
		/// <param name="isInherited">
		///       <see langword="true" /> if this rule is inherited from a parent container; otherwise, false..</param>
		/// <param name="inheritanceFlags">One of the <see cref="T:System.Security.AccessControl.InheritanceFlags" /> values that specifies the inheritance properties of the access rule.</param>
		/// <param name="propagationFlags">One of the <see cref="T:System.Security.AccessControl.PropagationFlags" /> values that specifies whether inherited access rules are automatically propagated. The propagation flags are ignored if <paramref name="inheritanceFlags" /> is set to <see cref="F:System.Security.AccessControl.InheritanceFlags.None" />.</param>
		/// <param name="flags">One of the <see cref="T:System.Security.AccessControl.AuditFlags" /> values that specifies the valid access control type.</param>
		/// <returns>The <see cref="T:System.Security.AccessControl.AuditRule" /> object that this method creates.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="accessMask" />, <paramref name="inheritanceFlags" />, <paramref name="propagationFlags" />, or <paramref name="flags" /> properties specify an invalid value.</exception>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="identityReference" /> property is <see langword="null" />. -or-The <paramref name="accessMask" /> property is zero.</exception>
		/// <exception cref="T:System.ArgumentException">The <paramref name="identityReference" /> property is neither of type <see cref="T:System.Security.Principal.SecurityIdentifier" /> nor of a type, such as <see cref="T:System.Security.Principal.NTAccount" />, that can be converted to type <see cref="T:System.Security.Principal.SecurityIdentifier" />.</exception>
		public sealed override AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags)
		{
			if (inheritanceFlags != InheritanceFlags.None)
			{
				throw new ArgumentException("This flag may not be set on a pipe.", "inheritanceFlags");
			}
			if (propagationFlags != PropagationFlags.None)
			{
				throw new ArgumentException("This flag may not be set on a pipe.", "propagationFlags");
			}
			return new PipeAuditRule(identityReference, accessMask, isInherited, flags);
		}

		private AccessControlSections GetAccessControlSectionsFromChanges()
		{
			AccessControlSections accessControlSections = AccessControlSections.None;
			if (base.AccessRulesModified)
			{
				accessControlSections = AccessControlSections.Access;
			}
			if (base.AuditRulesModified)
			{
				accessControlSections |= AccessControlSections.Audit;
			}
			if (base.OwnerModified)
			{
				accessControlSections |= AccessControlSections.Owner;
			}
			if (base.GroupModified)
			{
				accessControlSections |= AccessControlSections.Group;
			}
			return accessControlSections;
		}

		/// <summary>Saves the specified sections of the security descriptor that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object to permanent storage.</summary>
		/// <param name="handle">The handle of the securable object that the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object is associated with.</param>
		protected internal void Persist(SafeHandle handle)
		{
			WriteLock();
			try
			{
				AccessControlSections accessControlSectionsFromChanges = GetAccessControlSectionsFromChanges();
				Persist(handle, accessControlSectionsFromChanges);
				bool flag = (base.AccessRulesModified = false);
				bool flag3 = (base.AuditRulesModified = flag);
				bool ownerModified = (base.GroupModified = flag3);
				base.OwnerModified = ownerModified;
			}
			finally
			{
				WriteUnlock();
			}
		}

		/// <summary>Saves the specified sections of the security descriptor that is associated with the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object to permanent storage.</summary>
		/// <param name="name">The name of the securable object that the current <see cref="T:System.IO.Pipes.PipeSecurity" /> object is associated with.</param>
		protected internal void Persist(string name)
		{
			WriteLock();
			try
			{
				AccessControlSections accessControlSectionsFromChanges = GetAccessControlSectionsFromChanges();
				Persist(name, accessControlSectionsFromChanges);
				bool flag = (base.AccessRulesModified = false);
				bool flag3 = (base.AuditRulesModified = flag);
				bool ownerModified = (base.GroupModified = flag3);
				base.OwnerModified = ownerModified;
			}
			finally
			{
				WriteUnlock();
			}
		}
	}
	internal enum PipeState
	{
		WaitingToConnect,
		Connected,
		Broken,
		Disconnected,
		Closed
	}
	/// <summary>Exposes a <see cref="T:System.IO.Stream" /> object around a pipe, which supports both anonymous and named pipes.</summary>
	public abstract class PipeStream : Stream
	{
		internal const bool CheckOperationsRequiresSetHandle = true;

		internal ThreadPoolBoundHandle _threadPoolBinding;

		internal const string AnonymousPipeName = "anonymous";

		private static readonly Task<int> s_zeroTask = Task.FromResult(0);

		private SafePipeHandle _handle;

		private bool _canRead;

		private bool _canWrite;

		private bool _isAsync;

		private bool _isCurrentUserOnly;

		private bool _isMessageComplete;

		private bool _isFromExistingHandle;

		private bool _isHandleExposed;

		private PipeTransmissionMode _readMode;

		private PipeTransmissionMode _transmissionMode;

		private PipeDirection _pipeDirection;

		private int _outBufferSize;

		private PipeState _state;

		/// <summary>Gets the pipe transmission mode supported by the current pipe.</summary>
		/// <returns>One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates the transmission mode supported by the current pipe.</returns>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		/// <exception cref="T:System.InvalidOperationException">The handle has not been set.-or-The pipe is waiting to connect in an anonymous client/server operation or with a named client. </exception>
		/// <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
		public virtual PipeTransmissionMode TransmissionMode
		{
			get
			{
				CheckPipePropertyOperations();
				if (_isFromExistingHandle)
				{
					if (!global::Interop.Kernel32.GetNamedPipeInfo(_handle, out var lpFlags, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero))
					{
						throw WinIOError(Marshal.GetLastWin32Error());
					}
					if ((lpFlags & 4) != 0)
					{
						return PipeTransmissionMode.Message;
					}
					return PipeTransmissionMode.Byte;
				}
				return _transmissionMode;
			}
		}

		/// <summary>Gets the size, in bytes, of the inbound buffer for a pipe.</summary>
		/// <returns>An integer value that represents the inbound buffer size, in bytes.</returns>
		/// <exception cref="T:System.NotSupportedException">The stream is unreadable.</exception>
		/// <exception cref="T:System.InvalidOperationException">The pipe is waiting to connect.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
		public virtual int InBufferSize
		{
			get
			{
				CheckPipePropertyOperations();
				if (!CanRead)
				{
					throw new NotSupportedException("Stream does not support reading.");
				}
				if (!global::Interop.Kernel32.GetNamedPipeInfo(_handle, IntPtr.Zero, IntPtr.Zero, out var lpInBufferSize, IntPtr.Zero))
				{
					throw WinIOError(Marshal.GetLastWin32Error());
				}
				return lpInBufferSize;
			}
		}

		/// <summary>Gets the size, in bytes, of the outbound buffer for a pipe.</summary>
		/// <returns>The outbound buffer size, in bytes.</returns>
		/// <exception cref="T:System.NotSupportedException">The stream is unwriteable.</exception>
		/// <exception cref="T:System.InvalidOperationException">The pipe is waiting to connect.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
		public virtual int OutBufferSize
		{
			get
			{
				CheckPipePropertyOperations();
				if (!CanWrite)
				{
					throw new NotSupportedException("Stream does not support writing.");
				}
				if (_pipeDirection == PipeDirection.Out)
				{
					return _outBufferSize;
				}
				if (!global::Interop.Kernel32.GetNamedPipeInfo(_handle, IntPtr.Zero, out var lpOutBufferSize, IntPtr.Zero, IntPtr.Zero))
				{
					throw WinIOError(Marshal.GetLastWin32Error());
				}
				return lpOutBufferSize;
			}
		}

		/// <summary>Gets or sets the reading mode for a <see cref="T:System.IO.Pipes.PipeStream" /> object.</summary>
		/// <returns>One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates how the <see cref="T:System.IO.Pipes.PipeStream" /> object reads from the pipe.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The supplied value is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value.</exception>
		/// <exception cref="T:System.NotSupportedException">The supplied value is not a supported <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value for this pipe stream.</exception>
		/// <exception cref="T:System.InvalidOperationException">The handle has not been set.-or-The pipe is waiting to connect with a named client.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe is broken or an I/O error occurred with a named client.</exception>
		public unsafe virtual PipeTransmissionMode ReadMode
		{
			get
			{
				CheckPipePropertyOperations();
				if (_isFromExistingHandle || IsHandleExposed)
				{
					UpdateReadMode();
				}
				return _readMode;
			}
			set
			{
				CheckPipePropertyOperations();
				if (value < PipeTransmissionMode.Byte || value > PipeTransmissionMode.Message)
				{
					throw new ArgumentOutOfRangeException("value", "For named pipes, transmission mode can be TransmissionMode.Byte or PipeTransmissionMode.Message. For anonymous pipes, transmission mode can be TransmissionMode.Byte.");
				}
				int num = (int)value << 1;
				if (!global::Interop.Kernel32.SetNamedPipeHandleState(_handle, &num, IntPtr.Zero, IntPtr.Zero))
				{
					throw WinIOError(Marshal.GetLastWin32Error());
				}
				_readMode = value;
			}
		}

		/// <summary>Gets or sets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" /> object is connected.</summary>
		/// <returns>
		///     <see langword="true" /> if the <see cref="T:System.IO.Pipes.PipeStream" /> object is connected; otherwise, <see langword="false" />.</returns>
		public bool IsConnected
		{
			get
			{
				return State == PipeState.Connected;
			}
			protected set
			{
				_state = (value ? PipeState.Connected : PipeState.Disconnected);
			}
		}

		/// <summary>Gets a value indicating whether a <see cref="T:System.IO.Pipes.PipeStream" /> object was opened asynchronously or synchronously.</summary>
		/// <returns>
		///     <see langword="true" /> if the <see cref="T:System.IO.Pipes.PipeStream" /> object was opened asynchronously; otherwise, <see langword="false" />.</returns>
		public bool IsAsync => _isAsync;

		/// <summary>Gets a value indicating whether there is more data in the message returned from the most recent read operation.</summary>
		/// <returns>
		///     <see langword="true" /> if there are no more characters to read in the message; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.InvalidOperationException">The pipe is not connected.-or-The pipe handle has not been set.-or-The pipe's <see cref="P:System.IO.Pipes.PipeStream.ReadMode" /> property value is not <see cref="F:System.IO.Pipes.PipeTransmissionMode.Message" />.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		public bool IsMessageComplete
		{
			get
			{
				if (_state == PipeState.WaitingToConnect)
				{
					throw new InvalidOperationException("Pipe hasn't been connected yet.");
				}
				if (_state == PipeState.Disconnected)
				{
					throw new InvalidOperationException("Pipe is in a disconnected state.");
				}
				if (_handle == null)
				{
					throw new InvalidOperationException("Pipe handle has not been set.  Did your PipeStream implementation call InitializeHandle?");
				}
				if (_state == PipeState.Closed || (_handle != null && _handle.IsClosed))
				{
					throw Error.GetPipeNotOpen();
				}
				if (_readMode != PipeTransmissionMode.Message)
				{
					throw new InvalidOperationException("ReadMode is not of PipeTransmissionMode.Message.");
				}
				return _isMessageComplete;
			}
		}

		/// <summary>Gets the safe handle for the local end of the pipe that the current <see cref="T:System.IO.Pipes.PipeStream" /> object encapsulates.</summary>
		/// <returns>A <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object for the pipe that is encapsulated by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</returns>
		/// <exception cref="T:System.InvalidOperationException">The pipe handle has not been set.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		public SafePipeHandle SafePipeHandle
		{
			get
			{
				if (_handle == null)
				{
					throw new InvalidOperationException("Pipe handle has not been set.  Did your PipeStream implementation call InitializeHandle?");
				}
				if (_handle.IsClosed)
				{
					throw Error.GetPipeNotOpen();
				}
				_isHandleExposed = true;
				return _handle;
			}
		}

		internal SafePipeHandle InternalHandle => _handle;

		/// <summary>Gets a value indicating whether a handle to a <see cref="T:System.IO.Pipes.PipeStream" /> object is exposed.</summary>
		/// <returns>
		///     <see langword="true" /> if a handle to the <see cref="T:System.IO.Pipes.PipeStream" /> object is exposed; otherwise, <see langword="false" />.</returns>
		protected bool IsHandleExposed => _isHandleExposed;

		/// <summary>Gets a value indicating whether the current stream supports read operations.</summary>
		/// <returns>
		///     <see langword="true" /> if the stream supports read operations; otherwise, <see langword="false" />.</returns>
		public override bool CanRead => _canRead;

		/// <summary>Gets a value indicating whether the current stream supports write operations.</summary>
		/// <returns>
		///     <see langword="true" /> if the stream supports write operations; otherwise, <see langword="false" />.</returns>
		public override bool CanWrite => _canWrite;

		/// <summary>Gets a value indicating whether the current stream supports seek operations.</summary>
		/// <returns>
		///     <see langword="false" /> in all cases.</returns>
		public override bool CanSeek => false;

		/// <summary>Gets the length of a stream, in bytes.</summary>
		/// <returns>0 in all cases.</returns>
		/// <exception cref="T:System.NotSupportedException">Always thrown.</exception>
		public override long Length
		{
			get
			{
				throw Error.GetSeekNotSupported();
			}
		}

		/// <summary>Gets or sets the current position of the current stream.</summary>
		/// <returns>0 in all cases.</returns>
		/// <exception cref="T:System.NotSupportedException">Always thrown.</exception>
		public override long Position
		{
			get
			{
				throw Error.GetSeekNotSupported();
			}
			set
			{
				throw Error.GetSeekNotSupported();
			}
		}

		internal PipeState State
		{
			get
			{
				return _state;
			}
			set
			{
				_state = value;
			}
		}

		internal bool IsCurrentUserOnly
		{
			get
			{
				return _isCurrentUserOnly;
			}
			set
			{
				_isCurrentUserOnly = value;
			}
		}

		internal static string GetPipePath(string serverName, string pipeName)
		{
			string fullPath = Path.GetFullPath("\\\\" + serverName + "\\pipe\\" + pipeName);
			if (string.Equals(fullPath, "\\\\.\\pipe\\anonymous", StringComparison.OrdinalIgnoreCase))
			{
				throw new ArgumentOutOfRangeException("pipeName", "The pipeName \\\"anonymous\\\" is reserved.");
			}
			return fullPath;
		}

		internal void ValidateHandleIsPipe(SafePipeHandle safePipeHandle)
		{
			if (global::Interop.Kernel32.GetFileType(safePipeHandle) != 3)
			{
				throw new IOException("Invalid pipe handle.");
			}
		}

		private void InitializeAsyncHandle(SafePipeHandle handle)
		{
			_threadPoolBinding = ThreadPoolBoundHandle.BindHandle(handle);
		}

		private void DisposeCore(bool disposing)
		{
			if (disposing)
			{
				_threadPoolBinding?.Dispose();
			}
		}

		private unsafe int ReadCore(Span<byte> buffer)
		{
			int errorCode = 0;
			int num = ReadFileNative(_handle, buffer, null, out errorCode);
			if (num == -1)
			{
				if (errorCode != 109 && errorCode != 233)
				{
					throw Win32Marshal.GetExceptionForWin32Error(errorCode, string.Empty);
				}
				State = PipeState.Broken;
				num = 0;
			}
			_isMessageComplete = errorCode != 234;
			return num;
		}

		private unsafe Task<int> ReadAsyncCore(Memory<byte> buffer, CancellationToken cancellationToken)
		{
			ReadWriteCompletionSource readWriteCompletionSource = new ReadWriteCompletionSource(this, buffer, isWrite: false);
			int errorCode = 0;
			if (ReadFileNative(_handle, buffer.Span, readWriteCompletionSource.Overlapped, out errorCode) == -1)
			{
				switch (errorCode)
				{
				case 109:
				case 233:
					State = PipeState.Broken;
					readWriteCompletionSource.Overlapped->InternalLow = IntPtr.Zero;
					readWriteCompletionSource.ReleaseResources();
					UpdateMessageCompletion(completion: true);
					return s_zeroTask;
				default:
					throw Win32Marshal.GetExceptionForWin32Error(errorCode);
				case 997:
					break;
				}
			}
			readWriteCompletionSource.RegisterForCancellation(cancellationToken);
			return readWriteCompletionSource.Task;
		}

		private unsafe void WriteCore(ReadOnlySpan<byte> buffer)
		{
			int errorCode = 0;
			if (WriteFileNative(_handle, buffer, null, out errorCode) == -1)
			{
				throw WinIOError(errorCode);
			}
		}

		private unsafe Task WriteAsyncCore(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken)
		{
			ReadWriteCompletionSource readWriteCompletionSource = new ReadWriteCompletionSource(this, buffer, isWrite: true);
			int errorCode = 0;
			if (WriteFileNative(_handle, buffer.Span, readWriteCompletionSource.Overlapped, out errorCode) == -1 && errorCode != 997)
			{
				readWriteCompletionSource.ReleaseResources();
				throw WinIOError(errorCode);
			}
			readWriteCompletionSource.RegisterForCancellation(cancellationToken);
			return readWriteCompletionSource.Task;
		}

		/// <summary>Waits for the other end of the pipe to read all sent bytes.</summary>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		/// <exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
		public void WaitForPipeDrain()
		{
			CheckWriteOperations();
			if (!CanWrite)
			{
				throw Error.GetWriteNotSupported();
			}
			if (!global::Interop.Kernel32.FlushFileBuffers(_handle))
			{
				throw WinIOError(Marshal.GetLastWin32Error());
			}
		}

		private unsafe int ReadFileNative(SafePipeHandle handle, Span<byte> buffer, NativeOverlapped* overlapped, out int errorCode)
		{
			if (buffer.Length == 0)
			{
				errorCode = 0;
				return 0;
			}
			int numBytesRead = 0;
			int num;
			fixed (byte* reference = &MemoryMarshal.GetReference(buffer))
			{
				num = (_isAsync ? global::Interop.Kernel32.ReadFile(handle, reference, buffer.Length, IntPtr.Zero, overlapped) : global::Interop.Kernel32.ReadFile(handle, reference, buffer.Length, out numBytesRead, IntPtr.Zero));
			}
			if (num == 0)
			{
				errorCode = Marshal.GetLastWin32Error();
				if (errorCode != 234)
				{
					return -1;
				}
				return numBytesRead;
			}
			errorCode = 0;
			return numBytesRead;
		}

		private unsafe int WriteFileNative(SafePipeHandle handle, ReadOnlySpan<byte> buffer, NativeOverlapped* overlapped, out int errorCode)
		{
			if (buffer.Length == 0)
			{
				errorCode = 0;
				return 0;
			}
			int numBytesWritten = 0;
			int num;
			fixed (byte* reference = &MemoryMarshal.GetReference(buffer))
			{
				num = (_isAsync ? global::Interop.Kernel32.WriteFile(handle, reference, buffer.Length, IntPtr.Zero, overlapped) : global::Interop.Kernel32.WriteFile(handle, reference, buffer.Length, out numBytesWritten, IntPtr.Zero));
			}
			if (num == 0)
			{
				errorCode = Marshal.GetLastWin32Error();
				return -1;
			}
			errorCode = 0;
			return numBytesWritten;
		}

		internal unsafe static global::Interop.Kernel32.SECURITY_ATTRIBUTES GetSecAttrs(HandleInheritability inheritability)
		{
			global::Interop.Kernel32.SECURITY_ATTRIBUTES result = default(global::Interop.Kernel32.SECURITY_ATTRIBUTES);
			if ((inheritability & HandleInheritability.Inheritable) != HandleInheritability.None)
			{
				result = new global::Interop.Kernel32.SECURITY_ATTRIBUTES
				{
					nLength = (uint)sizeof(global::Interop.Kernel32.SECURITY_ATTRIBUTES),
					bInheritHandle = global::Interop.BOOL.TRUE
				};
			}
			return result;
		}

		internal unsafe static global::Interop.Kernel32.SECURITY_ATTRIBUTES GetSecAttrs(HandleInheritability inheritability, PipeSecurity pipeSecurity, ref GCHandle pinningHandle)
		{
			global::Interop.Kernel32.SECURITY_ATTRIBUTES result = new global::Interop.Kernel32.SECURITY_ATTRIBUTES
			{
				nLength = (uint)sizeof(global::Interop.Kernel32.SECURITY_ATTRIBUTES)
			};
			if ((inheritability & HandleInheritability.Inheritable) != HandleInheritability.None)
			{
				result.bInheritHandle = global::Interop.BOOL.TRUE;
			}
			if (pipeSecurity != null)
			{
				byte[] securityDescriptorBinaryForm = pipeSecurity.GetSecurityDescriptorBinaryForm();
				pinningHandle = GCHandle.Alloc(securityDescriptorBinaryForm, GCHandleType.Pinned);
				fixed (byte* ptr = securityDescriptorBinaryForm)
				{
					result.lpSecurityDescriptor = (IntPtr)ptr;
				}
			}
			return result;
		}

		private void UpdateReadMode()
		{
			if (!global::Interop.Kernel32.GetNamedPipeHandleState(SafePipeHandle, out var lpState, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero, 0))
			{
				throw WinIOError(Marshal.GetLastWin32Error());
			}
			if ((lpState & 2) != 0)
			{
				_readMode = PipeTransmissionMode.Message;
			}
			else
			{
				_readMode = PipeTransmissionMode.Byte;
			}
		}

		internal Exception WinIOError(int errorCode)
		{
			switch (errorCode)
			{
			case 109:
			case 232:
			case 233:
				_state = PipeState.Broken;
				return new IOException("Pipe is broken.", Win32Marshal.MakeHRFromErrorCode(errorCode));
			case 38:
				return Error.GetEndOfFile();
			case 6:
				_handle.SetHandleAsInvalid();
				_state = PipeState.Broken;
				break;
			}
			return Win32Marshal.GetExceptionForWin32Error(errorCode);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class using the specified <see cref="T:System.IO.Pipes.PipeDirection" /> value and buffer size.</summary>
		/// <param name="direction">One of the <see cref="T:System.IO.Pipes.PipeDirection" /> values that indicates the direction of the pipe object.</param>
		/// <param name="bufferSize">A positive <see cref="T:System.Int32" /> value greater than or equal to 0 that indicates the buffer size.</param>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.-or-
		///         <paramref name="bufferSize" /> is less than 0.</exception>
		protected PipeStream(PipeDirection direction, int bufferSize)
		{
			if (direction < PipeDirection.In || direction > PipeDirection.InOut)
			{
				throw new ArgumentOutOfRangeException("direction", "For named pipes, the pipe direction can be PipeDirection.In, PipeDirection.Out or PipeDirection.InOut. For anonymous pipes, the pipe direction can be PipeDirection.In or PipeDirection.Out.");
			}
			if (bufferSize < 0)
			{
				throw new ArgumentOutOfRangeException("bufferSize", "Non negative number is required.");
			}
			Init(direction, PipeTransmissionMode.Byte, bufferSize);
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.IO.Pipes.PipeStream" /> class using the specified <see cref="T:System.IO.Pipes.PipeDirection" />, <see cref="T:System.IO.Pipes.PipeTransmissionMode" />, and buffer size.</summary>
		/// <param name="direction">One of the <see cref="T:System.IO.Pipes.PipeDirection" /> values that indicates the direction of the pipe object.</param>
		/// <param name="transmissionMode">One of the <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> values that indicates the transmission mode of the pipe object.</param>
		/// <param name="outBufferSize">A positive <see cref="T:System.Int32" /> value greater than or equal to 0 that indicates the buffer size.</param>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="direction" /> is not a valid <see cref="T:System.IO.Pipes.PipeDirection" /> value.-or-
		///         <paramref name="transmissionMode" /> is not a valid <see cref="T:System.IO.Pipes.PipeTransmissionMode" /> value.-or-
		///         <paramref name="bufferSize" /> is less than 0.</exception>
		protected PipeStream(PipeDirection direction, PipeTransmissionMode transmissionMode, int outBufferSize)
		{
			if (direction < PipeDirection.In || direction > PipeDirection.InOut)
			{
				throw new ArgumentOutOfRangeException("direction", "For named pipes, the pipe direction can be PipeDirection.In, PipeDirection.Out or PipeDirection.InOut. For anonymous pipes, the pipe direction can be PipeDirection.In or PipeDirection.Out.");
			}
			if (transmissionMode < PipeTransmissionMode.Byte || transmissionMode > PipeTransmissionMode.Message)
			{
				throw new ArgumentOutOfRangeException("transmissionMode", "For named pipes, transmission mode can be TransmissionMode.Byte or PipeTransmissionMode.Message. For anonymous pipes, transmission mode can be TransmissionMode.Byte.");
			}
			if (outBufferSize < 0)
			{
				throw new ArgumentOutOfRangeException("outBufferSize", "Non negative number is required.");
			}
			Init(direction, transmissionMode, outBufferSize);
		}

		private void Init(PipeDirection direction, PipeTransmissionMode transmissionMode, int outBufferSize)
		{
			_readMode = transmissionMode;
			_transmissionMode = transmissionMode;
			_pipeDirection = direction;
			if ((_pipeDirection & PipeDirection.In) != 0)
			{
				_canRead = true;
			}
			if ((_pipeDirection & PipeDirection.Out) != 0)
			{
				_canWrite = true;
			}
			_outBufferSize = outBufferSize;
			_isMessageComplete = true;
			_state = PipeState.WaitingToConnect;
		}

		/// <summary>Initializes a <see cref="T:System.IO.Pipes.PipeStream" /> object from the specified <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object.</summary>
		/// <param name="handle">The <see cref="T:Microsoft.Win32.SafeHandles.SafePipeHandle" /> object of the pipe to initialize.</param>
		/// <param name="isExposed">
		///       <see langword="true" /> to expose the handle; otherwise, <see langword="false" />.</param>
		/// <param name="isAsync">
		///       <see langword="true" /> to indicate that the handle was opened asynchronously; otherwise, <see langword="false" />.</param>
		/// <exception cref="T:System.IO.IOException">A handle cannot be bound to the pipe.</exception>
		protected void InitializeHandle(SafePipeHandle handle, bool isExposed, bool isAsync)
		{
			if (isAsync && handle != null)
			{
				InitializeAsyncHandle(handle);
			}
			_handle = handle;
			_isAsync = isAsync;
			_isHandleExposed = isExposed;
			_isFromExistingHandle = isExposed;
		}

		/// <summary>Reads a block of bytes from a stream and writes the data to a specified buffer.</summary>
		/// <param name="buffer">When this method returns, contains the specified byte array with the values between <paramref name="offset" /> and (<paramref name="offset" /> + <paramref name="count" /> - 1) replaced by the bytes read from the current source.</param>
		/// <param name="offset">The byte offset in the <paramref name="buffer" /> array at which the bytes that are read will be placed.</param>
		/// <param name="count">The maximum number of bytes to read.</param>
		/// <returns>The total number of bytes that are read into <paramref name="buffer" />. This might be less than the number of bytes requested if that number of bytes is not currently available, or 0 if the end of the stream is reached.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="buffer" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="offset" /> is less than 0.-or-
		///         <paramref name="count" /> is less than 0.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		/// <exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception>
		/// <exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception>
		/// <exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
		public override int Read(byte[] buffer, int offset, int count)
		{
			if (_isAsync)
			{
				return ReadAsync(buffer, offset, count, CancellationToken.None).GetAwaiter().GetResult();
			}
			CheckReadWriteArgs(buffer, offset, count);
			if (!CanRead)
			{
				throw Error.GetReadNotSupported();
			}
			CheckReadOperations();
			return ReadCore(new Span<byte>(buffer, offset, count));
		}

		public override int Read(Span<byte> buffer)
		{
			if (_isAsync)
			{
				return base.Read(buffer);
			}
			if (!CanRead)
			{
				throw Error.GetReadNotSupported();
			}
			CheckReadOperations();
			return ReadCore(buffer);
		}

		public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
		{
			CheckReadWriteArgs(buffer, offset, count);
			if (!CanRead)
			{
				throw Error.GetReadNotSupported();
			}
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<int>(cancellationToken);
			}
			CheckReadOperations();
			if (!_isAsync)
			{
				return base.ReadAsync(buffer, offset, count, cancellationToken);
			}
			if (count == 0)
			{
				UpdateMessageCompletion(completion: false);
				return s_zeroTask;
			}
			return ReadAsyncCore(new Memory<byte>(buffer, offset, count), cancellationToken);
		}

		public override ValueTask<int> ReadAsync(Memory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_isAsync)
			{
				return base.ReadAsync(buffer, cancellationToken);
			}
			if (!CanRead)
			{
				throw Error.GetReadNotSupported();
			}
			if (cancellationToken.IsCancellationRequested)
			{
				return new ValueTask<int>(Task.FromCanceled<int>(cancellationToken));
			}
			CheckReadOperations();
			if (buffer.Length == 0)
			{
				UpdateMessageCompletion(completion: false);
				return new ValueTask<int>(0);
			}
			return new ValueTask<int>(ReadAsyncCore(buffer, cancellationToken));
		}

		/// <summary>Begins an asynchronous read operation.</summary>
		/// <param name="buffer">The buffer to read data into.</param>
		/// <param name="offset">The byte offset in <paramref name="buffer" /> at which to begin reading.</param>
		/// <param name="count">The maximum number of bytes to read.</param>
		/// <param name="callback">The method to call when the asynchronous read operation is completed.</param>
		/// <param name="state">A user-provided object that distinguishes this particular asynchronous read request from other requests.</param>
		/// <returns>An <see cref="T:System.IAsyncResult" /> object that references the asynchronous read.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="buffer" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="offset" /> is less than 0.-or-
		///         <paramref name="count" /> is less than 0.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		/// <exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception>
		/// <exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
		public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			if (_isAsync)
			{
				return TaskToApm.Begin(ReadAsync(buffer, offset, count, CancellationToken.None), callback, state);
			}
			return base.BeginRead(buffer, offset, count, callback, state);
		}

		/// <summary>Ends a pending asynchronous read request.</summary>
		/// <param name="asyncResult">The reference to the pending asynchronous request.</param>
		/// <returns>The number of bytes that were read. A return value of 0 indicates the end of the stream (the pipe has been closed).</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="asyncResult" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream. </exception>
		/// <exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
		public override int EndRead(IAsyncResult asyncResult)
		{
			if (_isAsync)
			{
				return TaskToApm.End<int>(asyncResult);
			}
			return base.EndRead(asyncResult);
		}

		/// <summary>Writes a block of bytes to the current stream using data from a buffer.</summary>
		/// <param name="buffer">The buffer that contains data to write to the pipe.</param>
		/// <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</param>
		/// <param name="count">The maximum number of bytes to write to the current stream.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="buffer" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="offset" /> is less than 0.-or-
		///         <paramref name="count" /> is less than 0.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		/// <exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
		public override void Write(byte[] buffer, int offset, int count)
		{
			if (_isAsync)
			{
				WriteAsync(buffer, offset, count, CancellationToken.None).GetAwaiter().GetResult();
				return;
			}
			CheckReadWriteArgs(buffer, offset, count);
			if (!CanWrite)
			{
				throw Error.GetWriteNotSupported();
			}
			CheckWriteOperations();
			WriteCore(new ReadOnlySpan<byte>(buffer, offset, count));
		}

		public override void Write(ReadOnlySpan<byte> buffer)
		{
			if (_isAsync)
			{
				base.Write(buffer);
				return;
			}
			if (!CanWrite)
			{
				throw Error.GetWriteNotSupported();
			}
			CheckWriteOperations();
			WriteCore(buffer);
		}

		public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
		{
			CheckReadWriteArgs(buffer, offset, count);
			if (!CanWrite)
			{
				throw Error.GetWriteNotSupported();
			}
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<int>(cancellationToken);
			}
			CheckWriteOperations();
			if (!_isAsync)
			{
				return base.WriteAsync(buffer, offset, count, cancellationToken);
			}
			if (count == 0)
			{
				return Task.CompletedTask;
			}
			return WriteAsyncCore(new ReadOnlyMemory<byte>(buffer, offset, count), cancellationToken);
		}

		public override ValueTask WriteAsync(ReadOnlyMemory<byte> buffer, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_isAsync)
			{
				return base.WriteAsync(buffer, cancellationToken);
			}
			if (!CanWrite)
			{
				throw Error.GetWriteNotSupported();
			}
			if (cancellationToken.IsCancellationRequested)
			{
				return new ValueTask(Task.FromCanceled<int>(cancellationToken));
			}
			CheckWriteOperations();
			if (buffer.Length == 0)
			{
				return default(ValueTask);
			}
			return new ValueTask(WriteAsyncCore(buffer, cancellationToken));
		}

		/// <summary>Begins an asynchronous write operation.</summary>
		/// <param name="buffer">The buffer that contains the data to write to the current stream.</param>
		/// <param name="offset">The zero-based byte offset in <paramref name="buffer" /> at which to begin copying bytes to the current stream.</param>
		/// <param name="count">The maximum number of bytes to write.</param>
		/// <param name="callback">The method to call when the asynchronous write operation is completed.</param>
		/// <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests.</param>
		/// <returns>An <see cref="T:System.IAsyncResult" /> object that references the asynchronous write operation.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="buffer" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="offset" /> is less than 0.-or-
		///         <paramref name="count" /> is less than 0.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="count" /> is greater than the number of bytes available in <paramref name="buffer" />.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		/// <exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception>
		/// <exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
		public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			if (_isAsync)
			{
				return TaskToApm.Begin(WriteAsync(buffer, offset, count, CancellationToken.None), callback, state);
			}
			return base.BeginWrite(buffer, offset, count, callback, state);
		}

		/// <summary>Ends a pending asynchronous write request.</summary>
		/// <param name="asyncResult">The reference to the pending asynchronous request.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="asyncResult" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="asyncResult" /> did not originate from a <see cref="M:System.IO.Pipes.PipeStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> method on the current stream. </exception>
		/// <exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception>
		public override void EndWrite(IAsyncResult asyncResult)
		{
			if (_isAsync)
			{
				TaskToApm.End(asyncResult);
			}
			else
			{
				base.EndWrite(asyncResult);
			}
		}

		private void CheckReadWriteArgs(byte[] buffer, int offset, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer", "Buffer cannot be null.");
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", "Non negative number is required.");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", "Non negative number is required.");
			}
			if (buffer.Length - offset < count)
			{
				throw new ArgumentException("Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.");
			}
		}

		[Conditional("DEBUG")]
		private static void DebugAssertHandleValid(SafePipeHandle handle)
		{
		}

		[Conditional("DEBUG")]
		private static void DebugAssertReadWriteArgs(byte[] buffer, int offset, int count, SafePipeHandle handle)
		{
		}

		/// <summary>Reads a byte from a pipe.</summary>
		/// <returns>The byte, cast to <see cref="T:System.Int32" />, or -1 indicates the end of the stream (the pipe has been closed).</returns>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		/// <exception cref="T:System.NotSupportedException">The pipe does not support read operations.</exception>
		/// <exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception>
		/// <exception cref="T:System.IO.IOException">Any I/O error occurred.</exception>
		public unsafe override int ReadByte()
		{
			byte result = default(byte);
			if (Read(new Span<byte>(&result, 1)) <= 0)
			{
				return -1;
			}
			return result;
		}

		/// <summary>Writes a byte to the current stream.</summary>
		/// <param name="value">The byte to write to the stream.</param>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		/// <exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception>
		/// <exception cref="T:System.InvalidOperationException">The pipe is disconnected, waiting to connect, or the handle has not been set.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
		public unsafe override void WriteByte(byte value)
		{
			Write(new ReadOnlySpan<byte>(&value, 1));
		}

		/// <summary>Clears the buffer for the current stream and causes any buffered data to be written to the underlying device.</summary>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		/// <exception cref="T:System.NotSupportedException">The pipe does not support write operations.</exception>
		/// <exception cref="T:System.IO.IOException">The pipe is broken or another I/O error occurred.</exception>
		public override void Flush()
		{
			CheckWriteOperations();
			if (!CanWrite)
			{
				throw Error.GetWriteNotSupported();
			}
		}

		/// <summary>Releases the unmanaged resources used by the <see cref="T:System.IO.Pipes.PipeStream" /> class and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///       <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		protected override void Dispose(bool disposing)
		{
			try
			{
				if (_handle != null && !_handle.IsClosed)
				{
					_handle.Dispose();
				}
				DisposeCore(disposing);
			}
			finally
			{
				base.Dispose(disposing);
			}
			_state = PipeState.Closed;
		}

		internal void UpdateMessageCompletion(bool completion)
		{
			_isMessageComplete = completion || _state == PipeState.Broken;
		}

		/// <summary>Sets the length of the current stream to the specified value.</summary>
		/// <param name="value">The new length of the stream.</param>
		public override void SetLength(long value)
		{
			throw Error.GetSeekNotSupported();
		}

		/// <summary>Sets the current position of the current stream to the specified value.</summary>
		/// <param name="offset">The point, relative to <paramref name="origin" />, to begin seeking from.</param>
		/// <param name="origin">Specifies the beginning, the end, or the current position as a reference point for <paramref name="offset" />, using a value of type <see cref="T:System.IO.SeekOrigin" />.</param>
		/// <returns>The new position in the stream.</returns>
		public override long Seek(long offset, SeekOrigin origin)
		{
			throw Error.GetSeekNotSupported();
		}

		/// <summary>Verifies that the pipe is in a proper state for getting or setting properties.</summary>
		protected internal virtual void CheckPipePropertyOperations()
		{
			if (_handle == null)
			{
				throw new InvalidOperationException("Pipe handle has not been set.  Did your PipeStream implementation call InitializeHandle?");
			}
			if (_state == PipeState.Closed || (_handle != null && _handle.IsClosed))
			{
				throw Error.GetPipeNotOpen();
			}
		}

		/// <summary>Verifies that the pipe is in a connected state for read operations.</summary>
		protected internal void CheckReadOperations()
		{
			if (_state == PipeState.WaitingToConnect)
			{
				throw new InvalidOperationException("Pipe hasn't been connected yet.");
			}
			if (_state == PipeState.Disconnected)
			{
				throw new InvalidOperationException("Pipe is in a disconnected state.");
			}
			if (_handle == null)
			{
				throw new InvalidOperationException("Pipe handle has not been set.  Did your PipeStream implementation call InitializeHandle?");
			}
			if (_state == PipeState.Closed || (_handle != null && _handle.IsClosed))
			{
				throw Error.GetPipeNotOpen();
			}
		}

		/// <summary>Verifies that the pipe is in a connected state for write operations.</summary>
		protected internal void CheckWriteOperations()
		{
			if (_state == PipeState.WaitingToConnect)
			{
				throw new InvalidOperationException("Pipe hasn't been connected yet.");
			}
			if (_state == PipeState.Disconnected)
			{
				throw new InvalidOperationException("Pipe is in a disconnected state.");
			}
			if (_handle == null)
			{
				throw new InvalidOperationException("Pipe handle has not been set.  Did your PipeStream implementation call InitializeHandle?");
			}
			if (_state == PipeState.Broken)
			{
				throw new IOException("Pipe is broken.");
			}
			if (_state == PipeState.Closed || (_handle != null && _handle.IsClosed))
			{
				throw Error.GetPipeNotOpen();
			}
		}

		/// <summary>Gets a <see cref="T:System.IO.Pipes.PipeSecurity" /> object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</summary>
		/// <returns>A <see cref="T:System.IO.Pipes.PipeSecurity" /> object that encapsulates the access control list (ACL) entries for the pipe described by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</returns>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		/// <exception cref="T:System.UnauthorizedAccessException">The underlying call to set security information failed.</exception>
		/// <exception cref="T:System.InvalidOperationException">The underlying call to set security information failed.</exception>
		/// <exception cref="T:System.NotSupportedException">The underlying call to set security information failed.</exception>
		public PipeSecurity GetAccessControl()
		{
			if (State == PipeState.Closed)
			{
				throw Error.GetPipeNotOpen();
			}
			return new PipeSecurity(SafePipeHandle, AccessControlSections.Access | AccessControlSections.Owner | AccessControlSections.Group);
		}

		/// <summary>Applies the access control list (ACL) entries specified by a <see cref="T:System.IO.Pipes.PipeSecurity" /> object to the pipe specified by the current <see cref="T:System.IO.Pipes.PipeStream" /> object.</summary>
		/// <param name="pipeSecurity">A <see cref="T:System.IO.Pipes.PipeSecurity" /> object that specifies an access control list (ACL) entry to apply to the current pipe.</param>
		/// <exception cref="T:System.ObjectDisposedException">The pipe is closed.</exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="pipeSecurity" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.UnauthorizedAccessException">The underlying call to set security information failed.</exception>
		/// <exception cref="T:System.InvalidOperationException">The underlying call to set security information failed.</exception>
		/// <exception cref="T:System.NotSupportedException">The underlying call to set security information failed.</exception>
		public void SetAccessControl(PipeSecurity pipeSecurity)
		{
			if (pipeSecurity == null)
			{
				throw new ArgumentNullException("pipeSecurity");
			}
			CheckPipePropertyOperations();
			pipeSecurity.Persist(SafePipeHandle);
		}
	}
	/// <summary>Specifies the transmission mode of the pipe.</summary>
	public enum PipeTransmissionMode
	{
		/// <summary>Indicates that data in the pipe is transmitted and read as a stream of bytes.</summary>
		Byte,
		/// <summary>Indicates that data in the pipe is transmitted and read as a stream of messages.</summary>
		Message
	}
	internal sealed class ReadWriteCompletionSource : PipeCompletionSource<int>
	{
		private readonly bool _isWrite;

		private readonly PipeStream _pipeStream;

		private bool _isMessageComplete;

		private int _numBytes;

		internal ReadWriteCompletionSource(PipeStream stream, ReadOnlyMemory<byte> bufferToPin, bool isWrite)
			: base(stream._threadPoolBinding, bufferToPin)
		{
			_pipeStream = stream;
			_isWrite = isWrite;
			_isMessageComplete = true;
		}

		internal override void SetCompletedSynchronously()
		{
			if (!_isWrite)
			{
				_pipeStream.UpdateMessageCompletion(_isMessageComplete);
			}
			TrySetResult(_numBytes);
		}

		protected override void AsyncCallback(uint errorCode, uint numBytes)
		{
			_numBytes = (int)numBytes;
			if (!_isWrite && (errorCode == 109 || errorCode - 232 <= 1))
			{
				errorCode = 0u;
			}
			if (errorCode == 234)
			{
				errorCode = 0u;
				_isMessageComplete = false;
			}
			else
			{
				_isMessageComplete = true;
			}
			base.AsyncCallback(errorCode, numBytes);
		}

		protected override void HandleError(int errorCode)
		{
			TrySetException(_pipeStream.WinIOError(errorCode));
		}
	}
}
namespace System.Collections.Generic
{
	internal struct ArrayBuilder<T>
	{
		private const int DefaultCapacity = 4;

		private const int MaxCoreClrArrayLength = 2146435071;

		private T[] _array;

		private int _count;

		public int Capacity
		{
			get
			{
				T[] array = _array;
				if (array == null)
				{
					return 0;
				}
				return array.Length;
			}
		}

		public int Count => _count;

		public T this[int index]
		{
			get
			{
				return _array[index];
			}
			set
			{
				_array[index] = value;
			}
		}

		public ArrayBuilder(int capacity)
		{
			this = default(ArrayBuilder<T>);
			if (capacity > 0)
			{
				_array = new T[capacity];
			}
		}

		public void Add(T item)
		{
			if (_count == Capacity)
			{
				EnsureCapacity(_count + 1);
			}
			UncheckedAdd(item);
		}

		public T First()
		{
			return _array[0];
		}

		public T Last()
		{
			return _array[_count - 1];
		}

		public T[] ToArray()
		{
			if (_count == 0)
			{
				return Array.Empty<T>();
			}
			T[] array = _array;
			if (_count < array.Length)
			{
				array = new T[_count];
				Array.Copy(_array, 0, array, 0, _count);
			}
			return array;
		}

		public void UncheckedAdd(T item)
		{
			_array[_count++] = item;
		}

		private void EnsureCapacity(int minimum)
		{
			int capacity = Capacity;
			int num = ((capacity == 0) ? 4 : (2 * capacity));
			if ((uint)num > 2146435071u)
			{
				num = Math.Max(capacity + 1, 2146435071);
			}
			num = Math.Max(num, minimum);
			T[] array = new T[num];
			if (_count > 0)
			{
				Array.Copy(_array, 0, array, 0, _count);
			}
			_array = array;
		}
	}
	internal static class EnumerableHelpers
	{
		internal static bool TryGetCount<T>(IEnumerable<T> source, out int count)
		{
			if (source is ICollection<T> collection)
			{
				count = collection.Count;
				return true;
			}
			if (source is IIListProvider<T> iIListProvider)
			{
				return (count = iIListProvider.GetCount(onlyIfCheap: true)) >= 0;
			}
			count = -1;
			return false;
		}

		internal static void Copy<T>(IEnumerable<T> source, T[] array, int arrayIndex, int count)
		{
			if (source is ICollection<T> collection)
			{
				collection.CopyTo(array, arrayIndex);
			}
			else
			{
				IterativeCopy(source, array, arrayIndex, count);
			}
		}

		internal static void IterativeCopy<T>(IEnumerable<T> source, T[] array, int arrayIndex, int count)
		{
			foreach (T item in source)
			{
				array[arrayIndex++] = item;
			}
		}

		internal static T[] ToArray<T>(IEnumerable<T> source)
		{
			if (source is ICollection<T> { Count: var count } collection)
			{
				if (count == 0)
				{
					return Array.Empty<T>();
				}
				T[] array = new T[count];
				collection.CopyTo(array, 0);
				return array;
			}
			LargeArrayBuilder<T> largeArrayBuilder = new LargeArrayBuilder<T>(initialize: true);
			largeArrayBuilder.AddRange(source);
			return largeArrayBuilder.ToArray();
		}

		internal static T[] ToArray<T>(IEnumerable<T> source, out int length)
		{
			if (source is ICollection<T> { Count: var count } collection)
			{
				if (count != 0)
				{
					T[] array = new T[count];
					collection.CopyTo(array, 0);
					length = count;
					return array;
				}
			}
			else
			{
				using IEnumerator<T> enumerator = source.GetEnumerator();
				if (enumerator.MoveNext())
				{
					T[] array2 = new T[4]
					{
						enumerator.Current,
						default(T),
						default(T),
						default(T)
					};
					int num = 1;
					while (enumerator.MoveNext())
					{
						if (num == array2.Length)
						{
							int num2 = num << 1;
							if ((uint)num2 > 2146435071u)
							{
								num2 = ((2146435071 <= num) ? (num + 1) : 2146435071);
							}
							Array.Resize(ref array2, num2);
						}
						array2[num++] = enumerator.Current;
					}
					length = num;
					return array2;
				}
			}
			length = 0;
			return Array.Empty<T>();
		}
	}
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	internal readonly struct CopyPosition
	{
		public static CopyPosition Start => default(CopyPosition);

		internal int Row { get; }

		internal int Column { get; }

		private string DebuggerDisplay => $"[{Row}, {Column}]";

		internal CopyPosition(int row, int column)
		{
			Row = row;
			Column = column;
		}

		public CopyPosition Normalize(int endColumn)
		{
			if (Column != endColumn)
			{
				return this;
			}
			return new CopyPosition(Row + 1, 0);
		}
	}
	internal struct LargeArrayBuilder<T>
	{
		private const int StartingCapacity = 4;

		private const int ResizeLimit = 8;

		private readonly int _maxCapacity;

		private T[] _first;

		private ArrayBuilder<T[]> _buffers;

		private T[] _current;

		private int _index;

		private int _count;

		public int Count => _count;

		public LargeArrayBuilder(bool initialize)
			: this(int.MaxValue)
		{
		}

		public LargeArrayBuilder(int maxCapacity)
		{
			this = default(LargeArrayBuilder<T>);
			_first = (_current = Array.Empty<T>());
			_maxCapacity = maxCapacity;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Add(T item)
		{
			int index = _index;
			T[] current = _current;
			if ((uint)index >= (uint)current.Length)
			{
				AddWithBufferAllocation(item);
			}
			else
			{
				current[index] = item;
				_index = index + 1;
			}
			_count++;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private void AddWithBufferAllocation(T item)
		{
			AllocateBuffer();
			_current[_index++] = item;
		}

		public void AddRange(IEnumerable<T> items)
		{
			using IEnumerator<T> enumerator = items.GetEnumerator();
			T[] destination = _current;
			int index = _index;
			while (enumerator.MoveNext())
			{
				T current = enumerator.Current;
				if ((uint)index >= (uint)destination.Length)
				{
					AddWithBufferAllocation(current, ref destination, ref index);
				}
				else
				{
					destination[index] = current;
				}
				index++;
			}
			_count += index - _index;
			_index = index;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private void AddWithBufferAllocation(T item, ref T[] destination, ref int index)
		{
			_count += index - _index;
			_index = index;
			AllocateBuffer();
			destination = _current;
			index = _index;
			_current[index] = item;
		}

		public void CopyTo(T[] array, int arrayIndex, int count)
		{
			int num = 0;
			while (count > 0)
			{
				T[] buffer = GetBuffer(num);
				int num2 = Math.Min(count, buffer.Length);
				Array.Copy(buffer, 0, array, arrayIndex, num2);
				count -= num2;
				arrayIndex += num2;
				num++;
			}
		}

		public CopyPosition CopyTo(CopyPosition position, T[] array, int arrayIndex, int count)
		{
			int num = position.Row;
			int column = position.Column;
			T[] buffer = GetBuffer(num);
			int num2 = CopyToCore(buffer, column);
			if (count == 0)
			{
				return new CopyPosition(num, column + num2).Normalize(buffer.Length);
			}
			do
			{
				buffer = GetBuffer(++num);
				num2 = CopyToCore(buffer, 0);
			}
			while (count > 0);
			return new CopyPosition(num, num2).Normalize(buffer.Length);
			int CopyToCore(T[] sourceBuffer, int sourceIndex)
			{
				int num3 = Math.Min(sourceBuffer.Length - sourceIndex, count);
				Array.Copy(sourceBuffer, sourceIndex, array, arrayIndex, num3);
				arrayIndex += num3;
				count -= num3;
				return num3;
			}
		}

		public T[] GetBuffer(int index)
		{
			if (index != 0)
			{
				if (index > _buffers.Count)
				{
					return _current;
				}
				return _buffers[index - 1];
			}
			return _first;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		public void SlowAdd(T item)
		{
			Add(item);
		}

		public T[] ToArray()
		{
			if (TryMove(out var array))
			{
				return array;
			}
			array = new T[_count];
			CopyTo(array, 0, _count);
			return array;
		}

		public bool TryMove(out T[] array)
		{
			array = _first;
			return _count == _first.Length;
		}

		private void AllocateBuffer()
		{
			if ((uint)_count < 8u)
			{
				int num = Math.Min((_count == 0) ? 4 : (_count * 2), _maxCapacity);
				_current = new T[num];
				Array.Copy(_first, 0, _current, 0, _count);
				_first = _current;
				return;
			}
			int num2;
			if (_count == 8)
			{
				num2 = 8;
			}
			else
			{
				_buffers.Add(_current);
				num2 = Math.Min(_count, _maxCapacity - _count);
			}
			_current = new T[num2];
			_index = 0;
		}
	}
	internal sealed class ReferenceEqualityComparer<T> : IEqualityComparer<T> where T : class
	{
		internal static readonly ReferenceEqualityComparer<T> Instance = new ReferenceEqualityComparer<T>();

		private ReferenceEqualityComparer()
		{
		}

		public bool Equals(T x, T y)
		{
			return x == y;
		}

		public int GetHashCode(T obj)
		{
			return RuntimeHelpers.GetHashCode(obj);
		}
	}
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
	internal readonly struct Marker
	{
		public int Count { get; }

		public int Index { get; }

		private string DebuggerDisplay => string.Format("{0}: {1}, {2}: {3}", "Index", Index, "Count", Count);

		public Marker(int count, int index)
		{
			Count = count;
			Index = index;
		}
	}
	internal struct SparseArrayBuilder<T>
	{
		private LargeArrayBuilder<T> _builder;

		private ArrayBuilder<Marker> _markers;

		private int _reservedCount;

		public int Count => checked(_builder.Count + _reservedCount);

		public ArrayBuilder<Marker> Markers => _markers;

		public SparseArrayBuilder(bool initialize)
		{
			this = default(SparseArrayBuilder<T>);
			_builder = new LargeArrayBuilder<T>(initialize: true);
		}

		public void Add(T item)
		{
			_builder.Add(item);
		}

		public void AddRange(IEnumerable<T> items)
		{
			_builder.AddRange(items);
		}

		public void CopyTo(T[] array, int arrayIndex, int count)
		{
			int num = 0;
			CopyPosition position = CopyPosition.Start;
			for (int i = 0; i < _markers.Count; i++)
			{
				Marker marker = _markers[i];
				int num2 = Math.Min(marker.Index - num, count);
				if (num2 > 0)
				{
					position = _builder.CopyTo(position, array, arrayIndex, num2);
					arrayIndex += num2;
					num += num2;
					count -= num2;
				}
				if (count == 0)
				{
					return;
				}
				int num3 = Math.Min(marker.Count, count);
				arrayIndex += num3;
				num += num3;
				count -= num3;
			}
			if (count > 0)
			{
				_builder.CopyTo(position, array, arrayIndex, count);
			}
		}

		public void Reserve(int count)
		{
			_markers.Add(new Marker(count, Count));
			checked
			{
				_reservedCount += count;
			}
		}

		public bool ReserveOrAdd(IEnumerable<T> items)
		{
			if (EnumerableHelpers.TryGetCount(items, out var count))
			{
				if (count > 0)
				{
					Reserve(count);
					return true;
				}
			}
			else
			{
				AddRange(items);
			}
			return false;
		}

		public T[] ToArray()
		{
			if (_markers.Count == 0)
			{
				return _builder.ToArray();
			}
			T[] array = new T[Count];
			CopyTo(array, 0, array.Length);
			return array;
		}
	}
	internal sealed class BitHelper
	{
		private const byte MarkedBitFlag = 1;

		private const byte IntSize = 32;

		private readonly int _length;

		private unsafe readonly int* _arrayPtr;

		private readonly int[] _array;

		private readonly bool _useStackAlloc;

		internal unsafe BitHelper(int* bitArrayPtr, int length)
		{
			_arrayPtr = bitArrayPtr;
			_length = length;
			_useStackAlloc = true;
		}

		internal BitHelper(int[] bitArray, int length)
		{
			_array = bitArray;
			_length = length;
		}

		internal unsafe void MarkBit(int bitPosition)
		{
			int num = bitPosition / 32;
			if (num < _length && num >= 0)
			{
				int num2 = 1 << bitPosition % 32;
				if (_useStackAlloc)
				{
					_arrayPtr[num] |= num2;
				}
				else
				{
					_array[num] |= num2;
				}
			}
		}

		internal unsafe bool IsMarked(int bitPosition)
		{
			int num = bitPosition / 32;
			if (num < _length && num >= 0)
			{
				int num2 = 1 << bitPosition % 32;
				if (_useStackAlloc)
				{
					return (_arrayPtr[num] & num2) != 0;
				}
				return (_array[num] & num2) != 0;
			}
			return false;
		}

		internal static int ToIntArrayLength(int n)
		{
			if (n <= 0)
			{
				return 0;
			}
			return (n - 1) / 32 + 1;
		}
	}
	/// <summary>Represents a set of values.To browse the .NET Framework source code for this type, see the Reference Source.</summary>
	/// <typeparam name="T">The type of elements in the hash set.</typeparam>
	[Serializable]
	[DebuggerTypeProxy(typeof(System.Collections.Generic.ICollectionDebugView<>))]
	[DebuggerDisplay("Count = {Count}")]
	public class HashSet<T> : ICollection<T>, IEnumerable<T>, IEnumerable, ISet<T>, IReadOnlyCollection<T>, ISerializable, IDeserializationCallback
	{
		internal struct ElementCount
		{
			internal int uniqueCount;

			internal int unfoundCount;
		}

		internal struct Slot
		{
			internal int hashCode;

			internal int next;

			internal T value;
		}

		/// <summary>Enumerates the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</summary>
		[Serializable]
		public struct Enumerator : IEnumerator<T>, IDisposable, IEnumerator
		{
			private HashSet<T> _set;

			private int _index;

			private int _version;

			private T _current;

			/// <summary>Gets the element at the current position of the enumerator.</summary>
			/// <returns>The element in the <see cref="T:System.Collections.Generic.HashSet`1" /> collection at the current position of the enumerator.</returns>
			public T Current => _current;

			/// <summary>Gets the element at the current position of the enumerator.</summary>
			/// <returns>The element in the collection at the current position of the enumerator, as an <see cref="T:System.Object" />.</returns>
			/// <exception cref="T:System.InvalidOperationException">The enumerator is positioned before the first element of the collection or after the last element. </exception>
			object IEnumerator.Current
			{
				get
				{
					if (_index == 0 || _index == _set._lastIndex + 1)
					{
						throw new InvalidOperationException("Enumeration has either not started or has already finished.");
					}
					return Current;
				}
			}

			internal Enumerator(HashSet<T> set)
			{
				_set = set;
				_index = 0;
				_version = set._version;
				_current = default(T);
			}

			/// <summary>Releases all resources used by a <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> object.</summary>
			public void Dispose()
			{
			}

			/// <summary>Advances the enumerator to the next element of the <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</summary>
			/// <returns>
			///     <see langword="true" /> if the enumerator was successfully advanced to the next element; <see langword="false" /> if the enumerator has passed the end of the collection.</returns>
			/// <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
			public bool MoveNext()
			{
				if (_version != _set._version)
				{
					throw new InvalidOperationException("Collection was modified; enumeration operation may not execute.");
				}
				while (_index < _set._lastIndex)
				{
					if (_set._slots[_index].hashCode >= 0)
					{
						_current = _set._slots[_index].value;
						_index++;
						return true;
					}
					_index++;
				}
				_index = _set._lastIndex + 1;
				_current = default(T);
				return false;
			}

			/// <summary>Sets the enumerator to its initial position, which is before the first element in the collection.</summary>
			/// <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
			void IEnumerator.Reset()
			{
				if (_version != _set._version)
				{
					throw new InvalidOperationException("Collection was modified; enumeration operation may not execute.");
				}
				_index = 0;
				_current = default(T);
			}
		}

		private const int Lower31BitMask = int.MaxValue;

		private const int StackAllocThreshold = 100;

		private const int ShrinkThreshold = 3;

		private const string CapacityName = "Capacity";

		private const string ElementsName = "Elements";

		private const string ComparerName = "Comparer";

		private const string VersionName = "Version";

		private int[] _buckets;

		private Slot[] _slots;

		private int _count;

		private int _lastIndex;

		private int _freeList;

		private IEqualityComparer<T> _comparer;

		private int _version;

		private SerializationInfo _siInfo;

		/// <summary>Gets the number of elements that are contained in a set.</summary>
		/// <returns>The number of elements that are contained in the set.</returns>
		public int Count => _count;

		/// <summary>Gets a value indicating whether a collection is read-only.</summary>
		/// <returns>
		///     <see langword="true" /> if the collection is read-only; otherwise, <see langword="false" />.</returns>
		bool ICollection<T>.IsReadOnly => false;

		/// <summary>Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</summary>
		/// <returns>The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</returns>
		public IEqualityComparer<T> Comparer => _comparer;

		/// <summary>Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the default equality comparer for the set type.</summary>
		public HashSet()
			: this((IEqualityComparer<T>)EqualityComparer<T>.Default)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the specified equality comparer for the set type.</summary>
		/// <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</param>
		public HashSet(IEqualityComparer<T> comparer)
		{
			if (comparer == null)
			{
				comparer = EqualityComparer<T>.Default;
			}
			_comparer = comparer;
			_lastIndex = 0;
			_count = 0;
			_freeList = -1;
			_version = 0;
		}

		/// <summary>
		/// 			Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty, but has reserved space for <paramref name="capacity" /> items and uses the default equality comparer for the set type.
		/// 		</summary>
		/// <param name="capacity">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></param>
		public HashSet(int capacity)
			: this(capacity, (IEqualityComparer<T>)EqualityComparer<T>.Default)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the default equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</summary>
		/// <param name="collection">The collection whose elements are copied to the new set.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="collection" /> is <see langword="null" />.</exception>
		public HashSet(IEnumerable<T> collection)
			: this(collection, (IEqualityComparer<T>)EqualityComparer<T>.Default)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</summary>
		/// <param name="collection">The collection whose elements are copied to the new set.</param>
		/// <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="collection" /> is <see langword="null" />.</exception>
		public HashSet(IEnumerable<T> collection, IEqualityComparer<T> comparer)
			: this(comparer)
		{
			if (collection == null)
			{
				throw new ArgumentNullException("collection");
			}
			if (collection is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet))
			{
				CopyFrom(hashSet);
				return;
			}
			Initialize((collection is ICollection<T> collection2) ? collection2.Count : 0);
			UnionWith(collection);
			if (_count > 0 && _slots.Length / _count > 3)
			{
				TrimExcess();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class with serialized data.</summary>
		/// <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
		/// <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
		protected HashSet(SerializationInfo info, StreamingContext context)
		{
			_siInfo = info;
		}

		private void CopyFrom(HashSet<T> source)
		{
			int count = source._count;
			if (count == 0)
			{
				return;
			}
			int num = source._buckets.Length;
			if (HashHelpers.ExpandPrime(count + 1) >= num)
			{
				_buckets = (int[])source._buckets.Clone();
				_slots = (Slot[])source._slots.Clone();
				_lastIndex = source._lastIndex;
				_freeList = source._freeList;
			}
			else
			{
				int lastIndex = source._lastIndex;
				Slot[] slots = source._slots;
				Initialize(count);
				int num2 = 0;
				for (int i = 0; i < lastIndex; i++)
				{
					int hashCode = slots[i].hashCode;
					if (hashCode >= 0)
					{
						AddValue(num2, hashCode, slots[i].value);
						num2++;
					}
				}
				_lastIndex = num2;
			}
			_count = count;
		}

		/// <summary>
		///   Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, and has sufficient capacity to accommodate <paramref name="capacity" /> elements.
		/// 		</summary>
		/// <param name="capacity">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></param>
		/// <param name="comparer">
		/// 				The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or null (Nothing in Visual Basic) to use the default <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation for the set type.
		/// 			</param>
		public HashSet(int capacity, IEqualityComparer<T> comparer)
			: this(comparer)
		{
			if (capacity < 0)
			{
				throw new ArgumentOutOfRangeException("capacity");
			}
			if (capacity > 0)
			{
				Initialize(capacity);
			}
		}

		/// <summary>Adds an item to an <see cref="T:System.Collections.Generic.ICollection`1" /> object.</summary>
		/// <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" /> object.</param>
		/// <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
		void ICollection<T>.Add(T item)
		{
			AddIfNotPresent(item);
		}

		/// <summary>Removes all elements from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</summary>
		public void Clear()
		{
			if (_lastIndex > 0)
			{
				Array.Clear(_slots, 0, _lastIndex);
				Array.Clear(_buckets, 0, _buckets.Length);
				_lastIndex = 0;
				_count = 0;
				_freeList = -1;
			}
			_version++;
		}

		/// <summary>Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element.</summary>
		/// <param name="item">The element to locate in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element; otherwise, <see langword="false" />.</returns>
		public bool Contains(T item)
		{
			if (_buckets != null)
			{
				int num = 0;
				int num2 = InternalGetHashCode(item);
				Slot[] slots = _slots;
				for (int num3 = _buckets[num2 % _buckets.Length] - 1; num3 >= 0; num3 = slots[num3].next)
				{
					if (slots[num3].hashCode == num2 && _comparer.Equals(slots[num3].value, item))
					{
						return true;
					}
					if (num >= slots.Length)
					{
						throw new InvalidOperationException("Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.");
					}
					num++;
				}
			}
			return false;
		}

		/// <summary>Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</summary>
		/// <param name="array">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object. The array must have zero-based indexing.</param>
		/// <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="array" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="arrayIndex" /> is less than 0.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</exception>
		public void CopyTo(T[] array, int arrayIndex)
		{
			CopyTo(array, arrayIndex, _count);
		}

		/// <summary>Removes the specified element from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</summary>
		/// <param name="item">The element to remove.</param>
		/// <returns>
		///     <see langword="true" /> if the element is successfully found and removed; otherwise, <see langword="false" />.  This method returns <see langword="false" /> if <paramref name="item" /> is not found in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</returns>
		public bool Remove(T item)
		{
			if (_buckets != null)
			{
				int num = InternalGetHashCode(item);
				int num2 = num % _buckets.Length;
				int num3 = -1;
				int num4 = 0;
				Slot[] slots = _slots;
				for (int num5 = _buckets[num2] - 1; num5 >= 0; num5 = slots[num5].next)
				{
					if (slots[num5].hashCode == num && _comparer.Equals(slots[num5].value, item))
					{
						if (num3 < 0)
						{
							_buckets[num2] = slots[num5].next + 1;
						}
						else
						{
							slots[num3].next = slots[num5].next;
						}
						slots[num5].hashCode = -1;
						if (RuntimeHelpers.IsReferenceOrContainsReferences<T>())
						{
							slots[num5].value = default(T);
						}
						slots[num5].next = _freeList;
						_count--;
						_version++;
						if (_count == 0)
						{
							_lastIndex = 0;
							_freeList = -1;
						}
						else
						{
							_freeList = num5;
						}
						return true;
					}
					if (num4 >= slots.Length)
					{
						throw new InvalidOperationException("Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.");
					}
					num4++;
					num3 = num5;
				}
			}
			return false;
		}

		/// <summary>Returns an enumerator that iterates through a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</summary>
		/// <returns>A <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> object for the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</returns>
		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		/// <summary>Returns an enumerator that iterates through a collection.</summary>
		/// <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" /> object that can be used to iterate through the collection.</returns>
		IEnumerator<T> IEnumerable<T>.GetEnumerator()
		{
			return new Enumerator(this);
		}

		/// <summary>Returns an enumerator that iterates through a collection.</summary>
		/// <returns>An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</returns>
		IEnumerator IEnumerable.GetEnumerator()
		{
			return new Enumerator(this);
		}

		/// <summary>Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and returns the data needed to serialize a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</summary>
		/// <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
		/// <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="info" /> is <see langword="null" />.</exception>
		[SecurityCritical]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		public virtual void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			if (info == null)
			{
				throw new ArgumentNullException("info");
			}
			info.AddValue("Version", _version);
			info.AddValue("Comparer", _comparer, typeof(IComparer<T>));
			info.AddValue("Capacity", (_buckets != null) ? _buckets.Length : 0);
			if (_buckets != null)
			{
				T[] array = new T[_count];
				CopyTo(array);
				info.AddValue("Elements", array, typeof(T[]));
			}
		}

		/// <summary>Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and raises the deserialization event when the deserialization is complete.</summary>
		/// <param name="sender">The source of the deserialization event.</param>
		/// <exception cref="T:System.Runtime.Serialization.SerializationException">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object associated with the current <see cref="T:System.Collections.Generic.HashSet`1" /> object is invalid.</exception>
		public virtual void OnDeserialization(object sender)
		{
			if (_siInfo == null)
			{
				return;
			}
			int @int = _siInfo.GetInt32("Capacity");
			_comparer = (IEqualityComparer<T>)_siInfo.GetValue("Comparer", typeof(IEqualityComparer<T>));
			_freeList = -1;
			if (@int != 0)
			{
				_buckets = new int[@int];
				_slots = new Slot[@int];
				T[] array = (T[])_siInfo.GetValue("Elements", typeof(T[]));
				if (array == null)
				{
					throw new SerializationException("The keys for this dictionary are missing.");
				}
				for (int i = 0; i < array.Length; i++)
				{
					AddIfNotPresent(array[i]);
				}
			}
			else
			{
				_buckets = null;
			}
			_version = _siInfo.GetInt32("Version");
			_siInfo = null;
		}

		/// <summary>Adds the specified element to a set.</summary>
		/// <param name="item">The element to add to the set.</param>
		/// <returns>
		///     <see langword="true" /> if the element is added to the <see cref="T:System.Collections.Generic.HashSet`1" /> object; <see langword="false" /> if the element is already present.</returns>
		public bool Add(T item)
		{
			return AddIfNotPresent(item);
		}

		/// <summary>Searches the set for a given value and returns the equal value it finds, if any.</summary>
		/// <param name="equalValue">The value to search for.</param>
		/// <param name="actualValue">The value from the set that the search found, or the default value of T when the search yielded no match.</param>
		/// <returns>A value indicating whether the search was successful.</returns>
		public bool TryGetValue(T equalValue, out T actualValue)
		{
			if (_buckets != null)
			{
				int num = InternalIndexOf(equalValue);
				if (num >= 0)
				{
					actualValue = _slots[num].value;
					return true;
				}
			}
			actualValue = default(T);
			return false;
		}

		/// <summary>Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain all elements that are present in itself, the specified collection, or both.</summary>
		/// <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="other" /> is <see langword="null" />.</exception>
		public void UnionWith(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			foreach (T item in other)
			{
				AddIfNotPresent(item);
			}
		}

		/// <summary>Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present in that object and in the specified collection.</summary>
		/// <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="other" /> is <see langword="null" />.</exception>
		public void IntersectWith(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (_count == 0 || other == this)
			{
				return;
			}
			if (other is ICollection<T> collection)
			{
				if (collection.Count == 0)
				{
					Clear();
					return;
				}
				if (other is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet))
				{
					IntersectWithHashSetWithSameEC(hashSet);
					return;
				}
			}
			IntersectWithEnumerable(other);
		}

		/// <summary>Removes all elements in the specified collection from the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</summary>
		/// <param name="other">The collection of items to remove from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="other" /> is <see langword="null" />.</exception>
		public void ExceptWith(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (_count == 0)
			{
				return;
			}
			if (other == this)
			{
				Clear();
				return;
			}
			foreach (T item in other)
			{
				Remove(item);
			}
		}

		/// <summary>Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present either in that object or in the specified collection, but not both.</summary>
		/// <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="other" /> is <see langword="null" />.</exception>
		public void SymmetricExceptWith(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (_count == 0)
			{
				UnionWith(other);
			}
			else if (other == this)
			{
				Clear();
			}
			else if (other is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet))
			{
				SymmetricExceptWithUniqueHashSet(hashSet);
			}
			else
			{
				SymmetricExceptWithEnumerable(other);
			}
		}

		/// <summary>Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of the specified collection.</summary>
		/// <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of <paramref name="other" />; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="other" /> is <see langword="null" />.</exception>
		public bool IsSubsetOf(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (_count == 0)
			{
				return true;
			}
			if (other == this)
			{
				return true;
			}
			if (other is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet))
			{
				if (_count > hashSet.Count)
				{
					return false;
				}
				return IsSubsetOfHashSetWithSameEC(hashSet);
			}
			ElementCount elementCount = CheckUniqueAndUnfoundElements(other, returnIfUnfound: false);
			if (elementCount.uniqueCount == _count)
			{
				return elementCount.unfoundCount >= 0;
			}
			return false;
		}

		/// <summary>Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of the specified collection.</summary>
		/// <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of <paramref name="other" />; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="other" /> is <see langword="null" />.</exception>
		public bool IsProperSubsetOf(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (other == this)
			{
				return false;
			}
			if (other is ICollection<T> collection)
			{
				if (collection.Count == 0)
				{
					return false;
				}
				if (_count == 0)
				{
					return collection.Count > 0;
				}
				if (other is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet))
				{
					if (_count >= hashSet.Count)
					{
						return false;
					}
					return IsSubsetOfHashSetWithSameEC(hashSet);
				}
			}
			ElementCount elementCount = CheckUniqueAndUnfoundElements(other, returnIfUnfound: false);
			if (elementCount.uniqueCount == _count)
			{
				return elementCount.unfoundCount > 0;
			}
			return false;
		}

		/// <summary>Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of the specified collection.</summary>
		/// <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of <paramref name="other" />; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="other" /> is <see langword="null" />.</exception>
		public bool IsSupersetOf(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (other == this)
			{
				return true;
			}
			if (other is ICollection<T> collection)
			{
				if (collection.Count == 0)
				{
					return true;
				}
				if (other is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet) && hashSet.Count > _count)
				{
					return false;
				}
			}
			return ContainsAllElements(other);
		}

		/// <summary>Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of the specified collection.</summary>
		/// <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object. </param>
		/// <returns>
		///     <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of <paramref name="other" />; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="other" /> is <see langword="null" />.</exception>
		public bool IsProperSupersetOf(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (_count == 0)
			{
				return false;
			}
			if (other == this)
			{
				return false;
			}
			if (other is ICollection<T> collection)
			{
				if (collection.Count == 0)
				{
					return true;
				}
				if (other is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet))
				{
					if (hashSet.Count >= _count)
					{
						return false;
					}
					return ContainsAllElements(hashSet);
				}
			}
			ElementCount elementCount = CheckUniqueAndUnfoundElements(other, returnIfUnfound: true);
			if (elementCount.uniqueCount < _count)
			{
				return elementCount.unfoundCount == 0;
			}
			return false;
		}

		/// <summary>Determines whether the current <see cref="T:System.Collections.Generic.HashSet`1" /> object and a specified collection share common elements.</summary>
		/// <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object and <paramref name="other" /> share at least one common element; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="other" /> is <see langword="null" />.</exception>
		public bool Overlaps(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (_count == 0)
			{
				return false;
			}
			if (other == this)
			{
				return true;
			}
			foreach (T item in other)
			{
				if (Contains(item))
				{
					return true;
				}
			}
			return false;
		}

		/// <summary>Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object and the specified collection contain the same elements.</summary>
		/// <param name="other">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</param>
		/// <returns>
		///     <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is equal to <paramref name="other" />; otherwise, false.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="other" /> is <see langword="null" />.</exception>
		public bool SetEquals(IEnumerable<T> other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			if (other == this)
			{
				return true;
			}
			if (other is HashSet<T> hashSet && AreEqualityComparersEqual(this, hashSet))
			{
				if (_count != hashSet.Count)
				{
					return false;
				}
				return ContainsAllElements(hashSet);
			}
			if (other is ICollection<T> collection && _count == 0 && collection.Count > 0)
			{
				return false;
			}
			ElementCount elementCount = CheckUniqueAndUnfoundElements(other, returnIfUnfound: true);
			if (elementCount.uniqueCount == _count)
			{
				return elementCount.unfoundCount == 0;
			}
			return false;
		}

		/// <summary>Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array.</summary>
		/// <param name="array">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object. The array must have zero-based indexing.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="array" /> is <see langword="null" />.</exception>
		public void CopyTo(T[] array)
		{
			CopyTo(array, 0, _count);
		}

		/// <summary>Copies the specified number of elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</summary>
		/// <param name="array">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object. The array must have zero-based indexing.</param>
		/// <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
		/// <param name="count">The number of elements to copy to <paramref name="array" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="array" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="arrayIndex" /> is less than 0.-or-
		///         <paramref name="count" /> is less than 0.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.-or-
		///         <paramref name="count" /> is greater than the available space from the <paramref name="index" /> to the end of the destination <paramref name="array" />.</exception>
		public void CopyTo(T[] array, int arrayIndex, int count)
		{
			if (array == null)
			{
				throw new ArgumentNullException("array");
			}
			if (arrayIndex < 0)
			{
				throw new ArgumentOutOfRangeException("arrayIndex", arrayIndex, "Non negative number is required.");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", count, "Non negative number is required.");
			}
			if (arrayIndex > array.Length || count > array.Length - arrayIndex)
			{
				throw new ArgumentException("Destination array is not long enough to copy all the items in the collection. Check array index and length.");
			}
			int num = 0;
			for (int i = 0; i < _lastIndex; i++)
			{
				if (num >= count)
				{
					break;
				}
				if (_slots[i].hashCode >= 0)
				{
					array[arrayIndex + num] = _slots[i].value;
					num++;
				}
			}
		}

		/// <summary>Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</summary>
		/// <param name="match">The <see cref="T:System.Predicate`1" /> delegate that defines the conditions of the elements to remove.</param>
		/// <returns>The number of elements that were removed from the <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="match" /> is <see langword="null" />.</exception>
		public int RemoveWhere(Predicate<T> match)
		{
			if (match == null)
			{
				throw new ArgumentNullException("match");
			}
			int num = 0;
			for (int i = 0; i < _lastIndex; i++)
			{
				if (_slots[i].hashCode >= 0)
				{
					T value = _slots[i].value;
					if (match(value) && Remove(value))
					{
						num++;
					}
				}
			}
			return num;
		}

		public int EnsureCapacity(int capacity)
		{
			if (capacity < 0)
			{
				throw new ArgumentOutOfRangeException("capacity");
			}
			int num = ((_slots != null) ? _slots.Length : 0);
			if (num >= capacity)
			{
				return num;
			}
			if (_buckets == null)
			{
				return Initialize(capacity);
			}
			int prime = HashHelpers.GetPrime(capacity);
			SetCapacity(prime);
			return prime;
		}

		/// <summary>Sets the capacity of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to the actual number of elements it contains, rounded up to a nearby, implementation-specific value.</summary>
		public void TrimExcess()
		{
			if (_count == 0)
			{
				_buckets = null;
				_slots = null;
				_version++;
				return;
			}
			int prime = HashHelpers.GetPrime(_count);
			Slot[] array = new Slot[prime];
			int[] array2 = new int[prime];
			int num = 0;
			for (int i = 0; i < _lastIndex; i++)
			{
				if (_slots[i].hashCode >= 0)
				{
					array[num] = _slots[i];
					int num2 = array[num].hashCode % prime;
					array[num].next = array2[num2] - 1;
					array2[num2] = num + 1;
					num++;
				}
			}
			_lastIndex = num;
			_slots = array;
			_buckets = array2;
			_freeList = -1;
		}

		/// <summary>Returns an <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for equality testing of a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</summary>
		/// <returns>An <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for deep equality testing of the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</returns>
		public static IEqualityComparer<HashSet<T>> CreateSetComparer()
		{
			return new HashSetEqualityComparer<T>();
		}

		private int Initialize(int capacity)
		{
			int prime = HashHelpers.GetPrime(capacity);
			_buckets = new int[prime];
			_slots = new Slot[prime];
			return prime;
		}

		private void IncreaseCapacity()
		{
			int num = HashHelpers.ExpandPrime(_count);
			if (num <= _count)
			{
				throw new ArgumentException("HashSet capacity is too big.");
			}
			SetCapacity(num);
		}

		private void SetCapacity(int newSize)
		{
			Slot[] array = new Slot[newSize];
			if (_slots != null)
			{
				Array.Copy(_slots, 0, array, 0, _lastIndex);
			}
			int[] array2 = new int[newSize];
			for (int i = 0; i < _lastIndex; i++)
			{
				int num = array[i].hashCode % newSize;
				array[i].next = array2[num] - 1;
				array2[num] = i + 1;
			}
			_slots = array;
			_buckets = array2;
		}

		private bool AddIfNotPresent(T value)
		{
			if (_buckets == null)
			{
				Initialize(0);
			}
			int num = InternalGetHashCode(value);
			int num2 = num % _buckets.Length;
			int num3 = 0;
			Slot[] slots = _slots;
			for (int num4 = _buckets[num2] - 1; num4 >= 0; num4 = slots[num4].next)
			{
				if (slots[num4].hashCode == num && _comparer.Equals(slots[num4].value, value))
				{
					return false;
				}
				if (num3 >= slots.Length)
				{
					throw new InvalidOperationException("Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.");
				}
				num3++;
			}
			int num5;
			if (_freeList >= 0)
			{
				num5 = _freeList;
				_freeList = slots[num5].next;
			}
			else
			{
				if (_lastIndex == slots.Length)
				{
					IncreaseCapacity();
					slots = _slots;
					num2 = num % _buckets.Length;
				}
				num5 = _lastIndex;
				_lastIndex++;
			}
			slots[num5].hashCode = num;
			slots[num5].value = value;
			slots[num5].next = _buckets[num2] - 1;
			_buckets[num2] = num5 + 1;
			_count++;
			_version++;
			return true;
		}

		private void AddValue(int index, int hashCode, T value)
		{
			int num = hashCode % _buckets.Length;
			_slots[index].hashCode = hashCode;
			_slots[index].value = value;
			_slots[index].next = _buckets[num] - 1;
			_buckets[num] = index + 1;
		}

		private bool ContainsAllElements(IEnumerable<T> other)
		{
			foreach (T item in other)
			{
				if (!Contains(item))
				{
					return false;
				}
			}
			return true;
		}

		private bool IsSubsetOfHashSetWithSameEC(HashSet<T> other)
		{
			using (Enumerator enumerator = GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					T current = enumerator.Current;
					if (!other.Contains(current))
					{
						return false;
					}
				}
			}
			return true;
		}

		private void IntersectWithHashSetWithSameEC(HashSet<T> other)
		{
			for (int i = 0; i < _lastIndex; i++)
			{
				if (_slots[i].hashCode >= 0)
				{
					T value = _slots[i].value;
					if (!other.Contains(value))
					{
						Remove(value);
					}
				}
			}
		}

		private unsafe void IntersectWithEnumerable(IEnumerable<T> other)
		{
			int lastIndex = _lastIndex;
			int num = System.Collections.Generic.BitHelper.ToIntArrayLength(lastIndex);
			System.Collections.Generic.BitHelper bitHelper = ((num > 100) ? new System.Collections.Generic.BitHelper(new int[num], num) : new System.Collections.Generic.BitHelper(stackalloc int[num], num));
			foreach (T item in other)
			{
				int num2 = InternalIndexOf(item);
				if (num2 >= 0)
				{
					bitHelper.MarkBit(num2);
				}
			}
			for (int i = 0; i < lastIndex; i++)
			{
				if (_slots[i].hashCode >= 0 && !bitHelper.IsMarked(i))
				{
					Remove(_slots[i].value);
				}
			}
		}

		private int InternalIndexOf(T item)
		{
			int num = 0;
			int num2 = InternalGetHashCode(item);
			Slot[] slots = _slots;
			for (int num3 = _buckets[num2 % _buckets.Length] - 1; num3 >= 0; num3 = slots[num3].next)
			{
				if (slots[num3].hashCode == num2 && _comparer.Equals(slots[num3].value, item))
				{
					return num3;
				}
				if (num >= slots.Length)
				{
					throw new InvalidOperationException("Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.");
				}
				num++;
			}
			return -1;
		}

		private void SymmetricExceptWithUniqueHashSet(HashSet<T> other)
		{
			foreach (T item in other)
			{
				if (!Remove(item))
				{
					AddIfNotPresent(item);
				}
			}
		}

		private unsafe void SymmetricExceptWithEnumerable(IEnumerable<T> other)
		{
			int lastIndex = _lastIndex;
			int num = System.Collections.Generic.BitHelper.ToIntArrayLength(lastIndex);
			System.Collections.Generic.BitHelper bitHelper;
			System.Collections.Generic.BitHelper bitHelper2;
			if (num <= 50)
			{
				bitHelper = new System.Collections.Generic.BitHelper(stackalloc int[num], num);
				bitHelper2 = new System.Collections.Generic.BitHelper(stackalloc int[num], num);
			}
			else
			{
				bitHelper = new System.Collections.Generic.BitHelper(new int[num], num);
				bitHelper2 = new System.Collections.Generic.BitHelper(new int[num], num);
			}
			foreach (T item in other)
			{
				int location = 0;
				if (AddOrGetLocation(item, out location))
				{
					bitHelper2.MarkBit(location);
				}
				else if (location < lastIndex && !bitHelper2.IsMarked(location))
				{
					bitHelper.MarkBit(location);
				}
			}
			for (int i = 0; i < lastIndex; i++)
			{
				if (bitHelper.IsMarked(i))
				{
					Remove(_slots[i].value);
				}
			}
		}

		private bool AddOrGetLocation(T value, out int location)
		{
			int num = InternalGetHashCode(value);
			int num2 = num % _buckets.Length;
			int num3 = 0;
			Slot[] slots = _slots;
			for (int num4 = _buckets[num2] - 1; num4 >= 0; num4 = slots[num4].next)
			{
				if (slots[num4].hashCode == num && _comparer.Equals(slots[num4].value, value))
				{
					location = num4;
					return false;
				}
				if (num3 >= slots.Length)
				{
					throw new InvalidOperationException("Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.");
				}
				num3++;
			}
			int num5;
			if (_freeList >= 0)
			{
				num5 = _freeList;
				_freeList = slots[num5].next;
			}
			else
			{
				if (_lastIndex == slots.Length)
				{
					IncreaseCapacity();
					slots = _slots;
					num2 = num % _buckets.Length;
				}
				num5 = _lastIndex;
				_lastIndex++;
			}
			slots[num5].hashCode = num;
			slots[num5].value = value;
			slots[num5].next = _buckets[num2] - 1;
			_buckets[num2] = num5 + 1;
			_count++;
			_version++;
			location = num5;
			return true;
		}

		private unsafe ElementCount CheckUniqueAndUnfoundElements(IEnumerable<T> other, bool returnIfUnfound)
		{
			ElementCount result = default(ElementCount);
			if (_count == 0)
			{
				int num = 0;
				using (IEnumerator<T> enumerator = other.GetEnumerator())
				{
					if (enumerator.MoveNext())
					{
						_ = enumerator.Current;
						num++;
					}
				}
				result.uniqueCount = 0;
				result.unfoundCount = num;
				return result;
			}
			int num2 = System.Collections.Generic.BitHelper.ToIntArrayLength(_lastIndex);
			System.Collections.Generic.BitHelper bitHelper = ((num2 > 100) ? new System.Collections.Generic.BitHelper(new int[num2], num2) : new System.Collections.Generic.BitHelper(stackalloc int[num2], num2));
			int num3 = 0;
			int num4 = 0;
			foreach (T item in other)
			{
				int num5 = InternalIndexOf(item);
				if (num5 >= 0)
				{
					if (!bitHelper.IsMarked(num5))
					{
						bitHelper.MarkBit(num5);
						num4++;
					}
				}
				else
				{
					num3++;
					if (returnIfUnfound)
					{
						break;
					}
				}
			}
			result.uniqueCount = num4;
			result.unfoundCount = num3;
			return result;
		}

		internal static bool HashSetEquals(HashSet<T> set1, HashSet<T> set2, IEqualityComparer<T> comparer)
		{
			if (set1 == null)
			{
				return set2 == null;
			}
			if (set2 == null)
			{
				return false;
			}
			if (AreEqualityComparersEqual(set1, set2))
			{
				if (set1.Count != set2.Count)
				{
					return false;
				}
				foreach (T item in set2)
				{
					if (!set1.Contains(item))
					{
						return false;
					}
				}
				return true;
			}
			foreach (T item2 in set2)
			{
				bool flag = false;
				foreach (T item3 in set1)
				{
					if (comparer.Equals(item2, item3))
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					return false;
				}
			}
			return true;
		}

		private static bool AreEqualityComparersEqual(HashSet<T> set1, HashSet<T> set2)
		{
			return set1.Comparer.Equals(set2.Comparer);
		}

		private int InternalGetHashCode(T item)
		{
			if (item == null)
			{
				return 0;
			}
			return _comparer.GetHashCode(item) & 0x7FFFFFFF;
		}
	}
	[Serializable]
	internal sealed class HashSetEqualityComparer<T> : IEqualityComparer<HashSet<T>>
	{
		private readonly IEqualityComparer<T> _comparer;

		public HashSetEqualityComparer()
		{
			_comparer = EqualityComparer<T>.Default;
		}

		public bool Equals(HashSet<T> x, HashSet<T> y)
		{
			return HashSet<T>.HashSetEquals(x, y, _comparer);
		}

		public int GetHashCode(HashSet<T> obj)
		{
			int num = 0;
			if (obj != null)
			{
				foreach (T item in obj)
				{
					num ^= _comparer.GetHashCode(item) & 0x7FFFFFFF;
				}
			}
			return num;
		}

		public override bool Equals(object obj)
		{
			if (!(obj is HashSetEqualityComparer<T> hashSetEqualityComparer))
			{
				return false;
			}
			return _comparer == hashSetEqualityComparer._comparer;
		}

		public override int GetHashCode()
		{
			return _comparer.GetHashCode();
		}
	}
	internal sealed class ICollectionDebugView<T>
	{
		private readonly ICollection<T> _collection;

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
		public T[] Items
		{
			get
			{
				T[] array = new T[_collection.Count];
				_collection.CopyTo(array, 0);
				return array;
			}
		}

		public ICollectionDebugView(ICollection<T> collection)
		{
			if (collection == null)
			{
				throw new ArgumentNullException("collection");
			}
			_collection = collection;
		}
	}
}
namespace System.Threading
{
	/// <summary>Specifies whether a lock can be entered multiple times by the same thread.</summary>
	public enum LockRecursionPolicy
	{
		/// <summary>If a thread tries to enter a lock recursively, an exception is thrown. Some classes may allow certain recursions when this setting is in effect. </summary>
		NoRecursion,
		/// <summary>A thread can enter a lock recursively. Some classes may restrict this capability. </summary>
		SupportsRecursion
	}
	internal class ReaderWriterCount
	{
		public long lockID;

		public int readercount;

		public int writercount;

		public int upgradecount;

		public ReaderWriterCount next;
	}
	/// <summary>Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class ReaderWriterLockSlim : IDisposable
	{
		private struct TimeoutTracker
		{
			private int m_total;

			private int m_start;

			public int RemainingMilliseconds
			{
				get
				{
					if (m_total == -1 || m_total == 0)
					{
						return m_total;
					}
					int num = Environment.TickCount - m_start;
					if (num < 0 || num >= m_total)
					{
						return 0;
					}
					return m_total - num;
				}
			}

			public bool IsExpired => RemainingMilliseconds == 0;

			public TimeoutTracker(TimeSpan timeout)
			{
				long num = (long)timeout.TotalMilliseconds;
				if (num < -1 || num > int.MaxValue)
				{
					throw new ArgumentOutOfRangeException("timeout");
				}
				m_total = (int)num;
				if (m_total != -1 && m_total != 0)
				{
					m_start = Environment.TickCount;
				}
				else
				{
					m_start = 0;
				}
			}

			public TimeoutTracker(int millisecondsTimeout)
			{
				if (millisecondsTimeout < -1)
				{
					throw new ArgumentOutOfRangeException("millisecondsTimeout");
				}
				m_total = millisecondsTimeout;
				if (m_total != -1 && m_total != 0)
				{
					m_start = Environment.TickCount;
				}
				else
				{
					m_start = 0;
				}
			}
		}

		private bool fIsReentrant;

		private int myLock;

		private const int LockSpinCycles = 20;

		private const int LockSpinCount = 10;

		private const int LockSleep0Count = 5;

		private uint numWriteWaiters;

		private uint numReadWaiters;

		private uint numWriteUpgradeWaiters;

		private uint numUpgradeWaiters;

		private bool fNoWaiters;

		private int upgradeLockOwnerId;

		private int writeLockOwnerId;

		private EventWaitHandle writeEvent;

		private EventWaitHandle readEvent;

		private EventWaitHandle upgradeEvent;

		private EventWaitHandle waitUpgradeEvent;

		private static long s_nextLockID;

		private long lockID;

		[ThreadStatic]
		private static ReaderWriterCount t_rwc;

		private bool fUpgradeThreadHoldingRead;

		private const int MaxSpinCount = 20;

		private uint owners;

		private const uint WRITER_HELD = 2147483648u;

		private const uint WAITING_WRITERS = 1073741824u;

		private const uint WAITING_UPGRADER = 536870912u;

		private const uint MAX_READER = 268435454u;

		private const uint READER_MASK = 268435455u;

		private bool fDisposed;

		/// <summary>Gets a value that indicates whether the current thread has entered the lock in read mode.</summary>
		/// <returns>
		///     <see langword="true" /> if the current thread has entered read mode; otherwise, <see langword="false" />.</returns>
		public bool IsReadLockHeld
		{
			get
			{
				if (RecursiveReadCount > 0)
				{
					return true;
				}
				return false;
			}
		}

		/// <summary>Gets a value that indicates whether the current thread has entered the lock in upgradeable mode. </summary>
		/// <returns>
		///     <see langword="true" /> if the current thread has entered upgradeable mode; otherwise, <see langword="false" />.</returns>
		public bool IsUpgradeableReadLockHeld
		{
			get
			{
				if (RecursiveUpgradeCount > 0)
				{
					return true;
				}
				return false;
			}
		}

		/// <summary>Gets a value that indicates whether the current thread has entered the lock in write mode.</summary>
		/// <returns>
		///     <see langword="true" /> if the current thread has entered write mode; otherwise, <see langword="false" />.</returns>
		public bool IsWriteLockHeld
		{
			get
			{
				if (RecursiveWriteCount > 0)
				{
					return true;
				}
				return false;
			}
		}

		/// <summary>Gets a value that indicates the recursion policy for the current <see cref="T:System.Threading.ReaderWriterLockSlim" /> object.</summary>
		/// <returns>One of the enumeration values that specifies the lock recursion policy.</returns>
		public LockRecursionPolicy RecursionPolicy
		{
			get
			{
				if (fIsReentrant)
				{
					return LockRecursionPolicy.SupportsRecursion;
				}
				return LockRecursionPolicy.NoRecursion;
			}
		}

		/// <summary>Gets the total number of unique threads that have entered the lock in read mode.</summary>
		/// <returns>The number of unique threads that have entered the lock in read mode.</returns>
		public int CurrentReadCount
		{
			get
			{
				int numReaders = (int)GetNumReaders();
				if (upgradeLockOwnerId != -1)
				{
					return numReaders - 1;
				}
				return numReaders;
			}
		}

		/// <summary>Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</summary>
		/// <returns>0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or n if the thread has entered the lock recursively n - 1 times.</returns>
		public int RecursiveReadCount
		{
			get
			{
				int result = 0;
				ReaderWriterCount threadRWCount = GetThreadRWCount(dontAllocate: true);
				if (threadRWCount != null)
				{
					result = threadRWCount.readercount;
				}
				return result;
			}
		}

		/// <summary>Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</summary>
		/// <returns>0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or n if the thread has entered upgradeable mode recursively n - 1 times.</returns>
		public int RecursiveUpgradeCount
		{
			get
			{
				if (fIsReentrant)
				{
					int result = 0;
					ReaderWriterCount threadRWCount = GetThreadRWCount(dontAllocate: true);
					if (threadRWCount != null)
					{
						result = threadRWCount.upgradecount;
					}
					return result;
				}
				if (Thread.CurrentThread.ManagedThreadId == upgradeLockOwnerId)
				{
					return 1;
				}
				return 0;
			}
		}

		/// <summary>Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</summary>
		/// <returns>0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or n if the thread has entered write mode recursively n - 1 times.</returns>
		public int RecursiveWriteCount
		{
			get
			{
				if (fIsReentrant)
				{
					int result = 0;
					ReaderWriterCount threadRWCount = GetThreadRWCount(dontAllocate: true);
					if (threadRWCount != null)
					{
						result = threadRWCount.writercount;
					}
					return result;
				}
				if (Thread.CurrentThread.ManagedThreadId == writeLockOwnerId)
				{
					return 1;
				}
				return 0;
			}
		}

		/// <summary>Gets the total number of threads that are waiting to enter the lock in read mode.</summary>
		/// <returns>The total number of threads that are waiting to enter read mode.</returns>
		public int WaitingReadCount => (int)numReadWaiters;

		/// <summary>Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</summary>
		/// <returns>The total number of threads that are waiting to enter upgradeable mode.</returns>
		public int WaitingUpgradeCount => (int)numUpgradeWaiters;

		/// <summary>Gets the total number of threads that are waiting to enter the lock in write mode.</summary>
		/// <returns>The total number of threads that are waiting to enter write mode.</returns>
		public int WaitingWriteCount => (int)numWriteWaiters;

		private void InitializeThreadCounts()
		{
			upgradeLockOwnerId = -1;
			writeLockOwnerId = -1;
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class with default property values.</summary>
		public ReaderWriterLockSlim()
			: this(LockRecursionPolicy.NoRecursion)
		{
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class, specifying the lock recursion policy.</summary>
		/// <param name="recursionPolicy">One of the enumeration values that specifies the lock recursion policy.</param>
		public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy)
		{
			if (recursionPolicy == LockRecursionPolicy.SupportsRecursion)
			{
				fIsReentrant = true;
			}
			InitializeThreadCounts();
			fNoWaiters = true;
			lockID = Interlocked.Increment(ref s_nextLockID);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static bool IsRWEntryEmpty(ReaderWriterCount rwc)
		{
			if (rwc.lockID == 0L)
			{
				return true;
			}
			if (rwc.readercount == 0 && rwc.writercount == 0 && rwc.upgradecount == 0)
			{
				return true;
			}
			return false;
		}

		private bool IsRwHashEntryChanged(ReaderWriterCount lrwc)
		{
			return lrwc.lockID != lockID;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private ReaderWriterCount GetThreadRWCount(bool dontAllocate)
		{
			ReaderWriterCount next = t_rwc;
			ReaderWriterCount readerWriterCount = null;
			while (next != null)
			{
				if (next.lockID == lockID)
				{
					return next;
				}
				if (!dontAllocate && readerWriterCount == null && IsRWEntryEmpty(next))
				{
					readerWriterCount = next;
				}
				next = next.next;
			}
			if (dontAllocate)
			{
				return null;
			}
			if (readerWriterCount == null)
			{
				readerWriterCount = new ReaderWriterCount();
				readerWriterCount.next = t_rwc;
				t_rwc = readerWriterCount;
			}
			readerWriterCount.lockID = lockID;
			return readerWriterCount;
		}

		/// <summary>Tries to enter the lock in read mode.</summary>
		/// <exception cref="T:System.Threading.LockRecursionException">The current thread cannot acquire the write lock when it holds the read lock.-or-The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the read lock. -or-The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" />, and the current thread has attempted to acquire the read lock when it already holds the write lock. -or-The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception. </exception>
		/// <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed. </exception>
		public void EnterReadLock()
		{
			TryEnterReadLock(-1);
		}

		/// <summary>Tries to enter the lock in read mode, with an optional time-out.</summary>
		/// <param name="timeout">The interval to wait, or -1 milliseconds to wait indefinitely. </param>
		/// <returns>
		///     <see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.-or-The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds. </exception>
		/// <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed. </exception>
		public bool TryEnterReadLock(TimeSpan timeout)
		{
			return TryEnterReadLock(new TimeoutTracker(timeout));
		}

		/// <summary>Tries to enter the lock in read mode, with an optional integer time-out.</summary>
		/// <param name="millisecondsTimeout">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</param>
		/// <returns>
		///     <see langword="true" /> if the calling thread entered read mode, otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed. </exception>
		public bool TryEnterReadLock(int millisecondsTimeout)
		{
			return TryEnterReadLock(new TimeoutTracker(millisecondsTimeout));
		}

		private bool TryEnterReadLock(TimeoutTracker timeout)
		{
			return TryEnterReadLockCore(timeout);
		}

		private bool TryEnterReadLockCore(TimeoutTracker timeout)
		{
			if (fDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			ReaderWriterCount readerWriterCount = null;
			int managedThreadId = Thread.CurrentThread.ManagedThreadId;
			if (!fIsReentrant)
			{
				if (managedThreadId == writeLockOwnerId)
				{
					throw new LockRecursionException(SR.GetString("A read lock may not be acquired with the write lock held in this mode."));
				}
				EnterMyLock();
				readerWriterCount = GetThreadRWCount(dontAllocate: false);
				if (readerWriterCount.readercount > 0)
				{
					ExitMyLock();
					throw new LockRecursionException(SR.GetString("Recursive read lock acquisitions not allowed in this mode."));
				}
				if (managedThreadId == upgradeLockOwnerId)
				{
					readerWriterCount.readercount++;
					owners++;
					ExitMyLock();
					return true;
				}
			}
			else
			{
				EnterMyLock();
				readerWriterCount = GetThreadRWCount(dontAllocate: false);
				if (readerWriterCount.readercount > 0)
				{
					readerWriterCount.readercount++;
					ExitMyLock();
					return true;
				}
				if (managedThreadId == upgradeLockOwnerId)
				{
					readerWriterCount.readercount++;
					owners++;
					ExitMyLock();
					fUpgradeThreadHoldingRead = true;
					return true;
				}
				if (managedThreadId == writeLockOwnerId)
				{
					readerWriterCount.readercount++;
					owners++;
					ExitMyLock();
					return true;
				}
			}
			bool flag = true;
			int num = 0;
			while (true)
			{
				if (owners < 268435454)
				{
					owners++;
					readerWriterCount.readercount++;
					ExitMyLock();
					return flag;
				}
				if (num < 20)
				{
					ExitMyLock();
					if (timeout.IsExpired)
					{
						return false;
					}
					num++;
					SpinWait(num);
					EnterMyLock();
					if (IsRwHashEntryChanged(readerWriterCount))
					{
						readerWriterCount = GetThreadRWCount(dontAllocate: false);
					}
				}
				else if (readEvent == null)
				{
					LazyCreateEvent(ref readEvent, makeAutoResetEvent: false);
					if (IsRwHashEntryChanged(readerWriterCount))
					{
						readerWriterCount = GetThreadRWCount(dontAllocate: false);
					}
				}
				else
				{
					flag = WaitOnEvent(readEvent, ref numReadWaiters, timeout, isWriteWaiter: false);
					if (!flag)
					{
						break;
					}
					if (IsRwHashEntryChanged(readerWriterCount))
					{
						readerWriterCount = GetThreadRWCount(dontAllocate: false);
					}
				}
			}
			return false;
		}

		/// <summary>Tries to enter the lock in write mode.</summary>
		/// <exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode. -or-The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed. </exception>
		public void EnterWriteLock()
		{
			TryEnterWriteLock(-1);
		}

		/// <summary>Tries to enter the lock in write mode, with an optional time-out.</summary>
		/// <param name="timeout">The interval to wait, or -1 milliseconds to wait indefinitely.</param>
		/// <returns>
		///     <see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock. -or-The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.-or-The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds. </exception>
		/// <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed. </exception>
		public bool TryEnterWriteLock(TimeSpan timeout)
		{
			return TryEnterWriteLock(new TimeoutTracker(timeout));
		}

		/// <summary>Tries to enter the lock in write mode, with an optional time-out.</summary>
		/// <param name="millisecondsTimeout">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</param>
		/// <returns>
		///     <see langword="true" /> if the calling thread entered write mode, otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock. -or-The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed. </exception>
		/// <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed. </exception>
		public bool TryEnterWriteLock(int millisecondsTimeout)
		{
			return TryEnterWriteLock(new TimeoutTracker(millisecondsTimeout));
		}

		private bool TryEnterWriteLock(TimeoutTracker timeout)
		{
			return TryEnterWriteLockCore(timeout);
		}

		private bool TryEnterWriteLockCore(TimeoutTracker timeout)
		{
			if (fDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			int managedThreadId = Thread.CurrentThread.ManagedThreadId;
			bool flag = false;
			ReaderWriterCount threadRWCount;
			if (!fIsReentrant)
			{
				if (managedThreadId == writeLockOwnerId)
				{
					throw new LockRecursionException(SR.GetString("Recursive write lock acquisitions not allowed in this mode."));
				}
				if (managedThreadId == upgradeLockOwnerId)
				{
					flag = true;
				}
				EnterMyLock();
				threadRWCount = GetThreadRWCount(dontAllocate: true);
				if (threadRWCount != null && threadRWCount.readercount > 0)
				{
					ExitMyLock();
					throw new LockRecursionException(SR.GetString("Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Please ensure that read locks are released before taking a write lock. If an upgrade is necessary, use an upgrade lock in place of the read lock."));
				}
			}
			else
			{
				EnterMyLock();
				threadRWCount = GetThreadRWCount(dontAllocate: false);
				if (managedThreadId == writeLockOwnerId)
				{
					threadRWCount.writercount++;
					ExitMyLock();
					return true;
				}
				if (managedThreadId == upgradeLockOwnerId)
				{
					flag = true;
				}
				else if (threadRWCount.readercount > 0)
				{
					ExitMyLock();
					throw new LockRecursionException(SR.GetString("Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Please ensure that read locks are released before taking a write lock. If an upgrade is necessary, use an upgrade lock in place of the read lock."));
				}
			}
			int num = 0;
			while (true)
			{
				if (IsWriterAcquired())
				{
					SetWriterAcquired();
					break;
				}
				if (flag)
				{
					uint numReaders = GetNumReaders();
					if (numReaders == 1)
					{
						SetWriterAcquired();
						break;
					}
					if (numReaders == 2 && threadRWCount != null)
					{
						if (IsRwHashEntryChanged(threadRWCount))
						{
							threadRWCount = GetThreadRWCount(dontAllocate: false);
						}
						if (threadRWCount.readercount > 0)
						{
							SetWriterAcquired();
							break;
						}
					}
				}
				if (num < 20)
				{
					ExitMyLock();
					if (timeout.IsExpired)
					{
						return false;
					}
					num++;
					SpinWait(num);
					EnterMyLock();
				}
				else if (flag)
				{
					if (waitUpgradeEvent == null)
					{
						LazyCreateEvent(ref waitUpgradeEvent, makeAutoResetEvent: true);
					}
					else if (!WaitOnEvent(waitUpgradeEvent, ref numWriteUpgradeWaiters, timeout, isWriteWaiter: true))
					{
						return false;
					}
				}
				else if (writeEvent == null)
				{
					LazyCreateEvent(ref writeEvent, makeAutoResetEvent: true);
				}
				else if (!WaitOnEvent(writeEvent, ref numWriteWaiters, timeout, isWriteWaiter: true))
				{
					return false;
				}
			}
			if (fIsReentrant)
			{
				if (IsRwHashEntryChanged(threadRWCount))
				{
					threadRWCount = GetThreadRWCount(dontAllocate: false);
				}
				threadRWCount.writercount++;
			}
			ExitMyLock();
			writeLockOwnerId = managedThreadId;
			return true;
		}

		/// <summary>Tries to enter the lock in upgradeable mode.</summary>
		/// <exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock in any mode. -or-The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception>
		/// <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed. </exception>
		public void EnterUpgradeableReadLock()
		{
			TryEnterUpgradeableReadLock(-1);
		}

		/// <summary>Tries to enter the lock in upgradeable mode, with an optional time-out.</summary>
		/// <param name="timeout">The interval to wait, or -1 milliseconds to wait indefinitely.</param>
		/// <returns>
		///     <see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock. -or-The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="timeout" /> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.-or-The value of <paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds. </exception>
		/// <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed. </exception>
		public bool TryEnterUpgradeableReadLock(TimeSpan timeout)
		{
			return TryEnterUpgradeableReadLock(new TimeoutTracker(timeout));
		}

		/// <summary>Tries to enter the lock in upgradeable mode, with an optional time-out.</summary>
		/// <param name="millisecondsTimeout">The number of milliseconds to wait, or -1 (<see cref="F:System.Threading.Timeout.Infinite" />) to wait indefinitely.</param>
		/// <returns>
		///     <see langword="true" /> if the calling thread entered upgradeable mode, otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.Threading.LockRecursionException">The <see cref="P:System.Threading.ReaderWriterLockSlim.RecursionPolicy" /> property is <see cref="F:System.Threading.LockRecursionPolicy.NoRecursion" /> and the current thread has already entered the lock. -or-The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock. -or-The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The value of <paramref name="millisecondsTimeout" /> is negative, but it is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (-1), which is the only negative value allowed. </exception>
		/// <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Threading.ReaderWriterLockSlim" /> object has been disposed. </exception>
		public bool TryEnterUpgradeableReadLock(int millisecondsTimeout)
		{
			return TryEnterUpgradeableReadLock(new TimeoutTracker(millisecondsTimeout));
		}

		private bool TryEnterUpgradeableReadLock(TimeoutTracker timeout)
		{
			return TryEnterUpgradeableReadLockCore(timeout);
		}

		private bool TryEnterUpgradeableReadLockCore(TimeoutTracker timeout)
		{
			if (fDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			int managedThreadId = Thread.CurrentThread.ManagedThreadId;
			ReaderWriterCount threadRWCount;
			if (!fIsReentrant)
			{
				if (managedThreadId == upgradeLockOwnerId)
				{
					throw new LockRecursionException(SR.GetString("Recursive upgradeable lock acquisitions not allowed in this mode."));
				}
				if (managedThreadId == writeLockOwnerId)
				{
					throw new LockRecursionException(SR.GetString("Upgradeable lock may not be acquired with write lock held in this mode. Acquiring Upgradeable lock gives the ability to read along with an option to upgrade to a writer."));
				}
				EnterMyLock();
				threadRWCount = GetThreadRWCount(dontAllocate: true);
				if (threadRWCount != null && threadRWCount.readercount > 0)
				{
					ExitMyLock();
					throw new LockRecursionException(SR.GetString("Upgradeable lock may not be acquired with read lock held."));
				}
			}
			else
			{
				EnterMyLock();
				threadRWCount = GetThreadRWCount(dontAllocate: false);
				if (managedThreadId == upgradeLockOwnerId)
				{
					threadRWCount.upgradecount++;
					ExitMyLock();
					return true;
				}
				if (managedThreadId == writeLockOwnerId)
				{
					owners++;
					upgradeLockOwnerId = managedThreadId;
					threadRWCount.upgradecount++;
					if (threadRWCount.readercount > 0)
					{
						fUpgradeThreadHoldingRead = true;
					}
					ExitMyLock();
					return true;
				}
				if (threadRWCount.readercount > 0)
				{
					ExitMyLock();
					throw new LockRecursionException(SR.GetString("Upgradeable lock may not be acquired with read lock held."));
				}
			}
			int num = 0;
			while (true)
			{
				if (upgradeLockOwnerId == -1 && owners < 268435454)
				{
					owners++;
					upgradeLockOwnerId = managedThreadId;
					if (fIsReentrant)
					{
						if (IsRwHashEntryChanged(threadRWCount))
						{
							threadRWCount = GetThreadRWCount(dontAllocate: false);
						}
						threadRWCount.upgradecount++;
					}
					break;
				}
				if (num < 20)
				{
					ExitMyLock();
					if (timeout.IsExpired)
					{
						return false;
					}
					num++;
					SpinWait(num);
					EnterMyLock();
				}
				else if (upgradeEvent == null)
				{
					LazyCreateEvent(ref upgradeEvent, makeAutoResetEvent: true);
				}
				else if (!WaitOnEvent(upgradeEvent, ref numUpgradeWaiters, timeout, isWriteWaiter: false))
				{
					return false;
				}
			}
			ExitMyLock();
			return true;
		}

		/// <summary>Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</summary>
		/// <exception cref="T:System.Threading.SynchronizationLockException">The current thread has not entered the lock in read mode. </exception>
		public void ExitReadLock()
		{
			ReaderWriterCount readerWriterCount = null;
			EnterMyLock();
			readerWriterCount = GetThreadRWCount(dontAllocate: true);
			if (readerWriterCount == null || readerWriterCount.readercount < 1)
			{
				ExitMyLock();
				throw new SynchronizationLockException(SR.GetString("The read lock is being released without being held."));
			}
			if (fIsReentrant)
			{
				if (readerWriterCount.readercount > 1)
				{
					readerWriterCount.readercount--;
					ExitMyLock();
					return;
				}
				if (Thread.CurrentThread.ManagedThreadId == upgradeLockOwnerId)
				{
					fUpgradeThreadHoldingRead = false;
				}
			}
			owners--;
			readerWriterCount.readercount--;
			ExitAndWakeUpAppropriateWaiters();
		}

		/// <summary>Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</summary>
		/// <exception cref="T:System.Threading.SynchronizationLockException">The current thread has not entered the lock in write mode.</exception>
		public void ExitWriteLock()
		{
			if (!fIsReentrant)
			{
				if (Thread.CurrentThread.ManagedThreadId != writeLockOwnerId)
				{
					throw new SynchronizationLockException(SR.GetString("The write lock is being released without being held."));
				}
				EnterMyLock();
			}
			else
			{
				EnterMyLock();
				ReaderWriterCount threadRWCount = GetThreadRWCount(dontAllocate: false);
				if (threadRWCount == null)
				{
					ExitMyLock();
					throw new SynchronizationLockException(SR.GetString("The write lock is being released without being held."));
				}
				if (threadRWCount.writercount < 1)
				{
					ExitMyLock();
					throw new SynchronizationLockException(SR.GetString("The write lock is being released without being held."));
				}
				threadRWCount.writercount--;
				if (threadRWCount.writercount > 0)
				{
					ExitMyLock();
					return;
				}
			}
			ClearWriterAcquired();
			writeLockOwnerId = -1;
			ExitAndWakeUpAppropriateWaiters();
		}

		/// <summary>Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</summary>
		/// <exception cref="T:System.Threading.SynchronizationLockException">The current thread has not entered the lock in upgradeable mode.</exception>
		public void ExitUpgradeableReadLock()
		{
			if (!fIsReentrant)
			{
				if (Thread.CurrentThread.ManagedThreadId != upgradeLockOwnerId)
				{
					throw new SynchronizationLockException(SR.GetString("The upgradeable lock is being released without being held."));
				}
				EnterMyLock();
			}
			else
			{
				EnterMyLock();
				ReaderWriterCount threadRWCount = GetThreadRWCount(dontAllocate: true);
				if (threadRWCount == null)
				{
					ExitMyLock();
					throw new SynchronizationLockException(SR.GetString("The upgradeable lock is being released without being held."));
				}
				if (threadRWCount.upgradecount < 1)
				{
					ExitMyLock();
					throw new SynchronizationLockException(SR.GetString("The upgradeable lock is being released without being held."));
				}
				threadRWCount.upgradecount--;
				if (threadRWCount.upgradecount > 0)
				{
					ExitMyLock();
					return;
				}
				fUpgradeThreadHoldingRead = false;
			}
			owners--;
			upgradeLockOwnerId = -1;
			ExitAndWakeUpAppropriateWaiters();
		}

		private void LazyCreateEvent(ref EventWaitHandle waitEvent, bool makeAutoResetEvent)
		{
			ExitMyLock();
			EventWaitHandle eventWaitHandle = ((!makeAutoResetEvent) ? ((EventWaitHandle)new ManualResetEvent(initialState: false)) : ((EventWaitHandle)new AutoResetEvent(initialState: false)));
			EnterMyLock();
			if (waitEvent == null)
			{
				waitEvent = eventWaitHandle;
			}
			else
			{
				eventWaitHandle.Close();
			}
		}

		private bool WaitOnEvent(EventWaitHandle waitEvent, ref uint numWaiters, TimeoutTracker timeout, bool isWriteWaiter)
		{
			waitEvent.Reset();
			numWaiters++;
			fNoWaiters = false;
			if (numWriteWaiters == 1)
			{
				SetWritersWaiting();
			}
			if (numWriteUpgradeWaiters == 1)
			{
				SetUpgraderWaiting();
			}
			bool flag = false;
			ExitMyLock();
			try
			{
				flag = waitEvent.WaitOne(timeout.RemainingMilliseconds);
			}
			finally
			{
				EnterMyLock();
				numWaiters--;
				if (numWriteWaiters == 0 && numWriteUpgradeWaiters == 0 && numUpgradeWaiters == 0 && numReadWaiters == 0)
				{
					fNoWaiters = true;
				}
				if (numWriteWaiters == 0)
				{
					ClearWritersWaiting();
				}
				if (numWriteUpgradeWaiters == 0)
				{
					ClearUpgraderWaiting();
				}
				if (!flag)
				{
					if (isWriteWaiter)
					{
						ExitAndWakeUpAppropriateReadWaiters();
					}
					else
					{
						ExitMyLock();
					}
				}
			}
			return flag;
		}

		private void ExitAndWakeUpAppropriateWaiters()
		{
			if (fNoWaiters)
			{
				ExitMyLock();
			}
			else
			{
				ExitAndWakeUpAppropriateWaitersPreferringWriters();
			}
		}

		private void ExitAndWakeUpAppropriateWaitersPreferringWriters()
		{
			uint numReaders = GetNumReaders();
			if (fIsReentrant && numWriteUpgradeWaiters != 0 && fUpgradeThreadHoldingRead && numReaders == 2)
			{
				ExitMyLock();
				waitUpgradeEvent.Set();
			}
			else if (numReaders == 1 && numWriteUpgradeWaiters != 0)
			{
				ExitMyLock();
				waitUpgradeEvent.Set();
			}
			else if (numReaders == 0 && numWriteWaiters != 0)
			{
				ExitMyLock();
				writeEvent.Set();
			}
			else
			{
				ExitAndWakeUpAppropriateReadWaiters();
			}
		}

		private void ExitAndWakeUpAppropriateReadWaiters()
		{
			if (numWriteWaiters != 0 || numWriteUpgradeWaiters != 0 || fNoWaiters)
			{
				ExitMyLock();
				return;
			}
			bool flag = numReadWaiters != 0;
			bool num = numUpgradeWaiters != 0 && upgradeLockOwnerId == -1;
			ExitMyLock();
			if (flag)
			{
				readEvent.Set();
			}
			if (num)
			{
				upgradeEvent.Set();
			}
		}

		private bool IsWriterAcquired()
		{
			return (owners & 0xBFFFFFFFu) == 0;
		}

		private void SetWriterAcquired()
		{
			owners |= 2147483648u;
		}

		private void ClearWriterAcquired()
		{
			owners &= 2147483647u;
		}

		private void SetWritersWaiting()
		{
			owners |= 1073741824u;
		}

		private void ClearWritersWaiting()
		{
			owners &= 3221225471u;
		}

		private void SetUpgraderWaiting()
		{
			owners |= 536870912u;
		}

		private void ClearUpgraderWaiting()
		{
			owners &= 3758096383u;
		}

		private uint GetNumReaders()
		{
			return owners & 0xFFFFFFF;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private void EnterMyLock()
		{
			if (Interlocked.CompareExchange(ref myLock, 1, 0) != 0)
			{
				EnterMyLockSpin();
			}
		}

		private void EnterMyLockSpin()
		{
			int processorCount = PlatformHelper.ProcessorCount;
			int num = 0;
			while (true)
			{
				if (num < 10 && processorCount > 1)
				{
					Thread.SpinWait(20 * (num + 1));
				}
				else if (num < 15)
				{
					Thread.Sleep(0);
				}
				else
				{
					Thread.Sleep(1);
				}
				if (myLock == 0 && Interlocked.CompareExchange(ref myLock, 1, 0) == 0)
				{
					break;
				}
				num++;
			}
		}

		private void ExitMyLock()
		{
			Volatile.Write(ref myLock, 0);
		}

		private static void SpinWait(int SpinCount)
		{
			if (SpinCount < 5 && PlatformHelper.ProcessorCount > 1)
			{
				Thread.SpinWait(20 * SpinCount);
			}
			else if (SpinCount < 17)
			{
				Thread.Sleep(0);
			}
			else
			{
				Thread.Sleep(1);
			}
		}

		/// <summary>Releases all resources used by the current instance of the <see cref="T:System.Threading.ReaderWriterLockSlim" /> class.</summary>
		/// <exception cref="T:System.Threading.SynchronizationLockException">
		///         <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingReadCount" /> is greater than zero. -or-
		///         <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount" /> is greater than zero. -or-
		///         <see cref="P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount" /> is greater than zero. </exception>
		public void Dispose()
		{
			Dispose(disposing: true);
		}

		private void Dispose(bool disposing)
		{
			if (disposing && !fDisposed)
			{
				if (WaitingReadCount > 0 || WaitingUpgradeCount > 0 || WaitingWriteCount > 0)
				{
					throw new SynchronizationLockException(SR.GetString("The lock is being disposed while still being used. It either is being held by a thread and/or has active waiters waiting to acquire the lock."));
				}
				if (IsReadLockHeld || IsUpgradeableReadLockHeld || IsWriteLockHeld)
				{
					throw new SynchronizationLockException(SR.GetString("The lock is being disposed while still being used. It either is being held by a thread and/or has active waiters waiting to acquire the lock."));
				}
				if (writeEvent != null)
				{
					writeEvent.Close();
					writeEvent = null;
				}
				if (readEvent != null)
				{
					readEvent.Close();
					readEvent = null;
				}
				if (upgradeEvent != null)
				{
					upgradeEvent.Close();
					upgradeEvent = null;
				}
				if (waitUpgradeEvent != null)
				{
					waitUpgradeEvent.Close();
					waitUpgradeEvent = null;
				}
				fDisposed = true;
			}
		}
	}
}
namespace System.Threading.Tasks
{
	/// <summary>Provides a set of static (Shared in Visual Basic) methods for working with specific kinds of <see cref="T:System.Threading.Tasks.Task" /> instances.</summary>
	public static class TaskExtensions
	{
		/// <summary>Creates a proxy <see cref="T:System.Threading.Tasks.Task" /> that represents the asynchronous operation of a <see cref="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />.</summary>
		/// <param name="task">The <see langword="Task&lt;Task&gt;" /> (C#) or <see langword="Task (Of Task)" /> (Visual Basic) to unwrap.</param>
		/// <returns>A Task that represents the asynchronous operation of the provided <see langword="System.Threading.Tasks.Task(Of Task)" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">The exception that is thrown if the <paramref name="task" /> argument is null.</exception>
		public static Task Unwrap(this Task<Task> task)
		{
			if (task == null)
			{
				throw new ArgumentNullException("task");
			}
			object task2;
			if (task.IsCompletedSuccessfully)
			{
				task2 = task.Result;
				if (task2 == null)
				{
					return Task.FromCanceled(new CancellationToken(canceled: true));
				}
			}
			else
			{
				task2 = Task.CreateUnwrapPromise<VoidTaskResult>(task, lookForOce: false);
			}
			return (Task)task2;
		}

		/// <summary>Creates a proxy <see cref="T:System.Threading.Tasks.Task" /> that represents the asynchronous operation of a <see langword="Task&lt;Task&lt;T&gt;&gt;" /> (C#) or <see langword="Task (Of Task(Of T))" /> (Visual Basic).</summary>
		/// <param name="task">The <see langword="Task&lt;Task&lt;T&gt;&gt;" /> (C#) or <see langword="Task (Of Task(Of T))" /> (Visual Basic) to unwrap.</param>
		/// <typeparam name="TResult">The type of the task's result.</typeparam>
		/// <returns>A <see cref="T:System.Threading.Tasks.Task" /> that represents the asynchronous operation of the provided <see langword="Task&lt;Task&lt;T&gt;&gt;" /> (C#) or <see langword="Task (Of Task(Of T))" /> (Visual Basic).</returns>
		/// <exception cref="T:System.ArgumentNullException">The exception that is thrown if the <paramref name="task" /> argument is null.</exception>
		public static Task<TResult> Unwrap<TResult>(this Task<Task<TResult>> task)
		{
			if (task == null)
			{
				throw new ArgumentNullException("task");
			}
			Task<TResult> task2;
			if (task.IsCompletedSuccessfully)
			{
				task2 = task.Result;
				if (task2 == null)
				{
					return Task.FromCanceled<TResult>(new CancellationToken(canceled: true));
				}
			}
			else
			{
				task2 = Task.CreateUnwrapPromise<TResult>(task, lookForOce: false);
			}
			return task2;
		}
	}
}
namespace System.Security
{
	/// <summary>Represents the type of manifest that the signature information applies to.</summary>
	[Flags]
	public enum ManifestKinds
	{
		/// <summary>The manifest is for an application. </summary>
		Application = 2,
		/// <summary>The manifest is for deployment and application. The is the default value for verifying signatures. </summary>
		ApplicationAndDeployment = 3,
		/// <summary>The manifest is for deployment only.</summary>
		Deployment = 1,
		/// <summary>The manifest is of no particular type. </summary>
		None = 0
	}
}
namespace System.Security.Cryptography
{
	/// <summary>Provides a Cryptography Next Generation (CNG) implementation of the Digital Signature Algorithm (DSA).</summary>
	public sealed class DSACng : DSA
	{
		/// <summary>Gets the key that will be used by the <see cref="T:System.Security.Cryptography.DSACng" /> object for any cryptographic operation that it performs. </summary>
		/// <returns>The key used by the <see cref="T:System.Security.Cryptography.DSACng" /> object to perform cryptographic operations. </returns>
		public CngKey Key
		{
			[SecuritySafeCritical]
			[SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.DSACng" /> class with a random 2,048-bit key pair. </summary>
		public DSACng()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.DSACng" /> class with a randomly generated key of the specified size. </summary>
		/// <param name="keySize">The size of the key to generate in bits. </param>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///         <paramref name="keySize" /> is not valid. </exception>
		public DSACng(int keySize)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.DSACng" /> class with the specified key. </summary>
		/// <param name="key">The key to use for DSA operations. </param>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="key" /> is not a valid DSA key. </exception>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="key" /> is <see langword="null" />. </exception>
		[SecuritySafeCritical]
		[SecurityPermission(SecurityAction.Assert, UnmanagedCode = true)]
		public DSACng(CngKey key)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Creates the digital signature for the specified data.</summary>
		/// <param name="rgbHash">The data to be signed.</param>
		/// <returns>The digital signature for the specified data.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="rgbHash" /> is <see langword="null" />. </exception>
		/// <exception cref="T:System.PlatformNotSupportedException">
		///         <paramref name="rgbHash" /> is shorter in length than the Q value of the DSA key . </exception>
		[SecuritySafeCritical]
		public override byte[] CreateSignature(byte[] rgbHash)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Exports the DSA algorithm parameters. </summary>
		/// <param name="includePrivateParameters">
		///       <see langword="true" /> to include private parameters; otherwise, <see langword="false" />. </param>
		/// <returns>The DSA algorithm parameters. </returns>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">DSA key is not a valid public or private key.</exception>
		public override DSAParameters ExportParameters(bool includePrivateParameters)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return default(DSAParameters);
		}

		/// <summary>Replaces the existing key that the current instance is working with by creating a new <see cref="T:System.Security.Cryptography.CngKey" /> for the parameters structure. </summary>
		/// <param name="parameters">The DSA parameters. </param>
		/// <exception cref="T:System.ArgumentException">The specified DSA parameters are not valid. </exception>
		public override void ImportParameters(DSAParameters parameters)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Verifies if the specified digital signature matches the specified data. </summary>
		/// <param name="rgbHash">The signed data.</param>
		/// <param name="rgbSignature">The digital signature to be verified.</param>
		/// <returns>
		///     <see langword="true" /> if <paramref name="rgbSignature" /> matches the signature computed using the specified data; otherwise, <see langword="false" />.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="rgbHash" /> parameter is <see langword="null" />.-or- The <paramref name="rgbSignature" /> parameter is <see langword="null" />. </exception>
		/// <exception cref="T:System.PlatformNotSupportedException">
		///         <paramref name="rgbHash" /> is shorter in length than the Q value of the DSA key . </exception>
		[SecuritySafeCritical]
		public override bool VerifySignature(byte[] rgbHash, byte[] rgbSignature)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return default(bool);
		}
	}
	/// <summary>Provides a Cryptography Next Generation (CNG) implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm. This class is used to perform cryptographic operations.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ECDiffieHellmanCng : ECDiffieHellman
	{
		/// <summary>Gets or sets the hash algorithm to use when generating key material.</summary>
		/// <returns>An object that specifies the hash algorithm.</returns>
		/// <exception cref="T:System.ArgumentNullException">The value is <see langword="null." /></exception>
		public CngAlgorithm HashAlgorithm
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets or sets the Hash-based Message Authentication Code (HMAC) key to use when deriving key material.</summary>
		/// <returns>The Hash-based Message Authentication Code (HMAC) key to use when deriving key material.</returns>
		public byte[] HmacKey
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Specifies the <see cref="T:System.Security.Cryptography.CngKey" /> that is used by the current object for cryptographic operations.</summary>
		/// <returns>The key pair used by this object to perform cryptographic operations.</returns>
		public CngKey Key
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets or sets the key derivation function for the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> class.</summary>
		/// <returns>One of the <see cref="T:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction" /> enumeration values: <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash" />, <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac" />, or <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" />. The default value is <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hash" />.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">The enumeration value is out of range.</exception>
		public ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(ECDiffieHellmanKeyDerivationFunction);
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets or sets the label value that is used for key derivation.</summary>
		/// <returns>The label value.</returns>
		public byte[] Label
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets the public key that can be used by another <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> object to generate a shared secret agreement.</summary>
		/// <returns>The public key that is associated with this instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> object.</returns>
		public override ECDiffieHellmanPublicKey PublicKey
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets or sets a value that will be appended to the secret agreement when generating key material.</summary>
		/// <returns>The value that is appended to the secret agreement.</returns>
		public byte[] SecretAppend
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets or sets a value that will be added to the beginning of the secret agreement when deriving key material.</summary>
		/// <returns>The value that is appended to the beginning of the secret agreement during key derivation.</returns>
		public byte[] SecretPrepend
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets or sets the seed value that will be used when deriving key material.</summary>
		/// <returns>The seed value.</returns>
		public byte[] Seed
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets a value that indicates whether the secret agreement is used as a Hash-based Message Authentication Code (HMAC) key to derive key material.</summary>
		/// <returns>
		///     <see langword="true" /> if the secret agreement is used as an HMAC key to derive key material; otherwise, <see langword="false" />.</returns>
		public bool UseSecretAgreementAsHmacKey
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(bool);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> class with a random key pair.</summary>
		public ECDiffieHellmanCng()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> class with a random key pair, using the specified key size.</summary>
		/// <param name="keySize">The size of the key. Valid key sizes are 256, 384, and 521 bits.</param>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="keySize" /> specifies an invalid length.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) classes are not supported on this system.</exception>
		public ECDiffieHellmanCng(int keySize)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> class by using the specified <see cref="T:System.Security.Cryptography.CngKey" /> object.</summary>
		/// <param name="key">The key that will be used as input to the cryptographic operations performed by the current object. </param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="key" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="key" /> does not specify an Elliptic Curve Diffie-Hellman (ECDH) algorithm group.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Cryptography Next Generation (CNG) classes are not supported on this system.</exception>
		[SecuritySafeCritical]
		public ECDiffieHellmanCng(CngKey key)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Creates a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> class whose public/private key pair is generated over the specified curve. </summary>
		/// <param name="curve">The curve used to generate the public/private key pair. </param>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">
		///         <paramref name="curve" /> does not validate. </exception>
		public ECDiffieHellmanCng(ECCurve curve)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Derives the key material that is generated from the secret agreement between two parties, given a <see cref="T:System.Security.Cryptography.CngKey" /> object that contains the second party's public key. </summary>
		/// <param name="otherPartyPublicKey">An object that contains the public part of the Elliptic Curve Diffie-Hellman (ECDH) key from the other party in the key exchange.</param>
		/// <returns>A byte array that contains the key material. This information is generated from the secret agreement that is calculated from the current object's private key and the specified public key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="otherPartyPublicKey" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="otherPartyPublicKey" /> is invalid. Either its <see cref="P:System.Security.Cryptography.CngKey.AlgorithmGroup" /> property does not specify <see cref="P:System.Security.Cryptography.CngAlgorithmGroup.ECDiffieHellman" /> or its key size does not match the key size of this instance.</exception>
		/// <exception cref="T:System.InvalidOperationException">This object's <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.KeyDerivationFunction" /> property specifies the <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" /> key derivation function, but either <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Label" /> or <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Seed" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		[SecuritySafeCritical]
		public byte[] DeriveKeyMaterial(CngKey otherPartyPublicKey)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Gets a handle to the secret agreement generated between two parties, given a <see cref="T:System.Security.Cryptography.CngKey" /> object that contains the second party's public key.</summary>
		/// <param name="otherPartyPublicKey">An object that contains the public part of the Elliptic Curve Diffie-Hellman (ECDH) key from the other party in the key exchange.</param>
		/// <returns>A handle to the secret agreement. This information is calculated from the current object's private key and the specified public key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="otherPartyPublicKey" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="otherPartyPublicKey" /> is not an ECDH key, or it is not the correct size.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		[SecurityCritical]
		[SecurityPermission(SecurityAction.Demand, UnmanagedCode = true)]
		public SafeNCryptSecretHandle DeriveSecretAgreementHandle(CngKey otherPartyPublicKey)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Gets a handle to the secret agreement generated between two parties, given an <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> object that contains the second party's public key.</summary>
		/// <param name="otherPartyPublicKey">The public key from the other party in the key exchange.</param>
		/// <returns>A handle to the secret agreement. This information is calculated from the current object's private key and the specified public key.</returns>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="otherPartyPublicKey" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="otherPartyPublicKey" /> is not an <see cref="T:System.Security.Cryptography.ECDiffieHellmanPublicKey" /> key. </exception>
		public SafeNCryptSecretHandle DeriveSecretAgreementHandle(ECDiffieHellmanPublicKey otherPartyPublicKey)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Deserializes the key information from an XML string by using the specified format.</summary>
		/// <param name="xml">The XML-based key information to be deserialized.</param>
		/// <param name="format">One of the enumeration values that specifies the format of the XML string. The only currently accepted format is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</param>
		/// <exception cref="T:System.ArgumentNullException">
		///         <paramref name="xml" /> is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">
		///         <paramref name="xml" /> is malformed.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="format" /> specifies an invalid format. The only accepted value is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</exception>
		/// <exception cref="T:System.Security.Cryptography.CryptographicException">All other errors.</exception>
		public void FromXmlString(string xml, ECKeyXmlFormat format)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Serializes the key information to an XML string by using the specified format.</summary>
		/// <param name="format">One of the enumeration values that specifies the format of the XML string. The only currently accepted format is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</param>
		/// <returns>A string object that contains the key information, serialized to an XML string, according to the requested format.</returns>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="format" /> specifies an invalid format. The only accepted value is <see cref="F:System.Security.Cryptography.ECKeyXmlFormat.Rfc4050" />.</exception>
		public string ToXmlString(ECKeyXmlFormat format)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}
	}
	/// <summary>Specifies the key derivation function that the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> class will use to convert secret agreements into key material.</summary>
	public enum ECDiffieHellmanKeyDerivationFunction
	{
		/// <summary>A hash algorithm is used to generate key material. The <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.HashAlgorithm" /> property specifies the name of the algorithm to use. If the algorithm name is not specified, <see cref="T:System.Security.Cryptography.SHA256" /> is used as the default algorithm. </summary>
		Hash,
		/// <summary>A Hash-based Message Authentication Code (HMAC) algorithm is used to generate key material. The <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.HmacKey" /> property specifies the key to use. Either this property must be set or the <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.UseSecretAgreementAsHmacKey" /> property must be set to <see langword="true" />; otherwise, a <see cref="T:System.Security.Cryptography.CryptographicException" /> is thrown when you use <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Hmac" />. If both properties are set, the secret agreement is used as the HMAC key. </summary>
		Hmac,
		/// <summary>The Transport Layer Security (TLS) protocol is used to generate key material. The <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Seed" /> and <see cref="P:System.Security.Cryptography.ECDiffieHellmanCng.Label" /> properties must be set; otherwise, a <see cref="T:System.Security.Cryptography.CryptographicException" /> is thrown when you use <see cref="F:System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction.Tls" />. </summary>
		Tls
	}
	/// <summary>Specifies an Elliptic Curve Diffie-Hellman (ECDH) public key for use with the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCng" /> class.</summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ECDiffieHellmanCngPublicKey : ECDiffieHellmanPublicKey
	{
		/// <summary>Gets the key BLOB format for a <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" /> object.</summary>
		/// <returns>The format that the key BLOB is expressed in.</returns>
		public CngKeyBlobFormat BlobFormat
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		internal ECDiffieHellmanCngPublicKey()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Converts a byte array that contains a public key to a <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" /> object according to the specified format.</summary>
		/// <param name="publicKeyBlob">A byte array that contains an Elliptic Curve Diffie-Hellman (ECDH) public key.</param>
		/// <param name="format">An object that specifies the format of the key BLOB.</param>
		/// <returns>An object that contains the ECDH public key that is serialized in the byte array.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="publicKeyBlob" /> or <paramref name="format" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <paramref name="publicKeyBlob" /> parameter does not contain an <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key. </exception>
		[SecuritySafeCritical]
		public static ECDiffieHellmanPublicKey FromByteArray(byte[] publicKeyBlob, CngKeyBlobFormat format)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Converts an XML string to an <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" /> object.</summary>
		/// <param name="xml">An XML string that contains an Elliptic Curve Diffie-Hellman (ECDH) key.</param>
		/// <returns>An object that contains the ECDH public key that is specified by the given XML.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="xml" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentException">The <paramref name="xml" /> parameter does not specify an <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key.</exception>
		[SecuritySafeCritical]
		public static ECDiffieHellmanCngPublicKey FromXmlString(string xml)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Converts the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" /> object to a <see cref="T:System.Security.Cryptography.CngKey" /> object.</summary>
		/// <returns>An object that contains the key represented by the <see cref="T:System.Security.Cryptography.ECDiffieHellmanCngPublicKey" /> object.</returns>
		public CngKey Import()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}
	}
	/// <summary>Provides information for a manifest signature. </summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManifestSignatureInformation
	{
		/// <summary>Gets the Authenticode signature information for a manifest. </summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation" /> object that contains Authenticode signature information for the manifest, or <see langword="null" /> if there is no signature.</returns>
		public AuthenticodeSignatureInformation AuthenticodeSignature
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the type of a manifest.</summary>
		/// <returns>One of the <see cref="T:System.Security.ManifestKinds" /> values.</returns>
		public ManifestKinds Manifest
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(ManifestKinds);
			}
		}

		/// <summary>Gets the details of the strong name signature of a manifest.</summary>
		/// <returns>A <see cref="P:System.Security.Cryptography.ManifestSignatureInformation.StrongNameSignature" /> object that contains the signature, or <see langword="null" /> if there is no strong name signature.</returns>
		public StrongNameSignatureInformation StrongNameSignature
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		internal ManifestSignatureInformation()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Gathers and verifies information about the signatures of manifests that belong to a specified activation context.</summary>
		/// <param name="application">The activation context of the manifest. Activation contexts belong to an application and contain multiple manifests.</param>
		/// <returns>A collection that contains a <see cref="T:System.Security.Cryptography.ManifestSignatureInformation" /> object for each manifest that is verified.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="application" /> parameter is <see langword="null" />.</exception>
		public static ManifestSignatureInformationCollection VerifySignature(ActivationContext application)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Gathers and verifies information about the signatures of manifests that belong to a specified activation context and manifest type.</summary>
		/// <param name="application">The activation context of the manifest. Activation contexts belong to an application and contain multiple manifests.</param>
		/// <param name="manifests">The type of manifest. This parameter specifies which manifests in the activation context you want to verify.</param>
		/// <returns>A collection that contains a <see cref="T:System.Security.Cryptography.ManifestSignatureInformation" /> object for each manifest that is verified.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="application" /> parameter is <see langword="null" />.</exception>
		public static ManifestSignatureInformationCollection VerifySignature(ActivationContext application, ManifestKinds manifests)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Gathers and verifies information about the signatures of manifests that belong to a specified activation context and manifest type, and allows certificates to be selected for revocation.</summary>
		/// <param name="application">The application context of the manifests. Activation contexts belong to an application and contain multiple manifests.</param>
		/// <param name="manifests">The type of manifest. This parameter specifies which manifests in the activation context you want to verify.</param>
		/// <param name="revocationFlag">One of the enumeration values that specifies which certificates in the chain are checked for revocation. The default is <see cref="F:System.Security.Cryptography.X509Certificates.X509RevocationFlag.ExcludeRoot" />.</param>
		/// <param name="revocationMode">Determines whether the X.509 verification should look online for revocation lists. </param>
		/// <returns>A collection that contains a <see cref="T:System.Security.Cryptography.ManifestSignatureInformation" /> object for each manifest that is verified.</returns>
		/// <exception cref="T:System.ArgumentNullException">The <paramref name="application" /> parameter is <see langword="null" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">A value specified for the <paramref name="revocationFlag" /> or <paramref name="revocationMode" /> parameter is invalid.</exception>
		[SecuritySafeCritical]
		public static ManifestSignatureInformationCollection VerifySignature(ActivationContext application, ManifestKinds manifests, X509RevocationFlag revocationFlag, X509RevocationMode revocationMode)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}
	}
}
namespace System.Security.Cryptography.X509Certificates
{
	/// <summary>Provides information about an Authenticode signature for a manifest. </summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class AuthenticodeSignatureInformation
	{
		/// <summary>Gets the description of the signing certificate.</summary>
		/// <returns>The description of the signing certificate.</returns>
		public string Description
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the description URL of the signing certificate.</summary>
		/// <returns>The description URL of the signing certificate.</returns>
		public Uri DescriptionUrl
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the hash algorithm used to compute the signature.</summary>
		/// <returns>The hash algorithm used to compute the signature.</returns>
		public string HashAlgorithm
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the HRESULT value from verifying the signature.</summary>
		/// <returns>The HRESULT value from verifying the signature.</returns>
		public int HResult
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(int);
			}
		}

		/// <summary>Gets the chain of certificates used to verify the Authenticode signature.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Chain" /> object that contains the certificate chain.</returns>
		public X509Chain SignatureChain
		{
			[SecuritySafeCritical]
			[StorePermission(SecurityAction.Demand, OpenStore = true, EnumerateCertificates = true)]
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the certificate that signed the manifest.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> object that represents the certificate.</returns>
		public X509Certificate2 SigningCertificate
		{
			[SecuritySafeCritical]
			[StorePermission(SecurityAction.Demand, OpenStore = true, EnumerateCertificates = true)]
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the time stamp that was applied to the Authenticode signature.</summary>
		/// <returns>A <see cref="T:System.Security.Cryptography.X509Certificates.TimestampInformation" /> object that contains the signature time stamp.</returns>
		public TimestampInformation Timestamp
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the trustworthiness of the Authenticode signature.</summary>
		/// <returns>One of the <see cref="T:System.Security.Cryptography.X509Certificates.TrustStatus" /> values. </returns>
		public TrustStatus TrustStatus
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(TrustStatus);
			}
		}

		/// <summary>Gets the result of verifying the Authenticode signature.</summary>
		/// <returns>One of the <see cref="T:System.Security.Cryptography.SignatureVerificationResult" /> values.</returns>
		public SignatureVerificationResult VerificationResult
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(SignatureVerificationResult);
			}
		}

		internal AuthenticodeSignatureInformation()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Provides details about the time stamp that was applied to an Authenticode signature for a manifest. </summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class TimestampInformation
	{
		/// <summary>Gets the hash algorithm used to compute the time stamp signature.</summary>
		/// <returns>The hash algorithm used to compute the time stamp signature.</returns>
		public string HashAlgorithm
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the HRESULT value that results from verifying the signature.</summary>
		/// <returns>The HRESULT value that results from verifying the signature.</returns>
		public int HResult
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(int);
			}
		}

		/// <summary>Gets a value indicating whether the time stamp of the signature is valid.</summary>
		/// <returns>
		///     <see langword="true" /> if the time stamp is valid; otherwise, <see langword="false" />. </returns>
		public bool IsValid
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(bool);
			}
		}

		/// <summary>Gets the chain of certificates used to verify the time stamp of the signature.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Chain" /> object that represents the certificate chain.</returns>
		public X509Chain SignatureChain
		{
			[SecuritySafeCritical]
			[StorePermission(SecurityAction.Demand, OpenStore = true, EnumerateCertificates = true)]
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the certificate that signed the time stamp.</summary>
		/// <returns>An <see cref="T:System.Security.Cryptography.X509Certificates.X509Certificate2" /> object that represents the certificate.</returns>
		public X509Certificate2 SigningCertificate
		{
			[SecuritySafeCritical]
			[StorePermission(SecurityAction.Demand, OpenStore = true, EnumerateCertificates = true)]
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the time stamp that was applied to the signature.</summary>
		/// <returns>A <see cref="T:System.DateTime" /> object that represents the time stamp.</returns>
		public DateTime Timestamp
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(DateTime);
			}
		}

		/// <summary>Gets the result of verifying the time stamp signature.</summary>
		/// <returns>One of the <see cref="T:System.Security.Cryptography.SignatureVerificationResult" /> values.</returns>
		public SignatureVerificationResult VerificationResult
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(SignatureVerificationResult);
			}
		}

		internal TimestampInformation()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
}
namespace System.Security.Cryptography
{
	/// <summary>Specifies most of the result codes for signature verification. </summary>
	public enum SignatureVerificationResult
	{
		/// <summary>The identity of the assembly specified in the /asm:assembly/asm:assemblyIdentity node of the manifest does not match the identity of the assembly in the Authenticode signature in the /asm:assembly/ds:signature/ds:KeyInfo/msrel:RelData/r:license/r:grant/as:ManifestInformation/as:assemblyIdentity node.</summary>
		AssemblyIdentityMismatch = 1,
		/// <summary>The digital signature of the object did not verify.</summary>
		BadDigest = -2146869232,
		/// <summary>The signature format is invalid.</summary>
		BadSignatureFormat = -2146762749,
		/// <summary>The basic constraint extension of a certificate has not been observed.</summary>
		BasicConstraintsNotObserved = -2146869223,
		/// <summary>The certificate has expired.</summary>
		CertificateExpired = -2146762495,
		/// <summary>The certificate was explicitly marked as not trusted by the user.</summary>
		CertificateExplicitlyDistrusted = -2146762479,
		/// <summary>The certificate is missing or has an empty value for an important field, such as a subject or issuer name.</summary>
		CertificateMalformed = -2146762488,
		/// <summary>The certificate is not trusted explicitly.</summary>
		CertificateNotExplicitlyTrusted = -2146762748,
		/// <summary>The certificate has been revoked.</summary>
		CertificateRevoked = -2146762484,
		/// <summary>The certificate cannot be used for signing and verification.</summary>
		CertificateUsageNotAllowed = -2146762490,
		/// <summary>The strong name signature does not verify in the <see cref="T:System.Security.Cryptography.X509Certificates.AuthenticodeSignatureInformation" /> object.Because the strong name signature wraps the Authenticode signature, someone could replace the Authenticode signature with a signature of their choosing. To prevent this, this error code is returned if the strong name does not verify because substituting a part of the strong name signature will invalidate it.</summary>
		ContainingSignatureInvalid = 2,
		/// <summary>The chain could not be built.</summary>
		CouldNotBuildChain = -2146762486,
		/// <summary>There is a general trust failure with the certificate.</summary>
		GenericTrustFailure = -2146762485,
		/// <summary>The certificate has an invalid name. The name is either not included in the permitted list or is explicitly excluded.</summary>
		InvalidCertificateName = -2146762476,
		/// <summary>The certificate has an invalid policy.</summary>
		InvalidCertificatePolicy = -2146762477,
		/// <summary>The certificate has an invalid role.</summary>
		InvalidCertificateRole = -2146762493,
		/// <summary>The signature of the certificate cannot be verified.</summary>
		InvalidCertificateSignature = -2146869244,
		/// <summary>The certificate has an invalid usage.</summary>
		InvalidCertificateUsage = -2146762480,
		/// <summary>One of the counter signatures is invalid.</summary>
		InvalidCountersignature = -2146869245,
		/// <summary>The certificate for the signer of the message is invalid or not found.</summary>
		InvalidSignerCertificate = -2146869246,
		/// <summary>A certificate was issued after the issuing certificate has expired.</summary>
		InvalidTimePeriodNesting = -2146762494,
		/// <summary>The time stamp signature or certificate could not be verified or is malformed.</summary>
		InvalidTimestamp = -2146869243,
		/// <summary>A parent of a given certificate did not issue that child certificate.</summary>
		IssuerChainingError = -2146762489,
		/// <summary>The signature is missing.</summary>
		MissingSignature = -2146762496,
		/// <summary>A path length constraint in the certification chain has been violated.</summary>
		PathLengthConstraintViolated = -2146762492,
		/// <summary>The public key token from the manifest identity in the /asm:assembly/asm:AssemblyIdentity node does not match the public key token of the key that is used to sign the manifest.</summary>
		PublicKeyTokenMismatch = 3,
		/// <summary>The publisher name from /asm:assembly/asmv2:publisherIdentity does not match the subject name of the signing certificate, or the issuer key hash from the same publisherIdentity node does not match the key hash of the signing certificate.</summary>
		PublisherMismatch = 4,
		/// <summary>The revocation check failed.</summary>
		RevocationCheckFailure = -2146762482,
		/// <summary>A system-level error occurred while verifying trust.</summary>
		SystemError = -2146869247,
		/// <summary>A certificate contains an unknown extension that is marked critical.</summary>
		UnknownCriticalExtension = -2146762491,
		/// <summary>The certificate has an unknown trust provider.</summary>
		UnknownTrustProvider = -2146762751,
		/// <summary>The certificate has an unknown verification action.</summary>
		UnknownVerificationAction = -2146762750,
		/// <summary>The certification chain processed correctly, but one of the CA certificates is not trusted by the policy provider.</summary>
		UntrustedCertificationAuthority = -2146762478,
		/// <summary>The root certificate is not trusted.</summary>
		UntrustedRootCertificate = -2146762487,
		/// <summary>The test root certificate is not trusted.</summary>
		UntrustedTestRootCertificate = -2146762483,
		/// <summary>The certificate verification result is valid.</summary>
		Valid = 0
	}
	/// <summary>Holds the strong name signature information for a manifest.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class StrongNameSignatureInformation
	{
		/// <summary>Gets the hash algorithm that is used to calculate the strong name signature.</summary>
		/// <returns>The name of the hash algorithm that is used to calculate the strong name signature.</returns>
		public string HashAlgorithm
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the HRESULT value of the result code.</summary>
		/// <returns>The HRESULT value of the result code.</returns>
		public int HResult
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(int);
			}
		}

		/// <summary>Gets a value indicating whether the strong name signature is valid.</summary>
		/// <returns>
		///     <see langword="true" /> if the strong name signature is valid; otherwise, <see langword="false" />.</returns>
		public bool IsValid
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(bool);
			}
		}

		/// <summary>Gets the public key that is used to verify the signature.</summary>
		/// <returns>The public key that is used to verify the signature. </returns>
		public AsymmetricAlgorithm PublicKey
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the results of verifying the strong name signature.</summary>
		/// <returns>The result codes for signature verification.</returns>
		public SignatureVerificationResult VerificationResult
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(SignatureVerificationResult);
			}
		}

		internal StrongNameSignatureInformation()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents a read-only collection of <see cref="T:System.Security.Cryptography.ManifestSignatureInformation" /> objects. </summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManifestSignatureInformationCollection : ReadOnlyCollection<ManifestSignatureInformation>
	{
		internal ManifestSignatureInformationCollection()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
}
namespace System.Management.Instrumentation
{
	/// <summary>The exception thrown to indicate that no instances are returned by a provider.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class InstanceNotFoundException : InstrumentationException
	{
		/// <summary>Initializes a new instance of the InstanceNotFoundException class.</summary>
		public InstanceNotFoundException()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the InstanceNotFoundException class with the specified serialization information and streaming context.</summary>
		/// <param name="info">The SerializationInfo that contains all the data required to serialize the exception.</param>
		/// <param name="context">The StreamingContext that specifies the source and destination of the stream.</param>
		protected InstanceNotFoundException(SerializationInfo info, StreamingContext context)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the InstanceNotFoundException class with its message string set to message.</summary>
		/// <param name="message">A string that contains the error message that explains the reason for the exception.</param>
		public InstanceNotFoundException(string message)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the InstanceNotFoundException class with the specified error message and the inner exception.</summary>
		/// <param name="message">A string that contains the error message that explains the reason for the exception.</param>
		/// <param name="innerException">The Exception that caused the current exception to be thrown.</param>
		public InstanceNotFoundException(string message, Exception innerException)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents a provider-related exception.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class InstrumentationException : InstrumentationBaseException
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentationException" /> class. This is the default constructor.</summary>
		public InstrumentationException()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new <see cref="T:System.Management.Instrumentation.InstrumentationException" /> class with the System.Exception that caused the current exception.</summary>
		/// <param name="innerException">The Exception instance that caused the current exception.</param>
		public InstrumentationException(Exception innerException)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentationException" /> class with serialization information.</summary>
		/// <param name="info">The data that is required to serialize or deserialize an object.</param>
		/// <param name="context">Description of the source and destination of the specified serialized stream.</param>
		protected InstrumentationException(SerializationInfo info, StreamingContext context)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentationException" /> class with a message that describes the exception.</summary>
		/// <param name="message">Message that describes the exception.</param>
		public InstrumentationException(string message)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new <see cref="T:System.Management.Instrumentation.InstrumentationException" /> class with the specified string and exception.</summary>
		/// <param name="message">Message that describes the exception.</param>
		/// <param name="innerException">The Exception instance that caused the current exception.</param>
		public InstrumentationException(string message, Exception innerException)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents the base provider-related exception.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class InstrumentationBaseException : Exception
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentationBaseException" />. class. This is the default constructor.</summary>
		public InstrumentationBaseException()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentationBaseException" /> class with serialization information.</summary>
		/// <param name="info">The data that is required to serialize or deserialize an object.</param>
		/// <param name="context">Description of the source and destination of the specified serialized stream.</param>
		protected InstrumentationBaseException(SerializationInfo info, StreamingContext context)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.Instrumentation.InstrumentationBaseException" /> class with a message that describes the exception.</summary>
		/// <param name="message">Message that describes the exception.</param>
		public InstrumentationBaseException(string message)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new <see cref="T:System.Management.Instrumentation.InstrumentationBaseException" /> class with the specified string and exception.</summary>
		/// <param name="message">Message that describes the exception.</param>
		/// <param name="innerException">The Exception instance that caused the current exception.</param>
		public InstrumentationBaseException(string message, Exception innerException)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>The ManagementBind attribute indicates that a method is used to return the instance of a WMI class associated with a specific key value.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementBindAttribute : ManagementNewInstanceAttribute
	{
		/// <summary>Gets or sets a value that defines the type of output that the method that is marked with the ManagementEnumerator attribute will output.</summary>
		/// <returns>A <see cref="T:System.Type" /> value that indicates the type of output that the method marked with the <see cref="ManagementBind" /> attribute will output.</returns>
		public Type Schema
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementBindAttribute" /> class. This is the default constructor.</summary>
		public ManagementBindAttribute()
		{
		}
	}
	/// <summary>The base class for management attributes that have only run-time functionality and no schema representation. The management attribute classes ManagementBindAttribute, ManagementCreateAttribute and ManagementEnumeratorAttribute are all derived from this class.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class ManagementNewInstanceAttribute : ManagementMemberAttribute
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementNewInstanceAttribute" /> class. This is the default constructor.</summary>
		protected ManagementNewInstanceAttribute()
		{
		}
	}
	/// <summary>This class is used by the WMI.NET Provider Extensions framework. It is the base class for all the management attributes that can be applied to members.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.All)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class ManagementMemberAttribute : Attribute
	{
		/// <summary>Gets or sets the name of the management attribute.</summary>
		/// <returns>Returns a string which is the name of the management attribute.</returns>
		public string Name
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
			}
		}

		/// <summary>Initializes a new instance of <see cref="T:System.Management.ManagementMemberAttribute" /> the class. This is the default constructor.</summary>
		protected ManagementMemberAttribute()
		{
		}
	}
	/// <summary>The ManagementCommit attribute marks a method that is called when it is necessary to update a set of read-write properties in one, atomic operation.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Method)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementCommitAttribute : ManagementMemberAttribute
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementCommitAttribute" /> class. This is the default constructor.</summary>
		public ManagementCommitAttribute()
		{
		}
	}
	/// <summary>The ManagementConfiguration attribute indicates that a property or field represents a read-write WMI property.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementConfigurationAttribute : ManagementMemberAttribute
	{
		/// <summary>Gets or sets the mode of the property, which specifies whether changes to it are applied as soon as possible or when a commit method is called.</summary>
		/// <returns>Returns a <see cref="T:System.Management.Instrumentation.ManagementConfigurationType" /> that indicates whether the WMI property uses <see cref="F:System.Management.Instrumentation.ManagementConfigurationType.Apply" /> or <see cref="F:System.Management.Instrumentation.ManagementConfigurationType.OnCommit" /> mode.</returns>
		public ManagementConfigurationType Mode
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(ManagementConfigurationType);
			}
			set
			{
			}
		}

		/// <summary>Gets or sets a value that defines the type of output that the property that is marked with the ManagementConfiguration attribute will return.</summary>
		/// <returns>A <see cref="T:System.Type" /> value representing the type of output that the property marked with the ManagementConfiguration attribute will return.</returns>
		public Type Schema
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementConfigurationAttribute" /> class. This is the default constructor.</summary>
		public ManagementConfigurationAttribute()
		{
		}
	}
	/// <summary>Represents the possible commit behaviors of a read/write property. It is used as the value of a parameter of the <see cref="T:System.Management.Instrumentation.ManagementConfigurationAttribute" /> attribute.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	public enum ManagementConfigurationType
	{
		/// <summary>Set values take effect only when Commit is called.</summary>
		Apply,
		/// <summary>Set values are applied immediately.</summary>
		OnCommit
	}
	/// <summary>The ManagementCreateAttribute is used to indicate that a method creates a new instance of a managed entity.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementCreateAttribute : ManagementNewInstanceAttribute
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementCreateAttribute" /> class. This is the default constructor.</summary>
		public ManagementCreateAttribute()
		{
		}
	}
	/// <summary>The ManagementEntity attribute indicates that a class provides management information exposed through a WMI provider.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementEntityAttribute : Attribute
	{
		/// <summary>Gets or sets a value that specifies whether the class represents a WMI class in a provider implemented external to the current assembly.</summary>
		/// <returns>A boolean value that is true if the class represents an external WMI class and false otherwise.</returns>
		public bool External
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(bool);
			}
			set
			{
			}
		}

		/// <summary>Gets or sets the name of the WMI class.</summary>
		/// <returns>A string that contains the name of the WMI class.</returns>
		public string Name
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
			}
		}

		/// <summary>Specifies whether the associated class represents a singleton WMI class.</summary>
		/// <returns>A boolean value that is true if the class represents a singleton WMI class and false otherwise.</returns>
		public bool Singleton
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(bool);
			}
			set
			{
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementEntityAttribute" /> class. This is the default constructor.</summary>
		public ManagementEntityAttribute()
		{
		}
	}
	/// <summary>The ManagementEnumerator attribute marks a method that returns all the instances of a WMI class.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementEnumeratorAttribute : ManagementNewInstanceAttribute
	{
		/// <summary>Gets or sets a value that defines the type of output that the method that is marked with the ManagementEnumerator attribute will output.</summary>
		/// <returns>A <see cref="T:System.Type" /> value that indicates the type of output that the method marked with the <see cref="ManagementEnumerator" /> attribute will output.</returns>
		public Type Schema
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementEnumeratorAttribute" /> class.</summary>
		public ManagementEnumeratorAttribute()
		{
		}
	}
	/// <summary>Defines values that specify the hosting model for the provider.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	public enum ManagementHostingModel
	{
		/// <summary>Activates the provider as a decoupled provider.</summary>
		Decoupled = 0,
		/// <summary>Activates the provider in the provider host process that is running under the LocalService account.</summary>
		LocalService = 2,
		/// <summary>Activates the provider in the provider host process that is running under the LocalSystem account.</summary>
		LocalSystem = 3,
		/// <summary>Activates the provider in the provider host process that is running under the NetworkService account.</summary>
		NetworkService = 1
	}
	/// <summary>The ManagementKey attribute identifies the key properties of a WMI class.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementKeyAttribute : ManagementMemberAttribute
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementKeyAttribute" />  class. This is the default constructor.</summary>
		public ManagementKeyAttribute()
		{
		}
	}
	/// <summary>The ManagementName attribute is used to override names exposed through a WMI class.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementNameAttribute : Attribute
	{
		/// <summary>Gets or sets the user-friendly name for an object. The object can be a method parameter or properties marked with the ManagementProbe, ManagementKey, or ManagementConfiguration attributes.</summary>
		/// <returns>A <see cref="T:System.String" /> value that indicates the user friendly name for an object.</returns>
		public string Name
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementNameAttribute" /> class that specifies a value for the <see cref="P:System.Management.ManagementNameAttribute.Name" /> property of the class.</summary>
		/// <param name="name">The user-friendly name for the object.</param>
		public ManagementNameAttribute(string name)
		{
		}
	}
	/// <summary>The ManagementProbe attribute indicates that a property or field represents a read-only WMI property.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementProbeAttribute : ManagementMemberAttribute
	{
		/// <summary>Gets or sets a value that defines the type of output that the property that is marked with the ManagementProbe attribute will output.</summary>
		/// <returns>A <see cref="T:System.Type" /> value that indicates the type of output that the property that is marked with the ManagementProbe attribute will output.</returns>
		public Type Schema
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementProbeAttribute" /> class. This is the default constructor for the class.</summary>
		public ManagementProbeAttribute()
		{
		}
	}
	/// <summary>The ManagementReferenceAttribute marks a class member, property or method parameter as a reference to another management object or class.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementReferenceAttribute : Attribute
	{
		/// <summary>Gets or sets the name of the referenced type.</summary>
		/// <returns>A string containing the name of the referenced type.</returns>
		public string Type
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementReferenceAttribute" /> class. This is the default constructor.</summary>
		public ManagementReferenceAttribute()
		{
		}
	}
	/// <summary>The ManagementRemoveAttribute is used to indicate that a method cleans up an instance of a managed entity.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementRemoveAttribute : ManagementMemberAttribute
	{
		/// <summary>Gets or sets a value that defines the type of output that the object that is marked with the ManagementRemove attribute will output.</summary>
		/// <returns>A <see cref="T:System.Type" /> value that indicates the type of output that the object marked with the Remove attribute will output.</returns>
		public Type Schema
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementRemoveAttribute" /> class. This is the default constructor.</summary>
		public ManagementRemoveAttribute()
		{
		}
	}
	/// <summary>The ManagementTask attribute indicates that the target method implements a WMI method.Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class ManagementTaskAttribute : ManagementMemberAttribute
	{
		/// <summary>Gets or sets a value that defines the type of output that the method that is marked with the ManagementTask attribute will output.</summary>
		/// <returns>A <see cref="T:System.Type" /> value that indicates the type of output that the method that is marked with the ManagementTask attribute will output.</returns>
		public Type Schema
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.ManagementTaskAttribute" /> class. This is the default constructor.</summary>
		public ManagementTaskAttribute()
		{
		}
	}
	/// <summary>The WmiConfiguration attribute indicates that an assembly contains code that implements a WMI provider by using the WMI.NET Provider Extensions model. The attribute accepts parameters that establish the high-level configuration of the implemented WMI provider. Note: the WMI .NET libraries are now considered in final state, and no further development, enhancements, or updates will be available for non-security related issues affecting these libraries. The MI APIs should be used for all new development.</summary>
	[AttributeUsage(AttributeTargets.Assembly)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class WmiConfigurationAttribute : Attribute
	{
		/// <summary>Gets or sets the hosting group for the WMI provider.</summary>
		/// <returns>A <see cref="T:System.String" /> value that indicates the hosting group for the WMI provider.</returns>
		public string HostingGroup
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
			}
		}

		/// <summary>Gets or sets the hosting model for the WMI provider.</summary>
		/// <returns>A <see cref="T:System.Management.Instrumentation.ManagementHostingModel" /> value that indicates the hosting model of the WMI provider.</returns>
		public ManagementHostingModel HostingModel
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(ManagementHostingModel);
			}
			set
			{
			}
		}

		/// <summary>Gets or sets a value that specifies whether the WMI provider can impersonate its callers. If the value is false, the provider cannot impersonate, and if the value is true, the provider can impersonate.</summary>
		/// <returns>A Boolean value that indicates whether a provider can or cannot impersonate its callers. If the value is false, the provider cannot impersonate, and if the value is true, the provider can impersonate.</returns>
		public bool IdentifyLevel
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(bool);
			}
			set
			{
			}
		}

		/// <summary>Gets or sets a Security Descriptor Definition Language (SDDL) string that specifies the security descriptor on the namespace in which the provider exposes management objects.</summary>
		/// <returns>An SDDL string that represents the security descriptor on the namespace in which the provider exposes management objects.</returns>
		public string NamespaceSecurity
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
			}
		}

		/// <summary>Gets or sets the WMI namespace in which the WMI provider exposes classes.</summary>
		/// <returns>A <see cref="T:System.String" /> value that indicates the namespace in which the WMI provider exposes classes.</returns>
		public string Scope
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets or sets a security descriptor for the WMI provider. For more information, see the SecurityDescriptor property information in the "__Win32Provider" topic in the MSDN online library at http://www.msdn.com. </summary>
		/// <returns>A <see cref="T:System.String" /> value that contains the security descriptor for the WMI provider.</returns>
		public string SecurityRestriction
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Management.WmiConfigurationAttribute" /> class that specifies the WMI namespace in which the WMI provider will expose classes.</summary>
		/// <param name="scope">The WMI namespace in which the provider will expose classes. For example, "root\MyProviderNamespace".</param>
		public WmiConfigurationAttribute(string scope)
		{
		}
	}
}
namespace System.Diagnostics
{
	/// <summary>Directs tracing or debugging output of end-to-end events to an XML-encoded, schema-compliant log file.</summary>
	[HostProtection(SecurityAction.LinkDemand, Synchronization = true)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventSchemaTraceListener : TextWriterTraceListener
	{
		/// <summary>Gets the size of the output buffer.</summary>
		/// <returns>The size of the output buffer, in bytes. </returns>
		public int BufferSize
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(int);
			}
		}

		/// <summary>Gets the maximum size of the log file.</summary>
		/// <returns>The maximum file size, in bytes.</returns>
		public long MaximumFileSize
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(long);
			}
		}

		/// <summary>Gets the maximum number of log files.</summary>
		/// <returns>The maximum number of log files, determined by the value of the <see cref="P:System.Diagnostics.EventSchemaTraceListener.TraceLogRetentionOption" /> property for the file.</returns>
		public int MaximumNumberOfFiles
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(int);
			}
		}

		/// <summary>Gets the trace log retention option for the file.</summary>
		/// <returns>One of the <see cref="T:System.Diagnostics.TraceLogRetentionOption" /> values. The default is <see cref="F:System.Diagnostics.TraceLogRetentionOption.SingleFileUnboundedSize" />. </returns>
		public TraceLogRetentionOption TraceLogRetentionOption
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(TraceLogRetentionOption);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventSchemaTraceListener" /> class, using the specified file as the recipient of debugging and tracing output.</summary>
		/// <param name="fileName">The path for the log file.</param>
		public EventSchemaTraceListener(string fileName)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventSchemaTraceListener" /> class with the specified name, using the specified file as the recipient of debugging and tracing output.</summary>
		/// <param name="fileName">The path for the log file.</param>
		/// <param name="name">The name of the listener.</param>
		public EventSchemaTraceListener(string fileName, string name)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventSchemaTraceListener" /> class with the specified name and specified buffer size, using the specified file as the recipient of debugging and tracing output.</summary>
		/// <param name="fileName">The path for the log file.</param>
		/// <param name="name">The name of the listener.</param>
		/// <param name="bufferSize">The size of the output buffer, in bytes.</param>
		public EventSchemaTraceListener(string fileName, string name, int bufferSize)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventSchemaTraceListener" /> class with the specified name and specified buffer size, using the specified file with the specified log retention policy as the recipient of the debugging and tracing output.</summary>
		/// <param name="fileName">The path for the log file.</param>
		/// <param name="name">The name of the listener.</param>
		/// <param name="bufferSize">The size of the output buffer, in bytes.</param>
		/// <param name="logRetentionOption">One of the <see cref="T:System.Diagnostics.TraceLogRetentionOption" /> values. </param>
		public EventSchemaTraceListener(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventSchemaTraceListener" /> class with the specified name and specified buffer size, using the specified file with the specified log retention policy and maximum size as the recipient of the debugging and tracing output.</summary>
		/// <param name="fileName">The path for the log file.</param>
		/// <param name="name">The name of the listener.</param>
		/// <param name="bufferSize">The size of the output buffer, in bytes.</param>
		/// <param name="logRetentionOption">One of the <see cref="T:System.Diagnostics.TraceLogRetentionOption" /> values.</param>
		/// <param name="maximumFileSize">The maximum file size, in bytes.</param>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="maximumFileSize" /> is less than <paramref name="bufferSize" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="maximumFileSize" /> is a negative number.</exception>
		public EventSchemaTraceListener(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption, long maximumFileSize)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.EventSchemaTraceListener" /> class with the specified name and specified buffer size, using the specified file with the specified log retention policy, maximum size, and file count as the recipient of the debugging and tracing output.</summary>
		/// <param name="fileName">The path for the log file.</param>
		/// <param name="name">The name of the listener.</param>
		/// <param name="bufferSize">The size of the output buffer, in bytes.</param>
		/// <param name="logRetentionOption">One of the <see cref="T:System.Diagnostics.TraceLogRetentionOption" /> values.</param>
		/// <param name="maximumFileSize">The maximum file size, in bytes.</param>
		/// <param name="maximumNumberOfFiles">The maximum number of output log files.</param>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="maximumFileSize" /> is less than <paramref name="bufferSize" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="maximumFileSize" /> is a negative number.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="maximumNumberOfFiles" /> is less than 1, and <paramref name="logRetentionOption" /> is <see cref="F:System.Diagnostics.TraceLogRetentionOption.LimitedSequentialFiles" />.</exception>
		/// <exception cref="T:System.ArgumentOutOfRangeException">
		///         <paramref name="maximumNumberOfFiles" /> is less than 2, and <paramref name="logRetentionOption" /> is <see cref="F:System.Diagnostics.TraceLogRetentionOption.LimitedCircularFiles" />.</exception>
		public EventSchemaTraceListener(string fileName, string name, int bufferSize, TraceLogRetentionOption logRetentionOption, long maximumFileSize, int maximumNumberOfFiles)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Specifies the file structure that will be used for the <see cref="T:System.Diagnostics.EventSchemaTraceListener" /> log.</summary>
	public enum TraceLogRetentionOption
	{
		/// <summary>A finite number of sequential files, each with a maximum file size. When the <see cref="P:System.Diagnostics.EventSchemaTraceListener.MaximumFileSize" /> property value is reached, writing starts in a new file with an incremented integer suffix. When the <see cref="P:System.Diagnostics.EventSchemaTraceListener.MaximumNumberOfFiles" /> property value is reached, the first file is cleared and overwritten. Files are then incrementally overwritten in a circular manner.</summary>
		LimitedCircularFiles = 1,
		/// <summary>A finite number of sequential files, each with a maximum file size. When the <see cref="P:System.Diagnostics.EventSchemaTraceListener.MaximumFileSize" /> property value is reached, writing starts in a new file with an incremented integer suffix.</summary>
		LimitedSequentialFiles = 3,
		/// <summary>One file with a maximum file size that is determined by the <see cref="P:System.Diagnostics.EventSchemaTraceListener.MaximumFileSize" /> property.</summary>
		SingleFileBoundedSize = 4,
		/// <summary>One file with no maximum file size restriction.</summary>
		SingleFileUnboundedSize = 2,
		/// <summary>An unlimited number of sequential files, each with a maximum file size that is determined by the <see cref="P:System.Diagnostics.EventSchemaTraceListener.MaximumFileSize" /> property. There is no logical bound to the number or size of the files, but it is limited by the physical constraints imposed by the computer.</summary>
		UnlimitedSequentialFiles = 0
	}
	/// <summary>Provides unescaped XML data for the logging of user-provided trace data.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class UnescapedXmlDiagnosticData
	{
		/// <summary>Gets or sets the unescaped XML data string.</summary>
		/// <returns>An unescaped XML string.</returns>
		public string UnescapedXml
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.UnescapedXmlDiagnosticData" /> class by using the specified XML data string.</summary>
		/// <param name="xmlPayload">The XML data to be logged in the <see langword="UserData" /> node of the event schema.  </param>
		public UnescapedXmlDiagnosticData(string xmlPayload)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
}
namespace System.Diagnostics.PerformanceData
{
	/// <summary>Contains the raw data for a counter.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CounterData
	{
		/// <summary>Sets or gets the raw counter data.</summary>
		/// <returns>The raw counter data.</returns>
		public long RawValue
		{
			[SecurityCritical]
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(long);
			}
			[SecurityCritical]
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Sets or gets the counter data.</summary>
		/// <returns>The counter data.</returns>
		public long Value
		{
			[SecurityCritical]
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(long);
			}
			[SecurityCritical]
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		internal CounterData()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Decrements the counter value by 1.</summary>
		[SecurityCritical]
		public void Decrement()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Increments the counter value by 1.</summary>
		[SecurityCritical]
		public void Increment()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Increments the counter value by the specified amount.</summary>
		/// <param name="value">The amount by which to increment the counter value. The increment value can be positive or negative.</param>
		[SecurityCritical]
		public void IncrementBy(long value)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Defines a set of logical counters.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class CounterSet : IDisposable
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.PerformanceData.CounterSet" /> class.</summary>
		/// <param name="providerGuid">Guid that uniquely identifies the provider of the counter data. Use the Guid specified in the manifest.</param>
		/// <param name="counterSetGuid">Guid that uniquely identifies the counter set for a provider. Use the Guid specified in the manifest.</param>
		/// <param name="instanceType">Identifies the type of the counter set, for example, whether the counter set is a single or multiple instance counter set.</param>
		/// <exception cref="T:System.InsufficientMemoryException">Not enough memory is available to complete the operation.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">Not supported prior to Windows Vista.</exception>
		/// <exception cref="T:System.ArgumentException">One of the parameters is NULL or not valid.</exception>
		/// <exception cref="T:System.ComponentModel.Win32Exception">An underlying Win32 function call failed.</exception>
		[SecuritySafeCritical]
		[PermissionSet(SecurityAction.Demand, Unrestricted = true)]
		public CounterSet(Guid providerGuid, Guid counterSetGuid, CounterSetInstanceType instanceType)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Adds a counter to the counter set by using the specified counter identifier and type.</summary>
		/// <param name="counterId">Identifies the counter. Use the same value that you used in the manifest to define the counter.</param>
		/// <param name="counterType">Identifies the counter type. The counter type determines how the counter data is calculated, averaged, and displayed. </param>
		/// <exception cref="T:System.ArgumentException">The counter identifier already exists in the set or is negative, or the counter type is NULL or not valid.</exception>
		/// <exception cref="T:System.InvalidOperationException">You cannot add counters to the counter set after creating an instance of the counter set.</exception>
		public void AddCounter(int counterId, CounterType counterType)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Adds a counter to the counter set by using the specified counter identifier and type and a display name for the counter.</summary>
		/// <param name="counterId">Identifies the counter. Use the same value that you used in the manifest to define the counter.</param>
		/// <param name="counterType">Identifies the counter type. The counter type determines how the counter data is calculated, averaged, and displayed. </param>
		/// <param name="counterName">Name of the counter. You can use this name to index the counter in the counter set instance. (See <see cref="P:System.Diagnostics.PerformanceData.CounterSetInstanceCounterDataSet.Item(System.String)" />.)</param>
		/// <exception cref="T:System.ArgumentException">The counter identifier already exists in the set or is negative, or the counter type is NULL or not valid.</exception>
		/// <exception cref="T:System.InvalidOperationException">You cannot add counters to the counter set after creating an instance of the counter set.</exception>
		public void AddCounter(int counterId, CounterType counterType, string counterName)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Creates an instance of the counter set.</summary>
		/// <param name="instanceName">Name of the instance. The name must be unique.</param>
		/// <returns>An instance of the counter set which will contain the counter data.</returns>
		/// <exception cref="T:System.ArgumentException">The instance name is NULL.</exception>
		/// <exception cref="T:System.InvalidOperationException">You must add counters to the counter set before creating an instance of the counter set.</exception>
		[SecuritySafeCritical]
		[PermissionSet(SecurityAction.Demand, Unrestricted = true)]
		public CounterSetInstance CreateCounterSetInstance(string instanceName)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Releases all unmanaged resources used by this object.</summary>
		public void Dispose()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases all unmanaged resources used by this object and optionally release the managed resources.</summary>
		/// <param name="disposing">
		///       <see langword="True" /> if this was called from the Dispose method, <see langword="False" /> if called from the finalizer.</param>
		[SecuritySafeCritical]
		protected virtual void Dispose(bool disposing)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Specifies whether the counter set allows multiple instances such as processes and physical disks, or a single instance such as memory.</summary>
	public enum CounterSetInstanceType
	{
		/// <summary>The counter set contains single instance counters whose aggregate value is obtained from one or more sources. For example, a counter in this type of counter set might obtain the number of reads from each of the three hard disks on the computer and sum their values.</summary>
		GlobalAggregate = 4,
		/// <summary>This type is similar to <see cref="F:System.Diagnostics.PerformanceData.CounterSetInstanceType.GlobalAggregate" /> except that this counter set type stores all counter values for the lifetime of the consumer application (the counter value is cached beyond the lifetime of the counter). For example, if one of the hard disks in the global aggregate example were to become unavailable, the total bytes read by that disk would still be available and used to calculate the aggregate value.</summary>
		GlobalAggregateWithHistory = 11,
		/// <summary>This type is similar to <see cref="F:System.Diagnostics.PerformanceData.CounterSetInstanceType.MultipleAggregate" />, except that instead of aggregating all instance data to one aggregated (_Total) instance, it will aggregate counter data from instances of the same name. For example, if multiple provider processes contained instances named IExplore, <see cref="F:System.Diagnostics.PerformanceData.CounterSetInstanceType.Multiple" /> and <see cref="F:System.Diagnostics.PerformanceData.CounterSetInstanceType.MultipleAggregate" /> CounterSet will show multiple IExplore instances (IExplore, IExplore#1, IExplore#2, and so on); however, a <see cref="F:System.Diagnostics.PerformanceData.CounterSetInstanceType.InstanceAggregate" /> instance type will publish only one IExplore instance with aggregated counter data from all instances named IExplore.</summary>
		InstanceAggregate = 22,
		/// <summary>The counter set contains multiple instance counters, for example, a counter that measures the average disk I/O for a process.</summary>
		Multiple = 2,
		/// <summary>The counter set contains multiple instance counters whose aggregate value is obtained from all instances of the counter. For example, a counter in this type of counter set might obtain the total thread execution time for all threads in a multithreaded application and sum their values.</summary>
		MultipleAggregate = 6,
		/// <summary>The counter set contains single instance counters, for example, a counter that measures physical memory.</summary>
		Single = 0
	}
	/// <summary>Defines the possible types of counters. Each counter is assigned a counter type. The counter type determines how the counter data is calculated, averaged, and displayed.</summary>
	public enum CounterType
	{
		/// <summary>This counter is used as the base data (denominator) in the computation of time or count averages for the <see cref="F:System.Diagnostics.PerformanceData.CounterType.AverageCount64" /> and <see cref="F:System.Diagnostics.PerformanceData.CounterType.AverageTimer32" /> counter types. This counter type collects the last observed value only. (See the PERF_AVERAGE_BASE counter type in the deployment kit.)</summary>
		AverageBase = 1073939458,
		/// <summary>This counter type shows how many items are processed, on average, during an operation. Counters of this type display a ratio of the items processed (such as bytes sent) to the number of operations completed. The ratio is calculated by comparing the number of items processed during the last interval to the number of operations completed during the last interval. (See the PERF_AVERAGE_BULK counter type in the deployment kit.)</summary>
		AverageCount64 = 1073874176,
		/// <summary>This counter type measures the average time it takes to complete a process or operation. Counters of this type display a ratio of the total elapsed time of the sample interval to the number of processes or operations completed during that time. This counter type measures time in ticks of the system clock. (See the PERF_AVERAGE_TIMER counter type in the deployment kit.)</summary>
		AverageTimer32 = 805438464,
		/// <summary>This counter type shows the change in the measured attribute between the two most recent sample intervals. (See the PERF_COUNTER_DELTA counter type in the deployment kit.)</summary>
		Delta32 = 4195328,
		/// <summary>This counter type shows the change in the measured attribute between the two most recent sample intervals. It is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.Delta32" /> counter type, except that it uses larger fields to accommodate larger values. (See the PERF_COUNTER_LARGE_DELTA counter type in the deployment kit.)</summary>
		Delta64 = 4195584,
		/// <summary>This counter type shows the total time between when the component or process started and the time when this value is calculated. (See the PERF_ELAPSED_TIME counter type in the deployment kit.)</summary>
		ElapsedTime = 807666944,
		/// <summary>This counter type monitors the average length of a queue to a resource over time. Counters of this type display the difference between the queue lengths observed during the last two sample intervals, divided by the duration of the interval. This counter type is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.QueueLength" /> counter type, except that it uses larger fields to accommodate larger values. (See the PERF_COUNTER_LARGE_QUEUELEN_TYPE counter type in the deployment kit.)</summary>
		LargeQueueLength = 4523264,
		/// <summary>Indicates the number of items sampled. It is used as the denominator in the calculations to get an average among the items sampled when taking timings of multiple, but similar, items. This type supports the following counter types: <see cref="F:System.Diagnostics.PerformanceData.CounterType.MultiTimerPercentageActive" />, <see cref="F:System.Diagnostics.PerformanceData.CounterType.MultiTimerPercentageNotActive" />, <see cref="F:System.Diagnostics.PerformanceData.CounterType.MultiTimerPercentageActive100Ns" />, and <see cref="F:System.Diagnostics.PerformanceData.CounterType.MultiTimerPercentageNotActive100Ns" />.</summary>
		MultiTimerBase = 1107494144,
		/// <summary>This counter type is a multitimer. Multitimers collect data from more than one instance of a component, such as a processor or disk. Counters of this type display the active time of one or more components as a percentage of the total time of the sample interval. Because the numerator records the active time of components operating simultaneously, the resulting percentage can exceed 100 percent. This counter type differs from <see cref="F:System.Diagnostics.PerformanceData.CounterType.MultiTimerPercentageActive100Ns" /> in that it measures time in units of ticks of the system performance timer, rather than in 100 nanosecond units. (See the PERF_COUNTER_MULTI_TIMER counter type in the deployment kit.)</summary>
		MultiTimerPercentageActive = 574686464,
		/// <summary>This counter type shows the active time of one or more components as a percentage of the total time of the sample interval. It measures time in 100nanosecond units. This counter type is a multitimer. Multitimers are designed to monitor more than one instance of a component, such as a processor or disk. (See the PERF_100NSEC_MULTI_TIMER counter type in the deployment kit.)</summary>
		MultiTimerPercentageActive100Ns = 575735040,
		/// <summary>This counter type shows the active time of one or more components as a percentage of the total time of the sample interval. This counter type is an inverse multitimer. Multitimers monitor more than one instance of a component, such as a processor or disk. Inverse counters measure the time that a component is not active and derive the active time from that measurement. This counter differs from <see cref="F:System.Diagnostics.PerformanceData.CounterType.MultiTimerPercentageNotActive100Ns" /> in that it measures time in units of ticks of the system performance timer, rather than in 100 nanosecond units. (See the PERF_COUNTER_MULTI_TIMER_INV counter type in the deployment kit.)</summary>
		MultiTimerPercentageNotActive = 591463680,
		/// <summary>This counter type shows the active time of one or more components as a percentage of the total time of the sample interval. Counters of this type measure time in 100 nanosecond units. This counter type is an inverse multitimer. Multitimers are designed to monitor more than one instance of a component, such as a processor or disk. Inverse counters measure the time that a component is not active and derive its active time from the measurement of inactive time. (See the PERF_100NSEC_MULTI_TIMER_INV counter type in the deployment kit.)</summary>
		MultiTimerPercentageNotActive100Ns = 592512256,
		/// <summary>This 64-bit counter type is a timer that displays in object-specific units. (See the PERF_OBJ_TIME_TIMER counter type in the deployment kit.)</summary>
		ObjectSpecificTimer = 543229184,
		/// <summary>This counter type shows the average time that a component was active as a percentage of the total sample time. (See the PERF_COUNTER_TIMER counter type in the deployment kit.)</summary>
		PercentageActive = 541132032,
		/// <summary>This counter type shows the active time of a component as a percentage of the total elapsed time of the sample interval. It measures time in units of 100 nanoseconds. Counters of this type are designed to measure the activity of one component at a time. (See the PERF_100NSEC_TIMER counter type in the deployment kit.)</summary>
		PercentageActive100Ns = 542180608,
		/// <summary>This is an inverse counter type. Inverse counters measure the time that a component is not active and derive the active time from that measurement. Counters of this type display the average percentage of active time observed during sample interval. The value of these counters is calculated by monitoring the percentage of time that the service was inactive and then subtracting that value from 100 percent. This counter type is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.PercentageNotActive100Ns" /> counter type, except that it measures time in units of ticks of the system performance timer, rather than in 100 nanosecond units. (See the PERF_COUNTER_TIMER_INV counter type in the deployment kit.)</summary>
		PercentageNotActive = 557909248,
		/// <summary>This counter type shows the average percentage of active time observed during the sample interval. This is an inverse counter. Inverse counters are calculated by monitoring the percentage of time that the service was inactive and then subtracting that value from 100 percent. (See the PERF_100NSEC_TIMER_INV counter type in the deployment kit.)</summary>
		PercentageNotActive100Ns = 558957824,
		/// <summary>This counter type shows a value that consists of two counter values: the count of the elapsed time of the event being monitored, and the frequency specified in the PerfFreq field of the object header. This counter type differs from other counter timers in that the clock tick value accompanies the counter value so as to eliminate any possible difference due to latency from the function call. Precision counter types are used when standard system timers are not precise enough for accurate readings. (See the PERF_PRECISION_OBJECT_TIMER counter type in the deployment kit.)</summary>
		PrecisionObjectSpecificTimer = 543622400,
		/// <summary>This counter type shows a value that consists of two counter values: the count of the elapsed time of the event being monitored, and the frequency from the system performance timer. This counter type differs from other counter timers in that the clock tick value accompanies the counter value, eliminating any possible difference due to latency from the function call. Precision counter types are used when standard system timers are not precise enough for accurate readings. (See the PERF_PRECISION_TIMER counter type in the deployment kit.)</summary>
		PrecisionSystemTimer = 541525248,
		/// <summary>This counter type shows a value that consists of two counter values: the count of the elapsed time of the event being monitored, and the "clock" time from a private timer in the same units. It measures time in 100nanosecond units. This counter type differs from other counter timers in that the clock tick value accompanies the counter value eliminating any possible difference due to latency from the function call. Precision counter types are used when standard system timers are not precise enough for accurate readings. (See the PERF_PRECISION_100NS_TIMER counter type in the deployment kit.)</summary>
		PrecisionTimer100Ns = 542573824,
		/// <summary>This counter type is designed to monitor the average length of a queue to a resource over time. It shows the difference between the queue lengths observed during the last two sample intervals divided by the duration of the interval. (See the PERF_COUNTER_QUEUELEN_TYPE counter type in the deployment kit.)</summary>
		QueueLength = 4523008,
		/// <summary>This counter type measures the queue-length space-time product using a 100-nanosecond time base. (See the PERF_COUNTER_100NS_QUEUELEN_TYPE counter type in the deployment kit.)</summary>
		QueueLength100Ns = 5571840,
		/// <summary>This counter type measures the queue-length space-time product using an object-specific time base. (See the PERF_COUNTER_OBJ_QUEUELEN_TYPE counter type in the deployment kit.)</summary>
		QueueLengthObjectTime = 6620416,
		/// <summary>This counter type shows the average number of operations completed during each second of the sample interval. Counters of this type measure time in ticks of the system clock. (See the PERF_COUNTER_COUNTER counter type in the deployment kit.)</summary>
		RateOfCountPerSecond32 = 272696320,
		/// <summary>This counter type shows the average number of operations completed during each second of the sample interval. Counters of this type measure time in ticks of the system clock. This counter type is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.RateOfCountPerSecond32" /> type, but it uses larger fields to accommodate larger values. (See the PERF_COUNTER_BULK_COUNT counter type in the deployment kit.)</summary>
		RateOfCountPerSecond64 = 272696576,
		/// <summary>This counter type collects the last observed value only. The value is used as the denominator of a counter that presents a general arithmetic fraction. This type supports the <see cref="F:System.Diagnostics.PerformanceData.CounterType.RawFraction32" /> counter type. (See the PERF_RAW_BASE counter type in the deployment kit.)</summary>
		RawBase32 = 1073939459,
		/// <summary>This counter type collects the last observed value. It is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.RawBase32" />counter type except that it uses larger fields to accommodate larger values. This type supports the <see cref="F:System.Diagnostics.PerformanceData.CounterType.RawFraction64" /> counter type. (See the PERF_LARGE_RAW_BASE counter type in the deployment kit.)</summary>
		RawBase64 = 1073939712,
		/// <summary>This counter type shows the last observed value only. It does not display an average. (See the PERF_COUNTER_RAWCOUNT counter type in the deployment kit.)</summary>
		RawData32 = 65536,
		/// <summary>This counter type shows the last observed value only, not an average. It is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.RawData32" /> counter type, except that it uses larger fields to accommodate larger values. (See the PERF_COUNTER_LARGE_RAWCOUNT counter type in the deployment kit.)</summary>
		RawData64 = 65792,
		/// <summary>This counter type shows the most recently observed value, in hexadecimal format. It does not display an average. (See the PERF_COUNTER_RAWCOUNT_HEX counter type in the deployment kit.)</summary>
		RawDataHex32 = 0,
		/// <summary>This counter type shows the last observed value, in hexadecimal format. It is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.RawDataHex32" /> counter type, except that it uses larger fields to accommodate larger values. (See the PERF_COUNTER_LARGE_RAWCOUNT_HEX counter type in the deployment kit.)</summary>
		RawDataHex64 = 256,
		/// <summary>This counter type shows the ratio of a subset to its set as a percentage. For example, it compares the number of bytes in use on a disk to the total number of bytes on the disk. Counters of this type display the current percentage only, not an average over time. (See the PERF_RAW_FRACTION counter type in the deployment kit.)</summary>
		RawFraction32 = 537003008,
		/// <summary>This counter type shows the ratio of a subset to its set as a percentage. For example, it compares the number of bytes in use on a disk to the total number of bytes on the disk. Counters of this type display the current percentage only, not an average over time. It is the same as the <see cref="F:System.Diagnostics.PerformanceData.CounterType.RawFraction32" /> counter type, except that it uses larger fields to accommodate larger values.</summary>
		RawFraction64 = 537003264,
		/// <summary>This counter stores the number of sampling interrupts taken and is used as a denominator in the sampling fraction. This type supports the <see cref="F:System.Diagnostics.PerformanceData.CounterType.SampleFraction" /> counter type.</summary>
		SampleBase = 1073939457,
		/// <summary>This counter type shows the average number of operations completed in one second. It measures time in units of ticks of the system performance timer. The variable F represents the number of ticks that occur in one second. The value of F is factored into the equation so that the result is displayed in seconds. (See the PERF_SAMPLE_COUNTER counter type in the deployment kit.)</summary>
		SampleCounter = 4260864,
		/// <summary>This counter type shows the average ratio of hits to all operations during the last two sample intervals. (See the PERF_SAMPLE_FRACTION counter type in the deployment kit.)</summary>
		SampleFraction = 549585920
	}
	/// <summary>Creates an instance of the logical counters defined in the <see cref="T:System.Diagnostics.PerformanceData.CounterSet" /> class.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CounterSetInstance : IDisposable
	{
		/// <summary>Retrieves the collection of counter data for the counter set instance.</summary>
		/// <returns>A collection of the counter data contained in the counter set instance.</returns>
		public CounterSetInstanceCounterDataSet Counters
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		internal CounterSetInstance()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases all unmanaged resources used by this object.</summary>
		[SecurityCritical]
		public void Dispose()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Contains the collection of counter values.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class CounterSetInstanceCounterDataSet : IDisposable
	{
		/// <summary>Accesses a counter value in the collection by using the specified counter name.</summary>
		/// <param name="counterName">Name of the counter. This is the name that you used when you added the counter to the counter set.</param>
		/// <returns>The counter data.</returns>
		public CounterData this[string counterName]
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		internal CounterSetInstanceCounterDataSet()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		[SpecialName]
		public CounterData get_Item(int counterId)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Releases all unmanaged resources used by this object.</summary>
		[SecurityCritical]
		public void Dispose()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
}
namespace System.Diagnostics.Eventing
{
	/// <summary>Contains the metadata that defines an event.</summary>
	[StructLayout(LayoutKind.Explicit, Size = 16)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public struct EventDescriptor
	{
		/// <summary>Retrieves the channel value from the event descriptor.</summary>
		/// <returns>The channel that defines a potential target for the event.</returns>
		public byte Channel
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(byte);
			}
		}

		/// <summary>Retrieves the event identifier value from the event descriptor.</summary>
		/// <returns>The event identifier.</returns>
		public int EventId
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(int);
			}
		}

		/// <summary>Retrieves the keyword value from the event descriptor.</summary>
		/// <returns>The keyword, which is a bit mask, that specifies the event category.</returns>
		public long Keywords
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(long);
			}
		}

		/// <summary>Retrieves the level value from the event descriptor.</summary>
		/// <returns>The level of detail included in the event.</returns>
		public byte Level
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(byte);
			}
		}

		/// <summary>Retrieves the operation code value from the event descriptor.</summary>
		/// <returns>The operation being performed at the time the event is written.</returns>
		public byte Opcode
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(byte);
			}
		}

		/// <summary>Retrieves the task value from the event descriptor.</summary>
		/// <returns>The task that identifies the logical component of the application that is writing the event.</returns>
		public int Task
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(int);
			}
		}

		/// <summary>Retrieves the version value from the event descriptor.</summary>
		/// <returns>The version of the event. </returns>
		public byte Version
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(byte);
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> class.</summary>
		/// <param name="id">The event identifier.</param>
		/// <param name="version">Version of the event. The version indicates a revision to the event definition. You can use this member and the Id member to identify a unique event.</param>
		/// <param name="channel">Defines a potential target for the event.</param>
		/// <param name="level">Specifies the level of detail included in the event.</param>
		/// <param name="opcode">Operation being performed at the time the event is written.</param>
		/// <param name="task">Identifies a logical component of the application that is writing the event.</param>
		/// <param name="keywords">Bit mask that specifies the event category. The keyword can contain one or more provider-defined keywords, standard keywords, or both.</param>
		public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Use this class to write events.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventProvider : IDisposable
	{
		/// <summary>Defines the possible states of the last write operation.</summary>
		public enum WriteEventErrorCode
		{
			/// <summary>The event is larger than the session buffer size; events cannot span buffers.</summary>
			EventTooBig = 2,
			/// <summary>The write was successful.</summary>
			NoError = 0,
			/// <summary>The session ran out of free buffers to write to. This can occur during high event rates because the disk subsystem is overloaded or the number of buffers is too small. Rather than blocking until more buffers become available, the event is dropped. Consider increasing the number and size of the buffers for the session, or reducing the number of events written or the size of the events.</summary>
			NoFreeBuffers = 1
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.EventProvider" /> class.</summary>
		/// <param name="providerGuid">Guid that uniquely identifies the provider.</param>
		/// <exception cref="T:System.InsufficientMemoryException">There is not enough memory to complete the operation.</exception>
		/// <exception cref="T:System.PlatformNotSupportedException">The classes in the <see cref="N:System.Diagnostics.Eventing" /> namespace work only on Windows Vista.</exception>
		/// <exception cref="T:System.ArgumentException">The <paramref name="providerGuid" /> parameter cannot be null.</exception>
		/// <exception cref="T:System.ComponentModel.Win32Exception">An error returned by the ETW subsystem. </exception>
		[SecuritySafeCritical]
		[PermissionSet(SecurityAction.Demand, Unrestricted = true)]
		public EventProvider(Guid providerGuid)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Removes the provider's registration from the ETW subsystem and releases all unmanaged resources.</summary>
		/// <exception cref="T:System.ComponentModel.Win32Exception">An error returned by the ETW subsystem. </exception>
		public virtual void Close()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Creates a unique activity identifier for the provider.</summary>
		/// <returns>A unique Guid that you use when calling the <see cref="M:System.Diagnostics.Eventing.EventProvider.SetActivityId(System.Guid@)" /> method to set the activity identifier for the provider.</returns>
		[SecurityCritical]
		public static Guid CreateActivityId()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return default(Guid);
		}

		/// <summary>Releases the resources used by this <see cref="T:System.Diagnostics.Eventing.EventProvider" /> object.</summary>
		public void Dispose()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases the resources used by this <see cref="T:System.Diagnostics.Eventing.EventProvider" /> object.</summary>
		/// <param name="disposing">This parameter is ignored by this method since there are no unmanaged resources.</param>
		[SecuritySafeCritical]
		protected virtual void Dispose(bool disposing)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Gets the last error associated with an event write failure.</summary>
		/// <returns>Use the value to determine the cause of an event write failure.</returns>
		public static WriteEventErrorCode GetLastWriteEventError()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return default(WriteEventErrorCode);
		}

		/// <summary>Determines whether any session enabled the provider, regardless of the level and keyword values used to enable the provider.</summary>
		/// <returns>Is <see langword="true" /> if the provider is enabled to any session; otherwise, <see langword="false" />.</returns>
		public bool IsEnabled()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return default(bool);
		}

		/// <summary>Determines whether any session is requesting the specified event from the provider.</summary>
		/// <param name="level">Level of detail included in the event.</param>
		/// <param name="keywords">Bit mask that specifies the event category. This mask should be the same keyword mask that is defined in the manifest for the event.</param>
		/// <returns>Is <see langword="true" /> if any session is requesting the specified event; otherwise, <see langword="false" />.</returns>
		public bool IsEnabled(byte level, long keywords)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return default(bool);
		}

		/// <summary>Sets the current activity identifier used by the <see cref="Overload:System.Diagnostics.Eventing.EventProvider.WriteEvent" /> methods.</summary>
		/// <param name="id">A unique activity identifier that the <see cref="M:System.Diagnostics.Eventing.EventProvider.CreateActivityId" /> method returns.</param>
		[SecurityCritical]
		public static void SetActivityId(ref Guid id)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Writes an event. The event data is specified as a block of memory.</summary>
		/// <param name="eventDescriptor">An instance of <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> that identifies the event to write.</param>
		/// <param name="dataCount">Size of the event data to which the <paramref name="data" /> parameter points. The maximum event data size is limited to 64 KB minus the size of the event headers. The event size is less if the session's buffer size is less and the session includes extended data items with the event.</param>
		/// <param name="data">Pointer to the event data to write.</param>
		/// <returns>Is <see langword="true" /> if the event is written; otherwise, <see langword="false" />. If false, call the <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> method to determine the cause of the failure.</returns>
		[SecurityCritical]
		protected bool WriteEvent(ref EventDescriptor eventDescriptor, int dataCount, IntPtr data)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return default(bool);
		}

		/// <summary>Writes an event. The event data is specified as an array of objects.</summary>
		/// <param name="eventDescriptor">An instance of <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> that identifies the event to write.</param>
		/// <param name="eventPayload">An array of objects that contain the event data to write. The object must be in the order specified in the manifest. The array is limited to 32 objects, of which only eight may be strings. The maximum data size for the event is limited to 64 KB minus the size of the event headers. The event size is less if the session's buffer size is less and the session includes extended data items with the event.This parameter can be null.</param>
		/// <returns>Is <see langword="true" /> if the event is written; otherwise, <see langword="false" />. If false, call the <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> method to determine the cause of the failure.</returns>
		/// <exception cref="T:System.ArgumentException">The <paramref name="eventPayload" /> parameter contains too many objects or strings.</exception>
		public bool WriteEvent(ref EventDescriptor eventDescriptor, object[] eventPayload)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return default(bool);
		}

		/// <summary>Writes an event. The event data is specified as a string.</summary>
		/// <param name="eventDescriptor">An instance of <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> that identifies the event to write.</param>
		/// <param name="data">The string to write as the event data.</param>
		/// <returns>Is <see langword="true" /> if the event is written; otherwise, <see langword="false" />. If false, call the <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> method to determine the cause of the failure.</returns>
		/// <exception cref="T:System.ArgumentException">If <paramref name="data" /> is <see langword="null" />.</exception>
		[SecurityCritical]
		public bool WriteEvent(ref EventDescriptor eventDescriptor, string data)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return default(bool);
		}

		/// <summary>Writes an event that contains a string as its data.</summary>
		/// <param name="eventMessage">String to write as the event data.</param>
		/// <returns>Is <see langword="true" /> if the event is written; otherwise, <see langword="false" />. If false, call the <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> method to determine the cause of the failure.</returns>
		/// <exception cref="T:System.ArgumentException">If <paramref name="eventMessage" /> is <see langword="null" />.</exception>
		public bool WriteMessageEvent(string eventMessage)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return default(bool);
		}

		/// <summary>Writes an event that contains a string as its data if the level and keyword value match the events requested by the session.</summary>
		/// <param name="eventMessage">String to write as the event data.</param>
		/// <param name="eventLevel">Level of detail included in the event. If the provider uses a manifest to define the event, set this value to the same level defined in the manifest.</param>
		/// <param name="eventKeywords">Bit mask that specifies the event category. If the provider uses a manifest to define the event, set this value to the same keyword mask defined in the manifest.</param>
		/// <returns>Is <see langword="true" /> if the event is written; otherwise, <see langword="false" />. If false, call the <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> method to determine the cause of the failure.</returns>
		/// <exception cref="T:System.ArgumentException">If <paramref name="eventMessage" /> is <see langword="null" />.</exception>
		[SecurityCritical]
		public bool WriteMessageEvent(string eventMessage, byte eventLevel, long eventKeywords)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return default(bool);
		}

		/// <summary>Links events together when tracing events in an end-to-end scenario. The event data is specified as a block of memory.</summary>
		/// <param name="eventDescriptor">An instance of <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> that identifies the event to write.</param>
		/// <param name="relatedActivityId">Activity identifier from the previous component. Use this parameter to link your component's events to the previous component's events.</param>
		/// <param name="dataCount">Size of the event data to which the <paramref name="data" /> parameter points. The maximum event data size is limited to 64 KB minus the size of the event headers. The event size is less if the session's buffer size is less and the session includes extended data items with the event.</param>
		/// <param name="data">Pointer to the event data to write.</param>
		/// <returns>Is <see langword="true" /> if the event is written; otherwise, <see langword="false" />. If false, call the <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> method to determine the cause of the failure.</returns>
		[SecurityCritical]
		protected bool WriteTransferEvent(ref EventDescriptor eventDescriptor, Guid relatedActivityId, int dataCount, IntPtr data)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return default(bool);
		}

		/// <summary>Links events together when tracing events in an end-to-end scenario. The event data is specified as an array of objects.</summary>
		/// <param name="eventDescriptor">An instance of <see cref="T:System.Diagnostics.Eventing.EventDescriptor" /> that identifies the event to write.</param>
		/// <param name="relatedActivityId">Activity identifier from the previous component. Use this parameter to link your component's events to the previous component's events.</param>
		/// <param name="eventPayload">An array of objects that contain the event data to write. The data must be in the order specified in the manifest. The array is limited to 32 objects, of which only eight may be strings. The maximum data size for the event is limited to 64 KB minus the size of the event headers. The event size is less if the session's buffer size is less and the session includes extended data items with the event.</param>
		/// <returns>Is <see langword="true" /> if the event is written; otherwise, <see langword="false" />. If false, call the <see cref="M:System.Diagnostics.Eventing.EventProvider.GetLastWriteEventError" /> method to determine the cause of the failure.</returns>
		/// <exception cref="T:System.ArgumentException">If <paramref name="eventPayload" /> contains too many objects or strings.</exception>
		[SecurityCritical]
		public bool WriteTransferEvent(ref EventDescriptor eventDescriptor, Guid relatedActivityId, object[] eventPayload)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return default(bool);
		}
	}
	/// <summary>A listener for <see cref="T:System.Diagnostics.TraceSource" /> that writes events to the ETW subsytem. </summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventProviderTraceListener : TraceListener
	{
		/// <summary>Gets and sets the delimiter used to delimit the event data that is written to the ETW subsystem.</summary>
		/// <returns>The delimiter used to delimit the event data. The default delimiter is a comma.</returns>
		public string Delimiter
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.EventProviderTraceListener" /> class using the specified provider identifier.</summary>
		/// <param name="providerId">A unique string <see cref="T:System.Guid" /> that identifies the provider.</param>
		public EventProviderTraceListener(string providerId)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.EventProviderTraceListener" /> class using the specified provider identifier and name of the listener.</summary>
		/// <param name="providerId">A unique string <see cref="T:System.Guid" /> that identifies the provider.</param>
		/// <param name="name">Name of the listener.</param>
		public EventProviderTraceListener(string providerId, string name)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.EventProviderTraceListener" /> class using the specified provider identifier, name of the listener, and delimiter.</summary>
		/// <param name="providerId">A unique string <see cref="T:System.Guid" /> that identifies the provider.</param>
		/// <param name="name">Name of the listener.</param>
		/// <param name="delimiter">Delimiter used to delimit the event data. (For more details, see the <see cref="P:System.Diagnostics.Eventing.EventProviderTraceListener.Delimiter" /> property.)</param>
		public EventProviderTraceListener(string providerId, string name, string delimiter)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>When overridden in a derived class, writes the specified message to the listener you create in the derived class.</summary>
		/// <param name="message">A message to write.</param>
		public sealed override void Write(string message)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>When overridden in a derived class, writes a message to the listener you create in the derived class, followed by a line terminator.</summary>
		/// <param name="message">A message to write. </param>
		public sealed override void WriteLine(string message)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
}
namespace System.Diagnostics.Eventing.Reader
{
	/// <summary>Represents a placeholder (bookmark) within an event stream. You can use the placeholder to mark a position and return to this position in a stream of events. An instance of this object can be obtained from an <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" /> object, in which case it corresponds to the position of that event record.</summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventBookmark : ISerializable
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventBookmark" /> class from the specified <see cref="T:System.Runtime.Serialization.SerializationInfo" /> and <see cref="T:System.Runtime.Serialization.StreamingContext" /> instances.</summary>
		/// <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the new <see cref="T:System.Diagnostics.Eventing.Reader.EventBookmark" /> object.</param>
		/// <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains the source of the serialized stream that is associated with the new <see cref="T:System.Diagnostics.Eventing.Reader.EventBookmark" />.</param>
		protected EventBookmark(SerializationInfo info, StreamingContext context)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data required to serialize the target object.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object to populate with data.</param>
		/// <param name="context">The destination for this serialization.</param>
		[SecurityCritical]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		protected virtual void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data needed to serialize the target object.</summary>
		/// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object to populate with data.</param>
		/// <param name="context">The destination for this serialization.</param>
		[SecurityCritical]
		[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.SerializationFormatter)]
		void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents a keyword for an event. Keywords are defined in an event provider and are used to group the event with other similar events (based on the usage of the events).</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventKeyword
	{
		/// <summary>Gets the localized name of the keyword.</summary>
		/// <returns>Returns a string that contains a localized name for this keyword.</returns>
		public string DisplayName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the non-localized name of the keyword.</summary>
		/// <returns>Returns a string that contains the non-localized name of this keyword.</returns>
		public string Name
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the numeric value associated with the keyword.</summary>
		/// <returns>Returns a <see langword="long" /> value.</returns>
		public long Value
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(long);
			}
		}

		internal EventKeyword()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Contains an event level that is defined in an event provider. The level signifies the severity of the event.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventLevel
	{
		/// <summary>Gets the localized name for the event level. The name describes what severity level of events this level is used for.</summary>
		/// <returns>Returns a string that contains the localized name for the event level.</returns>
		public string DisplayName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the non-localized name of the event level.</summary>
		/// <returns>Returns a string that contains the non-localized name of the event level.</returns>
		public string Name
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the numeric value of the event level.</summary>
		/// <returns>Returns an integer value.</returns>
		public int Value
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(int);
			}
		}

		internal EventLevel()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Contains static information and configuration settings for an event log. Many of the configurations settings were defined by the event provider that created the log.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogConfiguration : IDisposable
	{
		/// <summary>Gets the flag that indicates if the event log is a classic event log. A classic event log is one that has its events defined in a .mc file instead of a manifest (.xml file) used by the event provider.</summary>
		/// <returns>Returns <see langword="true" /> if the event log is a classic log, and returns <see langword="false" /> if the event log is not a classic log.</returns>
		public bool IsClassicLog
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(bool);
			}
		}

		/// <summary>Gets or sets a Boolean value that determines whether the event log is enabled or disabled. An enabled log is one in which events can be logged, and a disabled log is one in which events cannot be logged.</summary>
		/// <returns>Returns <see langword="true" /> if the log is enabled, and returns <see langword="false" /> if the log is disabled.</returns>
		public bool IsEnabled
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(bool);
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets or sets the file directory path to the location of the file where the events are stored for the log.</summary>
		/// <returns>Returns a string that contains the path to the event log file.</returns>
		public string LogFilePath
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogIsolation" /> value that specifies whether the event log is an application, system, or custom event log. </summary>
		/// <returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogIsolation" /> value.</returns>
		public EventLogIsolation LogIsolation
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(EventLogIsolation);
			}
		}

		/// <summary>Gets or sets an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogMode" /> value that determines how events are handled when the event log becomes full.</summary>
		/// <returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogMode" /> value.</returns>
		public EventLogMode LogMode
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(EventLogMode);
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets the name of the event log.</summary>
		/// <returns>Returns a string that contains the name of the event log.</returns>
		public string LogName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogType" /> value that determines the type of the event log.</summary>
		/// <returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogType" /> value.</returns>
		public EventLogType LogType
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(EventLogType);
			}
		}

		/// <summary>Gets or sets the maximum size, in bytes, that the event log file is allowed to be. When the file reaches this maximum size, it is considered full.</summary>
		/// <returns>Returns a long value that represents the maximum size, in bytes, that the event log file is allowed to be.</returns>
		public long MaximumSizeInBytes
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(long);
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets the name of the event provider that created this event log.</summary>
		/// <returns>Returns a string that contains the name of the event provider that created this event log.</returns>
		public string OwningProviderName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the size of the buffer that the event provider uses for publishing events to the log.</summary>
		/// <returns>Returns an integer value that can be null.</returns>
		public int? ProviderBufferSize
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the control globally unique identifier (GUID) for the event log if the log is a debug log. If this log is not a debug log, this value will be null. </summary>
		/// <returns>Returns a GUID value or null.</returns>
		public Guid? ProviderControlGuid
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets or sets keyword mask used by the event provider.</summary>
		/// <returns>Returns a long value that can be null if the event provider did not define any keywords.</returns>
		public long? ProviderKeywords
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets the maximum latency time used by the event provider when publishing events to the log.</summary>
		/// <returns>Returns an integer value that can be null if no latency time was specified by the event provider.</returns>
		public int? ProviderLatency
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets or sets the maximum event level (which defines the severity of the event) that is allowed to be logged in the event log. This value is defined by the event provider.</summary>
		/// <returns>Returns an integer value that can be null if the maximum event level was not defined in the event provider.</returns>
		public int? ProviderLevel
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets the maximum number of buffers used by the event provider to publish events to the event log.</summary>
		/// <returns>Returns an integer value that is the maximum number of buffers used by the event provider to publish events to the event log. This value can be null.</returns>
		public int? ProviderMaximumNumberOfBuffers
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the minimum number of buffers used by the event provider to publish events to the event log.</summary>
		/// <returns>Returns an integer value that is the minimum number of buffers used by the event provider to publish events to the event log. This value can be null.</returns>
		public int? ProviderMinimumNumberOfBuffers
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets an enumerable collection of the names of all the event providers that can publish events to this event log.</summary>
		/// <returns>Returns an enumerable collection of strings that contain the event provider names.</returns>
		public IEnumerable<string> ProviderNames
		{
			get
			{
				//IL_0007: Expected O, but got I4
				Unity.ThrowStub.ThrowNotSupportedException();
				return (IEnumerable<string>)0;
			}
		}

		/// <summary>Gets or sets the security descriptor of the event log. The security descriptor defines the users and groups of users that can read and write to the event log.</summary>
		/// <returns>Returns a string that contains the security descriptor for the event log.</returns>
		public string SecurityDescriptor
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Initializes a new <see cref="T:System.Diagnostics.Eventing.Reader.EventLogConfiguration" /> object by specifying the local event log for which to get information and configuration settings. </summary>
		/// <param name="logName">The name of the local event log for which to get information and configuration settings.</param>
		public EventLogConfiguration(string logName)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new <see cref="T:System.Diagnostics.Eventing.Reader.EventLogConfiguration" /> object by specifying the name of the log for which to get information and configuration settings. The log can be on the local computer or a remote computer, based on the event log session specified.</summary>
		/// <param name="logName">The name of the event log for which to get information and configuration settings.</param>
		/// <param name="session">The event log session used to determine the event log service that the specified log belongs to. The session is either connected to the event log service on the local computer or a remote computer.</param>
		[SecurityCritical]
		public EventLogConfiguration(string logName, EventLogSession session)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases all the resources used by this object.</summary>
		public void Dispose()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases the unmanaged resources used by this object, and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///       <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		[SecuritySafeCritical]
		protected virtual void Dispose(bool disposing)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Saves the configuration settings that </summary>
		public void SaveChanges()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Used to access the Event Log service on the local computer or a remote computer so you can manage and gather information about the event logs and event providers on the computer.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogSession : IDisposable
	{
		/// <summary>Gets a static predefined session object that is connected to the Event Log service on the local computer.</summary>
		/// <returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogSession" /> object that is a predefined session object that is connected to the Event Log service on the local computer.</returns>
		public static EventLogSession GlobalSession
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Initializes a new <see cref="T:System.Diagnostics.Eventing.Reader.EventLogSession" /> object, establishes a connection with the local Event Log service.</summary>
		[SecurityCritical]
		public EventLogSession()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new <see cref="T:System.Diagnostics.Eventing.Reader.EventLogSession" /> object, and establishes a connection with the Event Log service on the specified computer. The credentials (user name and password) of the user who calls the method is used for the credentials to access the remote computer.</summary>
		/// <param name="server">The name of the computer on which to connect to the Event Log service.</param>
		public EventLogSession(string server)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new <see cref="T:System.Diagnostics.Eventing.Reader.EventLogSession" /> object, and establishes a connection with the Event Log service on the specified computer. The specified credentials (user name and password) are used for the credentials to access the remote computer.</summary>
		/// <param name="server">The name of the computer on which to connect to the Event Log service.</param>
		/// <param name="domain">The domain of the specified user.</param>
		/// <param name="user">The user name used to connect to the remote computer.</param>
		/// <param name="password">The password used to connect to the remote computer.</param>
		/// <param name="logOnType">The type of connection to use for the connection to the remote computer.</param>
		[SecurityCritical]
		public EventLogSession(string server, string domain, string user, SecureString password, SessionAuthentication logOnType)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Cancels any operations (such as reading an event log or subscribing to an event log) that are currently active for the Event Log service that this session object is connected to.</summary>
		public void CancelCurrentOperations()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Clears events from the specified event log.</summary>
		/// <param name="logName">The name of the event log to clear all the events from.</param>
		public void ClearLog(string logName)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Clears events from the specified event log, and saves the cleared events to the specified file.</summary>
		/// <param name="logName">The name of the event log to clear all the events from.</param>
		/// <param name="backupPath">The path to the file in which the cleared events will be saved. The file should end in .evtx.</param>
		public void ClearLog(string logName, string backupPath)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases all the resources used by this object.</summary>
		public void Dispose()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases the unmanaged resources used by this object, and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///       <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		[SecuritySafeCritical]
		protected virtual void Dispose(bool disposing)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Exports events into an external log file. The events are stored without the event messages.</summary>
		/// <param name="path">The name of the event log to export events from, or the path to the event log file to export events from.</param>
		/// <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
		/// <param name="query">The query used to select the events to export.  Only the events returned from the query will be exported.</param>
		/// <param name="targetFilePath">The path to the log file (ends in .evtx) in which the exported events will be stored after this method is executed.</param>
		public void ExportLog(string path, PathType pathType, string query, string targetFilePath)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Exports events into an external log file. A flag can be set to indicate that the method will continue exporting events even if the specified query fails for some logs. The events are stored without the event messages.</summary>
		/// <param name="path">The name of the event log to export events from, or the path to the event log file to export events from.</param>
		/// <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
		/// <param name="query">The query used to select the events to export. Only the events returned from the query will be exported.</param>
		/// <param name="targetFilePath">The path to the log file (ends in .evtx) in which the exported events will be stored after this method is executed.</param>
		/// <param name="tolerateQueryErrors">
		///       <see langword="true" /> indicates that the method will continue exporting events even if the specified query fails for some logs, and <see langword="false" /> indicates that this method will not continue to export events when the specified query fails.</param>
		public void ExportLog(string path, PathType pathType, string query, string targetFilePath, bool tolerateQueryErrors)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Exports events and their messages into an external log file.</summary>
		/// <param name="path">The name of the event log to export events from, or the path to the event log file to export events from.</param>
		/// <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
		/// <param name="query">The query used to select the events to export.  Only the events returned from the query will be exported.</param>
		/// <param name="targetFilePath">The path to the log file (ends in .evtx) in which the exported events will be stored after this method is executed.</param>
		public void ExportLogAndMessages(string path, PathType pathType, string query, string targetFilePath)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Exports events and their messages into an external log file. A flag can be set to indicate that the method will continue exporting events even if the specified query fails for some logs. The event messages are exported in the specified language.</summary>
		/// <param name="path">The name of the event log to export events from, or the path to the event log file to export events from.</param>
		/// <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
		/// <param name="query">The query used to select the events to export.  Only the events returned from the query will be exported.</param>
		/// <param name="targetFilePath">The path to the log file (ends in .evtx) in which the exported events will be stored after this method is executed.</param>
		/// <param name="tolerateQueryErrors">
		///       <see langword="true" /> indicates that the method will continue exporting events even if the specified query fails for some logs, and <see langword="false" /> indicates that this method will not continue to export events when the specified query fails.</param>
		/// <param name="targetCultureInfo">The culture that specifies which language that the exported event messages will be in.</param>
		public void ExportLogAndMessages(string path, PathType pathType, string query, string targetFilePath, bool tolerateQueryErrors, CultureInfo targetCultureInfo)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Gets an object that contains runtime information for the specified event log.</summary>
		/// <param name="logName">The name of the event log to get information about, or the path to the event log file to get information about.</param>
		/// <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
		/// <returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogInformation" /> object that contains information about the specified log.</returns>
		public EventLogInformation GetLogInformation(string logName, PathType pathType)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Gets an enumerable collection of all the event log names that are registered with the Event Log service.</summary>
		/// <returns>Returns an enumerable collection of strings that contain the event log names.</returns>
		[SecurityCritical]
		public IEnumerable<string> GetLogNames()
		{
			//IL_0007: Expected O, but got I4
			Unity.ThrowStub.ThrowNotSupportedException();
			return (IEnumerable<string>)0;
		}

		/// <summary>Gets an enumerable collection of all the event provider names that are registered with the Event Log service. An event provider is an application that publishes events to an event log.</summary>
		/// <returns>Returns an enumerable collection of strings that contain the event provider names.</returns>
		[SecurityCritical]
		public IEnumerable<string> GetProviderNames()
		{
			//IL_0007: Expected O, but got I4
			Unity.ThrowStub.ThrowNotSupportedException();
			return (IEnumerable<string>)0;
		}
	}
	/// <summary>Defines values for the type of authentication used during a Remote Procedure Call (RPC) login to a server. This login occurs when you create a <see cref="T:System.Diagnostics.Eventing.Reader.EventLogSession" /> object that specifies a connection to a remote computer.</summary>
	public enum SessionAuthentication
	{
		/// <summary>Use the default authentication method during RPC login. The default authentication is equivalent to Negotiate.</summary>
		Default = 0,
		/// <summary>Use Kerberos authentication during RPC login. </summary>
		Kerberos = 2,
		/// <summary>Use the Negotiate authentication method during RPC login. This allows the client application to select the most appropriate authentication method (NTLM or Kerberos) for the situation. </summary>
		Negotiate = 1,
		/// <summary>Use Windows NT LAN Manager (NTLM) authentication during RPC login.</summary>
		Ntlm = 3
	}
	/// <summary>Specifies that a string contains a name of an event log or the file system path to an event log file.</summary>
	public enum PathType
	{
		/// <summary>A path parameter contains the file system path to an event log file.</summary>
		FilePath = 2,
		/// <summary>A path parameter contains the name of the event log.</summary>
		LogName = 1
	}
	/// <summary>Allows you to access the run-time properties of active event logs and event log files. These properties include the number of events in the log, the size of the log, a value that determines whether the log is full, and the last time the log was written to or accessed.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventLogInformation
	{
		/// <summary>Gets the file attributes of the log file associated with the log.</summary>
		/// <returns>Returns an integer value. This value can be null.</returns>
		public int? Attributes
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the time that the log file associated with the event log was created.</summary>
		/// <returns>Returns a <see cref="T:System.DateTime" /> object. This value can be null.</returns>
		public DateTime? CreationTime
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the size of the file, in bytes, associated with the event log.</summary>
		/// <returns>Returns a long value.</returns>
		public long? FileSize
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets a Boolean value that determines whether the log file has reached its maximum size (the log is full).</summary>
		/// <returns>Returns <see langword="true" /> if the log is full, and returns <see langword="false" /> if the log is not full.</returns>
		public bool? IsLogFull
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the last time the log file associated with the event log was accessed.</summary>
		/// <returns>Returns a <see cref="T:System.DateTime" /> object. This value can be null.</returns>
		public DateTime? LastAccessTime
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the last time data was written to the log file associated with the event log.</summary>
		/// <returns>Returns a <see cref="T:System.DateTime" /> object. This value can be null.</returns>
		public DateTime? LastWriteTime
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the number of the oldest event record in the event log.</summary>
		/// <returns>Returns a long value that represents the number of the oldest event record in the event log. This value can be null.</returns>
		public long? OldestRecordNumber
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the number of event records in the event log.</summary>
		/// <returns>Returns a long value that represents the number of event records in the event log. This value can be null.</returns>
		public long? RecordCount
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		internal EventLogInformation()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Defines the default access permissions for the event log. The Application and System values indicate that the log shares the access control list (ACL) with the appropriate Windows log (the Application or System event logs) and share the Event Tracing for Windows (ETW) session with other logs of the same isolation. All channels with Custom isolation use a private ETW session.</summary>
	public enum EventLogIsolation
	{
		/// <summary>The log shares the access control list with the Application event log and shares the ETW session with other logs that have Application isolation.</summary>
		Application = 0,
		/// <summary>The event log is a custom event log that uses its own private ETW session.</summary>
		Custom = 2,
		/// <summary>The log shares the access control list with the System event log and shares the ETW session with other logs that have System isolation.</summary>
		System = 1
	}
	/// <summary>Determines the behavior for the event log service handles an event log when the log reaches its maximum allowed size (when the event log is full).</summary>
	public enum EventLogMode
	{
		/// <summary>Archive the log when full, do not overwrite events. The log is automatically archived when necessary. No events are overwritten. </summary>
		AutoBackup = 1,
		/// <summary>New events continue to be stored when the log file is full. Each new incoming event replaces the oldest event in the log.</summary>
		Circular = 0,
		/// <summary>Do not overwrite events. Clear the log manually rather than automatically.</summary>
		Retain = 2
	}
	/// <summary>Defines the type of events that are logged in an event log. Each log can only contain one type of event.</summary>
	public enum EventLogType
	{
		/// <summary>These events are primarily for end users, administrators, and support. The events that are found in the Administrative type logs indicate a problem and a well-defined solution that an administrator can act on. An example of an administrative event is an event that occurs when an application fails to connect to a printer. </summary>
		Administrative = 0,
		/// <summary>Events in an analytic event log are published in high volume. They describe program operation and indicate problems that cannot be handled by user intervention.</summary>
		Analytical = 2,
		/// <summary>Events in a debug type event log are used solely by developers to diagnose a problem for debugging.</summary>
		Debug = 3,
		/// <summary>Events in an operational type event log are used for analyzing and diagnosing a problem or occurrence. They can be used to trigger tools or tasks based on the problem or occurrence. An example of an operational event is an event that occurs when a printer is added or removed from a system.</summary>
		Operational = 1
	}
	/// <summary>Represents the base class for all the exceptions that are thrown when an error occurs while reading event log related information. </summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogException : Exception
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogException" /> class.</summary>
		public EventLogException()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogException" /> class with the error code for the exception.</summary>
		/// <param name="errorCode">The error code for the error that occurred while reading or configuring event log related information. For more information and a list of event log related error codes, see http://go.microsoft.com/fwlink/?LinkId=82629.</param>
		protected EventLogException(int errorCode)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogException" /> class with serialized data.</summary>
		/// <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that holds the serialized object data about the exception being thrown.</param>
		/// <param name="streamingContext">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains contextual information about the source or destination.</param>
		protected EventLogException(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogException" /> class by specifying the error message that describes the current exception.</summary>
		/// <param name="message">The error message that describes the current exception.</param>
		public EventLogException(string message)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogException" /> class with an error message and inner exception.</summary>
		/// <param name="message">The error message that describes the current exception.</param>
		/// <param name="innerException">The Exception instance that caused the current exception.</param>
		public EventLogException(string message, Exception innerException)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents the exception thrown when an event provider publishes invalid data in an event.</summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogInvalidDataException : EventLogException
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogInvalidDataException" /> class.</summary>
		public EventLogInvalidDataException()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogInvalidDataException" /> class with serialized data.</summary>
		/// <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that holds the serialized object data about the exception thrown.</param>
		/// <param name="streamingContext">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains contextual information about the source or destination.</param>
		protected EventLogInvalidDataException(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogInvalidDataException" /> class by specifying the error message that describes the current exception.</summary>
		/// <param name="message">The error message that describes the current exception.</param>
		public EventLogInvalidDataException(string message)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogInvalidDataException" /> class with an error message and inner exception.</summary>
		/// <param name="message">The error message that describes the current exception.</param>
		/// <param name="innerException">The Exception instance that caused the current exception.</param>
		public EventLogInvalidDataException(string message, Exception innerException)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents a link between an event provider and an event log that the provider publishes events into. This object cannot be instantiated.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventLogLink
	{
		/// <summary>Gets the localized name of the event log.</summary>
		/// <returns>Returns a string that contains the localized name of the event log.</returns>
		public string DisplayName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets a Boolean value that determines whether the event log is imported, rather than defined in the event provider. An imported event log is defined in a different provider.</summary>
		/// <returns>Returns <see langword="true" /> if the event log is imported by the event provider, and returns <see langword="false" /> if the event log is not imported by the event provider.</returns>
		public bool IsImported
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(bool);
			}
		}

		/// <summary>Gets the non-localized name of the event log associated with this object.</summary>
		/// <returns>Returns a string that contains the non-localized name of the event log associated with this object.</returns>
		public string LogName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		internal EventLogLink()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents the exception that is thrown when a requested event log (usually specified by the name of the event log or the path to the event log file) does not exist.</summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogNotFoundException : EventLogException
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogNotFoundException" /> class.</summary>
		public EventLogNotFoundException()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogNotFoundException" /> class with serialized data.</summary>
		/// <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that holds the serialized object data about the exception thrown.</param>
		/// <param name="streamingContext">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains contextual information about the source or destination.</param>
		protected EventLogNotFoundException(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogNotFoundException" /> class by specifying the error message that describes the current exception.</summary>
		/// <param name="message">The error message that describes the current exception.</param>
		public EventLogNotFoundException(string message)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogNotFoundException" /> class with an error message and inner exception.</summary>
		/// <param name="message">The error message that describes the current exception.</param>
		/// <param name="innerException">The Exception instance that caused the current exception.</param>
		public EventLogNotFoundException(string message, Exception innerException)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Contains an array of strings that represent XPath queries for elements in the XML representation of an event, which is based on the Event Schema. The queries in this object are used to extract values from the event.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogPropertySelector : IDisposable
	{
		/// <summary>Initializes a new <see cref="T:System.Diagnostics.Eventing.Reader.EventLogPropertySelector" /> class instance.</summary>
		/// <param name="propertyQueries">XPath queries used to extract values from the XML representation of the event.</param>
		[SecurityCritical]
		public EventLogPropertySelector(IEnumerable<string> propertyQueries)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases all the resources used by this object.</summary>
		public void Dispose()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases the unmanaged resources used by this object, and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///       <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		[SecuritySafeCritical]
		protected virtual void Dispose(bool disposing)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents the exception that is thrown when a specified event provider name references a disabled event provider. A disabled event provider cannot publish events.</summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogProviderDisabledException : EventLogException
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogProviderDisabledException" /> class.</summary>
		public EventLogProviderDisabledException()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogProviderDisabledException" /> class with serialized data.</summary>
		/// <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that holds the serialized object data about the exception thrown.</param>
		/// <param name="streamingContext">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains contextual information about the source or destination.</param>
		protected EventLogProviderDisabledException(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogProviderDisabledException" /> class by specifying the error message that describes the current exception.</summary>
		/// <param name="message">The error message that describes the current exception.</param>
		public EventLogProviderDisabledException(string message)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogProviderDisabledException" /> class with an error message and inner exception.</summary>
		/// <param name="message">The error message that describes the current exception.</param>
		/// <param name="innerException">The Exception instance that caused the current exception.</param>
		public EventLogProviderDisabledException(string message, Exception innerException)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents a query for events in an event log and the settings that define how the query is executed and on what computer the query is executed on.</summary>
	public class EventLogQuery
	{
		/// <summary>Gets or sets the Boolean value that determines whether to read events from the newest event in an event log to the oldest event in the log.</summary>
		/// <returns>Returns <see langword="true" /> if events are read from the newest event in the log to the oldest event, and returns <see langword="false" /> if events are read from the oldest event in the log to the newest event.</returns>
		public bool ReverseDirection
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(bool);
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets or sets the session that access the Event Log service on the local computer or a remote computer. This object can be set to access a remote event log by creating a <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" /> object or an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogWatcher" /> object with this <see cref="T:System.Diagnostics.Eventing.Reader.EventLogQuery" /> object.</summary>
		/// <returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogSession" /> object.</returns>
		public EventLogSession Session
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets or sets a Boolean value that determines whether this query will continue to retrieve events when the query has an error.</summary>
		/// <returns>
		///     <see langword="true" /> indicates that the query will continue to retrieve events even if the query fails for some logs, and <see langword="false" /> indicates that this query will not continue to retrieve events when the query fails.</returns>
		public bool TolerateQueryErrors
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(bool);
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogQuery" /> class by specifying the target of the query. The target can be an active event log or a log file.</summary>
		/// <param name="path">The name of the event log to query, or the path to the event log file to query.</param>
		/// <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
		public EventLogQuery(string path, PathType pathType)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogQuery" /> class by specifying the target of the query and the event query. The target can be an active event log or a log file.</summary>
		/// <param name="path">The name of the event log to query, or the path to the event log file to query.</param>
		/// <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
		/// <param name="query">The event query used to retrieve events that match the query conditions.</param>
		public EventLogQuery(string path, PathType pathType, string query)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Enables you to read events from an event log based on an event query. The events that are read by this object are returned as <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" /> objects.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogReader : IDisposable
	{
		/// <summary>Gets or sets the number of events retrieved from the stream of events on every read operation.</summary>
		/// <returns>Returns an integer value.</returns>
		public int BatchSize
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(int);
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Gets the status of each event log or log file associated with the event query in this object.</summary>
		/// <returns>Returns a list of <see cref="T:System.Diagnostics.Eventing.Reader.EventLogStatus" /> objects that each contain status information about an event log associated with the event query in this object.</returns>
		public IList<EventLogStatus> LogStatus
		{
			[SecurityCritical]
			get
			{
				//IL_0007: Expected O, but got I4
				Unity.ThrowStub.ThrowNotSupportedException();
				return (IList<EventLogStatus>)0;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" /> class by specifying an event query.</summary>
		/// <param name="eventQuery">The event query used to retrieve events.</param>
		public EventLogReader(EventLogQuery eventQuery)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" /> class by specifying an event query and a bookmark that is used as starting position for the query.</summary>
		/// <param name="eventQuery">The event query used to retrieve events.</param>
		/// <param name="bookmark">The bookmark (placeholder) used as a starting position in the event log or stream of events. Only events logged after the bookmark event will be returned by the query.</param>
		[SecurityCritical]
		public EventLogReader(EventLogQuery eventQuery, EventBookmark bookmark)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" /> class by specifying an active event log to retrieve events from.</summary>
		/// <param name="path">The name of the event log to retrieve events from.</param>
		public EventLogReader(string path)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" /> class by specifying the name of an event log to retrieve events from or the path to a log file to retrieve events from.</summary>
		/// <param name="path">The name of the event log to retrieve events from, or the path to the event log file to retrieve events from.</param>
		/// <param name="pathType">Specifies whether the string used in the path parameter specifies the name of an event log, or the path to an event log file.</param>
		public EventLogReader(string path, PathType pathType)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Cancels the current query operation.</summary>
		public void CancelReading()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases all the resources used by this object.</summary>
		public void Dispose()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases the unmanaged resources used by this object, and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///       <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		[SecuritySafeCritical]
		protected virtual void Dispose(bool disposing)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Reads the next event that is returned from the event query in this object.</summary>
		/// <returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" /> object.</returns>
		public EventRecord ReadEvent()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Reads the next event that is returned from the event query in this object.</summary>
		/// <param name="timeout">The maximum time to allow the read operation to run before canceling the operation.</param>
		/// <returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" /> object.</returns>
		[SecurityCritical]
		public EventRecord ReadEvent(TimeSpan timeout)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Changes the position in the event stream where the next event that is read will come from by specifying a bookmark event. No events logged before the bookmark event will be retrieved.</summary>
		/// <param name="bookmark">The bookmark (placeholder) used as a starting position in the event log or stream of events. Only events that have been logged after the bookmark event will be returned by the query.</param>
		public void Seek(EventBookmark bookmark)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Changes the position in the event stream where the next event that is read will come from by specifying a bookmark event and an offset number of events from the bookmark. No events logged before the bookmark plus the offset will be retrieved.</summary>
		/// <param name="bookmark">The bookmark (placeholder) used as a starting position in the event log or stream of events. Only events that have been logged after the bookmark event will be returned by the query.</param>
		/// <param name="offset">The offset number of events to change the position of the bookmark.</param>
		[SecurityCritical]
		public void Seek(EventBookmark bookmark, long offset)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Changes the position in the event stream where the next event that is read will come from by specifying a starting position and an offset from the starting position. No events logged before the starting position plus the offset will be retrieved.</summary>
		/// <param name="origin">A value from the <see cref="T:System.IO.SeekOrigin" /> enumeration defines where in the stream of events to start querying for events.</param>
		/// <param name="offset">The offset number of events to add to the origin.</param>
		[SecurityCritical]
		public void Seek(SeekOrigin origin, long offset)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Contains the status code or error code for a specific event log. This status can be used to determine if the event log is available for an operation.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventLogStatus
	{
		/// <summary>Gets the name of the event log for which the status code is obtained.</summary>
		/// <returns>Returns a string that contains the name of the event log for which the status code is obtained.</returns>
		public string LogName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the status code or error code for the event log. This status or error is the result of a read or subscription operation on the event log.</summary>
		/// <returns>Returns an integer value.</returns>
		public int StatusCode
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(int);
			}
		}

		internal EventLogStatus()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Defines the properties of an event instance for an event that is received from an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" /> object. The event properties provide information about the event such as the name of the computer where the event was logged and the time the event was created. This class is an abstract class. The <see cref="T:System.Diagnostics.Eventing.Reader.EventLogRecord" /> class implements this class.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public abstract class EventRecord : IDisposable
	{
		/// <summary>Gets the globally unique identifier (GUID) for the activity in process for which the event is involved. This allows consumers to group related activities.</summary>
		/// <returns>Returns a GUID value.</returns>
		public abstract Guid? ActivityId { get; }

		/// <summary>Gets a placeholder (bookmark) that corresponds to this event. This can be used as a placeholder in a stream of events.</summary>
		/// <returns>Returns a <see cref="T:System.Diagnostics.Eventing.Reader.EventBookmark" /> object.</returns>
		public abstract EventBookmark Bookmark { get; }

		/// <summary>Gets the identifier for this event. All events with this identifier value represent the same type of event.</summary>
		/// <returns>Returns an integer value. This value can be null.</returns>
		public abstract int Id { get; }

		/// <summary>Gets the keyword mask of the event. Get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventRecord.KeywordsDisplayNames" /> property to get the name of the keywords used in this mask.</summary>
		/// <returns>Returns a long value. This value can be null.</returns>
		public abstract long? Keywords { get; }

		/// <summary>Gets the display names of the keywords used in the keyword mask for this event. </summary>
		/// <returns>Returns an enumerable collection of strings that contain the display names of the keywords used in the keyword mask for this event.</returns>
		public abstract IEnumerable<string> KeywordsDisplayNames { get; }

		/// <summary>Gets the level of the event. The level signifies the severity of the event. For the name of the level, get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventRecord.LevelDisplayName" /> property.</summary>
		/// <returns>Returns a byte value. This value can be null.</returns>
		public abstract byte? Level { get; }

		/// <summary>Gets the display name of the level for this event.</summary>
		/// <returns>Returns a string that contains the display name of the level for this event.</returns>
		public abstract string LevelDisplayName { get; }

		/// <summary>Gets the name of the event log where this event is logged.</summary>
		/// <returns>Returns a string that contains a name of the event log that contains this event.</returns>
		public abstract string LogName { get; }

		/// <summary>Gets the name of the computer on which this event was logged.</summary>
		/// <returns>Returns a string that contains the name of the computer on which this event was logged.</returns>
		public abstract string MachineName { get; }

		/// <summary>Gets the opcode of the event. The opcode defines a numeric value that identifies the activity or a point within an activity that the application was performing when it raised the event. For the name of the opcode, get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventRecord.OpcodeDisplayName" /> property.</summary>
		/// <returns>Returns a short value. This value can be null.</returns>
		public abstract short? Opcode { get; }

		/// <summary>Gets the display name of the opcode for this event.</summary>
		/// <returns>Returns a string that contains the display name of the opcode for this event.</returns>
		public abstract string OpcodeDisplayName { get; }

		/// <summary>Gets the process identifier for the event provider that logged this event.</summary>
		/// <returns>Returns an integer value. This value can be null.</returns>
		public abstract int? ProcessId { get; }

		/// <summary>Gets the user-supplied properties of the event.</summary>
		/// <returns>Returns a list of <see cref="T:System.Diagnostics.Eventing.Reader.EventProperty" /> objects.</returns>
		public abstract IList<EventProperty> Properties { get; }

		/// <summary>Gets the globally unique identifier (GUID) of the event provider that published this event.</summary>
		/// <returns>Returns a GUID value. This value can be null.</returns>
		public abstract Guid? ProviderId { get; }

		/// <summary>Gets the name of the event provider that published this event.</summary>
		/// <returns>Returns a string that contains the name of the event provider that published this event.</returns>
		public abstract string ProviderName { get; }

		/// <summary>Gets qualifier numbers that are used for event identification.</summary>
		/// <returns>Returns an integer value. This value can be null.</returns>
		public abstract int? Qualifiers { get; }

		/// <summary>Gets the event record identifier of the event in the log.</summary>
		/// <returns>Returns a long value. This value can be null.</returns>
		public abstract long? RecordId { get; }

		/// <summary>Gets a globally unique identifier (GUID) for a related activity in a process for which an event is involved.</summary>
		/// <returns>Returns a GUID value. This value can be null.</returns>
		public abstract Guid? RelatedActivityId { get; }

		/// <summary>Gets a task identifier for a portion of an application or a component that publishes an event. A task is a 16-bit value with 16 top values reserved. This type allows any value between 0x0000 and 0xffef to be used. To obtain the task name, get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventRecord.TaskDisplayName" /> property.</summary>
		/// <returns>Returns an integer value. This value can be null.</returns>
		public abstract int? Task { get; }

		/// <summary>Gets the display name of the task for the event.</summary>
		/// <returns>Returns a string that contains the display name of the task for the event.</returns>
		public abstract string TaskDisplayName { get; }

		/// <summary>Gets the thread identifier for the thread that the event provider is running in.</summary>
		/// <returns>Returns an integer value. This value can be null.</returns>
		public abstract int? ThreadId { get; }

		/// <summary>Gets the time, in <see cref="T:System.DateTime" /> format, that the event was created.</summary>
		/// <returns>Returns a <see cref="T:System.DateTime" /> value. The value can be null.</returns>
		public abstract DateTime? TimeCreated { get; }

		/// <summary>Gets the security descriptor of the user whose context is used to publish the event.</summary>
		/// <returns>Returns a <see cref="T:System.Security.Principal.SecurityIdentifier" /> value.</returns>
		public abstract SecurityIdentifier UserId { get; }

		/// <summary>Gets the version number for the event.</summary>
		/// <returns>Returns a byte value. This value can be null.</returns>
		public abstract byte? Version { get; }

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" /> class.</summary>
		protected EventRecord()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases all the resources used by this object.</summary>
		public void Dispose()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases the unmanaged resources used by this object, and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///       <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		protected virtual void Dispose(bool disposing)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Gets the event message in the current locale.</summary>
		/// <returns>Returns a string that contains the event message in the current locale.</returns>
		public abstract string FormatDescription();

		/// <summary>Gets the event message, replacing variables in the message with the specified values.</summary>
		/// <param name="values">The values used to replace variables in the event message. Variables are represented by %n, where n is a number.</param>
		/// <returns>Returns a string that contains the event message in the current locale.</returns>
		public abstract string FormatDescription(IEnumerable<object> values);

		/// <summary>Gets the XML representation of the event. All of the event properties are represented in the event XML. The XML conforms to the event schema.</summary>
		/// <returns>Returns a string that contains the XML representation of the event.</returns>
		public abstract string ToXml();
	}
	/// <summary>Contains the value of an event property that is specified by the event provider when the event is published.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventProperty
	{
		/// <summary>Gets the value of the event property that is specified by the event provider when the event is published.</summary>
		/// <returns>Returns an object.</returns>
		public object Value
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		internal EventProperty()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Represents an exception that is thrown when an error occurred while reading, querying, or subscribing to the events in an event log. </summary>
	[Serializable]
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogReadingException : EventLogException
	{
		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReadingException" /> class.</summary>
		public EventLogReadingException()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReadingException" /> class with serialized data.</summary>
		/// <param name="serializationInfo">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that holds the serialized object data about the exception thrown.</param>
		/// <param name="streamingContext">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> object that contains contextual information about the source or destination.</param>
		protected EventLogReadingException(SerializationInfo serializationInfo, StreamingContext streamingContext)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReadingException" /> class by specifying the error message that describes the current exception.</summary>
		/// <param name="message">The error message that describes the current exception.</param>
		public EventLogReadingException(string message)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReadingException" /> class with an error message and inner exception.</summary>
		/// <param name="message">The error message that describes the current exception.</param>
		/// <param name="innerException">The Exception instance that caused the current exception.</param>
		public EventLogReadingException(string message, Exception innerException)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Contains the properties of an event instance for an event that is received from an <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" /> object. The event properties provide information about the event such as the name of the computer where the event was logged and the time that the event was created.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogRecord : EventRecord
	{
		/// <summary>Gets the globally unique identifier (GUID) for the activity in process for which the event is involved. This allows consumers to group related activities.</summary>
		/// <returns>Returns a GUID value.</returns>
		public override Guid? ActivityId
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets a placeholder (bookmark) that corresponds to this event. This can be used as a placeholder in a stream of events.</summary>
		/// <returns>Returns a <see cref="T:System.Diagnostics.Eventing.Reader.EventBookmark" /> object.</returns>
		public override EventBookmark Bookmark
		{
			[SecuritySafeCritical]
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the name of the event log or the event log file in which the event is stored.</summary>
		/// <returns>Returns a string that contains the name of the event log or the event log file in which the event is stored.</returns>
		public string ContainerLog
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the identifier for this event. All events with this identifier value represent the same type of event.</summary>
		/// <returns>Returns an integer value. This value can be null.</returns>
		public override int Id
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(int);
			}
		}

		/// <summary>Gets the keyword mask of the event. Get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventLogRecord.KeywordsDisplayNames" /> property to get the name of the keywords used in this mask.</summary>
		/// <returns>Returns a long value. This value can be null.</returns>
		public override long? Keywords
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the display names of the keywords used in the keyword mask for this event.</summary>
		/// <returns>Returns an enumerable collection of strings that contain the display names of the keywords used in the keyword mask for this event.</returns>
		public override IEnumerable<string> KeywordsDisplayNames
		{
			get
			{
				//IL_0007: Expected O, but got I4
				Unity.ThrowStub.ThrowNotSupportedException();
				return (IEnumerable<string>)0;
			}
		}

		/// <summary>Gets the level of the event. The level signifies the severity of the event. For the name of the level, get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventLogRecord.LevelDisplayName" /> property.</summary>
		/// <returns>Returns a byte value. This value can be null.</returns>
		public override byte? Level
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the display name of the level for this event.</summary>
		/// <returns>Returns a string that contains the display name of the level for this event.</returns>
		public override string LevelDisplayName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the name of the event log where this event is logged.</summary>
		/// <returns>Returns a string that contains a name of the event log that contains this event.</returns>
		public override string LogName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the name of the computer on which this event was logged.</summary>
		/// <returns>Returns a string that contains the name of the computer on which this event was logged.</returns>
		public override string MachineName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets a list of query identifiers that this event matches. This event matches a query if the query would return this event.</summary>
		/// <returns>Returns an enumerable collection of integer values.</returns>
		public IEnumerable<int> MatchedQueryIds
		{
			get
			{
				//IL_0007: Expected O, but got I4
				Unity.ThrowStub.ThrowNotSupportedException();
				return (IEnumerable<int>)0;
			}
		}

		/// <summary>Gets the opcode of the event. The opcode defines a numeric value that identifies the activity or a point within an activity that the application was performing when it raised the event. For the name of the opcode, get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventLogRecord.OpcodeDisplayName" /> property.</summary>
		/// <returns>Returns a short value. This value can be null.</returns>
		public override short? Opcode
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the display name of the opcode for this event.</summary>
		/// <returns>Returns a string that contains the display name of the opcode for this event.</returns>
		public override string OpcodeDisplayName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the process identifier for the event provider that logged this event.</summary>
		/// <returns>Returns an integer value. This value can be null.</returns>
		public override int? ProcessId
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the user-supplied properties of the event.</summary>
		/// <returns>Returns a list of <see cref="T:System.Diagnostics.Eventing.Reader.EventProperty" /> objects.</returns>
		public override IList<EventProperty> Properties
		{
			get
			{
				//IL_0007: Expected O, but got I4
				Unity.ThrowStub.ThrowNotSupportedException();
				return (IList<EventProperty>)0;
			}
		}

		/// <summary>Gets the globally unique identifier (GUID) of the event provider that published this event.</summary>
		/// <returns>Returns a GUID value. This value can be null.</returns>
		public override Guid? ProviderId
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the name of the event provider that published this event.</summary>
		/// <returns>Returns a string that contains the name of the event provider that published this event.</returns>
		public override string ProviderName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets qualifier numbers that are used for event identification.</summary>
		/// <returns>Returns an integer value. This value can be null.</returns>
		public override int? Qualifiers
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the event record identifier of the event in the log.</summary>
		/// <returns>Returns a long value. This value can be null.</returns>
		public override long? RecordId
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets a globally unique identifier (GUID) for a related activity in a process for which an event is involved.</summary>
		/// <returns>Returns a GUID value. This value can be null.</returns>
		public override Guid? RelatedActivityId
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets a task identifier for a portion of an application or a component that publishes an event. A task is a 16-bit value with 16 top values reserved. This type allows any value between 0x0000 and 0xffef to be used. For the name of the task, get the value of the <see cref="P:System.Diagnostics.Eventing.Reader.EventLogRecord.TaskDisplayName" /> property.</summary>
		/// <returns>Returns an integer value. This value can be null.</returns>
		public override int? Task
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the display name of the task for the event.</summary>
		/// <returns>Returns a string that contains the display name of the task for the event.</returns>
		public override string TaskDisplayName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the thread identifier for the thread that the event provider is running in.</summary>
		/// <returns>Returns an integer value. This value can be null.</returns>
		public override int? ThreadId
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the time, in <see cref="T:System.DateTime" /> format, that the event was created.</summary>
		/// <returns>Returns a <see cref="T:System.DateTime" /> value. The value can be null.</returns>
		public override DateTime? TimeCreated
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the security descriptor of the user whose context is used to publish the event.</summary>
		/// <returns>Returns a <see cref="T:System.Security.Principal.SecurityIdentifier" /> value.</returns>
		public override SecurityIdentifier UserId
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the version number for the event.</summary>
		/// <returns>Returns a byte value. This value can be null.</returns>
		public override byte? Version
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		internal EventLogRecord()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases the unmanaged resources used by this object, and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///       <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		[SecuritySafeCritical]
		protected override void Dispose(bool disposing)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Gets the event message in the current locale.</summary>
		/// <returns>Returns a string that contains the event message in the current locale.</returns>
		public override string FormatDescription()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Gets the event message, replacing variables in the message with the specified values.</summary>
		/// <param name="values">The values used to replace variables in the event message. Variables are represented by %n, where n is a number.</param>
		/// <returns>Returns a string that contains the event message in the current locale.</returns>
		public override string FormatDescription(IEnumerable<object> values)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}

		/// <summary>Gets the enumeration of the values of the user-supplied event properties, or the results of XPath-based data if the event has XML representation.</summary>
		/// <param name="propertySelector">Selects the property values to return.</param>
		/// <returns>Returns a list of objects.</returns>
		public IList<object> GetPropertyValues(EventLogPropertySelector propertySelector)
		{
			//IL_0007: Expected O, but got I4
			Unity.ThrowStub.ThrowNotSupportedException();
			return (IList<object>)0;
		}

		/// <summary>Gets the XML representation of the event. All of the event properties are represented in the event's XML. The XML conforms to the event schema.</summary>
		/// <returns>Returns a string that contains the XML representation of the event.</returns>
		[SecuritySafeCritical]
		public override string ToXml()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
			return null;
		}
	}
	/// <summary>Allows you to subscribe to incoming events. Each time a desired event is published to an event log, the <see cref="E:System.Diagnostics.Eventing.Reader.EventLogWatcher.EventRecordWritten" /> event is raised, and the method that handles this event will be executed. </summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class EventLogWatcher : IDisposable
	{
		/// <summary>Determines whether this object starts delivering events to the event delegate.</summary>
		/// <returns>Returns <see langword="true" /> when this object can deliver events to the event delegate, and returns <see langword="false" /> when this object has stopped delivery.</returns>
		public bool Enabled
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(bool);
			}
			set
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Allows setting a delegate (event handler method) that gets called every time an event is published that matches the criteria specified in the event query for this object. </summary>
		public event EventHandler<EventRecordWrittenEventArgs> EventRecordWritten
		{
			add
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
			remove
			{
				Unity.ThrowStub.ThrowNotSupportedException();
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogWatcher" /> class by specifying an event query.</summary>
		/// <param name="eventQuery">Specifies a query for the event subscription. When an event is logged that matches the criteria expressed in the query, then the <see cref="E:System.Diagnostics.Eventing.Reader.EventLogWatcher.EventRecordWritten" /> event is raised. </param>
		public EventLogWatcher(EventLogQuery eventQuery)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogWatcher" /> class by specifying an event query and a bookmark that is used as starting position for the query.</summary>
		/// <param name="eventQuery">Specifies a query for the event subscription. When an event is logged that matches the criteria expressed in the query, then the <see cref="E:System.Diagnostics.Eventing.Reader.EventLogWatcher.EventRecordWritten" /> event is raised.</param>
		/// <param name="bookmark">The bookmark (placeholder) used as a starting position in the event log or stream of events. Only events that have been logged after the bookmark event will be returned by the query.</param>
		public EventLogWatcher(EventLogQuery eventQuery, EventBookmark bookmark)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogWatcher" /> class by specifying an event query, a bookmark that is used as starting position for the query, and a Boolean value that determines whether to read the events that already exist in the event log.</summary>
		/// <param name="eventQuery">Specifies a query for the event subscription. When an event is logged that matches the criteria expressed in the query, then the <see cref="E:System.Diagnostics.Eventing.Reader.EventLogWatcher.EventRecordWritten" /> event is raised.</param>
		/// <param name="bookmark">The bookmark (placeholder) used as a starting position in the event log or stream of events. Only events that have been logged after the bookmark event will be returned by the query.</param>
		/// <param name="readExistingEvents">A Boolean value that determines whether to read the events that already exist in the event log. If this value is <see langword="true" />, then the existing events are read and if this value is <see langword="false" />, then the existing events are not read.</param>
		public EventLogWatcher(EventLogQuery eventQuery, EventBookmark bookmark, bool readExistingEvents)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.EventLogWatcher" /> class by specifying the name or path to an event log.</summary>
		/// <param name="path">The path or name of the event log monitor for events. If any event is logged in this event log, then the <see cref="E:System.Diagnostics.Eventing.Reader.EventLogWatcher.EventRecordWritten" /> event is raised.</param>
		public EventLogWatcher(string path)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases all the resources used by this object.</summary>
		public void Dispose()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases the unmanaged resources used by this object, and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///       <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		[SecuritySafeCritical]
		protected virtual void Dispose(bool disposing)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>When the <see cref="E:System.Diagnostics.Eventing.Reader.EventLogWatcher.EventRecordWritten" /> event is raised, an instance of this object is passed to the delegate method that handles the event. This object contains the event that was published to the event log or the exception that occurred when the event subscription failed. </summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventRecordWrittenEventArgs : EventArgs
	{
		/// <summary>Gets the exception that occurred when the event subscription failed. The exception has a description of why the subscription failed.</summary>
		/// <returns>Returns an <see cref="T:System.Exception" /> object.</returns>
		public Exception EventException
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the event record that is published to the event log. This event matches the criteria from the query specified in the event subscription.</summary>
		/// <returns>Returns a <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" /> object.</returns>
		public EventRecord EventRecord
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		internal EventRecordWrittenEventArgs()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Contains the metadata (properties and settings) for an event that is defined in an event provider. </summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventMetadata
	{
		/// <summary>Gets the description template associated with the event using the current thread locale for the description language.</summary>
		/// <returns>Returns a string that contains the description template associated with the event.</returns>
		public string Description
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the identifier of the event that is defined in the event provider.</summary>
		/// <returns>Returns a <see langword="long" /> value that is the event identifier.</returns>
		public long Id
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(long);
			}
		}

		/// <summary>Gets the keywords associated with the event that is defined in the even provider.</summary>
		/// <returns>Returns an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventKeyword" /> objects.</returns>
		public IEnumerable<EventKeyword> Keywords
		{
			get
			{
				//IL_0007: Expected O, but got I4
				Unity.ThrowStub.ThrowNotSupportedException();
				return (IEnumerable<EventKeyword>)0;
			}
		}

		/// <summary>Gets the level associated with the event that is defined in the event provider. The level defines the severity of the event.</summary>
		/// <returns>Returns an <see cref="T:System.Diagnostics.Eventing.Reader.EventLevel" /> object.</returns>
		public EventLevel Level
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets a link to the event log that receives this event when the provider publishes this event.</summary>
		/// <returns>Returns a <see cref="T:System.Diagnostics.Eventing.Reader.EventLogLink" /> object.</returns>
		public EventLogLink LogLink
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the opcode associated with this event that is defined by an event provider. The opcode defines a numeric value that identifies the activity or a point within an activity that the application was performing when it raised the event.</summary>
		/// <returns>Returns a <see cref="T:System.Diagnostics.Eventing.Reader.EventOpcode" /> object.</returns>
		public EventOpcode Opcode
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the task associated with the event. A task identifies a portion of an application or a component that publishes an event. </summary>
		/// <returns>Returns a <see cref="T:System.Diagnostics.Eventing.Reader.EventTask" /> object.</returns>
		public EventTask Task
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the template string for the event. Templates are used to describe data that is used by a provider when an event is published. Templates optionally specify XML that provides the structure of an event. The XML allows values that the event publisher provides to be inserted during the rendering of an event.</summary>
		/// <returns>Returns a string that contains the template for the event.</returns>
		public string Template
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the version of the event that qualifies the event identifier.</summary>
		/// <returns>Returns a byte value.</returns>
		public byte Version
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(byte);
			}
		}

		internal EventMetadata()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Contains an event opcode that is defined in an event provider. An opcode defines a numeric value that identifies the activity or a point within an activity that the application was performing when it raised the event.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventOpcode
	{
		/// <summary>Gets the localized name for an event opcode.</summary>
		/// <returns>Returns a string that contains the localized name for an event opcode.</returns>
		public string DisplayName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the non-localized name for an event opcode.</summary>
		/// <returns>Returns a string that contains the non-localized name for an event opcode.</returns>
		public string Name
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the numeric value associated with the event opcode.</summary>
		/// <returns>Returns an integer value.</returns>
		public int Value
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(int);
			}
		}

		internal EventOpcode()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Contains an event task that is defined in an event provider. The task identifies a portion of an application or a component that publishes an event. A task is a 16-bit value with 16 top values reserved.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public sealed class EventTask
	{
		/// <summary>Gets the localized name for the event task.</summary>
		/// <returns>Returns a string that contains the localized name for the event task.</returns>
		public string DisplayName
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the event globally unique identifier (GUID) associated with the task. </summary>
		/// <returns>Returns a GUID value.</returns>
		public Guid EventGuid
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(Guid);
			}
		}

		/// <summary>Gets the non-localized name of the event task.</summary>
		/// <returns>Returns a string that contains the non-localized name of the event task.</returns>
		public string Name
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the numeric value associated with the task.</summary>
		/// <returns>Returns an integer value.</returns>
		public int Value
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(int);
			}
		}

		internal EventTask()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Contains static information about an event provider, such as the name and id of the provider, and the collection of events defined in the provider.</summary>
	[HostProtection(SecurityAction.LinkDemand, MayLeakOnAbort = true)]
	public class ProviderMetadata : IDisposable
	{
		/// <summary>Gets the localized name of the event provider.</summary>
		/// <returns>Returns a string that contains the localized name of the event provider.</returns>
		public string DisplayName
		{
			[SecurityCritical]
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventMetadata" /> objects, each of which represents an event that is defined in the provider.</summary>
		/// <returns>Returns an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventMetadata" /> objects.</returns>
		public IEnumerable<EventMetadata> Events
		{
			[SecurityCritical]
			get
			{
				//IL_0007: Expected O, but got I4
				Unity.ThrowStub.ThrowNotSupportedException();
				return (IEnumerable<EventMetadata>)0;
			}
		}

		/// <summary>Gets the base of the URL used to form help requests for the events in this event provider.</summary>
		/// <returns>Returns a <see cref="T:System.Uri" /> value.</returns>
		public Uri HelpLink
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the globally unique identifier (GUID) for the event provider.</summary>
		/// <returns>Returns the GUID value for the event provider.</returns>
		public Guid Id
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return default(Guid);
			}
		}

		/// <summary>Gets an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventKeyword" /> objects, each of which represent an event keyword that is defined in the event provider.</summary>
		/// <returns>Returns an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventKeyword" /> objects.</returns>
		public IList<EventKeyword> Keywords
		{
			get
			{
				//IL_0007: Expected O, but got I4
				Unity.ThrowStub.ThrowNotSupportedException();
				return (IList<EventKeyword>)0;
			}
		}

		/// <summary>Gets an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventLevel" /> objects, each of which represent a level that is defined in the event provider.</summary>
		/// <returns>Returns an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventLevel" /> objects.</returns>
		public IList<EventLevel> Levels
		{
			get
			{
				//IL_0007: Expected O, but got I4
				Unity.ThrowStub.ThrowNotSupportedException();
				return (IList<EventLevel>)0;
			}
		}

		/// <summary>Gets an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventLogLink" /> objects, each of which represent a link to an event log that is used by the event provider.</summary>
		/// <returns>Returns an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventLogLink" /> objects.</returns>
		public IList<EventLogLink> LogLinks
		{
			[SecurityCritical]
			get
			{
				//IL_0007: Expected O, but got I4
				Unity.ThrowStub.ThrowNotSupportedException();
				return (IList<EventLogLink>)0;
			}
		}

		/// <summary>Gets the path of the file that contains the message table resource that has the strings associated with the provider metadata.</summary>
		/// <returns>Returns a string that contains the path of the provider message file.</returns>
		public string MessageFilePath
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the unique name of the event provider.</summary>
		/// <returns>Returns a string that contains the unique name of the event provider.</returns>
		public string Name
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventOpcode" /> objects, each of which represent an opcode that is defined in the event provider.</summary>
		/// <returns>Returns an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventOpcode" /> objects.</returns>
		public IList<EventOpcode> Opcodes
		{
			get
			{
				//IL_0007: Expected O, but got I4
				Unity.ThrowStub.ThrowNotSupportedException();
				return (IList<EventOpcode>)0;
			}
		}

		/// <summary>Gets the path of the file that contains the message table resource that has the strings used for parameter substitutions in event descriptions.</summary>
		/// <returns>Returns a string that contains the path of the file that contains the message table resource that has the strings used for parameter substitutions in event descriptions.</returns>
		public string ParameterFilePath
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets the path to the file that contains the metadata associated with the provider.</summary>
		/// <returns>Returns a string that contains the path to the file that contains the metadata associated with the provider.</returns>
		public string ResourceFilePath
		{
			get
			{
				Unity.ThrowStub.ThrowNotSupportedException();
				return null;
			}
		}

		/// <summary>Gets an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventTask" /> objects, each of which represent a task that is defined in the event provider.</summary>
		/// <returns>Returns an enumerable collection of <see cref="T:System.Diagnostics.Eventing.Reader.EventTask" /> objects.</returns>
		public IList<EventTask> Tasks
		{
			get
			{
				//IL_0007: Expected O, but got I4
				Unity.ThrowStub.ThrowNotSupportedException();
				return (IList<EventTask>)0;
			}
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.ProviderMetadata" /> class by specifying the name of the provider that you want to retrieve information about.</summary>
		/// <param name="providerName">The name of the event provider that you want to retrieve information about.</param>
		public ProviderMetadata(string providerName)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Initializes a new instance of the <see cref="T:System.Diagnostics.Eventing.Reader.ProviderMetadata" /> class by specifying the name of the provider that you want to retrieve information about, the event log service that the provider is registered with, and the language that you want to return the information in.</summary>
		/// <param name="providerName">The name of the event provider that you want to retrieve information about.</param>
		/// <param name="session">The <see cref="T:System.Diagnostics.Eventing.Reader.EventLogSession" /> object that specifies whether to get the provider information from a provider on the local computer or a provider on a remote computer.</param>
		/// <param name="targetCultureInfo">The culture that specifies the language that the information should be returned in.</param>
		public ProviderMetadata(string providerName, EventLogSession session, CultureInfo targetCultureInfo)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases all the resources used by this object.</summary>
		public void Dispose()
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}

		/// <summary>Releases the unmanaged resources used by this object, and optionally releases the managed resources.</summary>
		/// <param name="disposing">
		///       <see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
		[SecuritySafeCritical]
		protected virtual void Dispose(bool disposing)
		{
			Unity.ThrowStub.ThrowNotSupportedException();
		}
	}
	/// <summary>Defines the standard keywords that are attached to events by the event provider. For more information about keywords, see <see cref="T:System.Diagnostics.Eventing.Reader.EventKeyword" />.</summary>
	[Flags]
	public enum StandardEventKeywords : long
	{
		/// <summary>Attached to all failed security audit events. This keyword should only be used for events in the Security log.</summary>
		AuditFailure = 0x10000000000000L,
		/// <summary>Attached to all successful security audit events. This keyword should only be used for events in the Security log.</summary>
		AuditSuccess = 0x20000000000000L,
		/// <summary>Attached to transfer events where the related Activity ID (Correlation ID) is a computed value and is not guaranteed to be unique (not a real GUID).</summary>
		[Obsolete("Incorrect value: use CorrelationHint2 instead", false)]
		CorrelationHint = 0x10000000000000L,
		/// <summary>Attached to transfer events where the related Activity ID (Correlation ID) is a computed value and is not guaranteed to be unique (not a real GUID).</summary>
		CorrelationHint2 = 0x40000000000000L,
		/// <summary>Attached to events which are raised using the RaiseEvent function.</summary>
		EventLogClassic = 0x80000000000000L,
		/// <summary>This value indicates that no filtering on keyword is performed when the event is published.</summary>
		None = 0L,
		/// <summary>Attached to all response time events. </summary>
		ResponseTime = 0x1000000000000L,
		/// <summary>Attached to all Service Quality Mechanism (SQM) events.</summary>
		Sqm = 0x8000000000000L,
		/// <summary>Attached to all Windows Diagnostic Infrastructure (WDI) context events.</summary>
		WdiContext = 0x2000000000000L,
		/// <summary>Attached to all Windows Diagnostic Infrastructure (WDI) diagnostic events.</summary>
		WdiDiagnostic = 0x4000000000000L
	}
	/// <summary>Defines the standard event levels that are used in the Event Log service. The level defines the severity of the event. Custom event levels can be defined beyond these standard levels. For more information about levels, see <see cref="T:System.Diagnostics.Eventing.Reader.EventLevel" />.</summary>
	public enum StandardEventLevel
	{
		/// <summary>This level corresponds to critical errors, which is a serious error that has caused a major failure. </summary>
		Critical = 1,
		/// <summary>This level corresponds to normal errors that signify a problem. </summary>
		Error = 2,
		/// <summary>This level corresponds to informational events or messages that are not errors. These events can help trace the progress or state of an application.</summary>
		Informational = 4,
		/// <summary>This value indicates that not filtering on the level is done during the event publishing.</summary>
		LogAlways = 0,
		/// <summary>This level corresponds to lengthy events or messages. </summary>
		Verbose = 5,
		/// <summary>This level corresponds to warning events. For example, an event that gets published because a disk is nearing full capacity is a warning event.</summary>
		Warning = 3
	}
	/// <summary>Defines the standard opcodes that are attached to events by the event provider. For more information about opcodes, see <see cref="T:System.Diagnostics.Eventing.Reader.EventOpcode" />.</summary>
	public enum StandardEventOpcode
	{
		/// <summary>An event with this opcode is a trace collection start event.</summary>
		DataCollectionStart = 3,
		/// <summary>An event with this opcode is a trace collection stop event.</summary>
		DataCollectionStop = 4,
		/// <summary>An event with this opcode is an extension event.</summary>
		Extension = 5,
		/// <summary>An event with this opcode is an informational event.</summary>
		Info = 0,
		/// <summary>An event with this opcode is published when one activity in an application receives data.</summary>
		Receive = 240,
		/// <summary>An event with this opcode is published after an activity in an application replies to an event.</summary>
		Reply = 6,
		/// <summary>An event with this opcode is published after an activity in an application resumes from a suspended state. The event should follow an event with the Suspend opcode.</summary>
		Resume = 7,
		/// <summary>An event with this opcode is published when one activity in an application transfers data or system resources to another activity. </summary>
		Send = 9,
		/// <summary>An event with this opcode is published when an application starts a new transaction or activity. This can be embedded into another transaction or activity when multiple events with the Start opcode follow each other without an event with a Stop opcode.</summary>
		Start = 1,
		/// <summary>An event with this opcode is published when an activity or a transaction in an application ends. The event corresponds to the last unpaired event with a Start opcode.</summary>
		Stop = 2,
		/// <summary>An event with this opcode is published when an activity in an application is suspended. </summary>
		Suspend = 8
	}
	/// <summary>Defines the standard tasks that are attached to events by the event provider. For more information about tasks, see <see cref="T:System.Diagnostics.Eventing.Reader.EventTask" />.</summary>
	public enum StandardEventTask
	{
		/// <summary>No task is used to identify a portion of an application that publishes an event.</summary>
		None
	}
}
namespace Unity
{
	internal sealed class ThrowStub : ObjectDisposedException
	{
		public static void ThrowNotSupportedException()
		{
			throw new PlatformNotSupportedException();
		}
	}
}
