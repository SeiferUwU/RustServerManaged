using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.IO;
using System.IO.Hashing;
using System.Linq;
using System.Net;
using System.Net.Http.Headers;
using System.Reflection;
using System.Resources;
using System.Runtime.CompilerServices;
using System.Runtime.ExceptionServices;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;
using System.Security;
using System.Security.Authentication;
using System.Security.Cryptography;
using System.Security.Permissions;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using System.Web;
using System.Xml;
using System.Xml.Linq;
using Azure;
using Azure.Core;
using Azure.Core.Cryptography;
using Azure.Core.Extensions;
using Azure.Core.Pipeline;
using Azure.Storage;
using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;
using Azure.Storage.Blobs.Specialized;
using Azure.Storage.Cryptography;
using Azure.Storage.Cryptography.Models;
using Azure.Storage.Internal.Avro;
using Azure.Storage.Sas;
using Azure.Storage.Shared;
using Azure.Storage.Shared.AesGcm;
using Microsoft.CodeAnalysis;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: InternalsVisibleTo("Azure.Storage.Blobs.Tests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100d15ddcb29688295338af4b7686603fe614abd555e09efba8fb88ee09e1f7b1ccaeed2e8f823fa9eef3fdd60217fc012ea67d2479751a0b8c087a4185541b851bd8b16f8d91b840e51b1cb0ba6fe647997e57429265e85ef62d565db50a69ae1647d54d7bd855e4db3d8a91510e5bcbd0edfbbecaa20a7bd9ae74593daa7b11b4")]
[assembly: InternalsVisibleTo("Azure.Storage.DataMovement.Blobs.Tests, PublicKey=0024000004800000940000000602000000240000525341310004000001000100d15ddcb29688295338af4b7686603fe614abd555e09efba8fb88ee09e1f7b1ccaeed2e8f823fa9eef3fdd60217fc012ea67d2479751a0b8c087a4185541b851bd8b16f8d91b840e51b1cb0ba6fe647997e57429265e85ef62d565db50a69ae1647d54d7bd855e4db3d8a91510e5bcbd0edfbbecaa20a7bd9ae74593daa7b11b4")]
[assembly: InternalsVisibleTo("DynamicProxyGenAssembly2, PublicKey=0024000004800000940000000602000000240000525341310004000001000100c547cac37abd99c8db225ef2f6c8a3602f3b3606cc9891605d02baa56104f4cfc0734aa39b93bf7852f7d9266654753cc297e7d2edfe0bac1cdcf9f717241550e0a7b191195b7667bb4f64bcb8e2121380fd1d9d46ad2d92d2d15605093924cceaf74c4861eff62abf69b9291ed0a340e113be11e6a7d3113e92484cf7045cc7")]
[assembly: AzureResourceProviderNamespace("Microsoft.Storage")]
[assembly: CodeGenSuppressType("QueryRequestQueryType")]
[assembly: TargetFramework(".NETStandard,Version=v2.0", FrameworkDisplayName = ".NET Standard 2.0")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyConfiguration("Release")]
[assembly: AssemblyCopyright("Â© Microsoft Corporation. All rights reserved.")]
[assembly: AssemblyDescription("\r\n      This client library enables working with the Microsoft Azure Storage Blob service for storing binary and text data.\r\n      For this release see notes - https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/storage/Azure.Storage.Blobs/README.md and https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/storage/Azure.Storage.Blobs/CHANGELOG.md\r\n      in addition to the breaking changes https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/storage/Azure.Storage.Blobs/BreakingChanges.txt\r\n      Microsoft Azure Storage quickstarts and tutorials - https://docs.microsoft.com/en-us/azure/storage/\r\n      Microsoft Azure Storage REST API Reference - https://docs.microsoft.com/en-us/rest/api/storageservices/\r\n      REST API Reference for Blob Service - https://docs.microsoft.com/en-us/rest/api/storageservices/blob-service-rest-api\r\n    ")]
[assembly: AssemblyFileVersion("12.1900.123.56305")]
[assembly: AssemblyInformationalVersion("12.19.1+675cf1fc091d02e385f4f8455beab2e9a40adc58")]
[assembly: AssemblyProduct("Azure .NET SDK")]
[assembly: AssemblyTitle("Microsoft Azure.Storage.Blobs client library")]
[assembly: AssemblyMetadata("RepositoryUrl", "https://github.com/Azure/azure-sdk-for-net")]
[assembly: NeutralResourcesLanguage("en-US")]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("12.19.1.0")]
[module: UnverifiableCode]
[module: RefSafetyRules(11)]
namespace Microsoft.CodeAnalysis
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class EmbeddedAttribute : Attribute
	{
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class IsReadOnlyAttribute : Attribute
	{
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Parameter | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter, AllowMultiple = false, Inherited = false)]
	internal sealed class NullableAttribute : Attribute
	{
		public readonly byte[] NullableFlags;

		public NullableAttribute(byte P_0)
		{
			NullableFlags = new byte[1] { P_0 };
		}

		public NullableAttribute(byte[] P_0)
		{
			NullableFlags = P_0;
		}
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Interface | AttributeTargets.Delegate, AllowMultiple = false, Inherited = false)]
	internal sealed class NullableContextAttribute : Attribute
	{
		public readonly byte Flag;

		public NullableContextAttribute(byte P_0)
		{
			Flag = P_0;
		}
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	[AttributeUsage(AttributeTargets.Module, AllowMultiple = false, Inherited = false)]
	internal sealed class RefSafetyRulesAttribute : Attribute
	{
		public readonly int Version;

		public RefSafetyRulesAttribute(int P_0)
		{
			Version = P_0;
		}
	}
}
namespace System.Diagnostics.CodeAnalysis
{
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Constructor | AttributeTargets.Method, Inherited = false)]
	internal sealed class RequiresDynamicCodeAttribute : Attribute
	{
		public string Message { get; }

		public string? Url { get; set; }

		public RequiresDynamicCodeAttribute(string message)
		{
			Message = message;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Constructor | AttributeTargets.Method, Inherited = false)]
	internal sealed class RequiresUnreferencedCodeAttribute : Attribute
	{
		public string Message { get; }

		public string? Url { get; set; }

		public RequiresUnreferencedCodeAttribute(string message)
		{
			Message = message;
		}
	}
	[AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)]
	internal sealed class UnconditionalSuppressMessageAttribute : Attribute
	{
		public string Category { get; }

		public string CheckId { get; }

		public string? Scope { get; set; }

		public string? Target { get; set; }

		public string? MessageId { get; set; }

		public string? Justification { get; set; }

		public UnconditionalSuppressMessageAttribute(string category, string checkId)
		{
			Category = category;
			CheckId = checkId;
		}
	}
	[AttributeUsage(AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Field, AllowMultiple = true, Inherited = false)]
	internal sealed class DynamicDependencyAttribute : Attribute
	{
		public string? MemberSignature { get; }

		public DynamicallyAccessedMemberTypes MemberTypes { get; }

		public Type? Type { get; }

		public string? TypeName { get; }

		public string? AssemblyName { get; }

		public string? Condition { get; set; }

		public DynamicDependencyAttribute(string memberSignature)
		{
			MemberSignature = memberSignature;
		}

		public DynamicDependencyAttribute(string memberSignature, Type type)
		{
			MemberSignature = memberSignature;
			Type = type;
		}

		public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName)
		{
			MemberSignature = memberSignature;
			TypeName = typeName;
			AssemblyName = assemblyName;
		}

		public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type)
		{
			MemberTypes = memberTypes;
			Type = type;
		}

		public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName)
		{
			MemberTypes = memberTypes;
			TypeName = typeName;
			AssemblyName = assemblyName;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Interface | AttributeTargets.Parameter | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter, Inherited = false)]
	internal sealed class DynamicallyAccessedMembersAttribute : Attribute
	{
		public DynamicallyAccessedMemberTypes MemberTypes { get; }

		public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes)
		{
			MemberTypes = memberTypes;
		}
	}
	[Flags]
	internal enum DynamicallyAccessedMemberTypes
	{
		None = 0,
		PublicParameterlessConstructor = 1,
		PublicConstructors = 3,
		NonPublicConstructors = 4,
		PublicMethods = 8,
		NonPublicMethods = 0x10,
		PublicFields = 0x20,
		NonPublicFields = 0x40,
		PublicNestedTypes = 0x80,
		NonPublicNestedTypes = 0x100,
		PublicProperties = 0x200,
		NonPublicProperties = 0x400,
		PublicEvents = 0x800,
		NonPublicEvents = 0x1000,
		Interfaces = 0x2000,
		All = -1
	}
}
namespace Autorest.CSharp.Core
{
	internal static class GeneratorPageableHelpers
	{
		private static readonly byte[] DefaultItemPropertyName = Encoding.UTF8.GetBytes("value");

		private static readonly byte[] DefaultNextLinkPropertyName = Encoding.UTF8.GetBytes("nextLink");

		public static AsyncPageable<T> CreateAsyncPageable<T>(Func<int?, HttpMessage>? createFirstPageRequest, Func<int?, string, HttpMessage>? createNextPageRequest, Func<Response, (List<T>? Values, string? NextLink)> responseParser, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext? requestContext = null) where T : notnull
		{
			return new Azure.Core.PageableHelpers.AsyncPageableWrapper<T>(new Azure.Core.PageableHelpers.PageableImplementation<T>(createFirstPageRequest, createNextPageRequest, responseParser, pipeline, clientDiagnostics, scopeName, null, requestContext));
		}

		public static AsyncPageable<T> CreateAsyncPageable<T>(Func<int?, HttpMessage>? createFirstPageRequest, Func<int?, string, HttpMessage>? createNextPageRequest, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, CancellationToken cancellationToken) where T : notnull
		{
			return new Azure.Core.PageableHelpers.AsyncPageableWrapper<T>(new Azure.Core.PageableHelpers.PageableImplementation<T>(null, createFirstPageRequest, createNextPageRequest, valueFactory, pipeline, clientDiagnostics, scopeName, itemPropertyName, nextLinkPropertyName, null, cancellationToken, null));
		}

		public static AsyncPageable<T> CreateAsyncPageable<T>(Func<int?, HttpMessage>? createFirstPageRequest, Func<int?, string, HttpMessage>? createNextPageRequest, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, RequestContext? requestContext = null) where T : notnull
		{
			return new Azure.Core.PageableHelpers.AsyncPageableWrapper<T>(new Azure.Core.PageableHelpers.PageableImplementation<T>(null, createFirstPageRequest, createNextPageRequest, valueFactory, pipeline, clientDiagnostics, scopeName, itemPropertyName, nextLinkPropertyName, null, requestContext?.CancellationToken, requestContext?.ErrorOptions));
		}

		public static AsyncPageable<T> CreateAsyncPageable<T>(Response initialResponse, Func<int?, string, HttpMessage>? createNextPageRequest, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, CancellationToken cancellationToken) where T : notnull
		{
			return new Azure.Core.PageableHelpers.AsyncPageableWrapper<T>(new Azure.Core.PageableHelpers.PageableImplementation<T>(initialResponse, null, createNextPageRequest, valueFactory, pipeline, clientDiagnostics, scopeName, itemPropertyName, nextLinkPropertyName, null, cancellationToken, null));
		}

		public static Pageable<T> CreatePageable<T>(Func<int?, HttpMessage>? createFirstPageRequest, Func<int?, string, HttpMessage>? createNextPageRequest, Func<Response, (List<T>? Values, string? NextLink)> responseParser, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext? requestContext = null) where T : notnull
		{
			return new Azure.Core.PageableHelpers.PageableWrapper<T>(new Azure.Core.PageableHelpers.PageableImplementation<T>(createFirstPageRequest, createNextPageRequest, responseParser, pipeline, clientDiagnostics, scopeName, null, requestContext));
		}

		public static Pageable<T> CreatePageable<T>(Func<int?, HttpMessage>? createFirstPageRequest, Func<int?, string, HttpMessage>? createNextPageRequest, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, CancellationToken cancellationToken) where T : notnull
		{
			return new Azure.Core.PageableHelpers.PageableWrapper<T>(new Azure.Core.PageableHelpers.PageableImplementation<T>(null, createFirstPageRequest, createNextPageRequest, valueFactory, pipeline, clientDiagnostics, scopeName, itemPropertyName, nextLinkPropertyName, null, cancellationToken, null));
		}

		public static Pageable<T> CreatePageable<T>(Func<int?, HttpMessage>? createFirstPageRequest, Func<int?, string, HttpMessage>? createNextPageRequest, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, RequestContext? requestContext = null) where T : notnull
		{
			return new Azure.Core.PageableHelpers.PageableWrapper<T>(new Azure.Core.PageableHelpers.PageableImplementation<T>(null, createFirstPageRequest, createNextPageRequest, valueFactory, pipeline, clientDiagnostics, scopeName, itemPropertyName, nextLinkPropertyName, null, requestContext?.CancellationToken, requestContext?.ErrorOptions));
		}

		public static Pageable<T> CreatePageable<T>(Response initialResponse, Func<int?, string, HttpMessage>? createNextPageRequest, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, CancellationToken cancellationToken) where T : notnull
		{
			return new Azure.Core.PageableHelpers.PageableWrapper<T>(new Azure.Core.PageableHelpers.PageableImplementation<T>(initialResponse, null, createNextPageRequest, valueFactory, pipeline, clientDiagnostics, scopeName, itemPropertyName, nextLinkPropertyName, null, cancellationToken, null));
		}

		public static async ValueTask<Operation<AsyncPageable<T>>> CreateAsyncPageable<T>(WaitUntil waitUntil, HttpMessage message, Func<int?, string, HttpMessage>? createNextPageMethod, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Azure.Core.OperationFinalStateVia finalStateVia, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, RequestContext? requestContext = null) where T : notnull
		{
			return await Azure.Core.PageableHelpers.CreateAsyncPageable(waitUntil, message, createNextPageMethod, valueFactory, clientDiagnostics, pipeline, finalStateVia, scopeName, itemPropertyName, nextLinkPropertyName, requestContext).ConfigureAwait(continueOnCapturedContext: false);
		}

		public static Operation<Pageable<T>> CreatePageable<T>(WaitUntil waitUntil, HttpMessage message, Func<int?, string, HttpMessage>? createNextPageMethod, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Azure.Core.OperationFinalStateVia finalStateVia, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, RequestContext? requestContext = null) where T : notnull
		{
			return Azure.Core.PageableHelpers.CreatePageable(waitUntil, message, createNextPageMethod, valueFactory, clientDiagnostics, pipeline, finalStateVia, scopeName, itemPropertyName, nextLinkPropertyName, requestContext);
		}

		public static Pageable<T> CreateEnumerable<T>(Func<int?, Page<T>> firstPageFunc, Func<string?, int?, Page<T>>? nextPageFunc, int? pageSize = null) where T : notnull
		{
			return Azure.Core.PageableHelpers.CreateEnumerable(firstPageFunc, nextPageFunc, pageSize);
		}

		public static AsyncPageable<T> CreateAsyncEnumerable<T>(Func<int?, Task<Page<T>>> firstPageFunc, Func<string?, int?, Task<Page<T>>>? nextPageFunc, int? pageSize = null) where T : notnull
		{
			return Azure.Core.PageableHelpers.CreateAsyncEnumerable(firstPageFunc, nextPageFunc, pageSize);
		}
	}
}
namespace Microsoft.Extensions.Azure
{
	public static class BlobClientBuilderExtensions
	{
		public static IAzureClientBuilder<BlobServiceClient, BlobClientOptions> AddBlobServiceClient<TBuilder>(this TBuilder builder, string connectionString) where TBuilder : IAzureClientFactoryBuilder
		{
			return builder.RegisterClientFactory((BlobClientOptions options) => new BlobServiceClient(connectionString, options));
		}

		public static IAzureClientBuilder<BlobServiceClient, BlobClientOptions> AddBlobServiceClient<TBuilder>(this TBuilder builder, Uri serviceUri) where TBuilder : IAzureClientFactoryBuilderWithCredential
		{
			return builder.RegisterClientFactory((BlobClientOptions options, TokenCredential token) => (token == null) ? new BlobServiceClient(serviceUri, options) : new BlobServiceClient(serviceUri, token, options), requiresCredential: false);
		}

		public static IAzureClientBuilder<BlobServiceClient, BlobClientOptions> AddBlobServiceClient<TBuilder>(this TBuilder builder, Uri serviceUri, StorageSharedKeyCredential sharedKeyCredential) where TBuilder : IAzureClientFactoryBuilder
		{
			return builder.RegisterClientFactory((BlobClientOptions options) => new BlobServiceClient(serviceUri, sharedKeyCredential, options));
		}

		public static IAzureClientBuilder<BlobServiceClient, BlobClientOptions> AddBlobServiceClient<TBuilder, TConfiguration>(this TBuilder builder, TConfiguration configuration) where TBuilder : IAzureClientFactoryBuilderWithConfiguration<TConfiguration>
		{
			return builder.RegisterClientFactory<BlobServiceClient, BlobClientOptions>(configuration);
		}
	}
}
namespace Azure
{
	internal class NoBodyResponse<T> : Response<T>
	{
		private class ResponseBodyNotFoundException : Exception
		{
			public int Status { get; }

			public ResponseBodyNotFoundException(int status, string message)
				: base(message)
			{
				Status = status;
			}
		}

		private readonly Response _response;

		public override bool HasValue => false;

		public override T Value
		{
			get
			{
				throw new ResponseBodyNotFoundException(_response.Status, _response.ReasonPhrase);
			}
		}

		public NoBodyResponse(Response response)
		{
			_response = response;
		}

		public override Response GetRawResponse()
		{
			return _response;
		}

		public override string ToString()
		{
			return $"Status: {GetRawResponse().Status}, Service returned no content";
		}
	}
}
namespace Azure.Core
{
	internal static class AuthorizationChallengeParser
	{
		public static string? GetChallengeParameterFromResponse(Response response, string challengeScheme, string challengeParameter)
		{
			if (response.Status != 401 || !response.Headers.TryGetValue(HttpHeader.Names.WwwAuthenticate, out string value))
			{
				return null;
			}
			ReadOnlySpan<char> other = MemoryExtensions.AsSpan(challengeScheme);
			ReadOnlySpan<char> other2 = MemoryExtensions.AsSpan(challengeParameter);
			ReadOnlySpan<char> headerValue = MemoryExtensions.AsSpan(value);
			ReadOnlySpan<char> challengeKey;
			while (TryGetNextChallenge(ref headerValue, out challengeKey))
			{
				ReadOnlySpan<char> paramKey;
				ReadOnlySpan<char> paramValue;
				while (TryGetNextParameter(ref headerValue, out paramKey, out paramValue))
				{
					if (MemoryExtensions.Equals(challengeKey, other, StringComparison.OrdinalIgnoreCase) && MemoryExtensions.Equals(paramKey, other2, StringComparison.OrdinalIgnoreCase))
					{
						return paramValue.ToString();
					}
				}
			}
			return null;
		}

		internal static bool TryGetNextChallenge(ref ReadOnlySpan<char> headerValue, out ReadOnlySpan<char> challengeKey)
		{
			challengeKey = default(ReadOnlySpan<char>);
			headerValue = headerValue.TrimStart(' ');
			int num = headerValue.IndexOf(' ');
			if (num < 0)
			{
				return false;
			}
			challengeKey = headerValue.Slice(0, num);
			headerValue = headerValue.Slice(num + 1);
			return true;
		}

		internal static bool TryGetNextParameter(ref ReadOnlySpan<char> headerValue, out ReadOnlySpan<char> paramKey, out ReadOnlySpan<char> paramValue, char separator = '=')
		{
			paramKey = default(ReadOnlySpan<char>);
			paramValue = default(ReadOnlySpan<char>);
			ReadOnlySpan<char> readOnlySpan = MemoryExtensions.AsSpan(" ,");
			headerValue = headerValue.TrimStart(readOnlySpan);
			int num = headerValue.IndexOf(' ');
			int num2 = headerValue.IndexOf(separator);
			if (num < num2 && num != -1)
			{
				return false;
			}
			if (num2 < 0)
			{
				return false;
			}
			paramKey = headerValue.Slice(0, num2).Trim();
			headerValue = headerValue.Slice(num2 + 1);
			int num3 = headerValue.IndexOf('"');
			headerValue = headerValue.Slice(num3 + 1);
			if (num3 >= 0)
			{
				paramValue = headerValue.Slice(0, headerValue.IndexOf('"'));
			}
			else
			{
				int num4 = headerValue.IndexOfAny(readOnlySpan);
				if (num4 >= 0)
				{
					paramValue = headerValue.Slice(0, num4);
				}
				else
				{
					paramValue = headerValue;
				}
			}
			if (headerValue != paramValue)
			{
				headerValue = headerValue.Slice(paramValue.Length + 1);
			}
			return true;
		}
	}
	[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = false)]
	internal class AzureResourceProviderNamespaceAttribute : Attribute
	{
		public string ResourceProviderNamespace { get; }

		public AzureResourceProviderNamespaceAttribute(string resourceProviderNamespace)
		{
			ResourceProviderNamespace = resourceProviderNamespace;
		}
	}
	internal class AzureSasCredentialSynchronousPolicy : HttpPipelineSynchronousPolicy
	{
		private class AzureSasSignatureHistory
		{
		}

		private readonly AzureSasCredential _credential;

		public AzureSasCredentialSynchronousPolicy(AzureSasCredential credential)
		{
			Azure.Core.Argument.AssertNotNull(credential, "credential");
			_credential = credential;
		}

		public override void OnSendingRequest(HttpMessage message)
		{
			string query = message.Request.Uri.Query;
			string text = _credential.Signature;
			if (text.StartsWith("?", StringComparison.InvariantCulture))
			{
				text = text.Substring(1);
			}
			if (!query.Contains(text))
			{
				query = ((!message.TryGetProperty(typeof(AzureSasSignatureHistory), out object value) || !(value is string text2) || !query.Contains(text2)) ? (string.IsNullOrEmpty(query) ? ("?" + text) : (query + "&" + text)) : query.Replace(text2, text));
				message.Request.Uri.Query = query;
				message.SetProperty(typeof(AzureSasSignatureHistory), text);
				base.OnSendingRequest(message);
			}
		}
	}
	[AttributeUsage(AttributeTargets.Method)]
	internal class CallerShouldAuditAttribute : Attribute
	{
		public string? Reason { get; set; }
	}
	internal static class CancellationHelper
	{
		private static readonly string s_cancellationMessage = new OperationCanceledException().Message;

		internal static bool ShouldWrapInOperationCanceledException(Exception exception, CancellationToken cancellationToken)
		{
			if (!(exception is OperationCanceledException))
			{
				return cancellationToken.IsCancellationRequested;
			}
			return false;
		}

		internal static Exception CreateOperationCanceledException(Exception? innerException, CancellationToken cancellationToken, string? message = null)
		{
			return new TaskCanceledException(message ?? s_cancellationMessage, innerException);
		}

		private static void ThrowOperationCanceledException(Exception? innerException, CancellationToken cancellationToken)
		{
			throw CreateOperationCanceledException(innerException, cancellationToken);
		}

		internal static void ThrowIfCancellationRequested(CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				ThrowOperationCanceledException(null, cancellationToken);
			}
		}
	}
	internal sealed class ArrayBufferWriter<T> : IBufferWriter<T>
	{
		private T[] _buffer;

		private const int DefaultInitialBufferSize = 256;

		public ReadOnlyMemory<T> WrittenMemory => MemoryExtensions.AsMemory(_buffer, 0, WrittenCount);

		public ReadOnlySpan<T> WrittenSpan => MemoryExtensions.AsSpan(_buffer, 0, WrittenCount);

		public int WrittenCount { get; private set; }

		public int Capacity => _buffer.Length;

		public int FreeCapacity => _buffer.Length - WrittenCount;

		public ArrayBufferWriter()
		{
			_buffer = Array.Empty<T>();
			WrittenCount = 0;
		}

		public ArrayBufferWriter(int initialCapacity)
		{
			if (initialCapacity <= 0)
			{
				throw new ArgumentException("initialCapacity");
			}
			_buffer = new T[initialCapacity];
			WrittenCount = 0;
		}

		public void Clear()
		{
			MemoryExtensions.AsSpan(_buffer, 0, WrittenCount).Clear();
			WrittenCount = 0;
		}

		public void Advance(int count)
		{
			if (count < 0)
			{
				throw new ArgumentException("count");
			}
			if (WrittenCount > _buffer.Length - count)
			{
				ThrowInvalidOperationException_AdvancedTooFar(_buffer.Length);
			}
			WrittenCount += count;
		}

		public Memory<T> GetMemory(int sizeHint = 0)
		{
			CheckAndResizeBuffer(sizeHint);
			return MemoryExtensions.AsMemory(_buffer, WrittenCount);
		}

		public Span<T> GetSpan(int sizeHint = 0)
		{
			CheckAndResizeBuffer(sizeHint);
			return MemoryExtensions.AsSpan(_buffer, WrittenCount);
		}

		private void CheckAndResizeBuffer(int sizeHint)
		{
			if (sizeHint < 0)
			{
				throw new ArgumentException("sizeHint");
			}
			if (sizeHint == 0)
			{
				sizeHint = 1;
			}
			if (sizeHint > FreeCapacity)
			{
				int num = Math.Max(sizeHint, _buffer.Length);
				if (_buffer.Length == 0)
				{
					num = Math.Max(num, 256);
				}
				int newSize = checked(_buffer.Length + num);
				Array.Resize(ref _buffer, newSize);
			}
		}

		private static void ThrowInvalidOperationException_AdvancedTooFar(int capacity)
		{
			throw new InvalidOperationException($"Advanced past capacity of {capacity}");
		}
	}
	[AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = true)]
	internal class ForwardsClientCallsAttribute : Attribute
	{
		public bool SkipChecks { get; }

		public ForwardsClientCallsAttribute()
			: this(skipChecks: false)
		{
		}

		public ForwardsClientCallsAttribute(bool skipChecks)
		{
			SkipChecks = skipChecks;
		}
	}
	internal struct HashCodeBuilder
	{
		private static readonly uint s_seed = GenerateGlobalSeed();

		private const uint Prime1 = 2654435761u;

		private const uint Prime2 = 2246822519u;

		private const uint Prime3 = 3266489917u;

		private const uint Prime4 = 668265263u;

		private const uint Prime5 = 374761393u;

		private uint _v1;

		private uint _v2;

		private uint _v3;

		private uint _v4;

		private uint _queue1;

		private uint _queue2;

		private uint _queue3;

		private uint _length;

		private static uint GenerateGlobalSeed()
		{
			return (uint)new Random().Next();
		}

		public static int Combine<T1>(T1 value1)
		{
			uint queuedValue = (uint)(value1?.GetHashCode() ?? 0);
			return (int)MixFinal(QueueRound(MixEmptyState() + 4, queuedValue));
		}

		public static int Combine<T1, T2>(T1 value1, T2 value2)
		{
			uint queuedValue = (uint)(value1?.GetHashCode() ?? 0);
			uint queuedValue2 = (uint)(value2?.GetHashCode() ?? 0);
			return (int)MixFinal(QueueRound(QueueRound(MixEmptyState() + 8, queuedValue), queuedValue2));
		}

		public static int Combine<T1, T2, T3>(T1 value1, T2 value2, T3 value3)
		{
			uint queuedValue = (uint)(value1?.GetHashCode() ?? 0);
			uint queuedValue2 = (uint)(value2?.GetHashCode() ?? 0);
			uint queuedValue3 = (uint)(value3?.GetHashCode() ?? 0);
			return (int)MixFinal(QueueRound(QueueRound(QueueRound(MixEmptyState() + 12, queuedValue), queuedValue2), queuedValue3));
		}

		public static int Combine<T1, T2, T3, T4>(T1 value1, T2 value2, T3 value3, T4 value4)
		{
			uint input = (uint)(value1?.GetHashCode() ?? 0);
			uint input2 = (uint)(value2?.GetHashCode() ?? 0);
			uint input3 = (uint)(value3?.GetHashCode() ?? 0);
			uint input4 = (uint)(value4?.GetHashCode() ?? 0);
			Initialize(out var v, out var v2, out var v3, out var v4);
			v = Round(v, input);
			v2 = Round(v2, input2);
			v3 = Round(v3, input3);
			v4 = Round(v4, input4);
			return (int)MixFinal(MixState(v, v2, v3, v4) + 16);
		}

		public static int Combine<T1, T2, T3, T4, T5>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5)
		{
			uint input = (uint)(value1?.GetHashCode() ?? 0);
			uint input2 = (uint)(value2?.GetHashCode() ?? 0);
			uint input3 = (uint)(value3?.GetHashCode() ?? 0);
			uint input4 = (uint)(value4?.GetHashCode() ?? 0);
			uint queuedValue = (uint)(value5?.GetHashCode() ?? 0);
			Initialize(out var v, out var v2, out var v3, out var v4);
			v = Round(v, input);
			v2 = Round(v2, input2);
			v3 = Round(v3, input3);
			v4 = Round(v4, input4);
			return (int)MixFinal(QueueRound(MixState(v, v2, v3, v4) + 20, queuedValue));
		}

		public static int Combine<T1, T2, T3, T4, T5, T6>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6)
		{
			uint input = (uint)(value1?.GetHashCode() ?? 0);
			uint input2 = (uint)(value2?.GetHashCode() ?? 0);
			uint input3 = (uint)(value3?.GetHashCode() ?? 0);
			uint input4 = (uint)(value4?.GetHashCode() ?? 0);
			uint queuedValue = (uint)(value5?.GetHashCode() ?? 0);
			uint queuedValue2 = (uint)(value6?.GetHashCode() ?? 0);
			Initialize(out var v, out var v2, out var v3, out var v4);
			v = Round(v, input);
			v2 = Round(v2, input2);
			v3 = Round(v3, input3);
			v4 = Round(v4, input4);
			return (int)MixFinal(QueueRound(QueueRound(MixState(v, v2, v3, v4) + 24, queuedValue), queuedValue2));
		}

		public static int Combine<T1, T2, T3, T4, T5, T6, T7>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7)
		{
			uint input = (uint)(value1?.GetHashCode() ?? 0);
			uint input2 = (uint)(value2?.GetHashCode() ?? 0);
			uint input3 = (uint)(value3?.GetHashCode() ?? 0);
			uint input4 = (uint)(value4?.GetHashCode() ?? 0);
			uint queuedValue = (uint)(value5?.GetHashCode() ?? 0);
			uint queuedValue2 = (uint)(value6?.GetHashCode() ?? 0);
			uint queuedValue3 = (uint)(value7?.GetHashCode() ?? 0);
			Initialize(out var v, out var v2, out var v3, out var v4);
			v = Round(v, input);
			v2 = Round(v2, input2);
			v3 = Round(v3, input3);
			v4 = Round(v4, input4);
			return (int)MixFinal(QueueRound(QueueRound(QueueRound(MixState(v, v2, v3, v4) + 28, queuedValue), queuedValue2), queuedValue3));
		}

		public static int Combine<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8)
		{
			uint input = (uint)(value1?.GetHashCode() ?? 0);
			uint input2 = (uint)(value2?.GetHashCode() ?? 0);
			uint input3 = (uint)(value3?.GetHashCode() ?? 0);
			uint input4 = (uint)(value4?.GetHashCode() ?? 0);
			uint input5 = (uint)(value5?.GetHashCode() ?? 0);
			uint input6 = (uint)(value6?.GetHashCode() ?? 0);
			uint input7 = (uint)(value7?.GetHashCode() ?? 0);
			uint input8 = (uint)(value8?.GetHashCode() ?? 0);
			Initialize(out var v, out var v2, out var v3, out var v4);
			v = Round(v, input);
			v2 = Round(v2, input2);
			v3 = Round(v3, input3);
			v4 = Round(v4, input4);
			v = Round(v, input5);
			v2 = Round(v2, input6);
			v3 = Round(v3, input7);
			v4 = Round(v4, input8);
			return (int)MixFinal(MixState(v, v2, v3, v4) + 32);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static void Initialize(out uint v1, out uint v2, out uint v3, out uint v4)
		{
			v1 = (uint)((int)s_seed + -1640531535 + -2048144777);
			v2 = s_seed + 2246822519u;
			v3 = s_seed;
			v4 = s_seed - 2654435761u;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static uint Round(uint hash, uint input)
		{
			return RotateLeft(hash + (uint)((int)input * -2048144777), 13) * 2654435761u;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static uint QueueRound(uint hash, uint queuedValue)
		{
			return RotateLeft(hash + (uint)((int)queuedValue * -1028477379), 17) * 668265263;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static uint MixState(uint v1, uint v2, uint v3, uint v4)
		{
			return RotateLeft(v1, 1) + RotateLeft(v2, 7) + RotateLeft(v3, 12) + RotateLeft(v4, 18);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static uint RotateLeft(uint value, int offset)
		{
			return (value << offset) | (value >> 64 - offset);
		}

		private static uint MixEmptyState()
		{
			return s_seed + 374761393;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static uint MixFinal(uint hash)
		{
			hash ^= hash >> 15;
			hash *= 2246822519u;
			hash ^= hash >> 13;
			hash *= 3266489917u;
			hash ^= hash >> 16;
			return hash;
		}

		public void Add<T>(T value)
		{
			Add(value?.GetHashCode() ?? 0);
		}

		public void Add<T>(T value, IEqualityComparer<T>? comparer)
		{
			Add((value != null) ? (comparer?.GetHashCode(value) ?? value.GetHashCode()) : 0);
		}

		private void Add(int value)
		{
			uint num = _length++;
			switch (num % 4)
			{
			case 0u:
				_queue1 = (uint)value;
				return;
			case 1u:
				_queue2 = (uint)value;
				return;
			case 2u:
				_queue3 = (uint)value;
				return;
			}
			if (num == 3)
			{
				Initialize(out _v1, out _v2, out _v3, out _v4);
			}
			_v1 = Round(_v1, _queue1);
			_v2 = Round(_v2, _queue2);
			_v3 = Round(_v3, _queue3);
			_v4 = Round(_v4, (uint)value);
		}

		public int ToHashCode()
		{
			uint length = _length;
			uint num = length % 4;
			uint num2 = ((length < 4) ? MixEmptyState() : MixState(_v1, _v2, _v3, _v4));
			num2 += length * 4;
			if (num != 0)
			{
				num2 = QueueRound(num2, _queue1);
				if (num > 1)
				{
					num2 = QueueRound(num2, _queue2);
					if (num > 2)
					{
						num2 = QueueRound(num2, _queue3);
					}
				}
			}
			return (int)MixFinal(num2);
		}

		[Obsolete("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public override int GetHashCode()
		{
			throw new NotSupportedException();
		}

		[Obsolete("HashCode is a mutable struct and should not be compared with other HashCodes.", true)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public override bool Equals(object? obj)
		{
			throw new NotSupportedException();
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	internal class CodeGenClientAttribute : CodeGenTypeAttribute
	{
		public Type? ParentClient { get; set; }

		public CodeGenClientAttribute(string originalName)
			: base(originalName)
		{
		}
	}
	[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field)]
	internal class CodeGenMemberAttribute : CodeGenTypeAttribute
	{
		public CodeGenMemberAttribute()
			: base(null)
		{
		}

		public CodeGenMemberAttribute(string originalName)
			: base(originalName)
		{
		}
	}
	[AttributeUsage(AttributeTargets.Property)]
	internal class CodeGenMemberSerializationAttribute : Attribute
	{
		public string[] SerializationPath { get; }

		public CodeGenMemberSerializationAttribute(params string[] serializationPath)
		{
			SerializationPath = serializationPath;
		}
	}
	[AttributeUsage(AttributeTargets.Property)]
	internal class CodeGenMemberSerializationHooksAttribute : Attribute
	{
		public string? SerializationValueHook { get; set; }

		public string? DeserializationValueHook { get; set; }
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum)]
	internal class CodeGenModelAttribute : CodeGenTypeAttribute
	{
		public string[]? Usage { get; set; }

		public string[]? Formats { get; set; }

		public CodeGenModelAttribute()
			: base(null)
		{
		}

		public CodeGenModelAttribute(string originalName)
			: base(originalName)
		{
		}
	}
	[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
	internal class CodeGenOverrideServiceVersionsAttribute : Attribute
	{
		public string[] Versions { get; }

		public CodeGenOverrideServiceVersionsAttribute(params string[] versions)
		{
			Versions = versions;
		}
	}
	[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum, AllowMultiple = true)]
	internal class CodeGenSuppressAttribute : Attribute
	{
		public string Member { get; }

		public Type[] Parameters { get; }

		public CodeGenSuppressAttribute(string member, params Type[] parameters)
		{
			Member = member;
			Parameters = parameters;
		}
	}
	[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
	internal class CodeGenSuppressTypeAttribute : Attribute
	{
		public string Typename { get; }

		public CodeGenSuppressTypeAttribute(string typename)
		{
			Typename = typename;
		}
	}
	[AttributeUsage(AttributeTargets.Class)]
	internal class CodeGenTypeAttribute : Attribute
	{
		public string? OriginalName { get; }

		public CodeGenTypeAttribute(string? originalName)
		{
			OriginalName = originalName;
		}
	}
	internal static class AppContextSwitchHelper
	{
		public static bool GetConfigValue(string appContexSwitchName, string environmentVariableName)
		{
			if (AppContext.TryGetSwitch(appContexSwitchName, out var isEnabled))
			{
				return isEnabled;
			}
			string environmentVariable = Environment.GetEnvironmentVariable(environmentVariableName);
			if (environmentVariable != null && (environmentVariable.Equals("true", StringComparison.OrdinalIgnoreCase) || environmentVariable.Equals("1")))
			{
				return true;
			}
			return false;
		}
	}
	internal static class Argument
	{
		public static void AssertNotNull<T>(T value, string name)
		{
			if (value == null)
			{
				throw new ArgumentNullException(name);
			}
		}

		public static void AssertNotNull<T>(T? value, string name) where T : struct
		{
			if (!value.HasValue)
			{
				throw new ArgumentNullException(name);
			}
		}

		public static void AssertNotNullOrEmpty<T>(IEnumerable<T> value, string name)
		{
			if (value == null)
			{
				throw new ArgumentNullException(name);
			}
			if (value is ICollection<T> { Count: 0 })
			{
				throw new ArgumentException("Value cannot be an empty collection.", name);
			}
			if (value is ICollection { Count: 0 })
			{
				throw new ArgumentException("Value cannot be an empty collection.", name);
			}
			using IEnumerator<T> enumerator = value.GetEnumerator();
			if (!enumerator.MoveNext())
			{
				throw new ArgumentException("Value cannot be an empty collection.", name);
			}
		}

		public static void AssertNotNullOrEmpty(string value, string name)
		{
			if (value == null)
			{
				throw new ArgumentNullException(name);
			}
			if (value.Length == 0)
			{
				throw new ArgumentException("Value cannot be an empty string.", name);
			}
		}

		public static void AssertNotNullOrWhiteSpace(string value, string name)
		{
			if (value == null)
			{
				throw new ArgumentNullException(name);
			}
			if (string.IsNullOrWhiteSpace(value))
			{
				throw new ArgumentException("Value cannot be empty or contain only white-space characters.", name);
			}
		}

		public static void AssertNotDefault<T>(ref T value, string name) where T : struct, IEquatable<T>
		{
			if (value.Equals(default(T)))
			{
				throw new ArgumentException("Value cannot be empty.", name);
			}
		}

		public static void AssertInRange<T>(T value, T minimum, T maximum, string name) where T : notnull, IComparable<T>
		{
			if (minimum.CompareTo(value) > 0)
			{
				throw new ArgumentOutOfRangeException(name, "Value is less than the minimum allowed.");
			}
			if (maximum.CompareTo(value) < 0)
			{
				throw new ArgumentOutOfRangeException(name, "Value is greater than the maximum allowed.");
			}
		}

		public static void AssertEnumDefined(Type enumType, object value, string name)
		{
			if (!Enum.IsDefined(enumType, value))
			{
				throw new ArgumentException("Value not defined for " + enumType.FullName + ".", name);
			}
		}

		public static T CheckNotNull<T>(T value, string name) where T : class
		{
			AssertNotNull(value, name);
			return value;
		}

		public static string CheckNotNullOrEmpty(string value, string name)
		{
			AssertNotNullOrEmpty(value, name);
			return value;
		}

		public static void AssertNull<T>(T value, string name, string? message = null)
		{
			if (value != null)
			{
				throw new ArgumentException(message ?? "Value must be null.", name);
			}
		}
	}
	internal sealed class AsyncLockWithValue<T>
	{
		public readonly struct LockOrValue : IDisposable
		{
			private readonly Azure.Core.AsyncLockWithValue<T>? _owner;

			private readonly T? _value;

			private readonly long _index;

			public bool HasValue => _owner == null;

			public T Value
			{
				get
				{
					if (!HasValue)
					{
						throw new InvalidOperationException("Value isn't set");
					}
					return _value;
				}
			}

			public LockOrValue(T value)
			{
				_owner = null;
				_value = value;
				_index = 0L;
			}

			public LockOrValue(Azure.Core.AsyncLockWithValue<T> owner, long index)
			{
				_owner = owner;
				_index = index;
				_value = default(T);
			}

			public void SetValue(T value)
			{
				if (_owner != null)
				{
					_owner.SetValue(value, in _index);
					return;
				}
				throw new InvalidOperationException("Value for the lock is set already");
			}

			public void Dispose()
			{
				_owner?.Reset(in _index);
			}
		}

		private readonly object _syncObj = new object();

		private Queue<TaskCompletionSource<LockOrValue>>? _waiters;

		private bool _isLocked;

		private bool _hasValue;

		private long _index;

		private T? _value;

		public bool HasValue
		{
			get
			{
				lock (_syncObj)
				{
					return _hasValue;
				}
			}
		}

		public AsyncLockWithValue()
		{
		}

		public AsyncLockWithValue(T value)
		{
			_hasValue = true;
			_value = value;
		}

		public bool TryGetValue(out T? value)
		{
			lock (_syncObj)
			{
				if (_hasValue)
				{
					value = _value;
					return true;
				}
			}
			value = default(T);
			return false;
		}

		public async ValueTask<LockOrValue> GetLockOrValueAsync(bool async, CancellationToken cancellationToken = default(CancellationToken))
		{
			TaskCompletionSource<LockOrValue> valueTcs;
			lock (_syncObj)
			{
				if (_hasValue)
				{
					return new LockOrValue(_value);
				}
				if (!_isLocked)
				{
					_isLocked = true;
					_index++;
					return new LockOrValue(this, _index);
				}
				cancellationToken.ThrowIfCancellationRequested();
				if (_waiters == null)
				{
					_waiters = new Queue<TaskCompletionSource<LockOrValue>>();
				}
				valueTcs = new TaskCompletionSource<LockOrValue>(async ? TaskCreationOptions.RunContinuationsAsynchronously : TaskCreationOptions.None);
				_waiters.Enqueue(valueTcs);
			}
			try
			{
				if (async)
				{
					return await valueTcs.Task.AwaitWithCancellation(cancellationToken);
				}
				valueTcs.Task.Wait(cancellationToken);
				return valueTcs.Task.EnsureCompleted();
			}
			catch (OperationCanceledException)
			{
				if (valueTcs.TrySetCanceled(cancellationToken))
				{
					throw;
				}
				return valueTcs.Task.Result;
			}
		}

		private void SetValue(T value, in long lockIndex)
		{
			Queue<TaskCompletionSource<LockOrValue>> waiters;
			lock (_syncObj)
			{
				if (lockIndex != _index)
				{
					throw new InvalidOperationException(string.Format("Disposed {0} tries to set value. Current index: {1}, {2} index: {3}", "LockOrValue", _index, "LockOrValue", lockIndex));
				}
				_value = value;
				_hasValue = true;
				_index = 0L;
				_isLocked = false;
				if (_waiters == null)
				{
					return;
				}
				waiters = _waiters;
				_waiters = null;
			}
			while (waiters.Count > 0)
			{
				waiters.Dequeue().TrySetResult(new LockOrValue(value));
			}
		}

		private void Reset(in long lockIndex)
		{
			UnlockOrGetNextWaiter(in lockIndex, out TaskCompletionSource<LockOrValue> nextWaiter);
			while (nextWaiter != null && !nextWaiter.TrySetResult(new LockOrValue(this, lockIndex + 1)))
			{
				UnlockOrGetNextWaiter(in lockIndex, out nextWaiter);
			}
		}

		private void UnlockOrGetNextWaiter(in long lockIndex, out TaskCompletionSource<LockOrValue>? nextWaiter)
		{
			lock (_syncObj)
			{
				nextWaiter = null;
				if (!_isLocked || lockIndex != _index)
				{
					return;
				}
				_index = lockIndex + 1;
				if (_waiters == null)
				{
					_isLocked = false;
					return;
				}
				while (_waiters.Count > 0)
				{
					nextWaiter = _waiters.Dequeue();
					if (!nextWaiter.Task.IsCompleted)
					{
						return;
					}
				}
				_isLocked = false;
			}
		}
	}
	internal class ChangeTrackingDictionary<TKey, TValue> : IDictionary<TKey, TValue>, ICollection<KeyValuePair<TKey, TValue>>, IEnumerable<KeyValuePair<TKey, TValue>>, IEnumerable, IReadOnlyDictionary<TKey, TValue>, IReadOnlyCollection<KeyValuePair<TKey, TValue>> where TKey : notnull
	{
		private IDictionary<TKey, TValue>? _innerDictionary;

		public bool IsUndefined => _innerDictionary == null;

		public int Count
		{
			get
			{
				if (IsUndefined)
				{
					return 0;
				}
				return EnsureDictionary().Count;
			}
		}

		public bool IsReadOnly
		{
			get
			{
				if (IsUndefined)
				{
					return false;
				}
				return EnsureDictionary().IsReadOnly;
			}
		}

		public TValue this[TKey key]
		{
			get
			{
				if (IsUndefined)
				{
					throw new KeyNotFoundException("key");
				}
				return EnsureDictionary()[key];
			}
			set
			{
				EnsureDictionary()[key] = value;
			}
		}

		IEnumerable<TKey> IReadOnlyDictionary<TKey, TValue>.Keys => Keys;

		IEnumerable<TValue> IReadOnlyDictionary<TKey, TValue>.Values => Values;

		public ICollection<TKey> Keys
		{
			get
			{
				if (IsUndefined)
				{
					return Array.Empty<TKey>();
				}
				return EnsureDictionary().Keys;
			}
		}

		public ICollection<TValue> Values
		{
			get
			{
				if (IsUndefined)
				{
					return Array.Empty<TValue>();
				}
				return EnsureDictionary().Values;
			}
		}

		public ChangeTrackingDictionary()
		{
		}

		public ChangeTrackingDictionary(Azure.Core.Optional<IReadOnlyDictionary<TKey, TValue>> optionalDictionary)
			: this(optionalDictionary.Value)
		{
		}

		public ChangeTrackingDictionary(Azure.Core.Optional<IDictionary<TKey, TValue>> optionalDictionary)
			: this(optionalDictionary.Value)
		{
		}

		private ChangeTrackingDictionary(IDictionary<TKey, TValue> dictionary)
		{
			if (dictionary != null)
			{
				_innerDictionary = new Dictionary<TKey, TValue>(dictionary);
			}
		}

		private ChangeTrackingDictionary(IReadOnlyDictionary<TKey, TValue> dictionary)
		{
			if (dictionary == null)
			{
				return;
			}
			_innerDictionary = new Dictionary<TKey, TValue>();
			foreach (KeyValuePair<TKey, TValue> item in dictionary)
			{
				_innerDictionary.Add(item);
			}
		}

		public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator()
		{
			if (IsUndefined)
			{
				return GetEmptyEnumerator();
			}
			return EnsureDictionary().GetEnumerator();
			static IEnumerator<KeyValuePair<TKey, TValue>> GetEmptyEnumerator()
			{
				yield break;
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public void Add(KeyValuePair<TKey, TValue> item)
		{
			EnsureDictionary().Add(item);
		}

		public void Clear()
		{
			EnsureDictionary().Clear();
		}

		public bool Contains(KeyValuePair<TKey, TValue> item)
		{
			if (IsUndefined)
			{
				return false;
			}
			return EnsureDictionary().Contains(item);
		}

		public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex)
		{
			if (!IsUndefined)
			{
				EnsureDictionary().CopyTo(array, arrayIndex);
			}
		}

		public bool Remove(KeyValuePair<TKey, TValue> item)
		{
			if (IsUndefined)
			{
				return false;
			}
			return EnsureDictionary().Remove(item);
		}

		public void Add(TKey key, TValue value)
		{
			EnsureDictionary().Add(key, value);
		}

		public bool ContainsKey(TKey key)
		{
			if (IsUndefined)
			{
				return false;
			}
			return EnsureDictionary().ContainsKey(key);
		}

		public bool Remove(TKey key)
		{
			if (IsUndefined)
			{
				return false;
			}
			return EnsureDictionary().Remove(key);
		}

		public bool TryGetValue(TKey key, out TValue value)
		{
			if (IsUndefined)
			{
				value = default(TValue);
				return false;
			}
			return EnsureDictionary().TryGetValue(key, out value);
		}

		private IDictionary<TKey, TValue> EnsureDictionary()
		{
			return _innerDictionary ?? (_innerDictionary = new Dictionary<TKey, TValue>());
		}
	}
	internal class ChangeTrackingList<T> : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable, IReadOnlyList<T>, IReadOnlyCollection<T>
	{
		private IList<T>? _innerList;

		public bool IsUndefined => _innerList == null;

		public int Count
		{
			get
			{
				if (IsUndefined)
				{
					return 0;
				}
				return EnsureList().Count;
			}
		}

		public bool IsReadOnly
		{
			get
			{
				if (IsUndefined)
				{
					return false;
				}
				return EnsureList().IsReadOnly;
			}
		}

		public T this[int index]
		{
			get
			{
				if (IsUndefined)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				return EnsureList()[index];
			}
			set
			{
				if (IsUndefined)
				{
					throw new ArgumentOutOfRangeException("index");
				}
				EnsureList()[index] = value;
			}
		}

		public ChangeTrackingList()
		{
		}

		public ChangeTrackingList(Azure.Core.Optional<IList<T>> optionalList)
			: this(optionalList.Value)
		{
		}

		public ChangeTrackingList(Azure.Core.Optional<IReadOnlyList<T>> optionalList)
			: this((IEnumerable<T>)optionalList.Value)
		{
		}

		private ChangeTrackingList(IEnumerable<T> innerList)
		{
			if (innerList != null)
			{
				_innerList = innerList.ToList();
			}
		}

		private ChangeTrackingList(IList<T> innerList)
		{
			if (innerList != null)
			{
				_innerList = innerList;
			}
		}

		public void Reset()
		{
			_innerList = null;
		}

		public IEnumerator<T> GetEnumerator()
		{
			if (IsUndefined)
			{
				return EnumerateEmpty();
			}
			return EnsureList().GetEnumerator();
			static IEnumerator<T> EnumerateEmpty()
			{
				yield break;
			}
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}

		public void Add(T item)
		{
			EnsureList().Add(item);
		}

		public void Clear()
		{
			EnsureList().Clear();
		}

		public bool Contains(T item)
		{
			if (IsUndefined)
			{
				return false;
			}
			return EnsureList().Contains(item);
		}

		public void CopyTo(T[] array, int arrayIndex)
		{
			if (!IsUndefined)
			{
				EnsureList().CopyTo(array, arrayIndex);
			}
		}

		public bool Remove(T item)
		{
			if (IsUndefined)
			{
				return false;
			}
			return EnsureList().Remove(item);
		}

		public int IndexOf(T item)
		{
			if (IsUndefined)
			{
				return -1;
			}
			return EnsureList().IndexOf(item);
		}

		public void Insert(int index, T item)
		{
			EnsureList().Insert(index, item);
		}

		public void RemoveAt(int index)
		{
			if (IsUndefined)
			{
				throw new ArgumentOutOfRangeException("index");
			}
			EnsureList().RemoveAt(index);
		}

		private IList<T> EnsureList()
		{
			return _innerList ?? (_innerList = new List<T>());
		}
	}
	internal class FixedDelayWithNoJitterStrategy : DelayStrategy
	{
		private static readonly TimeSpan DefaultDelay = TimeSpan.FromSeconds(1.0);

		private readonly TimeSpan _delay;

		public FixedDelayWithNoJitterStrategy(TimeSpan? suggestedDelay = null)
			: base(suggestedDelay.HasValue ? DelayStrategy.Max(suggestedDelay.Value, DefaultDelay) : DefaultDelay, 0.0)
		{
			_delay = (suggestedDelay.HasValue ? DelayStrategy.Max(suggestedDelay.Value, DefaultDelay) : DefaultDelay);
		}

		protected override TimeSpan GetNextDelayCore(Response? response, int retryNumber)
		{
			return _delay;
		}
	}
	internal class FormUrlEncodedContent : RequestContent
	{
		private List<KeyValuePair<string, string>> _values = new List<KeyValuePair<string, string>>();

		private Encoding Latin1 = Encoding.GetEncoding("iso-8859-1");

		private byte[] _bytes = Array.Empty<byte>();

		public void Add(string parameter, string value)
		{
			_values.Add(new KeyValuePair<string, string>(parameter, value));
		}

		private void BuildIfNeeded()
		{
			if (_bytes.Length == 0)
			{
				_bytes = GetContentByteArray(_values);
				_values.Clear();
			}
		}

		public override async Task WriteToAsync(Stream stream, CancellationToken cancellation)
		{
			BuildIfNeeded();
			await stream.WriteAsync(_bytes, 0, _bytes.Length, cancellation).ConfigureAwait(continueOnCapturedContext: false);
		}

		public override void WriteTo(Stream stream, CancellationToken cancellation)
		{
			BuildIfNeeded();
			stream.Write(_bytes, 0, _bytes.Length);
		}

		public override bool TryComputeLength(out long length)
		{
			BuildIfNeeded();
			length = _bytes.Length;
			return true;
		}

		public override void Dispose()
		{
		}

		private byte[] GetContentByteArray(IEnumerable<KeyValuePair<string, string>> nameValueCollection)
		{
			if (nameValueCollection == null)
			{
				throw new ArgumentNullException("nameValueCollection");
			}
			StringBuilder stringBuilder = new StringBuilder();
			foreach (KeyValuePair<string, string> item in nameValueCollection)
			{
				if (stringBuilder.Length > 0)
				{
					stringBuilder.Append('&');
				}
				stringBuilder.Append(Encode(item.Key));
				stringBuilder.Append('=');
				stringBuilder.Append(Encode(item.Value));
			}
			return Latin1.GetBytes(stringBuilder.ToString());
		}

		private static string Encode(string data)
		{
			if (string.IsNullOrEmpty(data))
			{
				return string.Empty;
			}
			return Uri.EscapeDataString(data).Replace("%20", "+");
		}
	}
	internal class HttpMessageSanitizer
	{
		private const string LogAllValue = "*";

		private readonly bool _logAllHeaders;

		private readonly bool _logFullQueries;

		private readonly string[] _allowedQueryParameters;

		private readonly string _redactedPlaceholder;

		private readonly HashSet<string> _allowedHeaders;

		internal static Azure.Core.HttpMessageSanitizer Default = new Azure.Core.HttpMessageSanitizer(Array.Empty<string>(), Array.Empty<string>());

		public HttpMessageSanitizer(string[] allowedQueryParameters, string[] allowedHeaders, string redactedPlaceholder = "REDACTED")
		{
			_logAllHeaders = allowedHeaders.Contains("*");
			_logFullQueries = allowedQueryParameters.Contains("*");
			_allowedQueryParameters = allowedQueryParameters;
			_redactedPlaceholder = redactedPlaceholder;
			_allowedHeaders = new HashSet<string>(allowedHeaders, StringComparer.InvariantCultureIgnoreCase);
		}

		public string SanitizeHeader(string name, string value)
		{
			if (_logAllHeaders || _allowedHeaders.Contains(name))
			{
				return value;
			}
			return _redactedPlaceholder;
		}

		public string SanitizeUrl(string url)
		{
			if (_logFullQueries)
			{
				return url;
			}
			int num = url.IndexOf('?');
			if (num == -1)
			{
				return url;
			}
			StringBuilder stringBuilder = new StringBuilder(url.Length);
			stringBuilder.Append(url, 0, num);
			string text = url.Substring(num);
			int num2 = 1;
			stringBuilder.Append('?');
			do
			{
				int num3 = text.IndexOf('&', num2);
				int num4 = text.IndexOf('=', num2);
				bool flag = false;
				if ((num3 == -1 && num4 == -1) || (num3 != -1 && (num4 == -1 || num4 > num3)))
				{
					num4 = num3;
					flag = true;
				}
				if (num4 == -1)
				{
					num4 = text.Length;
				}
				num3 = ((num3 != -1) ? (num3 + 1) : text.Length);
				ReadOnlySpan<char> span = MemoryExtensions.AsSpan(text, num2, num4 - num2);
				bool flag2 = false;
				string[] allowedQueryParameters = _allowedQueryParameters;
				foreach (string text2 in allowedQueryParameters)
				{
					if (MemoryExtensions.Equals(span, MemoryExtensions.AsSpan(text2), StringComparison.OrdinalIgnoreCase))
					{
						flag2 = true;
						break;
					}
				}
				int num5 = num3 - num2;
				int count = num4 - num2;
				if (flag2)
				{
					stringBuilder.Append(text, num2, num5);
				}
				else if (flag)
				{
					stringBuilder.Append(text, num2, num5);
				}
				else
				{
					stringBuilder.Append(text, num2, count);
					stringBuilder.Append('=');
					stringBuilder.Append(_redactedPlaceholder);
					if (text[num3 - 1] == '&')
					{
						stringBuilder.Append('&');
					}
				}
				num2 += num5;
			}
			while (num2 < text.Length);
			return stringBuilder.ToString();
		}
	}
	internal static class HttpPipelineExtensions
	{
		internal class ErrorResponse<T> : Response<T>
		{
			private readonly Response _response;

			private readonly RequestFailedException _exception;

			public override T Value
			{
				get
				{
					throw _exception;
				}
			}

			public ErrorResponse(Response response, RequestFailedException exception)
			{
				_response = response;
				_exception = exception;
			}

			public override Response GetRawResponse()
			{
				return _response;
			}
		}

		public static async ValueTask<Response> ProcessMessageAsync(this HttpPipeline pipeline, HttpMessage message, RequestContext? requestContext, CancellationToken cancellationToken = default(CancellationToken))
		{
			var (cancellationToken2, statusOption) = ApplyRequestContext(requestContext);
			if (!cancellationToken2.CanBeCanceled || !cancellationToken.CanBeCanceled)
			{
				await pipeline.SendAsync(message, cancellationToken.CanBeCanceled ? cancellationToken : cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
			}
			else
			{
				using CancellationTokenSource cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken2, cancellationToken);
				await pipeline.SendAsync(message, cts.Token).ConfigureAwait(continueOnCapturedContext: false);
			}
			if (!message.Response.IsError || statusOption == ErrorOptions.NoThrow)
			{
				return message.Response;
			}
			throw new RequestFailedException(message.Response);
		}

		public static Response ProcessMessage(this HttpPipeline pipeline, HttpMessage message, RequestContext? requestContext, CancellationToken cancellationToken = default(CancellationToken))
		{
			var (cancellationToken2, errorOptions) = ApplyRequestContext(requestContext);
			if (!cancellationToken2.CanBeCanceled || !cancellationToken.CanBeCanceled)
			{
				pipeline.Send(message, cancellationToken.CanBeCanceled ? cancellationToken : cancellationToken2);
			}
			else
			{
				using CancellationTokenSource cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken2, cancellationToken);
				pipeline.Send(message, cancellationTokenSource.Token);
			}
			if (!message.Response.IsError || errorOptions == ErrorOptions.NoThrow)
			{
				return message.Response;
			}
			throw new RequestFailedException(message.Response);
		}

		public static async ValueTask<Response<bool>> ProcessHeadAsBoolMessageAsync(this HttpPipeline pipeline, HttpMessage message, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, RequestContext? requestContext)
		{
			Response response = await pipeline.ProcessMessageAsync(message, requestContext).ConfigureAwait(continueOnCapturedContext: false);
			switch (response.Status)
			{
			case 200:
			case 201:
			case 202:
			case 203:
			case 204:
			case 205:
			case 206:
			case 207:
			case 208:
			case 209:
			case 210:
			case 211:
			case 212:
			case 213:
			case 214:
			case 215:
			case 216:
			case 217:
			case 218:
			case 219:
			case 220:
			case 221:
			case 222:
			case 223:
			case 224:
			case 225:
			case 226:
			case 227:
			case 228:
			case 229:
			case 230:
			case 231:
			case 232:
			case 233:
			case 234:
			case 235:
			case 236:
			case 237:
			case 238:
			case 239:
			case 240:
			case 241:
			case 242:
			case 243:
			case 244:
			case 245:
			case 246:
			case 247:
			case 248:
			case 249:
			case 250:
			case 251:
			case 252:
			case 253:
			case 254:
			case 255:
			case 256:
			case 257:
			case 258:
			case 259:
			case 260:
			case 261:
			case 262:
			case 263:
			case 264:
			case 265:
			case 266:
			case 267:
			case 268:
			case 269:
			case 270:
			case 271:
			case 272:
			case 273:
			case 274:
			case 275:
			case 276:
			case 277:
			case 278:
			case 279:
			case 280:
			case 281:
			case 282:
			case 283:
			case 284:
			case 285:
			case 286:
			case 287:
			case 288:
			case 289:
			case 290:
			case 291:
			case 292:
			case 293:
			case 294:
			case 295:
			case 296:
			case 297:
			case 298:
			case 299:
				return Response.FromValue(value: true, response);
			case 400:
			case 401:
			case 402:
			case 403:
			case 404:
			case 405:
			case 406:
			case 407:
			case 408:
			case 409:
			case 410:
			case 411:
			case 412:
			case 413:
			case 414:
			case 415:
			case 416:
			case 417:
			case 418:
			case 419:
			case 420:
			case 421:
			case 422:
			case 423:
			case 424:
			case 425:
			case 426:
			case 427:
			case 428:
			case 429:
			case 430:
			case 431:
			case 432:
			case 433:
			case 434:
			case 435:
			case 436:
			case 437:
			case 438:
			case 439:
			case 440:
			case 441:
			case 442:
			case 443:
			case 444:
			case 445:
			case 446:
			case 447:
			case 448:
			case 449:
			case 450:
			case 451:
			case 452:
			case 453:
			case 454:
			case 455:
			case 456:
			case 457:
			case 458:
			case 459:
			case 460:
			case 461:
			case 462:
			case 463:
			case 464:
			case 465:
			case 466:
			case 467:
			case 468:
			case 469:
			case 470:
			case 471:
			case 472:
			case 473:
			case 474:
			case 475:
			case 476:
			case 477:
			case 478:
			case 479:
			case 480:
			case 481:
			case 482:
			case 483:
			case 484:
			case 485:
			case 486:
			case 487:
			case 488:
			case 489:
			case 490:
			case 491:
			case 492:
			case 493:
			case 494:
			case 495:
			case 496:
			case 497:
			case 498:
			case 499:
				return Response.FromValue(value: false, response);
			default:
				return new ErrorResponse<bool>(response, new RequestFailedException(response));
			}
		}

		public static Response<bool> ProcessHeadAsBoolMessage(this HttpPipeline pipeline, HttpMessage message, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, RequestContext? requestContext)
		{
			Response response = pipeline.ProcessMessage(message, requestContext);
			switch (response.Status)
			{
			case 200:
			case 201:
			case 202:
			case 203:
			case 204:
			case 205:
			case 206:
			case 207:
			case 208:
			case 209:
			case 210:
			case 211:
			case 212:
			case 213:
			case 214:
			case 215:
			case 216:
			case 217:
			case 218:
			case 219:
			case 220:
			case 221:
			case 222:
			case 223:
			case 224:
			case 225:
			case 226:
			case 227:
			case 228:
			case 229:
			case 230:
			case 231:
			case 232:
			case 233:
			case 234:
			case 235:
			case 236:
			case 237:
			case 238:
			case 239:
			case 240:
			case 241:
			case 242:
			case 243:
			case 244:
			case 245:
			case 246:
			case 247:
			case 248:
			case 249:
			case 250:
			case 251:
			case 252:
			case 253:
			case 254:
			case 255:
			case 256:
			case 257:
			case 258:
			case 259:
			case 260:
			case 261:
			case 262:
			case 263:
			case 264:
			case 265:
			case 266:
			case 267:
			case 268:
			case 269:
			case 270:
			case 271:
			case 272:
			case 273:
			case 274:
			case 275:
			case 276:
			case 277:
			case 278:
			case 279:
			case 280:
			case 281:
			case 282:
			case 283:
			case 284:
			case 285:
			case 286:
			case 287:
			case 288:
			case 289:
			case 290:
			case 291:
			case 292:
			case 293:
			case 294:
			case 295:
			case 296:
			case 297:
			case 298:
			case 299:
				return Response.FromValue(value: true, response);
			case 400:
			case 401:
			case 402:
			case 403:
			case 404:
			case 405:
			case 406:
			case 407:
			case 408:
			case 409:
			case 410:
			case 411:
			case 412:
			case 413:
			case 414:
			case 415:
			case 416:
			case 417:
			case 418:
			case 419:
			case 420:
			case 421:
			case 422:
			case 423:
			case 424:
			case 425:
			case 426:
			case 427:
			case 428:
			case 429:
			case 430:
			case 431:
			case 432:
			case 433:
			case 434:
			case 435:
			case 436:
			case 437:
			case 438:
			case 439:
			case 440:
			case 441:
			case 442:
			case 443:
			case 444:
			case 445:
			case 446:
			case 447:
			case 448:
			case 449:
			case 450:
			case 451:
			case 452:
			case 453:
			case 454:
			case 455:
			case 456:
			case 457:
			case 458:
			case 459:
			case 460:
			case 461:
			case 462:
			case 463:
			case 464:
			case 465:
			case 466:
			case 467:
			case 468:
			case 469:
			case 470:
			case 471:
			case 472:
			case 473:
			case 474:
			case 475:
			case 476:
			case 477:
			case 478:
			case 479:
			case 480:
			case 481:
			case 482:
			case 483:
			case 484:
			case 485:
			case 486:
			case 487:
			case 488:
			case 489:
			case 490:
			case 491:
			case 492:
			case 493:
			case 494:
			case 495:
			case 496:
			case 497:
			case 498:
			case 499:
				return Response.FromValue(value: false, response);
			default:
				return new ErrorResponse<bool>(response, new RequestFailedException(response));
			}
		}

		private static (CancellationToken CancellationToken, ErrorOptions ErrorOptions) ApplyRequestContext(RequestContext? requestContext)
		{
			if (requestContext == null)
			{
				return (CancellationToken: CancellationToken.None, ErrorOptions: ErrorOptions.Default);
			}
			return (CancellationToken: requestContext.CancellationToken, ErrorOptions: requestContext.ErrorOptions);
		}
	}
	internal interface IOperationSource<T>
	{
		T CreateResult(Response response, CancellationToken cancellationToken);

		ValueTask<T> CreateResultAsync(Response response, CancellationToken cancellationToken);
	}
	internal interface IUtf8JsonSerializable
	{
		void Write(Utf8JsonWriter writer);
	}
	internal interface IXmlSerializable
	{
		void Write(XmlWriter writer, string? nameHint);
	}
	internal static class JsonElementExtensions
	{
		public static object? GetObject(this in JsonElement element)
		{
			switch (element.ValueKind)
			{
			case JsonValueKind.String:
				return element.GetString();
			case JsonValueKind.Number:
			{
				if (element.TryGetInt32(out var value))
				{
					return value;
				}
				if (element.TryGetInt64(out var value2))
				{
					return value2;
				}
				return element.GetDouble();
			}
			case JsonValueKind.True:
				return true;
			case JsonValueKind.False:
				return false;
			case JsonValueKind.Undefined:
			case JsonValueKind.Null:
				return null;
			case JsonValueKind.Object:
			{
				Dictionary<string, object> dictionary = new Dictionary<string, object>();
				{
					foreach (JsonProperty item in element.EnumerateObject())
					{
						dictionary.Add(item.Name, item.Value.GetObject());
					}
					return dictionary;
				}
			}
			case JsonValueKind.Array:
			{
				List<object> list = new List<object>();
				foreach (JsonElement item2 in element.EnumerateArray())
				{
					list.Add(item2.GetObject());
				}
				return list.ToArray();
			}
			default:
				throw new NotSupportedException("Not supported value kind " + element.ValueKind);
			}
		}

		public static byte[]? GetBytesFromBase64(this in JsonElement element, string format)
		{
			if (element.ValueKind == JsonValueKind.Null)
			{
				return null;
			}
			if (!(format == "U"))
			{
				if (format == "D")
				{
					return element.GetBytesFromBase64();
				}
				throw new ArgumentException("Format is not supported: '" + format + "'", "format");
			}
			return Azure.Core.TypeFormatters.FromBase64UrlString(element.GetRequiredString());
		}

		public static DateTimeOffset GetDateTimeOffset(this in JsonElement element, string format)
		{
			if (format == "U" && element.ValueKind == JsonValueKind.Number)
			{
				return DateTimeOffset.FromUnixTimeSeconds(element.GetInt64());
			}
			return Azure.Core.TypeFormatters.ParseDateTimeOffset(element.GetString(), format);
		}

		public static TimeSpan GetTimeSpan(this in JsonElement element, string format)
		{
			return Azure.Core.TypeFormatters.ParseTimeSpan(element.GetString(), format);
		}

		public static char GetChar(this in JsonElement element)
		{
			if (element.ValueKind == JsonValueKind.String)
			{
				string text = element.GetString();
				if (text == null || text.Length != 1)
				{
					throw new NotSupportedException("Cannot convert \"" + text + "\" to a Char");
				}
				return text[0];
			}
			throw new NotSupportedException($"Cannot convert {element.ValueKind} to a Char");
		}

		[Conditional("DEBUG")]
		public static void ThrowNonNullablePropertyIsNull(this JsonProperty property)
		{
			throw new JsonException("A property '" + property.Name + "' defined as non-nullable but received as null from the service. This exception only happens in DEBUG builds of the library and would be ignored in the release build");
		}

		public static string GetRequiredString(this in JsonElement element)
		{
			return element.GetString() ?? throw new InvalidOperationException($"The requested operation requires an element of type 'String', but the target element has type '{element.ValueKind}'.");
		}
	}
	internal class NextLinkOperationImplementation : Azure.Core.IOperation
	{
		private enum HeaderSource
		{
			None,
			OperationLocation,
			AzureAsyncOperation,
			Location
		}

		private class CompletedOperation : Azure.Core.IOperation
		{
			private readonly Azure.Core.OperationState _operationState;

			public CompletedOperation(Azure.Core.OperationState operationState)
			{
				_operationState = operationState;
			}

			public ValueTask<Azure.Core.OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken)
			{
				return new ValueTask<Azure.Core.OperationState>(_operationState);
			}
		}

		private sealed class OperationToOperationOfT<T> : Azure.Core.IOperation<T>
		{
			private readonly Azure.Core.IOperationSource<T> _operationSource;

			private readonly Azure.Core.IOperation _operation;

			public OperationToOperationOfT(Azure.Core.IOperationSource<T> operationSource, Azure.Core.IOperation operation)
			{
				_operationSource = operationSource;
				_operation = operation;
			}

			public async ValueTask<Azure.Core.OperationState<T>> UpdateStateAsync(bool async, CancellationToken cancellationToken)
			{
				Azure.Core.OperationState state = await _operation.UpdateStateAsync(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (state.HasSucceeded)
				{
					T val = ((!async) ? _operationSource.CreateResult(state.RawResponse, cancellationToken) : (await _operationSource.CreateResultAsync(state.RawResponse, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
					T value = val;
					return Azure.Core.OperationState<T>.Success(state.RawResponse, value);
				}
				if (state.HasCompleted)
				{
					return Azure.Core.OperationState<T>.Failure(state.RawResponse, state.OperationFailedException);
				}
				return Azure.Core.OperationState<T>.Pending(state.RawResponse);
			}
		}

		private const string ApiVersionParam = "api-version";

		private static readonly string[] FailureStates = new string[2] { "failed", "canceled" };

		private static readonly string[] SuccessStates = new string[1] { "succeeded" };

		private readonly HeaderSource _headerSource;

		private readonly bool _originalResponseHasLocation;

		private readonly Uri _startRequestUri;

		private readonly Azure.Core.OperationFinalStateVia _finalStateVia;

		private readonly RequestMethod _requestMethod;

		private readonly HttpPipeline _pipeline;

		private readonly string? _apiVersion;

		private string? _lastKnownLocation;

		private string _nextRequestUri;

		public static Azure.Core.IOperation Create(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, Azure.Core.OperationFinalStateVia finalStateVia, bool skipApiVersionOverride = false, string? apiVersionOverrideValue = null)
		{
			string text = null;
			text = ((apiVersionOverrideValue == null) ? ((!skipApiVersionOverride && TryGetApiVersion(startRequestUri, out var apiVersion)) ? apiVersion.ToString() : null) : apiVersionOverrideValue);
			string nextRequestUri;
			HeaderSource headerSource = GetHeaderSource(requestMethod, startRequestUri, response, text, out nextRequestUri);
			if (headerSource == HeaderSource.None && IsFinalState(response, headerSource, out Azure.Core.OperationState? failureState, out string _))
			{
				return new CompletedOperation(failureState ?? GetOperationStateFromFinalResponse(requestMethod, response));
			}
			string value;
			bool originalResponseHasLocation = response.Headers.TryGetValue("Location", out value);
			return new Azure.Core.NextLinkOperationImplementation(pipeline, requestMethod, startRequestUri, nextRequestUri, headerSource, originalResponseHasLocation, value, finalStateVia, text);
		}

		public static Azure.Core.IOperation<T> Create<T>(Azure.Core.IOperationSource<T> operationSource, HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, Response response, Azure.Core.OperationFinalStateVia finalStateVia, bool skipApiVersionOverride = false, string? apiVersionOverrideValue = null)
		{
			Azure.Core.IOperation operation = Create(pipeline, requestMethod, startRequestUri, response, finalStateVia, skipApiVersionOverride, apiVersionOverrideValue);
			return new OperationToOperationOfT<T>(operationSource, operation);
		}

		private NextLinkOperationImplementation(HttpPipeline pipeline, RequestMethod requestMethod, Uri startRequestUri, string nextRequestUri, HeaderSource headerSource, bool originalResponseHasLocation, string? lastKnownLocation, Azure.Core.OperationFinalStateVia finalStateVia, string? apiVersion)
		{
			_requestMethod = requestMethod;
			_headerSource = headerSource;
			_startRequestUri = startRequestUri;
			_nextRequestUri = nextRequestUri;
			_originalResponseHasLocation = originalResponseHasLocation;
			_lastKnownLocation = lastKnownLocation;
			_finalStateVia = finalStateVia;
			_pipeline = pipeline;
			_apiVersion = apiVersion;
		}

		public async ValueTask<Azure.Core.OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken)
		{
			Response response = await GetResponseAsync(async, _nextRequestUri, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			Azure.Core.OperationState? failureState;
			string resourceLocation;
			bool flag = IsFinalState(response, _headerSource, out failureState, out resourceLocation);
			if (failureState.HasValue)
			{
				return failureState.Value;
			}
			if (flag)
			{
				string finalUri = GetFinalUri(resourceLocation);
				Response response2 = ((finalUri == null) ? response : (await GetResponseAsync(async, finalUri, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
				Response response3 = response2;
				return GetOperationStateFromFinalResponse(_requestMethod, response3);
			}
			UpdateNextRequestUri(response.Headers);
			return Azure.Core.OperationState.Pending(response);
		}

		private static Azure.Core.OperationState GetOperationStateFromFinalResponse(RequestMethod requestMethod, Response response)
		{
			switch (response.Status)
			{
			case 201:
				if (!(requestMethod == RequestMethod.Put))
				{
					break;
				}
				goto case 200;
			case 204:
				if (!(requestMethod != RequestMethod.Put) || !(requestMethod != RequestMethod.Patch))
				{
					break;
				}
				goto case 200;
			case 200:
				return Azure.Core.OperationState.Success(response);
			}
			return Azure.Core.OperationState.Failure(response);
		}

		private void UpdateNextRequestUri(ResponseHeaders headers)
		{
			string value;
			bool flag = headers.TryGetValue("Location", out value);
			if (flag)
			{
				_lastKnownLocation = value;
			}
			switch (_headerSource)
			{
			case HeaderSource.OperationLocation:
			{
				if (headers.TryGetValue("Operation-Location", out string value2))
				{
					_nextRequestUri = AppendOrReplaceApiVersion(value2, _apiVersion);
				}
				break;
			}
			case HeaderSource.AzureAsyncOperation:
			{
				if (headers.TryGetValue("Azure-AsyncOperation", out string value3))
				{
					_nextRequestUri = AppendOrReplaceApiVersion(value3, _apiVersion);
				}
				break;
			}
			case HeaderSource.Location:
				if (flag)
				{
					_nextRequestUri = AppendOrReplaceApiVersion(value, _apiVersion);
				}
				break;
			}
		}

		internal static string AppendOrReplaceApiVersion(string uri, string? apiVersion)
		{
			if (!string.IsNullOrEmpty(apiVersion))
			{
				ReadOnlySpan<char> span = MemoryExtensions.AsSpan(uri);
				ReadOnlySpan<char> value = MemoryExtensions.AsSpan("api-version");
				int num = span.IndexOf(value);
				if (num == -1)
				{
					string text = ((span.IndexOf('?') > -1) ? "&" : "?");
					return uri + text + "api-version=" + apiVersion;
				}
				int num2 = num + "api-version".Length;
				ReadOnlySpan<char> span2 = span.Slice(num2);
				bool flag = false;
				if (span2.IndexOf('=') == 0)
				{
					span2 = span2.Slice(1);
					num2++;
					flag = true;
				}
				int num3 = span2.IndexOf('&');
				ReadOnlySpan<char> readOnlySpan = span.Slice(0, num2);
				if (num3 == -1)
				{
					return readOnlySpan.ToString() + (flag ? string.Empty : "=") + apiVersion;
				}
				ReadOnlySpan<char> readOnlySpan2 = span.Slice(num3 + num2);
				return readOnlySpan.ToString() + (flag ? string.Empty : "=") + apiVersion + readOnlySpan2;
			}
			return uri;
		}

		internal static bool TryGetApiVersion(Uri startRequestUri, out ReadOnlySpan<char> apiVersion)
		{
			apiVersion = default(ReadOnlySpan<char>);
			ReadOnlySpan<char> span = MemoryExtensions.AsSpan(startRequestUri.Query);
			int num = span.IndexOf(MemoryExtensions.AsSpan("api-version"));
			if (num == -1)
			{
				return false;
			}
			num += "api-version".Length;
			ReadOnlySpan<char> span2 = span.Slice(num);
			if (span2.IndexOf('=') == 0)
			{
				span2 = span2.Slice(1);
				num++;
				int num2 = span2.IndexOf('&');
				int length = ((num2 == -1) ? (span.Length - num) : num2);
				apiVersion = span.Slice(num, length);
				return true;
			}
			return false;
		}

		private string? GetFinalUri(string? resourceLocation)
		{
			HeaderSource headerSource = _headerSource;
			if (headerSource != HeaderSource.OperationLocation && headerSource != HeaderSource.AzureAsyncOperation)
			{
				return null;
			}
			if (_requestMethod == RequestMethod.Delete)
			{
				return null;
			}
			switch (_finalStateVia)
			{
			case Azure.Core.OperationFinalStateVia.LocationOverride:
				if (_originalResponseHasLocation)
				{
					return _lastKnownLocation;
				}
				break;
			case Azure.Core.OperationFinalStateVia.AzureAsyncOperation:
			case Azure.Core.OperationFinalStateVia.OperationLocation:
				if (_requestMethod == RequestMethod.Post)
				{
					return null;
				}
				break;
			case Azure.Core.OperationFinalStateVia.OriginalUri:
				return _startRequestUri.AbsoluteUri;
			}
			if (resourceLocation != null)
			{
				return resourceLocation;
			}
			if (_requestMethod == RequestMethod.Put || _requestMethod == RequestMethod.Patch)
			{
				return _startRequestUri.AbsoluteUri;
			}
			if (_originalResponseHasLocation)
			{
				return _lastKnownLocation;
			}
			return null;
		}

		private async ValueTask<Response> GetResponseAsync(bool async, string uri, CancellationToken cancellationToken)
		{
			using HttpMessage message = CreateRequest(uri);
			if (async)
			{
				await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			else
			{
				_pipeline.Send(message, cancellationToken);
			}
			return message.Response;
		}

		private HttpMessage CreateRequest(string uri)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			if (Uri.TryCreate(uri, UriKind.Absolute, out var result) && result.Scheme != "file")
			{
				request.Uri.Reset(result);
				return httpMessage;
			}
			request.Uri.Reset(new Uri(_startRequestUri, uri));
			return httpMessage;
		}

		private static bool IsFinalState(Response response, HeaderSource headerSource, out Azure.Core.OperationState? failureState, out string? resourceLocation)
		{
			failureState = null;
			resourceLocation = null;
			if (headerSource == HeaderSource.Location)
			{
				return response.Status != 202;
			}
			int status = response.Status;
			if (status >= 200 && status <= 204)
			{
				Stream contentStream = response.ContentStream;
				if (contentStream != null && contentStream.Length > 0)
				{
					try
					{
						using JsonDocument jsonDocument = JsonDocument.Parse(response.ContentStream);
						JsonElement rootElement = jsonDocument.RootElement;
						JsonElement value;
						switch (headerSource)
						{
						default:
							goto end_IL_006c;
						case HeaderSource.None:
						{
							if (rootElement.TryGetProperty("properties", out var value2) && value2.TryGetProperty("provisioningState", out value))
							{
								break;
							}
							goto end_IL_006c;
						}
						case HeaderSource.OperationLocation:
							if (rootElement.TryGetProperty("status", out value))
							{
								break;
							}
							goto end_IL_006c;
						case HeaderSource.AzureAsyncOperation:
							if (rootElement.TryGetProperty("status", out value))
							{
								break;
							}
							goto end_IL_006c;
						}
						string value3 = value.GetRequiredString().ToLowerInvariant();
						if (FailureStates.Contains<string>(value3))
						{
							failureState = Azure.Core.OperationState.Failure(response);
							return true;
						}
						if (!SuccessStates.Contains<string>(value3))
						{
							return false;
						}
						if ((headerSource == HeaderSource.OperationLocation || headerSource == HeaderSource.AzureAsyncOperation) && rootElement.TryGetProperty("resourceLocation", out var value4))
						{
							resourceLocation = value4.GetString();
						}
						return true;
						end_IL_006c:;
					}
					finally
					{
						response.ContentStream.Position = 0L;
					}
				}
				if (headerSource == HeaderSource.None)
				{
					return true;
				}
			}
			failureState = Azure.Core.OperationState.Failure(response);
			return true;
		}

		private static bool ShouldIgnoreHeader(RequestMethod method, Response response)
		{
			if (method.Method == RequestMethod.Patch.Method)
			{
				return response.Status == 200;
			}
			return false;
		}

		private static HeaderSource GetHeaderSource(RequestMethod requestMethod, Uri requestUri, Response response, string? apiVersion, out string nextRequestUri)
		{
			if (ShouldIgnoreHeader(requestMethod, response))
			{
				nextRequestUri = requestUri.AbsoluteUri;
				return HeaderSource.None;
			}
			ResponseHeaders headers = response.Headers;
			if (headers.TryGetValue("Operation-Location", out string value))
			{
				nextRequestUri = AppendOrReplaceApiVersion(value, apiVersion);
				return HeaderSource.OperationLocation;
			}
			if (headers.TryGetValue("Azure-AsyncOperation", out string value2))
			{
				nextRequestUri = AppendOrReplaceApiVersion(value2, apiVersion);
				return HeaderSource.AzureAsyncOperation;
			}
			if (headers.TryGetValue("Location", out string value3))
			{
				nextRequestUri = AppendOrReplaceApiVersion(value3, apiVersion);
				return HeaderSource.Location;
			}
			nextRequestUri = requestUri.AbsoluteUri;
			return HeaderSource.None;
		}
	}
	internal enum OperationFinalStateVia
	{
		AzureAsyncOperation,
		Location,
		OriginalUri,
		OperationLocation,
		LocationOverride
	}
	internal static class OperationHelpers
	{
		public static T GetValue<T>(ref T? value) where T : class
		{
			if (value == null)
			{
				throw new InvalidOperationException("The operation has not completed yet.");
			}
			return value;
		}

		public static T GetValue<T>(ref T? value) where T : struct
		{
			if (!value.HasValue)
			{
				throw new InvalidOperationException("The operation has not completed yet.");
			}
			return value.Value;
		}

		public static async ValueTask<Response<TResult>> DefaultWaitForCompletionAsync<TResult>(this Operation<TResult> operation, CancellationToken cancellationToken) where TResult : notnull
		{
			return await new Azure.Core.OperationPoller().WaitForCompletionAsync(operation, null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public static async ValueTask<Response<TResult>> DefaultWaitForCompletionAsync<TResult>(this Operation<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken) where TResult : notnull
		{
			return await new Azure.Core.OperationPoller().WaitForCompletionAsync(operation, pollingInterval, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public static Response<TResult> DefaultWaitForCompletion<TResult>(this Operation<TResult> operation, CancellationToken cancellationToken) where TResult : notnull
		{
			return new Azure.Core.OperationPoller().WaitForCompletion(operation, null, cancellationToken);
		}

		public static Response<TResult> DefaultWaitForCompletion<TResult>(this Operation<TResult> operation, TimeSpan pollingInterval, CancellationToken cancellationToken) where TResult : notnull
		{
			return new Azure.Core.OperationPoller().WaitForCompletion(operation, pollingInterval, cancellationToken);
		}

		public static async ValueTask<Response> DefaultWaitForCompletionResponseAsync(this Operation operation, CancellationToken cancellationToken)
		{
			return await new Azure.Core.OperationPoller().WaitForCompletionResponseAsync(operation, null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public static async ValueTask<Response> DefaultWaitForCompletionResponseAsync(this Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken)
		{
			return await new Azure.Core.OperationPoller().WaitForCompletionResponseAsync(operation, pollingInterval, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public static Response DefaultWaitForCompletionResponse(this Operation operation, CancellationToken cancellationToken)
		{
			return new Azure.Core.OperationPoller().WaitForCompletionResponse(operation, null, cancellationToken);
		}

		public static Response DefaultWaitForCompletionResponse(this Operation operation, TimeSpan pollingInterval, CancellationToken cancellationToken)
		{
			return new Azure.Core.OperationPoller().WaitForCompletionResponse(operation, pollingInterval, cancellationToken);
		}
	}
	internal class OperationInternal : Azure.Core.OperationInternalBase
	{
		private class OperationToOperationOfTProxy : Azure.Core.IOperation<Azure.Core.VoidValue>
		{
			private readonly Azure.Core.IOperation _operation;

			public OperationToOperationOfTProxy(Azure.Core.IOperation operation)
			{
				_operation = operation;
			}

			public async ValueTask<Azure.Core.OperationState<Azure.Core.VoidValue>> UpdateStateAsync(bool async, CancellationToken cancellationToken)
			{
				Azure.Core.OperationState operationState = await _operation.UpdateStateAsync(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (!operationState.HasCompleted)
				{
					return Azure.Core.OperationState<Azure.Core.VoidValue>.Pending(operationState.RawResponse);
				}
				if (operationState.HasSucceeded)
				{
					return Azure.Core.OperationState<Azure.Core.VoidValue>.Success(operationState.RawResponse, default(Azure.Core.VoidValue));
				}
				return Azure.Core.OperationState<Azure.Core.VoidValue>.Failure(operationState.RawResponse, operationState.OperationFailedException);
			}
		}

		private readonly Azure.Core.OperationInternal<Azure.Core.VoidValue> _internalOperation;

		public override Response RawResponse => _internalOperation.RawResponse;

		public override bool HasCompleted => _internalOperation.HasCompleted;

		public static Azure.Core.OperationInternal Succeeded(Response rawResponse)
		{
			return new Azure.Core.OperationInternal(Azure.Core.OperationState.Success(rawResponse));
		}

		public static Azure.Core.OperationInternal Failed(Response rawResponse, RequestFailedException operationFailedException)
		{
			return new Azure.Core.OperationInternal(Azure.Core.OperationState.Failure(rawResponse, operationFailedException));
		}

		public OperationInternal(Azure.Core.IOperation operation, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, Response rawResponse, string? operationTypeName = null, IEnumerable<KeyValuePair<string, string>>? scopeAttributes = null, DelayStrategy? fallbackStrategy = null)
			: base(clientDiagnostics, operationTypeName ?? operation.GetType().Name, scopeAttributes, fallbackStrategy)
		{
			_internalOperation = new Azure.Core.OperationInternal<Azure.Core.VoidValue>(new OperationToOperationOfTProxy(operation), clientDiagnostics, rawResponse, operationTypeName ?? operation.GetType().Name, scopeAttributes, fallbackStrategy);
		}

		private OperationInternal(Azure.Core.OperationState finalState)
			: base(finalState.RawResponse)
		{
			_internalOperation = (finalState.HasSucceeded ? Azure.Core.OperationInternal<Azure.Core.VoidValue>.Succeeded(finalState.RawResponse, default(Azure.Core.VoidValue)) : Azure.Core.OperationInternal<Azure.Core.VoidValue>.Failed(finalState.RawResponse, finalState.OperationFailedException));
		}

		protected override async ValueTask<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken)
		{
			return (!async) ? _internalOperation.UpdateStatus(cancellationToken) : (await _internalOperation.UpdateStatusAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}
	}
	internal interface IOperation
	{
		ValueTask<Azure.Core.OperationState> UpdateStateAsync(bool async, CancellationToken cancellationToken);
	}
	internal readonly struct OperationState
	{
		public Response RawResponse { get; }

		public bool HasCompleted { get; }

		public bool HasSucceeded { get; }

		public RequestFailedException? OperationFailedException { get; }

		private OperationState(Response rawResponse, bool hasCompleted, bool hasSucceeded, RequestFailedException? operationFailedException)
		{
			RawResponse = rawResponse;
			HasCompleted = hasCompleted;
			HasSucceeded = hasSucceeded;
			OperationFailedException = operationFailedException;
		}

		public static Azure.Core.OperationState Success(Response rawResponse)
		{
			Azure.Core.Argument.AssertNotNull(rawResponse, "rawResponse");
			return new Azure.Core.OperationState(rawResponse, hasCompleted: true, hasSucceeded: true, null);
		}

		public static Azure.Core.OperationState Failure(Response rawResponse, RequestFailedException? operationFailedException = null)
		{
			Azure.Core.Argument.AssertNotNull(rawResponse, "rawResponse");
			return new Azure.Core.OperationState(rawResponse, hasCompleted: true, hasSucceeded: false, operationFailedException);
		}

		public static Azure.Core.OperationState Pending(Response rawResponse)
		{
			Azure.Core.Argument.AssertNotNull(rawResponse, "rawResponse");
			return new Azure.Core.OperationState(rawResponse, hasCompleted: false, hasSucceeded: false, null);
		}
	}
	internal abstract class OperationInternalBase
	{
		private readonly Azure.Core.Pipeline.ClientDiagnostics _diagnostics;

		private readonly IReadOnlyDictionary<string, string>? _scopeAttributes;

		private readonly DelayStrategy? _fallbackStrategy;

		private readonly Azure.Core.AsyncLockWithValue<Response> _responseLock;

		private readonly string _waitForCompletionResponseScopeName;

		protected readonly string _updateStatusScopeName;

		protected readonly string _waitForCompletionScopeName;

		public abstract Response RawResponse { get; }

		public abstract bool HasCompleted { get; }

		protected OperationInternalBase(Response rawResponse)
		{
			_diagnostics = new Azure.Core.Pipeline.ClientDiagnostics(ClientOptions.Default);
			_updateStatusScopeName = string.Empty;
			_waitForCompletionResponseScopeName = string.Empty;
			_waitForCompletionScopeName = string.Empty;
			_scopeAttributes = null;
			_fallbackStrategy = null;
			_responseLock = new Azure.Core.AsyncLockWithValue<Response>(rawResponse);
		}

		protected OperationInternalBase(Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, string operationTypeName, IEnumerable<KeyValuePair<string, string>>? scopeAttributes = null, DelayStrategy? fallbackStrategy = null)
		{
			_diagnostics = clientDiagnostics;
			_updateStatusScopeName = operationTypeName + ".UpdateStatus";
			_waitForCompletionResponseScopeName = operationTypeName + ".WaitForCompletionResponse";
			_waitForCompletionScopeName = operationTypeName + ".WaitForCompletion";
			_scopeAttributes = scopeAttributes?.ToDictionary<KeyValuePair<string, string>, string, string>((KeyValuePair<string, string> kvp) => kvp.Key, (KeyValuePair<string, string> kvp) => kvp.Value);
			_fallbackStrategy = fallbackStrategy;
			_responseLock = new Azure.Core.AsyncLockWithValue<Response>();
		}

		public async ValueTask<Response> UpdateStatusAsync(CancellationToken cancellationToken)
		{
			return await UpdateStatusAsync(async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public Response UpdateStatus(CancellationToken cancellationToken)
		{
			return UpdateStatusAsync(async: false, cancellationToken).EnsureCompleted();
		}

		public async ValueTask<Response> WaitForCompletionResponseAsync(CancellationToken cancellationToken)
		{
			return await WaitForCompletionResponseAsync(async: true, null, _waitForCompletionResponseScopeName, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async ValueTask<Response> WaitForCompletionResponseAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
		{
			return await WaitForCompletionResponseAsync(async: true, pollingInterval, _waitForCompletionResponseScopeName, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public Response WaitForCompletionResponse(CancellationToken cancellationToken)
		{
			return WaitForCompletionResponseAsync(async: false, null, _waitForCompletionResponseScopeName, cancellationToken).EnsureCompleted();
		}

		public Response WaitForCompletionResponse(TimeSpan pollingInterval, CancellationToken cancellationToken)
		{
			return WaitForCompletionResponseAsync(async: false, pollingInterval, _waitForCompletionResponseScopeName, cancellationToken).EnsureCompleted();
		}

		protected async ValueTask<Response> WaitForCompletionResponseAsync(bool async, TimeSpan? pollingInterval, string scopeName, CancellationToken cancellationToken)
		{
			using Azure.Core.AsyncLockWithValue<Response>.LockOrValue lockOrValue = await _responseLock.GetLockOrValueAsync(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (lockOrValue.HasValue)
			{
				return lockOrValue.Value;
			}
			using Azure.Core.Pipeline.DiagnosticScope scope = CreateScope(scopeName);
			_ = 1;
			try
			{
				Azure.Core.OperationPoller operationPoller = new Azure.Core.OperationPoller(_fallbackStrategy);
				Response response = ((!async) ? operationPoller.WaitForCompletionResponse(this, pollingInterval, cancellationToken) : (await operationPoller.WaitForCompletionResponseAsync(this, pollingInterval, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
				Response response2 = response;
				lockOrValue.SetValue(response2);
				return response2;
			}
			catch (Exception exception)
			{
				scope.Failed(exception);
				throw;
			}
		}

		protected abstract ValueTask<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken);

		protected Azure.Core.Pipeline.DiagnosticScope CreateScope(string scopeName)
		{
			Azure.Core.Pipeline.DiagnosticScope result = _diagnostics.CreateScope(scopeName);
			if (_scopeAttributes != null)
			{
				foreach (KeyValuePair<string, string> scopeAttribute in _scopeAttributes)
				{
					result.AddAttribute(scopeAttribute.Key, scopeAttribute.Value);
				}
			}
			result.Start();
			return result;
		}
	}
	internal class OperationInternal<T> : Azure.Core.OperationInternalBase
	{
		private class FinalOperation : Azure.Core.IOperation<T>
		{
			public ValueTask<Azure.Core.OperationState<T>> UpdateStateAsync(bool async, CancellationToken cancellationToken)
			{
				throw new NotSupportedException("The operation has already completed");
			}
		}

		private readonly Azure.Core.IOperation<T> _operation;

		private readonly Azure.Core.AsyncLockWithValue<Azure.Core.OperationState<T>> _stateLock;

		private Response _rawResponse;

		public override Response RawResponse
		{
			get
			{
				if (!_stateLock.TryGetValue(out var value))
				{
					return _rawResponse;
				}
				return value.RawResponse;
			}
		}

		public override bool HasCompleted => _stateLock.HasValue;

		public bool HasValue
		{
			get
			{
				if (_stateLock.TryGetValue(out var value))
				{
					return value.HasSucceeded;
				}
				return false;
			}
		}

		public T Value
		{
			get
			{
				if (_stateLock.TryGetValue(out var value))
				{
					if (value.HasSucceeded)
					{
						return value.Value;
					}
					throw value.OperationFailedException;
				}
				throw new InvalidOperationException("The operation has not completed yet.");
			}
		}

		public static Azure.Core.OperationInternal<T> Succeeded(Response rawResponse, T value)
		{
			return new Azure.Core.OperationInternal<T>(Azure.Core.OperationState<T>.Success(rawResponse, value));
		}

		public static Azure.Core.OperationInternal<T> Failed(Response rawResponse, RequestFailedException operationFailedException)
		{
			return new Azure.Core.OperationInternal<T>(Azure.Core.OperationState<T>.Failure(rawResponse, operationFailedException));
		}

		public OperationInternal(Azure.Core.IOperation<T> operation, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, Response rawResponse, string? operationTypeName = null, IEnumerable<KeyValuePair<string, string>>? scopeAttributes = null, DelayStrategy? fallbackStrategy = null)
			: base(clientDiagnostics, operationTypeName ?? operation.GetType().Name, scopeAttributes, fallbackStrategy)
		{
			_operation = operation;
			_rawResponse = rawResponse;
			_stateLock = new Azure.Core.AsyncLockWithValue<Azure.Core.OperationState<T>>();
		}

		private OperationInternal(Azure.Core.OperationState<T> finalState)
			: base(finalState.RawResponse)
		{
			_operation = new FinalOperation();
			_rawResponse = finalState.RawResponse;
			_stateLock = new Azure.Core.AsyncLockWithValue<Azure.Core.OperationState<T>>(finalState);
		}

		public async ValueTask<Response<T>> WaitForCompletionAsync(CancellationToken cancellationToken)
		{
			return await WaitForCompletionAsync(async: true, null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async ValueTask<Response<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
		{
			return await WaitForCompletionAsync(async: true, pollingInterval, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public Response<T> WaitForCompletion(CancellationToken cancellationToken)
		{
			return WaitForCompletionAsync(async: false, null, cancellationToken).EnsureCompleted();
		}

		public Response<T> WaitForCompletion(TimeSpan pollingInterval, CancellationToken cancellationToken)
		{
			return WaitForCompletionAsync(async: false, pollingInterval, cancellationToken).EnsureCompleted();
		}

		private async ValueTask<Response<T>> WaitForCompletionAsync(bool async, TimeSpan? pollingInterval, CancellationToken cancellationToken)
		{
			Response response = await WaitForCompletionResponseAsync(async, pollingInterval, _waitForCompletionScopeName, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return Response.FromValue(Value, response);
		}

		protected override async ValueTask<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken)
		{
			using Azure.Core.AsyncLockWithValue<Azure.Core.OperationState<T>>.LockOrValue asyncLock = await _stateLock.GetLockOrValueAsync(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (asyncLock.HasValue)
			{
				return GetResponseFromState(asyncLock.Value);
			}
			using Azure.Core.Pipeline.DiagnosticScope scope = CreateScope(_updateStatusScopeName);
			_ = 1;
			try
			{
				Azure.Core.OperationState<T> operationState = await _operation.UpdateStateAsync(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (!operationState.HasCompleted)
				{
					Interlocked.Exchange(ref _rawResponse, operationState.RawResponse);
					return operationState.RawResponse;
				}
				if (!operationState.HasSucceeded && operationState.OperationFailedException == null)
				{
					operationState = Azure.Core.OperationState<T>.Failure(operationState.RawResponse, new RequestFailedException(operationState.RawResponse));
				}
				asyncLock.SetValue(operationState);
				return GetResponseFromState(operationState);
			}
			catch (Exception exception)
			{
				scope.Failed(exception);
				throw;
			}
		}

		private static Response GetResponseFromState(Azure.Core.OperationState<T> state)
		{
			if (state.HasSucceeded)
			{
				return state.RawResponse;
			}
			throw state.OperationFailedException;
		}
	}
	internal interface IOperation<T>
	{
		ValueTask<Azure.Core.OperationState<T>> UpdateStateAsync(bool async, CancellationToken cancellationToken);
	}
	internal readonly struct OperationState<T>
	{
		public Response RawResponse { get; }

		public bool HasCompleted { get; }

		public bool HasSucceeded { get; }

		public T? Value { get; }

		public RequestFailedException? OperationFailedException { get; }

		private OperationState(Response rawResponse, bool hasCompleted, bool hasSucceeded, T? value, RequestFailedException? operationFailedException)
		{
			RawResponse = rawResponse;
			HasCompleted = hasCompleted;
			HasSucceeded = hasSucceeded;
			Value = value;
			OperationFailedException = operationFailedException;
		}

		public static Azure.Core.OperationState<T> Success(Response rawResponse, T value)
		{
			Azure.Core.Argument.AssertNotNull(rawResponse, "rawResponse");
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return new Azure.Core.OperationState<T>(rawResponse, hasCompleted: true, hasSucceeded: true, value, null);
		}

		public static Azure.Core.OperationState<T> Failure(Response rawResponse, RequestFailedException? operationFailedException = null)
		{
			Azure.Core.Argument.AssertNotNull(rawResponse, "rawResponse");
			return new Azure.Core.OperationState<T>(rawResponse, hasCompleted: true, hasSucceeded: false, default(T), operationFailedException);
		}

		public static Azure.Core.OperationState<T> Pending(Response rawResponse)
		{
			Azure.Core.Argument.AssertNotNull(rawResponse, "rawResponse");
			return new Azure.Core.OperationState<T>(rawResponse, hasCompleted: false, hasSucceeded: false, default(T), null);
		}
	}
	internal sealed class OperationPoller
	{
		private readonly DelayStrategy _delayStrategy;

		public OperationPoller(DelayStrategy? strategy = null)
		{
			_delayStrategy = strategy ?? new Azure.Core.FixedDelayWithNoJitterStrategy();
		}

		public ValueTask<Response> WaitForCompletionResponseAsync(Operation operation, TimeSpan? delayHint, CancellationToken cancellationToken)
		{
			return WaitForCompletionAsync(async: true, operation, delayHint, cancellationToken);
		}

		public Response WaitForCompletionResponse(Operation operation, TimeSpan? delayHint, CancellationToken cancellationToken)
		{
			return WaitForCompletionAsync(async: false, operation, delayHint, cancellationToken).EnsureCompleted();
		}

		public ValueTask<Response> WaitForCompletionResponseAsync(Azure.Core.OperationInternalBase operation, TimeSpan? delayHint, CancellationToken cancellationToken)
		{
			return WaitForCompletionAsync(async: true, operation, delayHint, cancellationToken);
		}

		public Response WaitForCompletionResponse(Azure.Core.OperationInternalBase operation, TimeSpan? delayHint, CancellationToken cancellationToken)
		{
			return WaitForCompletionAsync(async: false, operation, delayHint, cancellationToken).EnsureCompleted();
		}

		public async ValueTask<Response<T>> WaitForCompletionAsync<T>(Operation<T> operation, TimeSpan? delayHint, CancellationToken cancellationToken) where T : notnull
		{
			Response response = await WaitForCompletionAsync(async: true, operation, delayHint, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return Response.FromValue(operation.Value, response);
		}

		public Response<T> WaitForCompletion<T>(Operation<T> operation, TimeSpan? delayHint, CancellationToken cancellationToken) where T : notnull
		{
			Response response = WaitForCompletionAsync(async: false, operation, delayHint, cancellationToken).EnsureCompleted();
			return Response.FromValue(operation.Value, response);
		}

		public async ValueTask<Response<T>> WaitForCompletionAsync<T>(Azure.Core.OperationInternal<T> operation, TimeSpan? delayHint, CancellationToken cancellationToken) where T : notnull
		{
			Response response = await WaitForCompletionAsync(async: true, operation, delayHint, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return Response.FromValue(operation.Value, response);
		}

		public Response<T> WaitForCompletion<T>(Azure.Core.OperationInternal<T> operation, TimeSpan? delayHint, CancellationToken cancellationToken) where T : notnull
		{
			Response response = WaitForCompletionAsync(async: false, operation, delayHint, cancellationToken).EnsureCompleted();
			return Response.FromValue(operation.Value, response);
		}

		private async ValueTask<Response> WaitForCompletionAsync(bool async, Operation operation, TimeSpan? delayHint, CancellationToken cancellationToken)
		{
			int retryNumber = 0;
			while (true)
			{
				Response response = ((!async) ? operation.UpdateStatus(cancellationToken) : (await operation.UpdateStatusAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
				Response response2 = response;
				if (operation.HasCompleted)
				{
					break;
				}
				DelayStrategy delayStrategy = (delayHint.HasValue ? new Azure.Core.FixedDelayWithNoJitterStrategy(delayHint.Value) : _delayStrategy);
				int num = retryNumber + 1;
				retryNumber = num;
				await Delay(async, delayStrategy.GetNextDelay(response2, num), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			return operation.GetRawResponse();
		}

		private async ValueTask<Response> WaitForCompletionAsync(bool async, Azure.Core.OperationInternalBase operation, TimeSpan? delayHint, CancellationToken cancellationToken)
		{
			int retryNumber = 0;
			while (true)
			{
				Response response = ((!async) ? operation.UpdateStatus(cancellationToken) : (await operation.UpdateStatusAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
				Response response2 = response;
				if (operation.HasCompleted)
				{
					break;
				}
				DelayStrategy delayStrategy = (delayHint.HasValue ? new Azure.Core.FixedDelayWithNoJitterStrategy(delayHint.Value) : _delayStrategy);
				int num = retryNumber + 1;
				retryNumber = num;
				await Delay(async, delayStrategy.GetNextDelay(response2, num), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			return operation.RawResponse;
		}

		private static async ValueTask Delay(bool async, TimeSpan delay, CancellationToken cancellationToken)
		{
			if (async)
			{
				await Task.Delay(delay, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			else if (cancellationToken.CanBeCanceled)
			{
				if (cancellationToken.WaitHandle.WaitOne(delay))
				{
					cancellationToken.ThrowIfCancellationRequested();
				}
			}
			else
			{
				Thread.Sleep(delay);
			}
		}
	}
	internal static class Optional
	{
		public static bool IsCollectionDefined<T>(IEnumerable<T> collection)
		{
			if (collection is Azure.Core.ChangeTrackingList<T> changeTrackingList)
			{
				return !changeTrackingList.IsUndefined;
			}
			return true;
		}

		public static bool IsCollectionDefined<TKey, TValue>(IReadOnlyDictionary<TKey, TValue> collection)
		{
			if (collection is Azure.Core.ChangeTrackingDictionary<TKey, TValue> changeTrackingDictionary)
			{
				return !changeTrackingDictionary.IsUndefined;
			}
			return true;
		}

		public static bool IsCollectionDefined<TKey, TValue>(IDictionary<TKey, TValue> collection)
		{
			if (collection is Azure.Core.ChangeTrackingDictionary<TKey, TValue> changeTrackingDictionary)
			{
				return !changeTrackingDictionary.IsUndefined;
			}
			return true;
		}

		public static bool IsDefined<T>(T? value) where T : struct
		{
			return value.HasValue;
		}

		public static bool IsDefined(object value)
		{
			return value != null;
		}

		public static bool IsDefined(string value)
		{
			return value != null;
		}

		public static bool IsDefined(JsonElement value)
		{
			return value.ValueKind != JsonValueKind.Undefined;
		}

		public static IReadOnlyDictionary<TKey, TValue> ToDictionary<TKey, TValue>(Azure.Core.Optional<IReadOnlyDictionary<TKey, TValue>> optional)
		{
			if (optional.HasValue)
			{
				return optional.Value;
			}
			return new Azure.Core.ChangeTrackingDictionary<TKey, TValue>(optional);
		}

		public static IDictionary<TKey, TValue> ToDictionary<TKey, TValue>(Azure.Core.Optional<IDictionary<TKey, TValue>> optional)
		{
			if (optional.HasValue)
			{
				return optional.Value;
			}
			return new Azure.Core.ChangeTrackingDictionary<TKey, TValue>(optional);
		}

		public static IReadOnlyList<T> ToList<T>(Azure.Core.Optional<IReadOnlyList<T>> optional)
		{
			if (optional.HasValue)
			{
				return optional.Value;
			}
			return new Azure.Core.ChangeTrackingList<T>(optional);
		}

		public static IList<T> ToList<T>(Azure.Core.Optional<IList<T>> optional)
		{
			if (optional.HasValue)
			{
				return optional.Value;
			}
			return new Azure.Core.ChangeTrackingList<T>(optional);
		}

		public static T? ToNullable<T>(Azure.Core.Optional<T> optional) where T : struct
		{
			if (optional.HasValue)
			{
				return optional.Value;
			}
			return null;
		}

		public static T? ToNullable<T>(Azure.Core.Optional<T?> optional) where T : struct
		{
			return optional.Value;
		}
	}
	internal readonly struct Optional<T>
	{
		public T Value { get; }

		public bool HasValue { get; }

		public Optional(T value)
		{
			this = default(Azure.Core.Optional<T>);
			Value = value;
			HasValue = true;
		}

		public static implicit operator Azure.Core.Optional<T>(T value)
		{
			return new Azure.Core.Optional<T>(value);
		}

		public static implicit operator T(Azure.Core.Optional<T> optional)
		{
			return optional.Value;
		}
	}
	internal static class Page
	{
		public static Page<T> FromValues<T>(IEnumerable<T> values, string continuationToken, Response response)
		{
			return Page<T>.FromValues(values.ToList(), continuationToken, response);
		}
	}
	internal static class PageableHelpers
	{
		internal class FuncAsyncPageable<T> : AsyncPageable<T> where T : notnull
		{
			private readonly Func<string?, int?, Task<Page<T>>> _firstPageFunc;

			private readonly Func<string?, int?, Task<Page<T>>>? _nextPageFunc;

			private readonly int? _defaultPageSize;

			public FuncAsyncPageable(Func<string?, int?, Task<Page<T>>> firstPageFunc, Func<string?, int?, Task<Page<T>>>? nextPageFunc, int? defaultPageSize = null)
			{
				_firstPageFunc = firstPageFunc;
				_nextPageFunc = nextPageFunc;
				_defaultPageSize = defaultPageSize;
			}

			public override async IAsyncEnumerable<Page<T>> AsPages(string? continuationToken = null, int? pageSizeHint = null)
			{
				Func<string, int?, Task<Page<T>>> func = (string.IsNullOrEmpty(continuationToken) ? _firstPageFunc : _nextPageFunc);
				if (func != null)
				{
					int? pageSize = pageSizeHint ?? _defaultPageSize;
					do
					{
						Page<T> pageResponse = await func(continuationToken, pageSize).ConfigureAwait(continueOnCapturedContext: false);
						yield return pageResponse;
						continuationToken = pageResponse.ContinuationToken;
						func = _nextPageFunc;
					}
					while (!string.IsNullOrEmpty(continuationToken) && func != null);
				}
			}
		}

		internal class FuncPageable<T> : Pageable<T> where T : notnull
		{
			private readonly Func<string?, int?, Page<T>> _firstPageFunc;

			private readonly Func<string?, int?, Page<T>>? _nextPageFunc;

			private readonly int? _defaultPageSize;

			public FuncPageable(Func<string?, int?, Page<T>> firstPageFunc, Func<string?, int?, Page<T>>? nextPageFunc, int? defaultPageSize = null)
			{
				_firstPageFunc = firstPageFunc;
				_nextPageFunc = nextPageFunc;
				_defaultPageSize = defaultPageSize;
			}

			public override IEnumerable<Page<T>> AsPages(string? continuationToken = null, int? pageSizeHint = null)
			{
				Func<string, int?, Page<T>> func = (string.IsNullOrEmpty(continuationToken) ? _firstPageFunc : _nextPageFunc);
				if (func != null)
				{
					int? pageSize = pageSizeHint ?? _defaultPageSize;
					do
					{
						Page<T> pageResponse = func(continuationToken, pageSize);
						yield return pageResponse;
						continuationToken = pageResponse.ContinuationToken;
						func = _nextPageFunc;
					}
					while (!string.IsNullOrEmpty(continuationToken) && func != null);
				}
			}
		}

		internal class AsyncPageableWrapper<T> : AsyncPageable<T> where T : notnull
		{
			private readonly PageableImplementation<T> _implementation;

			public AsyncPageableWrapper(PageableImplementation<T> implementation)
			{
				_implementation = implementation;
			}

			public override IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default(CancellationToken))
			{
				return _implementation.GetAsyncEnumerator(cancellationToken);
			}

			public override IAsyncEnumerable<Page<T>> AsPages(string? continuationToken = null, int? pageSizeHint = null)
			{
				return _implementation.AsPagesAsync(continuationToken, pageSizeHint, default(CancellationToken));
			}
		}

		internal class PageableWrapper<T> : Pageable<T> where T : notnull
		{
			private readonly PageableImplementation<T> _implementation;

			public PageableWrapper(PageableImplementation<T> implementation)
			{
				_implementation = implementation;
			}

			public override IEnumerator<T> GetEnumerator()
			{
				return _implementation.GetEnumerator();
			}

			public override IEnumerable<Page<T>> AsPages(string? continuationToken = null, int? pageSizeHint = null)
			{
				return _implementation.AsPages(continuationToken, pageSizeHint);
			}
		}

		internal class PageableImplementation<T>
		{
			private readonly Response? _initialResponse;

			private readonly Func<int?, HttpMessage>? _createFirstPageRequest;

			private readonly Func<int?, string, HttpMessage>? _createNextPageRequest;

			private readonly HttpPipeline _pipeline;

			private readonly Azure.Core.Pipeline.ClientDiagnostics _clientDiagnostics;

			private readonly Func<JsonElement, T>? _valueFactory;

			private readonly Func<Response, (List<T>? Values, string? NextLink)>? _responseParser;

			private readonly string _scopeName;

			private readonly byte[] _itemPropertyName;

			private readonly byte[] _nextLinkPropertyName;

			private readonly int? _defaultPageSize;

			private readonly CancellationToken _cancellationToken;

			private readonly ErrorOptions? _errorOptions;

			public PageableImplementation(Response? initialResponse, Func<int?, HttpMessage>? createFirstPageRequest, Func<int?, string, HttpMessage>? createNextPageRequest, Func<JsonElement, T> valueFactory, HttpPipeline pipeline, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, int? defaultPageSize, CancellationToken? cancellationToken, ErrorOptions? errorOptions)
			{
				_initialResponse = initialResponse;
				_createFirstPageRequest = createFirstPageRequest;
				_createNextPageRequest = createNextPageRequest;
				_valueFactory = ((typeof(T) == typeof(BinaryData)) ? null : valueFactory);
				_responseParser = null;
				_pipeline = pipeline;
				_clientDiagnostics = clientDiagnostics;
				_scopeName = scopeName;
				_itemPropertyName = ((itemPropertyName != null) ? Encoding.UTF8.GetBytes(itemPropertyName) : DefaultItemPropertyName);
				_nextLinkPropertyName = ((nextLinkPropertyName != null) ? Encoding.UTF8.GetBytes(nextLinkPropertyName) : DefaultNextLinkPropertyName);
				_defaultPageSize = defaultPageSize;
				_cancellationToken = cancellationToken.GetValueOrDefault();
				_errorOptions = errorOptions.GetValueOrDefault();
			}

			public PageableImplementation(Func<int?, HttpMessage>? createFirstPageRequest, Func<int?, string, HttpMessage>? createNextPageRequest, Func<Response, (List<T>? Values, string? NextLink)> responseParser, HttpPipeline pipeline, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, string scopeName, int? defaultPageSize, RequestContext? requestContext)
			{
				_createFirstPageRequest = createFirstPageRequest;
				_createNextPageRequest = createNextPageRequest;
				_valueFactory = null;
				_responseParser = responseParser;
				_pipeline = pipeline;
				_clientDiagnostics = clientDiagnostics;
				_scopeName = scopeName;
				_itemPropertyName = Array.Empty<byte>();
				_nextLinkPropertyName = Array.Empty<byte>();
				_defaultPageSize = defaultPageSize;
				_cancellationToken = requestContext?.CancellationToken ?? default(CancellationToken);
				_errorOptions = requestContext?.ErrorOptions ?? ErrorOptions.Default;
			}

			public async IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default(CancellationToken))
			{
				string nextLink = null;
				do
				{
					if (!TryGetItemsFromResponse(await GetNextResponseAsync(null, nextLink, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), out nextLink, out JsonElement.ArrayEnumerator jsonArrayEnumerator, out List<T> items))
					{
						continue;
					}
					if (_valueFactory != null)
					{
						foreach (JsonElement item in jsonArrayEnumerator)
						{
							yield return _valueFactory(item);
						}
						continue;
					}
					foreach (T item2 in items)
					{
						yield return item2;
					}
				}
				while (!string.IsNullOrEmpty(nextLink));
			}

			public async IAsyncEnumerable<Page<T>> AsPagesAsync(string? continuationToken, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken)
			{
				string nextLink = continuationToken;
				do
				{
					Response response = await GetNextResponseAsync(pageSizeHint, nextLink, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					if (response == null)
					{
						break;
					}
					yield return CreatePage(response, out nextLink);
				}
				while (!string.IsNullOrEmpty(nextLink));
			}

			public IEnumerator<T> GetEnumerator()
			{
				string nextLink = null;
				do
				{
					Response nextResponse = GetNextResponse(null, nextLink);
					if (!TryGetItemsFromResponse(nextResponse, out nextLink, out JsonElement.ArrayEnumerator jsonArrayEnumerator, out List<T> items))
					{
						continue;
					}
					if (_valueFactory != null)
					{
						foreach (JsonElement item in jsonArrayEnumerator)
						{
							yield return _valueFactory(item);
						}
						continue;
					}
					foreach (T item2 in items)
					{
						yield return item2;
					}
				}
				while (!string.IsNullOrEmpty(nextLink));
			}

			public IEnumerable<Page<T>> AsPages(string? continuationToken, int? pageSizeHint)
			{
				string nextLink = continuationToken;
				do
				{
					Response nextResponse = GetNextResponse(pageSizeHint, nextLink);
					if (nextResponse == null)
					{
						break;
					}
					yield return CreatePage(nextResponse, out nextLink);
				}
				while (!string.IsNullOrEmpty(nextLink));
			}

			private Response? GetNextResponse(int? pageSizeHint, string? nextLink)
			{
				Response response;
				HttpMessage httpMessage = CreateMessage(pageSizeHint, nextLink, out response);
				if (httpMessage == null)
				{
					return response;
				}
				using Azure.Core.Pipeline.DiagnosticScope diagnosticScope = _clientDiagnostics.CreateScope(_scopeName);
				diagnosticScope.Start();
				try
				{
					_pipeline.Send(httpMessage, _cancellationToken);
					return GetResponse(httpMessage);
				}
				catch (Exception exception)
				{
					diagnosticScope.Failed(exception);
					throw;
				}
			}

			private async ValueTask<Response?> GetNextResponseAsync(int? pageSizeHint, string? nextLink, CancellationToken cancellationToken)
			{
				Response response;
				HttpMessage message = CreateMessage(pageSizeHint, nextLink, out response);
				if (message == null)
				{
					return response;
				}
				using Azure.Core.Pipeline.DiagnosticScope scope = _clientDiagnostics.CreateScope(_scopeName);
				scope.Start();
				try
				{
					if (cancellationToken.CanBeCanceled)
					{
						CancellationToken cancellationToken2 = _cancellationToken;
						if (cancellationToken2.CanBeCanceled)
						{
							using (CancellationTokenSource cts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, _cancellationToken))
							{
								await _pipeline.SendAsync(message, cts.Token).ConfigureAwait(continueOnCapturedContext: false);
							}
							goto IL_01eb;
						}
					}
					CancellationToken cancellationToken3 = (cancellationToken.CanBeCanceled ? cancellationToken : _cancellationToken);
					await _pipeline.SendAsync(message, cancellationToken3).ConfigureAwait(continueOnCapturedContext: false);
					goto IL_01eb;
					IL_01eb:
					return GetResponse(message);
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
			}

			private HttpMessage? CreateMessage(int? pageSizeHint, string? nextLink, out Response? response)
			{
				if (!string.IsNullOrEmpty(nextLink))
				{
					response = null;
					return _createNextPageRequest?.Invoke(pageSizeHint ?? _defaultPageSize, nextLink);
				}
				if (_createFirstPageRequest == null)
				{
					response = _initialResponse;
					return null;
				}
				response = null;
				return _createFirstPageRequest(pageSizeHint ?? _defaultPageSize);
			}

			private Response GetResponse(HttpMessage message)
			{
				if (message.Response.IsError && _errorOptions != ErrorOptions.NoThrow)
				{
					throw new RequestFailedException(message.Response);
				}
				return message.Response;
			}

			private bool TryGetItemsFromResponse(Response? response, out string? nextLink, out JsonElement.ArrayEnumerator jsonArrayEnumerator, out List<T>? items)
			{
				if (response == null)
				{
					nextLink = null;
					jsonArrayEnumerator = default(JsonElement.ArrayEnumerator);
					items = null;
					return false;
				}
				if (_valueFactory != null)
				{
					items = null;
					JsonDocument jsonDocument = ((response.ContentStream != null) ? JsonDocument.Parse(response.ContentStream) : JsonDocument.Parse(response.Content));
					if (_createNextPageRequest == null && _itemPropertyName.Length == 0)
					{
						nextLink = null;
						jsonArrayEnumerator = jsonDocument.RootElement.EnumerateArray();
						return true;
					}
					nextLink = (jsonDocument.RootElement.TryGetProperty(_nextLinkPropertyName, out var value) ? value.GetString() : null);
					if (jsonDocument.RootElement.TryGetProperty(_itemPropertyName, out var value2))
					{
						jsonArrayEnumerator = value2.EnumerateArray();
						return true;
					}
					jsonArrayEnumerator = default(JsonElement.ArrayEnumerator);
					return false;
				}
				jsonArrayEnumerator = default(JsonElement.ArrayEnumerator);
				(items, nextLink) = _responseParser?.Invoke(response) ?? ParseResponseForBinaryData<T>(response, _itemPropertyName, _nextLinkPropertyName);
				return items != null;
			}

			private Page<T> CreatePage(Response response, out string? nextLink)
			{
				if (!TryGetItemsFromResponse(response, out nextLink, out JsonElement.ArrayEnumerator jsonArrayEnumerator, out List<T> items))
				{
					return Page<T>.FromValues(Array.Empty<T>(), nextLink, response);
				}
				if (_valueFactory == null)
				{
					return Page<T>.FromValues(items, nextLink, response);
				}
				List<T> list = new List<T>();
				foreach (JsonElement item in jsonArrayEnumerator)
				{
					list.Add(_valueFactory(item));
				}
				return Page<T>.FromValues(list, nextLink, response);
			}
		}

		private static readonly byte[] DefaultItemPropertyName = Encoding.UTF8.GetBytes("value");

		private static readonly byte[] DefaultNextLinkPropertyName = Encoding.UTF8.GetBytes("nextLink");

		public static AsyncPageable<T> CreateAsyncPageable<T>(Func<int?, HttpMessage>? createFirstPageRequest, Func<int?, string, HttpMessage>? createNextPageRequest, Func<Response, (List<T>? Values, string? NextLink)> responseParser, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext? requestContext = null) where T : notnull
		{
			return new AsyncPageableWrapper<T>(new PageableImplementation<T>(createFirstPageRequest, createNextPageRequest, responseParser, pipeline, clientDiagnostics, scopeName, null, requestContext));
		}

		public static AsyncPageable<T> CreateAsyncPageable<T>(Func<int?, HttpMessage>? createFirstPageRequest, Func<int?, string, HttpMessage>? createNextPageRequest, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, CancellationToken cancellationToken) where T : notnull
		{
			return new AsyncPageableWrapper<T>(new PageableImplementation<T>(null, createFirstPageRequest, createNextPageRequest, valueFactory, pipeline, clientDiagnostics, scopeName, itemPropertyName, nextLinkPropertyName, null, cancellationToken, null));
		}

		public static AsyncPageable<T> CreateAsyncPageable<T>(Func<int?, HttpMessage>? createFirstPageRequest, Func<int?, string, HttpMessage>? createNextPageRequest, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, RequestContext? requestContext = null) where T : notnull
		{
			return new AsyncPageableWrapper<T>(new PageableImplementation<T>(null, createFirstPageRequest, createNextPageRequest, valueFactory, pipeline, clientDiagnostics, scopeName, itemPropertyName, nextLinkPropertyName, null, requestContext?.CancellationToken, requestContext?.ErrorOptions));
		}

		public static AsyncPageable<T> CreateAsyncPageable<T>(Response initialResponse, Func<int?, string, HttpMessage>? createNextPageRequest, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, CancellationToken cancellationToken) where T : notnull
		{
			return new AsyncPageableWrapper<T>(new PageableImplementation<T>(initialResponse, null, createNextPageRequest, valueFactory, pipeline, clientDiagnostics, scopeName, itemPropertyName, nextLinkPropertyName, null, cancellationToken, null));
		}

		public static Pageable<T> CreatePageable<T>(Func<int?, HttpMessage>? createFirstPageRequest, Func<int?, string, HttpMessage>? createNextPageRequest, Func<Response, (List<T>? Values, string? NextLink)> responseParser, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, RequestContext? requestContext = null) where T : notnull
		{
			return new PageableWrapper<T>(new PageableImplementation<T>(createFirstPageRequest, createNextPageRequest, responseParser, pipeline, clientDiagnostics, scopeName, null, requestContext));
		}

		public static Pageable<T> CreatePageable<T>(Func<int?, HttpMessage>? createFirstPageRequest, Func<int?, string, HttpMessage>? createNextPageRequest, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, CancellationToken cancellationToken) where T : notnull
		{
			return new PageableWrapper<T>(new PageableImplementation<T>(null, createFirstPageRequest, createNextPageRequest, valueFactory, pipeline, clientDiagnostics, scopeName, itemPropertyName, nextLinkPropertyName, null, cancellationToken, null));
		}

		public static Pageable<T> CreatePageable<T>(Func<int?, HttpMessage>? createFirstPageRequest, Func<int?, string, HttpMessage>? createNextPageRequest, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, RequestContext? requestContext = null) where T : notnull
		{
			return new PageableWrapper<T>(new PageableImplementation<T>(null, createFirstPageRequest, createNextPageRequest, valueFactory, pipeline, clientDiagnostics, scopeName, itemPropertyName, nextLinkPropertyName, null, requestContext?.CancellationToken, requestContext?.ErrorOptions));
		}

		public static Pageable<T> CreatePageable<T>(Response initialResponse, Func<int?, string, HttpMessage>? createNextPageRequest, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, CancellationToken cancellationToken) where T : notnull
		{
			return new PageableWrapper<T>(new PageableImplementation<T>(initialResponse, null, createNextPageRequest, valueFactory, pipeline, clientDiagnostics, scopeName, itemPropertyName, nextLinkPropertyName, null, cancellationToken, null));
		}

		public static async ValueTask<Operation<AsyncPageable<T>>> CreateAsyncPageable<T>(WaitUntil waitUntil, HttpMessage message, Func<int?, string, HttpMessage>? createNextPageMethod, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Azure.Core.OperationFinalStateVia finalStateVia, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, RequestContext? requestContext = null) where T : notnull
		{
			Response response = await pipeline.ProcessMessageAsync(message, requestContext).ConfigureAwait(continueOnCapturedContext: false);
			Azure.Core.ProtocolOperation<AsyncPageable<T>> operation = new Azure.Core.ProtocolOperation<AsyncPageable<T>>(clientDiagnostics, pipeline, message.Request, response, finalStateVia, scopeName, ResultSelector);
			if (waitUntil == WaitUntil.Completed)
			{
				await operation.WaitForCompletionAsync(requestContext?.CancellationToken ?? default(CancellationToken)).ConfigureAwait(continueOnCapturedContext: false);
			}
			return operation;
			AsyncPageable<T> ResultSelector(Response r)
			{
				return new AsyncPageableWrapper<T>(new PageableImplementation<T>(r, null, createNextPageMethod, valueFactory, pipeline, clientDiagnostics, scopeName, itemPropertyName, nextLinkPropertyName, null, requestContext?.CancellationToken, requestContext?.ErrorOptions));
			}
		}

		public static Operation<Pageable<T>> CreatePageable<T>(WaitUntil waitUntil, HttpMessage message, Func<int?, string, HttpMessage>? createNextPageMethod, Func<JsonElement, T> valueFactory, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Azure.Core.OperationFinalStateVia finalStateVia, string scopeName, string? itemPropertyName, string? nextLinkPropertyName, RequestContext? requestContext = null) where T : notnull
		{
			Response response = pipeline.ProcessMessage(message, requestContext);
			Azure.Core.ProtocolOperation<Pageable<T>> protocolOperation = new Azure.Core.ProtocolOperation<Pageable<T>>(clientDiagnostics, pipeline, message.Request, response, finalStateVia, scopeName, ResultSelector);
			if (waitUntil == WaitUntil.Completed)
			{
				protocolOperation.WaitForCompletion(requestContext?.CancellationToken ?? default(CancellationToken));
			}
			return protocolOperation;
			Pageable<T> ResultSelector(Response r)
			{
				return new PageableWrapper<T>(new PageableImplementation<T>(r, null, createNextPageMethod, valueFactory, pipeline, clientDiagnostics, scopeName, itemPropertyName, nextLinkPropertyName, null, requestContext?.CancellationToken, requestContext?.ErrorOptions));
			}
		}

		public static Pageable<T> CreateEnumerable<T>(Func<int?, Page<T>> firstPageFunc, Func<string?, int?, Page<T>>? nextPageFunc, int? pageSize = null) where T : notnull
		{
			return new FuncPageable<T>((string? _, int? pageSizeHint) => firstPageFunc(pageSizeHint), nextPageFunc, pageSize);
		}

		public static AsyncPageable<T> CreateAsyncEnumerable<T>(Func<int?, Task<Page<T>>> firstPageFunc, Func<string?, int?, Task<Page<T>>>? nextPageFunc, int? pageSize = null) where T : notnull
		{
			return new FuncAsyncPageable<T>((string? _, int? pageSizeHint) => firstPageFunc(pageSizeHint), nextPageFunc, pageSize);
		}

		private static (List<T>? Values, string? NextLink) ParseResponseForBinaryData<T>(Response response, byte[] itemPropertyName, byte[] nextLinkPropertyName)
		{
			ReadOnlyMemory<byte> content = response.Content.ToMemory();
			Utf8JsonReader r = new Utf8JsonReader(content.Span);
			List<T> list = null;
			string item = null;
			if (!r.Read() || r.TokenType != JsonTokenType.StartObject)
			{
				throw new InvalidOperationException("Expected response to be JSON object");
			}
			while (r.Read())
			{
				switch (r.TokenType)
				{
				case JsonTokenType.PropertyName:
					if (r.ValueTextEquals(nextLinkPropertyName))
					{
						r.Read();
						item = r.GetString();
					}
					else if (r.ValueTextEquals(itemPropertyName))
					{
						if (!r.Read() || r.TokenType != JsonTokenType.StartArray)
						{
							throw new InvalidOperationException("Expected " + Encoding.UTF8.GetString(itemPropertyName) + " to be an array");
						}
						while (r.Read() && r.TokenType != JsonTokenType.EndArray)
						{
							object obj = ReadBinaryData(ref r, in content);
							if (list == null)
							{
								list = new List<T>();
							}
							list.Add((T)obj);
						}
					}
					else
					{
						r.Skip();
					}
					break;
				default:
					throw new Exception("Unexpected token");
				case JsonTokenType.EndObject:
					break;
				}
			}
			return (Values: list, NextLink: item);
			static object ReadBinaryData(ref Utf8JsonReader reference, in ReadOnlyMemory<byte> reference2)
			{
				switch (reference.TokenType)
				{
				case JsonTokenType.StartObject:
				case JsonTokenType.StartArray:
				{
					int num = (int)reference.TokenStartIndex;
					reference.Skip();
					int length = (int)reference.TokenStartIndex - num + 1;
					return new BinaryData(reference2.Slice(num, length));
				}
				case JsonTokenType.String:
					return new BinaryData(reference2.Slice((int)reference.TokenStartIndex, reference.ValueSpan.Length + 2));
				default:
					return new BinaryData(reference2.Slice((int)reference.TokenStartIndex, reference.ValueSpan.Length));
				}
			}
		}
	}
	internal class ProtocolOperation<T> : Operation<T>, Azure.Core.IOperation<T> where T : notnull
	{
		private readonly Func<Response, T> _resultSelector;

		private readonly Azure.Core.OperationInternal<T> _operation;

		private readonly Azure.Core.IOperation _nextLinkOperation;

		public override string Id
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override T Value => _operation.Value;

		public override bool HasCompleted => _operation.HasCompleted;

		public override bool HasValue => _operation.HasValue;

		internal ProtocolOperation(Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, Request request, Response response, Azure.Core.OperationFinalStateVia finalStateVia, string scopeName, Func<Response, T> resultSelector)
		{
			_resultSelector = resultSelector;
			_nextLinkOperation = Azure.Core.NextLinkOperationImplementation.Create(pipeline, request.Method, request.Uri.ToUri(), response, finalStateVia);
			_operation = new Azure.Core.OperationInternal<T>(this, clientDiagnostics, response, scopeName);
		}

		public override Response GetRawResponse()
		{
			return _operation.RawResponse;
		}

		public override Response UpdateStatus(CancellationToken cancellationToken = default(CancellationToken))
		{
			return _operation.UpdateStatus(cancellationToken);
		}

		public override ValueTask<Response> UpdateStatusAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return _operation.UpdateStatusAsync(cancellationToken);
		}

		public override ValueTask<Response<T>> WaitForCompletionAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return _operation.WaitForCompletionAsync(cancellationToken);
		}

		public override ValueTask<Response<T>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken = default(CancellationToken))
		{
			return _operation.WaitForCompletionAsync(pollingInterval, cancellationToken);
		}

		async ValueTask<Azure.Core.OperationState<T>> Azure.Core.IOperation<T>.UpdateStateAsync(bool async, CancellationToken cancellationToken)
		{
			Azure.Core.OperationState operationState = await _nextLinkOperation.UpdateStateAsync(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (operationState.HasSucceeded)
			{
				return Azure.Core.OperationState<T>.Success(operationState.RawResponse, _resultSelector(operationState.RawResponse));
			}
			if (operationState.HasCompleted)
			{
				return Azure.Core.OperationState<T>.Failure(operationState.RawResponse, operationState.OperationFailedException);
			}
			return Azure.Core.OperationState<T>.Pending(operationState.RawResponse);
		}
	}
	internal static class ProtocolOperationHelpers
	{
		private class ConvertOperation<TFrom, TTo> : Operation<TTo> where TFrom : notnull where TTo : notnull
		{
			private readonly Operation<TFrom> _operation;

			private readonly Azure.Core.Pipeline.ClientDiagnostics _diagnostics;

			private readonly string _waitForCompletionScopeName;

			private readonly string _updateStatusScopeName;

			private readonly Func<Response, TTo> _convertFunc;

			private Response<TTo>? _response;

			public override string Id => _operation.Id;

			public override TTo Value => GetOrCreateValue();

			public override bool HasValue => _operation.HasValue;

			public override bool HasCompleted => _operation.HasCompleted;

			public ConvertOperation(Operation<TFrom> operation, Azure.Core.Pipeline.ClientDiagnostics diagnostics, string operationName, Func<Response, TTo> convertFunc)
			{
				_operation = operation;
				_diagnostics = diagnostics;
				_waitForCompletionScopeName = operationName + ".WaitForCompletion";
				_updateStatusScopeName = operationName + ".UpdateStatus";
				_convertFunc = convertFunc;
				_response = null;
			}

			public override Response GetRawResponse()
			{
				return _operation.GetRawResponse();
			}

			public override Response UpdateStatus(CancellationToken cancellationToken = default(CancellationToken))
			{
				if (HasCompleted)
				{
					return GetRawResponse();
				}
				using Azure.Core.Pipeline.DiagnosticScope diagnosticScope = CreateScope(_updateStatusScopeName);
				try
				{
					return _operation.UpdateStatus(cancellationToken);
				}
				catch (Exception exception)
				{
					diagnosticScope.Failed(exception);
					throw;
				}
			}

			public override async ValueTask<Response> UpdateStatusAsync(CancellationToken cancellationToken = default(CancellationToken))
			{
				if (HasCompleted)
				{
					return GetRawResponse();
				}
				using Azure.Core.Pipeline.DiagnosticScope scope = CreateScope(_updateStatusScopeName);
				try
				{
					return await _operation.UpdateStatusAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
			}

			public override Response<TTo> WaitForCompletion(CancellationToken cancellationToken = default(CancellationToken))
			{
				if (_response != null)
				{
					return _response;
				}
				using Azure.Core.Pipeline.DiagnosticScope diagnosticScope = CreateScope(_waitForCompletionScopeName);
				try
				{
					Response<TFrom> responseTFrom = _operation.WaitForCompletion(cancellationToken);
					return CreateResponseOfTTo(responseTFrom);
				}
				catch (Exception exception)
				{
					diagnosticScope.Failed(exception);
					throw;
				}
			}

			public override Response<TTo> WaitForCompletion(TimeSpan pollingInterval, CancellationToken cancellationToken)
			{
				if (_response != null)
				{
					return _response;
				}
				using Azure.Core.Pipeline.DiagnosticScope diagnosticScope = CreateScope(_waitForCompletionScopeName);
				try
				{
					Response<TFrom> responseTFrom = _operation.WaitForCompletion(pollingInterval, cancellationToken);
					return CreateResponseOfTTo(responseTFrom);
				}
				catch (Exception exception)
				{
					diagnosticScope.Failed(exception);
					throw;
				}
			}

			public override async ValueTask<Response<TTo>> WaitForCompletionAsync(CancellationToken cancellationToken = default(CancellationToken))
			{
				if (_response != null)
				{
					return _response;
				}
				using Azure.Core.Pipeline.DiagnosticScope scope = CreateScope(_waitForCompletionScopeName);
				try
				{
					return CreateResponseOfTTo(await _operation.WaitForCompletionAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
			}

			public override async ValueTask<Response<TTo>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
			{
				if (_response != null)
				{
					return _response;
				}
				using Azure.Core.Pipeline.DiagnosticScope scope = CreateScope(_waitForCompletionScopeName);
				try
				{
					return CreateResponseOfTTo(await _operation.WaitForCompletionAsync(pollingInterval, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
			}

			private TTo GetOrCreateValue()
			{
				if (_response == null)
				{
					return CreateResponseOfTTo(GetRawResponse()).Value;
				}
				return _response.Value;
			}

			private Response<TTo> CreateResponseOfTTo(Response<TFrom> responseTFrom)
			{
				return CreateResponseOfTTo(responseTFrom.GetRawResponse());
			}

			private Response<TTo> CreateResponseOfTTo(Response rawResponse)
			{
				Response<TTo> value = Response.FromValue(_convertFunc(rawResponse), rawResponse);
				Interlocked.CompareExchange(ref _response, value, null);
				return _response;
			}

			private Azure.Core.Pipeline.DiagnosticScope CreateScope(string name)
			{
				Azure.Core.Pipeline.DiagnosticScope result = _diagnostics.CreateScope(name);
				result.Start();
				return result;
			}
		}

		public static Operation<TTo> Convert<TFrom, TTo>(Operation<TFrom> operation, Func<Response, TTo> convertFunc, Azure.Core.Pipeline.ClientDiagnostics diagnostics, string scopeName) where TFrom : notnull where TTo : notnull
		{
			return new ConvertOperation<TFrom, TTo>(operation, diagnostics, scopeName, convertFunc);
		}

		public static ValueTask<Operation<Azure.Core.VoidValue>> ProcessMessageWithoutResponseValueAsync(HttpPipeline pipeline, HttpMessage message, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, string scopeName, Azure.Core.OperationFinalStateVia finalStateVia, RequestContext? requestContext, WaitUntil waitUntil)
		{
			return ProcessMessageAsync(pipeline, message, clientDiagnostics, scopeName, finalStateVia, requestContext, waitUntil, (Response _) => default(Azure.Core.VoidValue));
		}

		public static Operation<Azure.Core.VoidValue> ProcessMessageWithoutResponseValue(HttpPipeline pipeline, HttpMessage message, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, string scopeName, Azure.Core.OperationFinalStateVia finalStateVia, RequestContext? requestContext, WaitUntil waitUntil)
		{
			return ProcessMessage(pipeline, message, clientDiagnostics, scopeName, finalStateVia, requestContext, waitUntil, (Response _) => default(Azure.Core.VoidValue));
		}

		public static ValueTask<Operation<BinaryData>> ProcessMessageAsync(HttpPipeline pipeline, HttpMessage message, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, string scopeName, Azure.Core.OperationFinalStateVia finalStateVia, RequestContext? requestContext, WaitUntil waitUntil)
		{
			return ProcessMessageAsync(pipeline, message, clientDiagnostics, scopeName, finalStateVia, requestContext, waitUntil, (Response r) => r.Content);
		}

		public static Operation<BinaryData> ProcessMessage(HttpPipeline pipeline, HttpMessage message, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, string scopeName, Azure.Core.OperationFinalStateVia finalStateVia, RequestContext? requestContext, WaitUntil waitUntil)
		{
			return ProcessMessage(pipeline, message, clientDiagnostics, scopeName, finalStateVia, requestContext, waitUntil, (Response r) => r.Content);
		}

		public static async ValueTask<Operation<T>> ProcessMessageAsync<T>(HttpPipeline pipeline, HttpMessage message, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, string scopeName, Azure.Core.OperationFinalStateVia finalStateVia, RequestContext? requestContext, WaitUntil waitUntil, Func<Response, T> resultSelector) where T : notnull
		{
			Response response = await pipeline.ProcessMessageAsync(message, requestContext).ConfigureAwait(continueOnCapturedContext: false);
			Azure.Core.ProtocolOperation<T> operation = new Azure.Core.ProtocolOperation<T>(clientDiagnostics, pipeline, message.Request, response, finalStateVia, scopeName, resultSelector);
			if (waitUntil == WaitUntil.Completed)
			{
				await operation.WaitForCompletionAsync(requestContext?.CancellationToken ?? default(CancellationToken)).ConfigureAwait(continueOnCapturedContext: false);
			}
			return operation;
		}

		public static Operation<T> ProcessMessage<T>(HttpPipeline pipeline, HttpMessage message, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, string scopeName, Azure.Core.OperationFinalStateVia finalStateVia, RequestContext? requestContext, WaitUntil waitUntil, Func<Response, T> resultSelector) where T : notnull
		{
			Response response = pipeline.ProcessMessage(message, requestContext);
			Azure.Core.ProtocolOperation<T> protocolOperation = new Azure.Core.ProtocolOperation<T>(clientDiagnostics, pipeline, message.Request, response, finalStateVia, scopeName, resultSelector);
			if (waitUntil == WaitUntil.Completed)
			{
				protocolOperation.WaitForCompletion(requestContext?.CancellationToken ?? default(CancellationToken));
			}
			return protocolOperation;
		}
	}
	internal class RawRequestUriBuilder : RequestUriBuilder
	{
		private enum RawWritingPosition
		{
			Scheme,
			Host,
			Port,
			Path,
			Query
		}

		private const string SchemeSeparator = "://";

		private const char HostSeparator = '/';

		private const char PortSeparator = ':';

		private static readonly char[] HostOrPort = new char[2] { '/', ':' };

		private const char QueryBeginSeparator = '?';

		private const char QueryContinueSeparator = '&';

		private const char QueryValueSeparator = '=';

		private RawWritingPosition? _position;

		private static void GetQueryParts(ReadOnlySpan<char> queryUnparsed, out ReadOnlySpan<char> name, out ReadOnlySpan<char> value)
		{
			int num = queryUnparsed.IndexOf('=');
			if (num == -1)
			{
				name = queryUnparsed;
				value = ReadOnlySpan<char>.Empty;
			}
			else
			{
				name = queryUnparsed.Slice(0, num);
				value = queryUnparsed.Slice(num + 1);
			}
		}

		public void AppendRaw(string value, bool escape)
		{
			AppendRaw(MemoryExtensions.AsSpan(value), escape);
		}

		private void AppendRaw(ReadOnlySpan<char> value, bool escape)
		{
			if (!_position.HasValue)
			{
				if (base.HasQuery)
				{
					_position = RawWritingPosition.Query;
				}
				else if (base.HasPath)
				{
					_position = RawWritingPosition.Path;
				}
				else if (!string.IsNullOrEmpty(base.Host))
				{
					_position = RawWritingPosition.Host;
				}
				else
				{
					_position = RawWritingPosition.Scheme;
				}
			}
			while (!value.IsEmpty)
			{
				if (_position == RawWritingPosition.Scheme)
				{
					int num = value.IndexOf(MemoryExtensions.AsSpan("://"), StringComparison.InvariantCultureIgnoreCase);
					if (num == -1)
					{
						base.Scheme += value;
						value = ReadOnlySpan<char>.Empty;
						continue;
					}
					base.Scheme += value.Slice(0, num);
					base.Port = (string.Equals(base.Scheme, "https", StringComparison.OrdinalIgnoreCase) ? 443 : 80);
					value = value.Slice(num + "://".Length);
					_position = RawWritingPosition.Host;
				}
				else if (_position == RawWritingPosition.Host)
				{
					int num2 = value.IndexOfAny(HostOrPort);
					if (num2 == -1)
					{
						if (!base.HasPath)
						{
							base.Host += value;
							value = ReadOnlySpan<char>.Empty;
						}
						else
						{
							_position = RawWritingPosition.Path;
						}
					}
					else
					{
						base.Host += value.Slice(0, num2);
						_position = ((value[num2] == '/') ? RawWritingPosition.Path : RawWritingPosition.Port);
						value = value.Slice(num2 + 1);
					}
				}
				else if (_position == RawWritingPosition.Port)
				{
					int num3 = value.IndexOf('/');
					if (num3 == -1)
					{
						base.Port = int.Parse(value.ToString(), CultureInfo.InvariantCulture);
						value = ReadOnlySpan<char>.Empty;
					}
					else
					{
						base.Port = int.Parse(value.Slice(0, num3).ToString(), CultureInfo.InvariantCulture);
						value = value.Slice(num3 + 1);
					}
					_position = RawWritingPosition.Path;
				}
				else if (_position == RawWritingPosition.Path)
				{
					int num4 = value.IndexOf('?');
					if (num4 == -1)
					{
						AppendPath(value, escape);
						value = ReadOnlySpan<char>.Empty;
					}
					else
					{
						AppendPath(value.Slice(0, num4), escape);
						value = value.Slice(num4 + 1);
						_position = RawWritingPosition.Query;
					}
				}
				else if (_position == RawWritingPosition.Query)
				{
					int num5 = value.IndexOf('&');
					switch (num5)
					{
					case 0:
						value = value.Slice(1);
						break;
					case -1:
					{
						GetQueryParts(value, out var name2, out var value3);
						AppendQuery(name2, value3, escape);
						value = ReadOnlySpan<char>.Empty;
						break;
					}
					default:
					{
						GetQueryParts(value.Slice(0, num5), out var name, out var value2);
						AppendQuery(name, value2, escape);
						value = value.Slice(num5 + 1);
						break;
					}
					}
				}
			}
		}

		public void AppendRawNextLink(string nextLink, bool escape)
		{
			if (nextLink.StartsWith(Uri.UriSchemeHttp, StringComparison.InvariantCultureIgnoreCase))
			{
				Reset(new Uri(nextLink));
			}
			else
			{
				AppendRaw(nextLink, escape);
			}
		}
	}
	internal static class RequestContentHelper
	{
		public static RequestContent FromEnumerable<T>(IEnumerable<T> enumerable) where T : notnull
		{
			Azure.Core.Utf8JsonRequestContent utf8JsonRequestContent = new Azure.Core.Utf8JsonRequestContent();
			utf8JsonRequestContent.JsonWriter.WriteStartArray();
			foreach (T item in enumerable)
			{
				utf8JsonRequestContent.JsonWriter.WriteObjectValue(item);
			}
			utf8JsonRequestContent.JsonWriter.WriteEndArray();
			return utf8JsonRequestContent;
		}

		public static RequestContent FromEnumerable(IEnumerable<BinaryData> enumerable)
		{
			Azure.Core.Utf8JsonRequestContent utf8JsonRequestContent = new Azure.Core.Utf8JsonRequestContent();
			utf8JsonRequestContent.JsonWriter.WriteStartArray();
			foreach (BinaryData item in enumerable)
			{
				if (item == null)
				{
					utf8JsonRequestContent.JsonWriter.WriteNullValue();
				}
				else
				{
					JsonSerializer.Serialize(utf8JsonRequestContent.JsonWriter, JsonDocument.Parse(item.ToString()).RootElement);
				}
			}
			utf8JsonRequestContent.JsonWriter.WriteEndArray();
			return utf8JsonRequestContent;
		}

		public static RequestContent FromDictionary<T>(IDictionary<string, T> dictionary) where T : notnull
		{
			Azure.Core.Utf8JsonRequestContent utf8JsonRequestContent = new Azure.Core.Utf8JsonRequestContent();
			utf8JsonRequestContent.JsonWriter.WriteStartObject();
			foreach (KeyValuePair<string, T> item in dictionary)
			{
				utf8JsonRequestContent.JsonWriter.WritePropertyName(item.Key);
				utf8JsonRequestContent.JsonWriter.WriteObjectValue(item.Value);
			}
			utf8JsonRequestContent.JsonWriter.WriteEndObject();
			return utf8JsonRequestContent;
		}

		public static RequestContent FromDictionary(IDictionary<string, BinaryData> dictionary)
		{
			Azure.Core.Utf8JsonRequestContent utf8JsonRequestContent = new Azure.Core.Utf8JsonRequestContent();
			utf8JsonRequestContent.JsonWriter.WriteStartObject();
			foreach (KeyValuePair<string, BinaryData> item in dictionary)
			{
				utf8JsonRequestContent.JsonWriter.WritePropertyName(item.Key);
				if (item.Value == null)
				{
					utf8JsonRequestContent.JsonWriter.WriteNullValue();
				}
				else
				{
					JsonSerializer.Serialize(utf8JsonRequestContent.JsonWriter, JsonDocument.Parse(item.Value.ToString()).RootElement);
				}
			}
			utf8JsonRequestContent.JsonWriter.WriteEndObject();
			return utf8JsonRequestContent;
		}

		public static RequestContent FromObject(object value)
		{
			Azure.Core.Utf8JsonRequestContent utf8JsonRequestContent = new Azure.Core.Utf8JsonRequestContent();
			utf8JsonRequestContent.JsonWriter.WriteObjectValue(value);
			return utf8JsonRequestContent;
		}

		public static RequestContent FromObject(BinaryData value)
		{
			Azure.Core.Utf8JsonRequestContent utf8JsonRequestContent = new Azure.Core.Utf8JsonRequestContent();
			JsonSerializer.Serialize(utf8JsonRequestContent.JsonWriter, JsonDocument.Parse(value).RootElement);
			return utf8JsonRequestContent;
		}
	}
	internal static class RequestHeaderExtensions
	{
		public static void Add(this RequestHeaders headers, string name, bool value)
		{
			headers.Add(name, Azure.Core.TypeFormatters.ToString(value));
		}

		public static void Add(this RequestHeaders headers, string name, float value)
		{
			headers.Add(name, value.ToString(Azure.Core.TypeFormatters.DefaultNumberFormat, CultureInfo.InvariantCulture));
		}

		public static void Add(this RequestHeaders headers, string name, double value)
		{
			headers.Add(name, value.ToString(Azure.Core.TypeFormatters.DefaultNumberFormat, CultureInfo.InvariantCulture));
		}

		public static void Add(this RequestHeaders headers, string name, int value)
		{
			headers.Add(name, value.ToString(Azure.Core.TypeFormatters.DefaultNumberFormat, CultureInfo.InvariantCulture));
		}

		public static void Add(this RequestHeaders headers, string name, long value)
		{
			headers.Add(name, value.ToString(Azure.Core.TypeFormatters.DefaultNumberFormat, CultureInfo.InvariantCulture));
		}

		public static void Add(this RequestHeaders headers, string name, DateTimeOffset value, string format)
		{
			headers.Add(name, Azure.Core.TypeFormatters.ToString(value, format));
		}

		public static void Add(this RequestHeaders headers, string name, TimeSpan value, string format)
		{
			headers.Add(name, Azure.Core.TypeFormatters.ToString(value, format));
		}

		public static void Add(this RequestHeaders headers, string name, Guid value)
		{
			headers.Add(name, value.ToString());
		}

		public static void Add(this RequestHeaders headers, string name, byte[] value, string format)
		{
			headers.Add(name, Azure.Core.TypeFormatters.ToString(value, format));
		}

		public static void Add(this RequestHeaders headers, string name, BinaryData value, string format)
		{
			headers.Add(name, Azure.Core.TypeFormatters.ToString(value.ToArray(), format));
		}

		public static void Add(this RequestHeaders headers, string prefix, IDictionary<string, string> headersToAdd)
		{
			foreach (KeyValuePair<string, string> item in headersToAdd)
			{
				headers.Add(prefix + item.Key, item.Value);
			}
		}

		public static void Add(this RequestHeaders headers, string name, ETag value)
		{
			headers.Add(name, value.ToString("H"));
		}

		public static void Add(this RequestHeaders headers, MatchConditions conditions)
		{
			if (conditions.IfMatch.HasValue)
			{
				headers.Add("If-Match", conditions.IfMatch.Value);
			}
			if (conditions.IfNoneMatch.HasValue)
			{
				headers.Add("If-None-Match", conditions.IfNoneMatch.Value);
			}
		}

		public static void Add(this RequestHeaders headers, RequestConditions conditions, string format)
		{
			if (conditions.IfMatch.HasValue)
			{
				headers.Add("If-Match", conditions.IfMatch.Value);
			}
			if (conditions.IfNoneMatch.HasValue)
			{
				headers.Add("If-None-Match", conditions.IfNoneMatch.Value);
			}
			if (conditions.IfModifiedSince.HasValue)
			{
				headers.Add("If-Modified-Since", conditions.IfModifiedSince.Value, format);
			}
			if (conditions.IfUnmodifiedSince.HasValue)
			{
				headers.Add("If-Unmodified-Since", conditions.IfUnmodifiedSince.Value, format);
			}
		}

		public static void AddDelimited<T>(this RequestHeaders headers, string name, IEnumerable<T> value, string delimiter)
		{
			headers.Add(name, string.Join(delimiter, value));
		}

		public static void AddDelimited<T>(this RequestHeaders headers, string name, IEnumerable<T> value, string delimiter, string format)
		{
			IEnumerable<string> values = value.Select<T, string>((T v) => Azure.Core.TypeFormatters.ConvertToString(v, format));
			headers.Add(name, string.Join(delimiter, values));
		}
	}
	internal static class RequestUriBuilderExtensions
	{
		public static void AppendPath(this RequestUriBuilder builder, bool value, bool escape = false)
		{
			builder.AppendPath(Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendPath(this RequestUriBuilder builder, float value, bool escape = true)
		{
			builder.AppendPath(Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendPath(this RequestUriBuilder builder, double value, bool escape = true)
		{
			builder.AppendPath(Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendPath(this RequestUriBuilder builder, int value, bool escape = true)
		{
			builder.AppendPath(Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendPath(this RequestUriBuilder builder, byte[] value, string format, bool escape = true)
		{
			builder.AppendPath(Azure.Core.TypeFormatters.ConvertToString(value, format), escape);
		}

		public static void AppendPath(this RequestUriBuilder builder, IEnumerable<string> value, bool escape = true)
		{
			builder.AppendPath(Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendPath(this RequestUriBuilder builder, DateTimeOffset value, string format, bool escape = true)
		{
			builder.AppendPath(Azure.Core.TypeFormatters.ConvertToString(value, format), escape);
		}

		public static void AppendPath(this RequestUriBuilder builder, TimeSpan value, string format, bool escape = true)
		{
			builder.AppendPath(Azure.Core.TypeFormatters.ConvertToString(value, format), escape);
		}

		public static void AppendPath(this RequestUriBuilder builder, Guid value, bool escape = true)
		{
			builder.AppendPath(Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendPath(this RequestUriBuilder builder, long value, bool escape = true)
		{
			builder.AppendPath(Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendQuery(this RequestUriBuilder builder, string name, bool value, bool escape = false)
		{
			builder.AppendQuery(name, Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendQuery(this RequestUriBuilder builder, string name, float value, bool escape = true)
		{
			builder.AppendQuery(name, Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendQuery(this RequestUriBuilder builder, string name, DateTimeOffset value, string format, bool escape = true)
		{
			builder.AppendQuery(name, Azure.Core.TypeFormatters.ConvertToString(value, format), escape);
		}

		public static void AppendQuery(this RequestUriBuilder builder, string name, TimeSpan value, string format, bool escape = true)
		{
			builder.AppendQuery(name, Azure.Core.TypeFormatters.ConvertToString(value, format), escape);
		}

		public static void AppendQuery(this RequestUriBuilder builder, string name, double value, bool escape = true)
		{
			builder.AppendQuery(name, Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendQuery(this RequestUriBuilder builder, string name, decimal value, bool escape = true)
		{
			builder.AppendQuery(name, Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendQuery(this RequestUriBuilder builder, string name, int value, bool escape = true)
		{
			builder.AppendQuery(name, Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendQuery(this RequestUriBuilder builder, string name, long value, bool escape = true)
		{
			builder.AppendQuery(name, Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendQuery(this RequestUriBuilder builder, string name, TimeSpan value, bool escape = true)
		{
			builder.AppendQuery(name, Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendQuery(this RequestUriBuilder builder, string name, byte[] value, string format, bool escape = true)
		{
			builder.AppendQuery(name, Azure.Core.TypeFormatters.ConvertToString(value, format), escape);
		}

		public static void AppendQuery(this RequestUriBuilder builder, string name, Guid value, bool escape = true)
		{
			builder.AppendQuery(name, Azure.Core.TypeFormatters.ConvertToString(value), escape);
		}

		public static void AppendQueryDelimited<T>(this RequestUriBuilder builder, string name, IEnumerable<T> value, string delimiter, bool escape = true)
		{
			IEnumerable<string> values = value.Select<T, string>((T v) => Azure.Core.TypeFormatters.ConvertToString(v));
			builder.AppendQuery(name, string.Join(delimiter, values), escape);
		}

		public static void AppendQueryDelimited<T>(this RequestUriBuilder builder, string name, IEnumerable<T> value, string delimiter, string format, bool escape = true)
		{
			IEnumerable<string> values = value.Select<T, string>((T v) => Azure.Core.TypeFormatters.ConvertToString(v, format));
			builder.AppendQuery(name, string.Join(delimiter, values), escape);
		}
	}
	internal static class ResponseHeadersExtensions
	{
		private static readonly string[] KnownFormats = new string[21]
		{
			"ddd, d MMM yyyy H:m:s 'GMT'", "ddd, d MMM yyyy H:m:s 'UTC'", "ddd, d MMM yyyy H:m:s", "d MMM yyyy H:m:s 'GMT'", "d MMM yyyy H:m:s 'UTC'", "d MMM yyyy H:m:s", "ddd, d MMM yy H:m:s 'GMT'", "ddd, d MMM yy H:m:s 'UTC'", "ddd, d MMM yy H:m:s", "d MMM yy H:m:s 'GMT'",
			"d MMM yy H:m:s 'UTC'", "d MMM yy H:m:s", "dddd, d'-'MMM'-'yy H:m:s 'GMT'", "dddd, d'-'MMM'-'yy H:m:s 'UTC'", "dddd, d'-'MMM'-'yy H:m:s zzz", "dddd, d'-'MMM'-'yy H:m:s", "ddd MMM d H:m:s yyyy", "ddd, d MMM yyyy H:m:s zzz", "ddd, d MMM yyyy H:m:s", "d MMM yyyy H:m:s zzz",
			"d MMM yyyy H:m:s"
		};

		public static bool TryGetValue(this ResponseHeaders headers, string name, out byte[]? value)
		{
			if (headers.TryGetValue(name, out string value2))
			{
				value = Convert.FromBase64String(value2);
				return true;
			}
			value = null;
			return false;
		}

		public static bool TryGetValue(this ResponseHeaders headers, string name, out TimeSpan? value)
		{
			if (headers.TryGetValue(name, out string value2))
			{
				value = XmlConvert.ToTimeSpan(value2);
				return true;
			}
			value = null;
			return false;
		}

		public static bool TryGetValue(this ResponseHeaders headers, string name, out DateTimeOffset? value)
		{
			if (headers.TryGetValue(name, out string value2))
			{
				if (DateTimeOffset.TryParseExact(value2, "r", DateTimeFormatInfo.InvariantInfo, DateTimeStyles.None, out var result) || DateTimeOffset.TryParseExact(value2, KnownFormats, DateTimeFormatInfo.InvariantInfo, DateTimeStyles.AllowInnerWhite | DateTimeStyles.AssumeUniversal, out result))
				{
					value = result;
				}
				else
				{
					value = Azure.Core.TypeFormatters.ParseDateTimeOffset(value2, "");
				}
				return true;
			}
			value = null;
			return false;
		}

		public static bool TryGetValue<T>(this ResponseHeaders headers, string name, out T? value) where T : struct
		{
			if (headers.TryGetValue(name, out string value2))
			{
				value = (T)Convert.ChangeType(value2, typeof(T), CultureInfo.InvariantCulture);
				return true;
			}
			value = null;
			return false;
		}

		public static bool TryGetValue<T>(this ResponseHeaders headers, string name, out T? value) where T : class
		{
			if (headers.TryGetValue(name, out string value2))
			{
				value = (T)Convert.ChangeType(value2, typeof(T), CultureInfo.InvariantCulture);
				return true;
			}
			value = null;
			return false;
		}

		public static bool TryGetValue(this ResponseHeaders headers, string prefix, out IDictionary<string, string> value)
		{
			value = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
			foreach (HttpHeader item in headers)
			{
				if (item.Name.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))
				{
					value.Add(item.Name.Substring(prefix.Length), item.Value);
				}
			}
			return true;
		}
	}
	internal static class ResponseWithHeaders
	{
		public static Azure.Core.ResponseWithHeaders<T, THeaders> FromValue<T, THeaders>(T value, THeaders headers, Response rawResponse)
		{
			return new Azure.Core.ResponseWithHeaders<T, THeaders>(value, headers, rawResponse);
		}

		public static Azure.Core.ResponseWithHeaders<THeaders> FromValue<THeaders>(THeaders headers, Response rawResponse)
		{
			return new Azure.Core.ResponseWithHeaders<THeaders>(headers, rawResponse);
		}
	}
	internal class ResponseWithHeaders<THeaders>
	{
		private readonly Response _rawResponse;

		public THeaders Headers { get; }

		public ResponseWithHeaders(THeaders headers, Response rawResponse)
		{
			_rawResponse = rawResponse;
			Headers = headers;
		}

		public Response GetRawResponse()
		{
			return _rawResponse;
		}

		public static implicit operator Response(Azure.Core.ResponseWithHeaders<THeaders> self)
		{
			return self.GetRawResponse();
		}
	}
	internal class ResponseWithHeaders<T, THeaders> : Response<T>
	{
		private readonly Response _rawResponse;

		public override T Value { get; }

		public THeaders Headers { get; }

		public ResponseWithHeaders(T value, THeaders headers, Response rawResponse)
		{
			_rawResponse = rawResponse;
			Value = value;
			Headers = headers;
		}

		public override Response GetRawResponse()
		{
			return _rawResponse;
		}

		public static implicit operator Response(Azure.Core.ResponseWithHeaders<T, THeaders> self)
		{
			return self.GetRawResponse();
		}
	}
	internal class SequentialDelayStrategy : DelayStrategy
	{
		private static readonly TimeSpan[] _pollingSequence = new TimeSpan[8]
		{
			TimeSpan.FromSeconds(1.0),
			TimeSpan.FromSeconds(1.0),
			TimeSpan.FromSeconds(1.0),
			TimeSpan.FromSeconds(2.0),
			TimeSpan.FromSeconds(4.0),
			TimeSpan.FromSeconds(8.0),
			TimeSpan.FromSeconds(16.0),
			TimeSpan.FromSeconds(32.0)
		};

		private static readonly TimeSpan _maxDelay = _pollingSequence[_pollingSequence.Length - 1];

		public SequentialDelayStrategy()
			: base(_maxDelay, 0.0)
		{
		}

		protected override TimeSpan GetNextDelayCore(Response? response, int retryNumber)
		{
			int num = retryNumber - 1;
			if (num < _pollingSequence.Length)
			{
				return _pollingSequence[num];
			}
			return _maxDelay;
		}
	}
	internal class StringRequestContent : RequestContent
	{
		private readonly byte[] _bytes;

		public StringRequestContent(string value)
		{
			_bytes = Encoding.UTF8.GetBytes(value);
		}

		public override async Task WriteToAsync(Stream stream, CancellationToken cancellation)
		{
			await stream.WriteAsync(_bytes, 0, _bytes.Length, cancellation).ConfigureAwait(continueOnCapturedContext: false);
		}

		public override void WriteTo(Stream stream, CancellationToken cancellation)
		{
			stream.Write(_bytes, 0, _bytes.Length);
		}

		public override bool TryComputeLength(out long length)
		{
			length = _bytes.Length;
			return true;
		}

		public override void Dispose()
		{
		}
	}
	internal class TypeFormatters
	{
		private const string RoundtripZFormat = "yyyy-MM-ddTHH:mm:ss.fffffffZ";

		public static string DefaultNumberFormat { get; } = "G";

		public static string ToString(bool value)
		{
			if (!value)
			{
				return "false";
			}
			return "true";
		}

		public static string ToString(DateTime value, string format)
		{
			if (value.Kind == DateTimeKind.Utc)
			{
				return ToString((DateTimeOffset)value, format);
			}
			throw new NotSupportedException($"DateTime {value} has a Kind of {value.Kind}. Azure SDK requires it to be UTC. You can call DateTime.SpecifyKind to change Kind property value to DateTimeKind.Utc.");
		}

		public static string ToString(DateTimeOffset value, string format)
		{
			return format switch
			{
				"D" => value.ToString("yyyy-MM-dd", CultureInfo.InvariantCulture), 
				"U" => value.ToUnixTimeSeconds().ToString(CultureInfo.InvariantCulture), 
				"O" => value.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ", CultureInfo.InvariantCulture), 
				"o" => value.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ", CultureInfo.InvariantCulture), 
				"R" => value.ToString("r", CultureInfo.InvariantCulture), 
				_ => value.ToString(format, CultureInfo.InvariantCulture), 
			};
		}

		public static string ToString(TimeSpan value, string format)
		{
			if (format == "P")
			{
				return XmlConvert.ToString(value);
			}
			return value.ToString(format, CultureInfo.InvariantCulture);
		}

		public static string ToString(byte[] value, string format)
		{
			if (!(format == "U"))
			{
				if (format == "D")
				{
					return Convert.ToBase64String(value);
				}
				throw new ArgumentException("Format is not supported: '" + format + "'", "format");
			}
			return ToBase64UrlString(value);
		}

		public static string ToBase64UrlString(byte[] value)
		{
			char[] array;
			int num;
			checked
			{
				array = new char[unchecked(checked(value.Length + 2) / 3) * 4];
				num = Convert.ToBase64CharArray(value, 0, value.Length, array, 0);
			}
			int i;
			for (i = 0; i < num; i++)
			{
				switch (array[i])
				{
				case '+':
					array[i] = '-';
					continue;
				case '/':
					array[i] = '_';
					continue;
				default:
					continue;
				case '=':
					break;
				}
				break;
			}
			return new string(array, 0, i);
		}

		public static byte[] FromBase64UrlString(string value)
		{
			int numBase64PaddingCharsToAddForDecode = GetNumBase64PaddingCharsToAddForDecode(value.Length);
			char[] array = new char[value.Length + numBase64PaddingCharsToAddForDecode];
			int i;
			for (i = 0; i < value.Length; i++)
			{
				char c = value[i];
				switch (c)
				{
				case '-':
					array[i] = '+';
					break;
				case '_':
					array[i] = '/';
					break;
				default:
					array[i] = c;
					break;
				}
			}
			for (; i < array.Length; i++)
			{
				array[i] = '=';
			}
			return Convert.FromBase64CharArray(array, 0, array.Length);
		}

		private static int GetNumBase64PaddingCharsToAddForDecode(int inputLength)
		{
			return (inputLength % 4) switch
			{
				0 => 0, 
				2 => 2, 
				3 => 1, 
				_ => throw new InvalidOperationException("Malformed input"), 
			};
		}

		public static DateTimeOffset ParseDateTimeOffset(string value, string format)
		{
			if (format == "U")
			{
				return DateTimeOffset.FromUnixTimeSeconds(long.Parse(value, CultureInfo.InvariantCulture));
			}
			return DateTimeOffset.Parse(value, CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal);
		}

		public static TimeSpan ParseTimeSpan(string value, string format)
		{
			if (format == "P")
			{
				return XmlConvert.ToTimeSpan(value);
			}
			return TimeSpan.ParseExact(value, format, CultureInfo.InvariantCulture);
		}

		public static string ConvertToString(object? value, string? format = null)
		{
			if (value != null)
			{
				if (!(value is string result))
				{
					if (!(value is bool flag))
					{
						if (!(value is int) && !(value is float) && !(value is double) && !(value is long) && !(value is decimal))
						{
							if (!(value is byte[] array))
							{
								if (value is IEnumerable<string> values)
								{
									return string.Join(",", values);
								}
								if (!(value is DateTimeOffset dateTimeOffset))
								{
									if (value is TimeSpan timeSpan)
									{
										if (format != null)
										{
											return ToString(timeSpan, format);
										}
										return XmlConvert.ToString(timeSpan);
									}
									if (value is Guid guid)
									{
										return guid.ToString();
									}
									if (value is BinaryData binaryData)
									{
										return ConvertToString(binaryData.ToArray(), format);
									}
								}
								else if (format != null)
								{
									return ToString(dateTimeOffset, format);
								}
							}
							else if (format != null)
							{
								return ToString(array, format);
							}
							return value.ToString();
						}
						return ((IFormattable)value).ToString(DefaultNumberFormat, CultureInfo.InvariantCulture);
					}
					return ToString(flag);
				}
				return result;
			}
			return "null";
		}
	}
	internal class Utf8JsonRequestContent : RequestContent
	{
		private readonly MemoryStream _stream;

		private readonly RequestContent _content;

		public Utf8JsonWriter JsonWriter { get; }

		public Utf8JsonRequestContent()
		{
			_stream = new MemoryStream();
			_content = RequestContent.Create(_stream);
			JsonWriter = new Utf8JsonWriter(_stream);
		}

		public override async Task WriteToAsync(Stream stream, CancellationToken cancellation)
		{
			await JsonWriter.FlushAsync(cancellation).ConfigureAwait(continueOnCapturedContext: false);
			await _content.WriteToAsync(stream, cancellation).ConfigureAwait(continueOnCapturedContext: false);
		}

		public override void WriteTo(Stream stream, CancellationToken cancellation)
		{
			JsonWriter.Flush();
			_content.WriteTo(stream, cancellation);
		}

		public override bool TryComputeLength(out long length)
		{
			length = JsonWriter.BytesCommitted + JsonWriter.BytesPending;
			return true;
		}

		public override void Dispose()
		{
			JsonWriter.Dispose();
			_content.Dispose();
			_stream.Dispose();
		}
	}
	internal static class Utf8JsonWriterExtensions
	{
		public static void WriteStringValue(this Utf8JsonWriter writer, DateTimeOffset value, string format)
		{
			writer.WriteStringValue(Azure.Core.TypeFormatters.ToString(value, format));
		}

		public static void WriteStringValue(this Utf8JsonWriter writer, DateTime value, string format)
		{
			writer.WriteStringValue(Azure.Core.TypeFormatters.ToString(value, format));
		}

		public static void WriteStringValue(this Utf8JsonWriter writer, TimeSpan value, string format)
		{
			writer.WriteStringValue(Azure.Core.TypeFormatters.ToString(value, format));
		}

		public static void WriteStringValue(this Utf8JsonWriter writer, char value)
		{
			writer.WriteStringValue(value.ToString(CultureInfo.InvariantCulture));
		}

		public static void WriteNonEmptyArray(this Utf8JsonWriter writer, string name, IReadOnlyList<string> values)
		{
			if (!values.Any())
			{
				return;
			}
			writer.WriteStartArray(name);
			foreach (string value in values)
			{
				writer.WriteStringValue(value);
			}
			writer.WriteEndArray();
		}

		public static void WriteBase64StringValue(this Utf8JsonWriter writer, byte[] value, string format)
		{
			if (value == null)
			{
				writer.WriteNullValue();
			}
			else if (!(format == "U"))
			{
				if (!(format == "D"))
				{
					throw new ArgumentException("Format is not supported: '" + format + "'", "format");
				}
				writer.WriteBase64StringValue(value);
			}
			else
			{
				writer.WriteStringValue(Azure.Core.TypeFormatters.ToBase64UrlString(value));
			}
		}

		public static void WriteNumberValue(this Utf8JsonWriter writer, DateTimeOffset value, string format)
		{
			if (format != "U")
			{
				throw new ArgumentOutOfRangeException(format, "Only 'U' format is supported when writing a DateTimeOffset as a Number.");
			}
			writer.WriteNumberValue(value.ToUnixTimeSeconds());
		}

		public static void WriteObjectValue(this Utf8JsonWriter writer, object value)
		{
			if (value != null)
			{
				if (!(value is Azure.Core.IUtf8JsonSerializable utf8JsonSerializable))
				{
					if (!(value is byte[] array))
					{
						if (!(value is BinaryData binaryData))
						{
							if (!(value is JsonElement jsonElement))
							{
								if (!(value is int value2))
								{
									if (!(value is decimal value3))
									{
										if (!(value is double num))
										{
											if (!(value is float value4))
											{
												if (!(value is long value5))
												{
													if (!(value is string value6))
													{
														if (!(value is bool value7))
														{
															if (!(value is Guid value8))
															{
																if (!(value is DateTimeOffset value9))
																{
																	if (!(value is DateTime value10))
																	{
																		if (!(value is IEnumerable<KeyValuePair<string, object>> enumerable))
																		{
																			if (!(value is IEnumerable<object> enumerable2))
																			{
																				if (value is TimeSpan value11)
																				{
																					writer.WriteStringValue(value11, "P");
																					return;
																				}
																				throw new NotSupportedException("Not supported type " + value.GetType());
																			}
																			writer.WriteStartArray();
																			foreach (object item in enumerable2)
																			{
																				writer.WriteObjectValue(item);
																			}
																			writer.WriteEndArray();
																			return;
																		}
																		writer.WriteStartObject();
																		foreach (KeyValuePair<string, object> item2 in enumerable)
																		{
																			writer.WritePropertyName(item2.Key);
																			writer.WriteObjectValue(item2.Value);
																		}
																		writer.WriteEndObject();
																	}
																	else
																	{
																		writer.WriteStringValue(value10, "O");
																	}
																}
																else
																{
																	writer.WriteStringValue(value9, "O");
																}
															}
															else
															{
																writer.WriteStringValue(value8);
															}
														}
														else
														{
															writer.WriteBooleanValue(value7);
														}
													}
													else
													{
														writer.WriteStringValue(value6);
													}
												}
												else
												{
													writer.WriteNumberValue(value5);
												}
											}
											else
											{
												writer.WriteNumberValue(value4);
											}
										}
										else if (double.IsNaN(num))
										{
											writer.WriteStringValue("NaN");
										}
										else
										{
											writer.WriteNumberValue(num);
										}
									}
									else
									{
										writer.WriteNumberValue(value3);
									}
								}
								else
								{
									writer.WriteNumberValue(value2);
								}
							}
							else
							{
								jsonElement.WriteTo(writer);
							}
						}
						else
						{
							writer.WriteBase64StringValue(binaryData);
						}
					}
					else
					{
						writer.WriteBase64StringValue(array);
					}
				}
				else
				{
					utf8JsonSerializable.Write(writer);
				}
			}
			else
			{
				writer.WriteNullValue();
			}
		}
	}
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	internal readonly struct VoidValue
	{
	}
	internal static class XElementExtensions
	{
		public static byte[] GetBytesFromBase64Value(this XElement element, string format)
		{
			if (!(format == "U"))
			{
				if (format == "D")
				{
					return Convert.FromBase64String(element.Value);
				}
				throw new ArgumentException("Format is not supported: '" + format + "'", "format");
			}
			return Azure.Core.TypeFormatters.FromBase64UrlString(element.Value);
		}

		public static DateTimeOffset GetDateTimeOffsetValue(this XElement element, string format)
		{
			if (format == "U")
			{
				return DateTimeOffset.FromUnixTimeSeconds((long)element);
			}
			return Azure.Core.TypeFormatters.ParseDateTimeOffset(element.Value, format);
		}

		public static TimeSpan GetTimeSpanValue(this XElement element, string format)
		{
			return Azure.Core.TypeFormatters.ParseTimeSpan(element.Value, format);
		}

		public static object GetObjectValue(this XElement element, string format)
		{
			return element.Value;
		}
	}
	internal class XmlWriterContent : RequestContent
	{
		private readonly MemoryStream _stream;

		private readonly RequestContent _content;

		public XmlWriter XmlWriter { get; }

		public XmlWriterContent()
		{
			_stream = new MemoryStream();
			_content = RequestContent.Create(_stream);
			XmlWriter = new XmlTextWriter(_stream, Encoding.UTF8);
		}

		public override async Task WriteToAsync(Stream stream, CancellationToken cancellation)
		{
			XmlWriter.Flush();
			await _content.WriteToAsync(stream, cancellation).ConfigureAwait(continueOnCapturedContext: false);
		}

		public override void WriteTo(Stream stream, CancellationToken cancellation)
		{
			XmlWriter.Flush();
			_content.WriteTo(stream, cancellation);
		}

		public override bool TryComputeLength(out long length)
		{
			XmlWriter.Flush();
			length = _stream.Length;
			return true;
		}

		public override void Dispose()
		{
			XmlWriter.Dispose();
			_content.Dispose();
			_stream.Dispose();
		}
	}
	internal static class XmlWriterExtensions
	{
		public static void WriteObjectValue(this XmlWriter writer, object value, string? nameHint)
		{
			if (value is Azure.Core.IXmlSerializable xmlSerializable)
			{
				xmlSerializable.Write(writer, nameHint);
				return;
			}
			throw new NotImplementedException();
		}

		public static void WriteValue(this XmlWriter writer, DateTimeOffset value, string format)
		{
			writer.WriteValue(Azure.Core.TypeFormatters.ToString(value, format));
		}

		public static void WriteValue(this XmlWriter writer, TimeSpan value, string format)
		{
			writer.WriteValue(Azure.Core.TypeFormatters.ToString(value, format));
		}

		public static void WriteValue(this XmlWriter writer, byte[] value, string format)
		{
			writer.WriteValue(Azure.Core.TypeFormatters.ToString(value, format));
		}
	}
}
namespace Azure.Core.Pipeline
{
	internal static class RetriableStream
	{
		private class RetriableStreamImpl : Stream
		{
			private readonly ResponseClassifier _responseClassifier;

			private readonly Func<long, Stream> _streamFactory;

			private readonly Func<long, ValueTask<Stream>> _asyncStreamFactory;

			private readonly int _maxRetries;

			private readonly long? _length;

			private Stream _currentStream;

			private long _position;

			private int _retryCount;

			private List<Exception> _exceptions;

			public override bool CanRead => _currentStream.CanRead;

			public override bool CanSeek { get; }

			public override long Length => _length ?? throw new NotSupportedException();

			public override long Position
			{
				get
				{
					return _position;
				}
				set
				{
					throw new NotSupportedException();
				}
			}

			public override bool CanWrite => false;

			public RetriableStreamImpl(Stream initialStream, Func<long, Stream> streamFactory, Func<long, ValueTask<Stream>> asyncStreamFactory, ResponseClassifier responseClassifier, int maxRetries)
			{
				if (initialStream.CanSeek)
				{
					try
					{
						_length = EnsureStream(initialStream).Length;
					}
					catch
					{
					}
				}
				_currentStream = EnsureStream(initialStream);
				_streamFactory = streamFactory;
				_responseClassifier = responseClassifier;
				_asyncStreamFactory = asyncStreamFactory;
				_maxRetries = maxRetries;
			}

			public override long Seek(long offset, SeekOrigin origin)
			{
				throw new NotSupportedException();
			}

			public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
			{
				while (true)
				{
					try
					{
						int num = await _currentStream.ReadAsync(buffer, offset, count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						_position += num;
						return num;
					}
					catch (Exception exception)
					{
						await RetryAsync(exception, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
				}
			}

			private async Task RetryAsync(Exception exception, bool async, CancellationToken cancellationToken)
			{
				if (exception is ObjectDisposedException)
				{
					Azure.Core.CancellationHelper.ThrowIfCancellationRequested(cancellationToken);
				}
				bool flag = exception is OperationCanceledException && !cancellationToken.IsCancellationRequested;
				if (!_responseClassifier.IsRetriableException(exception) && !flag)
				{
					ExceptionDispatchInfo.Capture(exception).Throw();
				}
				if (_exceptions == null)
				{
					_exceptions = new List<Exception>();
				}
				_exceptions.Add(exception);
				_retryCount++;
				if (_retryCount > _maxRetries)
				{
					throw new AggregateException($"Retry failed after {_retryCount} tries", _exceptions);
				}
				_currentStream.Dispose();
				Stream stream = ((!async) ? _streamFactory(_position) : (await _asyncStreamFactory(_position).ConfigureAwait(continueOnCapturedContext: false)));
				_currentStream = EnsureStream(stream);
			}

			public override int Read(byte[] buffer, int offset, int count)
			{
				while (true)
				{
					try
					{
						int num = _currentStream.Read(buffer, offset, count);
						_position += num;
						return num;
					}
					catch (Exception exception)
					{
						RetryAsync(exception, async: false, default(CancellationToken)).EnsureCompleted();
					}
				}
			}

			private static Stream EnsureStream(Stream stream)
			{
				if (stream == null)
				{
					throw new InvalidOperationException("The response didn't have content");
				}
				return stream;
			}

			public override void Write(byte[] buffer, int offset, int count)
			{
				throw new NotSupportedException();
			}

			public override void SetLength(long value)
			{
				throw new NotSupportedException();
			}

			public override void Flush()
			{
			}

			protected override void Dispose(bool disposing)
			{
				base.Dispose(disposing);
				_currentStream?.Dispose();
			}
		}

		public static Stream Create(Func<long, Stream> responseFactory, Func<long, ValueTask<Stream>> asyncResponseFactory, ResponseClassifier responseClassifier, int maxRetries)
		{
			return Create(responseFactory(0L), responseFactory, asyncResponseFactory, responseClassifier, maxRetries);
		}

		public static async Task<Stream> CreateAsync(Func<long, Stream> responseFactory, Func<long, ValueTask<Stream>> asyncResponseFactory, ResponseClassifier responseClassifier, int maxRetries)
		{
			return Create(await asyncResponseFactory(0L).ConfigureAwait(continueOnCapturedContext: false), responseFactory, asyncResponseFactory, responseClassifier, maxRetries);
		}

		public static Stream Create(Stream initialResponse, Func<long, Stream> streamFactory, Func<long, ValueTask<Stream>> asyncResponseFactory, ResponseClassifier responseClassifier, int maxRetries)
		{
			return new RetriableStreamImpl(initialResponse, streamFactory, asyncResponseFactory, responseClassifier, maxRetries);
		}
	}
	internal sealed class StorageRequestFailedDetailsParser : RequestFailedDetailsParser
	{
		public override bool TryParse(Response response, out ResponseError? error, out IDictionary<string, string>? data)
		{
			Stream contentStream = response.ContentStream;
			string value4;
			if (contentStream != null && response.Headers.ContentType != null)
			{
				long position = (contentStream.CanSeek ? contentStream.Position : 0);
				try
				{
					if (contentStream.CanSeek)
					{
						contentStream.Position = 0L;
					}
					if (response.Headers.ContentType.Contains("application/xml"))
					{
						XDocument xDocument = XDocument.Load(contentStream);
						string value = xDocument.Root.Element("Code").Value;
						string value2 = xDocument.Root.Element("Message").Value;
						data = new Dictionary<string, string>();
						foreach (XElement item in xDocument.Root.Elements())
						{
							string localName = item.Name.LocalName;
							if (!(localName == "Code") && !(localName == "Message"))
							{
								data[item.Name.LocalName] = item.Value;
							}
						}
						error = new ResponseError(value, value2);
						return true;
					}
					if (response.Headers.ContentType.Contains("application/json"))
					{
						using (JsonDocument jsonDocument = JsonDocument.Parse(contentStream))
						{
							JsonElement property = jsonDocument.RootElement.GetProperty("error");
							if (property.TryGetProperty("detail", out var value3) && value3.ValueKind == JsonValueKind.Object)
							{
								data = new Dictionary<string, string>();
								foreach (JsonProperty item2 in value3.EnumerateObject())
								{
									data[item2.Name] = item2.Value.GetString();
								}
							}
							else
							{
								data = null;
							}
							string message = property.GetProperty("message").GetString();
							string code = property.GetProperty("code").GetString();
							error = new ResponseError(code, message);
							return true;
						}
					}
				}
				finally
				{
					if (contentStream.CanSeek)
					{
						contentStream.Position = position;
					}
				}
			}
			else if (response.Headers.TryGetValue("x-ms-error-code", out value4))
			{
				data = null;
				error = new ResponseError(value4, null);
				return true;
			}
			error = null;
			data = null;
			return false;
		}
	}
	internal class ClientDiagnostics : Azure.Core.Pipeline.DiagnosticScopeFactory
	{
		public ClientDiagnostics(ClientOptions options, bool? suppressNestedClientActivities = null)
			: this(options.GetType().Namespace, GetResourceProviderNamespace(options.GetType().Assembly), options.Diagnostics, suppressNestedClientActivities)
		{
		}

		public ClientDiagnostics(string optionsNamespace, string? providerNamespace, DiagnosticsOptions diagnosticsOptions, bool? suppressNestedClientActivities = null)
			: base(optionsNamespace, providerNamespace, diagnosticsOptions.IsDistributedTracingEnabled, suppressNestedClientActivities ?? true, isStable: true)
		{
		}

		internal static Azure.Core.HttpMessageSanitizer CreateMessageSanitizer(DiagnosticsOptions diagnostics)
		{
			return new Azure.Core.HttpMessageSanitizer(diagnostics.LoggedQueryParameters.ToArray(), diagnostics.LoggedHeaderNames.ToArray());
		}

		internal static string? GetResourceProviderNamespace(Assembly assembly)
		{
			foreach (CustomAttributeData customAttributesDatum in assembly.GetCustomAttributesData())
			{
				if (customAttributesDatum.AttributeType.FullName == "Azure.Core.AzureResourceProviderNamespaceAttribute")
				{
					return customAttributesDatum.ConstructorArguments.Single().Value as string;
				}
			}
			return null;
		}
	}
	internal readonly struct DiagnosticScope : IDisposable
	{
		private class DiagnosticActivity : Activity
		{
			public new IEnumerable<Activity> Links { get; set; } = Array.Empty<Activity>();

			public DiagnosticActivity(string operationName)
				: base(operationName)
			{
			}
		}

		private class ActivityAdapter : IDisposable
		{
			private readonly ActivitySource? _activitySource;

			private readonly DiagnosticSource _diagnosticSource;

			private readonly string _activityName;

			private readonly ActivityKind _kind;

			private readonly object? _diagnosticSourceArgs;

			private Activity? _currentActivity;

			private Activity? _sampleOutActivity;

			private ActivityTagsCollection? _tagCollection;

			private DateTimeOffset _startTime;

			private List<Activity>? _links;

			private string? _traceparent;

			private string? _tracestate;

			private string? _displayName;

			public ActivityAdapter(ActivitySource? activitySource, DiagnosticSource diagnosticSource, string activityName, ActivityKind kind, object? diagnosticSourceArgs)
			{
				_activitySource = activitySource;
				_diagnosticSource = diagnosticSource;
				_activityName = activityName;
				_kind = kind;
				_diagnosticSourceArgs = diagnosticSourceArgs;
			}

			public void AddTag(string name, object value)
			{
				if (_currentActivity == null)
				{
					if (_tagCollection == null)
					{
						_tagCollection = new ActivityTagsCollection();
					}
					_tagCollection.Add(name, value);
				}
				else
				{
					AddObjectTag(name, value);
				}
			}

			private List<ActivityLink>? GetActivitySourceLinkCollection()
			{
				if (_links == null)
				{
					return null;
				}
				List<ActivityLink> list = new List<ActivityLink>();
				foreach (Activity link in _links)
				{
					ActivityTagsCollection activityTagsCollection = new ActivityTagsCollection();
					foreach (KeyValuePair<string, string> tag in link.Tags)
					{
						activityTagsCollection.Add(tag.Key, tag.Value);
					}
					if (ActivityContext.TryParse(link.ParentId, link.TraceStateString, out var context))
					{
						ActivityLink item = new ActivityLink(context, activityTagsCollection);
						list.Add(item);
					}
				}
				return list;
			}

			public void AddLink(string traceparent, string? tracestate, IDictionary<string, string>? attributes)
			{
				Activity activity = new Activity("LinkedActivity");
				activity.SetParentId(traceparent);
				activity.SetIdFormat(ActivityIdFormat.W3C);
				activity.TraceStateString = tracestate;
				if (attributes != null)
				{
					foreach (KeyValuePair<string, string> attribute in attributes)
					{
						activity.AddTag(attribute.Key, attribute.Value);
					}
				}
				if (_links == null)
				{
					_links = new List<Activity>();
				}
				_links.Add(activity);
			}

			[DynamicDependency(DynamicallyAccessedMemberTypes.PublicMethods | DynamicallyAccessedMemberTypes.PublicProperties, typeof(Activity))]
			[DynamicDependency(DynamicallyAccessedMemberTypes.PublicMethods | DynamicallyAccessedMemberTypes.PublicProperties, typeof(DiagnosticActivity))]
			public Activity? Start()
			{
				_currentActivity = StartActivitySourceActivity();
				if (_currentActivity != null)
				{
					if (!_currentActivity.IsAllDataRequested)
					{
						_sampleOutActivity = _currentActivity;
						_currentActivity = null;
						return null;
					}
					_currentActivity.AddTag("az.schema_url", "https://opentelemetry.io/schemas/1.23.0");
				}
				else
				{
					if (!_diagnosticSource.IsEnabled(_activityName, _diagnosticSourceArgs))
					{
						return null;
					}
					switch (_kind)
					{
					case ActivityKind.Internal:
						AddTag("kind", "internal");
						break;
					case ActivityKind.Server:
						AddTag("kind", "server");
						break;
					case ActivityKind.Client:
						AddTag("kind", "client");
						break;
					case ActivityKind.Producer:
						AddTag("kind", "producer");
						break;
					case ActivityKind.Consumer:
						AddTag("kind", "consumer");
						break;
					}
					DiagnosticActivity diagnosticActivity = new DiagnosticActivity(_activityName);
					IEnumerable<Activity> links = _links;
					diagnosticActivity.Links = links ?? Array.Empty<Activity>();
					_currentActivity = diagnosticActivity;
					_currentActivity.SetIdFormat(ActivityIdFormat.W3C);
					if (_startTime != default(DateTimeOffset))
					{
						_currentActivity.SetStartTime(_startTime.UtcDateTime);
					}
					if (_tagCollection != null)
					{
						foreach (KeyValuePair<string, object?> item in _tagCollection)
						{
							AddObjectTag(item.Key, item.Value);
						}
					}
					if (_traceparent != null)
					{
						_currentActivity.SetParentId(_traceparent);
					}
					if (_tracestate != null)
					{
						_currentActivity.TraceStateString = _tracestate;
					}
					_currentActivity.Start();
				}
				WriteStartEvent();
				if (_displayName != null)
				{
					_currentActivity.DisplayName = _displayName;
				}
				return _currentActivity;
			}

			[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026", Justification = "The values being passed into Write have the commonly used properties being preserved with DynamicDependency on the ActivityAdapter.Start() method, or the responsibility is on the user of this struct since the struct constructor is marked with RequiresUnreferencedCode.")]
			private void WriteStartEvent()
			{
				_diagnosticSource.Write(_activityName + ".Start", _diagnosticSourceArgs ?? _currentActivity);
			}

			public void SetDisplayName(string displayName)
			{
				_displayName = displayName;
				if (_currentActivity != null)
				{
					_currentActivity.DisplayName = _displayName;
				}
			}

			private Activity? StartActivitySourceActivity()
			{
				if (_activitySource == null)
				{
					return null;
				}
				ActivityContext parentContext = ((_traceparent == null) ? default(ActivityContext) : ActivityContext.Parse(_traceparent, _tracestate));
				return _activitySource.StartActivity(_activityName, _kind, parentContext, _tagCollection, GetActivitySourceLinkCollection(), _startTime);
			}

			public void SetStartTime(DateTime startTime)
			{
				_startTime = startTime;
				_currentActivity?.SetStartTime(startTime);
			}

			[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026", Justification = "The Exception being passed into this method has the commonly used properties being preserved with DynamicallyAccessedMemberTypes.")]
			public void MarkFailed<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicProperties)] T>(T? exception, string? errorCode)
			{
				if (exception != null)
				{
					_diagnosticSource?.Write(_activityName + ".Exception", exception);
				}
			}

			public void SetTraceContext(string traceparent, string? tracestate)
			{
				if (_currentActivity != null)
				{
					throw new InvalidOperationException("Traceparent can not be set after the activity is started.");
				}
				_traceparent = traceparent;
				_tracestate = tracestate;
			}

			private void AddObjectTag(string name, object value)
			{
				ActivitySource? activitySource = _activitySource;
				if (activitySource != null && activitySource.HasListeners())
				{
					_currentActivity?.AddTag(name, value);
				}
				else
				{
					_currentActivity?.AddTag(name, value.ToString());
				}
			}

			[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The class constructor is marked with RequiresUnreferencedCode.")]
			public void Dispose()
			{
				Activity activity = _currentActivity ?? _sampleOutActivity;
				if (activity != null)
				{
					if (activity.Duration == TimeSpan.Zero)
					{
						activity.SetEndTime(DateTime.UtcNow);
					}
					_diagnosticSource.Write(_activityName + ".Stop", _diagnosticSourceArgs);
					activity.Dispose();
				}
			}
		}

		private const string AzureSdkScopeLabel = "az.sdk.scope";

		internal const string OpenTelemetrySchemaAttribute = "az.schema_url";

		internal const string OpenTelemetrySchemaVersion = "https://opentelemetry.io/schemas/1.23.0";

		private static readonly object AzureSdkScopeValue = bool.TrueString;

		private readonly ActivityAdapter? _activityAdapter;

		private readonly bool _suppressNestedClientActivities;

		public bool IsEnabled { get; }

		[RequiresUnreferencedCode("The diagnosticSourceArgs are used in a call to DiagnosticSource.Write, all necessary properties need to be preserved on the type being passed in using DynamicDependency attributes.")]
		internal DiagnosticScope(string scopeName, DiagnosticListener source, object? diagnosticSourceArgs, ActivitySource? activitySource, ActivityKind kind, bool suppressNestedClientActivities)
		{
			_suppressNestedClientActivities = (kind == ActivityKind.Client || kind == ActivityKind.Internal) && suppressNestedClientActivities;
			bool flag = activitySource?.HasListeners() ?? false;
			IsEnabled = source.IsEnabled() || flag;
			if (_suppressNestedClientActivities)
			{
				IsEnabled &= !AzureSdkScopeValue.Equals(Activity.Current?.GetCustomProperty("az.sdk.scope"));
			}
			_activityAdapter = (IsEnabled ? new ActivityAdapter(activitySource, source, scopeName, kind, diagnosticSourceArgs) : null);
		}

		public void AddAttribute(string name, string? value)
		{
			if (value != null)
			{
				_activityAdapter?.AddTag(name, value);
			}
		}

		public void AddIntegerAttribute(string name, int value)
		{
			_activityAdapter?.AddTag(name, value);
		}

		public void AddAttribute<T>(string name, T value, Func<T, string> format)
		{
			if (_activityAdapter != null && value != null)
			{
				string value2 = format(value);
				_activityAdapter.AddTag(name, value2);
			}
		}

		public void AddLink(string traceparent, string? tracestate, IDictionary<string, string>? attributes = null)
		{
			_activityAdapter?.AddLink(traceparent, tracestate, attributes);
		}

		public void Start()
		{
			(_activityAdapter?.Start())?.SetCustomProperty("az.sdk.scope", AzureSdkScopeValue);
		}

		public void SetDisplayName(string displayName)
		{
			_activityAdapter?.SetDisplayName(displayName);
		}

		public void SetStartTime(DateTime dateTime)
		{
			_activityAdapter?.SetStartTime(dateTime);
		}

		public void SetTraceContext(string traceparent, string? tracestate = null)
		{
			_activityAdapter?.SetTraceContext(traceparent, tracestate);
		}

		public void Dispose()
		{
			_activityAdapter?.Dispose();
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026", Justification = "The Exception being passed into this method has public properties preserved on the inner method MarkFailed.The public property System.Exception.TargetSite.get is not compatible with trimming and produces a warning when preserving all public properties. Since we do not use this property, andneither does Application Insights, we can suppress the warning coming from the inner method.")]
		public void Failed(Exception exception)
		{
			if (exception is RequestFailedException ex)
			{
				_activityAdapter?.MarkFailed(exception, ex.ErrorCode);
			}
			else
			{
				_activityAdapter?.MarkFailed(exception, null);
			}
		}

		public void Failed(string errorCode)
		{
			_activityAdapter?.MarkFailed<Exception>(null, errorCode);
		}
	}
	internal static class ActivityExtensions
	{
		public static bool SupportsActivitySource { get; private set; }

		static ActivityExtensions()
		{
			ResetFeatureSwitch();
		}

		public static void ResetFeatureSwitch()
		{
			SupportsActivitySource = Azure.Core.AppContextSwitchHelper.GetConfigValue("Azure.Experimental.EnableActivitySource", "AZURE_EXPERIMENTAL_ENABLE_ACTIVITY_SOURCE");
		}
	}
	internal class DiagnosticScopeFactory
	{
		private static Dictionary<string, DiagnosticListener>? _listeners;

		private readonly string? _resourceProviderNamespace;

		private readonly DiagnosticListener? _source;

		private readonly bool _suppressNestedClientActivities;

		private readonly bool _isStable;

		private static readonly ConcurrentDictionary<string, ActivitySource?> ActivitySources = new ConcurrentDictionary<string, ActivitySource>();

		public bool IsActivityEnabled { get; }

		public DiagnosticScopeFactory(string clientNamespace, string? resourceProviderNamespace, bool isActivityEnabled, bool suppressNestedClientActivities = true, bool isStable = false)
		{
			_resourceProviderNamespace = resourceProviderNamespace;
			IsActivityEnabled = isActivityEnabled;
			_suppressNestedClientActivities = suppressNestedClientActivities;
			_isStable = isStable;
			if (!IsActivityEnabled)
			{
				return;
			}
			Dictionary<string, DiagnosticListener> dictionary = LazyInitializer.EnsureInitialized(ref _listeners);
			lock (dictionary)
			{
				if (!dictionary.TryGetValue(clientNamespace, out _source))
				{
					_source = new DiagnosticListener(clientNamespace);
					dictionary[clientNamespace] = _source;
				}
			}
		}

		[UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The DiagnosticScope constructor is marked as RequiresUnreferencedCode because of the usage of the diagnosticSourceArgs parameter. Since we are passing in null here we can suppress this warning.")]
		public Azure.Core.Pipeline.DiagnosticScope CreateScope(string name, ActivityKind kind = ActivityKind.Internal)
		{
			if (_source == null)
			{
				return default(Azure.Core.Pipeline.DiagnosticScope);
			}
			Azure.Core.Pipeline.DiagnosticScope result = new Azure.Core.Pipeline.DiagnosticScope(name, _source, null, GetActivitySource(_source.Name, name), kind, _suppressNestedClientActivities);
			if (_resourceProviderNamespace != null)
			{
				result.AddAttribute("az.namespace", _resourceProviderNamespace);
			}
			return result;
		}

		private ActivitySource? GetActivitySource(string ns, string name)
		{
			if (!(_isStable | Azure.Core.Pipeline.ActivityExtensions.SupportsActivitySource))
			{
				return null;
			}
			int num = name.IndexOf(".", StringComparison.OrdinalIgnoreCase);
			string key = ns + "." + ((num < 0) ? name : name.Substring(0, num));
			return ActivitySources.GetOrAdd(key, (string n) => new ActivitySource(n));
		}
	}
	internal static class TaskExtensions
	{
		public readonly struct Enumerable<T> : IEnumerable<T>, IEnumerable
		{
			private readonly IAsyncEnumerable<T> _asyncEnumerable;

			public Enumerable(IAsyncEnumerable<T> asyncEnumerable)
			{
				_asyncEnumerable = asyncEnumerable;
			}

			public Enumerator<T> GetEnumerator()
			{
				return new Enumerator<T>(_asyncEnumerable.GetAsyncEnumerator());
			}

			IEnumerator<T> IEnumerable<T>.GetEnumerator()
			{
				return new Enumerator<T>(_asyncEnumerable.GetAsyncEnumerator());
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct Enumerator<T> : IEnumerator<T>, IEnumerator, IDisposable
		{
			private readonly IAsyncEnumerator<T> _asyncEnumerator;

			public T Current => _asyncEnumerator.Current;

			object IEnumerator.Current => Current;

			public Enumerator(IAsyncEnumerator<T> asyncEnumerator)
			{
				_asyncEnumerator = asyncEnumerator;
			}

			public bool MoveNext()
			{
				return _asyncEnumerator.MoveNextAsync().EnsureCompleted();
			}

			public void Reset()
			{
				throw new NotSupportedException($"{GetType()} is a synchronous wrapper for {_asyncEnumerator.GetType()} async enumerator, which can't be reset, so IEnumerable.Reset() calls aren't supported.");
			}

			public void Dispose()
			{
				_asyncEnumerator.DisposeAsync().EnsureCompleted();
			}
		}

		public readonly struct WithCancellationTaskAwaitable
		{
			private readonly CancellationToken _cancellationToken;

			private readonly ConfiguredTaskAwaitable _awaitable;

			public WithCancellationTaskAwaitable(Task task, CancellationToken cancellationToken)
			{
				_awaitable = task.ConfigureAwait(continueOnCapturedContext: false);
				_cancellationToken = cancellationToken;
			}

			public WithCancellationTaskAwaiter GetAwaiter()
			{
				ConfiguredTaskAwaitable awaitable = _awaitable;
				return new WithCancellationTaskAwaiter(awaitable.GetAwaiter(), _cancellationToken);
			}
		}

		public readonly struct WithCancellationTaskAwaitable<T>
		{
			private readonly CancellationToken _cancellationToken;

			private readonly ConfiguredTaskAwaitable<T> _awaitable;

			public WithCancellationTaskAwaitable(Task<T> task, CancellationToken cancellationToken)
			{
				_awaitable = task.ConfigureAwait(continueOnCapturedContext: false);
				_cancellationToken = cancellationToken;
			}

			public WithCancellationTaskAwaiter<T> GetAwaiter()
			{
				ConfiguredTaskAwaitable<T> awaitable = _awaitable;
				return new WithCancellationTaskAwaiter<T>(awaitable.GetAwaiter(), _cancellationToken);
			}
		}

		public readonly struct WithCancellationValueTaskAwaitable<T>
		{
			private readonly CancellationToken _cancellationToken;

			private readonly ConfiguredValueTaskAwaitable<T> _awaitable;

			public WithCancellationValueTaskAwaitable(ValueTask<T> task, CancellationToken cancellationToken)
			{
				_awaitable = task.ConfigureAwait(continueOnCapturedContext: false);
				_cancellationToken = cancellationToken;
			}

			public WithCancellationValueTaskAwaiter<T> GetAwaiter()
			{
				return new WithCancellationValueTaskAwaiter<T>(_awaitable.GetAwaiter(), _cancellationToken);
			}
		}

		public readonly struct WithCancellationTaskAwaiter : ICriticalNotifyCompletion, INotifyCompletion
		{
			private readonly CancellationToken _cancellationToken;

			private readonly ConfiguredTaskAwaitable.ConfiguredTaskAwaiter _taskAwaiter;

			public bool IsCompleted
			{
				get
				{
					ConfiguredTaskAwaitable.ConfiguredTaskAwaiter taskAwaiter = _taskAwaiter;
					if (!taskAwaiter.IsCompleted)
					{
						CancellationToken cancellationToken = _cancellationToken;
						return cancellationToken.IsCancellationRequested;
					}
					return true;
				}
			}

			public WithCancellationTaskAwaiter(ConfiguredTaskAwaitable.ConfiguredTaskAwaiter awaiter, CancellationToken cancellationToken)
			{
				_taskAwaiter = awaiter;
				_cancellationToken = cancellationToken;
			}

			public void OnCompleted(Action continuation)
			{
				ConfiguredTaskAwaitable.ConfiguredTaskAwaiter taskAwaiter = _taskAwaiter;
				taskAwaiter.OnCompleted(WrapContinuation(in continuation));
			}

			public void UnsafeOnCompleted(Action continuation)
			{
				ConfiguredTaskAwaitable.ConfiguredTaskAwaiter taskAwaiter = _taskAwaiter;
				taskAwaiter.UnsafeOnCompleted(WrapContinuation(in continuation));
			}

			public void GetResult()
			{
				ConfiguredTaskAwaitable.ConfiguredTaskAwaiter taskAwaiter = _taskAwaiter;
				if (!taskAwaiter.IsCompleted)
				{
					CancellationToken cancellationToken = _cancellationToken;
					cancellationToken.ThrowIfCancellationRequested();
				}
				taskAwaiter = _taskAwaiter;
				taskAwaiter.GetResult();
			}

			private Action WrapContinuation(in Action originalContinuation)
			{
				CancellationToken cancellationToken = _cancellationToken;
				if (!cancellationToken.CanBeCanceled)
				{
					return originalContinuation;
				}
				return new WithCancellationContinuationWrapper(originalContinuation, _cancellationToken).Continuation;
			}
		}

		public readonly struct WithCancellationTaskAwaiter<T> : ICriticalNotifyCompletion, INotifyCompletion
		{
			private readonly CancellationToken _cancellationToken;

			private readonly ConfiguredTaskAwaitable<T>.ConfiguredTaskAwaiter _taskAwaiter;

			public bool IsCompleted
			{
				get
				{
					ConfiguredTaskAwaitable<T>.ConfiguredTaskAwaiter taskAwaiter = _taskAwaiter;
					if (!taskAwaiter.IsCompleted)
					{
						CancellationToken cancellationToken = _cancellationToken;
						return cancellationToken.IsCancellationRequested;
					}
					return true;
				}
			}

			public WithCancellationTaskAwaiter(ConfiguredTaskAwaitable<T>.ConfiguredTaskAwaiter awaiter, CancellationToken cancellationToken)
			{
				_taskAwaiter = awaiter;
				_cancellationToken = cancellationToken;
			}

			public void OnCompleted(Action continuation)
			{
				ConfiguredTaskAwaitable<T>.ConfiguredTaskAwaiter taskAwaiter = _taskAwaiter;
				taskAwaiter.OnCompleted(WrapContinuation(in continuation));
			}

			public void UnsafeOnCompleted(Action continuation)
			{
				ConfiguredTaskAwaitable<T>.ConfiguredTaskAwaiter taskAwaiter = _taskAwaiter;
				taskAwaiter.UnsafeOnCompleted(WrapContinuation(in continuation));
			}

			public T GetResult()
			{
				ConfiguredTaskAwaitable<T>.ConfiguredTaskAwaiter taskAwaiter = _taskAwaiter;
				if (!taskAwaiter.IsCompleted)
				{
					CancellationToken cancellationToken = _cancellationToken;
					cancellationToken.ThrowIfCancellationRequested();
				}
				taskAwaiter = _taskAwaiter;
				return taskAwaiter.GetResult();
			}

			private Action WrapContinuation(in Action originalContinuation)
			{
				CancellationToken cancellationToken = _cancellationToken;
				if (!cancellationToken.CanBeCanceled)
				{
					return originalContinuation;
				}
				return new WithCancellationContinuationWrapper(originalContinuation, _cancellationToken).Continuation;
			}
		}

		public readonly struct WithCancellationValueTaskAwaiter<T> : ICriticalNotifyCompletion, INotifyCompletion
		{
			private readonly CancellationToken _cancellationToken;

			private readonly ConfiguredValueTaskAwaitable<T>.ConfiguredValueTaskAwaiter _taskAwaiter;

			public bool IsCompleted
			{
				get
				{
					if (!_taskAwaiter.IsCompleted)
					{
						CancellationToken cancellationToken = _cancellationToken;
						return cancellationToken.IsCancellationRequested;
					}
					return true;
				}
			}

			public WithCancellationValueTaskAwaiter(ConfiguredValueTaskAwaitable<T>.ConfiguredValueTaskAwaiter awaiter, CancellationToken cancellationToken)
			{
				_taskAwaiter = awaiter;
				_cancellationToken = cancellationToken;
			}

			public void OnCompleted(Action continuation)
			{
				_taskAwaiter.OnCompleted(WrapContinuation(in continuation));
			}

			public void UnsafeOnCompleted(Action continuation)
			{
				_taskAwaiter.UnsafeOnCompleted(WrapContinuation(in continuation));
			}

			public T GetResult()
			{
				if (!_taskAwaiter.IsCompleted)
				{
					CancellationToken cancellationToken = _cancellationToken;
					cancellationToken.ThrowIfCancellationRequested();
				}
				return _taskAwaiter.GetResult();
			}

			private Action WrapContinuation(in Action originalContinuation)
			{
				CancellationToken cancellationToken = _cancellationToken;
				if (!cancellationToken.CanBeCanceled)
				{
					return originalContinuation;
				}
				return new WithCancellationContinuationWrapper(originalContinuation, _cancellationToken).Continuation;
			}
		}

		private class WithCancellationContinuationWrapper
		{
			private Action _originalContinuation;

			private readonly CancellationTokenRegistration _registration;

			public Action Continuation { get; }

			public WithCancellationContinuationWrapper(Action originalContinuation, CancellationToken cancellationToken)
			{
				Action callback = ContinuationImplementation;
				_originalContinuation = originalContinuation;
				_registration = cancellationToken.Register(callback);
				Continuation = callback;
			}

			private void ContinuationImplementation()
			{
				Action action = Interlocked.Exchange(ref _originalContinuation, null);
				if (action != null)
				{
					CancellationTokenRegistration registration = _registration;
					registration.Dispose();
					action();
				}
			}
		}

		public static WithCancellationTaskAwaitable AwaitWithCancellation(this Task task, CancellationToken cancellationToken)
		{
			return new WithCancellationTaskAwaitable(task, cancellationToken);
		}

		public static WithCancellationTaskAwaitable<T> AwaitWithCancellation<T>(this Task<T> task, CancellationToken cancellationToken)
		{
			return new WithCancellationTaskAwaitable<T>(task, cancellationToken);
		}

		public static WithCancellationValueTaskAwaitable<T> AwaitWithCancellation<T>(this ValueTask<T> task, CancellationToken cancellationToken)
		{
			return new WithCancellationValueTaskAwaitable<T>(task, cancellationToken);
		}

		public static T EnsureCompleted<T>(this Task<T> task)
		{
			return task.GetAwaiter().GetResult();
		}

		public static void EnsureCompleted(this Task task)
		{
			task.GetAwaiter().GetResult();
		}

		public static T EnsureCompleted<T>(this ValueTask<T> task)
		{
			return task.GetAwaiter().GetResult();
		}

		public static void EnsureCompleted(this ValueTask task)
		{
			task.GetAwaiter().GetResult();
		}

		public static Enumerable<T> EnsureSyncEnumerable<T>(this IAsyncEnumerable<T> asyncEnumerable)
		{
			return new Enumerable<T>(asyncEnumerable);
		}

		public static ConfiguredValueTaskAwaitable<T> EnsureCompleted<T>(this ConfiguredValueTaskAwaitable<T> awaitable, bool async)
		{
			return awaitable;
		}

		public static ConfiguredValueTaskAwaitable EnsureCompleted(this ConfiguredValueTaskAwaitable awaitable, bool async)
		{
			return awaitable;
		}

		[Conditional("DEBUG")]
		private static void VerifyTaskCompleted(bool isCompleted)
		{
			if (!isCompleted)
			{
				if (Debugger.IsAttached)
				{
					Debugger.Break();
				}
				throw new InvalidOperationException("Task is not completed");
			}
		}
	}
}
namespace Azure.Storage
{
	internal sealed class AggregatingProgressIncrementer : IProgress<long>
	{
		private long _currentValue;

		private readonly IProgress<long> _innerHandler;

		public static AggregatingProgressIncrementer None { get; } = new AggregatingProgressIncrementer(null);

		public long Current => Volatile.Read(ref _currentValue);

		public Stream CreateProgressIncrementingStream(Stream stream)
		{
			if (_innerHandler == null || stream == null)
			{
				return stream;
			}
			return new ProgressIncrementingStream(stream, this);
		}

		public AggregatingProgressIncrementer(IProgress<long> innerHandler)
		{
			_innerHandler = innerHandler;
		}

		public void Report(long bytes)
		{
			Interlocked.Add(ref _currentValue, bytes);
			_innerHandler?.Report(Current);
		}

		public void Reset()
		{
			Volatile.Write(ref _currentValue, 0L);
			Report(0L);
		}
	}
	internal static class BufferExtensions
	{
		private class DisposableRentedArray<T> : IDisposable
		{
			private ArrayPool<T> _pool;

			private T[] _rentedArray;

			public DisposableRentedArray(ArrayPool<T> pool, T[] rentedArray)
			{
				_pool = pool;
				_rentedArray = rentedArray;
			}

			public void Dispose()
			{
				_pool.Return(_rentedArray);
			}
		}

		public static IDisposable RentDisposable<T>(this ArrayPool<T> pool, int minimumLength, out T[] array)
		{
			array = pool.Rent(minimumLength);
			return new DisposableRentedArray<T>(pool, array);
		}

		public static IDisposable RentAsMemoryDisposable<T>(this ArrayPool<T> pool, int minimumLength, out Memory<T> memory)
		{
			if (minimumLength == 0)
			{
				memory = Memory<T>.Empty;
				return null;
			}
			T[] array;
			IDisposable result = pool.RentDisposable(minimumLength, out array);
			memory = new Memory<T>(array, 0, minimumLength);
			return result;
		}

		public static IDisposable RentAsSpanDisposable<T>(this ArrayPool<T> pool, int minimumLength, out Span<T> span)
		{
			if (minimumLength == 0)
			{
				span = Span<T>.Empty;
				return null;
			}
			T[] array;
			IDisposable result = pool.RentDisposable(minimumLength, out array);
			span = new Span<T>(array, 0, minimumLength);
			return result;
		}

		public static T[] Clear<T>(this T[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = default(T);
			}
			return array;
		}
	}
	internal class ChecksumCalculatingStream : Stream
	{
		public delegate void AppendChecksumCalculation(ReadOnlySpan<byte> checksum);

		private readonly Stream _stream;

		private readonly AppendChecksumCalculation _appendChecksumCalculation;

		private readonly long _initialPosition;

		private long _nextToBeChecksummedPosition;

		public override bool CanRead { get; }

		public override bool CanWrite { get; }

		public override bool CanSeek
		{
			get
			{
				if (!CanWrite)
				{
					return _stream.CanSeek;
				}
				return false;
			}
		}

		public override long Length => _stream.Length;

		public override long Position
		{
			get
			{
				return _stream.Position;
			}
			set
			{
				Seek(value, SeekOrigin.Begin);
			}
		}

		public override bool CanTimeout => _stream.CanTimeout;

		public override int ReadTimeout
		{
			get
			{
				return _stream.ReadTimeout;
			}
			set
			{
				_stream.ReadTimeout = value;
			}
		}

		public override int WriteTimeout
		{
			get
			{
				return _stream.WriteTimeout;
			}
			set
			{
				_stream.WriteTimeout = value;
			}
		}

		public static Stream GetReadStream(Stream stream, AppendChecksumCalculation appendChecksumCalculation)
		{
			return new ChecksumCalculatingStream(stream, appendChecksumCalculation, isReadMode: true);
		}

		public static Stream GetWriteStream(Stream stream, AppendChecksumCalculation appendChecksumCalculation)
		{
			return new ChecksumCalculatingStream(stream, appendChecksumCalculation, isReadMode: false);
		}

		private ChecksumCalculatingStream(Stream stream, AppendChecksumCalculation appendChecksumCalculation, bool isReadMode)
		{
			Azure.Core.Argument.AssertNotNull(stream, "stream");
			Azure.Core.Argument.AssertNotNull(appendChecksumCalculation, "appendChecksumCalculation");
			CanRead = isReadMode;
			CanWrite = !isReadMode;
			if (CanRead && !stream.CanRead)
			{
				throw new ArgumentException("Created stream in read mode but base stream cannot read.");
			}
			if (CanWrite && !stream.CanWrite)
			{
				throw new ArgumentException("Created stream in write mode but base stream cannot write.");
			}
			_stream = stream;
			_appendChecksumCalculation = appendChecksumCalculation;
			if (_stream.CanSeek)
			{
				_initialPosition = _stream.Position;
				_nextToBeChecksummedPosition = _stream.Position;
			}
			else
			{
				_initialPosition = -1L;
				_nextToBeChecksummedPosition = -1L;
			}
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (!CanSeek)
			{
				return ReadUnseekableInternal(buffer, offset, count, async: false, default(CancellationToken)).EnsureCompleted();
			}
			return ReadSeekableInternal(buffer, offset, count, async: false, default(CancellationToken)).EnsureCompleted();
		}

		public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
		{
			return (!CanSeek) ? (await ReadUnseekableInternal(buffer, offset, count, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)) : (await ReadSeekableInternal(buffer, offset, count, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		private async Task<int> ReadSeekableInternal(byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
		{
			AssertCanRead();
			Azure.Core.Argument.AssertInRange(_stream.Position, _initialPosition, _nextToBeChecksummedPosition, "Position");
			long startingPosition = _stream.Position;
			int num = await _stream.ReadInternal(buffer, offset, count, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (num > 0 && startingPosition + num >= _nextToBeChecksummedPosition)
			{
				int num2 = (int)(_nextToBeChecksummedPosition - startingPosition);
				_appendChecksumCalculation(new ReadOnlySpan<byte>(buffer, offset + num2, num - num2));
				_nextToBeChecksummedPosition += num - num2;
			}
			return num;
		}

		private async Task<int> ReadUnseekableInternal(byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
		{
			AssertCanRead();
			int num = await _stream.ReadInternal(buffer, offset, count, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (num > 0)
			{
				_appendChecksumCalculation(new ReadOnlySpan<byte>(buffer, offset, num));
			}
			_nextToBeChecksummedPosition += num;
			return num;
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			WriteInternal(buffer, offset, count, async: false, default(CancellationToken)).EnsureCompleted();
		}

		public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
		{
			await WriteInternal(buffer, offset, count, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task WriteInternal(byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
		{
			AssertCanWrite();
			if (CanSeek && _nextToBeChecksummedPosition != _stream.Position)
			{
				throw new InvalidOperationException("Stream position was moved, cannot properly checksum contents.");
			}
			_appendChecksumCalculation(new ReadOnlySpan<byte>(buffer, offset, count));
			await _stream.WriteInternal(buffer, offset, count, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			_nextToBeChecksummedPosition += count;
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			if (CanWrite)
			{
				throw new NotSupportedException("No seek support in write mode.");
			}
			if (_stream.CanSeek)
			{
				long num = origin switch
				{
					SeekOrigin.Begin => offset, 
					SeekOrigin.Current => _stream.Position + offset, 
					SeekOrigin.End => _stream.Length + offset, 
					_ => throw new ArgumentException($"SeekOrigin '{origin}' not recognized"), 
				};
				if (num < _initialPosition || _nextToBeChecksummedPosition < num)
				{
					throw new NotSupportedException("Cannot seek past current checksum calculation point.");
				}
			}
			return _stream.Seek(offset, origin);
		}

		public override void Flush()
		{
			_stream.Flush();
		}

		public override async Task FlushAsync(CancellationToken cancellationToken)
		{
			await _stream.FlushAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public override void Close()
		{
			_stream.Close();
		}

		public override void SetLength(long value)
		{
			_stream.SetLength(value);
		}

		private void AssertCanRead()
		{
			if (!CanRead)
			{
				throw new NotSupportedException("Cannot read from stream.");
			}
		}

		private void AssertCanWrite()
		{
			if (!CanWrite)
			{
				throw new NotSupportedException("Cannot write to stream.");
			}
		}
	}
	internal static class Constants
	{
		internal static class ConnectionStrings
		{
			internal const int BlobEndpointPortNumber = 10000;

			internal const int QueueEndpointPortNumber = 10001;

			internal const int TableEndpointPortNumber = 10002;

			internal const string UseDevelopmentSetting = "UseDevelopmentStorage";

			internal const string DevelopmentProxyUriSetting = "DevelopmentStorageProxyUri";

			internal const string DefaultEndpointsProtocolSetting = "DefaultEndpointsProtocol";

			internal const string AccountNameSetting = "AccountName";

			internal const string AccountKeyNameSetting = "AccountKeyName";

			internal const string AccountKeySetting = "AccountKey";

			internal const string BlobEndpointSetting = "BlobEndpoint";

			internal const string QueueEndpointSetting = "QueueEndpoint";

			internal const string TableEndpointSetting = "TableEndpoint";

			internal const string FileEndpointSetting = "FileEndpoint";

			internal const string BlobSecondaryEndpointSetting = "BlobSecondaryEndpoint";

			internal const string QueueSecondaryEndpointSetting = "QueueSecondaryEndpoint";

			internal const string TableSecondaryEndpointSetting = "TableSecondaryEndpoint";

			internal const string FileSecondaryEndpointSetting = "FileSecondaryEndpoint";

			internal const string EndpointSuffixSetting = "EndpointSuffix";

			internal const string SharedAccessSignatureSetting = "SharedAccessSignature";

			internal const string DevStoreAccountName = "devstoreaccount1";

			internal const string DevStoreAccountKey = "Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==";

			internal const string SecondaryLocationAccountSuffix = "-secondary";

			internal const string DefaultEndpointSuffix = "core.windows.net";

			internal const string DefaultBlobHostnamePrefix = "blob";

			internal const string DefaultQueueHostnamePrefix = "queue";

			internal const string DefaultTableHostnamePrefix = "table";

			internal const string DefaultFileHostnamePrefix = "file";
		}

		internal static class HeaderNames
		{
			public const string XMsPrefix = "x-ms-";

			public const string MetadataPrefix = "x-ms-meta-";

			public const string ErrorCode = "x-ms-error-code";

			public const string RequestId = "x-ms-request-id";

			public const string ClientRequestId = "x-ms-client-request-id";

			public const string Date = "x-ms-date";

			public const string SharedKey = "SharedKey";

			public const string Authorization = "Authorization";

			public const string ContentEncoding = "Content-Encoding";

			public const string ContentLanguage = "Content-Language";

			public const string ContentLength = "Content-Length";

			public const string ContentMD5 = "Content-MD5";

			public const string ContentType = "Content-Type";

			public const string IfModifiedSince = "If-Modified-Since";

			public const string IfMatch = "If-Match";

			public const string IfNoneMatch = "If-None-Match";

			public const string IfUnmodifiedSince = "If-Unmodified-Since";

			public const string Range = "Range";

			public const string ContentRange = "Content-Range";

			public const string VersionId = "x-ms-version-id";

			public const string LeaseTime = "x-ms-lease-time";

			public const string LeaseId = "x-ms-lease-id";

			public const string LastModified = "Last-Modified";

			public const string ETag = "ETag";
		}

		internal static class ErrorCodes
		{
			public const string InternalError = "InternalError";

			public const string OperationTimedOut = "OperationTimedOut";

			public const string ServerBusy = "ServerBusy";

			public const string ContainerAlreadyExists = "ContainerAlreadyExists";

			public const string BlobAlreadyExists = "BlobAlreadyExists";
		}

		internal static class Blob
		{
			internal static class Append
			{
				public const int Pre_2022_11_02_MaxAppendBlockBytes = 4194304;

				public const int MaxAppendBlockBytes = 104857600;

				public const int MaxBlocks = 50000;
			}

			internal static class Block
			{
				public const int DefaultConcurrentTransfersCount = 5;

				public const int DefaultInitalDownloadRangeSize = 268435456;

				public const int Pre_2019_12_12_MaxUploadBytes = 268435456;

				public const long MaxUploadBytes = 5242880000L;

				public const int MaxDownloadBytes = 268435456;

				public const int Pre_2019_12_12_MaxStageBytes = 104857600;

				public const long MaxStageBytes = 4194304000L;

				public const int MaxBlocks = 50000;
			}

			internal static class Page
			{
				public const int PageSizeBytes = 512;

				public const int MaxPageBlockBytes = 4194304;
			}

			internal static class Container
			{
				public const string Name = "Blob Container";

				public const string RootName = "$root";

				public const string LogsName = "$logs";

				public const string WebName = "$web";
			}

			internal static class Lease
			{
				public const int InfiniteLeaseDuration = -1;
			}

			public const int HttpsPort = 443;

			public const string UriSubDomain = "blob";

			public const int QuickQueryDownloadSize = 4194304;

			public const string MetadataHeaderPrefix = "x-ms-meta-";

			public const string ObjectReplicationRulesHeaderPrefix = "x-ms-or-";
		}

		internal static class File
		{
			internal static class Lease
			{
				public const long InfiniteLeaseDuration = -1L;
			}

			internal static class Errors
			{
				public const string ShareUsageBytesOverflow = "ShareUsageBytes exceeds int.MaxValue. Use ShareUsageInBytes instead.";

				public const string LeaseNotPresentWithFileOperation = "LeaseNotPresentWithFileOperation";
			}

			internal static class Share
			{
				public const string Name = "Share";
			}

			public const string UriSubDomain = "file";

			public const string FileAttributesNone = "None";

			public const string FileTimeNow = "Now";

			public const string Preserve = "Preserve";

			public const string Source = "Source";

			public const string FilePermissionInherit = "Inherit";

			public const int MaxFilePermissionHeaderSize = 8192;

			public const int MaxFileUpdateRange = 4194304;

			public const string FileTimeFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffff'Z'";

			public const string SnapshotParameterName = "sharesnapshot";

			public const string SmbProtocol = "SMB";

			public const string NfsProtocol = "NFS";
		}

		internal static class DataLake
		{
			public const string BlobUriSuffix = "blob";

			public const string BlobUriPeriodSuffix = ".blob.";

			public const string DfsUriSuffix = "dfs";

			public const string DfsUriPeriodSuffix = ".dfs.";

			public const string ErrorKey = "error";

			public const string ErrorCodeKey = "code";

			public const string ErrorMessageKey = "message";

			public const string AlreadyExists = "ContainerAlreadyExists";

			public const string FilesystemNotFound = "FilesystemNotFound";

			public const string PathNotFound = "PathNotFound";

			public const string PathAlreadyExists = "PathAlreadyExists";

			public const int DefaultConcurrentTransfersCount = 5;

			public const int Pre_2019_12_12_MaxAppendBytes = 104857600;

			public const long MaxAppendBytes = 4194304000L;

			public const string IsDirectoryKey = "hdi_isFolder";

			public const string FileSystemName = "FileSystem";

			public const string DeletionId = "deletionid";

			public const string DirectoryResourceType = "directory";

			public const string EncryptionContextHeaderName = "x-ms-encryption-context";

			public const string OwnerHeaderName = "x-ms-owner";

			public const string GroupHeaderName = "x-ms-group";

			public const string PermissionsHeaderName = "x-ms-permissions";
		}

		internal static class Queue
		{
			public const int MaxMessagesDequeue = 32;

			public const int QueueMessageMaxBytes = 65536;

			public const int StatusCodeNoContent = 204;

			public const string MessagesUri = "messages";

			public const string UriSubDomain = "queue";

			public const string QueueTraitsMetadata = "metadata";
		}

		internal static class ChangeFeed
		{
			internal static class Event
			{
				public const string Topic = "topic";

				public const string Subject = "subject";

				public const string EventType = "eventType";

				public const string EventTime = "eventTime";

				public const string EventId = "id";

				public const string Data = "data";

				public const string SchemaVersion = "schemaVersion";

				public const string MetadataVersion = "metadataVersion";
			}

			internal static class EventData
			{
				public const string Api = "api";

				public const string ClientRequestId = "clientRequestId";

				public const string RequestId = "requestId";

				public const string Etag = "etag";

				public const string ContentType = "contentType";

				public const string ContentLength = "contentLength";

				public const string BlobType = "blobType";

				public const string BlobVersionLower = "blobVersion";

				public const string ContainerVersion = "containerVersion";

				public const string BlobTier = "blobTier";

				public const string BlockBlob = "BlockBlob";

				public const string PageBlob = "PageBlob";

				public const string AppendBlob = "AppendBlob";

				public const string ContentOffset = "contentOffset";

				public const string DestinationUrl = "destinationUrl";

				public const string SourceUrl = "sourceUrl";

				public const string Url = "url";

				public const string Recursive = "recursive";

				public const string Sequencer = "sequencer";

				public const string PreviousInfo = "previousInfo";

				public const string Snapshot = "snapshot";

				public const string BlobPropertiesUpdated = "blobPropertiesUpdated";

				public const string AsyncOperationInfo = "asyncOperationInfo";

				public const string Current = "current";

				public const string Previous = "previous";

				public const string DestinationTier = "DestinationTier";

				public const string WasAsyncOperation = "WasAsyncOperation";

				public const string CopyId = "CopyId";

				public const string SoftDeletedSnapshot = "SoftDeleteSnapshot";

				public const string WasBlobSoftDeleted = "WasBlobSoftDeleted";

				public const string BlobVersion = "BlobVersion";

				public const string LastVersion = "LastVersion";

				public const string PreviousTier = "PreviousTier";

				public const string BlobTagsUpdated = "blobTagsUpdated";
			}

			public const string ChangeFeedContainerName = "$blobchangefeed";

			public const string SegmentPrefix = "idx/segments/";

			public const string InitalizationManifestPath = "/0000/";

			public const string InitalizationSegment = "1601";

			public const string MetaSegmentsPath = "meta/segments.json";

			public const long ChunkBlockDownloadSize = 1048576L;

			public const int DefaultPageSize = 5000;

			public const int LazyLoadingBlobStreamBlockSize = 3072;
		}

		internal static class QuickQuery
		{
			public const string SqlQueryType = "SQL";

			public const string Data = "data";

			public const string BytesScanned = "bytesScanned";

			public const string TotalBytes = "totalBytes";

			public const string Fatal = "fatal";

			public const string Name = "name";

			public const string Description = "description";

			public const string Position = "position";

			public const string DataRecordName = "com.microsoft.azure.storage.queryBlobContents.resultData";

			public const string ProgressRecordName = "com.microsoft.azure.storage.queryBlobContents.progress";

			public const string ErrorRecordName = "com.microsoft.azure.storage.queryBlobContents.error";

			public const string EndRecordName = "com.microsoft.azure.storage.queryBlobContents.end";

			public const string ArrowFieldTypeInt64 = "int64";

			public const string ArrowFieldTypeBool = "bool";

			public const string ArrowFieldTypeTimestamp = "timestamp[ms]";

			public const string ArrowFieldTypeString = "string";

			public const string ArrowFieldTypeDouble = "double";

			public const string ArrowFieldTypeDecimal = "decimal";
		}

		internal static class Sas
		{
			internal static class Permissions
			{
				public const char Read = 'r';

				public const char Write = 'w';

				public const char Delete = 'd';

				public const char DeleteBlobVersion = 'x';

				public const char List = 'l';

				public const char Add = 'a';

				public const char Update = 'u';

				public const char Process = 'p';

				public const char Create = 'c';

				public const char Tag = 't';

				public const char FilterByTags = 'f';

				public const char Move = 'm';

				public const char Execute = 'e';

				public const char SetImmutabilityPolicy = 'i';

				public const char ManageOwnership = 'o';

				public const char ManageAccessControl = 'p';

				public const char PermanentDelete = 'y';
			}

			internal static class Parameters
			{
				public const string Version = "sv";

				public const string VersionUpper = "SV";

				public const string Services = "ss";

				public const string ServicesUpper = "SS";

				public const string ResourceTypes = "srt";

				public const string ResourceTypesUpper = "SRT";

				public const string Protocol = "spr";

				public const string ProtocolUpper = "SPR";

				public const string StartTime = "st";

				public const string StartTimeUpper = "ST";

				public const string ExpiryTime = "se";

				public const string ExpiryTimeUpper = "SE";

				public const string IPRange = "sip";

				public const string IPRangeUpper = "SIP";

				public const string Identifier = "si";

				public const string IdentifierUpper = "SI";

				public const string Resource = "sr";

				public const string ResourceUpper = "SR";

				public const string Permissions = "sp";

				public const string PermissionsUpper = "SP";

				public const string Signature = "sig";

				public const string SignatureUpper = "SIG";

				public const string KeyObjectId = "skoid";

				public const string KeyObjectIdUpper = "SKOID";

				public const string KeyTenantId = "sktid";

				public const string KeyTenantIdUpper = "SKTID";

				public const string KeyStart = "skt";

				public const string KeyStartUpper = "SKT";

				public const string KeyExpiry = "ske";

				public const string KeyExpiryUpper = "SKE";

				public const string KeyService = "sks";

				public const string KeyServiceUpper = "SKS";

				public const string KeyVersion = "skv";

				public const string KeyVersionUpper = "SKV";

				public const string CacheControl = "rscc";

				public const string CacheControlUpper = "RSCC";

				public const string ContentDisposition = "rscd";

				public const string ContentDispositionUpper = "RSCD";

				public const string ContentEncoding = "rsce";

				public const string ContentEncodingUpper = "RSCE";

				public const string ContentLanguage = "rscl";

				public const string ContentLanguageUpper = "RSCL";

				public const string ContentType = "rsct";

				public const string ContentTypeUpper = "RSCT";

				public const string PreauthorizedAgentObjectId = "saoid";

				public const string PreauthorizedAgentObjectIdUpper = "SAOID";

				public const string AgentObjectId = "suoid";

				public const string AgentObjectIdUpper = "SUOID";

				public const string CorrelationId = "scid";

				public const string CorrelationIdUpper = "SCID";

				public const string DirectoryDepth = "sdd";

				public const string DirectoryDepthUpper = "SDD";

				public const string EncryptionScope = "ses";

				public const string EncryptionScopeUpper = "SES";
			}

			internal static class Resource
			{
				public const string BlobSnapshot = "bs";

				public const string BlobVersion = "bv";

				public const string Blob = "b";

				public const string Container = "c";

				public const string File = "f";

				public const string Share = "s";

				public const string Directory = "d";
			}

			internal static class AccountServices
			{
				public const char Blob = 'b';

				public const char Queue = 'q';

				public const char File = 'f';

				public const char Table = 't';
			}

			internal static class AccountResources
			{
				public const char Service = 's';

				public const char Container = 'c';

				public const char Object = 'o';
			}

			public static readonly List<char> ValidPermissionsInOrder = new List<char>
			{
				'r', 'a', 'c', 'w', 'd', 'x', 'y', 'l', 't', 'u',
				'p', 'f', 'm', 'e', 'i'
			};

			internal static readonly int[] PathStylePorts = new int[20]
			{
				10000, 10001, 10002, 10003, 10004, 10100, 10101, 10102, 10103, 10104,
				11000, 11001, 11002, 11003, 11004, 11100, 11101, 11102, 11103, 11104
			};
		}

		internal static class ClientSideEncryption
		{
			internal static class V2
			{
				public const int EncryptionRegionDataSize = 4194304;

				public const int NonceSize = 12;

				public const int TagSize = 16;

				public const int EncryptionRegionTotalSize = 4194332;

				public const int WrappedDataVersionLength = 8;
			}

			public const string HttpMessagePropertyKeyV1 = "Azure.Storage.StorageTelemetryPolicy.ClientSideEncryption.V1";

			public const string HttpMessagePropertyKeyV2 = "Azure.Storage.StorageTelemetryPolicy.ClientSideEncryption.V2";

			public const string AgentMetadataKey = "EncryptionLibrary";

			public const string AesCbcPkcs5Padding = "AES/CBC/PKCS5Padding";

			public const string AesCbcNoPadding = "AES/CBC/NoPadding";

			public const string EncryptionDataKey = "encryptiondata";

			public const string EncryptionMode = "FullBlob";

			public const int EncryptionBlockSize = 16;

			public const int EncryptionKeySizeBits = 256;

			public const string XMsRange = "x-ms-range";

			public const string BCRYPT_AES_ALGORITHM = "AES";

			public const string BCRYPT_CHAIN_MODE_GCM = "ChainingModeGCM";

			public const string BCRYPT_CHAINING_MODE = "ChainingMode";

			internal const string BCryptdll = "BCrypt.dll";
		}

		internal static class Xml
		{
			internal const string Code = "Code";

			internal const string Message = "Message";
		}

		internal static class GeoRedundantRead
		{
			internal const string AlternateHostKey = "AlternateHostKey";

			internal const string ResourceNotReplicated = "ResourceNotReplicated";
		}

		internal static class HttpStatusCode
		{
			internal const int NotFound = 404;

			internal const int NotModified = 304;
		}

		internal static class ServerTimeout
		{
			internal const string HttpMessagePropertyKey = "Azure.Storage.StorageServerTimeoutPolicy.Timeout";

			internal const string QueryParameterKey = "timeout";
		}

		internal static class CopyHttpAuthorization
		{
			internal static readonly string[] Scopes = new string[1] { "https://storage.azure.com/.default" };

			internal const string BearerScheme = "Bearer";
		}

		public const int KB = 1024;

		public const int MB = 1048576;

		public const int GB = 1073741824;

		public const long TB = 1099511627776L;

		public const int Base16 = 16;

		public const int MaxReliabilityRetries = 5;

		public const int MaxIdleTimeMs = 120000;

		public const string DefaultSasVersion = "2023-11-03";

		public const int MaxHashRequestDownloadRange = 4194304;

		public const int DefaultBufferSize = 4194304;

		public const int LargeBufferSize = 8388608;

		public const int LargeUploadThreshold = 104857600;

		public const int DefaultStreamingDownloadSize = 4194304;

		public const int DefaultStreamCopyBufferSize = 81920;

		public const int DefaultDownloadCopyBufferSize = 16384;

		public const int StorageCrc64SizeInBytes = 8;

		public const int MD5SizeInBytes = 16;

		public const bool DefaultTrimBlobNameSlashes = true;

		public const string CloseAllHandles = "*";

		public const string Wildcard = "*";

		public const string BlockNameFormat = "Block_{0:D5}";

		public const string SasTimeFormatSeconds = "yyyy-MM-ddTHH:mm:ssZ";

		public const string SasTimeFormatSubSeconds = "yyyy-MM-ddTHH:mm:ss.fffffffZ";

		public const string SasTimeFormatMinutes = "yyyy-MM-ddTHH:mmZ";

		public const string SasTimeFormatDays = "yyyy-MM-dd";

		public const string SnapshotParameterName = "snapshot";

		public const string VersionIdParameterName = "versionid";

		public const string ShareSnapshotParameterName = "sharesnapshot";

		public const string Https = "https";

		public const string Http = "http";

		public const string PercentSign = "%";

		public const string EncodedPercentSign = "%25";

		public const string QueryDelimiter = "?";

		public const string PathBackSlashDelimiter = "/";

		public const string FalseName = "false";

		public const string TrueName = "true";

		public const string ErrorCode = "Code";

		public const string ErrorMessage = "Message";

		public const string CommaString = ",";

		public const char CommaChar = ',';

		public const string ContentTypeApplicationXml = "application/xml";

		public const string ContentTypeApplicationJson = "application/json";

		public const string ErrorPropertyKey = "error";

		public const string DetailPropertyKey = "detail";

		public const string MessagePropertyKey = "message";

		public const string CodePropertyKey = "code";

		public const string Iso8601Format = "yyyy'-'MM'-'dd'T'HH':'mm':'ssZ";

		public const string DisableRequestConditionsValidationSwitchName = "Azure.Storage.DisableRequestConditionsValidation";

		public const string DisableRequestConditionsValidationEnvVar = "AZURE_STORAGE_DISABLE_REQUEST_CONDITIONS_VALIDATION";

		public const string DefaultScope = "/.default";
	}
	internal static class CompatSwitches
	{
		private static bool? _disableRequestConditionsValidation;

		public static bool DisableRequestConditionsValidation
		{
			get
			{
				bool valueOrDefault = _disableRequestConditionsValidation == true;
				if (!_disableRequestConditionsValidation.HasValue)
				{
					valueOrDefault = Azure.Core.AppContextSwitchHelper.GetConfigValue("Azure.Storage.DisableRequestConditionsValidation", "AZURE_STORAGE_DISABLE_REQUEST_CONDITIONS_VALIDATION");
					_disableRequestConditionsValidation = valueOrDefault;
					return valueOrDefault;
				}
				return valueOrDefault;
			}
		}
	}
	internal static class ContentHasher
	{
		internal class GetHashResult
		{
			public static GetHashResult Empty { get; } = new GetHashResult(StorageChecksumAlgorithm.None, default(ReadOnlyMemory<byte>));

			public StorageChecksumAlgorithm Algorithm { get; }

			public ReadOnlyMemory<byte> Checksum { get; }

			public ReadOnlyMemory<byte> MD5
			{
				get
				{
					if (Algorithm != StorageChecksumAlgorithm.MD5)
					{
						return default(ReadOnlyMemory<byte>);
					}
					return Checksum;
				}
			}

			public ReadOnlyMemory<byte> StorageCrc64
			{
				get
				{
					if (Algorithm != StorageChecksumAlgorithm.StorageCrc64)
					{
						return default(ReadOnlyMemory<byte>);
					}
					return Checksum;
				}
			}

			public byte[] MD5AsArray
			{
				get
				{
					if (!MD5.IsEmpty)
					{
						return MD5.ToArray();
					}
					return null;
				}
			}

			public byte[] StorageCrc64AsArray
			{
				get
				{
					if (!StorageCrc64.IsEmpty)
					{
						return StorageCrc64.ToArray();
					}
					return null;
				}
			}

			private GetHashResult(StorageChecksumAlgorithm algorithm, ReadOnlyMemory<byte> checksum)
			{
				Algorithm = algorithm;
				Checksum = checksum;
			}

			public static GetHashResult FromStorageCrc64(ReadOnlyMemory<byte> checksum)
			{
				return new GetHashResult(StorageChecksumAlgorithm.StorageCrc64, checksum);
			}

			public static GetHashResult FromMD5(ReadOnlyMemory<byte> checksum)
			{
				return new GetHashResult(StorageChecksumAlgorithm.MD5, checksum);
			}
		}

		public delegate int GetFinalStreamHash(Span<byte> destination);

		internal static int GetHashSizeInBytes(StorageChecksumAlgorithm algorithm)
		{
			return algorithm.ResolveAuto() switch
			{
				StorageChecksumAlgorithm.None => 0, 
				StorageChecksumAlgorithm.MD5 => 16, 
				StorageChecksumAlgorithm.StorageCrc64 => 8, 
				_ => throw Azure.Storage.Errors.InvalidArgument("algorithm"), 
			};
		}

		internal static UploadTransferValidationOptions ToUploadTransferValidationOptions(this GetHashResult hashResult)
		{
			if (hashResult == null)
			{
				return new UploadTransferValidationOptions
				{
					ChecksumAlgorithm = StorageChecksumAlgorithm.None
				};
			}
			return new UploadTransferValidationOptions
			{
				ChecksumAlgorithm = hashResult.Algorithm,
				PrecalculatedChecksum = hashResult.Checksum
			};
		}

		public static async Task AssertResponseHashMatchInternal(Stream content, StorageChecksumAlgorithm algorithm, Response response, bool async, CancellationToken cancellationToken)
		{
			AssertResponseHashMatch(await GetHashInternal(content, algorithm, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), algorithm, response);
		}

		public static void AssertResponseHashMatch(byte[] content, int offset, int count, StorageChecksumAlgorithm algorithm, Response response)
		{
			AssertResponseHashMatch(GetHash(BinaryData.FromBytes(new ReadOnlyMemory<byte>(content, offset, count)), algorithm), algorithm, response);
		}

		private static void AssertResponseHashMatch(GetHashResult computedHash, StorageChecksumAlgorithm algorithm, Response response)
		{
			if (computedHash == null)
			{
				throw Azure.Storage.Errors.ArgumentNull("computedHash");
			}
			if (response == null)
			{
				throw Azure.Storage.Errors.ArgumentNull("response");
			}
			ReadOnlyMemory<byte> readOnlyMemory;
			switch (algorithm.ResolveAuto())
			{
			case StorageChecksumAlgorithm.MD5:
			{
				readOnlyMemory = computedHash.MD5;
				if (!readOnlyMemory.Span.SequenceEqual(response.Headers.TryGetValue("Content-MD5", out byte[] value2) ? value2 : null))
				{
					throw Azure.Storage.Errors.HashMismatch("Content-MD5");
				}
				break;
			}
			case StorageChecksumAlgorithm.StorageCrc64:
			{
				readOnlyMemory = computedHash.StorageCrc64;
				if (!readOnlyMemory.Span.SequenceEqual(response.Headers.TryGetValue("x-ms-content-crc64", out byte[] value) ? value : null))
				{
					throw Azure.Storage.Errors.HashMismatch("x-ms-content-crc64");
				}
				break;
			}
			default:
				throw Azure.Storage.Errors.InvalidArgument("algorithm");
			}
		}

		public static async Task<GetHashResult> GetHashOrDefaultInternal(Stream content, UploadTransferValidationOptions options, bool async, CancellationToken cancellationToken)
		{
			if (GetHashOrDefaultTryFromOptions(options, out var result))
			{
				return result;
			}
			return await GetHashInternal(content, options.ChecksumAlgorithm, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public static GetHashResult GetHashOrDefault(BinaryData content, UploadTransferValidationOptions options)
		{
			if (GetHashOrDefaultTryFromOptions(options, out var result))
			{
				return result;
			}
			return GetHash(content, options.ChecksumAlgorithm);
		}

		private static bool GetHashOrDefaultTryFromOptions(UploadTransferValidationOptions options, out GetHashResult result)
		{
			if (options == null || options.ChecksumAlgorithm == StorageChecksumAlgorithm.None)
			{
				result = null;
				return true;
			}
			if (!options.PrecalculatedChecksum.IsEmpty)
			{
				result = options.ChecksumAlgorithm.ResolveAuto() switch
				{
					StorageChecksumAlgorithm.StorageCrc64 => GetHashResult.FromStorageCrc64(options.PrecalculatedChecksum), 
					StorageChecksumAlgorithm.MD5 => GetHashResult.FromMD5(options.PrecalculatedChecksum), 
					_ => throw Azure.Storage.Errors.InvalidArgument("ChecksumAlgorithm"), 
				};
				return true;
			}
			result = null;
			return false;
		}

		public static async Task<GetHashResult> GetHashInternal(Stream content, StorageChecksumAlgorithm algorithmIdentifier, bool async, CancellationToken cancellationToken)
		{
			return algorithmIdentifier.ResolveAuto() switch
			{
				StorageChecksumAlgorithm.StorageCrc64 => GetHashResult.FromStorageCrc64(await ComputeHashInternal(content, new NonCryptographicHashAlgorithmHasher(StorageCrc64HashAlgorithm.Create()), async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)), 
				StorageChecksumAlgorithm.MD5 => GetHashResult.FromMD5(await ComputeHashInternal(content, new HashAlgorithmHasher(MD5.Create()), async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)), 
				_ => throw Azure.Storage.Errors.InvalidArgument("algorithmIdentifier"), 
			};
		}

		public static GetHashResult GetHash(BinaryData content, StorageChecksumAlgorithm algorithmIdentifier)
		{
			return algorithmIdentifier.ResolveAuto() switch
			{
				StorageChecksumAlgorithm.StorageCrc64 => GetHashResult.FromStorageCrc64(computeCrc(StorageCrc64HashAlgorithm.Create())), 
				StorageChecksumAlgorithm.MD5 => GetHashResult.FromMD5(MD5.Create().ComputeHash(content.ToArray())), 
				_ => throw Azure.Storage.Errors.InvalidArgument("algorithmIdentifier"), 
			};
			byte[] computeCrc(StorageCrc64HashAlgorithm nonCryptographicHashAlgorithm)
			{
				nonCryptographicHashAlgorithm.Append(content.ToMemory().Span);
				return nonCryptographicHashAlgorithm.GetCurrentHash();
			}
		}

		public static (Stream Stream, GetFinalStreamHash GetCurrentStreamHash, int HashSize, IDisposable Disposable) SetupChecksumCalculatingReadStream(Stream stream, StorageChecksumAlgorithm algorithmIdentifier)
		{
			IHasher hasher = GetHasher(algorithmIdentifier);
			return (Stream: ChecksumCalculatingStream.GetReadStream(stream, hasher.AppendHash), GetCurrentStreamHash: hasher.GetFinalHash, HashSize: hasher.HashSizeInBytes, Disposable: hasher);
		}

		private static IHasher GetHasher(StorageChecksumAlgorithm algorithmIdentifier)
		{
			return algorithmIdentifier.ResolveAuto() switch
			{
				StorageChecksumAlgorithm.StorageCrc64 => new NonCryptographicHashAlgorithmHasher(StorageCrc64HashAlgorithm.Create()), 
				StorageChecksumAlgorithm.MD5 => new HashAlgorithmHasher(MD5.Create()), 
				_ => throw Azure.Storage.Errors.InvalidArgument("algorithmIdentifier"), 
			};
		}

		private static async Task<byte[]> ComputeHashInternal(Stream content, IHasher hasher, bool async, CancellationToken cancellationToken)
		{
			long startPosition = content.Position;
			byte[] result = await hasher.ComputeHashInternal(content, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			content.Position = startPosition;
			return result;
		}

		public static IHasher GetHasherFromAlgorithmId(StorageChecksumAlgorithm algorithm)
		{
			return algorithm.ResolveAuto() switch
			{
				StorageChecksumAlgorithm.None => null, 
				StorageChecksumAlgorithm.MD5 => new HashAlgorithmHasher(MD5.Create()), 
				StorageChecksumAlgorithm.StorageCrc64 => new NonCryptographicHashAlgorithmHasher(StorageCrc64HashAlgorithm.Create()), 
				_ => throw Azure.Storage.Errors.InvalidArgument("algorithm"), 
			};
		}

		public static (ReadOnlyMemory<byte> Checksum, StorageChecksumAlgorithm Algorithm) GetResponseChecksumOrDefault(Response response)
		{
			if (response.Headers.TryGetValue("x-ms-content-crc64", out byte[] value))
			{
				return (Checksum: value, Algorithm: StorageChecksumAlgorithm.StorageCrc64);
			}
			if (response.Headers.TryGetValue("Content-MD5", out byte[] value2))
			{
				return (Checksum: value2, Algorithm: StorageChecksumAlgorithm.MD5);
			}
			return (Checksum: ReadOnlyMemory<byte>.Empty, Algorithm: StorageChecksumAlgorithm.None);
		}
	}
	internal class DisposableBucket : IDisposable
	{
		private List<IDisposable> Disposables { get; } = new List<IDisposable>();

		public void Add(IDisposable disposable)
		{
			Disposables.Add(disposable);
		}

		public void Dispose()
		{
			foreach (IDisposable disposable in Disposables)
			{
				disposable.Dispose();
			}
		}
	}
	internal class Errors
	{
		public static class ClientSideEncryption
		{
			public static ArgumentException UnrecognizedVersion()
			{
				return new ArgumentException("Unrecognized ClientSideEncryptionVersion");
			}

			public static InvalidOperationException ClientSideEncryptionVersionNotSupported(string versionString = null)
			{
				return new InvalidOperationException(("This library does not support the given version of client-side encryption." + versionString == null) ? "" : (" Version ID = " + versionString));
			}

			public static InvalidOperationException TypeNotSupported(Type type)
			{
				return new InvalidOperationException("Client-side encryption is not supported for type \"" + type.FullName + "\". Please use a supported client type or create this client without specifying client-side encryption options.");
			}

			public static InvalidOperationException MissingRequiredEncryptionResources(params string[] resourceNames)
			{
				return new InvalidOperationException("Cannot encrypt without specifying " + string.Join(",", resourceNames.AsEnumerable()));
			}

			public static ArgumentException KeyNotFound(string keyId)
			{
				return new ArgumentException("Resolution of id " + keyId + " returned null.");
			}

			public static ArgumentException BadEncryptionAgent(string agent)
			{
				return new ArgumentException("Invalid Encryption Agent. This version of the client library does not understandthe Encryption Agent protocol \"" + agent + "\" set on the blob.");
			}

			public static ArgumentException BadEncryptionAlgorithm(string algorithm)
			{
				return new ArgumentException("Invalid Encryption Algorithm \"" + algorithm + "\" found on the resource. This version of the clientlibrary does not support the given encryption algorithm.");
			}

			public static InvalidOperationException MissingEncryptionMetadata(string field)
			{
				return new InvalidOperationException("Missing field \"" + field + "\" in encryption metadata");
			}
		}

		public static ArgumentException AccountMismatch(string accountNameCredential, string accountNameValue)
		{
			return new ArgumentException(string.Format(CultureInfo.CurrentCulture, "Account Name Mismatch: {0} != {1}", accountNameCredential, accountNameValue));
		}

		public static InvalidOperationException AccountSasMissingData()
		{
			return new InvalidOperationException("Account SAS is missing at least one of these: ExpiryTime, Permissions, Service, or ResourceType");
		}

		public static ArgumentNullException ArgumentNull(string paramName)
		{
			return new ArgumentNullException(paramName);
		}

		public static ArgumentException InvalidArgument(string paramName)
		{
			return new ArgumentException(paramName + " is invalid");
		}

		public static ArgumentException InvalidResourceType(char s)
		{
			return new ArgumentException($"Invalid resource type: '{s}'");
		}

		public static InvalidOperationException TaskIncomplete()
		{
			return new InvalidOperationException("Task is not completed");
		}

		public static FormatException InvalidFormat(string err)
		{
			return new FormatException(err);
		}

		public static ArgumentException ParsingConnectionStringFailed()
		{
			return new ArgumentException("Connection string parsing error");
		}

		public static ArgumentOutOfRangeException InvalidSasProtocol(string protocol, string sasProtocol)
		{
			return new ArgumentOutOfRangeException(protocol, "Invalid " + sasProtocol + " value");
		}

		public static ArgumentException InvalidService(char s)
		{
			return new ArgumentException($"Invalid service: '{s}'");
		}

		public static ArgumentException InsufficientStorageTransferOptions(long streamLength, long statedMaxBlockSize, long necessaryMinBlockSize)
		{
			return new ArgumentException($"Cannot upload {streamLength} bytes with a maximum transfer size of {statedMaxBlockSize} bytes per block. Please increase the StorageTransferOptions.MaximumTransferSize to at least {necessaryMinBlockSize}.");
		}

		public static InvalidDataException HashMismatch(string hashHeaderName)
		{
			return new InvalidDataException(hashHeaderName + " did not match hash of recieved data.");
		}

		public static InvalidDataException ChecksumMismatch(ReadOnlySpan<byte> left, ReadOnlySpan<byte> right)
		{
			return new InvalidDataException("Compared checksums did not match. Invalid data may have been written to the destination. Left: " + Convert.ToBase64String(left.ToArray()) + " Right: " + Convert.ToBase64String(right.ToArray()));
		}

		public static InvalidDataException HashMismatchOnStreamedDownload(string mismatchedRange)
		{
			return new InvalidDataException("Detected invalid data while streaming to the destination. Range " + mismatchedRange + " produced mismatched checksum.");
		}

		public static ArgumentException PrecalculatedHashNotSupportedOnSplit()
		{
			return new ArgumentException("Precalculated checksum not supported when potentially partitioning an upload.");
		}

		public static ArgumentException CannotDeferTransactionalHashVerification()
		{
			return new ArgumentException("Cannot defer transactional hash verification. Returned hash is unavailable to caller.");
		}

		public static ArgumentException CannotInitializeWriteStreamWithData()
		{
			return new ArgumentException("Initialized buffer for StorageWriteStream must be empty.");
		}

		internal static void VerifyStreamPosition(Stream stream, string streamName)
		{
			if (stream != null && stream.CanSeek && stream.Length > 0 && stream.Position >= stream.Length)
			{
				throw new ArgumentException(streamName + ".Position must be less than " + streamName + ".Length. Please set " + streamName + ".Position to the start of the data to upload.");
			}
		}

		public static void ThrowIfParamNull(object obj, string paramName)
		{
			if (obj == null)
			{
				throw new ArgumentNullException("Param: \"" + paramName + "\" is null");
			}
		}

		internal static void CheckCryptKeySize(int keySizeInBytes)
		{
			if (keySizeInBytes != 16 && keySizeInBytes != 24 && keySizeInBytes != 32)
			{
				throw new CryptographicException("Specified key is not a valid size for this algorithm.");
			}
		}

		public static CryptographicException CryptographyAuthTagMismatch()
		{
			throw new CryptographicException("The computed authentication tag did not match the input authentication tag.");
		}

		public static ArgumentException CryptographyPlaintextCiphertextLengthMismatch()
		{
			throw new ArgumentException("Plaintext and ciphertext must have the same length.");
		}

		public static ArgumentException CryptographyInvalidNonceLength()
		{
			throw new ArgumentException("The specified nonce is not a valid size for this algorithm.");
		}

		public static ArgumentException CryptographyInvalidTagLength()
		{
			throw new ArgumentException("The specified tag is not a valid size for this algorithm.");
		}

		public static ArgumentException CannotBothBeNotNull(string param0, string param1)
		{
			return new ArgumentException(param0 + " and " + param1 + " cannot both be set");
		}

		public static ArgumentOutOfRangeException MustBeGreaterThanOrEqualTo(string paramName, long value)
		{
			return new ArgumentOutOfRangeException(paramName, $"Value must be greater than or equal to {value}");
		}

		public static ArgumentOutOfRangeException MustBeLessThanOrEqualTo(string paramName, long value)
		{
			return new ArgumentOutOfRangeException(paramName, $"Value must be less than or equal to {value}");
		}

		public static ArgumentOutOfRangeException MustBeBetweenInclusive(string paramName, long lower, long upper, long actual)
		{
			return new ArgumentOutOfRangeException(paramName, $"Value must be between {lower} and {upper} inclusive, not {actual}");
		}

		public static ArgumentOutOfRangeException MustBeGreaterThanValueOrEqualToOtherValue(string paramName, long value0, long value1)
		{
			return new ArgumentOutOfRangeException(paramName, $"Value must be greater than {value0} or equal to {value1}");
		}

		public static ArgumentException StreamMustBeReadable(string paramName)
		{
			return new ArgumentException("Stream must be readable", paramName);
		}

		public static InvalidOperationException StreamMustBeAtPosition0()
		{
			return new InvalidOperationException("Stream must be set to position 0");
		}

		public static InvalidOperationException TokenCredentialsRequireHttps()
		{
			return new InvalidOperationException("Use of token credentials requires HTTPS");
		}

		public static ArgumentException SasCredentialRequiresUriWithoutSas<TUriBuilder>(Uri uri)
		{
			return new ArgumentException(string.Format("You cannot use {0} when the resource URI also contains a Shared Access Signature: {1}\n", "AzureSasCredential", uri) + "You can remove the shared access signature by creating a " + typeof(TUriBuilder).Name + ", setting " + typeof(TUriBuilder).Name + ".Sas to null, and calling " + typeof(TUriBuilder).Name + ".ToUri.");
		}

		public static InvalidOperationException SasMissingData(string paramName)
		{
			return new InvalidOperationException("SAS is missing required parameter: " + paramName);
		}

		public static InvalidOperationException SasDataNotAllowed(string paramName, string paramNameNotAllowed)
		{
			return new InvalidOperationException("SAS cannot have the " + paramNameNotAllowed + " parameter when the " + paramName + " parameter is present");
		}

		public static InvalidOperationException SasDataInConjunction(string paramName, string paramName2)
		{
			return new InvalidOperationException("SAS cannot have the following parameters specified in conjunction: " + paramName + ", " + paramName2);
		}

		public static InvalidOperationException SasNamesNotMatching(string builderParam, string builderName, string clientParam)
		{
			return new InvalidOperationException("SAS Uri cannot be generated. " + builderName + "." + builderParam + " does not match " + clientParam + " in the Client. " + builderName + "." + builderParam + " must either be left empty or match the " + clientParam + " in the Client");
		}

		public static InvalidOperationException SasNamesNotMatching(string builderParam, string builderName)
		{
			return new InvalidOperationException("SAS Uri cannot be generated. " + builderName + "." + builderParam + " does not match snapshot value in the URI in the Client. " + builderName + "." + builderParam + " must either be left empty or match the snapshot value in the URI in the Client");
		}

		public static InvalidOperationException SasServiceNotMatching(string builderParam, string builderName, string expectedService)
		{
			return new InvalidOperationException("SAS Uri cannot be generated. " + builderName + "." + builderParam + " does specify " + expectedService + ". " + builderName + "." + builderParam + " must either specify " + expectedService + " or specify all Services are accessible in the value.");
		}

		public static InvalidOperationException SasClientMissingData(string paramName)
		{
			return new InvalidOperationException("SAS Uri cannot be generated. " + paramName + " in the client has not been set");
		}

		public static InvalidOperationException SasBuilderEmptyParam(string builderName, string paramName, string sasType)
		{
			return new InvalidOperationException("SAS Uri cannot be generated. " + builderName + "." + paramName + " cannot be set to create a " + sasType + " SAS.");
		}

		public static InvalidOperationException SasIncorrectResourceType(string builderName, string builderParam, string value, string clientName)
		{
			return new InvalidOperationException("SAS Uri cannot be generated. Expected " + builderName + "." + builderParam + " to be set to " + value + " to generatethe respective SAS for the client, " + clientName);
		}

		public static ArgumentException InvalidPermission(char s)
		{
			return new ArgumentException($"Invalid permission: '{s}'");
		}

		public static ArgumentException ParsingHttpRangeFailed()
		{
			return new ArgumentException("Could not parse the serialized range.");
		}

		public static AccessViolationException UnableAccessArray()
		{
			return new AccessViolationException("Unable to get array from memory pool");
		}

		public static NotImplementedException NotImplemented()
		{
			return new NotImplementedException();
		}

		public static AuthenticationException InvalidCredentials(string fullName)
		{
			return new AuthenticationException("Cannot authenticate credentials with " + fullName);
		}

		public static ArgumentException SeekOutsideBufferRange(long index, long inclusiveRangeStart, long exclusiveRangeEnd)
		{
			return new ArgumentException($"Tried to seek ouside buffer range. Gave index {index}, range is [{inclusiveRangeStart},{exclusiveRangeEnd}).");
		}

		public static ArgumentException VersionNotSupported(string paramName)
		{
			return new ArgumentException("The version specified by " + paramName + " is not supported by this library.");
		}

		public static RequestFailedException ClientRequestIdMismatch(Response response, string echo, string original)
		{
			return new RequestFailedException(response.Status, "Response x-ms-client-request-id '" + echo + "' does not match the original expected request id, '" + original + "'.", null);
		}

		public static ArgumentException TransactionalHashingNotSupportedWithClientSideEncryption()
		{
			return new ArgumentException("Client-side encryption and transactional hashing are not supported at the same time.");
		}

		public static void VerifyHttpsTokenAuth(Uri uri)
		{
			if (uri.Scheme != "https")
			{
				throw new ArgumentException("Cannot use TokenCredential without HTTPS.");
			}
		}
	}
	internal class GeoRedundantReadPolicy : HttpPipelineSynchronousPolicy
	{
		private readonly string _secondaryStorageHost;

		public GeoRedundantReadPolicy(Uri secondaryStorageUri)
		{
			if (secondaryStorageUri == null)
			{
				throw Azure.Storage.Errors.ArgumentNull("secondaryStorageUri");
			}
			_secondaryStorageHost = secondaryStorageUri.Host;
		}

		public override void OnSendingRequest(HttpMessage message)
		{
			if (message.Request.Method != RequestMethod.Get && message.Request.Method != RequestMethod.Head)
			{
				return;
			}
			object value;
			string text = (message.TryGetProperty("AlternateHostKey", out value) ? (value as string) : null);
			object value2;
			if (text == null)
			{
				message.SetProperty("AlternateHostKey", _secondaryStorageHost);
			}
			else if (!message.TryGetProperty("ResourceNotReplicated", out value2) || !(bool)value2)
			{
				string host = message.Request.Uri.Host;
				if (message.HasResponse && message.Response.Status == 404 && host == _secondaryStorageHost)
				{
					message.SetProperty("ResourceNotReplicated", true);
				}
				message.Request.Uri.Host = text;
				message.SetProperty("AlternateHostKey", host);
			}
		}
	}
	internal class HashAlgorithmHasher : IHasher, IDisposable
	{
		private readonly HashAlgorithm _hashAlgorithm;

		public int HashSizeInBytes => BitsToBytes(_hashAlgorithm.HashSize);

		public HashAlgorithmHasher(HashAlgorithm hashAlgorithm)
		{
			_hashAlgorithm = hashAlgorithm;
		}

		public async Task<byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken)
		{
			Azure.Core.Argument.AssertNotNull(stream, "stream");
			await ChecksumCalculatingStream.GetReadStream(stream, AppendHash).CopyToInternal(Stream.Null, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			byte[] array = new byte[HashSizeInBytes];
			GetFinalHash(array);
			return array;
		}

		public void AppendHash(ReadOnlySpan<byte> content)
		{
			_hashAlgorithm.TransformBlock(content.ToArray(), 0, content.Length, null, 0);
		}

		public int GetFinalHash(Span<byte> hashDestination)
		{
			_hashAlgorithm.TransformFinalBlock(new byte[0], 0, 0);
			_hashAlgorithm.Hash.CopyTo(hashDestination);
			return _hashAlgorithm.Hash.Length;
		}

		public void Dispose()
		{
			_hashAlgorithm.Dispose();
		}

		private static int BitsToBytes(int bits)
		{
			return bits >> 3;
		}
	}
	internal interface IHasher : IDisposable
	{
		int HashSizeInBytes { get; }

		Task<byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken);

		void AppendHash(ReadOnlySpan<byte> content);

		int GetFinalHash(Span<byte> hashDestination);
	}
	internal static class IHasherExtensions
	{
		public static Memory<byte> GetFinalHash(this IHasher hasher)
		{
			Memory<byte> result = new Memory<byte>(new byte[hasher.HashSizeInBytes]);
			hasher.GetFinalHash(result.Span);
			return result;
		}
	}
	internal static class LoggingExtensions
	{
		public static IDisposable BeginLoggingScope(this HttpPipeline pipeline, string className, [CallerMemberName] string member = null)
		{
			return null;
		}

		[Conditional("EnableLoggingHelpers")]
		public static void LogMethodEnter(this HttpPipeline pipeline, string className, [CallerMemberName] string member = null, string message = null)
		{
		}

		[Conditional("EnableLoggingHelpers")]
		public static void LogMethodExit(this HttpPipeline pipeline, string className, [CallerMemberName] string member = null, string message = "")
		{
		}

		[Conditional("EnableLoggingHelpers")]
		public static void LogException(this HttpPipeline pipeline, Exception ex, string message = null)
		{
		}

		[Conditional("EnableLoggingHelpers")]
		public static void LogTrace(this HttpPipeline pipeline, string message = null)
		{
		}
	}
	internal class NonCryptographicHashAlgorithmHasher : IHasher, IDisposable
	{
		private const int _streamBufferSize = 4194304;

		private readonly NonCryptographicHashAlgorithm _nonCryptographicHashAlgorithm;

		public int HashSizeInBytes => _nonCryptographicHashAlgorithm.HashLengthInBytes;

		public NonCryptographicHashAlgorithmHasher(NonCryptographicHashAlgorithm nonCryptographicHashAlgorithm)
		{
			_nonCryptographicHashAlgorithm = nonCryptographicHashAlgorithm;
		}

		public async Task<byte[]> ComputeHashInternal(Stream stream, bool async, CancellationToken cancellationToken)
		{
			if (stream == null)
			{
				throw new ArgumentNullException("stream");
			}
			if (async)
			{
				await _nonCryptographicHashAlgorithm.AppendAsync(stream, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			else
			{
				_nonCryptographicHashAlgorithm.Append(stream);
			}
			return _nonCryptographicHashAlgorithm.GetCurrentHash();
		}

		public void AppendHash(ReadOnlySpan<byte> content)
		{
			_nonCryptographicHashAlgorithm.Append(content);
		}

		public int GetFinalHash(Span<byte> hashDestination)
		{
			return _nonCryptographicHashAlgorithm.GetCurrentHash(hashDestination);
		}

		public void Dispose()
		{
		}
	}
	internal class NonDisposingStream : Stream
	{
		private readonly Stream _innerStream;

		public override bool CanRead => _innerStream.CanRead;

		public override bool CanSeek => _innerStream.CanSeek;

		public override bool CanWrite => _innerStream.CanWrite;

		public override bool CanTimeout => _innerStream.CanTimeout;

		public override long Length => _innerStream.Length;

		public override long Position
		{
			get
			{
				return _innerStream.Position;
			}
			set
			{
				_innerStream.Position = value;
			}
		}

		public override int ReadTimeout
		{
			get
			{
				return _innerStream.ReadTimeout;
			}
			set
			{
				_innerStream.ReadTimeout = value;
			}
		}

		public override int WriteTimeout
		{
			get
			{
				return _innerStream.WriteTimeout;
			}
			set
			{
				_innerStream.WriteTimeout = value;
			}
		}

		public NonDisposingStream(Stream innerStream)
		{
			_innerStream = innerStream;
		}

		public override Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken)
		{
			return _innerStream.CopyToAsync(destination, bufferSize, cancellationToken);
		}

		public override void Flush()
		{
			_innerStream.Flush();
		}

		public override Task FlushAsync(CancellationToken cancellationToken)
		{
			return _innerStream.FlushAsync(cancellationToken);
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			return _innerStream.Read(buffer, offset, count);
		}

		public override Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
		{
			return _innerStream.ReadAsync(buffer, offset, count, cancellationToken);
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			return _innerStream.Seek(offset, origin);
		}

		public override void SetLength(long value)
		{
			_innerStream.SetLength(value);
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			_innerStream.Write(buffer, offset, count);
		}

		public override Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
		{
			return _innerStream.WriteAsync(buffer, offset, count, cancellationToken);
		}

		public override int ReadByte()
		{
			return _innerStream.ReadByte();
		}

		public override void WriteByte(byte value)
		{
			_innerStream.WriteByte(value);
		}

		public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			return _innerStream.BeginRead(buffer, offset, count, callback, state);
		}

		public override int EndRead(IAsyncResult asyncResult)
		{
			return _innerStream.EndRead(asyncResult);
		}

		public override IAsyncResult BeginWrite(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			return _innerStream.BeginWrite(buffer, offset, count, callback, state);
		}

		public override void EndWrite(IAsyncResult asyncResult)
		{
			_innerStream.EndWrite(asyncResult);
		}
	}
	internal static class StreamExtensions
	{
		public static Stream WithNoDispose(this Stream stream)
		{
			if (!(stream is NonDisposingStream))
			{
				return new NonDisposingStream(stream);
			}
			return stream;
		}

		public static long? GetLengthOrDefault(this Stream content)
		{
			try
			{
				if (content.CanSeek)
				{
					return content.Length - content.Position;
				}
			}
			catch (NotSupportedException)
			{
			}
			return null;
		}

		public static async Task<int> ReadInternal(this Stream stream, byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
		{
			if (async)
			{
				return await stream.ReadAsync(buffer, offset, count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			return stream.Read(buffer, offset, count);
		}

		public static async Task WriteInternal(this Stream stream, byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
		{
			if (async)
			{
				await stream.WriteAsync(buffer, offset, count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			else
			{
				stream.Write(buffer, offset, count);
			}
		}

		public static Task CopyToInternal(this Stream src, Stream dest, bool async, CancellationToken cancellationToken)
		{
			return src.CopyToInternal(dest, 81920, async, cancellationToken);
		}

		public static async Task CopyToInternal(this Stream src, Stream dest, int bufferSize, bool async, CancellationToken cancellationToken)
		{
			if (async)
			{
				await src.CopyToAsync(dest, bufferSize, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			else
			{
				src.CopyTo(dest, bufferSize);
			}
		}
	}
	internal class PartitionedUploader<TServiceSpecificData, TCompleteUploadReturn>
	{
		private readonly struct ContentPartition<TContent>
		{
			public long AbsolutePosition { get; }

			public long Length { get; }

			public TContent Content { get; }

			public ReadOnlyMemory<byte> ContentChecksum { get; }

			public ContentPartition(long position, long length, TContent content, ReadOnlyMemory<byte> contentChecksum)
			{
				AbsolutePosition = position;
				Length = length;
				Content = content;
				ContentChecksum = contentChecksum;
			}
		}

		private delegate IAsyncEnumerable<ContentPartition<TContent>> GetContentPartitionsAsync<TContent>(TContent content, long? contentLength, long blockSize, bool async, CancellationToken cancellationToken);

		private delegate Task StageContentPartitionAsync<TContent>(TContent content, long offset, TServiceSpecificData args, UploadTransferValidationOptions validationOptions, IProgress<long> progressHandler, bool async, CancellationToken cancellationToken);

		private delegate Task<(Stream PartitionContent, ReadOnlyMemory<byte> PartitionChecksum)> GetNextStreamPartition(Stream stream, long minCount, long maxCount, long absolutePosition, bool async, CancellationToken cancellationToken);

		public delegate Azure.Core.Pipeline.DiagnosticScope CreateScope(string operationName);

		public delegate Task InitializeDestinationInternal(TServiceSpecificData args, bool async, CancellationToken cancellationToken);

		public delegate Task<Response<TCompleteUploadReturn>> SingleUploadStreamingInternal(Stream contentStream, TServiceSpecificData args, IProgress<long> progressHandler, UploadTransferValidationOptions transferValidation, string operationName, bool async, CancellationToken cancellationToken);

		public delegate Task<Response<TCompleteUploadReturn>> SingleUploadBinaryDataInternal(BinaryData content, TServiceSpecificData args, IProgress<long> progressHandler, UploadTransferValidationOptions transferValidation, string operationName, bool async, CancellationToken cancellationToken);

		public delegate Task UploadPartitionStreamingInternal(Stream contentStream, long offset, TServiceSpecificData args, IProgress<long> progressHandler, UploadTransferValidationOptions transferValidation, bool async, CancellationToken cancellationToken);

		public delegate Task UploadPartitionBinaryDataInternal(BinaryData content, long offset, TServiceSpecificData args, IProgress<long> progressHandler, UploadTransferValidationOptions transferValidation, bool async, CancellationToken cancellationToken);

		public delegate Task<Response<TCompleteUploadReturn>> CommitPartitionedUploadInternal(List<(long Offset, long Size)> partitions, TServiceSpecificData args, bool async, CancellationToken cancellationToken);

		public struct Behaviors
		{
			public InitializeDestinationInternal InitializeDestination { get; set; }

			public SingleUploadStreamingInternal SingleUploadStreaming { get; set; }

			public SingleUploadBinaryDataInternal SingleUploadBinaryData { get; set; }

			public UploadPartitionStreamingInternal UploadPartitionStreaming { get; set; }

			public UploadPartitionBinaryDataInternal UploadPartitionBinaryData { get; set; }

			public CommitPartitionedUploadInternal CommitPartitionedUpload { get; set; }

			public CreateScope Scope { get; set; }
		}

		public static readonly InitializeDestinationInternal InitializeNoOp = (TServiceSpecificData args, bool async, CancellationToken cancellationToken) => Task.CompletedTask;

		private readonly InitializeDestinationInternal _initializeDestinationInternal;

		private readonly SingleUploadStreamingInternal _singleUploadStreamingInternal;

		private readonly SingleUploadBinaryDataInternal _singleUploadBinaryDataInternal;

		private readonly UploadPartitionStreamingInternal _uploadPartitionStreamingInternal;

		private readonly UploadPartitionBinaryDataInternal _uploadPartitionBinaryDataInternal;

		private readonly CommitPartitionedUploadInternal _commitPartitionedUploadInternal;

		private readonly CreateScope _createScope;

		private readonly int _maxWorkerCount;

		private readonly ArrayPool<byte> _arrayPool;

		private readonly long _singleUploadThreshold;

		private readonly long? _blockSize;

		private readonly StorageChecksumAlgorithm _validationAlgorithm;

		private Func<Memory<byte>> _masterCrcSupplier;

		private readonly string _operationName;

		private bool UseMasterCrc => _validationAlgorithm.ResolveAuto() == StorageChecksumAlgorithm.StorageCrc64;

		private UploadTransferValidationOptions ValidationOptions => new UploadTransferValidationOptions
		{
			ChecksumAlgorithm = _validationAlgorithm
		};

		public PartitionedUploader(Behaviors behaviors, StorageTransferOptions transferOptions, UploadTransferValidationOptions transferValidation, ArrayPool<byte> arrayPool = null, string operationName = null)
		{
			_initializeDestinationInternal = behaviors.InitializeDestination ?? InitializeNoOp;
			_singleUploadStreamingInternal = Azure.Core.Argument.CheckNotNull(behaviors.SingleUploadStreaming, "SingleUploadStreaming");
			_singleUploadBinaryDataInternal = Azure.Core.Argument.CheckNotNull(behaviors.SingleUploadBinaryData, "SingleUploadBinaryData");
			_uploadPartitionStreamingInternal = Azure.Core.Argument.CheckNotNull(behaviors.UploadPartitionStreaming, "UploadPartitionStreaming");
			_uploadPartitionBinaryDataInternal = Azure.Core.Argument.CheckNotNull(behaviors.UploadPartitionBinaryData, "UploadPartitionBinaryData");
			_commitPartitionedUploadInternal = Azure.Core.Argument.CheckNotNull(behaviors.CommitPartitionedUpload, "CommitPartitionedUpload");
			_createScope = Azure.Core.Argument.CheckNotNull(behaviors.Scope, "Scope");
			_arrayPool = arrayPool ?? ArrayPool<byte>.Shared;
			if (transferOptions.MaximumConcurrency.HasValue && transferOptions.MaximumConcurrency > 0)
			{
				_maxWorkerCount = transferOptions.MaximumConcurrency.Value;
			}
			else
			{
				_maxWorkerCount = 5;
			}
			if (transferOptions.InitialTransferSize.HasValue && transferOptions.InitialTransferSize.Value > 0)
			{
				_singleUploadThreshold = Math.Min(transferOptions.InitialTransferSize.Value, 5242880000L);
			}
			else
			{
				_singleUploadThreshold = 268435456L;
			}
			if (transferOptions.MaximumTransferSize.HasValue && transferOptions.MaximumTransferSize > 0)
			{
				_blockSize = Math.Min(4194304000L, transferOptions.MaximumTransferSize.Value);
			}
			_validationAlgorithm = Azure.Core.Argument.CheckNotNull(transferValidation, "transferValidation").ChecksumAlgorithm.ResolveAuto();
			if (!transferValidation.PrecalculatedChecksum.IsEmpty)
			{
				if (!UseMasterCrc)
				{
					throw Azure.Storage.Errors.PrecalculatedHashNotSupportedOnSplit();
				}
				Memory<byte> userSuppliedMasterCrc = new Memory<byte>(new byte[transferValidation.PrecalculatedChecksum.Length]);
				transferValidation.PrecalculatedChecksum.CopyTo(userSuppliedMasterCrc);
				_masterCrcSupplier = () => userSuppliedMasterCrc;
			}
			_operationName = operationName;
		}

		public async Task<Response<TCompleteUploadReturn>> UploadInternal(BinaryData content, TServiceSpecificData args, IProgress<long> progressHandler, bool async, CancellationToken cancellationToken = default(CancellationToken))
		{
			Azure.Core.Argument.AssertNotNull(content, "content");
			await _initializeDestinationInternal(args, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			long num = content.ToMemory().Length;
			if (num < _singleUploadThreshold)
			{
				UploadTransferValidationOptions transferValidation = ((!UseMasterCrc || _masterCrcSupplier == null) ? ContentHasher.GetHashOrDefault(content, ValidationOptions).ToUploadTransferValidationOptions() : new UploadTransferValidationOptions
				{
					ChecksumAlgorithm = StorageChecksumAlgorithm.StorageCrc64,
					PrecalculatedChecksum = _masterCrcSupplier()
				});
				return await _singleUploadBinaryDataInternal(content, args, progressHandler, transferValidation, _operationName, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			if (UseMasterCrc && _masterCrcSupplier == null)
			{
				NonCryptographicHashAlgorithmHasher masterCrc = new NonCryptographicHashAlgorithmHasher(StorageCrc64HashAlgorithm.Create());
				masterCrc.AppendHash(content);
				_masterCrcSupplier = () => masterCrc.GetFinalHash();
			}
			long num2 = (_blockSize.HasValue ? _blockSize.Value : ((num < 104857600) ? 4194304 : 8388608));
			if (async && _maxWorkerCount > 1)
			{
				return await UploadInParallelAsync(content, num, num2, args, progressHandler, GetContentPartitionsBinaryDataInternal, StageBinaryDataPartitionInternal, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			return await UploadInSequenceInternal(content, num, num2, args, progressHandler, GetContentPartitionsBinaryDataInternal, StageBinaryDataPartitionInternal, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<Response<TCompleteUploadReturn>> UploadInternal(Stream content, long? expectedContentLength, TServiceSpecificData args, IProgress<long> progressHandler, bool async, CancellationToken cancellationToken = default(CancellationToken))
		{
			Azure.Core.Argument.AssertNotNull(content, "content");
			Azure.Storage.Errors.VerifyStreamPosition(content, "content");
			if (content.CanSeek && content.Position > 0)
			{
				content = WindowStream.GetWindow(content, content.Length - content.Position);
			}
			await _initializeDestinationInternal(args, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			long? num = expectedContentLength ?? content.GetLengthOrDefault();
			if (num < _singleUploadThreshold)
			{
				using (DisposableBucket bucket = new DisposableBucket())
				{
					UploadTransferValidationOptions oneshotValidationOptions = ValidationOptions;
					oneshotValidationOptions.PrecalculatedChecksum = _masterCrcSupplier?.Invoke() ?? default(Memory<byte>);
					if (!content.CanSeek)
					{
						Stream stream;
						if (!UseMasterCrc || _masterCrcSupplier == null)
						{
							(stream, oneshotValidationOptions) = await BufferAndOptionalChecksumStreamInternal(content, num.Value, num.Value, oneshotValidationOptions, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						}
						else
						{
							stream = await PooledMemoryStream.BufferStreamPartitionInternal(content, num.Value, num.Value, _arrayPool, null, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						}
						bucket.Add(stream);
						content = stream;
					}
					return await _singleUploadStreamingInternal(content, args, progressHandler, oneshotValidationOptions, _operationName, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
			}
			if (UseMasterCrc && _masterCrcSupplier == null)
			{
				NonCryptographicHashAlgorithmHasher masterCrc = new NonCryptographicHashAlgorithmHasher(StorageCrc64HashAlgorithm.Create());
				content = ChecksumCalculatingStream.GetReadStream(content, masterCrc.AppendHash);
				_masterCrcSupplier = () => masterCrc.GetFinalHash();
			}
			long num2 = (_blockSize.HasValue ? _blockSize.Value : ((num < 104857600) ? 4194304 : 8388608));
			if (async && _maxWorkerCount > 1)
			{
				return await UploadInParallelAsync(content, num, num2, args, progressHandler, GetStreamPartitioner(GetBufferedPartitionInternal), StageStreamPartitionInternal, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			GetNextStreamPartition partitionCreator = (content.CanSeek ? new GetNextStreamPartition(GetStreamedPartitionInternal) : new GetNextStreamPartition(GetBufferedPartitionInternal));
			return await UploadInSequenceInternal(content, num, num2, args, progressHandler, GetStreamPartitioner(partitionCreator), StageStreamPartitionInternal, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<(Stream Stream, UploadTransferValidationOptions ValidationOptions)> BufferAndOptionalChecksumStreamInternal(Stream source, long minCount, long maxCount, UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken)
		{
			Azure.Core.Argument.AssertNotNull(source, "source");
			Azure.Core.Argument.AssertNotNull(validationOptions, "validationOptions");
			bool usingChecksumStream = validationOptions.ChecksumAlgorithm != StorageChecksumAlgorithm.None && validationOptions.PrecalculatedChecksum.IsEmpty;
			ContentHasher.GetFinalStreamHash checksumCallback = null;
			int checksumSize = 0;
			IDisposable hashCalculatorDisposable = null;
			if (usingChecksumStream)
			{
				(source, checksumCallback, checksumSize, hashCalculatorDisposable) = ContentHasher.SetupChecksumCalculatingReadStream(source, validationOptions.ChecksumAlgorithm);
			}
			PooledMemoryStream item = await PooledMemoryStream.BufferStreamPartitionInternal(source, minCount, maxCount, _arrayPool, null, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (usingChecksumStream)
			{
				Memory<byte> memory = new Memory<byte>(new byte[checksumSize]);
				checksumCallback(memory.Span);
				validationOptions = new UploadTransferValidationOptions
				{
					ChecksumAlgorithm = validationOptions.ChecksumAlgorithm,
					PrecalculatedChecksum = memory
				};
			}
			hashCalculatorDisposable?.Dispose();
			return (Stream: item, ValidationOptions: validationOptions);
		}

		private async Task<Response<TCompleteUploadReturn>> UploadInSequenceInternal<TContent>(TContent content, long? contentLength, long partitionSize, TServiceSpecificData args, IProgress<long> progressHandler, GetContentPartitionsAsync<TContent> partitionContentAsync, StageContentPartitionAsync<TContent> stageContentAsync, bool async, CancellationToken cancellationToken)
		{
			Azure.Core.Pipeline.DiagnosticScope scope = _createScope(_operationName);
			try
			{
				scope.Start();
				if (progressHandler != null)
				{
					progressHandler = new AggregatingProgressIncrementer(progressHandler);
				}
				List<(long Offset, long Size)> partitions = new List<(long, long)>();
				Memory<byte> _composedBlockCrc64 = (UseMasterCrc ? new Memory<byte>(new byte[8]) : Memory<byte>.Empty);
				long composedOriginalDataLength = 0L;
				if (async)
				{
					ConfiguredCancelableAsyncEnumerable<ContentPartition<TContent>>.Enumerator asyncEnumerator = partitionContentAsync(content, contentLength, partitionSize, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false).GetAsyncEnumerator();
					object obj = null;
					try
					{
						while (await asyncEnumerator.MoveNextAsync())
						{
							ContentPartition<TContent> block = asyncEnumerator.Current;
							await stageContentAsync(block.Content, block.AbsolutePosition, args, new UploadTransferValidationOptions
							{
								ChecksumAlgorithm = _validationAlgorithm,
								PrecalculatedChecksum = block.ContentChecksum
							}, progressHandler, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
							partitions.Add((block.AbsolutePosition, block.Length));
							if (UseMasterCrc)
							{
								_composedBlockCrc64 = Azure.Storage.StorageCrc64Composer.Compose((_composedBlockCrc64.ToArray(), composedOriginalDataLength), (block.ContentChecksum.ToArray(), block.Length));
							}
						}
					}
					catch (object obj2)
					{
						obj = obj2;
					}
					await asyncEnumerator.DisposeAsync();
					object obj3 = obj;
					if (obj3 != null)
					{
						ExceptionDispatchInfo.Capture((obj3 as Exception) ?? throw obj3).Throw();
					}
				}
				else
				{
					foreach (ContentPartition<TContent> item in partitionContentAsync(content, contentLength, partitionSize, async: false, cancellationToken).EnsureSyncEnumerable())
					{
						stageContentAsync(item.Content, item.AbsolutePosition, args, new UploadTransferValidationOptions
						{
							ChecksumAlgorithm = _validationAlgorithm,
							PrecalculatedChecksum = item.ContentChecksum
						}, progressHandler, async: false, cancellationToken).EnsureCompleted();
						partitions.Add((item.AbsolutePosition, item.Length));
						if (UseMasterCrc)
						{
							_composedBlockCrc64 = Azure.Storage.StorageCrc64Composer.Compose((_composedBlockCrc64.ToArray(), composedOriginalDataLength), (item.ContentChecksum.ToArray(), item.Length));
						}
					}
				}
				if (UseMasterCrc)
				{
					Memory<byte> memory = _masterCrcSupplier();
					if (!_composedBlockCrc64.Span.SequenceEqual(memory.Span))
					{
						throw Azure.Storage.Errors.ChecksumMismatch(memory.Span, _composedBlockCrc64.Span);
					}
				}
				return await _commitPartitionedUploadInternal(partitions, args, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			catch (Exception exception)
			{
				scope.Failed(exception);
				throw;
			}
			finally
			{
				scope.Dispose();
			}
		}

		private async Task<Response<TCompleteUploadReturn>> UploadInParallelAsync<TContent>(TContent content, long? contentLength, long blockSize, TServiceSpecificData args, IProgress<long> progressHandler, GetContentPartitionsAsync<TContent> partitionContentAsync, StageContentPartitionAsync<TContent> stageContentAsync, CancellationToken cancellationToken)
		{
			Azure.Core.Pipeline.DiagnosticScope scope = _createScope(_operationName);
			try
			{
				scope.Start();
				if (progressHandler != null)
				{
					progressHandler = new AggregatingProgressIncrementer(progressHandler);
				}
				List<(long Offset, long Size)> partitions = new List<(long, long)>();
				List<Task> runningTasks = new List<Task>();
				Memory<byte> _composedBlockCrc64 = (UseMasterCrc ? new Memory<byte>(new byte[8]) : Memory<byte>.Empty);
				long composedOriginalDataLength = 0L;
				ConfiguredCancelableAsyncEnumerable<ContentPartition<TContent>>.Enumerator asyncEnumerator = partitionContentAsync(content, contentLength, blockSize, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false).GetAsyncEnumerator();
				object obj = null;
				try
				{
					while (await asyncEnumerator.MoveNextAsync())
					{
						ContentPartition<TContent> current = asyncEnumerator.Current;
						partitions.Add((current.AbsolutePosition, current.Length));
						if (UseMasterCrc)
						{
							_composedBlockCrc64 = Azure.Storage.StorageCrc64Composer.Compose((_composedBlockCrc64.ToArray(), composedOriginalDataLength), (current.ContentChecksum.ToArray(), current.Length));
						}
						Task item = stageContentAsync(current.Content, current.AbsolutePosition, args, new UploadTransferValidationOptions
						{
							ChecksumAlgorithm = _validationAlgorithm,
							PrecalculatedChecksum = current.ContentChecksum
						}, progressHandler, async: true, cancellationToken);
						runningTasks.Add(item);
						if (runningTasks.Count < _maxWorkerCount)
						{
							continue;
						}
						await Task.WhenAny(runningTasks).ConfigureAwait(continueOnCapturedContext: false);
						for (int i = 0; i < runningTasks.Count; i++)
						{
							Task task = runningTasks[i];
							if (task.IsCompleted)
							{
								await task.ConfigureAwait(continueOnCapturedContext: false);
								runningTasks.RemoveAt(i);
								i--;
							}
						}
					}
				}
				catch (object obj2)
				{
					obj = obj2;
				}
				await asyncEnumerator.DisposeAsync();
				object obj3 = obj;
				if (obj3 != null)
				{
					ExceptionDispatchInfo.Capture((obj3 as Exception) ?? throw obj3).Throw();
				}
				await Task.WhenAll(runningTasks).ConfigureAwait(continueOnCapturedContext: false);
				if (UseMasterCrc)
				{
					Memory<byte> memory = _masterCrcSupplier();
					if (!_composedBlockCrc64.Span.SequenceEqual(memory.Span))
					{
						throw Azure.Storage.Errors.ChecksumMismatch(memory.Span, _composedBlockCrc64.Span);
					}
				}
				return await _commitPartitionedUploadInternal(partitions, args, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			catch (Exception exception)
			{
				scope.Failed(exception);
				throw;
			}
			finally
			{
				scope.Dispose();
			}
		}

		private async Task StageStreamPartitionInternal(Stream partition, long offset, TServiceSpecificData args, UploadTransferValidationOptions validationOptions, IProgress<long> progressHandler, bool async, CancellationToken cancellationToken)
		{
			try
			{
				await _uploadPartitionStreamingInternal(partition, offset, args, progressHandler, validationOptions, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			finally
			{
				partition.Dispose();
			}
		}

		private async Task StageBinaryDataPartitionInternal(BinaryData content, long offset, TServiceSpecificData args, UploadTransferValidationOptions validationOptions, IProgress<long> progressHandler, bool async, CancellationToken cancellationToken)
		{
			await _uploadPartitionBinaryDataInternal(content, offset, args, progressHandler, validationOptions, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async IAsyncEnumerable<ContentPartition<BinaryData>> GetContentPartitionsBinaryDataInternal(BinaryData content, long? contentLength, long blockSize, bool async, [EnumeratorCancellation] CancellationToken cancellationToken)
		{
			foreach (ContentPartition<BinaryData> binaryDataPartition in GetBinaryDataPartitions(content, (int)blockSize))
			{
				yield return (!async) ? binaryDataPartition : (await Task.FromResult(binaryDataPartition).ConfigureAwait(continueOnCapturedContext: false));
			}
		}

		private IEnumerable<ContentPartition<BinaryData>> GetBinaryDataPartitions(BinaryData content, int blockSize)
		{
			int position = 0;
			ReadOnlyMemory<byte> remaining = content.ToMemory();
			while (!remaining.IsEmpty)
			{
				ReadOnlyMemory<byte> next;
				if (remaining.Length <= blockSize)
				{
					next = remaining;
					remaining = ReadOnlyMemory<byte>.Empty;
				}
				else
				{
					next = remaining.Slice(0, blockSize);
					remaining = remaining.Slice(blockSize);
				}
				BinaryData content2 = BinaryData.FromBytes(next);
				ContentHasher.GetHashResult hashOrDefault = ContentHasher.GetHashOrDefault(content2, ValidationOptions);
				yield return new ContentPartition<BinaryData>(position, next.Length, content2, hashOrDefault?.Checksum ?? ReadOnlyMemory<byte>.Empty);
				position += next.Length;
			}
		}

		private static GetContentPartitionsAsync<Stream> GetStreamPartitioner(GetNextStreamPartition partitionCreator)
		{
			return (Stream content, long? contentLength, long blockSize, bool async, CancellationToken cancellationToken) => GetStreamPartitionsAsync(content, contentLength, blockSize, partitionCreator, async, cancellationToken);
		}

		private static async IAsyncEnumerable<ContentPartition<Stream>> GetStreamPartitionsAsync(Stream stream, long? streamLength, long blockSize, GetNextStreamPartition getNextPartition, bool async, [EnumeratorCancellation] CancellationToken cancellationToken)
		{
			long acceptableBlockSize = Math.Max(1L, blockSize / 2);
			if (streamLength.HasValue)
			{
				long num = (long)Math.Ceiling((double)streamLength.Value / 50000.0);
				if (blockSize < num)
				{
					throw Azure.Storage.Errors.InsufficientStorageTransferOptions(streamLength.Value, blockSize, num);
				}
				acceptableBlockSize = Math.Max(acceptableBlockSize, num);
			}
			long absolutePosition = 0L;
			long read;
			do
			{
				(Stream, ReadOnlyMemory<byte>) obj = await getNextPartition(stream, acceptableBlockSize, blockSize, absolutePosition, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				Stream item = obj.Item1;
				ReadOnlyMemory<byte> item2 = obj.Item2;
				read = item.Length;
				if (item.Length != 0L)
				{
					yield return new ContentPartition<Stream>(absolutePosition, item.Length, item, item2);
				}
				absolutePosition += read;
			}
			while (read != 0L);
		}

		private async Task<(Stream PartitionContent, ReadOnlyMemory<byte> PartitionChecksum)> GetBufferedPartitionInternal(Stream stream, long minCount, long maxCount, long absolutePosition, bool async, CancellationToken cancellationToken)
		{
			var (item, uploadTransferValidationOptions) = await BufferAndOptionalChecksumStreamInternal(stream, minCount, maxCount, new UploadTransferValidationOptions
			{
				ChecksumAlgorithm = _validationAlgorithm
			}, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return (PartitionContent: item, PartitionChecksum: uploadTransferValidationOptions.PrecalculatedChecksum);
		}

		private async Task<(Stream PartitionContent, ReadOnlyMemory<byte> PartitionChecksum)> GetStreamedPartitionInternal(Stream stream, long minCount, long maxCount, long absolutePosition, bool async, CancellationToken cancellationToken)
		{
			if (!stream.CanSeek)
			{
				throw Azure.Storage.Errors.InvalidArgument("stream");
			}
			Stream partitionStream = WindowStream.GetWindow(stream, maxCount);
			return (PartitionContent: partitionStream, PartitionChecksum: (await ContentHasher.GetHashOrDefaultInternal(partitionStream, ValidationOptions, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))?.Checksum ?? ReadOnlyMemory<byte>.Empty);
		}
	}
	internal class ProgressIncrementingStream : Stream
	{
		private readonly Stream _innerStream;

		private readonly AggregatingProgressIncrementer _incrementer;

		public override bool CanRead => _innerStream.CanRead;

		public override bool CanSeek => _innerStream.CanSeek;

		public override bool CanTimeout => _innerStream.CanTimeout;

		public override bool CanWrite => _innerStream.CanWrite;

		public override long Length => _innerStream.Length;

		public override long Position
		{
			get
			{
				return _innerStream.Position;
			}
			set
			{
				long bytes = value - _innerStream.Position;
				_innerStream.Position = value;
				_incrementer.Report(bytes);
			}
		}

		public override int ReadTimeout
		{
			get
			{
				return _innerStream.ReadTimeout;
			}
			set
			{
				_innerStream.ReadTimeout = value;
			}
		}

		public override int WriteTimeout
		{
			get
			{
				return _innerStream.WriteTimeout;
			}
			set
			{
				_innerStream.WriteTimeout = value;
			}
		}

		public ProgressIncrementingStream(Stream stream, AggregatingProgressIncrementer incrementer)
		{
			_innerStream = stream ?? throw Azure.Storage.Errors.ArgumentNull("stream");
			_incrementer = incrementer ?? throw Azure.Storage.Errors.ArgumentNull("incrementer");
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			_innerStream.Dispose();
		}

		public override async Task FlushAsync(CancellationToken cancellationToken)
		{
			long oldPosition = _innerStream.Position;
			await _innerStream.FlushAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			long position = _innerStream.Position;
			_incrementer.Report(position - oldPosition);
		}

		public override void Flush()
		{
			long position = _innerStream.Position;
			_innerStream.Flush();
			long position2 = _innerStream.Position;
			_incrementer.Report(position2 - position);
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			int num = _innerStream.Read(buffer, offset, count);
			_incrementer.Report(num);
			return num;
		}

		public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
		{
			int num = await _innerStream.ReadAsync(buffer, offset, count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			_incrementer.Report(num);
			return num;
		}

		public override int ReadByte()
		{
			int num = _innerStream.ReadByte();
			if (num != -1)
			{
				_incrementer.Report(1L);
			}
			return num;
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			long position = _innerStream.Position;
			long num = _innerStream.Seek(offset, origin);
			_incrementer.Report(num - position);
			return num;
		}

		public override void SetLength(long value)
		{
			_innerStream.SetLength(value);
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			_innerStream.Write(buffer, offset, count);
			_incrementer.Report(count);
		}

		public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
		{
			await _innerStream.WriteAsync(buffer, offset, count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			_incrementer.Report(count);
		}

		public override void WriteByte(byte value)
		{
			_innerStream.WriteByte(value);
			_incrementer.Report(1L);
		}
	}
	internal sealed class SharedAccessSignatureCredentials
	{
		public string SasToken { get; }

		public SharedAccessSignatureCredentials(string sasToken)
		{
			SasToken = sasToken;
		}
	}
	internal static class StorageClientOptions
	{
		private const string StorageScope = "https://storage.azure.com/.default";

		public static void Initialize(this ClientOptions options)
		{
			options.Retry.MaxRetries = 5;
		}

		public static HttpPipelinePolicy AsPolicy(this StorageSharedKeyCredential credential)
		{
			return new Azure.Storage.StorageSharedKeyPipelinePolicy(credential ?? throw Azure.Storage.Errors.ArgumentNull("credential"));
		}

		public static HttpPipelinePolicy AsPolicy<TUriBuilder>(this AzureSasCredential credential, Uri resourceUri)
		{
			Azure.Core.Argument.AssertNotNull(resourceUri, "resourceUri");
			Azure.Core.Argument.AssertNotNull(credential, "credential");
			if (resourceUri.GetQueryParameters().ContainsKey("sig"))
			{
				throw Azure.Storage.Errors.SasCredentialRequiresUriWithoutSas<TUriBuilder>(resourceUri);
			}
			return new Azure.Core.AzureSasCredentialSynchronousPolicy(credential);
		}

		public static HttpPipelinePolicy AsPolicy(this TokenCredential credential, string scope, ClientOptions options)
		{
			return new Azure.Storage.StorageBearerTokenChallengeAuthorizationPolicy(credential ?? throw Azure.Storage.Errors.ArgumentNull("credential"), scope ?? "https://storage.azure.com/.default", options is Azure.Storage.Shared.ISupportsTenantIdChallenges supportsTenantIdChallenges && supportsTenantIdChallenges.EnableTenantDiscovery);
		}

		public static HttpPipelinePolicy GetAuthenticationPolicy(object credentials = null, string scope = null, ClientOptions options = null)
		{
			if (!(credentials is Azure.Storage.SharedAccessSignatureCredentials) && credentials != null)
			{
				if (!(credentials is StorageSharedKeyCredential credential))
				{
					if (credentials is TokenCredential credential2)
					{
						return credential2.AsPolicy(scope, options);
					}
					throw Azure.Storage.Errors.InvalidCredentials(credentials.GetType().FullName);
				}
				return credential.AsPolicy();
			}
			return null;
		}

		public static HttpPipeline Build(this ClientOptions options, HttpPipelinePolicy authentication = null, Uri geoRedundantSecondaryStorageUri = null)
		{
			Azure.Storage.StorageResponseClassifier storageResponseClassifier = new Azure.Storage.StorageResponseClassifier();
			HttpPipelineOptions httpPipelineOptions = new HttpPipelineOptions(options)
			{
				PerCallPolicies = { (HttpPipelinePolicy)StorageServerTimeoutPolicy.Shared },
				PerRetryPolicies = { (HttpPipelinePolicy)StorageTelemetryPolicy.Shared },
				ResponseClassifier = storageResponseClassifier,
				RequestFailedDetailsParser = new StorageRequestFailedDetailsParser()
			};
			if (geoRedundantSecondaryStorageUri != null)
			{
				httpPipelineOptions.PerRetryPolicies.Add(new Azure.Storage.GeoRedundantReadPolicy(geoRedundantSecondaryStorageUri));
				storageResponseClassifier.SecondaryStorageUri = geoRedundantSecondaryStorageUri;
			}
			httpPipelineOptions.PerRetryPolicies.Add(new StorageRequestValidationPipelinePolicy());
			httpPipelineOptions.PerRetryPolicies.Add(authentication);
			return HttpPipelineBuilder.Build(httpPipelineOptions);
		}

		public static HttpPipeline Build(this ClientOptions options, object credentials, Uri geoRedundantSecondaryStorageUri = null)
		{
			return options.Build(GetAuthenticationPolicy(credentials), geoRedundantSecondaryStorageUri);
		}
	}
	internal class StorageConnectionString
	{
		private static readonly KeyValuePair<string, Func<string, bool>> s_useDevelopmentStorageSetting = Setting("UseDevelopmentStorage", "true");

		private static readonly KeyValuePair<string, Func<string, bool>> s_developmentStorageProxyUriSetting = Setting("DevelopmentStorageProxyUri", IsValidUri);

		private static readonly KeyValuePair<string, Func<string, bool>> s_defaultEndpointsProtocolSetting = Setting("DefaultEndpointsProtocol", "http", "https");

		private static readonly KeyValuePair<string, Func<string, bool>> s_accountNameSetting = Setting("AccountName");

		private static readonly KeyValuePair<string, Func<string, bool>> s_accountKeyNameSetting = Setting("AccountKeyName");

		private static readonly KeyValuePair<string, Func<string, bool>> s_accountKeySetting = Setting("AccountKey", IsValidBase64String);

		private static readonly KeyValuePair<string, Func<string, bool>> s_blobEndpointSetting = Setting("BlobEndpoint", IsValidUri);

		private static readonly KeyValuePair<string, Func<string, bool>> s_queueEndpointSetting = Setting("QueueEndpoint", IsValidUri);

		private static readonly KeyValuePair<string, Func<string, bool>> s_fileEndpointSetting = Setting("FileEndpoint", IsValidUri);

		private static readonly KeyValuePair<string, Func<string, bool>> s_tableEndpointSetting = Setting("TableEndpoint", IsValidUri);

		private static readonly KeyValuePair<string, Func<string, bool>> s_blobSecondaryEndpointSetting = Setting("BlobSecondaryEndpoint", IsValidUri);

		private static readonly KeyValuePair<string, Func<string, bool>> s_queueSecondaryEndpointSetting = Setting("QueueSecondaryEndpoint", IsValidUri);

		private static readonly KeyValuePair<string, Func<string, bool>> s_fileSecondaryEndpointSetting = Setting("FileSecondaryEndpoint", IsValidUri);

		private static readonly KeyValuePair<string, Func<string, bool>> s_tableSecondaryEndpointSetting = Setting("TableSecondaryEndpoint", IsValidUri);

		private static readonly KeyValuePair<string, Func<string, bool>> s_endpointSuffixSetting = Setting("EndpointSuffix", IsValidDomain);

		private static readonly KeyValuePair<string, Func<string, bool>> s_sharedAccessSignatureSetting = Setting("SharedAccessSignature");

		private static Azure.Storage.StorageConnectionString s_devStoreAccount;

		internal string _accountName;

		private static readonly Func<IDictionary<string, string>, IDictionary<string, string>> s_validCredentials = MatchesOne(MatchesAll(AllRequired(s_accountNameSetting, s_accountKeySetting), Optional(s_accountKeyNameSetting), None(s_sharedAccessSignatureSetting)), MatchesAll(AllRequired(s_sharedAccessSignatureSetting), Optional(s_accountNameSetting), None(s_accountKeySetting, s_accountKeyNameSetting)), None(s_accountNameSetting, s_accountKeySetting, s_accountKeyNameSetting, s_sharedAccessSignatureSetting));

		internal static bool UseV1MD5 => true;

		public static Azure.Storage.StorageConnectionString DevelopmentStorageAccount
		{
			get
			{
				if (s_devStoreAccount == null)
				{
					s_devStoreAccount = GetDevelopmentStorageAccount(null);
				}
				return s_devStoreAccount;
			}
		}

		internal bool IsDevStoreAccount { get; set; }

		internal string EndpointSuffix { get; set; }

		internal IDictionary<string, string> Settings { get; set; }

		internal bool DefaultEndpoints { get; set; }

		public Uri BlobEndpoint => BlobStorageUri.PrimaryUri;

		public Uri QueueEndpoint => QueueStorageUri.PrimaryUri;

		public Uri TableEndpoint => TableStorageUri.PrimaryUri;

		public Uri FileEndpoint => FileStorageUri.PrimaryUri;

		public (Uri PrimaryUri, Uri SecondaryUri) BlobStorageUri { get; set; }

		public (Uri PrimaryUri, Uri SecondaryUri) QueueStorageUri { get; set; }

		public (Uri PrimaryUri, Uri SecondaryUri) TableStorageUri { get; set; }

		public (Uri PrimaryUri, Uri SecondaryUri) FileStorageUri { get; set; }

		public object Credentials { get; set; }

		public StorageConnectionString(object storageCredentials, (Uri Primary, Uri Secondary) blobStorageUri = default((Uri Primary, Uri Secondary)), (Uri Primary, Uri Secondary) queueStorageUri = default((Uri Primary, Uri Secondary)), (Uri Primary, Uri Secondary) tableStorageUri = default((Uri Primary, Uri Secondary)), (Uri Primary, Uri Secondary) fileStorageUri = default((Uri Primary, Uri Secondary)))
		{
			Credentials = storageCredentials;
			BlobStorageUri = blobStorageUri;
			QueueStorageUri = queueStorageUri;
			TableStorageUri = tableStorageUri;
			FileStorageUri = fileStorageUri;
			DefaultEndpoints = false;
		}

		public static Azure.Storage.StorageConnectionString Parse(string connectionString)
		{
			if (string.IsNullOrEmpty(connectionString))
			{
				throw Azure.Storage.Errors.ArgumentNull("connectionString");
			}
			if (ParseCore(connectionString, out var accountInformation, delegate(string err)
			{
				throw Azure.Storage.Errors.InvalidFormat(err);
			}))
			{
				return accountInformation;
			}
			throw Azure.Storage.Errors.ParsingConnectionStringFailed();
		}

		public static bool TryParse(string connectionString, out Azure.Storage.StorageConnectionString account)
		{
			if (string.IsNullOrEmpty(connectionString))
			{
				account = null;
				return false;
			}
			try
			{
				return ParseCore(connectionString, out account, delegate
				{
				});
			}
			catch (Exception)
			{
				account = null;
				return false;
			}
		}

		private static Azure.Storage.StorageConnectionString GetDevelopmentStorageAccount(Uri proxyUri)
		{
			UriBuilder obj = ((proxyUri != null) ? new UriBuilder(proxyUri.Scheme, proxyUri.Host) : new UriBuilder("http", "127.0.0.1"));
			obj.Path = "devstoreaccount1";
			obj.Port = 10000;
			Uri uri = obj.Uri;
			obj.Port = 10002;
			Uri uri2 = obj.Uri;
			obj.Port = 10001;
			Uri uri3 = obj.Uri;
			obj.Path = "devstoreaccount1-secondary";
			obj.Port = 10000;
			Uri uri4 = obj.Uri;
			obj.Port = 10001;
			Uri uri5 = obj.Uri;
			obj.Port = 10002;
			Uri uri6 = obj.Uri;
			Azure.Storage.StorageConnectionString storageConnectionString = new Azure.Storage.StorageConnectionString(new StorageSharedKeyCredential("devstoreaccount1", "Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw=="), (Primary: uri, Secondary: uri4), (Primary: uri3, Secondary: uri5), (Primary: uri2, Secondary: uri6), (Primary: null, Secondary: null));
			storageConnectionString.Settings = new Dictionary<string, string>();
			storageConnectionString.Settings.Add("UseDevelopmentStorage", "true");
			if (proxyUri != null)
			{
				storageConnectionString.Settings.Add("DevelopmentStorageProxyUri", proxyUri.AbsoluteUri);
			}
			storageConnectionString.IsDevStoreAccount = true;
			return storageConnectionString;
		}

		internal static bool ParseCore(string connectionString, out Azure.Storage.StorageConnectionString accountInformation, Action<string> error)
		{
			IDictionary<string, string> settings = ParseStringIntoSettings(connectionString, error);
			if (settings == null)
			{
				accountInformation = null;
				return false;
			}
			if (MatchesSpecification(settings, AllRequired(s_useDevelopmentStorageSetting), Optional(s_developmentStorageProxyUriSetting)))
			{
				accountInformation = (settings.TryGetValue("DevelopmentStorageProxyUri", out var value) ? GetDevelopmentStorageAccount(new Uri(value)) : DevelopmentStorageAccount);
				accountInformation.Settings = s_validCredentials(settings);
				return true;
			}
			Func<IDictionary<string, string>, IDictionary<string, string>> func = Optional(s_blobEndpointSetting, s_blobSecondaryEndpointSetting, s_queueEndpointSetting, s_queueSecondaryEndpointSetting, s_fileEndpointSetting, s_fileSecondaryEndpointSetting, s_tableEndpointSetting, s_tableSecondaryEndpointSetting);
			Func<IDictionary<string, string>, IDictionary<string, string>> func2 = AtLeastOne(s_blobEndpointSetting, s_queueEndpointSetting, s_fileEndpointSetting, s_tableEndpointSetting);
			Func<IDictionary<string, string>, IDictionary<string, string>> func3 = Optional(s_blobSecondaryEndpointSetting, s_queueSecondaryEndpointSetting, s_fileSecondaryEndpointSetting, s_tableSecondaryEndpointSetting);
			Func<IDictionary<string, string>, IDictionary<string, string>> func4 = MatchesExactly(MatchesAll(MatchesOne(MatchesAll(AllRequired(s_accountKeySetting), Optional(s_accountKeyNameSetting)), AllRequired(s_sharedAccessSignatureSetting)), AllRequired(s_accountNameSetting), func, Optional(s_defaultEndpointsProtocolSetting, s_endpointSuffixSetting)));
			Func<IDictionary<string, string>, IDictionary<string, string>> func5 = MatchesExactly(MatchesAll(s_validCredentials, func2, func3));
			bool matchesAutomaticEndpointsSpec = MatchesSpecification(settings, func4);
			bool flag = MatchesSpecification(settings, func5);
			if (matchesAutomaticEndpointsSpec || flag)
			{
				if (matchesAutomaticEndpointsSpec && !settings.ContainsKey("DefaultEndpointsProtocol"))
				{
					settings.Add("DefaultEndpointsProtocol", "https");
				}
				string primary = settingOrDefault("BlobEndpoint");
				string primary2 = settingOrDefault("QueueEndpoint");
				string primary3 = settingOrDefault("TableEndpoint");
				string primary4 = settingOrDefault("FileEndpoint");
				string secondary = settingOrDefault("BlobSecondaryEndpoint");
				string secondary2 = settingOrDefault("QueueSecondaryEndpoint");
				string secondary3 = settingOrDefault("TableSecondaryEndpoint");
				string secondary4 = settingOrDefault("FileSecondaryEndpoint");
				string sasToken = settingOrDefault("SharedAccessSignature");
				if (s_isValidEndpointPair(primary, secondary) && s_isValidEndpointPair(primary2, secondary2) && s_isValidEndpointPair(primary3, secondary3) && s_isValidEndpointPair(primary4, secondary4))
				{
					accountInformation = new Azure.Storage.StorageConnectionString(GetCredentials(settings), createStorageUri(primary, secondary, sasToken, ConstructBlobEndpoint), createStorageUri(primary2, secondary2, sasToken, ConstructQueueEndpoint), createStorageUri(primary3, secondary3, sasToken, ConstructTableEndpoint), createStorageUri(primary4, secondary4, sasToken, ConstructFileEndpoint))
					{
						EndpointSuffix = settingOrDefault("EndpointSuffix"),
						Settings = s_validCredentials(settings)
					};
					accountInformation._accountName = settingOrDefault("AccountName");
					return true;
				}
			}
			accountInformation = null;
			error("No valid combination of account information found.");
			return false;
			static Uri CreateUri(string endpoint, string text)
			{
				UriBuilder uriBuilder = new UriBuilder(endpoint);
				if (!string.IsNullOrEmpty(uriBuilder.Query))
				{
					uriBuilder.Query = uriBuilder.Query + "&" + text;
				}
				else
				{
					uriBuilder.Query = text;
				}
				return uriBuilder.Uri;
			}
			(Uri Primary, Uri Secondary) createStorageUri(string text2, string text, string sasToken2, Func<IDictionary<string, string>, (Uri Primary, Uri Secondary)> factory)
			{
				if (string.IsNullOrWhiteSpace(text) || string.IsNullOrWhiteSpace(text2))
				{
					if (string.IsNullOrWhiteSpace(text2))
					{
						if (!matchesAutomaticEndpointsSpec || factory == null)
						{
							return (Primary: null, Secondary: null);
						}
						return factory(settings);
					}
					return (Primary: CreateUri(text2, sasToken2), Secondary: null);
				}
				return (Primary: CreateUri(text2, sasToken2), Secondary: CreateUri(text, sasToken2));
			}
			static bool s_isValidEndpointPair(string value2, string value3)
			{
				if (string.IsNullOrWhiteSpace(value2))
				{
					return string.IsNullOrWhiteSpace(value3);
				}
				return true;
			}
			string settingOrDefault(string key)
			{
				settings.TryGetValue(key, out var value2);
				return value2;
			}
		}

		private static IDictionary<string, string> ParseStringIntoSettings(string connectionString, Action<string> error)
		{
			IDictionary<string, string> dictionary = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
			string[] array = connectionString.Split(new char[1] { ';' }, StringSplitOptions.RemoveEmptyEntries);
			for (int i = 0; i < array.Length; i++)
			{
				string[] array2 = array[i].Split(new char[1] { '=' }, 2);
				if (array2.Length != 2)
				{
					error("Settings must be of the form \"name=value\".");
					return null;
				}
				if (dictionary.ContainsKey(array2[0]))
				{
					error(string.Format(CultureInfo.InvariantCulture, "Duplicate setting '{0}' found.", array2[0]));
					return null;
				}
				dictionary.Add(array2[0], array2[1]);
			}
			return dictionary;
		}

		private static KeyValuePair<string, Func<string, bool>> Setting(string name, params string[] validValues)
		{
			return new KeyValuePair<string, Func<string, bool>>(name, (string settingValue) => validValues.Length == 0 || validValues.Contains(settingValue, StringComparer.OrdinalIgnoreCase));
		}

		private static KeyValuePair<string, Func<string, bool>> Setting(string name, Func<string, bool> isValid)
		{
			return new KeyValuePair<string, Func<string, bool>>(name, isValid);
		}

		private static bool IsValidBase64String(string settingValue)
		{
			try
			{
				Convert.FromBase64String(settingValue);
				return true;
			}
			catch (FormatException)
			{
				return false;
			}
		}

		private static bool IsValidUri(string settingValue)
		{
			return Uri.IsWellFormedUriString(settingValue, UriKind.Absolute);
		}

		private static bool IsValidDomain(string settingValue)
		{
			return Uri.CheckHostName(settingValue).Equals(UriHostNameType.Dns);
		}

		private static Func<IDictionary<string, string>, IDictionary<string, string>> AllRequired(params KeyValuePair<string, Func<string, bool>>[] requiredSettings)
		{
			return delegate(IDictionary<string, string> settings)
			{
				IDictionary<string, string> dictionary = new Dictionary<string, string>(settings, StringComparer.OrdinalIgnoreCase);
				KeyValuePair<string, Func<string, bool>>[] array = requiredSettings;
				for (int i = 0; i < array.Length; i++)
				{
					KeyValuePair<string, Func<string, bool>> keyValuePair = array[i];
					if (!dictionary.TryGetValue(keyValuePair.Key, out var value) || !keyValuePair.Value(value))
					{
						return (IDictionary<string, string>)null;
					}
					dictionary.Remove(keyValuePair.Key);
				}
				return dictionary;
			};
		}

		private static Func<IDictionary<string, string>, IDictionary<string, string>> Optional(params KeyValuePair<string, Func<string, bool>>[] optionalSettings)
		{
			return delegate(IDictionary<string, string> settings)
			{
				IDictionary<string, string> dictionary = new Dictionary<string, string>(settings, StringComparer.OrdinalIgnoreCase);
				KeyValuePair<string, Func<string, bool>>[] array = optionalSettings;
				for (int i = 0; i < array.Length; i++)
				{
					KeyValuePair<string, Func<string, bool>> keyValuePair = array[i];
					if (dictionary.TryGetValue(keyValuePair.Key, out var value) && keyValuePair.Value(value))
					{
						dictionary.Remove(keyValuePair.Key);
					}
				}
				return dictionary;
			};
		}

		private static Func<IDictionary<string, string>, IDictionary<string, string>> AtLeastOne(params KeyValuePair<string, Func<string, bool>>[] atLeastOneSettings)
		{
			return delegate(IDictionary<string, string> settings)
			{
				IDictionary<string, string> dictionary = new Dictionary<string, string>(settings, StringComparer.OrdinalIgnoreCase);
				bool flag = false;
				KeyValuePair<string, Func<string, bool>>[] array = atLeastOneSettings;
				for (int i = 0; i < array.Length; i++)
				{
					KeyValuePair<string, Func<string, bool>> keyValuePair = array[i];
					if (dictionary.TryGetValue(keyValuePair.Key, out var value) && keyValuePair.Value(value))
					{
						dictionary.Remove(keyValuePair.Key);
						flag = true;
					}
				}
				return (!flag) ? null : dictionary;
			};
		}

		private static Func<IDictionary<string, string>, IDictionary<string, string>> None(params KeyValuePair<string, Func<string, bool>>[] atLeastOneSettings)
		{
			return delegate(IDictionary<string, string> settings)
			{
				IDictionary<string, string> dictionary = new Dictionary<string, string>(settings, StringComparer.OrdinalIgnoreCase);
				bool flag = false;
				KeyValuePair<string, Func<string, bool>>[] array = atLeastOneSettings;
				for (int i = 0; i < array.Length; i++)
				{
					KeyValuePair<string, Func<string, bool>> keyValuePair = array[i];
					if (dictionary.TryGetValue(keyValuePair.Key, out var value) && keyValuePair.Value(value))
					{
						flag = true;
					}
				}
				return (!flag) ? dictionary : null;
			};
		}

		private static Func<IDictionary<string, string>, IDictionary<string, string>> MatchesAll(params Func<IDictionary<string, string>, IDictionary<string, string>>[] filters)
		{
			return delegate(IDictionary<string, string> settings)
			{
				IDictionary<string, string> dictionary = new Dictionary<string, string>(settings, StringComparer.OrdinalIgnoreCase);
				Func<IDictionary<string, string>, IDictionary<string, string>>[] array = filters;
				foreach (Func<IDictionary<string, string>, IDictionary<string, string>> func in array)
				{
					if (dictionary == null)
					{
						break;
					}
					dictionary = func(dictionary);
				}
				return dictionary;
			};
		}

		private static Func<IDictionary<string, string>, IDictionary<string, string>> MatchesOne(params Func<IDictionary<string, string>, IDictionary<string, string>>[] filters)
		{
			return delegate(IDictionary<string, string> settings)
			{
				IDictionary<string, string>[] array = (from filter in filters
					select filter(new Dictionary<string, string>(settings)) into result
					where result != null
					select result).Take(2).ToArray();
				return (array.Length == 1) ? array.First() : null;
			};
		}

		private static Func<IDictionary<string, string>, IDictionary<string, string>> MatchesExactly(Func<IDictionary<string, string>, IDictionary<string, string>> filter)
		{
			return delegate(IDictionary<string, string> settings)
			{
				IDictionary<string, string> dictionary = filter(settings);
				return (dictionary != null && !dictionary.Any()) ? dictionary : null;
			};
		}

		private static bool MatchesSpecification(IDictionary<string, string> settings, params Func<IDictionary<string, string>, IDictionary<string, string>>[] constraints)
		{
			for (int i = 0; i < constraints.Length; i++)
			{
				IDictionary<string, string> dictionary = constraints[i](settings);
				if (dictionary == null)
				{
					return false;
				}
				settings = dictionary;
			}
			return !settings.Any();
		}

		private static object GetCredentials(IDictionary<string, string> settings)
		{
			settings.TryGetValue("AccountName", out var value);
			settings.TryGetValue("AccountKey", out var value2);
			settings.TryGetValue("SharedAccessSignature", out var value3);
			if (value == null || value2 == null || value3 != null)
			{
				if (value2 != null || value3 == null)
				{
					return null;
				}
				return new Azure.Storage.SharedAccessSignatureCredentials(value3);
			}
			return new StorageSharedKeyCredential(value, value2);
		}

		private static (Uri Primary, Uri Secondary) ConstructBlobEndpoint(IDictionary<string, string> settings)
		{
			return ConstructBlobEndpoint(settings["DefaultEndpointsProtocol"], settings["AccountName"], settings.ContainsKey("EndpointSuffix") ? settings["EndpointSuffix"] : null, settings.ContainsKey("SharedAccessSignature") ? settings["SharedAccessSignature"] : null);
		}

		internal static (Uri Primary, Uri Secondary) ConstructBlobEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken)
		{
			if (string.IsNullOrEmpty(scheme))
			{
				throw Azure.Storage.Errors.ArgumentNull("scheme");
			}
			if (string.IsNullOrEmpty(accountName))
			{
				throw Azure.Storage.Errors.ArgumentNull("accountName");
			}
			if (string.IsNullOrEmpty(endpointSuffix))
			{
				endpointSuffix = "core.windows.net";
			}
			return ConstructUris(scheme, accountName, "blob", endpointSuffix, sasToken);
		}

		private static (Uri Primary, Uri Secondary) ConstructFileEndpoint(IDictionary<string, string> settings)
		{
			return ConstructFileEndpoint(settings["DefaultEndpointsProtocol"], settings["AccountName"], settings.ContainsKey("EndpointSuffix") ? settings["EndpointSuffix"] : null, settings.ContainsKey("SharedAccessSignature") ? settings["SharedAccessSignature"] : null);
		}

		internal static (Uri Primary, Uri Secondary) ConstructFileEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken)
		{
			if (string.IsNullOrEmpty(scheme))
			{
				throw Azure.Storage.Errors.ArgumentNull("scheme");
			}
			if (string.IsNullOrEmpty(accountName))
			{
				throw Azure.Storage.Errors.ArgumentNull("accountName");
			}
			if (string.IsNullOrEmpty(endpointSuffix))
			{
				endpointSuffix = "core.windows.net";
			}
			return ConstructUris(scheme, accountName, "file", endpointSuffix, sasToken);
		}

		private static (Uri Primary, Uri Secondary) ConstructQueueEndpoint(IDictionary<string, string> settings)
		{
			return ConstructQueueEndpoint(settings["DefaultEndpointsProtocol"], settings["AccountName"], settings.ContainsKey("EndpointSuffix") ? settings["EndpointSuffix"] : null, settings.ContainsKey("SharedAccessSignature") ? settings["SharedAccessSignature"] : null);
		}

		internal static (Uri Primary, Uri Secondary) ConstructQueueEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken)
		{
			if (string.IsNullOrEmpty(scheme))
			{
				throw Azure.Storage.Errors.ArgumentNull("scheme");
			}
			if (string.IsNullOrEmpty(accountName))
			{
				throw Azure.Storage.Errors.ArgumentNull("accountName");
			}
			if (string.IsNullOrEmpty(endpointSuffix))
			{
				endpointSuffix = "core.windows.net";
			}
			return ConstructUris(scheme, accountName, "queue", endpointSuffix, sasToken);
		}

		private static (Uri Primary, Uri Secondary) ConstructTableEndpoint(IDictionary<string, string> settings)
		{
			return ConstructTableEndpoint(settings["DefaultEndpointsProtocol"], settings["AccountName"], settings.ContainsKey("EndpointSuffix") ? settings["EndpointSuffix"] : null, settings.ContainsKey("SharedAccessSignature") ? settings["SharedAccessSignature"] : null);
		}

		internal static (Uri Primary, Uri Secondary) ConstructTableEndpoint(string scheme, string accountName, string endpointSuffix, string sasToken)
		{
			if (string.IsNullOrEmpty(scheme))
			{
				throw Azure.Storage.Errors.ArgumentNull("scheme");
			}
			if (string.IsNullOrEmpty(accountName))
			{
				throw Azure.Storage.Errors.ArgumentNull("accountName");
			}
			if (string.IsNullOrEmpty(endpointSuffix))
			{
				endpointSuffix = "core.windows.net";
			}
			return ConstructUris(scheme, accountName, "table", endpointSuffix, sasToken);
		}

		private static (Uri Primary, Uri Secondary) ConstructUris(string scheme, string accountName, string hostNamePrefix, string endpointSuffix, string sasToken)
		{
			UriBuilder uriBuilder = new UriBuilder
			{
				Scheme = scheme,
				Host = string.Format(CultureInfo.InvariantCulture, "{0}.{1}.{2}", accountName, hostNamePrefix, endpointSuffix),
				Query = sasToken
			};
			UriBuilder uriBuilder2 = new UriBuilder();
			uriBuilder2.Scheme = scheme;
			uriBuilder2.Host = string.Format(CultureInfo.InvariantCulture, "{0}{1}.{2}.{3}", accountName, "-secondary", hostNamePrefix, endpointSuffix);
			uriBuilder2.Query = sasToken;
			UriBuilder uriBuilder3 = uriBuilder2;
			return (Primary: uriBuilder.Uri, Secondary: uriBuilder3.Uri);
		}
	}
	internal abstract class StorageCollectionEnumerator<T>
	{
		private class StoragePageable : Pageable<T>
		{
			private StorageCollectionEnumerator<T> _enumerator;

			protected StoragePageable()
			{
			}

			public StoragePageable(StorageCollectionEnumerator<T> enumerator, CancellationToken cancellationToken)
				: base(cancellationToken)
			{
				_enumerator = enumerator;
			}

			protected virtual bool CanContinue(string continuationToken)
			{
				return !string.IsNullOrEmpty(continuationToken);
			}

			public override IEnumerable<Page<T>> AsPages(string continuationToken = null, int? pageHintSize = null)
			{
				do
				{
					Page<T> page = _enumerator.GetNextPageAsync(continuationToken, pageHintSize, async: false, CancellationToken).EnsureCompleted();
					continuationToken = page.ContinuationToken;
					yield return page;
				}
				while (CanContinue(continuationToken));
			}

			public override IEnumerator<T> GetEnumerator()
			{
				string continuationToken = null;
				do
				{
					Page<T> page = _enumerator.GetNextPageAsync(continuationToken, null, async: false, CancellationToken).EnsureCompleted();
					continuationToken = page.ContinuationToken;
					foreach (T value in page.Values)
					{
						yield return value;
					}
				}
				while (CanContinue(continuationToken));
			}
		}

		private class StorageAsyncPageable : AsyncPageable<T>
		{
			private StorageCollectionEnumerator<T> _enumerator;

			protected StorageAsyncPageable()
			{
			}

			public StorageAsyncPageable(StorageCollectionEnumerator<T> enumerator, CancellationToken cancellationToken)
				: base(cancellationToken)
			{
				_enumerator = enumerator;
			}

			protected virtual bool CanContinue(string continuationToken)
			{
				return !string.IsNullOrEmpty(continuationToken);
			}

			public override async IAsyncEnumerable<Page<T>> AsPages(string continuationToken = null, int? pageHintSize = null)
			{
				do
				{
					Page<T> page = await _enumerator.GetNextPageAsync(continuationToken, pageHintSize, async: true, CancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					continuationToken = page.ContinuationToken;
					yield return page;
				}
				while (CanContinue(continuationToken));
			}

			public override async IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default(CancellationToken))
			{
				if (cancellationToken == default(CancellationToken))
				{
					cancellationToken = CancellationToken;
				}
				string continuationToken = null;
				do
				{
					Page<T> page = await _enumerator.GetNextPageAsync(continuationToken, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					continuationToken = page.ContinuationToken;
					foreach (T value in page.Values)
					{
						yield return value;
					}
				}
				while (CanContinue(continuationToken));
			}
		}

		public abstract ValueTask<Page<T>> GetNextPageAsync(string continuationToken, int? pageSizeHint, bool async, CancellationToken cancellationToken);

		public Pageable<T> ToSyncCollection(CancellationToken cancellationToken)
		{
			return new StoragePageable(this, cancellationToken);
		}

		public AsyncPageable<T> ToAsyncCollection(CancellationToken cancellationToken)
		{
			return new StorageAsyncPageable(this, cancellationToken);
		}
	}
	internal static class StorageCrc64Calculator
	{
		private static ulong poly = 11127430586519243189uL;

		private static ulong[] m_u1 = new ulong[256]
		{
			0uL, 9182541432847960441uL, 18365082865695920882uL, 9345832722727082891uL, 14511413233979602575uL, 13117883710352670710uL, 4016934769805403261uL, 5247243509741595908uL, 11969702169228410485uL, 15668617373955487500uL,
			6395407394255400071uL, 2859783479402063358uL, 8033869539610806522uL, 1157698950281609603uL, 10494487019483191816uL, 17207436825116529521uL, 8710242310496874369uL, 544390144406054648uL, 9672921298356239731uL, 17965965451118834698uL,
			12790814788510800142uL, 14910550302343712887uL, 5719566958804126716uL, 3472568952111055493uL, 16067739079221613044uL, 11642617884288424077uL, 2315397900563219206uL, 6867711082173303423uL, 1702069273413494651uL, 7561550595985681922uL,
			16808303987311785353uL, 10821560171884821744uL, 17420484620993748738uL, 10281452688370128507uL, 1088780288812109296uL, 8102801665828209801uL, 4081135393624123789uL, 5174050811428790516uL, 14303144984052136831uL, 13335169890544513542uL,
			6331237281917575543uL, 2932936320451717134uL, 12178000930637296517uL, 15451291336501017340uL, 11439133917608253432uL, 16271795144152063617uL, 6945137904222110986uL, 2237417001980464243uL, 9881180485936394371uL, 17748670208579942906uL,
			8646032624330580593uL, 617573780371024648uL, 4630795801126438412uL, 4552317850264964981uL, 13735422164346606846uL, 13974939467834563975uL, 3404138546826989302uL, 5788002041349785487uL, 15123101191971363844uL, 12578268576127440253uL,
			16599996146375981177uL, 11038877129812111616uL, 1766230306223614603uL, 7488388675408585714uL, 15517955973396180335uL, 12120359180407907350uL, 2992425542307102621uL, 6262760941951170276uL, 2177560577624218592uL, 7014021097877803673uL,
			16205603331656419602uL, 11496333698567045227uL, 8162270787248247578uL, 1020283848406030947uL, 10348101622857581032uL, 17362827168352323729uL, 13268962925398943125uL, 14360329612356938988uL, 5114174836390786919uL, 4149999036593995294uL,
			12662474563835151086uL, 15047886789205674903uL, 5865872640903434268uL, 3317240731349735781uL, 7410885347125621857uL, 1852721336781405464uL, 10954198386508228243uL, 16675652587215613930uL, 695464411657452699uL, 8559154840590169570uL,
			17832891829959241321uL, 9805981716846356240uL, 13890275808444221972uL, 13811093689104106349uL, 4474834003960928486uL, 4717306313667482015uL, 2781857646629810797uL, 6482320345254034196uL, 15584360551092445343uL, 12044936105578752486uL,
			17292065248661161186uL, 10418850627624291739uL, 1235147560742049296uL, 7947394159970475881uL, 9261591602252876824uL, 18440332504439424353uL, 9104635700529929962uL, 86933051457181587uL, 5324711670898473623uL, 3930478940865573870uL,
			13202527286532548709uL, 14435791994760012060uL, 6808277093653978604uL, 2383859105125700757uL, 11576004082699570974uL, 16125361296017327719uL, 10887802304290696035uL, 16751084157523239450uL, 7621461738281908625uL, 1633170428957798632uL,
			17899336015843713945uL, 9730527881461623520uL, 484936124168630635uL, 8778683483337193490uL, 3532460612447229206uL, 5650648632384052335uL, 14976777350817171428uL, 12733579874785513117uL, 11127430586519243189uL, 16501861805283229900uL,
			7255706616989801287uL, 2008467384902701630uL, 5984851084614205242uL, 3197703697127700035uL, 12525521883902340552uL, 15185406778534061233uL, 4355121155248437184uL, 4836460649178119865uL, 14028042195755607346uL, 13673894688497708107uL,
			17659347437411533135uL, 9978967587602237494uL, 851034636706747325uL, 8404151993655892676uL, 16324541574496495156uL, 11376828069156237133uL, 2040567696812061894uL, 7151572492026068415uL, 3165618640958787771uL, 6089000465318648258uL,
			15362738141892903497uL, 12276135533837191984uL, 4940590242968197185uL, 4323016312165290296uL, 13424492949564705459uL, 14205358170246726602uL, 10228349672781573838uL, 17482011809167009719uL, 8299998073187990588uL, 883115153111807301uL,
			7758977986698090167uL, 1496212771153551310uL, 10768261529147802693uL, 16870057623371222332uL, 11731745281806868536uL, 15970178678932056385uL, 6634481462699471562uL, 2557087418195393459uL, 14821770694251243714uL, 12889145053243924923uL,
			3705442673562810928uL, 5477099193254114121uL, 347732205828726349uL, 8916445914979620660uL, 18018485433612717247uL, 9610811077088298438uL, 1390928823314905398uL, 7792180275546222671uL, 17118309681180339140uL, 10592047673346876093uL,
			15721915763462295481uL, 11907948279947413184uL, 2662355835449236811uL, 6601263643266274354uL, 13065363431662389059uL, 14573523159059271226uL, 5443901152145348017uL, 3810730869140954312uL, 8949668007921856972uL, 242468062084315317uL,
			9434612627334964030uL, 18266752897469557319uL, 5563715293259621594uL, 3627853308494900643uL, 12964640690508068392uL, 14737282991092629329uL, 9535436420502803029uL, 18102883011221642028uL, 8829673718705766567uL, 425517318353373662uL,
			16945538107983338159uL, 10683758673333097430uL, 1582809320479393885uL, 7681369070946451748uL, 2470295121484098592uL, 6712246474782352729uL, 15894788319940951762uL, 11816127157005858731uL, 3879488993349045083uL, 5384130764573901346uL,
			14630883743593699753uL, 12998980579021361360uL, 18209271401059859924uL, 9501085674329060525uL, 173866102914363174uL, 9009242716806358623uL, 10649423341796947246uL, 17051941912459279447uL, 7860957881731147740uL, 1331177917724618405uL,
			6532681715831194529uL, 2721950576072674008uL, 11850482417207202131uL, 15788404444129941546uL, 13616554187307957208uL, 14094374762992939681uL, 4767718210251401514uL, 4414836859352883283uL, 8472769053991669079uL, 791404660239696942uL,
			10036468583241064357uL, 17592823520898193116uL, 1939744496674522541uL, 7315441871796849876uL, 16444536456726632287uL, 11193778306393792038uL, 15242923476563817250uL, 12459013669784255067uL, 3266340857915597264uL, 5925241208603601065uL,
			14129842449788916825uL, 13509030938278026528uL, 4236384526995834539uL, 5018234291620532178uL, 969872248337261270uL, 8222268228363316143uL, 17557366966674386980uL, 10144002964842903901uL, 7064921224894458412uL, 2118192263497917269uL,
			11301297264768104670uL, 16409064479275168167uL, 12351475057656208547uL, 15278375800261809626uL, 6175737528828104273uL, 3087868764414052136uL
		};

		private static ulong[] m_u32 = new ulong[2048]
		{
			0uL, 13314104777806623281uL, 4995408779574703881uL, 18272917952776127800uL, 9990817559149407762uL, 3630939668061314083uL, 14985097136918436123uL, 8588630238580288298uL, 2419595280346009423uL, 11047632078064778622uL,
			7261879336122628166uL, 15853324927293196919uL, 12336101225143050589uL, 1438778539722085228uL, 17177260477160576596uL, 6243344386453529701uL, 4839190560692018846uL, 18153290931779284143uL, 466971369176983959uL, 13744476153000549286uL,
			14523758672245256332uL, 8163885170551931581uL, 10150410278941460357uL, 3753947787305760180uL, 7114670618595086801uL, 15742703009609180128uL, 2877557079444170456uL, 11468998281230587113uL, 16724927115800166339uL, 5827608819780259314uL,
			12486688772907059402uL, 1552777088887782139uL, 9678381121384037692uL, 4509712478557409037uL, 14052292465040017973uL, 8919086911451396100uL, 933942738353967918uL, 12984779574341165343uL, 5306724880489522215uL, 17393031402499380758uL,
			12088969047850185331uL, 2234232424948285506uL, 16327770341103863162uL, 6508501205480191819uL, 3270219084831693921uL, 10783611126490213968uL, 7507895574611520360uL, 15056752904239896921uL, 14229341237190173602uL, 9060668187673563539uL,
			9235624609781601451uL, 4102414666794133146uL, 5755114158888340912uL, 17805955384257740673uL, 760268329942694585uL, 12846579258659178632uL, 16495813941225975021uL, 6641072911623610076uL, 11655217639560518628uL, 1835944114540095957uL,
			7947275282931516159uL, 15460671713970139342uL, 3105554177775564278uL, 10654415914121054151uL, 4069053834368248083uL, 9276602857674201890uL, 9019424957114818074uL, 14262439286667324459uL, 12888929698626668289uL, 728350057390060848uL,
			17838173822902792200uL, 5713061687187489337uL, 1867885476707935836uL, 11612879294349907053uL, 6683146274174357845uL, 16463609796103103332uL, 10613449760979044430uL, 3138938099822951039uL, 15427587958021472071uL, 7988539404333878646uL,
			8885721681034573709uL, 14093275110923552188uL, 4468464849896571012uL, 9711483568963269301uL, 17435386240585734559uL, 5274802209818028974uL, 13017002410960383638uL, 891885868678962343uL, 6540438169663387842uL, 16285436393877900019uL,
			2276301389390663627uL, 12056769300835696122uL, 15015791149223040720uL, 7541275098533749985uL, 10750531768509407705uL, 3311478808266183656uL, 13702389596435043375uL, 499223892686693918uL, 18121336375347127078uL, 4881577284539027735uL,
			3787009552894999101uL, 10109203332270622732uL, 8204829333588266292uL, 14490431924675641093uL, 11510228317776681824uL, 2844507408351766865uL, 15776050647768657001uL, 7073740749340991064uL, 1520536659885389170uL, 12528798419337332547uL,
			5785236389704991355uL, 16756902562832658506uL, 18230826998244854449uL, 5027665701050185856uL, 13282145823247220152uL, 42391121974267785uL, 8621696402279998627uL, 14943885792137123474uL, 3671888229080191914uL, 9957486413597237659uL,
			15894550565863032318uL, 7228834063006480335uL, 11080975318107484919uL, 2378669809208672454uL, 6211108355551128556uL, 17219365725490862557uL, 1396410507639856357uL, 12368072274182516436uL, 8138107668736496166uL, 14426557995101282327uL,
			3864963828248814895uL, 10188883840789878558uL, 18038849914229636148uL, 4797439356862238213uL, 13764583471170505533uL, 558636003161176332uL, 5864949882499341673uL, 16834823851763904344uL, 1456700114780121696uL, 12462039372163962961uL,
			15835500142712222587uL, 7135897241754845514uL, 11426123374374978674uL, 2761987960811697731uL, 3735770953415871672uL, 10024216873222930057uL, 8542024690686344113uL, 14865940313687918976uL, 13366292548348715690uL, 124886380503896219uL,
			18171423683030832547uL, 4965480621596141458uL, 1318498013465740279uL, 12288367576166281670uL, 6277876199645902078uL, 17283211067504936655uL, 11018827623122529765uL, 2319229111673053140uL, 15977078808667757292uL, 7312947801685403869uL,
			17771443362069147418uL, 5649178961375419691uL, 12966875177746962451uL, 808021769923242530uL, 8936929699793142024uL, 14178292563042218809uL, 4131238913151202817uL, 9336006171948696624uL, 15507292654829740117uL, 8066451897031594596uL,
			10549604419636057948uL, 3072170256667698541uL, 6742586972917943879uL, 16525757492564458614uL, 1783771737357924686uL, 11530351050605661055uL, 13080876339326775684uL, 958607532054332341uL, 17355705732737566349uL, 5196847935403734204uL,
			4552602778781327254uL, 9793970031557160359uL, 8826309569889003679uL, 14031081235248569006uL, 10672610478370209483uL, 3231765313995443450uL, 15082550197067499970uL, 7605111644578544627uL, 2214144898184761561uL, 11997319807368520424uL,
			6622957616532367312uL, 16369541336340076001uL, 5226553991581547317uL, 17315567511325935876uL, 998447785373387836uL, 13050870116949589517uL, 13992385572602893607uL, 8857387814886926102uL, 9763154569078055470uL, 4591563424455954463uL,
			7574019105789998202uL, 15121224969131705931uL, 3192792573832364915uL, 10703402850965664066uL, 16409658667176532584uL, 6593237266557642841uL, 12027302939855777121uL, 2174292550383558480uL, 837723427998967211uL, 12926741354437416858uL,
			5689014816703533730uL, 17741441537682890899uL, 9297314907277183929uL, 4162312760174967176uL, 14147481498681982128uL, 8975885947348913793uL, 3041073319770778340uL, 10588283589808642261uL, 8027474758883876333uL, 15538089425409847260uL,
			11570472779409982710uL, 1754046989415331527uL, 16555745023176864767uL, 6702730226991579598uL, 14904935044227204617uL, 8511175143342584888uL, 10055331402100371712uL, 3697039006890672945uL, 4935510683106863131uL, 18211227652461976106uL,
			84782243948535570uL, 13395964519670263075uL, 17243392804559997254uL, 6307825247276890999uL, 12258683510079471183uL, 1358579060414286974uL, 7343776458160383828uL, 15938069784625157477uL, 2357937968601911389uL, 10987700999469326956uL,
			10227874173201914007uL, 3834118679032310438uL, 14457668126012960670uL, 8099380120177073583uL, 528670462654445189uL, 13804383042619098292uL, 4757339618417344908uL, 18068517487440704445uL, 12422216711102257112uL, 1486653560527873513uL,
			16805135387700830417uL, 5905035327424140000uL, 2792821015279712714uL, 11387109952339348475uL, 7174610496783699651uL, 15804369120959036658uL, 0uL, 17795750414920992584uL, 15652066155665235451uL, 3440885951733652147uL,
			9707430005003888797uL, 8088619545869807573uL, 6881771903467304294uL, 12211444018068779566uL, 4158605880245666385uL, 14934326367322670361uL, 16177239091739615146uL, 1618531183280494818uL, 13763543806934608588uL, 5329687576586300804uL,
			7365251356733110071uL, 10430782732424065151uL, 8317211760491332770uL, 9627456514162279402uL, 12275655047854856537uL, 6677949350095543825uL, 17715775754843728959uL, 228593521434585975uL, 3237062366560989636uL, 15716278079943308940uL,
			5393898400245434099uL, 13559721322313744827uL, 10659375153172601608uL, 7285277797140536384uL, 14730502713466220142uL, 4222818010717792550uL, 1538556591887086485uL, 16405832406980080861uL, 16634423520982665540uL, 1165988892599602700uL,
			4606644975495812287uL, 14490652333704500215uL, 6948737735228826073uL, 10851938492356421265uL, 13355898700191087650uL, 5741697744827710314uL, 16100102641861249813uL, 2997210129391651933uL, 457187042869171950uL, 17343209908929073574uL,
			6474124733121979272uL, 12623451852133770432uL, 9290918443066424947uL, 8509777644550175035uL, 10787796800490868198uL, 7152491088056076974uL, 5513174730750660637uL, 13435802853112141653uL, 1369740940761310587uL, 16570282996205314611uL,
			14570555594281072768uL, 4378122991072214984uL, 12394928769305825207uL, 6554029092169976063uL, 8445636021435585100uL, 9494671589766665476uL, 3077113183774172970uL, 15871580726121439330uL, 17546962163284900561uL, 393046449407966617uL,
			17972623996477342179uL, 1124953203026282155uL, 2331977785199205400uL, 15468718787813366608uL, 9213289950991624574uL, 9884023296933522998uL, 12027814264650544261uL, 5772583309854864333uL, 13897475470457652146uL, 3903201379966321914uL,
			1867462721629478473uL, 17230134200194177281uL, 5074000312779205423uL, 12726412586066422887uL, 11483395489655420628uL, 7613902433661202844uL, 9945982394365904193uL, 9002712138369221129uL, 5994420258783303866uL, 11945588830717829106uL,
			914374085738343900uL, 18034584260997933716uL, 15386492461536161831uL, 2553815763781089135uL, 12948249466243958544uL, 4991775084973424728uL, 7675861599844555499uL, 11272817470906015139uL, 3820974847495073677uL, 14119313517723330757uL,
			17019555289100350070uL, 1929422917466207550uL, 2284114744097015975uL, 16809117116094664687uL, 14304982176112153948uL, 3491052535749661204uL, 11026349461501321274uL, 8066583400317413234uL, 4625822816565738945uL, 13169947943851817609uL,
			2739481881522621174uL, 15056568154612698558uL, 18389278632294045453uL, 703937903355564101uL, 11579634704575357547uL, 6216116333187147043uL, 8756245982144429968uL, 10336706602061052120uL, 7844815651933457413uL, 11108505557513489229uL,
			13108058184339952126uL, 4836331428643624630uL, 16891272042871170200uL, 2062348302526112720uL, 3701560116026653027uL, 14243093311092293163uL, 6154226367548345940uL, 11790143385404147996uL, 10114939059804099503uL, 8838402009405625575uL,
			15267075666205894345uL, 2677593222696804737uL, 786092898815933234uL, 18167511984529030266uL, 14271356128258724013uL, 3528920495235061733uL, 2249906406052564310uL, 16847527791942683166uL, 4663955570398410800uL, 13136584867098492792uL,
			11065060459665827275uL, 8032672874147504771uL, 18426579901983249148uL, 670869757795243444uL, 2778461448337575687uL, 15021799713104398415uL, 8723442665257564769uL, 10374270808524176681uL, 11545166619709728666uL, 6255393677550461138uL,
			13070192475467748367uL, 4869959624064586567uL, 7806402759932643828uL, 11142711713798442684uL, 3734925443258956946uL, 14204962704692935642uL, 16925180352754065769uL, 2023635122467890721uL, 10148000625558410846uL, 8801094125517115670uL,
			6189001354670689189uL, 11751170467248901357uL, 748522112412581571uL, 18200308687082371467uL, 15227804867322405688uL, 2712067956087923824uL, 2366451139905821161uL, 15429444960977936033uL, 18005424276738442258uL, 1087383245551616858uL,
			11988840517566607732uL, 5807354719269451324uL, 9175985095055060111uL, 9917086241372335047uL, 1828748171476687800uL, 17264039490715065584uL, 13859348433176118851uL, 3936567527537377547uL, 11517600825601618725uL, 7575485972542567533uL,
			5107631527562178270uL, 12688548247288785302uL, 6033696233052052811uL, 11911117726490188291uL, 9983550169946849456uL, 8969909641821112312uL, 15351723199689110998uL, 2592791761478218398uL, 881308959540029485uL, 18071886900781707109uL,
			7641949694990147354uL, 11311525441118574674uL, 12914889967198388961uL, 5029908667734787497uL, 17057965136019683207uL, 1895211001713995983uL, 3858845834932415100uL, 14085688848554405172uL, 4568229488194031950uL, 14524856687109953030uL,
			16596560370769988789uL, 1199618927273069565uL, 13389804964662786515uL, 5702982212268129947uL, 6982105071499322408uL, 10813810275099861856uL, 491959469050286879uL, 17304235153534587991uL, 16133166800634826468uL, 2959904050395908524uL,
			9251645633131477890uL, 8544249991080197322uL, 6436555990116558457uL, 12656250909470171441uL, 5478963763045242348uL, 13474211760440136356uL, 10754173414376441879uL, 7190360783715028831uL, 14609264512674905457uL, 4344210146760948281uL,
			1407875806711128202uL, 16536922205515311042uL, 8484612924229834685uL, 9459901414098079989uL, 12432232666374294086uL, 6520962717142945038uL, 17512491964288859936uL, 432321509989660776uL, 3044311944644715227uL, 15909147253007623571uL,
			15689631303866914826uL, 3408081684652252994uL, 39278638289454577uL, 17761281044853637817uL, 6848704699511582871uL, 12248744337429493727uL, 9672662857287249260uL, 8127597827348556324uL, 16143876930955041371uL, 1656663029868305683uL,
			4124696605052225440uL, 14973036106055254248uL, 7403120232053306054uL, 10397155777191818638uL, 13801955733624614717uL, 5295477978975447157uL, 12308452735096691880uL, 6640377587728112608uL, 8351687676139176275uL, 9588184524566087195uL,
			3199755467226494005uL, 15749338669599060861uL, 17676804018811251150uL, 263367317710270086uL, 10621245557231542009uL, 7318642105459087793uL, 5355186445393609474uL, 13593628415714133066uL, 1572185797631866468uL, 16367965679059644716uL,
			14764710094823615391uL, 4184403902100516055uL, 0uL, 8192260192693531485uL, 16384520385387062970uL, 10579310971610093031uL, 17445294202075176479uL, 9487645808758975810uL, 1259777398387980453uL, 6974776076101291000uL,
			15054798087340502869uL, 11627628094419573768uL, 3714591610324732399uL, 4772725293978712754uL, 2519554796775960906uL, 6000906318572175895uL, 13949552152202582000uL, 12692835880654611629uL, 10737672651763207617uL, 16479552155529248412uL,
			8530488506137553787uL, 563692279294040102uL, 7429183220649464798uL, 1632840715178909827uL, 9545450587957425508uL, 17710547929865700921uL, 5039109593551921812uL, 3773526413697536457uL, 12001812637144351790uL, 15510327009725822835uL,
			13255397586018483339uL, 14286650443619733462uL, 6094816860633029169uL, 2676794701239413100uL, 2224468801865124073uL, 8029398802249956276uL, 18284443984023023187uL, 10092467602768682254uL, 17060977012275107574uL, 11345698921169118635uL,
			1127384558588080204uL, 9085316763342930705uL, 14858366441298929596uL, 13799949221084206305uL, 3265681430357819654uL, 6693130561793520219uL, 4335179923219708323uL, 5591612658206395134uL, 16089150697174343449uL, 12608078313892359236uL,
			10078219187103843624uL, 18045298950508639861uL, 7547052827395072914uL, 1804894185114800335uL, 8775022333477165879uL, 610208528129632362uL, 11143777030265568653uL, 16939840397221351120uL, 6570863924763224701uL, 3062628965574433056uL,
			13281651414986427591uL, 14546950783402164122uL, 12189633721266058338uL, 15607935294051813183uL, 5353589402478826200uL, 4322052733438386565uL, 4448937603730248146uL, 5480049586572239503uL, 16058797604499912552uL, 12640634845224911925uL,
			14963191654740611021uL, 13697468149613821072uL, 3226387075058313591uL, 6734760297733626410uL, 17100359328236387975uL, 11304157148038237658uL, 1022647305271334973uL, 9187885797085768544uL, 2254769117176160408uL, 7996789495701459909uL,
			18170633526685861410uL, 10203977899723732351uL, 12159205861289221139uL, 15640698533058703182uL, 5467281111780014761uL, 4210705165571557876uL, 6531362860715639308uL, 3104333467743203665uL, 13386261123587040438uL, 14444535682067388395uL,
			8670359846439416646uL, 712570853174722587uL, 11183225316412790268uL, 16898083119299733153uL, 9964615437390687577uL, 18156734480110951940uL, 7577568646423104483uL, 1772218907306621118uL, 2549929897105824059uL, 5968371794895579750uL,
			13835807649431584641uL, 12804412130028834012uL, 15094105654790145828uL, 11586011570629080185uL, 3609788370229600670uL, 4875228338795123395uL, 17550044666954331758uL, 9385089986579072307uL, 1220417056259264724uL, 7016339823065260937uL,
			113832465580320881uL, 8080771903981116204uL, 16354233247329554123uL, 10611933455411592598uL, 13141727849526449402uL, 14398019984296241063uL, 6125257931148866112uL, 2644044672772047133uL, 4934513061080763109uL, 3875954691161242040uL,
			12041335708311022687uL, 15468644514675613442uL, 7389748111218375599uL, 1674611169817184498uL, 9650135081627196693uL, 17608207611453156936uL, 10707178804957652400uL, 16512249405559379693uL, 8644105466876773130uL, 452269960717267031uL,
			8897875207460496292uL, 777815854587973881uL, 10960099173144479006uL, 16837508876986644035uL, 9899396859023031739uL, 17929245473684410086uL, 7638169311773399809uL, 1995371405161080924uL, 12364343895119170801uL, 15719313666694922156uL,
			5257806571491912267uL, 4127472116736940310uL, 6452774150116627182uL, 2899221788499403187uL, 13469520595467252820uL, 14654036576950028041uL, 17183618765321268837uL, 11513658076643712312uL, 944058559875877087uL, 8982774151563688834uL,
			2045294610542669946uL, 7913556412137505575uL, 18375771594171537088uL, 10282592998631728541uL, 4509538234352320816uL, 5703202118082425453uL, 15993578991402919818uL, 12413145872452981975uL, 14740065545194020655uL, 13636893872504286322uL,
			3453902469802228117uL, 6800005264351546056uL, 7324397590398380877uL, 1447271697995405328uL, 9711166754478640631uL, 17830946693959024298uL, 10934562223560029522uL, 16577643941610997263uL, 8421410331143115752uL, 391282303089057973uL,
			13062725721431278616uL, 14193339314701023045uL, 6208666935486407330uL, 2853413627349914111uL, 5139237677448190471uL, 3955000834479647066uL, 11832010700513754301uL, 15385279525569695712uL, 17340719692878833292uL, 9301724962676790737uL,
			1425141706349445174uL, 7095385931588285291uL, 197241435189590163uL, 8290140892214627278uL, 16275231084505128489uL, 10407252819471035764uL, 2327234795026827737uL, 5907384102538115716uL, 14063191101689605987uL, 12869806631352179774uL,
			15155137292846208966uL, 11808750686857700507uL, 3544437814613242236uL, 4647888900695114273uL, 5099859794211648118uL, 3996546971616280875uL, 11936743589791159500uL, 15282706059068598161uL, 13032420973529754729uL, 14225944257377951540uL,
			6322481756728658643uL, 2741907763018938766uL, 10820800179681172771uL, 16689202581157916286uL, 8451767855871261593uL, 358730135091235012uL, 7219576740459201340uL, 1549757201687277665uL, 9750456677590246790uL, 17789312594549937883uL,
			15259804211971227575uL, 11706392725180894442uL, 3504985165131258125uL, 4689641746563050064uL, 2440834112518529448uL, 5795944209433268981uL, 14032679646130521874uL, 12902486341348291663uL, 227664931160641762uL, 8257373220483031999uL,
			16161543807962232408uL, 10518604751377171717uL, 17380225120797953789uL, 9260024893098540448uL, 1320527565124790343uL, 7197796669017938714uL, 6348019252612840095uL, 3001773246774643138uL, 13508885301467044901uL, 14612477262577168248uL,
			12250515862297732224uL, 15830806319446185949uL, 5288089345544094266uL, 4094845200210145639uL, 9869026122161526218uL, 17961784429549397655uL, 7751909382322484080uL, 1883790792284913709uL, 8858563276676680661uL, 819427946324326536uL,
			11064906845327338863uL, 16735010195537927730uL, 14779496222436751198uL, 13595119054397621251uL, 3349222339634368996uL, 6902350014986035897uL, 4540036513212049729uL, 5670509231386434076uL, 15879957667295973371uL, 12524563758942059686uL,
			2158968710939334667uL, 7802191304085662550uL, 18345326091064622769uL, 10315338663227985388uL, 17288210933753546260uL, 11411225366421157193uL, 904539921434534062uL, 9024461010619192307uL, 0uL, 13824762537890386270uL,
			5435843389918327255uL, 17632879567996264585uL, 10871686779836654510uL, 2955647571599356656uL, 15974271476589515385uL, 7091884143152218919uL, 1830393695483286583uL, 12014954090240984425uL, 5911295143198713312uL, 17136847308542735550uL,
			10356344933674923929uL, 3486433246119044807uL, 14183768286304437838uL, 8866939313174419216uL, 3660787390966573166uL, 10166549554642499888uL, 8764643140330461625uL, 14301506311825885415uL, 11822590286397426624uL, 2002179278080727710uL,
			17257153827578018327uL, 5811567326429637449uL, 3146722988342115417uL, 10696061943161711879uL, 6972866492238089614uL, 16077839028455922896uL, 13651706126026579959uL, 193643978992848553uL, 17733878626348838432uL, 5314257382929317758uL,
			7321574781933146332uL, 15726597597130965378uL, 3383482852370407691uL, 10461835487050756181uL, 17529286280660923250uL, 5521383145158058540uL, 13270830730307469989uL, 571986241638437883uL, 9006539716542072043uL, 14062142868687263157uL,
			4004358556161455420uL, 9820444972906259554uL, 16871141307392288581uL, 6195046438697498139uL, 11623134652859274898uL, 2204168053248247756uL, 6293445976684230834uL, 16757229616687114732uL, 2033710611994724709uL, 11809103765812205627uL,
			13945732984476179228uL, 9102441198461848130uL, 10008912073189894859uL, 3836399239677590421uL, 5634023594246450309uL, 17432166230595157467uL, 387287957985697106uL, 13440007996446051340uL, 15631975740571111211uL, 7436713287088496245uL,
			10628514765858635516uL, 3196286443948011426uL, 14643149563866292664uL, 8425538611776008422uL, 9248445511903875183uL, 4576352633966788913uL, 6766965704740815382uL, 16299225501472805704uL, 1623241691541500865uL, 12204057899130610335uL,
			15154673959339816335uL, 7893503808290579665uL, 11042766290316117080uL, 2802546455471379718uL, 4940389601680725537uL, 18110282944942901119uL, 1143972483276875766uL, 12698841025324496552uL, 18013079433084144086uL, 5053104780943399048uL,
			12868101959430486017uL, 959199400746887519uL, 8008717112322910840uL, 15059968434811763494uL, 2615275316874435503uL, 11209529030916197105uL, 16185247739280711137uL, 6865422453713194175uL, 12390092877394996278uL, 1452727108004248936uL,
			8521497235978731087uL, 14526673814343495441uL, 4408336106496495512uL, 9436978683674173126uL, 12586891953368461668uL, 1258461165104291898uL, 16555902143576621235uL, 6492234632876446189uL, 4067421223989449418uL, 9775360158263870356uL,
			8294958500777960221uL, 14755745691174154819uL, 13243752613299266899uL, 581015605248734221uL, 18204882396923696260uL, 4863835225021711834uL, 2383740469573306109uL, 11443597294758680483uL, 7672798479355180842uL, 15393353934706501236uL,
			11268047188492900618uL, 2574732424221083732uL, 15496846687460780253uL, 7553864496710449539uL, 774575915971394212uL, 13070771000547322874uL, 4742332680126892915uL, 18305806724866841133uL, 9585621990451973437uL, 4241709297048067171uL,
			14873426574176992490uL, 8192728193547447732uL, 1430180882088029843uL, 12394585292042731469uL, 6392572887896022852uL, 16676151451390594586uL, 11724263699383504923uL, 2121089868990202181uL, 16851077223552016844uL, 6197059998517555346uL,
			3777128320185643957uL, 10065653443242894059uL, 9152705267933577826uL, 13897999300888269628uL, 13533931409481630764uL, 290836911066584434uL, 17347250220556826107uL, 5721467507677504677uL, 3246483383083001730uL, 10580854551979194076uL,
			7377509360494335573uL, 15688643228598781707uL, 10410432329431939189uL, 3432346839815153963uL, 15787007616581159330uL, 7263703119834470652uL, 479268930048826331uL, 13366077611745512069uL, 5605092910942759436uL, 17443046115025369938uL,
			9880779203361451074uL, 3946551979999280412uL, 14010815637502401941uL, 9055339030367177931uL, 2287944966553751532uL, 11536821034690928306uL, 6102262117026037307uL, 16966462053679984485uL, 14352838758776668359uL, 8715849042132865433uL,
			10106209561886798096uL, 3718588204966649934uL, 5904354664847958889uL, 17161836097907159607uL, 1918398801493775038uL, 11908900341414347744uL, 16017434224645821680uL, 7030743370106881454uL, 10747459338605847847uL, 3097853238592664697uL,
			5230550633748871006uL, 17820121808727057920uL, 286357727443617417uL, 13556455681311283159uL, 17717790348440053929uL, 5348394246754318839uL, 13730844907426388350uL, 96456829629106208uL, 7151085039179287303uL, 15917600957864729177uL,
			2905454216008497872uL, 10919350577390250894uL, 17042994471957462174uL, 6007675891775040960uL, 12099799939367095625uL, 1743020221055196183uL, 8816672212992991024uL, 14231498939321060974uL, 3545707749297729255uL, 10299607147170250681uL,
			7602666906942206371uL, 15445505097399656701uL, 2516922330208583796uL, 11328395630184845610uL, 18401115182443074061uL, 4649553799906886483uL, 12984469265752892378uL, 858347258439545476uL, 8134842447978898836uL, 14933839964366484682uL,
			4290587771152733251uL, 9534215589332256029uL, 16589917001555920442uL, 6476270640392427364uL, 12489826876976068589uL, 1337475729278723763uL, 6579657874365143501uL, 16471018100179290259uL, 1162031210497468442uL, 12680783544181324100uL,
			14812443075659151971uL, 8235731557181958973uL, 9727670450043423668uL, 4117641308438436586uL, 4767480939146612218uL, 18298709056423074980uL, 668362765688847405uL, 13158933363776466291uL, 15345596958710361684uL, 7723092170951589642uL,
			11500361534702509955uL, 2324439781390929629uL, 871847009512661375uL, 12952915978289197089uL, 5149464848442167464uL, 17919258555078410742uL, 11152761759188927185uL, 2674572973411783567uL, 15107728993420899078uL, 7958427003201086040uL,
			1549151831942788424uL, 12296196055775437846uL, 6778004993722336415uL, 16270137564314293697uL, 9484665360253785830uL, 4358112990276650936uL, 14469980012328888113uL, 8580727762175145583uL, 4527479374428473617uL, 9299857127719966799uL,
			8483418594096134342uL, 14582730410298354072uL, 12108819329727785663uL, 1715949860019731425uL, 16385456387094895464uL, 6683264387893414454uL, 2860361764176059686uL, 10982423063177940088uL, 7844695634684570865uL, 15206009786165099951uL,
			12785145775792045704uL, 1060204156351819734uL, 18014970923011477343uL, 5033164917675564545uL, 0uL, 4514320678209523063uL, 9028641356419046126uL, 4893789673109002137uL, 18057282712838092252uL, 14140823758577154219uL,
			9787579346218004274uL, 13362849919600632389uL, 13972861746229016787uL, 18397069268572108196uL, 13593480783646810685uL, 9368516906576572234uL, 4283426060203969807uL, 421051327351275640uL, 5061452472281323489uL, 8690806579843881622uL,
			13189355726925488845uL, 9920330031216291770uL, 14575386022283737123uL, 17645168074733352276uL, 5589631053278762769uL, 8301345151327754854uL, 3521382429991259647uL, 1042688955219132552uL, 8566852120407939614uL, 5207713818755897193uL,
			842102654702551280uL, 3821771963736821127uL, 10122904944562646978uL, 12888702714096296629uL, 17381613159687763244uL, 14957003768750717019uL, 6542925544232015601uL, 7235932893324139398uL, 2846566779642530847uL, 1812452399036776808uL,
			11553279960366146349uL, 11453612988773330522uL, 15931857048321489347uL, 16410911631088841908uL, 11179262106557525538uL, 11926271900343968597uL, 16602690302655509708uL, 15622578504149481915uL, 7042764859982519294uL, 6853066784115627657uL,
			2085377910438265104uL, 2474400976648244327uL, 17133704240815879228uL, 15231512072787212619uL, 10415427637511794386uL, 12550721812541744037uL, 1684205309405102560uL, 3024564567684025495uL, 7643543927473642254uL, 6103859676569933433uL,
			3183682650152946927uL, 1335493476406641048uL, 5864421166226265601uL, 8053717373499464566uL, 15471813553718360371uL, 16722141158135166020uL, 12392429592176419805uL, 10762714374571814570uL, 13085851088464031202uL, 10032998001731936405uL,
			14471865786648278796uL, 17757820860391864955uL, 5693133559285061694uL, 8188674910926378313uL, 3624904798073553616uL, 930038439454805927uL, 8391291880504120625uL, 5392441788758775878uL, 666522831895613407uL, 4006479938519712424uL,
			10298467312618266861uL, 12703977009692568986uL, 17557190854334446083uL, 14772293528376997748uL, 184727973224959791uL, 4338760439380296280uL, 9213349330128524737uL, 4718209847081162934uL, 17872557009507908339uL, 14316386129853806468uL,
			9602869102622335005uL, 13538427613172854122uL, 14085529719965038588uL, 18293564631183538827uL, 13706133568231255314uL, 9264996667719557221uL, 4170755820876530208uL, 524553836579000151uL, 4948801953296488654uL, 8794328946853156281uL,
			17246372210521275155uL, 15128007430839531108uL, 10528080418065605117uL, 12447201569125624970uL, 1571535074100104911uL, 3128067081479439288uL, 7530893412511241249uL, 6207382048146905430uL, 3368410618810205120uL, 1159933233554984631uL,
			6049129135368050990uL, 7878137543449187417uL, 15287087854947284508uL, 16897703533442448235uL, 12207719353139866866uL, 10938292072174657925uL, 6367365300305893854uL, 7420660858759451817uL, 2670986952813282096uL, 1997160369252109895uL,
			11728842332452531202uL, 11268887288928838005uL, 16107434746998929132uL, 16226201395274365851uL, 11075757463536820493uL, 12038939866828860538uL, 16499170062460812259uL, 15735231285777233556uL, 7146267370556380369uL, 6740396547736557990uL,
			2188900283088129599uL, 2361750464906216264uL, 6912381268945193135uL, 7010873824684787160uL, 2495446497949700673uL, 2019738966020448054uL, 11922695969517272435uL, 11228593644287029252uL, 15580697325944498077uL, 16618237647347641066uL,
			11386267118570123388uL, 11574870218298899723uL, 16377349821852756626uL, 15991752696440170469uL, 7249809596147107232uL, 6501625386507438295uL, 1860076878909611854uL, 2843535728253735481uL, 16782583761008241250uL, 15438798836809836309uL,
			10784883577517551756uL, 12325662529681473019uL, 1333045663791226814uL, 3231890506103886537uL, 8012959877039424848uL, 5878840392740603943uL, 2958342383554351793uL, 1704667453421543366uL, 6071425981216671839uL, 7702315889552409896uL,
			15246512461515941741uL, 17091275969342761498uL, 12599474406196739459uL, 10411272900183748852uL, 369455946449919582uL, 4289261401793139497uL, 8677520878760592560uL, 5101076439280552391uL, 18426698660257049474uL, 13915804472600733429uL,
			9436419694162325868uL, 13570175851578440731uL, 14179866567660168845uL, 18045667791066065914uL, 13368140519194000483uL, 9737690885737509140uL, 4490470872076145489uL, 69609850815340070uL, 4836151373635799487uL, 9059941384608629960uL,
			12838235447379754131uL, 10127616600346784228uL, 14944841753438971517uL, 17420109012535798538uL, 5238471324457879887uL, 8508671161142395960uL, 3890798436993455009uL, 817669608583651030uL, 8341511641753060416uL, 5576888013194725687uL,
			1049107673158000302uL, 3470370288134853593uL, 9897603906592977308uL, 13257837459261045995uL, 17588657893706312562uL, 14605562368996746757uL, 16895251939020006733uL, 15335293990851668026uL, 10897536158355849123uL, 12222142498866688724uL,
			1220375353323704465uL, 3335393082175741414uL, 7900309428648430207uL, 5982362693450024712uL, 3143070148200209822uL, 1529107418875334889uL, 6256134162958878576uL, 7526735859785697799uL, 15061786825022482498uL, 17266838269488702773uL,
			12414764096293810860uL, 10586850664359182299uL, 6736821237620410240uL, 7195601590404582135uL, 2319866467109969262uL, 2204447144542146585uL, 12098258270736101980uL, 11043868011013947179uL, 15756275086898374834uL, 16433527336370644421uL,
			11282762275832987475uL, 11687538397384208932uL, 16273829789963511229uL, 16104405274056517834uL, 7353312173293554319uL, 6388955079261997048uL, 1963599176398131297uL, 2730885278789328150uL, 12734730600611787708uL, 10240284774872792779uL,
			14841321717518903634uL, 17532761585592837157uL, 5341973905626564192uL, 8396000858464455447uL, 3994320738504219790uL, 705019163686736377uL, 8165951605860780911uL, 5761615774892279320uL, 873527637750763905uL, 3655078462634319094uL,
			10073166212371119795uL, 13073111830018782148uL, 17764235659219493981uL, 14420852062050576682uL, 554183707073401201uL, 4113701362679307270uL, 8862229056480431007uL, 4925496404946208488uL, 18241973027794281645uL, 14091366777305852378uL,
			9251709388290096707uL, 13745753620313043764uL, 14292534741112760738uL, 17942162941077202133uL, 13480793095473115980uL, 9634170850892037691uL, 4377800566176259198uL, 173112430909559049uL, 4723500929812432528uL, 9163463689340423143uL,
			0uL, 1627076877180555749uL, 3254153754361111498uL, 4304766511847567919uL, 6508307508722222996uL, 5532301601655232113uL, 8609533023695135838uL, 7057067394980558267uL, 13016615017444445992uL, 11687060557970792141uL,
			11064603203310464226uL, 10311506129017994503uL, 17219066047390271676uL, 17898114823170201945uL, 14114134789961116534uL, 15369645348968741523uL, 6742375288560323899uL, 5405783375000362206uL, 8122427758785605361uL, 7362295566600601364uL,
			559464125406104239uL, 1249489845609208650uL, 3092440436427811173uL, 4358930276052383872uL, 16804606958606221843uL, 18420141604947973110uL, 14131424163184419289uL, 15170497026562715708uL, 12927534132269761927uL, 11958000392873448546uL,
			11407266381551363661uL, 9861275257238108072uL, 13484750577120647798uL, 12517751835485555603uL, 10811566750000724412uL, 9268108286718044249uL, 16244855517571210722uL, 17862925160600374279uL, 14724591133201202728uL, 15766196656536268749uL,
			1118928250812208478uL, 1806984259669771451uL, 2498979691218417300uL, 3763497483303675761uL, 6184880872855622346uL, 4846319249023796015uL, 8717860552104767744uL, 7955756313454125285uL, 16623577522202187597uL, 17304596008253965992uL,
			14671562341988250759uL, 15929044947461498210uL, 13610133830783652057uL, 12282549082655523132uL, 10505203605321052947uL, 9754078578567881462uL, 5915057869070080101uL, 4936516965315660160uL, 9169208254935317423uL, 7614209966263953994uL,
			595784637983776753uL, 2220326517403094548uL, 2697011182507326523uL, 3745091278963191262uL, 4800780284202952583uL, 6056011051257099874uL, 8049867273830073421uL, 8728634058901706152uL, 1787343054361387027uL, 1033966189054898678uL,
			3883502080015090649uL, 2553665630772597308uL, 17742918502166505647uL, 16190171914609523018uL, 15785839923567102821uL, 14809550858366016128uL, 12423642936564150075uL, 13473974734000176862uL, 9313645190084349169uL, 10940438907922783508uL,
			2237856501624416956uL, 692146337361591129uL, 3613968519339542902uL, 2644717939285350547uL, 4997959382436834600uL, 6037313204657536205uL, 7526994966607351522uL, 9142812771083198215uL, 12369761745711244692uL, 13636531376349836401uL,
			9692638498047592030uL, 10382946208019535803uL, 17435721104209535488uL, 16675868703978009573uL, 15911512626908250570uL, 14575202704056586287uL, 17995461689412730353uL, 17233077589954915348uL, 15318337272343567931uL, 13979493588949749726uL,
			11812552860237691493uL, 13076790792723671936uL, 10288347611577407919uL, 10976121562080872522uL, 5555462180541969113uL, 6596786813619888956uL, 6931573031267504403uL, 8549359584747831542uL, 1678382892091667789uL, 134643537612252328uL,
			4207421707319105159uL, 3240139875195586402uL, 11830115738140160202uL, 12878476725792760111uL, 9873033930631320320uL, 11497858900539065061uL, 18338416509870634846uL, 16783699111456417467uL, 15228419932527907988uL, 14250162118322324849uL,
			1191569275967553506uL, 440724108813659655uL, 4440653034806189096uL, 3113350345032158669uL, 5394022365014653046uL, 6651784831295072659uL, 7490182557926382524uL, 8171483103540152921uL, 9601560568405905166uL, 10640618042396122859uL,
			12112022102514199748uL, 13727536961421360417uL, 16099734547660146842uL, 14553723636986370431uL, 17457268117803412304uL, 16487718990093089461uL, 3574686108722774054uL, 2814573703972032963uL, 2067932378109797356uL, 731355853937586697uL,
			7767004160030181298uL, 9033509387969091159uL, 5107331261545194616uL, 5797376768109147549uL, 15613455359580684853uL, 14860378081345967056uL, 17692164036055753215uL, 16362624974593339418uL, 9438425375779358113uL, 10693951331724809284uL,
			12670057618718205547uL, 13349126189482473358uL, 7785154244699704605uL, 8835751604174593272uL, 4693734945791798999uL, 6320792026914275122uL, 3915963146398206601uL, 2363477722699619180uL, 1977458617861056835uL, 1001437313856567462uL,
			4475713003248833912uL, 2920694927143142557uL, 1384292674723182258uL, 405736381580945239uL, 7227937038679085804uL, 8276001746820678409uL, 5289435878570701094uL, 6913957971629236419uL, 9995918764873669200uL, 11253416759734930357uL,
			12074626409315072410uL, 12755664682801375359uL, 15053989933214703044uL, 14302884692822117409uL, 18285625542166396430uL, 16958056182352343019uL, 7173486372772960323uL, 8438019562869721510uL, 5666729273999653769uL, 6354805078915230316uL,
			4170175935399174103uL, 3408091491732606514uL, 1510504066800368669uL, 171957839906106872uL, 15503951495479842667uL, 13960473236139345550uL, 18014409663306855585uL, 17047395523660457284uL, 10194810967608725759uL, 11236401094006030618uL,
			11552345569517220661uL, 13170395417562112720uL, 14384589897994791049uL, 15074917395401259372uL, 16900118059129523011uL, 18166903079156128422uL, 11381286197612752669uL, 10044991663075163896uL, 12743886119367675095uL, 11984053505496735026uL,
			8287777973661886369uL, 7318512004219876932uL, 6786090870343910507uL, 5240360918646756750uL, 2978635386689495093uL, 4594433404804559312uL, 324028840084734975uL, 1363367273991164442uL, 11110924361083938226uL, 10134619897871545431uL,
			13193573627239777912uL, 11640807243624978333uL, 13863146062535008806uL, 15489919985389171651uL, 17098719169495663084uL, 18149035569993928713uL, 3356765784183335578uL, 4035552365312981887uL, 269287075224504656uL, 1524533240290154677uL,
			8414843414638210318uL, 7085022362333281515uL, 6480279750391172804uL, 5726922680068759329uL, 8972051685281362687uL, 7644764384895083290uL, 5884571808997396789uL, 5133746429277765840uL, 2797023761118180715uL, 3478344093092799630uL,
			862463327592519329uL, 2120241182187276100uL, 14422618499663363543uL, 16047423682136517682uL, 16505266596615020061uL, 17553612194879541240uL, 10553420664906988099uL, 9575147462387395494uL, 13788997000709970313uL, 12234259815935232108uL,
			2383138551935107012uL, 4000905309357354529uL, 881448217627319310uL, 1922757452693671403uL, 8881306069612378192uL, 7914008840551360949uL, 6226700690064317338uL, 4682941540600892031uL, 10788044730029306092uL, 9449216444646727945uL,
			13303569662590145318uL, 12541205359190082243uL, 14980365115852765048uL, 15668158861340567197uL, 16342966207080305842uL, 17607219536504112471uL, 0uL, 787345783882751359uL, 1574691567765502718uL, 2249367087917868929uL,
			3149383135531005436uL, 2403213109735319683uL, 4498734175835737858uL, 3784009074528670333uL, 6298766271062010872uL, 6738652078272902791uL, 4806426219470639366uL, 5214867102192651385uL, 8997468351671475716uL, 8516407063399170939uL,
			7568018149057340666uL, 7199627124515158405uL, 12597532542124021744uL, 11834997800763017871uL, 13477304156545805582uL, 12818430263456788593uL, 9612852438941278732uL, 10343220837673090931uL, 10429734204385302770uL, 11119648263171147149uL,
			17994936703342951432uL, 17534744561339769207uL, 17032814126798341878uL, 16613076324741389193uL, 15136036298114681332uL, 15628394505721402507uL, 14399254249030316810uL, 14787951608365313653uL, 7602072216140004491uL, 7175020041742557684uL,
			8981745304614405749uL, 8523246006843251466uL, 4812983652164716919uL, 5198862542380848136uL, 6273877681976996745uL, 6772424636753178358uL, 4473845649564555123uL, 3817781704412842508uL, 3155940635334143373uL, 2387208625622118642uL,
			1558968592112198287uL, 2256206094175911920uL, 34054142781659249uL, 762738768218817806uL, 14388034875940531067uL, 14790287011522967044uL, 15165586827024978309uL, 15608291103391960314uL, 17012429212251037319uL, 16642345343438554104uL,
			17996990598435087481uL, 17523243682474440966uL, 10431788023778705539uL, 11108147317196889596uL, 9592467452989946493uL, 10372489793556555522uL, 13506854618347304319uL, 12798326785428482048uL, 12586313106220142465uL, 11837333132517036798uL,
			15204144432280008982uL, 15569733498547987561uL, 14350040083485115368uL, 14828281804104195735uL, 17963490609228811498uL, 17556743671269659029uL, 17046492013686502932uL, 16608282541877275499uL, 9625967304329433838uL, 10338989941806010257uL,
			10397725084761696272uL, 11142210256088085871uL, 12547755363953993490uL, 11875890875194243693uL, 13544849273506356716uL, 12760332130395242643uL, 8947691299129110246uL, 8557300012202734489uL, 7635563408825685016uL, 7141528848645818727uL,
			6311881270668286746uL, 6734421048187700837uL, 4774417251244237284uL, 5237428943712386203uL, 3117937184224396574uL, 2425212076857677921uL, 4512412188351823840uL, 3779215166036632223uL, 68108285563318498uL, 728684625311346077uL,
			1525477536437635612uL, 2289697149439416163uL, 13510804007889421725uL, 12784930411702114530uL, 12563469603102752611uL, 11869060739658474012uL, 10391176462114893921uL, 11158206005852613918uL, 9650847094104459935uL, 10305226182635722720uL,
			17071371732057632357uL, 16574518719893156634uL, 17956941910883407003uL, 17572739353925126628uL, 14365754259819912089uL, 14821451597164660454uL, 15170099099554406759uL, 15594331704155864088uL, 1536688116651627117uL, 2287370539157557010uL,
			38566538791528595uL, 748779245502281196uL, 4532788318621656977uL, 3749954931616938734uL, 3115892079852313967uL, 2436704165002952720uL, 4772372213981084053uL, 5248921107556394218uL, 6332257463751820139uL, 6705160885172035092uL,
			7606021737752759401uL, 7161623535945552150uL, 8958901950746736279uL, 8554973464734968808uL, 10459284472548778311uL, 11226314016269597752uL, 9582739082848525241uL, 10237118171430241990uL, 13443821621981287611uL, 12717948025743509956uL,
			12630451988759195205uL, 11936043125331833658uL, 14289747082974300863uL, 14745444420335704000uL, 15246106277222068289uL, 15670338881773317438uL, 17148504534435626819uL, 16651651522321343036uL, 17879809108757104061uL, 17495606551782185154uL,
			4608795221377857207uL, 3825961834390039496uL, 3039885177918164041uL, 2360697263018348854uL, 1459555039613862731uL, 2210237462170263092uL, 115699616080984501uL, 825912322774820042uL, 7537913451652472143uL, 7093515249828610096uL,
			9027010236024973233uL, 8623081750063413966uL, 4839354324793174195uL, 5315903218318292428uL, 6265275352688038477uL, 6638178774124891954uL, 17895382598258220492uL, 17488635660315705523uL, 17114600024405468978uL, 16676390552546048589uL,
			15271126817651370032uL, 15636715883969557839uL, 14283057697291637454uL, 14761299417894064049uL, 12623762541336573492uL, 11951898052559907659uL, 13468842096375401674uL, 12684324953314759093uL, 9548834502488474568uL, 10261857139914596023uL,
			10474857887424772406uL, 11219343058768061513uL, 6235874368448793148uL, 6658414145951569731uL, 4850424153715355842uL, 5313435846233697725uL, 9024824376703647680uL, 8634433089727062719uL, 7558430332073264446uL, 7064395771910051905uL,
			136216571126636996uL, 796792910891580603uL, 1457369250622692154uL, 2221588863574001221uL, 3050955072875271224uL, 2358229965559007559uL, 4579394298878832326uL, 3846197276546741177uL, 4888990554929436753uL, 5274869445162206510uL,
			6197870780034327215uL, 6696417734760316880uL, 7524939139093982637uL, 7097886964746744018uL, 9058878381912119123uL, 8600379084124310060uL, 1490860306003653545uL, 2188097808050450134uL, 102162428068153687uL, 830847053555782696uL,
			4540827760385164885uL, 3884763815182998314uL, 3088958524261842091uL, 2320226514566717908uL, 17080537222693179297uL, 16710453353864057566uL, 17928882587170895199uL, 17455135671260440608uL, 14321052490023877213uL, 14723304625556104994uL,
			15232569212689940643uL, 15675273489073577436uL, 13430847441493173337uL, 12722319608591268134uL, 12662320283896323751uL, 11913340310142747608uL, 10508920826164957605uL, 11185280119633595610uL, 9515334650855385947uL, 10295356991405094436uL,
			3073376233303254234uL, 2327206207490668965uL, 4574741078315114020uL, 3860015977058501467uL, 77133077583057190uL, 864478861415337049uL, 1497558491004562392uL, 2172234011173844647uL, 9065576637243313954uL, 8584515348987662941uL,
			7499909863233877468uL, 7131518838641485987uL, 6231784159704627934uL, 6671669966965712801uL, 4873408330005905440uL, 5281849212711279967uL, 9544744427962168106uL, 10275112826710879829uL, 10497842215112788436uL, 11187756273848177835uL,
			12664514927503640278uL, 11901980186193107881uL, 13410321770344070184uL, 12751447877238137175uL, 15212043475505518802uL, 15704401683095586221uL, 14323247071891104300uL, 14711944431276310355uL, 17917803901493472558uL, 17457611759440097361uL,
			17109946929469937616uL, 16690209127429622447uL, 0uL, 12735104804238718208uL, 6170348077646248299uL, 16509444970853862507uL, 12340696155292496598uL, 2017291147968776150uL, 18366681100960566205uL, 5647410020680629949uL,
			7087766252628637383uL, 15195395291188200391uL, 4034582295937552300uL, 9746239707350891180uL, 14492082353831314449uL, 8764592317971984657uL, 11294820041361259898uL, 3171498017405012090uL, 14175532505257274766uL, 8360288316147898510uL,
			10455354299411240165uL, 2424290165905580517uL, 8069164591875104600uL, 16088898739697412696uL, 4204695827194471987uL, 10008751866545607475uL, 12026113418985642825uL, 1610450521212481097uL, 17529184635943969314uL, 4897667708912932642uL,
			983934998540085663uL, 13626641174839860383uL, 6342996034810024180uL, 16769987818756040180uL, 13666754959799896183uL, 943010859455266167uL, 16720576632295797020uL, 6392654625517126684uL, 1650821038878145185uL, 11985427320909746081uL,
			4848580331811161034uL, 17579150543333897930uL, 16138329183750209200uL, 8019488974878067632uL, 9968618824059996123uL, 4245636992636465883uL, 8409391654388943974uL, 14125548474144930150uL, 2383903687033664781uL, 10496058521142312973uL,
			8724469239847757305uL, 14533015753876459769uL, 3220901042424962194uL, 11245169644315093394uL, 15155034169900160815uL, 7128442917811298863uL, 9795335417825865284uL, 3984608091673254724uL, 1967869997080171326uL, 12390362511329207870uL,
			5687551224606534229uL, 18325731741857636181uL, 12685992069620048360uL, 49993464005580008uL, 16549823116352575619uL, 6129652152789544323uL, 5732242439398949765uL, 18388525449166714501uL, 1886021718910532334uL, 12290412006796791790uL,
			16487662723588944211uL, 6085453523643991123uL, 12785309251034253368uL, 131349165135199544uL, 3301642077756290370uL, 11343977721637208130uL, 8678633399360621609uL, 14469112605244913961uL, 9697160663622322068uL, 3904359633382109844uL,
			15218304003986685695uL, 7173786172651670527uL, 10030817736304094731uL, 4289874141128104715uL, 16038977949756135264uL, 7938099221034263136uL, 2339173952895261917uL, 10433226294353193437uL, 8491273985272931766uL, 14225533031257575606uL,
			16818783308777887948uL, 6472935006220938700uL, 13603448873973965223uL, 897631353009542311uL, 4767807374067329562uL, 17480310543733595930uL, 1696693130970731377uL, 12049366721281123953uL, 17448938479695514610uL, 4799494982008422130uL,
			12071458975870825113uL, 1673722382600095641uL, 6441802084849924388uL, 16850726552061430820uL, 920029822624186447uL, 13580803032324715855uL, 10411153299503529269uL, 2362127677123446837uL, 14256885835622597726uL, 8459603401541529950uL,
			4267491630505250787uL, 10053445452083444451uL, 7969216183346509448uL, 16007052832275252104uL, 3935739994160342652uL, 9665464722442244988uL, 7151703350820986647uL, 15241265356113914391uL, 11375102449213068458uL, 3269706996047258026uL,
			14446704874535726529uL, 8701288534308280513uL, 6107518221753503931uL, 16464717332599743931uL, 99986928011160016uL, 12816989231009062096uL, 18410916153584722541uL, 5709606562045089645uL, 12259304305579088646uL, 1917937543093005830uL,
			11464484878797899530uL, 3433473658752004618uL, 14608395860728905313uL, 8793099033037802337uL, 3772043437821064668uL, 9576011654218252508uL, 7059822771495537847uL, 15079645017149569463uL, 18250491813091111373uL, 5619062709015053517uL,
			12170907047287982246uL, 1755156051682065830uL, 6198132172524913435uL, 16625071043010131483uL, 262698330270399088uL, 12905457145152933744uL, 6603284155512580740uL, 16942468872748801924uL, 1009625548606182383uL, 13744642253938255599uL,
			17357266798721243218uL, 4637942803906882898uL, 11907549105953988921uL, 1584196738286916665uL, 4179162533076442179uL, 9890872859023141187uL, 7808719266764219688uL, 15916295665668198440uL, 10573796523720076949uL, 2450386675736288149uL,
			14347572345303341054uL, 8620170408349590270uL, 2499525798771838845uL, 10523847040318618237uL, 8579748282256209430uL, 14388241881750487830uL, 9940267621763300779uL, 4129452196704045227uL, 15876198442068526272uL, 7849695014008271296uL,
			4678347905790523834uL, 17316616521947204794uL, 1535074639393865937uL, 11957479329615361489uL, 16982547970545863532uL, 6562324367327247980uL, 13695265617067946503uL, 1059319925986838279uL, 16575923724174533363uL, 6248089815227586547uL,
			12945870012441877400uL, 222038089143299736uL, 5569676245288374309uL, 18300193818229384485uL, 1795262706019084622uL, 12129921901510450254uL, 9535614748134659124uL, 3812685555293888820uL, 15128776374847057247uL, 7009883252514117727uL,
			3393386261941462754uL, 11505452998217356258uL, 8842466239170764681uL, 14558710881881729673uL, 15030495895401333903uL, 6929670081212969359uL, 9598989964016844260uL, 3857993729185384676uL, 8923312724748924505uL, 14657483946705879897uL,
			3347444765200191282uL, 11441585205563587122uL, 12883604169699848776uL, 177874472764147528uL, 16675346561574439715uL, 6329410160110992931uL, 1840059645248372894uL, 12192680321024226718uL, 5487722586128382453uL, 18200278395451149557uL,
			1454266669001206017uL, 11858744779842329601uL, 4724255354246893674uL, 17380450266181756266uL, 13793507581462649815uL, 1139494582102912727uL, 16919206803083059900uL, 6517050241721014204uL, 8534983261010501574uL, 14325515380354411206uL,
			2581443210487391917uL, 10623726215786468269uL, 15938432366693018896uL, 7893826712404203536uL, 9840881031673877627uL, 4048168099265503611uL, 7871479988320685304uL, 15961094632196520440uL, 4079249412343018899uL, 9808921227164237971uL,
			14303406701641973294uL, 8557902263581625134uL, 10655114841319130949uL, 2549807211108184645uL, 1108396242668173887uL, 13825486643497914175uL, 6539413992094516052uL, 16896525279986955860uL, 11827338030654540009uL, 1485918629586615785uL,
			17402577068616561026uL, 4701320390536545410uL, 12215036443507007862uL, 1817387949141742710uL, 18169205413473540125uL, 5519674091758759197uL, 199973856022320032uL, 12860694426067379872uL, 6298013375142898379uL, 16706990756887912395uL,
			14688572887741355953uL, 8891343093316788913uL, 11419213124090179290uL, 3370134587175558106uL, 6961086125855024487uL, 14998834675877269607uL, 3835875086186011660uL, 9621916731792926988uL
		};

		private static ulong[] m_uX2N = new ulong[64]
		{
			36028797018963968uL, 140737488355328uL, 2147483648uL, 11127430586519243189uL, 1221807072334778582uL, 8138107668736496166uL, 3535907488026231341uL, 3441480032374409582uL, 14577399307959786116uL, 18108090348644263661uL,
			16872192058669208586uL, 6470743304385776052uL, 2356340599778112122uL, 3282589245383169411uL, 4813772690843722589uL, 2123572894795720761uL, 13361200295056722901uL, 6714339060555490282uL, 14813753520627564098uL, 2575392968416258319uL,
			3781498879954341639uL, 2029575846824038122uL, 11210212698471928928uL, 2698801079951716530uL, 5369600018057262368uL, 10474170701250152447uL, 12693693266037740021uL, 14926416049973907054uL, 12778104656887448071uL, 14865980173302332725uL,
			5898182234392518323uL, 11506987473448080863uL, 8338456165086097871uL, 6752081962152672116uL, 18050102898699742154uL, 14183399822074814198uL, 12097687167394233669uL, 10929469909668459249uL, 1876517811888844395uL, 4541923943557071381uL,
			5671875008802276871uL, 5352236642095812106uL, 3280130613932697821uL, 9694238273182980114uL, 5923064843803063040uL, 11819714483094804698uL, 15354363091388458338uL, 1261561810665423398uL, 11395176905717369489uL, 11207650524541939074uL,
			12880488140263503615uL, 3418619511318683672uL, 4382979584528688930uL, 9313537133046378584uL, 13796321753777571544uL, 9630359120624875631uL, 3783882481749783366uL, 10828018389360610332uL, 1514337215546087857uL, 16997139097890852538uL,
			10296581199785350754uL, 4611686018427387904uL, 2305843009213693952uL, 576460752303423488uL
		};

		private const ulong m_uComplement = ulong.MaxValue;

		private const int m_uBitWidth = 64;

		public static ulong ComputeSlicedSafe(ReadOnlySpan<byte> src, ulong uCrc)
		{
			int i = 0;
			ulong num = (ulong)src.Length;
			uCrc ^= 0xFFFFFFFFFFFFFFFFuL;
			ulong num2 = 0uL;
			ulong num3 = num - num % 32;
			if (num3 >= 64)
			{
				ulong num4 = 0uL;
				ulong num5 = 0uL;
				ulong num6 = 0uL;
				ulong num7 = 0uL;
				int num8 = i + (int)num3 - 32;
				num -= num3;
				num4 = uCrc;
				for (; i < num8; i += 32)
				{
					ulong num9 = BinaryPrimitives.ReadUInt64LittleEndian(src.Slice(i)) ^ num4;
					ulong num10 = BinaryPrimitives.ReadUInt64LittleEndian(src.Slice(i + 8)) ^ num5;
					ulong num11 = BinaryPrimitives.ReadUInt64LittleEndian(src.Slice(i + 16)) ^ num6;
					ulong num12 = BinaryPrimitives.ReadUInt64LittleEndian(src.Slice(i + 24)) ^ num7;
					num4 = m_u32[1792 + (num9 & 0xFF)];
					num9 >>= 8;
					num5 = m_u32[1792 + (num10 & 0xFF)];
					num10 >>= 8;
					num6 = m_u32[1792 + (num11 & 0xFF)];
					num11 >>= 8;
					num7 = m_u32[1792 + (num12 & 0xFF)];
					num12 >>= 8;
					num4 ^= m_u32[1536 + (num9 & 0xFF)];
					num9 >>= 8;
					num5 ^= m_u32[1536 + (num10 & 0xFF)];
					num10 >>= 8;
					num6 ^= m_u32[1536 + (num11 & 0xFF)];
					num11 >>= 8;
					num7 ^= m_u32[1536 + (num12 & 0xFF)];
					num12 >>= 8;
					num4 ^= m_u32[1280 + (num9 & 0xFF)];
					num9 >>= 8;
					num5 ^= m_u32[1280 + (num10 & 0xFF)];
					num10 >>= 8;
					num6 ^= m_u32[1280 + (num11 & 0xFF)];
					num11 >>= 8;
					num7 ^= m_u32[1280 + (num12 & 0xFF)];
					num12 >>= 8;
					num4 ^= m_u32[1024 + (num9 & 0xFF)];
					num9 >>= 8;
					num5 ^= m_u32[1024 + (num10 & 0xFF)];
					num10 >>= 8;
					num6 ^= m_u32[1024 + (num11 & 0xFF)];
					num11 >>= 8;
					num7 ^= m_u32[1024 + (num12 & 0xFF)];
					num12 >>= 8;
					num4 ^= m_u32[768 + (num9 & 0xFF)];
					num9 >>= 8;
					num5 ^= m_u32[768 + (num10 & 0xFF)];
					num10 >>= 8;
					num6 ^= m_u32[768 + (num11 & 0xFF)];
					num11 >>= 8;
					num7 ^= m_u32[768 + (num12 & 0xFF)];
					num12 >>= 8;
					num4 ^= m_u32[512 + (num9 & 0xFF)];
					num9 >>= 8;
					num5 ^= m_u32[512 + (num10 & 0xFF)];
					num10 >>= 8;
					num6 ^= m_u32[512 + (num11 & 0xFF)];
					num11 >>= 8;
					num7 ^= m_u32[512 + (num12 & 0xFF)];
					num12 >>= 8;
					num4 ^= m_u32[256 + (num9 & 0xFF)];
					num9 >>= 8;
					num5 ^= m_u32[256 + (num10 & 0xFF)];
					num10 >>= 8;
					num6 ^= m_u32[256 + (num11 & 0xFF)];
					num11 >>= 8;
					num7 ^= m_u32[256 + (num12 & 0xFF)];
					num12 >>= 8;
					num4 ^= m_u32[num9 & 0xFF];
					num5 ^= m_u32[num10 & 0xFF];
					num6 ^= m_u32[num11 & 0xFF];
					num7 ^= m_u32[num12 & 0xFF];
				}
				uCrc = 0uL;
				uCrc ^= BinaryPrimitives.ReadUInt64LittleEndian(src.Slice(i)) ^ num4;
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc ^= BinaryPrimitives.ReadUInt64LittleEndian(src.Slice(i + 8)) ^ num5;
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc ^= BinaryPrimitives.ReadUInt64LittleEndian(src.Slice(i + 16)) ^ num6;
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc ^= BinaryPrimitives.ReadUInt64LittleEndian(src.Slice(i + 24)) ^ num7;
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				uCrc = (uCrc >> 8) ^ m_u1[uCrc & 0xFF];
				i += 32;
			}
			num2 = 0uL;
			while (num2 < num)
			{
				uCrc = (uCrc >> 8) ^ m_u1[(uCrc ^ src[i]) & 0xFF];
				num2++;
				i++;
			}
			return uCrc ^ 0xFFFFFFFFFFFFFFFFuL;
		}

		internal static ulong Concatenate(ulong uInitialCrcAB, ulong uInitialCrcA, ulong uFinalCrcA, ulong uSizeA, ulong uInitialCrcB, ulong uFinalCrcB, ulong uSizeB)
		{
			ulong num = uFinalCrcA ^ 0xFFFFFFFFFFFFFFFFuL;
			if (uInitialCrcA != uInitialCrcAB)
			{
				num ^= MulX_N(uInitialCrcA ^ uInitialCrcAB, uSizeA);
			}
			num ^= uInitialCrcB ^ 0xFFFFFFFFFFFFFFFFuL;
			num = MulX_N(num, uSizeB);
			return num ^ uFinalCrcB;
		}

		private static ulong MulX_N(ulong a, ulong uSize)
		{
			int num = 0;
			ulong num2 = a;
			uSize >>= num;
			while (uSize != 0L)
			{
				if ((uSize & 1) == 1)
				{
					num2 = MulPoly(num2, m_uX2N[num]);
				}
				uSize >>= 1;
				num++;
			}
			return num2;
		}

		private static ulong MulPoly(ulong a, ulong b)
		{
			return MulPolyUnrolled(a, b);
		}

		private static ulong MulPolyUnrolled(ulong a, ulong b)
		{
			ulong num = poly;
			ulong num2 = (num >> 1) ^ (num * (num & 1));
			int num3 = 64;
			ulong[] array = new ulong[4]
			{
				0uL,
				num2,
				num,
				num ^ num2
			};
			int[] array2 = new int[2]
			{
				num3 - 2,
				num3 - 1
			};
			ulong[] array3 = new ulong[2]
			{
				(b >> 1) ^ array[(b & 1) << 1],
				b
			};
			ulong[] array4 = new ulong[2];
			for (int i = 0; i < num3; i += 2)
			{
				for (int j = 0; j < 2; j++)
				{
					array4[j] ^= array3[j] * ((a >> array2[j]) & 1);
					array3[j] = (array3[j] >> 2) ^ array[array3[j] & 3];
				}
				a <<= 2;
			}
			return array4[0] ^ array4[1];
		}
	}
	internal static class StorageCrc64Composer
	{
		public static Memory<byte> Compose(params (byte[] Crc64, long OriginalDataLength)[] partitions)
		{
			return Compose(partitions.AsEnumerable());
		}

		public static Memory<byte> Compose(IEnumerable<(byte[] Crc64, long OriginalDataLength)> partitions)
		{
			return new Memory<byte>(BitConverter.GetBytes(Compose(partitions.Select(((byte[] Crc64, long OriginalDataLength) tup) => (BitConverter.ToUInt64(tup.Crc64, 0), OriginalDataLength: tup.OriginalDataLength)))));
		}

		public static ulong Compose(IEnumerable<(ulong Crc64, long OriginalDataLength)> partitions)
		{
			ulong num = 0uL;
			long num2 = 0L;
			foreach (var partition in partitions)
			{
				num = Azure.Storage.StorageCrc64Calculator.Concatenate(0uL, 0uL, num, (ulong)num2, 0uL, partition.Crc64, (ulong)partition.OriginalDataLength);
				num2 += partition.OriginalDataLength;
			}
			return num;
		}
	}
	internal static class StorageExceptionExtensions
	{
		public static string GetErrorCode(this Response response, string errorCode)
		{
			if (string.IsNullOrEmpty(errorCode))
			{
				response.Headers.TryGetValue("x-ms-error-code", out errorCode);
			}
			return errorCode;
		}

		public static bool IsUnavailable<T>(this Response<T> response)
		{
			return (response?.GetRawResponse().Status ?? 0) == 304;
		}

		public static Response<T> AsNoBodyResponse<T>(this Response rawResponse)
		{
			return new Azure.NoBodyResponse<T>(rawResponse);
		}
	}
	internal class StorageRequestValidationPipelinePolicy : HttpPipelineSynchronousPolicy
	{
		public override void OnReceivedResponse(HttpMessage message)
		{
			if (message.HasResponse && message.Request.Headers.TryGetValue("x-ms-client-request-id", out string value) && message.Response.Headers.TryGetValues("x-ms-client-request-id", out IEnumerable<string> values) && !string.Equals(value, values.First(), StringComparison.OrdinalIgnoreCase))
			{
				throw Azure.Storage.Errors.ClientRequestIdMismatch(message.Response, values.First(), value);
			}
		}
	}
	internal static class StorageProgressExtensions
	{
		public static Stream WithProgress(this Stream stream, IProgress<long> progressHandler)
		{
			if (progressHandler != null && stream != null)
			{
				if (progressHandler is AggregatingProgressIncrementer aggregatingProgressIncrementer)
				{
					return aggregatingProgressIncrementer.CreateProgressIncrementingStream(stream);
				}
				return new AggregatingProgressIncrementer(progressHandler).CreateProgressIncrementingStream(stream);
			}
			return stream;
		}
	}
	internal class StorageSharedKeyCredentialInternals : StorageSharedKeyCredential
	{
		private StorageSharedKeyCredentialInternals(string accountName, string accountKey)
			: base(accountName, accountKey)
		{
		}

		internal new static string ComputeSasSignature(StorageSharedKeyCredential credential, string message)
		{
			return StorageSharedKeyCredential.ComputeSasSignature(credential, message);
		}
	}
	internal sealed class StorageSharedKeyPipelinePolicy : HttpPipelineSynchronousPolicy
	{
		private const bool IncludeXMsDate = true;

		private readonly StorageSharedKeyCredential _credentials;

		public StorageSharedKeyPipelinePolicy(StorageSharedKeyCredential credentials)
		{
			_credentials = credentials;
		}

		public override void OnSendingRequest(HttpMessage message)
		{
			base.OnSendingRequest(message);
			string value = DateTimeOffset.UtcNow.ToString("r", CultureInfo.InvariantCulture);
			message.Request.Headers.SetValue("x-ms-date", value);
			string message2 = BuildStringToSign(message);
			string text = Azure.Storage.StorageSharedKeyCredentialInternals.ComputeSasSignature(_credentials, message2);
			string value2 = new AuthenticationHeaderValue("SharedKey", _credentials.AccountName + ":" + text).ToString();
			message.Request.Headers.SetValue("Authorization", value2);
		}

		private string BuildStringToSign(HttpMessage message)
		{
			message.Request.Headers.TryGetValue("Content-Encoding", out string value);
			message.Request.Headers.TryGetValue("Content-Language", out string value2);
			message.Request.Headers.TryGetValue("Content-MD5", out string value3);
			message.Request.Headers.TryGetValue("Content-Type", out string value4);
			message.Request.Headers.TryGetValue("If-Modified-Since", out string value5);
			message.Request.Headers.TryGetValue("If-Match", out string value6);
			message.Request.Headers.TryGetValue("If-None-Match", out string value7);
			message.Request.Headers.TryGetValue("If-Unmodified-Since", out string value8);
			message.Request.Headers.TryGetValue("Range", out string value9);
			string text = string.Empty;
			if (message.Request.Content != null && message.Request.Content.TryComputeLength(out var length))
			{
				text = length.ToString(CultureInfo.InvariantCulture);
			}
			Uri uri = message.Request.Uri.ToUri();
			StringBuilder stringBuilder = new StringBuilder(uri.AbsolutePath.Length + 64);
			stringBuilder.Append(message.Request.Method.ToString().ToUpperInvariant()).Append('\n');
			stringBuilder.Append(value ?? "").Append('\n');
			stringBuilder.Append(value2 ?? "").Append('\n');
			stringBuilder.Append((text == "0") ? "" : (text ?? "")).Append('\n');
			stringBuilder.Append(value3 ?? "");
			stringBuilder.Append('\n');
			stringBuilder.Append(value4 ?? "").Append('\n');
			stringBuilder.Append('\n');
			stringBuilder.Append(value5 ?? "").Append('\n');
			stringBuilder.Append(value6 ?? "").Append('\n');
			stringBuilder.Append(value7 ?? "").Append('\n');
			stringBuilder.Append(value8 ?? "").Append('\n');
			stringBuilder.Append(value9 ?? "").Append('\n');
			BuildCanonicalizedHeaders(stringBuilder, message);
			BuildCanonicalizedResource(stringBuilder, uri);
			return stringBuilder.ToString();
		}

		private static void BuildCanonicalizedHeaders(StringBuilder stringBuilder, HttpMessage message)
		{
			List<HttpHeader> list = new List<HttpHeader>();
			foreach (HttpHeader header in message.Request.Headers)
			{
				if (header.Name.StartsWith("x-ms-", StringComparison.OrdinalIgnoreCase))
				{
					list.Add(new HttpHeader(header.Name.ToLowerInvariant(), header.Value));
				}
			}
			list.Sort((HttpHeader x, HttpHeader y) => string.CompareOrdinal(x.Name, y.Name));
			foreach (HttpHeader item in list)
			{
				stringBuilder.Append(item.Name).Append(':').Append(item.Value)
					.Append('\n');
			}
		}

		private void BuildCanonicalizedResource(StringBuilder stringBuilder, Uri resource)
		{
			stringBuilder.Append('/');
			stringBuilder.Append(_credentials.AccountName);
			if (resource.AbsolutePath.Length > 0)
			{
				stringBuilder.Append(resource.AbsolutePath);
			}
			else
			{
				stringBuilder.Append('/');
			}
			IDictionary<string, string> queryParameters = resource.GetQueryParameters();
			if (queryParameters.Count <= 0)
			{
				return;
			}
			foreach (string item in queryParameters.Keys.OrderBy((string key) => key, StringComparer.Ordinal))
			{
				stringBuilder.Append('\n').Append(item.ToLowerInvariant()).Append(':')
					.Append(queryParameters[item]);
			}
		}
	}
	internal class StorageResponseClassifier : ResponseClassifier
	{
		public Uri SecondaryStorageUri { get; set; }

		public override bool IsRetriableResponse(HttpMessage message)
		{
			if (SecondaryStorageUri != null && message.Request.Uri.Host == SecondaryStorageUri.Host && message.Response.Status == 404)
			{
				return true;
			}
			if (message.Response.Status >= 400 && message.Response.Headers.TryGetValue("x-ms-error-code", out string value))
			{
				switch (value)
				{
				case "InternalError":
				case "OperationTimedOut":
				case "ServerBusy":
					return true;
				}
			}
			return base.IsRetriableResponse(message);
		}

		public override bool IsErrorResponse(HttpMessage message)
		{
			if (message.Response.Status == 409)
			{
				RequestHeaders headers = message.Request.Headers;
				if (message.Response.Headers.TryGetValue("x-ms-error-code", out string value) && (value == "ContainerAlreadyExists" || value == "BlobAlreadyExists"))
				{
					return !headers.Contains(HttpHeader.Names.IfMatch) && !headers.Contains(HttpHeader.Names.IfNoneMatch) && !headers.Contains(HttpHeader.Names.IfModifiedSince) && !headers.Contains(HttpHeader.Names.IfUnmodifiedSince);
				}
			}
			return base.IsErrorResponse(message);
		}
	}
	internal class StorageServerTimeoutPolicy : HttpPipelineSynchronousPolicy
	{
		private const string QueryParameterKeyWithEqualSign = "timeout=";

		public static StorageServerTimeoutPolicy Shared { get; } = new StorageServerTimeoutPolicy();

		private StorageServerTimeoutPolicy()
		{
		}

		public override void OnSendingRequest(HttpMessage message)
		{
			if (message.TryGetProperty("Azure.Storage.StorageServerTimeoutPolicy.Timeout", out object value))
			{
				if (!(value is TimeSpan timeSpan))
				{
					throw new ArgumentException(string.Format("{0} http message property must be a TimeSpan but was {1}", "Azure.Storage.StorageServerTimeoutPolicy.Timeout", value?.GetType()));
				}
				string query = message.Request.Uri.Query;
				int num = Convert.ToInt32(timeSpan.TotalSeconds);
				if (string.IsNullOrEmpty(query))
				{
					message.Request.Uri.Query += string.Format(CultureInfo.InvariantCulture, "?{0}{1}", "timeout=", num);
				}
				else if (!query.Contains("timeout="))
				{
					message.Request.Uri.Query += string.Format(CultureInfo.InvariantCulture, "&{0}{1}", "timeout=", num);
				}
			}
		}
	}
	internal class StorageTelemetryPolicy : HttpPipelineSynchronousPolicy
	{
		[Flags]
		private enum AzFeatures
		{
			None = 0,
			CseV1 = 1,
			CseV2 = 2
		}

		private const string CseIdentifierV2 = "azstorage-clientsideencryption/2.0";

		private const string CseIdentifierV1 = "azstorage-clientsideencryption/1.0";

		public static StorageTelemetryPolicy Shared { get; } = new StorageTelemetryPolicy();

		private StorageTelemetryPolicy()
		{
		}

		public override void OnSendingRequest(HttpMessage message)
		{
			AzFeatures azFeatures = AzFeatures.None;
			if (message.TryGetProperty("Azure.Storage.StorageTelemetryPolicy.ClientSideEncryption.V2", out object value))
			{
				azFeatures |= AzFeatures.CseV2;
			}
			else if (message.TryGetProperty("Azure.Storage.StorageTelemetryPolicy.ClientSideEncryption.V1", out value))
			{
				azFeatures |= AzFeatures.CseV1;
			}
			if (azFeatures != AzFeatures.None)
			{
				ApplyAzFeatures(message, azFeatures);
			}
		}

		private static void ApplyAzFeatures(HttpMessage message, AzFeatures azFeatures)
		{
			string text = Serialize(azFeatures);
			if (message.Request.Headers.TryGetValue(HttpHeader.Names.UserAgent, out string value) && !value.Contains(text))
			{
				message.Request.Headers.SetValue(HttpHeader.Names.UserAgent, TransformUserAgent(value, text));
			}
			else
			{
				message.Request.Headers.SetValue(HttpHeader.Names.UserAgent, text);
			}
		}

		private static string Serialize(AzFeatures azFeatures)
		{
			if ((azFeatures & AzFeatures.CseV2) == AzFeatures.CseV2)
			{
				return "azstorage-clientsideencryption/2.0";
			}
			if ((azFeatures & AzFeatures.CseV1) == AzFeatures.CseV1)
			{
				return "azstorage-clientsideencryption/1.0";
			}
			return "";
		}

		private static string TransformUserAgent(string userAgent, string injection)
		{
			if (string.IsNullOrEmpty(injection))
			{
				return userAgent;
			}
			return string.Join(" ", injection, userAgent);
		}
	}
	internal static class StorageVersionExtensions
	{
		public const BlobClientOptions.ServiceVersion LatestVersion = BlobClientOptions.ServiceVersion.V2023_11_03;

		internal const BlobClientOptions.ServiceVersion MaxVersion = BlobClientOptions.ServiceVersion.V2023_11_03;

		public static string ToVersionString(this BlobClientOptions.ServiceVersion version)
		{
			return version switch
			{
				BlobClientOptions.ServiceVersion.V2019_02_02 => "2019-02-02", 
				BlobClientOptions.ServiceVersion.V2019_07_07 => "2019-07-07", 
				BlobClientOptions.ServiceVersion.V2019_12_12 => "2019-12-12", 
				BlobClientOptions.ServiceVersion.V2020_02_10 => "2020-02-10", 
				BlobClientOptions.ServiceVersion.V2020_04_08 => "2020-04-08", 
				BlobClientOptions.ServiceVersion.V2020_06_12 => "2020-06-12", 
				BlobClientOptions.ServiceVersion.V2020_08_04 => "2020-08-04", 
				BlobClientOptions.ServiceVersion.V2020_10_02 => "2020-10-02", 
				BlobClientOptions.ServiceVersion.V2020_12_06 => "2020-12-06", 
				BlobClientOptions.ServiceVersion.V2021_02_12 => "2021-02-12", 
				BlobClientOptions.ServiceVersion.V2021_04_10 => "2021-04-10", 
				BlobClientOptions.ServiceVersion.V2021_06_08 => "2021-06-08", 
				BlobClientOptions.ServiceVersion.V2021_08_06 => "2021-08-06", 
				BlobClientOptions.ServiceVersion.V2021_10_04 => "2021-10-04", 
				BlobClientOptions.ServiceVersion.V2021_12_02 => "2021-12-02", 
				BlobClientOptions.ServiceVersion.V2022_11_02 => "2022-11-02", 
				BlobClientOptions.ServiceVersion.V2023_01_03 => "2023-01-03", 
				BlobClientOptions.ServiceVersion.V2023_05_03 => "2023-05-03", 
				BlobClientOptions.ServiceVersion.V2023_08_03 => "2023-08-03", 
				BlobClientOptions.ServiceVersion.V2023_11_03 => "2023-11-03", 
				_ => throw Azure.Storage.Errors.VersionNotSupported("version"), 
			};
		}
	}
	internal static class UriExtensions
	{
		public static Uri AppendToPath(this Uri uri, string segment)
		{
			UriBuilder uriBuilder = new UriBuilder(uri);
			string path = uriBuilder.Path;
			string text = ((path.Length == 0 || path[path.Length - 1] != '/') ? "/" : "");
			segment = segment.Replace("%", "%25");
			uriBuilder.Path = uriBuilder.Path + text + segment;
			return uriBuilder.Uri;
		}

		public static IDictionary<string, string> GetQueryParameters(this Uri uri)
		{
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			string text = uri.Query ?? "";
			if (!string.IsNullOrEmpty(text))
			{
				if (text.StartsWith("?", ignoreCase: true, CultureInfo.InvariantCulture))
				{
					text = text.Substring(1);
				}
				string[] array = text.Split(new char[1] { '&' }, StringSplitOptions.RemoveEmptyEntries);
				for (int i = 0; i < array.Length; i++)
				{
					string[] array2 = array[i].Split(new char[1] { '=' }, 2);
					string key = WebUtility.UrlDecode(array2[0]);
					if (array2.Length == 1)
					{
						dictionary.Add(key, null);
					}
					else
					{
						dictionary.Add(key, WebUtility.UrlDecode(array2[1]));
					}
				}
			}
			return dictionary;
		}

		public static string GetAccountNameFromDomain(this Uri uri, string serviceSubDomain)
		{
			return GetAccountNameFromDomain(uri.Host, serviceSubDomain);
		}

		public static string GetAccountNameFromDomain(string host, string serviceSubDomain)
		{
			int num = host.IndexOf(".", StringComparison.InvariantCulture);
			if (num >= 0)
			{
				if (host.IndexOf(serviceSubDomain, num, StringComparison.InvariantCulture) <= -1)
				{
					return null;
				}
				return host.Substring(0, num);
			}
			return null;
		}

		public static string GetPath(this Uri uri)
		{
			if (uri.AbsolutePath[0] != '/')
			{
				return uri.AbsolutePath;
			}
			return uri.AbsolutePath.Substring(1);
		}

		public static bool IsHostIPEndPointStyle(this Uri uri)
		{
			if (string.IsNullOrEmpty(uri.Host) || uri.Host.IndexOf(".", StringComparison.InvariantCulture) < 0 || !IPAddress.TryParse(uri.Host, out var _))
			{
				return Azure.Storage.Constants.Sas.PathStylePorts.Contains(uri.Port);
			}
			return true;
		}

		internal static void AppendQueryParameter(this StringBuilder sb, string key, string value)
		{
			sb.Append((sb.Length > 0) ? "&" : "").Append(key).Append('=')
				.Append(value);
		}
	}
	internal sealed class UriQueryParamsCollection : Dictionary<string, string>
	{
		public UriQueryParamsCollection()
			: base((IEqualityComparer<string>)StringComparer.OrdinalIgnoreCase)
		{
		}

		public UriQueryParamsCollection(string encodedQueryParamString)
			: base((IEqualityComparer<string>)StringComparer.OrdinalIgnoreCase)
		{
			encodedQueryParamString = encodedQueryParamString ?? throw Azure.Storage.Errors.ArgumentNull("encodedQueryParamString");
			if (encodedQueryParamString.StartsWith("?", ignoreCase: true, CultureInfo.InvariantCulture))
			{
				encodedQueryParamString = encodedQueryParamString.Substring(1);
			}
			string[] array = encodedQueryParamString.Split(new char[1] { '&' }, StringSplitOptions.RemoveEmptyEntries);
			for (int i = 0; i < array.Length; i++)
			{
				string[] array2 = array[i].Split(new char[1] { '=' }, 2);
				if (array2.Length == 1)
				{
					Add(WebUtility.UrlDecode(array2[0]), null);
				}
				else
				{
					Add(WebUtility.UrlDecode(array2[0]), WebUtility.UrlDecode(array2[1]));
				}
			}
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			using (Enumerator enumerator = GetEnumerator())
			{
				while (enumerator.MoveNext())
				{
					KeyValuePair<string, string> current = enumerator.Current;
					if (stringBuilder.Length > 0)
					{
						stringBuilder.Append('&');
					}
					stringBuilder.Append(WebUtility.UrlEncode(current.Key)).Append('=').Append(WebUtility.UrlEncode(current.Value));
				}
			}
			return stringBuilder.ToString();
		}
	}
	internal class LazyLoadingReadOnlyStream<TProperties> : Stream
	{
		public delegate Task<Response<IDownloadedContent>> DownloadInternalAsync(HttpRange range, DownloadTransferValidationOptions transferValidation, bool async, CancellationToken cancellationToken);

		public delegate Task<Response<TProperties>> GetPropertiesAsync(bool async, CancellationToken cancellationToken);

		public delegate HttpRange PredictEncryptedRangeAdjustment(HttpRange range);

		private long _position;

		private long _length;

		private readonly int _bufferSize;

		private byte[] _buffer;

		private int _bufferPosition;

		private int _bufferLength;

		private readonly bool _allowBlobModifications;

		private bool _bufferInvalidated;

		private readonly DownloadInternalAsync _downloadInternalFunc;

		private readonly GetPropertiesAsync _getPropertiesInternalFunc;

		private readonly DownloadTransferValidationOptions _validationOptions;

		private readonly PredictEncryptedRangeAdjustment _predictEncryptedRangeAdjustment;

		public static PredictEncryptedRangeAdjustment NoRangeAdjustment => (HttpRange range) => range;

		public override bool CanRead => true;

		public override bool CanSeek => true;

		public override bool CanWrite => false;

		public override long Length => _length;

		public override long Position
		{
			get
			{
				return _position;
			}
			set
			{
				Seek(value, SeekOrigin.Begin);
			}
		}

		public LazyLoadingReadOnlyStream(DownloadInternalAsync downloadInternalFunc, GetPropertiesAsync getPropertiesFunc, DownloadTransferValidationOptions transferValidation, bool allowModifications, long initialLenght, long position = 0L, int? bufferSize = null, PredictEncryptedRangeAdjustment rangePredictionFunc = null)
		{
			_downloadInternalFunc = downloadInternalFunc;
			_getPropertiesInternalFunc = getPropertiesFunc;
			_predictEncryptedRangeAdjustment = rangePredictionFunc ?? ((PredictEncryptedRangeAdjustment)((HttpRange range) => range));
			_position = position;
			_bufferSize = bufferSize ?? 4194304;
			_buffer = ArrayPool<byte>.Shared.Rent(_bufferSize);
			_allowBlobModifications = allowModifications;
			_bufferPosition = 0;
			_bufferLength = 0;
			_length = initialLenght;
			_bufferInvalidated = false;
			if (transferValidation != null && !transferValidation.AutoValidateChecksum)
			{
				throw Azure.Storage.Errors.CannotDeferTransactionalHashVerification();
			}
			_validationOptions = ((transferValidation == null) ? null : new DownloadTransferValidationOptions
			{
				ChecksumAlgorithm = transferValidation.ChecksumAlgorithm,
				AutoValidateChecksum = false
			});
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			return ReadInternal(buffer, offset, count, async: false, default(CancellationToken)).EnsureCompleted();
		}

		public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
		{
			return await ReadInternal(buffer, offset, count, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<int> ReadInternal(byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
		{
			ValidateReadParameters(buffer, offset, count);
			if (_position == _length)
			{
				if (!_allowBlobModifications)
				{
					return 0;
				}
				_length = await GetBlobLengthInternal(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (_position == _length)
				{
					return 0;
				}
			}
			if (_bufferPosition == _bufferLength || _bufferInvalidated)
			{
				if (await DownloadInternal(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) == 0)
				{
					return 0;
				}
				_bufferInvalidated = false;
			}
			int num = Math.Min(_bufferLength - _bufferPosition, count);
			Array.Copy(_buffer, _bufferPosition, buffer, offset, num);
			_position += num;
			_bufferPosition += num;
			return num;
		}

		private async Task<int> DownloadInternal(bool async, CancellationToken cancellationToken)
		{
			HttpRange range = new HttpRange(_position, _bufferSize);
			if (_predictEncryptedRangeAdjustment(range).Offset >= _length)
			{
				return 0;
			}
			Response<IDownloadedContent> response = await _downloadInternalFunc(range, _validationOptions, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			using Stream networkStream = response.Value.Content;
			long value = GetResponseRange(response.GetRawResponse()).Length.Value;
			int totalCopiedBytes = 0;
			int remainingBytes = (int)value;
			int num;
			do
			{
				num = ((!async) ? networkStream.Read(_buffer, totalCopiedBytes, remainingBytes) : (await networkStream.ReadAsync(_buffer, totalCopiedBytes, remainingBytes, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
				totalCopiedBytes += num;
				remainingBytes -= num;
			}
			while (num != 0);
			_bufferPosition = 0;
			_bufferLength = totalCopiedBytes;
			_length = GetBlobLengthFromResponse(response.GetRawResponse());
			if (_validationOptions != null && _validationOptions.ChecksumAlgorithm != StorageChecksumAlgorithm.None && !_validationOptions.AutoValidateChecksum)
			{
				ContentHasher.AssertResponseHashMatch(_buffer, _bufferPosition, _bufferLength, _validationOptions.ChecksumAlgorithm, response.GetRawResponse());
			}
			return totalCopiedBytes;
		}

		private static void ValidateReadParameters(byte[] buffer, int offset, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer", "buffer cannot be null.");
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", "offset cannot be less than 0.");
			}
			if (offset > buffer.Length)
			{
				throw new ArgumentOutOfRangeException("offset", "offset cannot exceed buffer length.");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", "count cannot be less than 0.");
			}
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (_buffer != null)
			{
				ArrayPool<byte>.Shared.Return(_buffer, clearArray: true);
				_buffer = null;
			}
		}

		private async Task<long> GetBlobLengthInternal(bool async, CancellationToken cancellationToken)
		{
			(await _getPropertiesInternalFunc(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).GetRawResponse().Headers.TryGetValue("Content-Length", out string value);
			if (value == null)
			{
				throw new ArgumentException(HttpHeader.Names.ContentLength + " header is missing on get properties response.");
			}
			return Convert.ToInt64(value, CultureInfo.InvariantCulture);
		}

		private static long GetBlobLengthFromResponse(Response response)
		{
			response.Headers.TryGetValue("Content-Range", out string value);
			if (value == null)
			{
				throw new ArgumentException("Content-Range header is missing on download response.");
			}
			return Convert.ToInt64(value.Split(new char[1] { '/' })[1], CultureInfo.InvariantCulture);
		}

		private static HttpRange GetResponseRange(Response response)
		{
			response.Headers.TryGetValue("Content-Range", out string value);
			if (value == null)
			{
				throw new InvalidOperationException("Content-Range header is missing on download response.");
			}
			string[] array = value.Split(new char[1] { '/' })[0].Split(new char[1] { '-' });
			long num = Convert.ToInt64(array[0].Split(new char[1] { ' ' })[1], CultureInfo.InvariantCulture);
			long num2 = Convert.ToInt64(array[1], CultureInfo.InvariantCulture);
			return new HttpRange(num, num2 - num + 1);
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			long num = CalculateNewPosition(offset, origin);
			if (num == _position)
			{
				return _position;
			}
			if (num < 0)
			{
				throw new ArgumentException(string.Format("New {0} cannot be less than 0.  Value was {1}", "offset", num), "offset");
			}
			if (num > _length)
			{
				throw new ArgumentException("You cannot seek past the last known length of the underlying blob or file.", "offset");
			}
			long num2 = _position - _bufferPosition;
			if (num < _position && num >= num2)
			{
				_bufferPosition = (int)(num - num2);
				_position = num;
				return num;
			}
			long num3 = _position + (_bufferLength - _bufferPosition);
			if (num > _position && num < num3)
			{
				_bufferPosition = (int)(num - num2);
				_position = num;
				return num;
			}
			_bufferInvalidated = true;
			_position = num;
			return num;
		}

		internal long CalculateNewPosition(long offset, SeekOrigin origin)
		{
			switch (origin)
			{
			case SeekOrigin.Begin:
				return offset;
			case SeekOrigin.Current:
				return _position + offset;
			case SeekOrigin.End:
				if (_allowBlobModifications)
				{
					throw new ArgumentException("Cannot Seek with SeekOrigin.End on a growing blob or file.  Call Stream.Seek(Stream.Length, SeekOrigin.Begin) to get to the end of known data.", "origin");
				}
				return _length + offset;
			default:
				throw new ArgumentException("Unknown $SeekOrigin value", "origin");
			}
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			throw new NotSupportedException();
		}

		public override void Flush()
		{
		}

		public override Task FlushAsync(CancellationToken cancellationToken)
		{
			return Task.CompletedTask;
		}
	}
	internal static class TransferValidationOptionsExtensions
	{
		public static StorageChecksumAlgorithm ResolveAuto(this StorageChecksumAlgorithm checksumAlgorithm)
		{
			if (checksumAlgorithm == StorageChecksumAlgorithm.Auto)
			{
				return StorageChecksumAlgorithm.StorageCrc64;
			}
			return checksumAlgorithm;
		}

		public static UploadTransferValidationOptions ToValidationOptions(this byte[] md5)
		{
			if (md5 != null)
			{
				return new UploadTransferValidationOptions
				{
					ChecksumAlgorithm = StorageChecksumAlgorithm.MD5,
					PrecalculatedChecksum = md5
				};
			}
			return null;
		}

		public static DownloadTransferValidationOptions ToValidationOptions(this bool requestTransactionalMD5)
		{
			if (!requestTransactionalMD5)
			{
				return null;
			}
			return new DownloadTransferValidationOptions
			{
				ChecksumAlgorithm = StorageChecksumAlgorithm.MD5,
				AutoValidateChecksum = false
			};
		}

		public static void CopyTo(this TransferValidationOptions source, TransferValidationOptions dest)
		{
			source.Upload.CopyTo(dest.Upload);
			source.Download.CopyTo(dest.Download);
		}

		public static void CopyTo(this UploadTransferValidationOptions source, UploadTransferValidationOptions dest)
		{
			dest.ChecksumAlgorithm = source.ChecksumAlgorithm;
			dest.PrecalculatedChecksum = source.PrecalculatedChecksum;
		}

		public static void CopyTo(this DownloadTransferValidationOptions source, DownloadTransferValidationOptions dest)
		{
			dest.ChecksumAlgorithm = source.ChecksumAlgorithm;
			dest.AutoValidateChecksum = source.AutoValidateChecksum;
		}
	}
	internal class StorageBearerTokenChallengeAuthorizationPolicy : BearerTokenAuthenticationPolicy
	{
		private volatile string[] _scopes;

		private volatile string tenantId;

		private readonly bool _enableTenantDiscovery;

		public StorageBearerTokenChallengeAuthorizationPolicy(TokenCredential credential, string scope, bool enableTenantDiscovery)
			: base(credential, scope)
		{
			Azure.Core.Argument.AssertNotNullOrEmpty(scope, "scope");
			_scopes = new string[1] { scope };
			_enableTenantDiscovery = enableTenantDiscovery;
		}

		public StorageBearerTokenChallengeAuthorizationPolicy(TokenCredential credential, IEnumerable<string> scopes, bool enableTenantDiscovery)
			: base(credential, scopes)
		{
			Azure.Core.Argument.AssertNotNull(scopes, "scopes");
			_scopes = scopes.ToArray();
			_enableTenantDiscovery = enableTenantDiscovery;
		}

		protected override void AuthorizeRequest(HttpMessage message)
		{
			AuthorizeRequestInternal(message, async: false).EnsureCompleted();
		}

		protected override ValueTask AuthorizeRequestAsync(HttpMessage message)
		{
			return AuthorizeRequestInternal(message, async: true);
		}

		private async ValueTask AuthorizeRequestInternal(HttpMessage message, bool async)
		{
			if (tenantId != null || !_enableTenantDiscovery)
			{
				TokenRequestContext context = new TokenRequestContext(_scopes, message.Request.ClientRequestId, null, tenantId, isCaeEnabled: false);
				if (async)
				{
					await AuthenticateAndAuthorizeRequestAsync(message, context).ConfigureAwait(continueOnCapturedContext: false);
				}
				else
				{
					AuthenticateAndAuthorizeRequest(message, context);
				}
			}
		}

		protected override bool AuthorizeRequestOnChallenge(HttpMessage message)
		{
			return AuthorizeRequestOnChallengeInternalAsync(message, async: false).EnsureCompleted();
		}

		protected override ValueTask<bool> AuthorizeRequestOnChallengeAsync(HttpMessage message)
		{
			return AuthorizeRequestOnChallengeInternalAsync(message, async: true);
		}

		private async ValueTask<bool> AuthorizeRequestOnChallengeInternalAsync(HttpMessage message, bool async)
		{
			try
			{
				string challengeParameterFromResponse = Azure.Core.AuthorizationChallengeParser.GetChallengeParameterFromResponse(message.Response, "Bearer", "authorization_uri");
				tenantId = new Uri(challengeParameterFromResponse).Segments[1].Trim(new char[1] { '/' });
				string challengeParameterFromResponse2 = Azure.Core.AuthorizationChallengeParser.GetChallengeParameterFromResponse(message.Response, "Bearer", "resource_id");
				if (challengeParameterFromResponse2 != null)
				{
					challengeParameterFromResponse2 += "/.default";
					_scopes = new string[1] { challengeParameterFromResponse2 };
				}
				TokenRequestContext context = new TokenRequestContext(_scopes, message.Request.ClientRequestId, null, tenantId, isCaeEnabled: false);
				if (async)
				{
					await AuthenticateAndAuthorizeRequestAsync(message, context).ConfigureAwait(continueOnCapturedContext: false);
				}
				else
				{
					AuthenticateAndAuthorizeRequest(message, context);
				}
				return true;
			}
			catch
			{
				return false;
			}
		}
	}
}
namespace Azure.Storage.Internal.Avro
{
	internal static class AvroParser
	{
		public static async Task<byte[]> ReadFixedBytesAsync(Stream stream, int length, bool async, CancellationToken cancellationToken)
		{
			byte[] data = new byte[length];
			int start = 0;
			while (length > 0)
			{
				int num = ((!async) ? stream.Read(data, start, length) : (await stream.ReadAsync(data, start, length, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
				int num2 = num;
				start += num2;
				length -= num2;
				if (num2 <= 0)
				{
					return data;
				}
			}
			return data;
		}

		private static async Task<byte> ReadByteAsync(Stream stream, bool async, CancellationToken cancellationToken)
		{
			return (await ReadFixedBytesAsync(stream, 1, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))[0];
		}

		private static async Task<long> ReadZigZagLongAsync(Stream stream, bool async, CancellationToken cancellationToken)
		{
			byte b = await ReadByteAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ulong next = (ulong)b & 0x7FuL;
			int shift = 7;
			while ((b & 0x80) != 0)
			{
				b = await ReadByteAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				next |= ((ulong)b & 0x7FuL) << shift;
				shift += 7;
			}
			long num = (long)next;
			return -(num & 1) ^ ((num >> 1) & 0x7FFFFFFFFFFFFFFFL);
		}

		public static Task<object> ReadNullAsync()
		{
			return Task.FromResult<object>(null);
		}

		public static async Task<bool> ReadBoolAsync(Stream stream, bool async, CancellationToken cancellationToken)
		{
			if (await ReadByteAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false) != 0)
			{
				return true;
			}
			return false;
		}

		public static async Task<long> ReadLongAsync(Stream stream, bool async, CancellationToken cancellationToken)
		{
			return await ReadZigZagLongAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public static async Task<int> ReadIntAsync(Stream stream, bool async, CancellationToken cancellationToken)
		{
			return (int)(await ReadLongAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		public static async Task<float> ReadFloatAsync(Stream stream, bool async, CancellationToken cancellationToken)
		{
			return BitConverter.ToSingle(await ReadFixedBytesAsync(stream, 4, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), 0);
		}

		public static async Task<double> ReadDoubleAsync(Stream stream, bool async, CancellationToken cancellationToken)
		{
			return BitConverter.ToDouble(await ReadFixedBytesAsync(stream, 8, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), 0);
		}

		public static async Task<byte[]> ReadBytesAsync(Stream stream, bool async, CancellationToken cancellationToken)
		{
			return await ReadFixedBytesAsync(stream, await ReadIntAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public static async Task<string> ReadStringAsync(Stream stream, bool async, CancellationToken cancellationToken)
		{
			byte[] bytes = await ReadBytesAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return Encoding.UTF8.GetString(bytes);
		}

		private static async Task<KeyValuePair<string, T>> ReadMapPairAsync<T>(Stream stream, Func<Stream, bool, CancellationToken, Task<T>> parseItemAsync, bool async, CancellationToken cancellationToken)
		{
			return new KeyValuePair<string, T>(await ReadStringAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), await parseItemAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		public static async Task<Dictionary<string, T>> ReadMapAsync<T>(Stream stream, Func<Stream, bool, CancellationToken, Task<T>> parseItemAsync, bool async, CancellationToken cancellationToken)
		{
			Func<Stream, bool, CancellationToken, Task<KeyValuePair<string, T>>> parseItemAsync2 = async (Stream s, bool async2, CancellationToken cancellationToken2) => await ReadMapPairAsync(s, parseItemAsync, async2, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
			return (await ReadArrayAsync(stream, parseItemAsync2, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).ToDictionary();
		}

		private static async Task<IEnumerable<T>> ReadArrayAsync<T>(Stream stream, Func<Stream, bool, CancellationToken, Task<T>> parseItemAsync, bool async, CancellationToken cancellationToken)
		{
			List<T> items = new List<T>();
			for (long length = await ReadLongAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false); length != 0L; length = await ReadLongAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false))
			{
				if (length < 0)
				{
					await ReadLongAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					length = -length;
				}
				while (length-- > 0)
				{
					items.Add(await parseItemAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
				}
			}
			return items;
		}

		internal static List<T> Map<T>(this JsonElement array, Func<JsonElement, T> selector)
		{
			List<T> list = new List<T>();
			foreach (JsonElement item in array.EnumerateArray())
			{
				list.Add(selector(item));
			}
			return list;
		}

		internal static Dictionary<string, T> ToDictionary<T>(this IEnumerable<KeyValuePair<string, T>> values)
		{
			Dictionary<string, T> dictionary = new Dictionary<string, T>();
			foreach (KeyValuePair<string, T> value in values)
			{
				dictionary[value.Key] = value.Value;
			}
			return dictionary;
		}
	}
	internal abstract class AvroType
	{
		public abstract Task<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken);

		public static AvroType FromSchema(JsonElement schema)
		{
			return schema.ValueKind switch
			{
				JsonValueKind.String => FromStringSchema(schema), 
				JsonValueKind.Array => FromArraySchema(schema), 
				JsonValueKind.Object => FromObjectSchema(schema), 
				_ => throw new InvalidOperationException($"Unexpected JSON Element: {schema}"), 
			};
		}

		private static AvroType FromStringSchema(JsonElement schema)
		{
			string text = schema.GetString();
			return text switch
			{
				"null" => new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.Null
				}, 
				"boolean" => new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.Boolean
				}, 
				"int" => new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.Int
				}, 
				"long" => new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.Long
				}, 
				"float" => new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.Float
				}, 
				"double" => new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.Double
				}, 
				"bytes" => new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.Bytes
				}, 
				"string" => new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.String
				}, 
				_ => throw new InvalidOperationException($"Unexpected Avro type {text} in {schema}"), 
			};
		}

		private static AvroType FromArraySchema(JsonElement schema)
		{
			return new AvroUnionType
			{
				Types = schema.Map(FromSchema)
			};
		}

		private static AvroType FromObjectSchema(JsonElement schema)
		{
			JsonElement value = schema.GetProperty("type");
			string text = value.GetString();
			switch (text)
			{
			case "null":
				return new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.Null
				};
			case "boolean":
				return new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.Boolean
				};
			case "int":
				return new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.Int
				};
			case "long":
				return new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.Long
				};
			case "float":
				return new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.Float
				};
			case "double":
				return new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.Double
				};
			case "bytes":
				return new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.Bytes
				};
			case "string":
				return new AvroPrimitiveType
				{
					Primitive = AvroPrimitive.String
				};
			case "record":
			{
				if (schema.TryGetProperty("aliases", out value))
				{
					throw new InvalidOperationException($"Unexpected aliases on {schema}");
				}
				string schema2 = schema.GetProperty("name").GetString();
				Dictionary<string, AvroType> dictionary = new Dictionary<string, AvroType>();
				foreach (JsonElement item in schema.GetProperty("fields").EnumerateArray())
				{
					dictionary[item.GetProperty("name").GetString()] = FromSchema(item.GetProperty("type"));
				}
				return new AvroRecordType
				{
					Schema = schema2,
					Fields = dictionary
				};
			}
			case "enum":
				if (schema.TryGetProperty("aliases", out value))
				{
					throw new InvalidOperationException($"Unexpected aliases on {schema}");
				}
				return new AvroEnumType
				{
					Symbols = schema.GetProperty("symbols").Map((JsonElement s) => s.GetString())
				};
			case "map":
				return new AvroMapType
				{
					ItemType = FromSchema(schema.GetProperty("values"))
				};
			default:
				throw new InvalidOperationException($"Unexpected Avro type {text} in {schema}");
			}
		}
	}
	internal enum AvroPrimitive
	{
		Null,
		Boolean,
		Int,
		Long,
		Float,
		Double,
		Bytes,
		String
	}
	internal class AvroPrimitiveType : AvroType
	{
		public AvroPrimitive Primitive { get; set; }

		public override async Task<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken)
		{
			return Primitive switch
			{
				AvroPrimitive.Null => await AvroParser.ReadNullAsync().ConfigureAwait(continueOnCapturedContext: false), 
				AvroPrimitive.Boolean => await AvroParser.ReadBoolAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), 
				AvroPrimitive.Int => await AvroParser.ReadIntAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), 
				AvroPrimitive.Long => await AvroParser.ReadLongAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), 
				AvroPrimitive.Float => await AvroParser.ReadFloatAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), 
				AvroPrimitive.Double => await AvroParser.ReadDoubleAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), 
				AvroPrimitive.Bytes => await AvroParser.ReadBytesAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), 
				AvroPrimitive.String => await AvroParser.ReadStringAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), 
				_ => throw new InvalidOperationException("Unknown Avro Primitive!"), 
			};
		}
	}
	internal class AvroEnumType : AvroType
	{
		public IReadOnlyList<string> Symbols { get; set; }

		public override async Task<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken)
		{
			int index = await AvroParser.ReadIntAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return Symbols[index];
		}
	}
	internal class AvroUnionType : AvroType
	{
		public IReadOnlyList<AvroType> Types { get; set; }

		public override async Task<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken)
		{
			int index = await AvroParser.ReadIntAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return await Types[index].ReadAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
	}
	internal class AvroMapType : AvroType
	{
		public AvroType ItemType { get; set; }

		public override async Task<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken)
		{
			Func<Stream, bool, CancellationToken, Task<object>> parseItemAsync = async (Stream s, bool a, CancellationToken c) => await ItemType.ReadAsync(s, a, c).ConfigureAwait(continueOnCapturedContext: false);
			return await AvroParser.ReadMapAsync(stream, parseItemAsync, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}
	}
	internal class AvroRecordType : AvroType
	{
		public string Schema { get; set; }

		public IReadOnlyDictionary<string, AvroType> Fields { get; set; }

		public override async Task<object> ReadAsync(Stream stream, bool async, CancellationToken cancellationToken)
		{
			Dictionary<string, object> record = new Dictionary<string, object> { ["$schema"] = Schema };
			foreach (KeyValuePair<string, AvroType> field in Fields)
			{
				Dictionary<string, object> dictionary = record;
				string key = field.Key;
				dictionary[key] = await field.Value.ReadAsync(stream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			return record;
		}
	}
	internal class AvroConstants
	{
		public const int SyncMarkerSize = 16;

		public static byte[] InitBytes = new byte[4] { 79, 98, 106, 1 };

		public const string CodecKey = "avro.codec";

		public const string SchemaKey = "avro.schema";

		public const string Null = "null";

		public const string Boolean = "boolean";

		public const string Int = "int";

		public const string Long = "long";

		public const string Float = "float";

		public const string Double = "double";

		public const string Bytes = "bytes";

		public const string String = "string";

		public const string Record = "record";

		public const string Enum = "enum";

		public const string Map = "map";

		public const string Array = "array";

		public const string Union = "union";

		public const string Fixed = "fixed";

		public const string Aliases = "aliases";

		public const string Name = "name";

		public const string Fields = "fields";

		public const string Type = "type";

		public const string Symbols = "symbols";

		public const string Values = "values";
	}
	internal class AvroReader : IDisposable
	{
		private readonly Stream _dataStream;

		private readonly Stream _headerStream;

		private byte[] _syncMarker;

		private Dictionary<string, string> _metadata;

		private AvroType _itemType;

		private long _itemsRemainingInBlock;

		private bool _initalized;

		private bool _disposed;

		private readonly long _initialBlockOffset;

		public virtual long BlockOffset { get; private set; }

		public virtual long ObjectIndex { get; private set; }

		public AvroReader(Stream dataStream)
		{
			if (dataStream.CanSeek)
			{
				_dataStream = dataStream;
				_headerStream = dataStream;
			}
			else
			{
				_dataStream = new StreamWithPosition(dataStream, 0L);
				_headerStream = _dataStream;
			}
			_metadata = new Dictionary<string, string>();
			_initalized = false;
		}

		public AvroReader(Stream dataStream, Stream headerStream, long currentBlockOffset, long indexWithinCurrentBlock)
		{
			if (dataStream.CanSeek)
			{
				_dataStream = dataStream;
			}
			else
			{
				_dataStream = new StreamWithPosition(dataStream, 0L);
			}
			if (headerStream.CanSeek)
			{
				_headerStream = headerStream;
			}
			else
			{
				_headerStream = new StreamWithPosition(headerStream, 0L);
			}
			_metadata = new Dictionary<string, string>();
			_initalized = false;
			_initialBlockOffset = currentBlockOffset;
			BlockOffset = currentBlockOffset;
			ObjectIndex = indexWithinCurrentBlock;
			_initalized = false;
		}

		public AvroReader()
		{
		}

		public virtual async Task Initalize(bool async, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!(await AvroParser.ReadFixedBytesAsync(_headerStream, AvroConstants.InitBytes.Length, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).SequenceEqual(AvroConstants.InitBytes))
			{
				throw new ArgumentException("Stream is not an Avro file.");
			}
			_metadata = await AvroParser.ReadMapAsync(_headerStream, AvroParser.ReadStringAsync, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			_metadata.TryGetValue("avro.codec", out var value);
			if (value != null && !(value == "null"))
			{
				throw new ArgumentException("Codecs are not supported");
			}
			_syncMarker = await AvroParser.ReadFixedBytesAsync(_headerStream, 16, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			using JsonDocument schema = JsonDocument.Parse(_metadata["avro.schema"]);
			_itemType = AvroType.FromSchema(schema.RootElement);
			if (BlockOffset == 0L)
			{
				BlockOffset = _initialBlockOffset + _dataStream.Position;
			}
			_itemsRemainingInBlock = await AvroParser.ReadLongAsync(_dataStream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			await AvroParser.ReadLongAsync(_dataStream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			_initalized = true;
			if (ObjectIndex > 0)
			{
				for (int i = 0; i < ObjectIndex; i++)
				{
					await _itemType.ReadAsync(_dataStream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					_itemsRemainingInBlock--;
				}
			}
		}

		public virtual bool HasNext()
		{
			if (_initalized)
			{
				return _itemsRemainingInBlock > 0;
			}
			return true;
		}

		public virtual async Task<object> Next(bool async, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (!_initalized)
			{
				await Initalize(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			if (!HasNext())
			{
				throw new ArgumentException("There are no more items in the stream");
			}
			object result = await _itemType.ReadAsync(_dataStream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			_itemsRemainingInBlock--;
			long objectIndex = ObjectIndex;
			ObjectIndex = objectIndex + 1;
			if (_itemsRemainingInBlock == 0L)
			{
				byte[] second = await AvroParser.ReadFixedBytesAsync(_dataStream, 16, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				BlockOffset = _initialBlockOffset + _dataStream.Position;
				ObjectIndex = 0L;
				if (!_syncMarker.SequenceEqual(second))
				{
					throw new ArgumentException("Stream is not a valid Avro file.");
				}
				try
				{
					_itemsRemainingInBlock = await AvroParser.ReadLongAsync(_dataStream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				catch (InvalidOperationException)
				{
				}
				if (_itemsRemainingInBlock > 0)
				{
					await AvroParser.ReadLongAsync(_dataStream, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
			}
			return result;
		}

		public void Dispose()
		{
			Dispose(disposing: true);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (!_disposed)
			{
				if (disposing)
				{
					_dataStream.Dispose();
					_headerStream.Dispose();
				}
				_disposed = true;
			}
		}
	}
	internal class StreamWithPosition : Stream
	{
		private readonly Stream _stream;

		private long _position;

		private bool _disposed;

		public override long Position
		{
			get
			{
				return _position;
			}
			set
			{
				throw new NotImplementedException();
			}
		}

		public override bool CanRead => _stream.CanRead;

		public override bool CanSeek => _stream.CanSeek;

		public override bool CanWrite => _stream.CanWrite;

		public override long Length => _stream.Length;

		public StreamWithPosition(Stream stream, long position = 0L)
		{
			_stream = stream;
			_position = position;
		}

		public override int ReadByte()
		{
			int num = _stream.ReadByte();
			if (num != -1)
			{
				_position++;
			}
			return num;
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			return ReadInternal(buffer, offset, count, async: false, default(CancellationToken)).EnsureCompleted();
		}

		public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
		{
			return await ReadInternal(buffer, offset, count, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<int> ReadInternal(byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
		{
			int num = ((!async) ? _stream.Read(buffer, offset, count) : (await _stream.ReadAsync(buffer, offset, count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
			int num2 = num;
			_position += num2;
			return num2;
		}

		public override IAsyncResult BeginRead(byte[] buffer, int offset, int count, AsyncCallback callback, object state)
		{
			return _stream.BeginRead(buffer, offset, count, callback, state);
		}

		public override int EndRead(IAsyncResult asyncResult)
		{
			int num = _stream.EndRead(asyncResult);
			_position += num;
			return num;
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			return _stream.Seek(offset, origin);
		}

		public override void SetLength(long value)
		{
			_stream.SetLength(value);
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			_stream.Write(buffer, offset, count);
		}

		public override void Flush()
		{
			_stream.Flush();
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (!_disposed && disposing)
			{
				_stream.Dispose();
				_disposed = true;
			}
		}
	}
}
namespace Azure.Storage.Cryptography
{
	internal class AuthenticatedRegionCryptoStream : Stream
	{
		private readonly Stream _innerStream;

		private readonly CryptoStreamMode _mode;

		private readonly IAuthenticatedCryptographicTransform _transform;

		private bool _flushedFinal;

		private readonly byte[] _buffer;

		private int _bufferPos;

		private int _bufferPopulatedLength;

		private readonly int _bufferLength;

		private readonly int _tempRefillBufferSize;

		public override bool CanRead => _mode == CryptoStreamMode.Read;

		public override bool CanWrite
		{
			get
			{
				if (_mode == CryptoStreamMode.Write)
				{
					return !_flushedFinal;
				}
				return false;
			}
		}

		public override bool CanSeek => false;

		public override long Length
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override long Position
		{
			get
			{
				throw new NotSupportedException();
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public AuthenticatedRegionCryptoStream(Stream innerStream, IAuthenticatedCryptographicTransform transform, int regionDataSize, CryptoStreamMode streamMode)
		{
			_innerStream = innerStream;
			_transform = transform;
			_mode = streamMode;
			int num;
			if ((transform.TransformMode == TransformMode.Encrypt && streamMode == CryptoStreamMode.Write) || (transform.TransformMode == TransformMode.Decrypt && streamMode == CryptoStreamMode.Read))
			{
				num = regionDataSize;
				_tempRefillBufferSize = transform.NonceLength + regionDataSize + transform.TagLength;
			}
			else
			{
				if ((transform.TransformMode != TransformMode.Encrypt || streamMode != CryptoStreamMode.Read) && (transform.TransformMode != TransformMode.Decrypt || streamMode != CryptoStreamMode.Write))
				{
					throw Azure.Storage.Errors.InvalidArgument("transform");
				}
				num = transform.NonceLength + regionDataSize + transform.TagLength;
				_tempRefillBufferSize = regionDataSize;
			}
			_buffer = ArrayPool<byte>.Shared.Rent(num);
			_bufferLength = num;
			_bufferPopulatedLength = _bufferLength;
			_bufferPos = streamMode switch
			{
				CryptoStreamMode.Read => _bufferLength, 
				CryptoStreamMode.Write => 0, 
				_ => throw Azure.Storage.Errors.InvalidArgument("streamMode"), 
			};
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			return ReadInternal(buffer, offset, count, async: false, default(CancellationToken)).EnsureCompleted();
		}

		public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
		{
			return await ReadInternal(buffer, offset, count, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<int> ReadInternal(byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
		{
			if (!CanRead)
			{
				throw new NotSupportedException();
			}
			if (_bufferPos >= _bufferLength)
			{
				byte[] transformInputBuffer = null;
				try
				{
					transformInputBuffer = ArrayPool<byte>.Shared.Rent(_tempRefillBufferSize);
					int totalRead = 0;
					while (totalRead < _tempRefillBufferSize)
					{
						int num = ((!async) ? _innerStream.Read(transformInputBuffer, totalRead, _tempRefillBufferSize - totalRead) : (await _innerStream.ReadAsync(transformInputBuffer, totalRead, _tempRefillBufferSize - totalRead, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
						int num2 = num;
						totalRead += num2;
						if (num2 == 0)
						{
							break;
						}
					}
					if (totalRead == 0)
					{
						return 0;
					}
					_bufferPopulatedLength = _transform.TransformAuthenticationBlock(new ReadOnlySpan<byte>(transformInputBuffer, 0, totalRead), new Span<byte>(_buffer, 0, _bufferLength));
					_bufferPos = 0;
				}
				finally
				{
					ArrayPool<byte>.Shared.Return(transformInputBuffer);
				}
			}
			int num3 = Math.Min(count, _bufferPopulatedLength - _bufferPos);
			Array.Copy(_buffer, _bufferPos, buffer, offset, num3);
			_bufferPos += num3;
			return num3;
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			WriteInternal(buffer, offset, count, async: false, default(CancellationToken)).EnsureCompleted();
		}

		public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
		{
			await WriteInternal(buffer, offset, count, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task WriteInternal(byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
		{
			if (!CanWrite)
			{
				throw new NotSupportedException();
			}
			int num;
			for (int written = 0; written < count; written += num)
			{
				await FlushIfReadyInternal(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				num = Math.Min(count - written, _bufferLength - _bufferPos);
				Array.Copy(buffer, offset + written, _buffer, _bufferPos, num);
				_bufferPos += num;
			}
		}

		public override void Flush()
		{
			FlushIfReadyInternal(async: false, default(CancellationToken)).Wait();
		}

		public override async Task FlushAsync(CancellationToken cancellationToken)
		{
			await FlushIfReadyInternal(async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task FlushIfReadyInternal(bool async, CancellationToken cancellationToken)
		{
			if (!CanWrite)
			{
				throw new NotSupportedException();
			}
			if (_bufferPos < _bufferLength)
			{
				return;
			}
			byte[] transformedContentsBuffer = null;
			try
			{
				transformedContentsBuffer = ArrayPool<byte>.Shared.Rent(_tempRefillBufferSize);
				int count = _transform.TransformAuthenticationBlock(new ReadOnlySpan<byte>(_buffer, 0, _bufferLength), transformedContentsBuffer);
				if (async)
				{
					await _innerStream.WriteAsync(transformedContentsBuffer, 0, count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					await _innerStream.FlushAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				else
				{
					_innerStream.Write(transformedContentsBuffer, 0, count);
					_innerStream.Flush();
				}
				_bufferPos = 0;
			}
			finally
			{
				ArrayPool<byte>.Shared.Return(transformedContentsBuffer);
			}
		}

		public async Task FlushFinalInternal(bool async, CancellationToken cancellationToken)
		{
			if (!CanWrite)
			{
				throw new NotSupportedException();
			}
			if (_flushedFinal)
			{
				return;
			}
			await FlushIfReadyInternal(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (_bufferPos != 0)
			{
				byte[] transformedContentsBuffer = null;
				try
				{
					transformedContentsBuffer = ArrayPool<byte>.Shared.Rent(_tempRefillBufferSize);
					int count = _transform.TransformAuthenticationBlock(new ReadOnlySpan<byte>(_buffer, 0, _bufferPos), transformedContentsBuffer);
					if (async)
					{
						await _innerStream.WriteAsync(transformedContentsBuffer, 0, count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						await _innerStream.FlushAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						_innerStream.Write(transformedContentsBuffer, 0, count);
						_innerStream.Flush();
					}
				}
				finally
				{
					ArrayPool<byte>.Shared.Return(transformedContentsBuffer);
				}
			}
			_flushedFinal = true;
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		protected override void Dispose(bool disposing)
		{
			if (CanWrite)
			{
				FlushFinalInternal(async: false, default(CancellationToken)).EnsureCompleted();
			}
			ArrayPool<byte>.Shared.Return(_buffer);
			base.Dispose(disposing);
			_transform.Dispose();
			_innerStream?.Dispose();
		}
	}
	internal class ClientSideDecryptor
	{
		internal class ContentEncryptionKeyCache
		{
			public Memory<byte>? Key { get; set; }
		}

		private static readonly AsyncLocal<ContentEncryptionKeyCache> s_contentEncryptionKeyCache = new AsyncLocal<ContentEncryptionKeyCache>();

		private readonly IKeyEncryptionKey _potentialCachedIKeyEncryptionKey;

		private readonly IKeyEncryptionKeyResolver _keyResolver;

		public ClientSideDecryptor(ClientSideEncryptionOptions options)
		{
			_potentialCachedIKeyEncryptionKey = options.KeyEncryptionKey;
			_keyResolver = options.KeyResolver;
		}

		public async Task<Stream> DecryptReadInternal(Stream ciphertext, EncryptionData encryptionData, bool ivInStream, bool noPadding, bool async, CancellationToken cancellationToken)
		{
			return encryptionData.EncryptionAgent.EncryptionVersion switch
			{
				ClientSideEncryptionVersion.V1_0 => await DecryptReadInternalV1_0(ciphertext, encryptionData, ivInStream, noPadding, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), 
				ClientSideEncryptionVersion.V2_0 => await DecryptInternalV2_0(ciphertext, encryptionData, CryptoStreamMode.Read, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), 
				_ => throw Azure.Storage.Errors.ClientSideEncryption.BadEncryptionAgent(encryptionData.EncryptionAgent.EncryptionVersion.ToString()), 
			};
		}

		public async Task<Stream> DecryptWholeContentWriteInternal(Stream plaintextDestination, EncryptionData encryptionData, bool async, CancellationToken cancellationToken)
		{
			return encryptionData.EncryptionAgent.EncryptionVersion switch
			{
				ClientSideEncryptionVersion.V1_0 => await DecryptWholeContentWriteInternalV1_0(plaintextDestination, encryptionData, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), 
				ClientSideEncryptionVersion.V2_0 => await DecryptInternalV2_0(plaintextDestination, encryptionData, CryptoStreamMode.Write, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), 
				_ => throw Azure.Storage.Errors.ClientSideEncryption.BadEncryptionAgent(encryptionData.EncryptionAgent.EncryptionVersion.ToString()), 
			};
		}

		private async Task<Stream> DecryptInternalV2_0(Stream ciphertext, EncryptionData encryptionData, CryptoStreamMode mode, bool async, CancellationToken cancellationToken)
		{
			if (encryptionData.EncryptionAgent.EncryptionAlgorithm != ClientSideEncryptionAlgorithm.AesGcm256)
			{
				throw Azure.Storage.Errors.ClientSideEncryption.BadEncryptionAlgorithm(encryptionData.EncryptionAgent.EncryptionAlgorithm.ToString());
			}
			Memory<byte> memory = await GetContentEncryptionKeyAsync(encryptionData, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			int dataLength = encryptionData.EncryptedRegionInfo.DataLength;
			return WrapStreamV2_0(ciphertext, mode, memory.ToArray(), dataLength);
		}

		private static Stream WrapStreamV2_0(Stream contentStream, CryptoStreamMode mode, byte[] contentEncryptionKey, int authRegionPlaintextSize)
		{
			GcmAuthenticatedCryptographicTransform transform = new GcmAuthenticatedCryptographicTransform(contentEncryptionKey, TransformMode.Decrypt);
			return new AuthenticatedRegionCryptoStream(contentStream, transform, authRegionPlaintextSize, mode);
		}

		private async Task<Stream> DecryptReadInternalV1_0(Stream ciphertext, EncryptionData encryptionData, bool ivInStream, bool noPadding, bool async, CancellationToken cancellationToken)
		{
			Memory<byte> contentEncryptionKey = await GetContentEncryptionKeyAsync(encryptionData, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			Stream result;
			if (encryptionData != null)
			{
				byte[] IV;
				if (!ivInStream)
				{
					IV = encryptionData.ContentEncryptionIV;
				}
				else
				{
					IV = new byte[16];
					if (async)
					{
						await ciphertext.ReadAsync(IV, 0, IV.Length, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ciphertext.Read(IV, 0, IV.Length);
					}
				}
				result = WrapStreamV1_0(ciphertext, contentEncryptionKey.ToArray(), encryptionData, IV, noPadding, CryptoStreamMode.Read);
			}
			else
			{
				result = ciphertext;
			}
			return result;
		}

		private async Task<Stream> DecryptWholeContentWriteInternalV1_0(Stream plaintextDestination, EncryptionData encryptionData, bool async, CancellationToken cancellationToken)
		{
			if (encryptionData != null)
			{
				plaintextDestination = WrapStreamV1_0(plaintextDestination, (await GetContentEncryptionKeyAsync(encryptionData, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).ToArray(), encryptionData, encryptionData.ContentEncryptionIV, noPadding: false, CryptoStreamMode.Write);
			}
			return plaintextDestination;
		}

		private static Stream WrapStreamV1_0(Stream contentStream, byte[] contentEncryptionKey, EncryptionData encryptionData, byte[] iv, bool noPadding, CryptoStreamMode mode)
		{
			if (encryptionData.EncryptionAgent.EncryptionAlgorithm == ClientSideEncryptionAlgorithm.AesCbc256)
			{
				using (Aes aes = new AesCryptoServiceProvider())
				{
					aes.IV = iv ?? encryptionData.ContentEncryptionIV;
					aes.Key = contentEncryptionKey;
					if (noPadding)
					{
						aes.Padding = PaddingMode.None;
					}
					return new CryptoStream(new BufferedStream(contentStream), aes.CreateDecryptor(), mode);
				}
			}
			throw Azure.Storage.Errors.ClientSideEncryption.BadEncryptionAlgorithm(encryptionData.EncryptionAgent.EncryptionAlgorithm.ToString());
		}

		internal async Task<Memory<byte>> GetContentEncryptionKeyAsync(EncryptionData encryptionData, bool async, CancellationToken cancellationToken)
		{
			if (s_contentEncryptionKeyCache.Value?.Key.HasValue ?? false)
			{
				return s_contentEncryptionKeyCache.Value.Key.Value;
			}
			IKeyEncryptionKey keyEncryptionKey = null;
			if (encryptionData.WrappedContentKey.KeyId == _potentialCachedIKeyEncryptionKey?.KeyId)
			{
				keyEncryptionKey = _potentialCachedIKeyEncryptionKey;
			}
			else if (_keyResolver != null)
			{
				IKeyEncryptionKey keyEncryptionKey2 = ((!async) ? _keyResolver.Resolve(encryptionData.WrappedContentKey.KeyId, cancellationToken) : (await _keyResolver.ResolveAsync(encryptionData.WrappedContentKey.KeyId, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
				keyEncryptionKey = keyEncryptionKey2;
			}
			if (keyEncryptionKey == null)
			{
				throw Azure.Storage.Errors.ClientSideEncryption.KeyNotFound(encryptionData.WrappedContentKey.KeyId);
			}
			byte[] array = ((!async) ? keyEncryptionKey.UnwrapKey(encryptionData.WrappedContentKey.Algorithm, encryptionData.WrappedContentKey.EncryptedKey, cancellationToken) : (await keyEncryptionKey.UnwrapKeyAsync(encryptionData.WrappedContentKey.Algorithm, encryptionData.WrappedContentKey.EncryptedKey, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
			byte[] array2 = array;
			Memory<byte> memory;
			switch (encryptionData.EncryptionAgent.EncryptionVersion)
			{
			case ClientSideEncryptionVersion.V1_0:
				memory = array2;
				break;
			case ClientSideEncryptionVersion.V2_0:
				if (Encoding.UTF8.GetString(array2, 0, 8).Trim(new char[1]) != encryptionData.EncryptionAgent.EncryptionVersion.Serialize())
				{
					throw new CryptographicException("Encryption metadata has been tampered.");
				}
				memory = new Memory<byte>(array2).Slice(8).ToArray();
				break;
			default:
				throw Azure.Storage.Errors.InvalidArgument("encryptionData");
			}
			if (s_contentEncryptionKeyCache.Value != null)
			{
				s_contentEncryptionKeyCache.Value.Key = memory;
			}
			return memory;
		}

		internal static void BeginContentEncryptionKeyCaching(ContentEncryptionKeyCache cache = null)
		{
			s_contentEncryptionKeyCache.Value = cache ?? new ContentEncryptionKeyCache();
		}
	}
	internal static class ClientSideEncryptionOptionsExtensions
	{
		public static ClientSideEncryptionOptions Clone(this ClientSideEncryptionOptions options)
		{
			ClientSideEncryptionOptions clientSideEncryptionOptions = new ClientSideEncryptionOptions(options.EncryptionVersion);
			CopyOptions(options, clientSideEncryptionOptions);
			return clientSideEncryptionOptions;
		}

		internal static void CopyOptions(ClientSideEncryptionOptions source, ClientSideEncryptionOptions destination)
		{
			destination.KeyEncryptionKey = source.KeyEncryptionKey;
			destination.KeyResolver = source.KeyResolver;
			destination.KeyWrapAlgorithm = source.KeyWrapAlgorithm;
		}

		public static IClientSideEncryptor GetClientSideEncryptor(this ClientSideEncryptionOptions options)
		{
			return options.EncryptionVersion switch
			{
				ClientSideEncryptionVersion.V1_0 => new ClientSideEncryptorV1_0(options), 
				ClientSideEncryptionVersion.V2_0 => new ClientSideEncryptorV2_0(options), 
				_ => throw Azure.Storage.Errors.ClientSideEncryption.ClientSideEncryptionVersionNotSupported(), 
			};
		}
	}
	internal class ClientSideEncryptorV1_0 : IClientSideEncryptor
	{
		private readonly IKeyEncryptionKey _keyEncryptionKey;

		private readonly string _keyWrapAlgorithm;

		public ClientSideEncryptorV1_0(ClientSideEncryptionOptions options)
		{
			Azure.Core.Argument.AssertNotNull(options, "options");
			if (options.EncryptionVersion != ClientSideEncryptionVersion.V1_0)
			{
				Azure.Storage.Errors.InvalidArgument("EncryptionVersion");
			}
			_keyEncryptionKey = options.KeyEncryptionKey;
			_keyWrapAlgorithm = options.KeyWrapAlgorithm;
		}

		private void ValidateMembers()
		{
			if (_keyEncryptionKey == null || _keyWrapAlgorithm == null)
			{
				throw Azure.Storage.Errors.ClientSideEncryption.MissingRequiredEncryptionResources("_keyEncryptionKey", "_keyWrapAlgorithm");
			}
		}

		public long ExpectedOutputContentLength(long plaintextLength)
		{
			return CalculateExpectedOutputContentLength(plaintextLength);
		}

		public static long CalculateExpectedOutputContentLength(long plaintextLength)
		{
			return plaintextLength + (16 - plaintextLength % 16);
		}

		public async Task<(Stream Ciphertext, EncryptionData EncryptionData)> EncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken)
		{
			ValidateMembers();
			byte[] key = CreateKey(256);
			EncryptionData item = null;
			Stream item2 = null;
			using (Aes aes = new AesCryptoServiceProvider())
			{
				aes.Key = key;
				item = await CreateEncryptionDataInternal(aes, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				item2 = new CryptoStream(plaintext, aes.CreateEncryptor(), CryptoStreamMode.Read);
			}
			return (Ciphertext: item2, EncryptionData: item);
		}

		public async Task<(byte[] Ciphertext, EncryptionData EncryptionData)> BufferedEncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken)
		{
			ValidateMembers();
			byte[] key = CreateKey(256);
			EncryptionData encryptionData = null;
			MemoryStream ciphertext = new MemoryStream();
			byte[] item = null;
			using (Aes aes = new AesCryptoServiceProvider())
			{
				aes.Key = key;
				encryptionData = await CreateEncryptionDataInternal(aes, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				CryptoStream transformStream = new CryptoStream(ciphertext, aes.CreateEncryptor(), CryptoStreamMode.Write);
				if (async)
				{
					await plaintext.CopyToAsync(transformStream, 81920, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				else
				{
					plaintext.CopyTo(transformStream);
				}
				transformStream.FlushFinalBlock();
				item = ciphertext.ToArray();
			}
			return (Ciphertext: item, EncryptionData: encryptionData);
		}

		public async Task<Stream> EncryptedOpenWriteInternal(Func<EncryptionData, bool, CancellationToken, Task<Stream>> openWriteInternal, bool async, CancellationToken cancellationToken)
		{
			ValidateMembers();
			byte[] key = CreateKey(256);
			Stream result = null;
			using (Aes aes = new AesCryptoServiceProvider())
			{
				aes.Key = key;
				result = new CryptoStream(await openWriteInternal(await CreateEncryptionDataInternal(aes, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), aes.CreateEncryptor(), CryptoStreamMode.Write);
			}
			return result;
		}

		private async Task<EncryptionData> CreateEncryptionDataInternal(Aes aes, bool async, CancellationToken cancellationToken)
		{
			return await EncryptionData.CreateInternalV1_0(aes.IV, _keyWrapAlgorithm, aes.Key, _keyEncryptionKey, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private static byte[] CreateKey(int numBits)
		{
			using RNGCryptoServiceProvider rNGCryptoServiceProvider = new RNGCryptoServiceProvider();
			byte[] array = new byte[numBits / 8];
			rNGCryptoServiceProvider.GetBytes(array);
			return array;
		}
	}
	internal class ClientSideEncryptorV2_0 : IClientSideEncryptor
	{
		private readonly IKeyEncryptionKey _keyEncryptionKey;

		private readonly string _keyWrapAlgorithm;

		public ClientSideEncryptorV2_0(ClientSideEncryptionOptions options)
		{
			Azure.Core.Argument.AssertNotNull(options, "options");
			Azure.Core.Argument.AssertNotNull(options.KeyEncryptionKey, "KeyEncryptionKey");
			Azure.Core.Argument.AssertNotNull(options.KeyWrapAlgorithm, "KeyWrapAlgorithm");
			if (options.EncryptionVersion != ClientSideEncryptionVersion.V2_0)
			{
				Azure.Storage.Errors.InvalidArgument("EncryptionVersion");
			}
			_keyEncryptionKey = options.KeyEncryptionKey;
			_keyWrapAlgorithm = options.KeyWrapAlgorithm;
		}

		public long ExpectedOutputContentLength(long plaintextLength)
		{
			return CalculateExpectedOutputContentLength(plaintextLength);
		}

		public static long CalculateExpectedOutputContentLength(long plaintextLength)
		{
			long num = plaintextLength / 4194304;
			if (plaintextLength % 4194304 != 0L)
			{
				num++;
			}
			return plaintextLength + num * 28;
		}

		public async Task<(Stream Ciphertext, EncryptionData EncryptionData)> EncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken)
		{
			byte[] key = CreateKey(256);
			GcmAuthenticatedCryptographicTransform gcm = new GcmAuthenticatedCryptographicTransform(key, TransformMode.Encrypt);
			EncryptionData item = await CreateEncryptionDataInternal(key, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return (Ciphertext: new AuthenticatedRegionCryptoStream(plaintext, gcm, 4194304, CryptoStreamMode.Read), EncryptionData: item);
		}

		public async Task<(byte[] Ciphertext, EncryptionData EncryptionData)> BufferedEncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken)
		{
			byte[] key = CreateKey(256);
			using GcmAuthenticatedCryptographicTransform gcm = new GcmAuthenticatedCryptographicTransform(key, TransformMode.Encrypt);
			EncryptionData encryptionData = await CreateEncryptionDataInternal(key, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			MemoryStream ciphertext = new MemoryStream();
			AuthenticatedRegionCryptoStream transformStream = new AuthenticatedRegionCryptoStream(ciphertext, gcm, 4194304, CryptoStreamMode.Write);
			if (async)
			{
				await plaintext.CopyToAsync(transformStream, 81920, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			else
			{
				plaintext.CopyTo(transformStream);
			}
			await transformStream.FlushFinalInternal(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return (Ciphertext: ciphertext.ToArray(), EncryptionData: encryptionData);
		}

		public async Task<Stream> EncryptedOpenWriteInternal(Func<EncryptionData, bool, CancellationToken, Task<Stream>> openWriteInternal, bool async, CancellationToken cancellationToken)
		{
			byte[] generatedKey = CreateKey(256);
			EncryptionData arg = await CreateEncryptionDataInternal(generatedKey, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return new AuthenticatedRegionCryptoStream(transform: new GcmAuthenticatedCryptographicTransform(generatedKey, TransformMode.Encrypt), innerStream: await openWriteInternal(arg, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), regionDataSize: 4194304, streamMode: CryptoStreamMode.Write);
		}

		private async Task<EncryptionData> CreateEncryptionDataInternal(byte[] key, bool async, CancellationToken cancellationToken)
		{
			return await EncryptionData.CreateInternalV2_0(_keyWrapAlgorithm, key, _keyEncryptionKey, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private static byte[] CreateKey(int numBits)
		{
			using RNGCryptoServiceProvider rNGCryptoServiceProvider = new RNGCryptoServiceProvider();
			byte[] array = new byte[numBits / 8];
			rNGCryptoServiceProvider.GetBytes(array);
			return array;
		}
	}
	internal class GcmAuthenticatedCryptographicTransform : IAuthenticatedCryptographicTransform, IDisposable
	{
		private AesGcmWindows _gcm;

		private long _nonceCounter = 1L;

		public TransformMode TransformMode { get; }

		public int NonceLength => 12;

		public int TagLength => 16;

		public GcmAuthenticatedCryptographicTransform(byte[] key, TransformMode mode)
		{
			TransformMode = mode;
			_gcm = new AesGcmWindows(key);
		}

		public int TransformAuthenticationBlock(ReadOnlySpan<byte> input, Span<byte> output)
		{
			switch (TransformMode)
			{
			case TransformMode.Encrypt:
			{
				ReadOnlySpan<byte> newNonce = GetNewNonce();
				Span<byte> tag = new Span<byte>(new byte[TagLength]);
				newNonce.CopyTo(output.Slice(0, NonceLength));
				_gcm.Encrypt(newNonce, input, output.Slice(NonceLength, input.Length), tag);
				tag.CopyTo(output.Slice(NonceLength + input.Length, TagLength));
				return NonceLength + input.Length + TagLength;
			}
			case TransformMode.Decrypt:
			{
				int length = input.Length - NonceLength - TagLength;
				_gcm.Decrypt(input.Slice(0, NonceLength), input.Slice(NonceLength, length), input.Slice(input.Length - TagLength, TagLength), output.Slice(0, length));
				return input.Length - NonceLength - TagLength;
			}
			default:
				throw new InvalidOperationException("TransformMode invalid for this operation.");
			}
		}

		public void Dispose()
		{
			_gcm.Dispose();
		}

		private ReadOnlySpan<byte> GetNewNonce()
		{
			Span<byte> span = new Span<byte>(new byte[NonceLength]);
			int num = NonceLength - 8;
			new byte[4].CopyTo(span.Slice(0, num));
			BitConverter.GetBytes(_nonceCounter++).CopyTo(span.Slice(num, 8));
			return span;
		}
	}
	internal interface IAuthenticatedCryptographicTransform : IDisposable
	{
		TransformMode TransformMode { get; }

		int NonceLength { get; }

		int TagLength { get; }

		int TransformAuthenticationBlock(ReadOnlySpan<byte> input, Span<byte> output);
	}
	internal interface IClientSideEncryptor
	{
		long ExpectedOutputContentLength(long plaintextLength);

		Task<(Stream Ciphertext, EncryptionData EncryptionData)> EncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken);

		Task<(byte[] Ciphertext, EncryptionData EncryptionData)> BufferedEncryptInternal(Stream plaintext, bool async, CancellationToken cancellationToken);

		Task<Stream> EncryptedOpenWriteInternal(Func<EncryptionData, bool, CancellationToken, Task<Stream>> openWriteInternal, bool async, CancellationToken cancellationToken);
	}
}
namespace Azure.Storage.Cryptography.Models
{
	internal static class ClientSideEncryptionVersionExtensions
	{
		public static class ClientSideEncryptionVersionString
		{
			public const string V1_0 = "1.0";

			public const string V2_0 = "2.0";
		}

		public static string Serialize(this ClientSideEncryptionVersion version)
		{
			return version switch
			{
				ClientSideEncryptionVersion.V1_0 => "1.0", 
				ClientSideEncryptionVersion.V2_0 => "2.0", 
				_ => throw Azure.Storage.Errors.ClientSideEncryption.ClientSideEncryptionVersionNotSupported(), 
			};
		}

		public static ClientSideEncryptionVersion ToClientSideEncryptionVersion(this string versionString)
		{
			if (!(versionString == "1.0"))
			{
				if (versionString == "2.0")
				{
					return ClientSideEncryptionVersion.V2_0;
				}
				throw Azure.Storage.Errors.ClientSideEncryption.ClientSideEncryptionVersionNotSupported(versionString);
			}
			return ClientSideEncryptionVersion.V1_0;
		}
	}
	internal readonly struct ClientSideEncryptionAlgorithm
	{
		internal const string AesCbc256Value = "AES_CBC_256";

		internal const string AesGcm256Value = "AES_GCM_256";

		private readonly string _value;

		public static ClientSideEncryptionAlgorithm AesCbc256 { get; } = new ClientSideEncryptionAlgorithm("AES_CBC_256");

		public static ClientSideEncryptionAlgorithm AesGcm256 { get; } = new ClientSideEncryptionAlgorithm("AES_GCM_256");

		public ClientSideEncryptionAlgorithm(string value)
		{
			_value = value ?? throw new ArgumentNullException("value");
		}

		public static bool operator ==(ClientSideEncryptionAlgorithm left, ClientSideEncryptionAlgorithm right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(ClientSideEncryptionAlgorithm left, ClientSideEncryptionAlgorithm right)
		{
			return !left.Equals(right);
		}

		public static implicit operator ClientSideEncryptionAlgorithm(string value)
		{
			return new ClientSideEncryptionAlgorithm(value);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override bool Equals(object obj)
		{
			if (obj is ClientSideEncryptionAlgorithm other)
			{
				return Equals(other);
			}
			return false;
		}

		public bool Equals(ClientSideEncryptionAlgorithm other)
		{
			return string.Equals(_value, other._value, StringComparison.Ordinal);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override int GetHashCode()
		{
			return _value?.GetHashCode() ?? 0;
		}

		public override string ToString()
		{
			return _value;
		}
	}
	internal class EncryptedRegionInfo
	{
		public int DataLength { get; set; }

		public int NonceLength { get; set; }
	}
	internal class EncryptionAgent
	{
		public ClientSideEncryptionVersion EncryptionVersion { get; set; }

		public ClientSideEncryptionAlgorithm EncryptionAlgorithm { get; set; }
	}
	internal class EncryptionData
	{
		public string EncryptionMode { get; set; }

		public KeyEnvelope WrappedContentKey { get; set; }

		public EncryptionAgent EncryptionAgent { get; set; }

		public byte[] ContentEncryptionIV { get; set; }

		public EncryptedRegionInfo EncryptedRegionInfo { get; set; }

		public IDictionary<string, string> KeyWrappingMetadata { get; set; }

		private static string AgentString { get; } = GenerateAgentString();

		internal static async ValueTask<EncryptionData> CreateInternalV1_0(byte[] contentEncryptionIv, string keyWrapAlgorithm, byte[] contentEncryptionKey, IKeyEncryptionKey keyEncryptionKey, bool async, CancellationToken cancellationToken)
		{
			EncryptionData encryptionData = new EncryptionData
			{
				EncryptionMode = "FullBlob",
				ContentEncryptionIV = contentEncryptionIv,
				EncryptionAgent = new EncryptionAgent
				{
					EncryptionAlgorithm = ClientSideEncryptionAlgorithm.AesCbc256,
					EncryptionVersion = ClientSideEncryptionVersion.V1_0
				},
				KeyWrappingMetadata = new Dictionary<string, string> { { "EncryptionLibrary", AgentString } }
			};
			EncryptionData encryptionData2 = encryptionData;
			KeyEnvelope keyEnvelope = new KeyEnvelope
			{
				Algorithm = keyWrapAlgorithm
			};
			KeyEnvelope keyEnvelope2 = keyEnvelope;
			byte[] encryptedKey = ((!async) ? keyEncryptionKey.WrapKey(keyWrapAlgorithm, contentEncryptionKey, cancellationToken) : (await keyEncryptionKey.WrapKeyAsync(keyWrapAlgorithm, contentEncryptionKey, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
			keyEnvelope2.EncryptedKey = encryptedKey;
			keyEnvelope.KeyId = keyEncryptionKey.KeyId;
			encryptionData2.WrappedContentKey = keyEnvelope;
			return encryptionData;
		}

		internal static async Task<EncryptionData> CreateInternalV2_0(string keyWrapAlgorithm, byte[] contentEncryptionKey, IKeyEncryptionKey keyEncryptionKey, bool async, CancellationToken cancellationToken)
		{
			int num = 8;
			byte[] array = new byte[num + contentEncryptionKey.Length];
			Encoding.UTF8.GetBytes(ClientSideEncryptionVersion.V2_0.Serialize()).CopyTo(array, 0);
			contentEncryptionKey.CopyTo(array, num);
			EncryptionData encryptionData = new EncryptionData
			{
				EncryptionMode = "FullBlob",
				EncryptionAgent = new EncryptionAgent
				{
					EncryptionAlgorithm = ClientSideEncryptionAlgorithm.AesGcm256,
					EncryptionVersion = ClientSideEncryptionVersion.V2_0
				},
				EncryptedRegionInfo = new EncryptedRegionInfo
				{
					DataLength = 4194304,
					NonceLength = 12
				},
				KeyWrappingMetadata = new Dictionary<string, string> { { "EncryptionLibrary", AgentString } }
			};
			EncryptionData encryptionData2 = encryptionData;
			KeyEnvelope keyEnvelope = new KeyEnvelope
			{
				Algorithm = keyWrapAlgorithm
			};
			KeyEnvelope keyEnvelope2 = keyEnvelope;
			byte[] encryptedKey = ((!async) ? keyEncryptionKey.WrapKey(keyWrapAlgorithm, array, cancellationToken) : (await keyEncryptionKey.WrapKeyAsync(keyWrapAlgorithm, array, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
			keyEnvelope2.EncryptedKey = encryptedKey;
			keyEnvelope.KeyId = keyEncryptionKey.KeyId;
			encryptionData2.WrappedContentKey = keyEnvelope;
			return encryptionData;
		}

		private static string GenerateAgentString()
		{
			Assembly assembly = typeof(EncryptionData).Assembly;
			string text = "(" + RuntimeInformation.FrameworkDescription + "; " + RuntimeInformation.OSDescription + ")";
			return "azsdk-net-" + assembly.GetName().Name + "/" + assembly.GetCustomAttribute<AssemblyInformationalVersionAttribute>().InformationalVersion + " " + text;
		}
	}
	internal static class EncryptionDataSerializer
	{
		private const string EncryptionAgent_EncryptionVersionName = "Protocol";

		public static string Serialize(EncryptionData data)
		{
			return Encoding.UTF8.GetString(SerializeEncryptionData(data).ToArray());
		}

		private static ReadOnlyMemory<byte> SerializeEncryptionData(EncryptionData data)
		{
			Azure.Core.ArrayBufferWriter<byte> arrayBufferWriter = new Azure.Core.ArrayBufferWriter<byte>();
			using Utf8JsonWriter utf8JsonWriter = new Utf8JsonWriter(arrayBufferWriter);
			utf8JsonWriter.WriteStartObject();
			WriteEncryptionData(utf8JsonWriter, data);
			utf8JsonWriter.WriteEndObject();
			utf8JsonWriter.Flush();
			return arrayBufferWriter.WrittenMemory;
		}

		public static void WriteEncryptionData(Utf8JsonWriter json, EncryptionData data)
		{
			json.WriteString("EncryptionMode", data.EncryptionMode);
			json.WriteStartObject("WrappedContentKey");
			WriteWrappedKey(json, data.WrappedContentKey);
			json.WriteEndObject();
			json.WriteStartObject("EncryptionAgent");
			WriteEncryptionAgent(json, data.EncryptionAgent);
			json.WriteEndObject();
			if (data.ContentEncryptionIV != null)
			{
				json.WriteString("ContentEncryptionIV", Convert.ToBase64String(data.ContentEncryptionIV));
			}
			if (data.EncryptedRegionInfo != null)
			{
				json.WriteStartObject("EncryptedRegionInfo");
				WriteEncryptedRegionInfo(json, data.EncryptedRegionInfo);
				json.WriteEndObject();
			}
			json.WriteStartObject("KeyWrappingMetadata");
			WriteDictionary(json, data.KeyWrappingMetadata);
			json.WriteEndObject();
		}

		private static void WriteEncryptedRegionInfo(Utf8JsonWriter json, EncryptedRegionInfo encryptedRegionInfo)
		{
			json.WriteNumber("DataLength", encryptedRegionInfo.DataLength);
			json.WriteNumber("NonceLength", encryptedRegionInfo.NonceLength);
		}

		private static void WriteWrappedKey(Utf8JsonWriter json, KeyEnvelope key)
		{
			json.WriteString("KeyId", key.KeyId);
			json.WriteString("EncryptedKey", Convert.ToBase64String(key.EncryptedKey));
			json.WriteString("Algorithm", key.Algorithm);
		}

		private static void WriteEncryptionAgent(Utf8JsonWriter json, EncryptionAgent encryptionAgent)
		{
			json.WriteString("Protocol", encryptionAgent.EncryptionVersion.Serialize());
			json.WriteString("EncryptionAlgorithm", encryptionAgent.EncryptionAlgorithm.ToString());
		}

		private static void WriteDictionary(Utf8JsonWriter json, IDictionary<string, string> dictionary)
		{
			foreach (KeyValuePair<string, string> item in dictionary)
			{
				json.WriteString(item.Key, item.Value);
			}
		}

		public static EncryptionData Deserialize(string serializedData)
		{
			Utf8JsonReader reader = new Utf8JsonReader(Encoding.UTF8.GetBytes(serializedData));
			return DeserializeEncryptionData(ref reader);
		}

		public static EncryptionData DeserializeEncryptionData(ref Utf8JsonReader reader)
		{
			using JsonDocument jsonDocument = JsonDocument.ParseValue(ref reader);
			return ReadEncryptionData(jsonDocument.RootElement);
		}

		public static EncryptionData ReadEncryptionData(JsonElement root)
		{
			EncryptionData encryptionData = new EncryptionData();
			foreach (JsonProperty item in root.EnumerateObject())
			{
				ReadPropertyValue(encryptionData, item);
			}
			return encryptionData;
		}

		private static void ReadPropertyValue(EncryptionData data, JsonProperty property)
		{
			if (property.Name.Equals("EncryptionMode", StringComparison.InvariantCultureIgnoreCase))
			{
				data.EncryptionMode = property.Value.GetString();
			}
			else if (property.Name.Equals("WrappedContentKey", StringComparison.InvariantCultureIgnoreCase))
			{
				KeyEnvelope keyEnvelope = new KeyEnvelope();
				foreach (JsonProperty item in property.Value.EnumerateObject())
				{
					ReadPropertyValue(keyEnvelope, item);
				}
				data.WrappedContentKey = keyEnvelope;
			}
			else if (property.Name.Equals("EncryptionAgent", StringComparison.InvariantCultureIgnoreCase))
			{
				EncryptionAgent encryptionAgent = new EncryptionAgent();
				foreach (JsonProperty item2 in property.Value.EnumerateObject())
				{
					ReadPropertyValue(encryptionAgent, item2);
				}
				data.EncryptionAgent = encryptionAgent;
			}
			else if (property.Name.Equals("ContentEncryptionIV", StringComparison.InvariantCultureIgnoreCase))
			{
				data.ContentEncryptionIV = Convert.FromBase64String(property.Value.GetString());
			}
			else if (property.Name.Equals("KeyWrappingMetadata", StringComparison.InvariantCultureIgnoreCase))
			{
				Dictionary<string, string> dictionary = new Dictionary<string, string>();
				foreach (JsonProperty item3 in property.Value.EnumerateObject())
				{
					dictionary.Add(item3.Name, item3.Value.GetString());
				}
				data.KeyWrappingMetadata = dictionary;
			}
			else
			{
				if (!property.Name.Equals("EncryptedRegionInfo", StringComparison.InvariantCultureIgnoreCase))
				{
					return;
				}
				EncryptedRegionInfo encryptedRegionInfo = new EncryptedRegionInfo();
				foreach (JsonProperty item4 in property.Value.EnumerateObject())
				{
					ReadPropertyValue(encryptedRegionInfo, item4);
				}
				data.EncryptedRegionInfo = encryptedRegionInfo;
			}
		}

		private static void ReadPropertyValue(KeyEnvelope key, JsonProperty property)
		{
			if (property.Name.Equals("Algorithm", StringComparison.InvariantCultureIgnoreCase))
			{
				key.Algorithm = property.Value.GetString();
			}
			else if (property.Name.Equals("EncryptedKey", StringComparison.InvariantCultureIgnoreCase))
			{
				key.EncryptedKey = Convert.FromBase64String(property.Value.GetString());
			}
			else if (property.Name.Equals("KeyId", StringComparison.InvariantCultureIgnoreCase))
			{
				key.KeyId = property.Value.GetString();
			}
		}

		private static void ReadPropertyValue(EncryptionAgent agent, JsonProperty property)
		{
			if (property.Name.Equals("EncryptionAlgorithm", StringComparison.InvariantCultureIgnoreCase))
			{
				agent.EncryptionAlgorithm = new ClientSideEncryptionAlgorithm(property.Value.GetString());
			}
			else if (property.Name.Equals("Protocol", StringComparison.InvariantCultureIgnoreCase))
			{
				agent.EncryptionVersion = property.Value.GetString().ToClientSideEncryptionVersion();
			}
		}

		private static void ReadPropertyValue(EncryptedRegionInfo info, JsonProperty property)
		{
			if (property.Name.Equals("NonceLength", StringComparison.InvariantCultureIgnoreCase))
			{
				info.NonceLength = property.Value.GetInt32();
			}
			else if (property.Name.Equals("DataLength", StringComparison.InvariantCultureIgnoreCase))
			{
				info.DataLength = property.Value.GetInt32();
			}
		}
	}
	internal class KeyEnvelope
	{
		public string KeyId { get; set; }

		public byte[] EncryptedKey { get; set; }

		public string Algorithm { get; set; }
	}
	internal enum TransformMode
	{
		Encrypt,
		Decrypt
	}
}
namespace Azure.Storage.Shared
{
	internal interface IDownloadedContent
	{
		Stream Content { get; }
	}
	internal class PooledMemoryStream : Stream
	{
		private class BufferPartition
		{
			public byte[] Buffer { get; set; }

			public int DataLength { get; set; }
		}

		private const int DefaultMaxArrayPoolRentalSize = 134217728;

		public int MaxArraySize { get; }

		public ArrayPool<byte> ArrayPool { get; }

		private List<BufferPartition> BufferSet { get; } = new List<BufferPartition>();

		public override bool CanRead => true;

		public override bool CanSeek => true;

		public override bool CanWrite => true;

		public override long Length => ((IEnumerable<BufferPartition>)BufferSet).Sum((Func<BufferPartition, long>)((BufferPartition tuple) => tuple.DataLength));

		public override long Position { get; set; }

		public PooledMemoryStream(ArrayPool<byte> arrayPool, int maxArraySize)
		{
			ArrayPool = arrayPool;
			MaxArraySize = maxArraySize;
		}

		public PooledMemoryStream()
		{
		}

		internal static async Task<PooledMemoryStream> BufferStreamPartitionInternal(Stream stream, long minCount, long maxCount, ArrayPool<byte> arrayPool, int? maxArrayPoolRentalSize, bool async, CancellationToken cancellationToken)
		{
			long totalRead = 0L;
			PooledMemoryStream streamPartition = new PooledMemoryStream(arrayPool, maxArrayPoolRentalSize ?? 134217728);
			int maxCountIndividualBuffer;
			int num2;
			do
			{
				BufferPartition latestBuffer = streamPartition.GetLatestBufferWithAvailableSpaceOrDefault();
				byte[] buffer;
				int num;
				bool newbuffer;
				if (latestBuffer != null)
				{
					buffer = latestBuffer.Buffer;
					num = latestBuffer.DataLength;
					newbuffer = false;
				}
				else
				{
					buffer = arrayPool.Rent((int)Math.Min(maxCount - totalRead, streamPartition.MaxArraySize));
					num = 0;
					newbuffer = true;
				}
				maxCountIndividualBuffer = (int)Math.Min(maxCount - totalRead, buffer.Length - num);
				int minCount2 = (int)Math.Min(minCount - totalRead, maxCountIndividualBuffer);
				num2 = await ReadLoopInternal(stream, buffer, num, minCount2, maxCountIndividualBuffer, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				if (num2 == 0 && newbuffer)
				{
					arrayPool.Return(buffer);
				}
				else if (newbuffer)
				{
					streamPartition.BufferSet.Add(new BufferPartition
					{
						Buffer = buffer,
						DataLength = num2
					});
				}
				else
				{
					latestBuffer.DataLength += num2;
				}
				totalRead += num2;
			}
			while (num2 != 0 && totalRead < maxCount && (totalRead < minCount || num2 == maxCountIndividualBuffer));
			return streamPartition;
		}

		private static async Task<int> ReadLoopInternal(Stream stream, byte[] buffer, int offset, int minCount, int maxCount, bool async, CancellationToken cancellationToken)
		{
			if (minCount > maxCount)
			{
				throw new ArgumentException("minCount cannot be greater than maxCount.");
			}
			if (maxCount <= 0)
			{
				throw new ArgumentException("Cannot read a non-positive number of bytes.");
			}
			int totalRead = 0;
			do
			{
				int num = ((!async) ? stream.Read(buffer, offset + totalRead, maxCount - totalRead) : (await stream.ReadAsync(buffer, offset + totalRead, maxCount - totalRead, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
				int num2 = num;
				if (num2 == 0)
				{
					break;
				}
				totalRead += num2;
			}
			while (totalRead < minCount);
			return totalRead;
		}

		public override void Flush()
		{
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (Position >= Length)
			{
				return 0;
			}
			int num = 0;
			while (num < count && Position < Length)
			{
				(byte[] CurrentBuffer, int BufferCount, long OffsetOfBuffer) bufferFromPosition = GetBufferFromPosition();
				byte[] item = bufferFromPosition.CurrentBuffer;
				int item2 = bufferFromPosition.BufferCount;
				long item3 = bufferFromPosition.OffsetOfBuffer;
				int num2 = (int)Min(Length - Position, item2 - (Position - item3), count - num);
				Array.Copy(item, Position - item3, buffer, num, num2);
				num += num2;
				Position += num2;
			}
			return num;
		}

		public override int ReadByte()
		{
			if (Position >= Length)
			{
				return -1;
			}
			(byte[] CurrentBuffer, int BufferCount, long OffsetOfBuffer) bufferFromPosition = GetBufferFromPosition();
			byte[] item = bufferFromPosition.CurrentBuffer;
			long item2 = bufferFromPosition.OffsetOfBuffer;
			byte result = item[Position - item2];
			Position++;
			return result;
		}

		private (byte[] CurrentBuffer, int BufferCount, long OffsetOfBuffer) GetBufferFromPosition()
		{
			AssertPositionInBounds();
			long num = 0L;
			foreach (BufferPartition item in BufferSet)
			{
				if (num + item.DataLength <= Position)
				{
					num += item.DataLength;
					continue;
				}
				return (CurrentBuffer: item.Buffer, BufferCount: item.DataLength, OffsetOfBuffer: num);
			}
			throw new InvalidOperationException("Incorrect stream partition length.");
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			switch (origin)
			{
			case SeekOrigin.Begin:
				Position = offset;
				break;
			case SeekOrigin.Current:
				Position += offset;
				break;
			case SeekOrigin.End:
				Position = Length + offset;
				break;
			}
			return Position;
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			while (count > 0)
			{
				BufferPartition bufferPartition = GetLatestBufferWithAvailableSpaceOrDefault();
				if (bufferPartition == null)
				{
					byte[] buffer2 = ArrayPool.Rent(MaxArraySize);
					bufferPartition = new BufferPartition
					{
						Buffer = buffer2,
						DataLength = 0
					};
					BufferSet.Add(bufferPartition);
				}
				int num = Math.Min(bufferPartition.Buffer.Length - bufferPartition.DataLength, count);
				Array.Copy(buffer, offset, bufferPartition.Buffer, bufferPartition.DataLength, num);
				bufferPartition.DataLength += num;
				count -= num;
				offset += num;
				Position += num;
			}
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			Clear();
		}

		public void Clear()
		{
			foreach (BufferPartition item in BufferSet)
			{
				ArrayPool.Return(item.Buffer);
			}
			BufferSet.Clear();
			Position = 0L;
		}

		private void AssertPositionInBounds()
		{
			if (Position >= Length || Position < 0)
			{
				throw new InvalidOperationException("Cannot read outside the bounds of this stream.");
			}
		}

		private BufferPartition GetLatestBufferWithAvailableSpaceOrDefault()
		{
			BufferPartition bufferPartition = BufferSet.LastOrDefault();
			if (bufferPartition == null || bufferPartition.DataLength >= bufferPartition.Buffer.Length)
			{
				return null;
			}
			return bufferPartition;
		}

		private static long Min(long val1, long val2, long val3)
		{
			return Math.Min(Math.Min(val1, val2), val3);
		}
	}
	internal class StorageClientConfiguration
	{
		public virtual HttpPipeline Pipeline { get; private set; }

		public virtual StorageSharedKeyCredential SharedKeyCredential { get; private set; }

		public virtual TokenCredential TokenCredential { get; private set; }

		public virtual AzureSasCredential SasCredential { get; private set; }

		public virtual Azure.Core.Pipeline.ClientDiagnostics ClientDiagnostics { get; private set; }

		public StorageClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics)
			: this(pipeline, clientDiagnostics)
		{
			SharedKeyCredential = sharedKeyCredential;
		}

		public StorageClientConfiguration(HttpPipeline pipeline, AzureSasCredential sasCredential, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics)
			: this(pipeline, clientDiagnostics)
		{
			SasCredential = sasCredential;
		}

		public StorageClientConfiguration(HttpPipeline pipeline, TokenCredential tokenCredential, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics)
			: this(pipeline, clientDiagnostics)
		{
			TokenCredential = tokenCredential;
		}

		internal StorageClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics)
		{
			Pipeline = pipeline;
			SharedKeyCredential = sharedKeyCredential;
			SasCredential = sasCredential;
			TokenCredential = tokenCredential;
			ClientDiagnostics = clientDiagnostics;
		}

		internal StorageClientConfiguration(HttpPipeline pipeline, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics)
		{
			Pipeline = pipeline;
			ClientDiagnostics = clientDiagnostics;
		}

		internal StorageClientConfiguration()
		{
		}
	}
	internal static class StorageExtensions
	{
		public static string EscapePath(this string path, bool trimOuterSlashes = true)
		{
			if (path == null)
			{
				return null;
			}
			path = (trimOuterSlashes ? path.Trim(new char[1] { '/' }) : path);
			string[] array = path.Split(new char[1] { '/' });
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = Uri.EscapeDataString(array[i]);
			}
			return string.Join("/", array);
		}

		public static string UnescapePath(this string path, bool trimOuterSlashes = true)
		{
			if (path == null)
			{
				return null;
			}
			path = (trimOuterSlashes ? path.Trim(new char[1] { '/' }) : path);
			string[] array = path.Split(new char[1] { '/' });
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = Uri.UnescapeDataString(array[i]);
			}
			return string.Join("/", array);
		}

		public static string GenerateBlockId(long offset)
		{
			byte[] array = new byte[48];
			BitConverter.GetBytes(offset).CopyTo(array, 0);
			return Convert.ToBase64String(array);
		}

		public static async Task<HttpAuthorization> GetCopyAuthorizationHeaderAsync(this TokenCredential tokenCredential, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new HttpAuthorization("Bearer", (await tokenCredential.GetTokenAsync(new TokenRequestContext(Azure.Storage.Constants.CopyHttpAuthorization.Scopes), cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Token);
		}

		public static IDisposable CreateClientSideEncryptionScope(ClientSideEncryptionVersion version)
		{
			string key = version switch
			{
				ClientSideEncryptionVersion.V1_0 => "Azure.Storage.StorageTelemetryPolicy.ClientSideEncryption.V1", 
				ClientSideEncryptionVersion.V2_0 => "Azure.Storage.StorageTelemetryPolicy.ClientSideEncryption.V2", 
				_ => throw Azure.Storage.Errors.ClientSideEncryption.UnrecognizedVersion(), 
			};
			return HttpPipeline.CreateHttpMessagePropertiesScope(new Dictionary<string, object> { { key, true } });
		}
	}
	internal abstract class WindowStream : Stream
	{
		private class UnseekableWindowStream : WindowStream
		{
			private long _position;

			private long MaxLength { get; }

			public override bool CanSeek => false;

			public override long Length
			{
				get
				{
					throw new NotSupportedException();
				}
			}

			public override long Position
			{
				get
				{
					throw new NotSupportedException();
				}
				set
				{
					throw new NotSupportedException();
				}
			}

			public UnseekableWindowStream(Stream stream, long maxWindowLength)
				: base(stream)
			{
				MaxLength = maxWindowLength;
			}

			public override long Seek(long offset, SeekOrigin origin)
			{
				throw new NotSupportedException();
			}

			public override void SetLength(long value)
			{
				throw new NotSupportedException();
			}

			protected override int AdjustCount(int count)
			{
				return (int)Math.Min(count, MaxLength - _position);
			}

			protected override void ReportInnerStreamRead(int resultRead)
			{
				_position += resultRead;
			}
		}

		private class SeekableWindowStream : WindowStream
		{
			private readonly long _baseStreamStartingPosition;

			public override bool CanSeek => true;

			public override long Length { get; }

			public override long Position
			{
				get
				{
					return base.InnerStream.Position - _baseStreamStartingPosition;
				}
				set
				{
					base.InnerStream.Position = _baseStreamStartingPosition + value;
				}
			}

			public SeekableWindowStream(Stream stream, long maxWindowLength)
				: base(stream)
			{
				Length = Math.Min(stream.Length - stream.Position, maxWindowLength);
				_baseStreamStartingPosition = stream.Position;
			}

			public override long Seek(long offset, SeekOrigin origin)
			{
				switch (origin)
				{
				case SeekOrigin.Begin:
					base.InnerStream.Seek(_baseStreamStartingPosition + offset, SeekOrigin.Begin);
					break;
				case SeekOrigin.Current:
					base.InnerStream.Seek(base.InnerStream.Position + offset, SeekOrigin.Current);
					break;
				case SeekOrigin.End:
					base.InnerStream.Seek(_baseStreamStartingPosition + Length - base.InnerStream.Length + offset, SeekOrigin.End);
					break;
				}
				return Position;
			}

			public override void SetLength(long value)
			{
				throw new NotSupportedException();
			}

			protected override int AdjustCount(int count)
			{
				return (int)Math.Min(count, Length - Position);
			}

			protected override void ReportInnerStreamRead(int resultRead)
			{
			}
		}

		private Stream InnerStream { get; }

		public override bool CanRead => true;

		public override bool CanWrite => false;

		private WindowStream(Stream stream)
		{
			InnerStream = stream;
		}

		public static Stream GetWindow(Stream stream, long maxWindowLength)
		{
			if (stream.CanSeek)
			{
				return new SeekableWindowStream(stream, maxWindowLength);
			}
			return new UnseekableWindowStream(stream, maxWindowLength);
		}

		public override void Flush()
		{
			throw new NotSupportedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			throw new NotSupportedException();
		}

		public override void WriteByte(byte value)
		{
			throw new NotSupportedException();
		}

		public override int ReadByte()
		{
			if (AdjustCount(1) <= 0)
			{
				return -1;
			}
			int num = InnerStream.ReadByte();
			if (num != -1)
			{
				ReportInnerStreamRead(1);
			}
			return num;
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			return ReadInternal(buffer, offset, count, async: false, default(CancellationToken)).EnsureCompleted();
		}

		public override async Task<int> ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
		{
			return await ReadInternal(buffer, offset, count, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<int> ReadInternal(byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
		{
			count = AdjustCount(count);
			if (count <= 0)
			{
				return 0;
			}
			int num = ((!async) ? InnerStream.Read(buffer, offset, count) : (await InnerStream.ReadAsync(buffer, offset, count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
			int num2 = num;
			ReportInnerStreamRead(num2);
			return num2;
		}

		protected abstract int AdjustCount(int count);

		protected abstract void ReportInnerStreamRead(int resultRead);
	}
	internal static class StreamExtensions
	{
		public static long? GetPositionOrDefault(this Stream content)
		{
			if (content == null)
			{
				return 0L;
			}
			try
			{
				if (content.CanSeek)
				{
					return content.Position;
				}
			}
			catch (NotSupportedException)
			{
			}
			return null;
		}
	}
	internal abstract class StorageWriteStream : Stream
	{
		protected long _position;

		protected long _bufferSize;

		protected readonly IProgress<long> _progressHandler;

		protected readonly PooledMemoryStream _buffer;

		private ArrayPool<byte> _bufferPool;

		private readonly StorageChecksumAlgorithm _checksumAlgorithm;

		private StorageCrc64HashAlgorithm _masterCrcChecksummer;

		private Memory<byte> _composedCrc = Memory<byte>.Empty;

		private Memory<byte> _userProvidedChecksum = Memory<byte>.Empty;

		private IHasher _bufferChecksumer;

		private bool _disposed;

		private readonly DisposableBucket _accumulatedDisposables = new DisposableBucket();

		private bool UseMasterCrc => _checksumAlgorithm.ResolveAuto() == StorageChecksumAlgorithm.StorageCrc64;

		public override bool CanRead => false;

		public override bool CanSeek => false;

		public override bool CanWrite => true;

		public override long Length
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override long Position
		{
			get
			{
				return _position;
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		protected StorageWriteStream(long position, long bufferSize, IProgress<long> progressHandler, UploadTransferValidationOptions transferValidation, PooledMemoryStream buffer = null, ArrayPool<byte> bufferPool = null)
		{
			_position = position;
			_bufferSize = bufferSize;
			_bufferPool = bufferPool ?? ArrayPool<byte>.Shared;
			if (progressHandler != null)
			{
				_progressHandler = new AggregatingProgressIncrementer(progressHandler);
			}
			_checksumAlgorithm = Azure.Core.Argument.CheckNotNull(transferValidation, "transferValidation").ChecksumAlgorithm;
			if (!transferValidation.PrecalculatedChecksum.IsEmpty)
			{
				if (!UseMasterCrc)
				{
					throw Azure.Storage.Errors.PrecalculatedHashNotSupportedOnSplit();
				}
				_accumulatedDisposables.Add(_bufferPool.RentDisposable(transferValidation.PrecalculatedChecksum.Length, out var array));
				array.Clear();
				_userProvidedChecksum = new Memory<byte>(array, 0, transferValidation.PrecalculatedChecksum.Length);
				transferValidation.PrecalculatedChecksum.CopyTo(_userProvidedChecksum);
			}
			if (UseMasterCrc)
			{
				_masterCrcChecksummer = StorageCrc64HashAlgorithm.Create();
				_accumulatedDisposables.Add(_bufferPool.RentDisposable(8, out var array2));
				array2.Clear();
				_composedCrc = new Memory<byte>(array2, 0, 8);
			}
			if (buffer != null)
			{
				if (buffer.Position != 0L)
				{
					throw Azure.Storage.Errors.CannotInitializeWriteStreamWithData();
				}
				_buffer = buffer;
			}
			else
			{
				_buffer = new PooledMemoryStream(_bufferPool, (int)Math.Min(1048576L, bufferSize));
				_accumulatedDisposables.Add(_buffer);
			}
			_bufferChecksumer = ContentHasher.GetHasherFromAlgorithmId(_checksumAlgorithm);
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			throw new NotSupportedException();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			WriteInternal(buffer, offset, count, async: false, default(CancellationToken)).EnsureCompleted();
		}

		public override async Task WriteAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
		{
			await WriteInternal(buffer, offset, count, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task WriteInternal(byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
		{
			ValidateWriteParameters(buffer, offset, count);
			int remaining = count;
			if (count <= _bufferSize - _buffer.Position)
			{
				await WriteToBufferInternal(buffer, offset, count, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				return;
			}
			int remainingSpace = (int)(_bufferSize - _buffer.Position);
			await WriteToBufferInternal(buffer, offset, remainingSpace, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			remaining -= remainingSpace;
			offset += remainingSpace;
			UploadTransferValidationOptions validationOptions;
			using (FinalizeAndReplaceBufferChecksum(out validationOptions))
			{
				await AppendAndClearBufferInternal(validationOptions, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			while (remaining > 0)
			{
				int available = (int)Math.Min(remaining, _bufferSize);
				await WriteToBufferInternal(buffer, offset, available, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				remaining -= available;
				offset += available;
				if (remaining > 0)
				{
					UploadTransferValidationOptions validationOptions2;
					using (FinalizeAndReplaceBufferChecksum(out validationOptions2))
					{
						await AppendAndClearBufferInternal(validationOptions2, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
				}
			}
		}

		public override void Flush()
		{
			FlushInternal(async: false, default(CancellationToken)).EnsureCompleted();
		}

		public override async Task FlushAsync(CancellationToken cancellationToken)
		{
			await FlushInternal(async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task FlushInternal(bool async, CancellationToken cancellationToken)
		{
			UploadTransferValidationOptions validationOptions;
			using (FinalizeAndReplaceBufferChecksum(out validationOptions))
			{
				await AppendAndClearBufferInternal(validationOptions, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			if (UseMasterCrc)
			{
				byte[] array;
				using (_bufferPool.RentDisposable(_masterCrcChecksummer.HashLengthInBytes, out array))
				{
					array.Clear();
					Memory<byte> memory = new Memory<byte>(array, 0, _masterCrcChecksummer.HashLengthInBytes);
					_masterCrcChecksummer.GetCurrentHash(memory.Span);
					if (!memory.Span.SequenceEqual(_composedCrc.Span))
					{
						throw Azure.Storage.Errors.ChecksumMismatch(memory.Span, _composedCrc.Span);
					}
				}
			}
			await CommitInternal(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		protected virtual Task CommitInternal(bool async, CancellationToken cancellationToken)
		{
			return Task.CompletedTask;
		}

		private async Task AppendAndClearBufferInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken)
		{
			try
			{
				await AppendInternal(validationOptions, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			finally
			{
				_buffer.Clear();
			}
		}

		protected abstract Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken);

		protected abstract void ValidateBufferSize(long bufferSize);

		protected async Task WriteToBufferInternal(byte[] buffer, int offset, int count, bool async, CancellationToken cancellationToken)
		{
			_bufferChecksumer?.AppendHash(new Span<byte>(buffer, offset, count));
			_masterCrcChecksummer?.Append(new Span<byte>(buffer, offset, count));
			if (async)
			{
				await _buffer.WriteAsync(buffer, offset, count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			else
			{
				_buffer.Write(buffer, offset, count);
			}
			_position += count;
		}

		protected static void ValidateWriteParameters(byte[] buffer, int offset, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer", "buffer cannot be null.");
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", "offset cannot be less than 0.");
			}
			if (offset > buffer.Length)
			{
				throw new ArgumentOutOfRangeException("offset", "offset cannot be greater than buffer length.");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", "count cannot be less than 0.");
			}
			if (offset + count > buffer.Length)
			{
				throw new ArgumentOutOfRangeException("offset and count", "offset + count cannot exceed buffer length.");
			}
		}

		protected override void Dispose(bool disposing)
		{
			if (!_disposed)
			{
				if (disposing)
				{
					Flush();
					ValidateCallerCrcIfAny();
					_accumulatedDisposables.Dispose();
				}
				_disposed = true;
				base.Dispose(disposing);
			}
		}

		private void ValidateCallerCrcIfAny()
		{
			if (!UseMasterCrc || _userProvidedChecksum.IsEmpty)
			{
				return;
			}
			Span<byte> span;
			using (_bufferPool.RentAsSpanDisposable(_masterCrcChecksummer.HashLengthInBytes, out span))
			{
				_masterCrcChecksummer.GetCurrentHash(span);
				if (!span.SequenceEqual(_userProvidedChecksum.Span))
				{
					throw Azure.Storage.Errors.ChecksumMismatch(span, _userProvidedChecksum.Span);
				}
			}
		}

		protected IDisposable FinalizeAndReplaceBufferChecksum(out UploadTransferValidationOptions validationOptions)
		{
			if (_buffer.Length == 0L)
			{
				validationOptions = new UploadTransferValidationOptions
				{
					ChecksumAlgorithm = StorageChecksumAlgorithm.None
				};
				return null;
			}
			Memory<byte> memory = Memory<byte>.Empty;
			IDisposable result = null;
			if (_bufferChecksumer != null)
			{
				result = _bufferPool.RentDisposable(_bufferChecksumer.HashSizeInBytes, out var array);
				array.Clear();
				memory = new Memory<byte>(array, 0, _bufferChecksumer.HashSizeInBytes);
				_bufferChecksumer.GetFinalHash(memory.Span);
				if (UseMasterCrc)
				{
					Azure.Storage.StorageCrc64Composer.Compose((_composedCrc.ToArray(), 0L), (memory.ToArray(), _buffer.Length)).CopyTo(_composedCrc);
				}
				_bufferChecksumer?.Dispose();
				_bufferChecksumer = ContentHasher.GetHasherFromAlgorithmId(_checksumAlgorithm);
			}
			validationOptions = new UploadTransferValidationOptions
			{
				ChecksumAlgorithm = _checksumAlgorithm,
				PrecalculatedChecksum = memory
			};
			return result;
		}
	}
	internal interface ISupportsTenantIdChallenges
	{
		bool EnableTenantDiscovery { get; }
	}
}
namespace Azure.Storage.Shared.AesGcm
{
	internal sealed class AesGcmWindows : IDisposable
	{
		private const int NonceSize = 12;

		private Interop.BCrypt.SafeKeyHandle _keyHandle;

		internal static KeySizes NonceByteSizes { get; } = new KeySizes(12, 12, 1);

		internal static KeySizes TagByteSizes { get; } = new KeySizes(12, 16, 1);

		internal static bool IsSupported => true;

		internal AesGcmWindows(ReadOnlySpan<byte> key)
		{
			ThrowIfNotSupported();
			Azure.Storage.Errors.CheckCryptKeySize(key.Length);
			ImportKey(key);
		}

		internal AesGcmWindows(byte[] key)
		{
			ThrowIfNotSupported();
			Azure.Storage.Errors.ThrowIfParamNull(key, "key");
			Azure.Storage.Errors.CheckCryptKeySize(key.Length);
			ImportKey(key);
		}

		internal void Encrypt(byte[] nonce, byte[] plaintext, byte[] ciphertext, byte[] tag, byte[] associatedData = null)
		{
			Azure.Storage.Errors.ThrowIfParamNull(nonce, "nonce");
			Azure.Storage.Errors.ThrowIfParamNull(plaintext, "plaintext");
			Azure.Storage.Errors.ThrowIfParamNull(ciphertext, "ciphertext");
			Azure.Storage.Errors.ThrowIfParamNull(tag, "tag");
			Encrypt((ReadOnlySpan<byte>)nonce, (ReadOnlySpan<byte>)plaintext, (Span<byte>)ciphertext, (Span<byte>)tag, (ReadOnlySpan<byte>)associatedData);
		}

		internal void Encrypt(ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, Span<byte> tag, ReadOnlySpan<byte> associatedData = default(ReadOnlySpan<byte>))
		{
			CheckParameters(plaintext, ciphertext, nonce, tag);
			EncryptCore(nonce, plaintext, ciphertext, tag, associatedData);
		}

		internal void Decrypt(byte[] nonce, byte[] ciphertext, byte[] tag, byte[] plaintext, byte[] associatedData = null)
		{
			Azure.Storage.Errors.ThrowIfParamNull(nonce, "nonce");
			Azure.Storage.Errors.ThrowIfParamNull(ciphertext, "ciphertext");
			Azure.Storage.Errors.ThrowIfParamNull(tag, "tag");
			Azure.Storage.Errors.ThrowIfParamNull(plaintext, "plaintext");
			Decrypt((ReadOnlySpan<byte>)nonce, (ReadOnlySpan<byte>)ciphertext, (ReadOnlySpan<byte>)tag, (Span<byte>)plaintext, (ReadOnlySpan<byte>)associatedData);
		}

		internal void Decrypt(ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> tag, Span<byte> plaintext, ReadOnlySpan<byte> associatedData = default(ReadOnlySpan<byte>))
		{
			CheckParameters(plaintext, ciphertext, nonce, tag);
			DecryptCore(nonce, ciphertext, tag, plaintext, associatedData);
		}

		private static void CheckParameters(ReadOnlySpan<byte> plaintext, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> tag)
		{
			if (plaintext.Length != ciphertext.Length)
			{
				Azure.Storage.Errors.CryptographyPlaintextCiphertextLengthMismatch();
			}
			if (!nonce.Length.IsLegalSize(NonceByteSizes))
			{
				Azure.Storage.Errors.CryptographyInvalidNonceLength();
			}
			if (!tag.Length.IsLegalSize(TagByteSizes))
			{
				Azure.Storage.Errors.CryptographyInvalidTagLength();
			}
		}

		private static void ThrowIfNotSupported()
		{
		}

		private void ImportKey(ReadOnlySpan<byte> key)
		{
			_keyHandle = Interop.BCrypt.BCryptImportKey(Interop.BCrypt.BCryptAeadHandleCache.AesGcm, key);
		}

		private void EncryptCore(ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, Span<byte> tag, ReadOnlySpan<byte> associatedData = default(ReadOnlySpan<byte>))
		{
			AeadCommon.Encrypt(_keyHandle, nonce, associatedData, plaintext, ciphertext, tag);
		}

		private void DecryptCore(ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> tag, Span<byte> plaintext, ReadOnlySpan<byte> associatedData = default(ReadOnlySpan<byte>))
		{
			AeadCommon.Decrypt(_keyHandle, nonce, associatedData, ciphertext, tag, plaintext, clearPlaintextOnFailure: true);
		}

		public void Dispose()
		{
			_keyHandle.Dispose();
		}
	}
	internal static class AeadCommon
	{
		internal unsafe static void Encrypt(Interop.BCrypt.SafeKeyHandle keyHandle, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> associatedData, ReadOnlySpan<byte> plaintext, Span<byte> ciphertext, Span<byte> tag)
		{
			fixed (byte* nonNullPinnableReference = &GetNonNullPinnableReference(plaintext))
			{
				fixed (byte* nonNullPinnableReference2 = &GetNonNullPinnableReference(nonce))
				{
					fixed (byte* nonNullPinnableReference3 = &GetNonNullPinnableReference(ciphertext))
					{
						fixed (byte* nonNullPinnableReference4 = &GetNonNullPinnableReference(tag))
						{
							fixed (byte* nonNullPinnableReference5 = &GetNonNullPinnableReference(associatedData))
							{
								Interop.BCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = Interop.BCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.Create();
								bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.pbNonce = nonNullPinnableReference2;
								bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.cbNonce = nonce.Length;
								bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.pbTag = nonNullPinnableReference4;
								bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.cbTag = tag.Length;
								bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.pbAuthData = nonNullPinnableReference5;
								bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.cbAuthData = associatedData.Length;
								int cbResult;
								Interop.BCrypt.NTSTATUS nTSTATUS = Interop.BCrypt.BCryptEncrypt(keyHandle, nonNullPinnableReference, plaintext.Length, new IntPtr(&bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO), null, 0, nonNullPinnableReference3, ciphertext.Length, out cbResult, 0);
								if (nTSTATUS != Interop.BCrypt.NTSTATUS.STATUS_SUCCESS)
								{
									throw Interop.BCrypt.CreateCryptographicException(nTSTATUS);
								}
							}
						}
					}
				}
			}
		}

		internal unsafe static void Decrypt(Interop.BCrypt.SafeKeyHandle keyHandle, ReadOnlySpan<byte> nonce, ReadOnlySpan<byte> associatedData, ReadOnlySpan<byte> ciphertext, ReadOnlySpan<byte> tag, Span<byte> plaintext, bool clearPlaintextOnFailure)
		{
			fixed (byte* nonNullPinnableReference = &GetNonNullPinnableReference(plaintext))
			{
				fixed (byte* nonNullPinnableReference2 = &GetNonNullPinnableReference(nonce))
				{
					fixed (byte* nonNullPinnableReference3 = &GetNonNullPinnableReference(ciphertext))
					{
						fixed (byte* nonNullPinnableReference4 = &GetNonNullPinnableReference(tag))
						{
							fixed (byte* nonNullPinnableReference5 = &GetNonNullPinnableReference(associatedData))
							{
								Interop.BCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = Interop.BCrypt.BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.Create();
								bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.pbNonce = nonNullPinnableReference2;
								bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.cbNonce = nonce.Length;
								bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.pbTag = nonNullPinnableReference4;
								bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.cbTag = tag.Length;
								bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.pbAuthData = nonNullPinnableReference5;
								bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO.cbAuthData = associatedData.Length;
								int cbResult;
								Interop.BCrypt.NTSTATUS nTSTATUS = Interop.BCrypt.BCryptDecrypt(keyHandle, nonNullPinnableReference3, ciphertext.Length, new IntPtr(&bCRYPT_AUTHENTICATED_CIPHER_MODE_INFO), null, 0, nonNullPinnableReference, plaintext.Length, out cbResult, 0);
								switch (nTSTATUS)
								{
								case Interop.BCrypt.NTSTATUS.STATUS_SUCCESS:
									break;
								case Interop.BCrypt.NTSTATUS.STATUS_AUTH_TAG_MISMATCH:
									if (clearPlaintextOnFailure)
									{
										plaintext.Clear();
									}
									Azure.Storage.Errors.CryptographyAuthTagMismatch();
									break;
								default:
									throw new CryptographicException($"Error: 0x{(int)nTSTATUS:X8}");
								}
							}
						}
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe static ref readonly byte GetNonNullPinnableReference(ReadOnlySpan<byte> buffer)
		{
			if (buffer.Length == 0)
			{
				return ref Unsafe.AsRef<byte>((void*)1);
			}
			return ref MemoryMarshal.GetReference(buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private unsafe static ref byte GetNonNullPinnableReference(Span<byte> buffer)
		{
			if (buffer.Length == 0)
			{
				return ref Unsafe.AsRef<byte>((void*)1);
			}
			return ref MemoryMarshal.GetReference(buffer);
		}
	}
	internal static class Interop
	{
		internal static class BCrypt
		{
			internal struct BCRYPT_KEY_DATA_BLOB_HEADER
			{
				public uint dwMagic;

				public uint dwVersion;

				public uint cbKeyData;

				public const uint BCRYPT_KEY_DATA_BLOB_MAGIC = 1296188491u;

				public const uint BCRYPT_KEY_DATA_BLOB_VERSION1 = 1u;
			}

			internal struct BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO
			{
				private int cbSize;

				private uint dwInfoVersion;

				internal unsafe byte* pbNonce;

				internal int cbNonce;

				internal unsafe byte* pbAuthData;

				internal int cbAuthData;

				internal unsafe byte* pbTag;

				internal int cbTag;

				internal unsafe byte* pbMacContext;

				internal int cbMacContext;

				internal int cbAAD;

				internal ulong cbData;

				internal uint dwFlags;

				public unsafe static BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO Create()
				{
					return new BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO
					{
						cbSize = sizeof(BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO),
						dwInfoVersion = 1u
					};
				}
			}

			internal static class BCryptAeadHandleCache
			{
				internal static SafeAlgorithmHandle AesGcm { get; } = OpenAlgorithm("AES", "ChainingModeGCM");

				private static SafeAlgorithmHandle OpenAlgorithm(string algId, string chainingMode = null)
				{
					SafeAlgorithmHandle safeAlgorithmHandle = BCryptOpenAlgorithmProvider(algId, null, 0);
					if (chainingMode != null)
					{
						SetCipherMode(safeAlgorithmHandle, chainingMode);
					}
					return safeAlgorithmHandle;
				}
			}

			internal enum NTSTATUS : uint
			{
				STATUS_SUCCESS = 0u,
				STATUS_NOT_FOUND = 3221226021u,
				STATUS_INVALID_PARAMETER = 3221225485u,
				STATUS_NO_MEMORY = 3221225495u,
				STATUS_AUTH_TAG_MISMATCH = 3221266434u
			}

			internal sealed class SafeAlgorithmHandle : SafeBCryptHandle
			{
				protected sealed override bool ReleaseHandle()
				{
					return BCryptCloseAlgorithmProvider(handle, 0) == 0;
				}

				[DllImport("BCrypt.dll")]
				private static extern uint BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, int dwFlags);
			}

			internal sealed class SafeKeyHandle : SafeBCryptHandle
			{
				private SafeAlgorithmHandle _parentHandle;

				public void SetParentHandle(SafeAlgorithmHandle parentHandle)
				{
					bool success = false;
					parentHandle.DangerousAddRef(ref success);
					_parentHandle = parentHandle;
				}

				protected sealed override bool ReleaseHandle()
				{
					if (_parentHandle != null)
					{
						_parentHandle.DangerousRelease();
						_parentHandle = null;
					}
					return BCryptDestroyKey(handle) == 0;
				}

				[DllImport("BCrypt.dll")]
				private static extern uint BCryptDestroyKey(IntPtr hKey);
			}

			internal unsafe static int BCryptEncrypt(SafeKeyHandle hKey, ReadOnlySpan<byte> input, byte[] iv, Span<byte> output)
			{
				fixed (byte* pbInput = input)
				{
					fixed (byte* pbOutput = output)
					{
						int cbResult;
						NTSTATUS nTSTATUS = BCryptEncrypt(hKey, pbInput, input.Length, IntPtr.Zero, iv, (iv != null) ? iv.Length : 0, pbOutput, output.Length, out cbResult, 0);
						if (nTSTATUS != NTSTATUS.STATUS_SUCCESS)
						{
							throw CreateCryptographicException(nTSTATUS);
						}
						return cbResult;
					}
				}
			}

			internal unsafe static int BCryptDecrypt(SafeKeyHandle hKey, ReadOnlySpan<byte> input, byte[] iv, Span<byte> output)
			{
				fixed (byte* pbInput = input)
				{
					fixed (byte* pbOutput = output)
					{
						int cbResult;
						NTSTATUS nTSTATUS = BCryptDecrypt(hKey, pbInput, input.Length, IntPtr.Zero, iv, (iv != null) ? iv.Length : 0, pbOutput, output.Length, out cbResult, 0);
						if (nTSTATUS != NTSTATUS.STATUS_SUCCESS)
						{
							throw CreateCryptographicException(nTSTATUS);
						}
						return cbResult;
					}
				}
			}

			[DllImport("BCrypt.dll")]
			internal unsafe static extern NTSTATUS BCryptEncrypt(SafeKeyHandle hKey, byte* pbInput, int cbInput, IntPtr paddingInfo, byte[] pbIV, int cbIV, byte* pbOutput, int cbOutput, out int cbResult, int dwFlags);

			[DllImport("BCrypt.dll")]
			internal unsafe static extern NTSTATUS BCryptDecrypt(SafeKeyHandle hKey, byte* pbInput, int cbInput, IntPtr paddingInfo, byte[] pbIV, int cbIV, byte* pbOutput, int cbOutput, out int cbResult, int dwFlags);

			internal unsafe static SafeKeyHandle BCryptImportKey(SafeAlgorithmHandle hAlg, ReadOnlySpan<byte> key)
			{
				int length = key.Length;
				int num = sizeof(BCRYPT_KEY_DATA_BLOB_HEADER) + length;
				int num2 = 64;
				Span<byte> span = stackalloc byte[num2];
				if (num > num2)
				{
					span = new byte[num];
				}
				else
				{
					span.Clear();
				}
				fixed (byte* ptr = span)
				{
					BCRYPT_KEY_DATA_BLOB_HEADER* ptr2 = (BCRYPT_KEY_DATA_BLOB_HEADER*)ptr;
					ptr2->dwMagic = 1296188491u;
					ptr2->dwVersion = 1u;
					ptr2->cbKeyData = (uint)length;
					key.CopyTo(span.Slice(sizeof(BCRYPT_KEY_DATA_BLOB_HEADER)));
					SafeKeyHandle hKey;
					NTSTATUS nTSTATUS = BCryptImportKey(hAlg, IntPtr.Zero, "KeyDataBlob", out hKey, IntPtr.Zero, 0, ptr, num, 0);
					if (nTSTATUS != NTSTATUS.STATUS_SUCCESS)
					{
						throw CreateCryptographicException(nTSTATUS);
					}
					return hKey;
				}
			}

			[DllImport("BCrypt.dll", CharSet = CharSet.Unicode)]
			private unsafe static extern NTSTATUS BCryptImportKey(SafeAlgorithmHandle hAlgorithm, IntPtr hImportKey, string pszBlobType, out SafeKeyHandle hKey, IntPtr pbKeyObject, int cbKeyObject, byte* pbInput, int cbInput, int dwFlags);

			internal static CryptographicException CreateCryptographicException(NTSTATUS ntstatus)
			{
				return CreateCryptographicException((int)ntstatus);
			}

			internal static CryptographicException CreateCryptographicException(int hr)
			{
				return new CryptographicException(hr);
			}

			private static void SetCipherMode(SafeAlgorithmHandle hAlg, string cipherMode)
			{
				NTSTATUS nTSTATUS = BCryptSetProperty(hAlg, "ChainingMode", cipherMode, (cipherMode.Length + 1) * 2, 0);
				if (nTSTATUS != NTSTATUS.STATUS_SUCCESS)
				{
					throw CreateCryptographicException(nTSTATUS);
				}
			}

			private static SafeAlgorithmHandle BCryptOpenAlgorithmProvider(string pszAlgId, string pszImplementation, int dwFlags)
			{
				SafeAlgorithmHandle phAlgorithm;
				NTSTATUS nTSTATUS = BCryptOpenAlgorithmProvider(out phAlgorithm, pszAlgId, pszImplementation, dwFlags);
				if (nTSTATUS != NTSTATUS.STATUS_SUCCESS)
				{
					throw CreateCryptographicException(nTSTATUS);
				}
				return phAlgorithm;
			}

			[DllImport("BCrypt.dll", CharSet = CharSet.Unicode)]
			private static extern NTSTATUS BCryptOpenAlgorithmProvider(out SafeAlgorithmHandle phAlgorithm, string pszAlgId, string pszImplementation, int dwFlags);

			[DllImport("BCrypt.dll", CharSet = CharSet.Unicode)]
			private static extern NTSTATUS BCryptSetProperty(SafeAlgorithmHandle hObject, string pszProperty, string pbInput, int cbInput, int dwFlags);
		}
	}
	internal static class KeySizeHelpers
	{
		internal static KeySizes[] CloneKeySizesArray(this KeySizes[] src)
		{
			return (KeySizes[])src.Clone();
		}

		internal static bool IsLegalSize(this int size, KeySizes legalSizes)
		{
			bool validatedByZeroSkipSizeKeySizes;
			return size.IsLegalSize(legalSizes, out validatedByZeroSkipSizeKeySizes);
		}

		internal static bool IsLegalSize(this int size, KeySizes[] legalSizes)
		{
			bool validatedByZeroSkipSizeKeySizes;
			return size.IsLegalSize(legalSizes, out validatedByZeroSkipSizeKeySizes);
		}

		internal static bool IsLegalSize(this int size, KeySizes legalSizes, out bool validatedByZeroSkipSizeKeySizes)
		{
			validatedByZeroSkipSizeKeySizes = false;
			if (legalSizes.SkipSize == 0)
			{
				if (legalSizes.MinSize == size)
				{
					validatedByZeroSkipSizeKeySizes = true;
					return true;
				}
			}
			else if (size >= legalSizes.MinSize && size <= legalSizes.MaxSize && (size - legalSizes.MinSize) % legalSizes.SkipSize == 0)
			{
				return true;
			}
			return false;
		}

		internal static bool IsLegalSize(this int size, KeySizes[] legalSizes, out bool validatedByZeroSkipSizeKeySizes)
		{
			for (int i = 0; i < legalSizes.Length; i++)
			{
				if (size.IsLegalSize(legalSizes[i], out validatedByZeroSkipSizeKeySizes))
				{
					return true;
				}
			}
			validatedByZeroSkipSizeKeySizes = false;
			return false;
		}
	}
	internal abstract class SafeBCryptHandle : SafeHandle, IDisposable
	{
		public sealed override bool IsInvalid => handle == IntPtr.Zero;

		protected SafeBCryptHandle()
			: base(IntPtr.Zero, ownsHandle: true)
		{
		}

		protected abstract override bool ReleaseHandle();
	}
}
namespace Azure.Storage.Sas
{
	[Flags]
	public enum BlobAccountSasPermissions
	{
		Read = 1,
		Add = 2,
		Create = 4,
		Write = 8,
		Delete = 0x10,
		List = 0x20,
		All = -1
	}
	[Flags]
	public enum BlobContainerSasPermissions
	{
		Read = 1,
		Add = 2,
		Create = 4,
		Write = 8,
		Delete = 0x10,
		List = 0x20,
		Tag = 0x40,
		DeleteBlobVersion = 0x80,
		Move = 0x100,
		Execute = 0x200,
		SetImmutabilityPolicy = 0x400,
		Filter = 0x800,
		All = -1
	}
	public class BlobSasBuilder
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		public string Version { get; set; }

		public SasProtocol Protocol { get; set; }

		public DateTimeOffset StartsOn { get; set; }

		public DateTimeOffset ExpiresOn { get; set; }

		public string Permissions { get; private set; }

		public SasIPRange IPRange { get; set; }

		public string Identifier { get; set; }

		public string BlobContainerName { get; set; }

		public string BlobName { get; set; }

		public string Snapshot { get; set; }

		public string BlobVersionId { get; set; }

		public string Resource { get; set; }

		public string CacheControl { get; set; }

		public string ContentDisposition { get; set; }

		public string ContentEncoding { get; set; }

		public string ContentLanguage { get; set; }

		public string ContentType { get; set; }

		public string PreauthorizedAgentObjectId { get; set; }

		public string CorrelationId { get; set; }

		public string EncryptionScope { get; set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		public BlobSasBuilder()
		{
		}

		public BlobSasBuilder(BlobSasPermissions permissions, DateTimeOffset expiresOn)
		{
			ExpiresOn = expiresOn;
			SetPermissions(permissions);
		}

		public BlobSasBuilder(BlobContainerSasPermissions permissions, DateTimeOffset expiresOn)
		{
			ExpiresOn = expiresOn;
			SetPermissions(permissions);
		}

		public void SetPermissions(BlobSasPermissions permissions)
		{
			Permissions = permissions.ToPermissionsString();
		}

		public void SetPermissions(BlobAccountSasPermissions permissions)
		{
			Permissions = permissions.ToPermissionsString();
		}

		public void SetPermissions(BlobContainerSasPermissions permissions)
		{
			Permissions = permissions.ToPermissionsString();
		}

		public void SetPermissions(SnapshotSasPermissions permissions)
		{
			Permissions = permissions.ToPermissionsString();
		}

		public void SetPermissions(BlobVersionSasPermissions permissions)
		{
			Permissions = permissions.ToPermissionsString();
		}

		public void SetPermissions(string rawPermissions, bool normalize = false)
		{
			if (normalize)
			{
				rawPermissions = Azure.Storage.Sas.SasExtensions.ValidateAndSanitizeRawPermissions(rawPermissions, Azure.Storage.Constants.Sas.ValidPermissionsInOrder);
			}
			SetPermissions(rawPermissions);
		}

		public void SetPermissions(string rawPermissions)
		{
			Permissions = rawPermissions;
		}

		[Azure.Core.CallerShouldAudit(Reason = "https://aka.ms/azsdk/callershouldaudit/storage-blobs")]
		public BlobSasQueryParameters ToSasQueryParameters(StorageSharedKeyCredential sharedKeyCredential)
		{
			sharedKeyCredential = sharedKeyCredential ?? throw Azure.Storage.Errors.ArgumentNull("sharedKeyCredential");
			EnsureState();
			string text = Azure.Storage.Sas.SasExtensions.FormatTimesForSasSigning(StartsOn);
			string text2 = Azure.Storage.Sas.SasExtensions.FormatTimesForSasSigning(ExpiresOn);
			string message = string.Join("\n", Permissions, text, text2, GetCanonicalName(sharedKeyCredential.AccountName, BlobContainerName ?? string.Empty, BlobName ?? string.Empty), Identifier, IPRange.ToString(), Protocol.ToProtocolString(), Version, Resource, Snapshot ?? BlobVersionId, EncryptionScope, CacheControl, ContentDisposition, ContentEncoding, ContentLanguage, ContentType);
			string signature = Azure.Storage.StorageSharedKeyCredentialInternals.ComputeSasSignature(sharedKeyCredential, message);
			string version = Version;
			SasProtocol protocol = Protocol;
			DateTimeOffset startsOn = StartsOn;
			DateTimeOffset expiresOn = ExpiresOn;
			SasIPRange iPRange = IPRange;
			string identifier = Identifier;
			string resource = Resource;
			string permissions = Permissions;
			string cacheControl = CacheControl;
			string contentDisposition = ContentDisposition;
			string contentEncoding = ContentEncoding;
			string contentLanguage = ContentLanguage;
			string contentType = ContentType;
			string encryptionScope = EncryptionScope;
			return new BlobSasQueryParameters(version, null, null, protocol, startsOn, expiresOn, iPRange, identifier, resource, permissions, signature, null, null, default(DateTimeOffset), default(DateTimeOffset), null, null, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType, null, null, null, encryptionScope);
		}

		[Azure.Core.CallerShouldAudit(Reason = "https://aka.ms/azsdk/callershouldaudit/storage-blobs")]
		public BlobSasQueryParameters ToSasQueryParameters(UserDelegationKey userDelegationKey, string accountName)
		{
			userDelegationKey = userDelegationKey ?? throw Azure.Storage.Errors.ArgumentNull("userDelegationKey");
			EnsureState();
			string text = Azure.Storage.Sas.SasExtensions.FormatTimesForSasSigning(StartsOn);
			string text2 = Azure.Storage.Sas.SasExtensions.FormatTimesForSasSigning(ExpiresOn);
			string text3 = Azure.Storage.Sas.SasExtensions.FormatTimesForSasSigning(userDelegationKey.SignedStartsOn);
			string text4 = Azure.Storage.Sas.SasExtensions.FormatTimesForSasSigning(userDelegationKey.SignedExpiresOn);
			string message = string.Join("\n", Permissions, text, text2, GetCanonicalName(accountName, BlobContainerName ?? string.Empty, BlobName ?? string.Empty), userDelegationKey.SignedObjectId, userDelegationKey.SignedTenantId, text3, text4, userDelegationKey.SignedService, userDelegationKey.SignedVersion, PreauthorizedAgentObjectId, null, CorrelationId, IPRange.ToString(), Protocol.ToProtocolString(), Version, Resource, Snapshot ?? BlobVersionId, EncryptionScope, CacheControl, ContentDisposition, ContentEncoding, ContentLanguage, ContentType);
			string signature = ComputeHMACSHA256(userDelegationKey.Value, message);
			string version = Version;
			SasProtocol protocol = Protocol;
			DateTimeOffset startsOn = StartsOn;
			DateTimeOffset expiresOn = ExpiresOn;
			SasIPRange iPRange = IPRange;
			string resource = Resource;
			string permissions = Permissions;
			string signedObjectId = userDelegationKey.SignedObjectId;
			string signedTenantId = userDelegationKey.SignedTenantId;
			DateTimeOffset signedStartsOn = userDelegationKey.SignedStartsOn;
			DateTimeOffset signedExpiresOn = userDelegationKey.SignedExpiresOn;
			string signedService = userDelegationKey.SignedService;
			string signedVersion = userDelegationKey.SignedVersion;
			return new BlobSasQueryParameters(version, null, null, protocol, startsOn, expiresOn, iPRange, null, resource, permissions, signature, signedObjectId, signedTenantId, signedStartsOn, signedExpiresOn, signedService, signedVersion, CacheControl, ContentDisposition, ContentEncoding, ContentLanguage, ContentType, PreauthorizedAgentObjectId, null, CorrelationId, EncryptionScope);
		}

		private static string GetCanonicalName(string account, string containerName, string blobName)
		{
			if (string.IsNullOrEmpty(blobName))
			{
				return "/blob/" + account + "/" + containerName;
			}
			return "/blob/" + account + "/" + containerName + "/" + blobName.Replace("\\", "/");
		}

		private static string ComputeHMACSHA256(string userDelegationKeyValue, string message)
		{
			return Convert.ToBase64String(new HMACSHA256(Convert.FromBase64String(userDelegationKeyValue)).ComputeHash(Encoding.UTF8.GetBytes(message)));
		}

		private void EnsureState()
		{
			if (Identifier == null)
			{
				if (ExpiresOn == default(DateTimeOffset))
				{
					throw Azure.Storage.Errors.SasMissingData("ExpiresOn");
				}
				if (string.IsNullOrEmpty(Permissions))
				{
					throw Azure.Storage.Errors.SasMissingData("Permissions");
				}
			}
			if (string.IsNullOrEmpty(BlobName))
			{
				Resource = "c";
			}
			else if (string.IsNullOrEmpty(Snapshot) && string.IsNullOrEmpty(BlobVersionId))
			{
				Resource = "b";
			}
			else if (string.IsNullOrEmpty(BlobVersionId))
			{
				Resource = "bs";
			}
			else
			{
				Resource = "bv";
			}
			Version = Azure.Storage.Sas.SasQueryParametersInternals.DefaultSasVersionInternal;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override string ToString()
		{
			return base.ToString();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override bool Equals(object obj)
		{
			return base.Equals(obj);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		internal static BlobSasBuilder DeepCopy(BlobSasBuilder originalBlobSasBuilder)
		{
			return new BlobSasBuilder
			{
				Version = originalBlobSasBuilder.Version,
				Protocol = originalBlobSasBuilder.Protocol,
				StartsOn = originalBlobSasBuilder.StartsOn,
				ExpiresOn = originalBlobSasBuilder.ExpiresOn,
				Permissions = originalBlobSasBuilder.Permissions,
				IPRange = originalBlobSasBuilder.IPRange,
				Identifier = originalBlobSasBuilder.Identifier,
				BlobContainerName = originalBlobSasBuilder.BlobContainerName,
				BlobName = originalBlobSasBuilder.BlobName,
				Snapshot = originalBlobSasBuilder.Snapshot,
				BlobVersionId = originalBlobSasBuilder.BlobVersionId,
				Resource = originalBlobSasBuilder.Resource,
				CacheControl = originalBlobSasBuilder.CacheControl,
				ContentDisposition = originalBlobSasBuilder.ContentDisposition,
				ContentEncoding = originalBlobSasBuilder.ContentEncoding,
				ContentLanguage = originalBlobSasBuilder.ContentLanguage,
				ContentType = originalBlobSasBuilder.ContentType,
				PreauthorizedAgentObjectId = originalBlobSasBuilder.PreauthorizedAgentObjectId,
				CorrelationId = originalBlobSasBuilder.CorrelationId,
				EncryptionScope = originalBlobSasBuilder.EncryptionScope
			};
		}
	}
	[Flags]
	public enum BlobSasPermissions
	{
		Read = 1,
		Add = 2,
		Create = 4,
		Write = 8,
		Delete = 0x10,
		Tag = 0x20,
		DeleteBlobVersion = 0x40,
		List = 0x80,
		Move = 0x100,
		Execute = 0x200,
		SetImmutabilityPolicy = 0x400,
		PermanentDelete = 0x800,
		All = -1
	}
	public sealed class BlobSasQueryParameters : SasQueryParameters
	{
		internal UserDelegationKeyProperties KeyProperties { get; set; }

		public string KeyObjectId => KeyProperties?.ObjectId;

		public string KeyTenantId => KeyProperties?.TenantId;

		public DateTimeOffset KeyStartsOn
		{
			get
			{
				if (KeyProperties != null)
				{
					return KeyProperties.StartsOn;
				}
				return default(DateTimeOffset);
			}
		}

		public DateTimeOffset KeyExpiresOn
		{
			get
			{
				if (KeyProperties != null)
				{
					return KeyProperties.ExpiresOn;
				}
				return default(DateTimeOffset);
			}
		}

		public string KeyService => KeyProperties?.Service;

		public string KeyVersion => KeyProperties?.Version;

		public new static BlobSasQueryParameters Empty => new BlobSasQueryParameters();

		internal BlobSasQueryParameters()
		{
		}

		internal BlobSasQueryParameters(string version, AccountSasServices? services, AccountSasResourceTypes? resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string keyOid = null, string keyTid = null, DateTimeOffset keyStart = default(DateTimeOffset), DateTimeOffset keyExpiry = default(DateTimeOffset), string keyService = null, string keyVersion = null, string cacheControl = null, string contentDisposition = null, string contentEncoding = null, string contentLanguage = null, string contentType = null, string authorizedAadObjectId = null, string unauthorizedAadObjectId = null, string correlationId = null, string encryptionScope = null)
			: base(version, services, resourceTypes, protocol, startsOn, expiresOn, ipRange, identifier, resource, permissions, signature, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType, authorizedAadObjectId, unauthorizedAadObjectId, correlationId, null, encryptionScope)
		{
			KeyProperties = new UserDelegationKeyProperties
			{
				ObjectId = keyOid,
				TenantId = keyTid,
				StartsOn = keyStart,
				ExpiresOn = keyExpiry,
				Service = keyService,
				Version = keyVersion
			};
		}

		internal BlobSasQueryParameters(IDictionary<string, string> values)
			: base(values)
		{
			this.ParseKeyProperties(values);
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			KeyProperties.AppendProperties(stringBuilder);
			AppendProperties(stringBuilder);
			return stringBuilder.ToString();
		}
	}
	[Flags]
	public enum BlobVersionSasPermissions
	{
		Delete = 1,
		SetImmutabilityPolicy = 2,
		PermanentDelete = 4,
		All = -1
	}
	internal static class SasQueryParametersExtensions
	{
		internal static void ParseKeyProperties(this BlobSasQueryParameters parameters, IDictionary<string, string> values)
		{
			KeyValuePair<string, string>[] array = values.ToArray();
			parameters.KeyProperties = new UserDelegationKeyProperties();
			foreach (KeyValuePair<string, string> item in (IEnumerable<KeyValuePair<string, string>>)array)
			{
				bool flag = true;
				switch (item.Key.ToUpperInvariant())
				{
				case "SKOID":
					parameters.KeyProperties.ObjectId = item.Value;
					break;
				case "SKTID":
					parameters.KeyProperties.TenantId = item.Value;
					break;
				case "SKT":
					parameters.KeyProperties.StartsOn = DateTimeOffset.ParseExact(item.Value, "yyyy-MM-ddTHH:mm:ssZ", CultureInfo.InvariantCulture);
					break;
				case "SKE":
					parameters.KeyProperties.ExpiresOn = DateTimeOffset.ParseExact(item.Value, "yyyy-MM-ddTHH:mm:ssZ", CultureInfo.InvariantCulture);
					break;
				case "SKS":
					parameters.KeyProperties.Service = item.Value;
					break;
				case "SKV":
					parameters.KeyProperties.Version = item.Value;
					break;
				default:
					flag = false;
					break;
				}
				if (flag)
				{
					values.Remove(item.Key);
				}
			}
		}
	}
	[Flags]
	public enum SnapshotSasPermissions
	{
		Read = 1,
		Write = 2,
		Delete = 4,
		SetImmutabilityPolicy = 8,
		PermanentDelete = 0x10,
		All = -1
	}
	internal static class SasExtensions
	{
		private const string NoneName = null;

		private const string HttpsName = "https";

		private const string HttpsAndHttpName = "https,http";

		internal static string ToPermissionsString(this AccountSasResourceTypes resourceTypes)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if ((resourceTypes & AccountSasResourceTypes.Service) == AccountSasResourceTypes.Service)
			{
				stringBuilder.Append('s');
			}
			if ((resourceTypes & AccountSasResourceTypes.Container) == AccountSasResourceTypes.Container)
			{
				stringBuilder.Append('c');
			}
			if ((resourceTypes & AccountSasResourceTypes.Object) == AccountSasResourceTypes.Object)
			{
				stringBuilder.Append('o');
			}
			return stringBuilder.ToString();
		}

		internal static AccountSasResourceTypes ParseResourceTypes(string s)
		{
			AccountSasResourceTypes accountSasResourceTypes = (AccountSasResourceTypes)0;
			foreach (char c in s)
			{
				AccountSasResourceTypes accountSasResourceTypes2 = accountSasResourceTypes;
				accountSasResourceTypes = (AccountSasResourceTypes)((int)accountSasResourceTypes2 | (c switch
				{
					's' => 1, 
					'c' => 2, 
					'o' => 4, 
					_ => throw Azure.Storage.Errors.InvalidResourceType(c), 
				}));
			}
			return accountSasResourceTypes;
		}

		internal static string ToProtocolString(this SasProtocol protocol)
		{
			return protocol switch
			{
				SasProtocol.Https => "https", 
				SasProtocol.HttpsAndHttp => "https,http", 
				_ => null, 
			};
		}

		public static SasProtocol ParseProtocol(string s)
		{
			if (s != null && (s == null || s.Length != 0))
			{
				if (!(s == "https"))
				{
					if (s == "https,http")
					{
						return SasProtocol.HttpsAndHttp;
					}
					throw Azure.Storage.Errors.InvalidSasProtocol("s", "SasProtocol");
				}
				return SasProtocol.Https;
			}
			return SasProtocol.None;
		}

		internal static string ToPermissionsString(this AccountSasServices services)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if ((services & AccountSasServices.Blobs) == AccountSasServices.Blobs)
			{
				stringBuilder.Append('b');
			}
			if ((services & AccountSasServices.Files) == AccountSasServices.Files)
			{
				stringBuilder.Append('f');
			}
			if ((services & AccountSasServices.Queues) == AccountSasServices.Queues)
			{
				stringBuilder.Append('q');
			}
			if ((services & AccountSasServices.Tables) == AccountSasServices.Tables)
			{
				stringBuilder.Append('t');
			}
			return stringBuilder.ToString();
		}

		internal static AccountSasServices ParseAccountServices(string s)
		{
			AccountSasServices accountSasServices = (AccountSasServices)0;
			foreach (char c in s)
			{
				AccountSasServices accountSasServices2 = accountSasServices;
				accountSasServices = (AccountSasServices)((int)accountSasServices2 | (c switch
				{
					'b' => 1, 
					'q' => 2, 
					'f' => 4, 
					't' => 8, 
					_ => throw Azure.Storage.Errors.InvalidService(c), 
				}));
			}
			return accountSasServices;
		}

		internal static string FormatTimesForSasSigning(DateTimeOffset time)
		{
			if (!(time == default(DateTimeOffset)))
			{
				return time.ToString("yyyy-MM-ddTHH:mm:ssZ", CultureInfo.InvariantCulture);
			}
			return "";
		}

		internal static void AddToBuilder(StringBuilder sb, string key, string value)
		{
			sb.Append((sb.Length > 0) ? "&" : "").Append(key).Append('=')
				.Append(value);
		}

		internal static string ValidateAndSanitizeRawPermissions(string permissions, List<char> validPermissionsInOrder)
		{
			if (permissions == null)
			{
				return null;
			}
			permissions = permissions.ToLowerInvariant();
			HashSet<char> hashSet = new HashSet<char>(validPermissionsInOrder);
			HashSet<char> hashSet2 = new HashSet<char>();
			string text = permissions;
			foreach (char c in text)
			{
				if (!hashSet.Contains(c))
				{
					throw new ArgumentException($"{c} is not a valid SAS permission");
				}
				hashSet2.Add(c);
			}
			StringBuilder stringBuilder = new StringBuilder();
			foreach (char item in validPermissionsInOrder)
			{
				if (hashSet2.Contains(item))
				{
					stringBuilder.Append(item);
				}
			}
			return stringBuilder.ToString();
		}
	}
	internal class SasQueryParametersInternals : SasQueryParameters
	{
		internal static string DefaultSasVersionInternal { get; set; } = "2023-11-03";

		internal new static SasQueryParameters Create(IDictionary<string, string> values)
		{
			return SasQueryParameters.Create(values);
		}

		internal new static SasQueryParameters Create(string version, AccountSasServices? services, AccountSasResourceTypes? resourceTypes, SasProtocol protocol, DateTimeOffset startsOn, DateTimeOffset expiresOn, SasIPRange ipRange, string identifier, string resource, string permissions, string signature, string cacheControl = null, string contentDisposition = null, string contentEncoding = null, string contentLanguage = null, string contentType = null, string authorizedAadObjectId = null, string unauthorizedAadObjectId = null, string correlationId = null, int? directoryDepth = null, string encryptionScope = null)
		{
			return SasQueryParameters.Create(version, services, resourceTypes, protocol, startsOn, expiresOn, ipRange, identifier, resource, permissions, signature, cacheControl, contentDisposition, contentEncoding, contentLanguage, contentType, authorizedAadObjectId, unauthorizedAadObjectId, correlationId, directoryDepth, encryptionScope);
		}
	}
	internal class UserDelegationKeyProperties
	{
		internal string ObjectId { get; set; }

		internal string TenantId { get; set; }

		internal DateTimeOffset StartsOn { get; set; }

		internal DateTimeOffset ExpiresOn { get; set; }

		internal string Service { get; set; }

		internal string Version { get; set; }

		public void AppendProperties(StringBuilder stringBuilder)
		{
			if (!string.IsNullOrWhiteSpace(ObjectId))
			{
				stringBuilder.AppendQueryParameter("skoid", ObjectId);
			}
			if (!string.IsNullOrWhiteSpace(TenantId))
			{
				stringBuilder.AppendQueryParameter("sktid", TenantId);
			}
			if (StartsOn != DateTimeOffset.MinValue)
			{
				stringBuilder.AppendQueryParameter("skt", WebUtility.UrlEncode(StartsOn.ToString("yyyy-MM-ddTHH:mm:ssZ", CultureInfo.InvariantCulture)));
			}
			if (ExpiresOn != DateTimeOffset.MinValue)
			{
				stringBuilder.AppendQueryParameter("ske", WebUtility.UrlEncode(ExpiresOn.ToString("yyyy-MM-ddTHH:mm:ssZ", CultureInfo.InvariantCulture)));
			}
			if (!string.IsNullOrWhiteSpace(Service))
			{
				stringBuilder.AppendQueryParameter("sks", Service);
			}
			if (!string.IsNullOrWhiteSpace(Version))
			{
				stringBuilder.AppendQueryParameter("skv", Version);
			}
		}
	}
}
namespace Azure.Storage.Blobs
{
	internal class AppendBlobWriteStream : StorageWriteStream
	{
		private readonly AppendBlobClient _appendBlobClient;

		private readonly AppendBlobRequestConditions _conditions;

		public AppendBlobWriteStream(AppendBlobClient appendBlobClient, long bufferSize, long position, AppendBlobRequestConditions conditions, IProgress<long> progressHandler, UploadTransferValidationOptions transferValidation)
			: base(position, bufferSize, progressHandler, transferValidation)
		{
			ValidateBufferSize(bufferSize);
			_appendBlobClient = appendBlobClient;
			_conditions = conditions ?? new AppendBlobRequestConditions();
		}

		protected override async Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken)
		{
			if (_buffer.Length > 0)
			{
				_buffer.Position = 0L;
				Response<BlobAppendInfo> response = await _appendBlobClient.AppendBlockInternal(_buffer, validationOptions, _conditions, _progressHandler, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				_conditions.IfMatch = response.Value.ETag;
			}
		}

		protected override void ValidateBufferSize(long bufferSize)
		{
			if (bufferSize < 1)
			{
				throw new ArgumentOutOfRangeException("bufferSize", "Must be greater than or equal to 1");
			}
			if (bufferSize > 104857600)
			{
				throw new ArgumentOutOfRangeException("bufferSize", $"Must less than or equal to {104857600}");
			}
		}
	}
	public class BlobClient : BlobBaseClient
	{
		private BlockBlobClient _blockBlobClient;

		private BlockBlobClient BlockBlobClient
		{
			get
			{
				if (_blockBlobClient == null)
				{
					_blockBlobClient = new BlockBlobClient(Uri, ClientConfiguration, ClientSideEncryption);
				}
				return _blockBlobClient;
			}
		}

		protected BlobClient()
		{
		}

		public BlobClient(string connectionString, string blobContainerName, string blobName)
			: base(connectionString, blobContainerName, blobName)
		{
		}

		public BlobClient(string connectionString, string blobContainerName, string blobName, BlobClientOptions options)
			: base(connectionString, blobContainerName, blobName, options)
		{
		}

		public BlobClient(Uri blobUri, BlobClientOptions options = null)
			: base(blobUri, options)
		{
		}

		public BlobClient(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options = null)
			: base(blobUri, credential, options)
		{
		}

		public BlobClient(Uri blobUri, AzureSasCredential credential, BlobClientOptions options = null)
			: base(blobUri, credential, options)
		{
		}

		public BlobClient(Uri blobUri, TokenCredential credential, BlobClientOptions options = null)
			: base(blobUri, credential, options)
		{
		}

		internal BlobClient(Uri blobUri, BlobClientConfiguration clientConfiguration, ClientSideEncryptionOptions clientSideEncryption)
			: base(blobUri, clientConfiguration, clientSideEncryption)
		{
		}

		public new BlobClient WithSnapshot(string snapshot)
		{
			return new BlobClient(new BlobUriBuilder(Uri)
			{
				Snapshot = snapshot
			}.ToUri(), ClientConfiguration, ClientSideEncryption);
		}

		public new BlobClient WithVersion(string versionId)
		{
			return new BlobClient(new BlobUriBuilder(Uri)
			{
				VersionId = versionId
			}.ToUri(), ClientConfiguration, ClientSideEncryption);
		}

		public new BlobClient WithCustomerProvidedKey(CustomerProvidedKey? customerProvidedKey)
		{
			BlobClientConfiguration blobClientConfiguration = BlobClientConfiguration.DeepCopy(ClientConfiguration);
			blobClientConfiguration.CustomerProvidedKey = customerProvidedKey;
			return new BlobClient(Uri, blobClientConfiguration, ClientSideEncryption?.Clone());
		}

		public new BlobClient WithEncryptionScope(string encryptionScope)
		{
			BlobClientConfiguration blobClientConfiguration = BlobClientConfiguration.DeepCopy(ClientConfiguration);
			blobClientConfiguration.EncryptionScope = encryptionScope;
			return new BlobClient(Uri, blobClientConfiguration, ClientSideEncryption?.Clone());
		}

		protected internal virtual BlobClient WithClientSideEncryptionOptionsCore(ClientSideEncryptionOptions clientSideEncryptionOptions)
		{
			return new BlobClient(Uri, ClientConfiguration, clientSideEncryptionOptions);
		}

		public virtual Response<BlobContentInfo> Upload(Stream content)
		{
			return Upload(content, CancellationToken.None);
		}

		public virtual Response<BlobContentInfo> Upload(BinaryData content)
		{
			return Upload(content, CancellationToken.None);
		}

		public virtual Response<BlobContentInfo> Upload(string path)
		{
			return Upload(path, CancellationToken.None);
		}

		public virtual async Task<Response<BlobContentInfo>> UploadAsync(Stream content)
		{
			return await UploadAsync(content, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual async Task<Response<BlobContentInfo>> UploadAsync(BinaryData content)
		{
			return await UploadAsync(content, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual async Task<Response<BlobContentInfo>> UploadAsync(string path)
		{
			return await UploadAsync(path, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<BlobContentInfo> Upload(Stream content, CancellationToken cancellationToken)
		{
			return Upload(content, overwrite: false, cancellationToken);
		}

		public virtual Response<BlobContentInfo> Upload(BinaryData content, CancellationToken cancellationToken)
		{
			return Upload(content, overwrite: false, cancellationToken);
		}

		public virtual Response<BlobContentInfo> Upload(string path, CancellationToken cancellationToken)
		{
			return Upload(path, overwrite: false, cancellationToken);
		}

		public virtual Task<Response<BlobContentInfo>> UploadAsync(Stream content, CancellationToken cancellationToken)
		{
			return UploadAsync(content, overwrite: false, cancellationToken);
		}

		public virtual Task<Response<BlobContentInfo>> UploadAsync(BinaryData content, CancellationToken cancellationToken)
		{
			return UploadAsync(content, overwrite: false, cancellationToken);
		}

		public virtual async Task<Response<BlobContentInfo>> UploadAsync(string path, CancellationToken cancellationToken)
		{
			return await UploadAsync(path, overwrite: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<BlobContentInfo> Upload(Stream content, bool overwrite = false, CancellationToken cancellationToken = default(CancellationToken))
		{
			return Upload(content, null, null, overwrite ? null : new BlobRequestConditions
			{
				IfNoneMatch = new ETag("*")
			}, null, null, default(StorageTransferOptions), cancellationToken);
		}

		public virtual Response<BlobContentInfo> Upload(BinaryData content, bool overwrite = false, CancellationToken cancellationToken = default(CancellationToken))
		{
			return Upload(content, overwrite ? null : new BlobUploadOptions
			{
				Conditions = new BlobRequestConditions
				{
					IfNoneMatch = new ETag("*")
				}
			}, cancellationToken);
		}

		public virtual Response<BlobContentInfo> Upload(string path, bool overwrite = false, CancellationToken cancellationToken = default(CancellationToken))
		{
			return Upload(path, null, null, overwrite ? null : new BlobRequestConditions
			{
				IfNoneMatch = new ETag("*")
			}, null, null, default(StorageTransferOptions), cancellationToken);
		}

		public virtual Task<Response<BlobContentInfo>> UploadAsync(Stream content, bool overwrite = false, CancellationToken cancellationToken = default(CancellationToken))
		{
			return UploadAsync(content, null, null, overwrite ? null : new BlobRequestConditions
			{
				IfNoneMatch = new ETag("*")
			}, null, null, default(StorageTransferOptions), cancellationToken);
		}

		public virtual Task<Response<BlobContentInfo>> UploadAsync(BinaryData content, bool overwrite = false, CancellationToken cancellationToken = default(CancellationToken))
		{
			return UploadAsync(content, overwrite ? null : new BlobUploadOptions
			{
				Conditions = new BlobRequestConditions
				{
					IfNoneMatch = new ETag("*")
				}
			}, cancellationToken);
		}

		public virtual async Task<Response<BlobContentInfo>> UploadAsync(string path, bool overwrite = false, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await UploadAsync(path, null, null, overwrite ? null : new BlobRequestConditions
			{
				IfNoneMatch = new ETag("*")
			}, null, null, default(StorageTransferOptions), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<BlobContentInfo> Upload(Stream content, BlobUploadOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return StagedUploadInternal(content, options, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual Response<BlobContentInfo> Upload(BinaryData content, BlobUploadOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return StagedUploadInternal(content.ToStream(), options, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobContentInfo> Upload(Stream content, BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, BlobRequestConditions conditions = null, IProgress<long> progressHandler = null, AccessTier? accessTier = null, StorageTransferOptions transferOptions = default(StorageTransferOptions), CancellationToken cancellationToken = default(CancellationToken))
		{
			return StagedUploadInternal(content, new BlobUploadOptions
			{
				HttpHeaders = httpHeaders,
				Metadata = metadata,
				Conditions = conditions,
				ProgressHandler = progressHandler,
				AccessTier = accessTier,
				TransferOptions = transferOptions
			}, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual Response<BlobContentInfo> Upload(string path, BlobUploadOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			using FileStream content = new FileStream(path, FileMode.Open, FileAccess.Read);
			return StagedUploadInternal(content, options, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobContentInfo> Upload(string path, BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, BlobRequestConditions conditions = null, IProgress<long> progressHandler = null, AccessTier? accessTier = null, StorageTransferOptions transferOptions = default(StorageTransferOptions), CancellationToken cancellationToken = default(CancellationToken))
		{
			using FileStream content = new FileStream(path, FileMode.Open, FileAccess.Read);
			return StagedUploadInternal(content, new BlobUploadOptions
			{
				HttpHeaders = httpHeaders,
				Metadata = metadata,
				Conditions = conditions,
				ProgressHandler = progressHandler,
				AccessTier = accessTier,
				TransferOptions = transferOptions
			}, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContentInfo>> UploadAsync(Stream content, BlobUploadOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await StagedUploadInternal(content, options, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual async Task<Response<BlobContentInfo>> UploadAsync(BinaryData content, BlobUploadOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await StagedUploadInternal(content.ToStream(), options, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[ForwardsClientCalls]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Task<Response<BlobContentInfo>> UploadAsync(Stream content, BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, BlobRequestConditions conditions = null, IProgress<long> progressHandler = null, AccessTier? accessTier = null, StorageTransferOptions transferOptions = default(StorageTransferOptions), CancellationToken cancellationToken = default(CancellationToken))
		{
			return StagedUploadInternal(content, new BlobUploadOptions
			{
				HttpHeaders = httpHeaders,
				Metadata = metadata,
				Conditions = conditions,
				ProgressHandler = progressHandler,
				AccessTier = accessTier,
				TransferOptions = transferOptions
			}, async: true, cancellationToken);
		}

		public virtual async Task<Response<BlobContentInfo>> UploadAsync(string path, BlobUploadOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			using FileStream stream = new FileStream(path, FileMode.Open, FileAccess.Read);
			return await StagedUploadInternal(stream, options, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[ForwardsClientCalls]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobContentInfo>> UploadAsync(string path, BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, BlobRequestConditions conditions = null, IProgress<long> progressHandler = null, AccessTier? accessTier = null, StorageTransferOptions transferOptions = default(StorageTransferOptions), CancellationToken cancellationToken = default(CancellationToken))
		{
			using FileStream stream = new FileStream(path, FileMode.Open, FileAccess.Read);
			return await StagedUploadInternal(stream, new BlobUploadOptions
			{
				HttpHeaders = httpHeaders,
				Metadata = metadata,
				Conditions = conditions,
				ProgressHandler = progressHandler,
				AccessTier = accessTier,
				TransferOptions = transferOptions
			}, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal async Task<Response<BlobContentInfo>> StagedUploadInternal(Stream content, BlobUploadOptions options, bool async = true, CancellationToken cancellationToken = default(CancellationToken))
		{
			UploadTransferValidationOptions validationOptions = options?.TransferValidation ?? ClientConfiguration.TransferValidation.Upload;
			long? expectedContentLength = null;
			if (UsingClientSideEncryption)
			{
				if (options == null)
				{
					options = new BlobUploadOptions();
				}
				expectedContentLength = content.GetLengthOrDefault();
				IClientSideEncryptor clientSideEncryptor = ClientSideEncryption.GetClientSideEncryptor();
				if (expectedContentLength.HasValue)
				{
					expectedContentLength = clientSideEncryptor.ExpectedOutputContentLength(expectedContentLength.Value);
				}
				(content, options.Metadata) = await new BlobClientSideEncryptor(clientSideEncryptor).ClientSideEncryptInternal(content, options.Metadata, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			return await GetPartitionedUploader(options?.TransferOptions ?? default(StorageTransferOptions), validationOptions, null, "BlobClient.Upload").UploadInternal(content, expectedContentLength, options, options?.ProgressHandler, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal async Task<Response<BlobContentInfo>> StagedUploadInternal(string path, BlobUploadOptions options, bool async = true, CancellationToken cancellationToken = default(CancellationToken))
		{
			using FileStream stream = new FileStream(path, FileMode.Open, FileAccess.Read);
			return await StagedUploadInternal(stream, options, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[ForwardsClientCalls]
		public virtual Stream OpenWrite(bool overwrite, BlobOpenWriteOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return OpenWriteInternal(overwrite, options, async: false, cancellationToken).EnsureCompleted();
		}

		[ForwardsClientCalls]
		public virtual async Task<Stream> OpenWriteAsync(bool overwrite, BlobOpenWriteOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await OpenWriteInternal(overwrite, options, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal async Task<Stream> OpenWriteInternal(bool overwrite, BlobOpenWriteOptions options, bool async, CancellationToken cancellationToken)
		{
			if (UsingClientSideEncryption)
			{
				return await new BlobClientSideEncryptor(ClientSideEncryption.GetClientSideEncryptor()).ClientSideEncryptionOpenWriteInternal(BlockBlobClient, overwrite, options?.ToBlockBlobOpenWriteOptions(), async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			return await BlockBlobClient.OpenWriteInternal(overwrite, options?.ToBlockBlobOpenWriteOptions(), async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal PartitionedUploader<BlobUploadOptions, BlobContentInfo> GetPartitionedUploader(StorageTransferOptions transferOptions, UploadTransferValidationOptions validationOptions, ArrayPool<byte> arrayPool = null, string operationName = null)
		{
			return BlockBlobClient.GetPartitionedUploader(transferOptions, validationOptions, arrayPool, operationName);
		}
	}
	public class BlobClientOptions : ClientOptions, Azure.Storage.Shared.ISupportsTenantIdChallenges
	{
		public enum ServiceVersion
		{
			V2019_02_02 = 1,
			V2019_07_07,
			V2019_12_12,
			V2020_02_10,
			V2020_04_08,
			V2020_06_12,
			V2020_08_04,
			V2020_10_02,
			V2020_12_06,
			V2021_02_12,
			V2021_04_10,
			V2021_06_08,
			V2021_08_06,
			V2021_10_04,
			V2021_12_02,
			V2022_11_02,
			V2023_01_03,
			V2023_05_03,
			V2023_08_03,
			V2023_11_03
		}

		internal const ServiceVersion LatestVersion = ServiceVersion.V2023_11_03;

		internal ClientSideEncryptionOptions _clientSideEncryptionOptions;

		public ServiceVersion Version { get; }

		public CustomerProvidedKey? CustomerProvidedKey { get; set; }

		public string EncryptionScope { get; set; }

		public Uri GeoRedundantSecondaryUri { get; set; }

		public TransferValidationOptions TransferValidation { get; } = new TransferValidationOptions();

		public bool TrimBlobNameSlashes { get; set; } = true;

		public bool EnableTenantDiscovery { get; set; }

		public BlobAudience? Audience { get; set; }

		public BlobClientOptions(ServiceVersion version = ServiceVersion.V2023_11_03)
		{
			if (ServiceVersion.V2019_02_02 <= version && version <= ServiceVersion.V2023_11_03)
			{
				Version = version;
				this.Initialize();
				AddHeadersAndQueryParameters();
				return;
			}
			throw Azure.Storage.Errors.VersionNotSupported("version");
		}

		private void AddHeadersAndQueryParameters()
		{
			base.Diagnostics.LoggedHeaderNames.Add("Access-Control-Allow-Origin");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-date");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-error-code");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-request-id");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-version");
			base.Diagnostics.LoggedHeaderNames.Add("Accept-Ranges");
			base.Diagnostics.LoggedHeaderNames.Add("Content-Disposition");
			base.Diagnostics.LoggedHeaderNames.Add("Content-Encoding");
			base.Diagnostics.LoggedHeaderNames.Add("Content-Language");
			base.Diagnostics.LoggedHeaderNames.Add("Content-MD5");
			base.Diagnostics.LoggedHeaderNames.Add("Content-Range");
			base.Diagnostics.LoggedHeaderNames.Add("Vary");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-content-crc64");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-copy-action");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-copy-completion-time");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-copy-id");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-copy-progress");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-copy-status");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-has-immutability-policy");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-has-legal-hold");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-lease-state");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-lease-status");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-range");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-request-server-encrypted");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-server-encrypted");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-snapshot");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-source-range");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-access-tier");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-access-tier-change-time");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-access-tier-inferred");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-account-kind");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-archive-status");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-blob-append-offset");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-blob-cache-control");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-blob-committed-block-count");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-blob-condition-appendpos");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-blob-condition-maxsize");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-blob-content-disposition");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-blob-content-encoding");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-blob-content-language");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-blob-content-length");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-blob-content-md5");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-blob-content-type");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-blob-public-access");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-blob-sequence-number");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-blob-type");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-copy-destination-snapshot");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-creation-time");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-default-encryption-scope");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-delete-snapshots");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-delete-type-permanent");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-deny-encryption-scope-override");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-encryption-algorithm");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-if-sequence-number-eq");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-if-sequence-number-le");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-if-sequence-number-lt");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-incremental-copy");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-lease-action");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-lease-break-period");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-lease-duration");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-lease-id");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-lease-time");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-page-write");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-proposed-lease-id");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-range-get-content-md5");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-rehydrate-priority");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-sequence-number-action");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-sku-name");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-source-content-md5");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-source-if-match");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-source-if-modified-since");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-source-if-none-match");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-source-if-unmodified-since");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-tag-count");
			base.Diagnostics.LoggedHeaderNames.Add("x-ms-encryption-key-sha256");
			base.Diagnostics.LoggedQueryParameters.Add("comp");
			base.Diagnostics.LoggedQueryParameters.Add("maxresults");
			base.Diagnostics.LoggedQueryParameters.Add("rscc");
			base.Diagnostics.LoggedQueryParameters.Add("rscd");
			base.Diagnostics.LoggedQueryParameters.Add("rsce");
			base.Diagnostics.LoggedQueryParameters.Add("rscl");
			base.Diagnostics.LoggedQueryParameters.Add("rsct");
			base.Diagnostics.LoggedQueryParameters.Add("se");
			base.Diagnostics.LoggedQueryParameters.Add("si");
			base.Diagnostics.LoggedQueryParameters.Add("sip");
			base.Diagnostics.LoggedQueryParameters.Add("sp");
			base.Diagnostics.LoggedQueryParameters.Add("spr");
			base.Diagnostics.LoggedQueryParameters.Add("sr");
			base.Diagnostics.LoggedQueryParameters.Add("srt");
			base.Diagnostics.LoggedQueryParameters.Add("ss");
			base.Diagnostics.LoggedQueryParameters.Add("st");
			base.Diagnostics.LoggedQueryParameters.Add("sv");
			base.Diagnostics.LoggedQueryParameters.Add("include");
			base.Diagnostics.LoggedQueryParameters.Add("marker");
			base.Diagnostics.LoggedQueryParameters.Add("prefix");
			base.Diagnostics.LoggedQueryParameters.Add("copyid");
			base.Diagnostics.LoggedQueryParameters.Add("restype");
			base.Diagnostics.LoggedQueryParameters.Add("blockid");
			base.Diagnostics.LoggedQueryParameters.Add("blocklisttype");
			base.Diagnostics.LoggedQueryParameters.Add("delimiter");
			base.Diagnostics.LoggedQueryParameters.Add("prevsnapshot");
			base.Diagnostics.LoggedQueryParameters.Add("ske");
			base.Diagnostics.LoggedQueryParameters.Add("skoid");
			base.Diagnostics.LoggedQueryParameters.Add("sks");
			base.Diagnostics.LoggedQueryParameters.Add("skt");
			base.Diagnostics.LoggedQueryParameters.Add("sktid");
			base.Diagnostics.LoggedQueryParameters.Add("skv");
			base.Diagnostics.LoggedQueryParameters.Add("snapshot");
		}

		internal HttpPipeline Build(HttpPipelinePolicy authentication = null)
		{
			return this.Build(authentication, GeoRedundantSecondaryUri);
		}

		internal HttpPipeline Build(object credentials)
		{
			return this.Build(credentials, GeoRedundantSecondaryUri);
		}
	}
	internal class BlobClientSideDecryptor
	{
		private readonly ClientSideDecryptor _decryptor;

		public BlobClientSideDecryptor(ClientSideDecryptor decryptor)
		{
			_decryptor = decryptor;
		}

		public async Task<Stream> DecryptInternal(Stream content, IDictionary<string, string> metadata, HttpRange originalRange, string receivedContentRange, bool async, CancellationToken cancellationToken)
		{
			ContentRange? contentRange = (string.IsNullOrWhiteSpace(receivedContentRange) ? default(ContentRange) : ContentRange.Parse(receivedContentRange));
			EncryptionData encryptionData = GetAndValidateEncryptionDataOrDefault(metadata);
			if (encryptionData == null)
			{
				return await TrimStreamInternal(content, originalRange, contentRange, 0, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			bool ivInStream = originalRange.Offset >= 16;
			Stream stream = await _decryptor.DecryptReadInternal(content, encryptionData, ivInStream, CanIgnorePadding(contentRange), async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			int num = (int)(contentRange?.Start / encryptionData.EncryptedRegionInfo?.GetTotalRegionLength()).GetValueOrDefault();
			int num2;
			switch (encryptionData.EncryptionAgent.EncryptionVersion)
			{
			case ClientSideEncryptionVersion.V1_0:
				num2 = (ivInStream ? 16 : 0);
				break;
			case ClientSideEncryptionVersion.V2_0:
				num2 = ((contentRange.HasValue && contentRange.GetValueOrDefault().Start > 0) ? (-encryptionData.EncryptedRegionInfo.NonceLength * num - 16 * num) : 0);
				break;
			default:
				throw Azure.Storage.Errors.ClientSideEncryption.ClientSideEncryptionVersionNotSupported();
			}
			int alreadyTrimmedOffsetAmount = num2;
			return await TrimStreamInternal(stream, originalRange, contentRange, alreadyTrimmedOffsetAmount, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public async Task<Stream> DecryptWholeBlobWriteInternal(Stream plaintextDestination, IDictionary<string, string> metadata, bool async, CancellationToken cancellationToken)
		{
			EncryptionData andValidateEncryptionDataOrDefault = GetAndValidateEncryptionDataOrDefault(metadata);
			if (andValidateEncryptionDataOrDefault == null)
			{
				return plaintextDestination;
			}
			return await _decryptor.DecryptWholeContentWriteInternal(plaintextDestination, andValidateEncryptionDataOrDefault, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private static async Task<Stream> TrimStreamInternal(Stream stream, HttpRange originalRange, ContentRange? receivedRange, int alreadyTrimmedOffsetAmount, bool async, CancellationToken cancellationToken)
		{
			int gap = (int)(originalRange.Offset - (receivedRange?.Start).GetValueOrDefault()) - alreadyTrimmedOffsetAmount;
			int num = 0;
			while (gap > num)
			{
				int num2 = gap - num;
				if (async)
				{
					int num3 = num;
					num = num3 + await stream.ReadAsync(new byte[num2], 0, num2, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				else
				{
					num += stream.Read(new byte[num2], 0, num2);
				}
			}
			if (originalRange.Length.HasValue)
			{
				stream = WindowStream.GetWindow(stream, originalRange.Length.Value);
			}
			return stream;
		}

		internal static EncryptionData GetAndValidateEncryptionDataOrDefault(IDictionary<string, string> metadata)
		{
			if (metadata == null)
			{
				return null;
			}
			if (!metadata.TryGetValue("encryptiondata", out var value))
			{
				return null;
			}
			EncryptionData encryptionData = EncryptionDataSerializer.Deserialize(value);
			switch (encryptionData.EncryptionAgent.EncryptionVersion)
			{
			case ClientSideEncryptionVersion.V1_0:
				if (encryptionData.ContentEncryptionIV == null)
				{
					throw Azure.Storage.Errors.ClientSideEncryption.MissingEncryptionMetadata("ContentEncryptionIV");
				}
				break;
			case ClientSideEncryptionVersion.V2_0:
				if (encryptionData.EncryptedRegionInfo == null)
				{
					throw Azure.Storage.Errors.ClientSideEncryption.MissingEncryptionMetadata("EncryptedRegionInfo");
				}
				break;
			default:
				throw Azure.Storage.Errors.ClientSideEncryption.ClientSideEncryptionVersionNotSupported();
			}
			if (encryptionData.WrappedContentKey.EncryptedKey == null)
			{
				throw Azure.Storage.Errors.ClientSideEncryption.MissingEncryptionMetadata("EncryptedKey");
			}
			return encryptionData;
		}

		private static bool CanIgnorePadding(ContentRange? contentRange)
		{
			if (!contentRange.HasValue)
			{
				return false;
			}
			if (!contentRange.Value.End.HasValue)
			{
				return false;
			}
			if (contentRange.Value.Size - contentRange.Value.End == 1)
			{
				return false;
			}
			return true;
		}

		internal static HttpRange GetEncryptedBlobRange(HttpRange originalRange, string rawEncryptionData)
		{
			Azure.Core.Argument.AssertNotNull(rawEncryptionData, "rawEncryptionData");
			EncryptionData encryptionData = EncryptionDataSerializer.Deserialize(rawEncryptionData);
			return GetEncryptedBlobRange(originalRange, encryptionData);
		}

		internal static HttpRange GetEncryptedBlobRange(HttpRange originalRange, EncryptionData encryptionData)
		{
			if (encryptionData == null)
			{
				return originalRange;
			}
			return encryptionData.EncryptionAgent.EncryptionVersion switch
			{
				ClientSideEncryptionVersion.V1_0 => GetEncryptedBlobRangeV1_0(originalRange), 
				ClientSideEncryptionVersion.V2_0 => GetEncryptedBlobRangeV2_0(originalRange, encryptionData), 
				_ => throw Azure.Storage.Errors.InvalidArgument("encryptionData"), 
			};
		}

		private static HttpRange GetEncryptedBlobRangeV2_0(HttpRange originalRange, EncryptionData encryptionData)
		{
			int dataLength = encryptionData.EncryptedRegionInfo.DataLength;
			int num = encryptionData.EncryptedRegionInfo.NonceLength + encryptionData.EncryptedRegionInfo.DataLength + 16;
			long num2 = 0L;
			long? length = null;
			if (originalRange.Offset != 0L)
			{
				num2 = originalRange.Offset / dataLength * num;
			}
			if (originalRange.Length.HasValue)
			{
				long num3 = (originalRange.Offset + originalRange.Length.Value - 1) / dataLength;
				length = (num3 + 1) * num - num2;
			}
			return new HttpRange(num2, length);
		}

		private static HttpRange GetEncryptedBlobRangeV1_0(HttpRange originalRange)
		{
			int num = 0;
			long? num2 = originalRange.Length;
			if (originalRange.Offset != 0L)
			{
				int num3;
				if ((num3 = (int)(originalRange.Offset % 16)) != 0)
				{
					num += num3;
					if (num2.HasValue)
					{
						num2 += num3;
					}
				}
				if (originalRange.Offset >= 16)
				{
					num += 16;
					if (num2.HasValue)
					{
						num2 += 16;
					}
				}
			}
			if (num2.HasValue)
			{
				num2 += (16 - (int)(num2 % 16).Value) % 16;
			}
			return new HttpRange(originalRange.Offset - num, num2);
		}
	}
	internal static class EncryptionRangeExtensions
	{
		public static int GetTotalRegionLength(this EncryptedRegionInfo info)
		{
			return info.NonceLength + info.DataLength + 16;
		}
	}
	internal class BlobClientSideEncryptor
	{
		private readonly IClientSideEncryptor _encryptor;

		public BlobClientSideEncryptor(IClientSideEncryptor encryptor)
		{
			_encryptor = encryptor;
		}

		public async Task<(Stream NonSeekableCiphertext, IDictionary<string, string> Metadata)> ClientSideEncryptInternal(Stream content, IDictionary<string, string> metadata, bool async, CancellationToken cancellationToken)
		{
			(Stream, EncryptionData) obj = await _encryptor.EncryptInternal(content, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			Stream item = obj.Item1;
			EncryptionData item2 = obj.Item2;
			IDictionary<string, string> item3 = TransformMetadata(metadata, item2);
			return (NonSeekableCiphertext: item, Metadata: item3);
		}

		public async Task<Stream> ClientSideEncryptionOpenWriteInternal(BlockBlobClient blobClient, bool overwrite, BlockBlobOpenWriteOptions options, bool async, CancellationToken cancellationToken)
		{
			return await _encryptor.EncryptedOpenWriteInternal(async delegate(EncryptionData encryptiondata, bool funcAsync, CancellationToken funcCancellationToken)
			{
				if (options == null)
				{
					options = new BlockBlobOpenWriteOptions();
				}
				options.Metadata = TransformMetadata(options.Metadata, encryptiondata);
				return await blobClient.OpenWriteInternal(overwrite, options, funcAsync, funcCancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private static IDictionary<string, string> TransformMetadata(IDictionary<string, string> metadata, EncryptionData encryptionData)
		{
			Dictionary<string, string> obj = ((metadata == null) ? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase) : new Dictionary<string, string>(metadata, StringComparer.OrdinalIgnoreCase));
			((IDictionary<string, string>)obj)["encryptiondata"] = EncryptionDataSerializer.Serialize(encryptionData);
			return obj;
		}
	}
	public class BlobContainerClient
	{
		public static readonly string RootBlobContainerName = "$root";

		public static readonly string LogsBlobContainerName = "$logs";

		public static readonly string WebBlobContainerName = "$web";

		private readonly Uri _uri;

		private readonly BlobClientConfiguration _clientConfiguration;

		private readonly HttpPipelinePolicy _authenticationPolicy;

		private readonly ClientSideEncryptionOptions _clientSideEncryption;

		private string _accountName;

		private string _name;

		private readonly ContainerRestClient _containerRestClient;

		private BlobServiceClient _parentBlobServiceClient;

		public virtual Uri Uri => _uri;

		internal virtual BlobClientConfiguration ClientConfiguration => _clientConfiguration;

		internal virtual HttpPipelinePolicy AuthenticationPolicy => _authenticationPolicy;

		internal virtual ClientSideEncryptionOptions ClientSideEncryption => _clientSideEncryption;

		public virtual string AccountName
		{
			get
			{
				SetNameFieldsIfNull();
				return _accountName;
			}
		}

		public virtual string Name
		{
			get
			{
				SetNameFieldsIfNull();
				return _name;
			}
		}

		public virtual bool CanGenerateSasUri => ClientConfiguration.SharedKeyCredential != null;

		internal virtual ContainerRestClient ContainerRestClient => _containerRestClient;

		protected BlobContainerClient()
		{
		}

		public BlobContainerClient(string connectionString, string blobContainerName)
			: this(connectionString, blobContainerName, null)
		{
		}

		public BlobContainerClient(string connectionString, string blobContainerName, BlobClientOptions options)
		{
			Azure.Storage.StorageConnectionString storageConnectionString = Azure.Storage.StorageConnectionString.Parse(connectionString);
			_uri = new BlobUriBuilder(storageConnectionString.BlobEndpoint, options?.TrimBlobNameSlashes ?? true)
			{
				BlobContainerName = blobContainerName
			}.ToUri();
			if (options == null)
			{
				options = new BlobClientOptions();
			}
			_clientConfiguration = new BlobClientConfiguration(options.Build(storageConnectionString.Credentials), storageConnectionString.Credentials as StorageSharedKeyCredential, new Azure.Core.Pipeline.ClientDiagnostics(options), options.Version, options.CustomerProvidedKey, options.TransferValidation, options.EncryptionScope, options.TrimBlobNameSlashes);
			_authenticationPolicy = StorageClientOptions.GetAuthenticationPolicy(storageConnectionString.Credentials);
			_containerRestClient = BuildContainerRestClient(_uri);
			BlobErrors.VerifyHttpsCustomerProvidedKey(_uri, _clientConfiguration.CustomerProvidedKey);
			BlobErrors.VerifyCpkAndEncryptionScopeNotBothSet(_clientConfiguration.CustomerProvidedKey, _clientConfiguration.EncryptionScope);
		}

		public BlobContainerClient(Uri blobContainerUri, BlobClientOptions options = null)
		{
			Azure.Core.Argument.AssertNotNull(blobContainerUri, "blobContainerUri");
			_uri = blobContainerUri;
			_authenticationPolicy = null;
			if (options == null)
			{
				options = new BlobClientOptions();
			}
			_clientConfiguration = new BlobClientConfiguration(options.Build(), null, null, null, new Azure.Core.Pipeline.ClientDiagnostics(options), options.Version, options.CustomerProvidedKey, options.TransferValidation, options.EncryptionScope, options.TrimBlobNameSlashes);
			_clientSideEncryption = options._clientSideEncryptionOptions?.Clone();
			_containerRestClient = BuildContainerRestClient(blobContainerUri);
			BlobErrors.VerifyHttpsCustomerProvidedKey(_uri, _clientConfiguration.CustomerProvidedKey);
			BlobErrors.VerifyCpkAndEncryptionScopeNotBothSet(_clientConfiguration.CustomerProvidedKey, _clientConfiguration.EncryptionScope);
		}

		public BlobContainerClient(Uri blobContainerUri, StorageSharedKeyCredential credential, BlobClientOptions options = null)
		{
			Azure.Core.Argument.AssertNotNull(blobContainerUri, "blobContainerUri");
			HttpPipelinePolicy httpPipelinePolicy = credential.AsPolicy();
			_uri = blobContainerUri;
			_authenticationPolicy = httpPipelinePolicy;
			if (options == null)
			{
				options = new BlobClientOptions();
			}
			_clientConfiguration = new BlobClientConfiguration(options.Build(httpPipelinePolicy), credential, new Azure.Core.Pipeline.ClientDiagnostics(options), options.Version, options.CustomerProvidedKey, options.TransferValidation, options.EncryptionScope, options.TrimBlobNameSlashes);
			_clientSideEncryption = options._clientSideEncryptionOptions?.Clone();
			_containerRestClient = BuildContainerRestClient(blobContainerUri);
			BlobErrors.VerifyHttpsCustomerProvidedKey(_uri, _clientConfiguration.CustomerProvidedKey);
			BlobErrors.VerifyCpkAndEncryptionScopeNotBothSet(_clientConfiguration.CustomerProvidedKey, _clientConfiguration.EncryptionScope);
		}

		public BlobContainerClient(Uri blobContainerUri, AzureSasCredential credential, BlobClientOptions options = null)
		{
			Azure.Core.Argument.AssertNotNull(blobContainerUri, "blobContainerUri");
			_uri = blobContainerUri;
			_authenticationPolicy = credential.AsPolicy<BlobUriBuilder>(blobContainerUri);
			if (options == null)
			{
				options = new BlobClientOptions();
			}
			_clientConfiguration = new BlobClientConfiguration(options.Build(_authenticationPolicy), credential, new Azure.Core.Pipeline.ClientDiagnostics(options), options.Version, options.CustomerProvidedKey, options.TransferValidation, options.EncryptionScope, options.TrimBlobNameSlashes);
			_clientSideEncryption = options._clientSideEncryptionOptions?.Clone();
			_containerRestClient = BuildContainerRestClient(blobContainerUri);
			BlobErrors.VerifyHttpsCustomerProvidedKey(_uri, _clientConfiguration.CustomerProvidedKey);
			BlobErrors.VerifyCpkAndEncryptionScopeNotBothSet(_clientConfiguration.CustomerProvidedKey, _clientConfiguration.EncryptionScope);
		}

		public BlobContainerClient(Uri blobContainerUri, TokenCredential credential, BlobClientOptions options = null)
		{
			Azure.Storage.Errors.VerifyHttpsTokenAuth(blobContainerUri);
			Azure.Core.Argument.AssertNotNull(blobContainerUri, "blobContainerUri");
			_uri = blobContainerUri;
			_authenticationPolicy = credential.AsPolicy(string.IsNullOrEmpty(options?.Audience?.ToString()) ? BlobAudience.DefaultAudience.CreateDefaultScope() : options.Audience.Value.CreateDefaultScope(), options);
			if (options == null)
			{
				options = new BlobClientOptions();
			}
			_clientConfiguration = new BlobClientConfiguration(options.Build(_authenticationPolicy), credential, new Azure.Core.Pipeline.ClientDiagnostics(options), options.Version, options.CustomerProvidedKey, options.TransferValidation, options.EncryptionScope, options.TrimBlobNameSlashes);
			_clientSideEncryption = options._clientSideEncryptionOptions?.Clone();
			_containerRestClient = BuildContainerRestClient(blobContainerUri);
			BlobErrors.VerifyHttpsCustomerProvidedKey(_uri, _clientConfiguration.CustomerProvidedKey);
			BlobErrors.VerifyCpkAndEncryptionScopeNotBothSet(_clientConfiguration.CustomerProvidedKey, _clientConfiguration.EncryptionScope);
		}

		internal BlobContainerClient(Uri containerUri, BlobClientConfiguration clientConfiguration, ClientSideEncryptionOptions clientSideEncryption)
		{
			_uri = containerUri;
			_clientConfiguration = clientConfiguration;
			_authenticationPolicy = StorageClientOptions.GetAuthenticationPolicy(_clientConfiguration.SharedKeyCredential);
			_clientSideEncryption = clientSideEncryption?.Clone();
			_containerRestClient = BuildContainerRestClient(containerUri);
			BlobErrors.VerifyHttpsCustomerProvidedKey(_uri, _clientConfiguration.CustomerProvidedKey);
			BlobErrors.VerifyCpkAndEncryptionScopeNotBothSet(_clientConfiguration.CustomerProvidedKey, _clientConfiguration.EncryptionScope);
		}

		protected static BlobContainerClient CreateClient(Uri containerUri, BlobClientOptions options, HttpPipeline pipeline)
		{
			return new BlobContainerClient(containerUri, new BlobClientConfiguration(pipeline, (StorageSharedKeyCredential)null, new Azure.Core.Pipeline.ClientDiagnostics(options), options.Version, (CustomerProvidedKey?)null, options.TransferValidation, (string)null, options.TrimBlobNameSlashes), null);
		}

		private ContainerRestClient BuildContainerRestClient(Uri containerUri)
		{
			return new ContainerRestClient(_clientConfiguration.ClientDiagnostics, _clientConfiguration.Pipeline, containerUri.AbsoluteUri, _clientConfiguration.Version.ToVersionString());
		}

		protected internal virtual BlobBaseClient GetBlobBaseClientCore(string blobName)
		{
			return new BlobBaseClient(new BlobUriBuilder(Uri, ClientConfiguration.TrimBlobNameSlashes)
			{
				BlobName = blobName
			}.ToUri(), ClientConfiguration, ClientSideEncryption);
		}

		public virtual BlobClient GetBlobClient(string blobName)
		{
			return new BlobClient(new BlobUriBuilder(Uri, ClientConfiguration.TrimBlobNameSlashes)
			{
				BlobName = blobName
			}.ToUri(), ClientConfiguration, ClientSideEncryption);
		}

		protected internal virtual BlockBlobClient GetBlockBlobClientCore(string blobName)
		{
			if (ClientSideEncryption != null)
			{
				throw Azure.Storage.Errors.ClientSideEncryption.TypeNotSupported(typeof(BlockBlobClient));
			}
			return new BlockBlobClient(new BlobUriBuilder(Uri, ClientConfiguration.TrimBlobNameSlashes)
			{
				BlobName = blobName
			}.ToUri(), ClientConfiguration);
		}

		protected internal virtual AppendBlobClient GetAppendBlobClientCore(string blobName)
		{
			if (ClientSideEncryption != null)
			{
				throw Azure.Storage.Errors.ClientSideEncryption.TypeNotSupported(typeof(AppendBlobClient));
			}
			return new AppendBlobClient(new BlobUriBuilder(Uri, ClientConfiguration.TrimBlobNameSlashes)
			{
				BlobName = blobName
			}.ToUri(), ClientConfiguration);
		}

		protected internal virtual PageBlobClient GetPageBlobClientCore(string blobName)
		{
			if (ClientSideEncryption != null)
			{
				throw Azure.Storage.Errors.ClientSideEncryption.TypeNotSupported(typeof(PageBlobClient));
			}
			return new PageBlobClient(new BlobUriBuilder(Uri, ClientConfiguration.TrimBlobNameSlashes)
			{
				BlobName = blobName
			}.ToUri(), ClientConfiguration);
		}

		protected internal virtual BlobLeaseClient GetBlobLeaseClientCore(string leaseId)
		{
			return new BlobLeaseClient(this, leaseId);
		}

		private void SetNameFieldsIfNull()
		{
			if (_name == null || _accountName == null)
			{
				BlobUriBuilder blobUriBuilder = new BlobUriBuilder(Uri, ClientConfiguration.TrimBlobNameSlashes);
				_name = blobUriBuilder.BlobContainerName;
				_accountName = blobUriBuilder.AccountName;
			}
		}

		public virtual Response<BlobContainerInfo> Create(PublicAccessType publicAccessType = PublicAccessType.None, IDictionary<string, string> metadata = null, BlobContainerEncryptionScopeOptions encryptionScopeOptions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CreateInternal(publicAccessType, metadata, encryptionScopeOptions, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobContainerInfo> Create(PublicAccessType publicAccessType, IDictionary<string, string> metadata, CancellationToken cancellationToken)
		{
			return CreateInternal(publicAccessType, metadata, null, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContainerInfo>> CreateAsync(PublicAccessType publicAccessType = PublicAccessType.None, IDictionary<string, string> metadata = null, BlobContainerEncryptionScopeOptions encryptionScopeOptions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await CreateInternal(publicAccessType, metadata, encryptionScopeOptions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobContainerInfo>> CreateAsync(PublicAccessType publicAccessType, IDictionary<string, string> metadata, CancellationToken cancellationToken)
		{
			return await CreateInternal(publicAccessType, metadata, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<BlobContainerInfo> CreateIfNotExists(PublicAccessType publicAccessType = PublicAccessType.None, IDictionary<string, string> metadata = null, BlobContainerEncryptionScopeOptions encryptionScopeOptions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CreateIfNotExistsInternal(publicAccessType, metadata, encryptionScopeOptions, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobContainerInfo> CreateIfNotExists(PublicAccessType publicAccessType, IDictionary<string, string> metadata, CancellationToken cancellationToken)
		{
			return CreateIfNotExistsInternal(publicAccessType, metadata, null, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContainerInfo>> CreateIfNotExistsAsync(PublicAccessType publicAccessType = PublicAccessType.None, IDictionary<string, string> metadata = null, BlobContainerEncryptionScopeOptions encryptionScopeOptions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await CreateIfNotExistsInternal(publicAccessType, metadata, encryptionScopeOptions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobContainerInfo>> CreateIfNotExistsAsync(PublicAccessType publicAccessType, IDictionary<string, string> metadata, CancellationToken cancellationToken)
		{
			return await CreateIfNotExistsInternal(publicAccessType, metadata, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobContainerInfo>> CreateIfNotExistsInternal(PublicAccessType publicAccessType, IDictionary<string, string> metadata, BlobContainerEncryptionScopeOptions encryptionScopeOptions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobContainerClient", "CreateIfNotExistsInternal"))
			{
				string text = "BlobContainerClient.CreateIfNotExists";
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope(text);
				scope.Start();
				Response<BlobContainerInfo> result;
				try
				{
					result = await CreateInternal(publicAccessType, metadata, encryptionScopeOptions, async, cancellationToken, text).ConfigureAwait(continueOnCapturedContext: false);
				}
				catch (RequestFailedException ex) when (ex.ErrorCode == BlobErrorCode.ContainerAlreadyExists)
				{
					result = null;
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
				return result;
			}
		}

		private async Task<Response<BlobContainerInfo>> CreateInternal(PublicAccessType publicAccessType, IDictionary<string, string> metadata, BlobContainerEncryptionScopeOptions encryptionScopeOptions, bool async, CancellationToken cancellationToken, string operationName = null)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobContainerClient", "CreateInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobContainerClient.Create");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<ContainerCreateHeaders> responseWithHeaders;
					if (async)
					{
						ContainerRestClient containerRestClient = ContainerRestClient;
						IDictionary<string, string> metadata2 = metadata;
						PublicAccessType? access = ((publicAccessType == PublicAccessType.None) ? ((PublicAccessType?)null) : new PublicAccessType?(publicAccessType));
						string defaultEncryptionScope = encryptionScopeOptions?.DefaultEncryptionScope;
						bool? preventEncryptionScopeOverride = encryptionScopeOptions?.PreventEncryptionScopeOverride;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await containerRestClient.CreateAsync(null, metadata2, access, defaultEncryptionScope, preventEncryptionScopeOverride, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ContainerRestClient containerRestClient2 = ContainerRestClient;
						IDictionary<string, string> metadata2 = metadata;
						PublicAccessType? access = ((publicAccessType == PublicAccessType.None) ? ((PublicAccessType?)null) : new PublicAccessType?(publicAccessType));
						string defaultEncryptionScope = encryptionScopeOptions?.DefaultEncryptionScope;
						bool? preventEncryptionScopeOverride = encryptionScopeOptions?.PreventEncryptionScopeOverride;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = containerRestClient2.Create(null, metadata2, access, defaultEncryptionScope, preventEncryptionScopeOverride, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobContainerInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response Delete(BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return DeleteInternal(conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response> DeleteAsync(BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await DeleteInternal(conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<bool> DeleteIfExists(BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return DeleteIfExistsInternal(conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<bool>> DeleteIfExistsAsync(BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await DeleteIfExistsInternal(conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<bool>> DeleteIfExistsInternal(BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobContainerClient", "DeleteIfExistsInternal"))
			{
				string operationName = "BlobContainerClient.DeleteIfExists";
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobContainerClient.DeleteIfExists");
				scope.Start();
				try
				{
					return Response.FromValue(value: true, await DeleteInternal(conditions, async, cancellationToken, operationName).ConfigureAwait(continueOnCapturedContext: false));
				}
				catch (RequestFailedException ex) when (ex.ErrorCode == BlobErrorCode.ContainerNotFound || ex.ErrorCode == BlobErrorCode.BlobNotFound)
				{
					return Response.FromValue(value: false, null);
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		private async Task<Response> DeleteInternal(BlobRequestConditions conditions, bool async, CancellationToken cancellationToken, string operationName = null)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobContainerClient", "DeleteInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobContainerClient.Delete");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.TagConditions | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "Delete", "conditions");
				try
				{
					scope.Start();
					if ((conditions?.IfMatch.HasValue ?? false) || (conditions?.IfNoneMatch.HasValue ?? false))
					{
						throw BlobErrors.BlobConditionsMustBeDefault("IfMatch", "IfNoneMatch");
					}
					Azure.Core.ResponseWithHeaders<ContainerDeleteHeaders> responseWithHeaders;
					if (async)
					{
						ContainerRestClient containerRestClient = ContainerRestClient;
						string leaseId = conditions?.LeaseId;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await containerRestClient.DeleteAsync(null, leaseId, ifModifiedSince, ifUnmodifiedSince, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ContainerRestClient containerRestClient2 = ContainerRestClient;
						string leaseId = conditions?.LeaseId;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = containerRestClient2.Delete(null, leaseId, ifUnmodifiedSince, ifModifiedSince, cancellationToken2);
					}
					return responseWithHeaders.GetRawResponse();
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<bool> Exists(CancellationToken cancellationToken = default(CancellationToken))
		{
			return ExistsInternal(async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<bool>> ExistsAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return await ExistsInternal(async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<bool>> ExistsInternal(bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobContainerClient", "ExistsInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobContainerClient.Exists");
				scope.Start();
				try
				{
					return Response.FromValue(value: true, (await GetPropertiesInternal(null, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).GetRawResponse());
				}
				catch (RequestFailedException ex) when (ex.ErrorCode == BlobErrorCode.ContainerNotFound)
				{
					return Response.FromValue(value: false, null);
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobContainerProperties> GetProperties(BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetPropertiesInternal(conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContainerProperties>> GetPropertiesAsync(BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetPropertiesInternal(conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobContainerProperties>> GetPropertiesInternal(BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobContainerClient", "GetPropertiesInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobContainerClient.GetProperties");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.TagConditions | BlobRequestConditionProperty.IfModifiedSince | BlobRequestConditionProperty.IfUnmodifiedSince | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "GetProperties", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<ContainerGetPropertiesHeaders> responseWithHeaders;
					if (async)
					{
						ContainerRestClient containerRestClient = ContainerRestClient;
						string leaseId = conditions?.LeaseId;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await containerRestClient.GetPropertiesAsync(null, leaseId, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ContainerRestClient containerRestClient2 = ContainerRestClient;
						string leaseId = conditions?.LeaseId;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = containerRestClient2.GetProperties(null, leaseId, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobContainerProperties(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobContainerInfo> SetMetadata(IDictionary<string, string> metadata, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SetMetadataInternal(metadata, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContainerInfo>> SetMetadataAsync(IDictionary<string, string> metadata, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await SetMetadataInternal(metadata, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobContainerInfo>> SetMetadataInternal(IDictionary<string, string> metadata, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobContainerClient", "SetMetadataInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobContainerClient.SetMetadata");
				try
				{
					scope.Start();
					conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.TagConditions | BlobRequestConditionProperty.IfUnmodifiedSince | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "SetMetadata", "conditions");
					Azure.Core.ResponseWithHeaders<ContainerSetMetadataHeaders> responseWithHeaders;
					if (async)
					{
						ContainerRestClient containerRestClient = ContainerRestClient;
						string leaseId = conditions?.LeaseId;
						IDictionary<string, string> metadata2 = metadata;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await containerRestClient.SetMetadataAsync(null, leaseId, metadata2, ifModifiedSince, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ContainerRestClient containerRestClient2 = ContainerRestClient;
						string leaseId = conditions?.LeaseId;
						IDictionary<string, string> metadata2 = metadata;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = containerRestClient2.SetMetadata(null, leaseId, metadata2, ifModifiedSince, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobContainerInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobContainerAccessPolicy> GetAccessPolicy(BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetAccessPolicyInternal(conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContainerAccessPolicy>> GetAccessPolicyAsync(BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetAccessPolicyInternal(conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobContainerAccessPolicy>> GetAccessPolicyInternal(BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobContainerClient", "GetAccessPolicyInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobContainerClient.GetAccessPolicy");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.TagConditions | BlobRequestConditionProperty.IfModifiedSince | BlobRequestConditionProperty.IfUnmodifiedSince | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "GetAccessPolicy", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<IReadOnlyList<BlobSignedIdentifier>, ContainerGetAccessPolicyHeaders> responseWithHeaders;
					if (async)
					{
						ContainerRestClient containerRestClient = ContainerRestClient;
						string leaseId = conditions?.LeaseId;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await containerRestClient.GetAccessPolicyAsync(null, leaseId, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ContainerRestClient containerRestClient2 = ContainerRestClient;
						string leaseId = conditions?.LeaseId;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = containerRestClient2.GetAccessPolicy(null, leaseId, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobContainerAccessPolicy(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		[Azure.Core.CallerShouldAudit(Reason = "https://aka.ms/azsdk/callershouldaudit/storage-blobs")]
		public virtual Response<BlobContainerInfo> SetAccessPolicy(PublicAccessType accessType = PublicAccessType.None, IEnumerable<BlobSignedIdentifier> permissions = null, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SetAccessPolicyInternal(accessType, permissions, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		[Azure.Core.CallerShouldAudit(Reason = "https://aka.ms/azsdk/callershouldaudit/storage-blobs")]
		public virtual async Task<Response<BlobContainerInfo>> SetAccessPolicyAsync(PublicAccessType accessType = PublicAccessType.None, IEnumerable<BlobSignedIdentifier> permissions = null, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await SetAccessPolicyInternal(accessType, permissions, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobContainerInfo>> SetAccessPolicyInternal(PublicAccessType accessType, IEnumerable<BlobSignedIdentifier> permissions, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobContainerClient", "SetAccessPolicyInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobContainerClient.SetAccessPolicy");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.TagConditions | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "SetAccessPolicy", "conditions");
				try
				{
					scope.Start();
					if ((conditions?.IfMatch.HasValue ?? false) || (conditions?.IfNoneMatch.HasValue ?? false))
					{
						throw BlobErrors.BlobConditionsMustBeDefault("IfMatch", "IfNoneMatch");
					}
					List<BlobSignedIdentifier> list = null;
					if (permissions != null)
					{
						list = new List<BlobSignedIdentifier>();
						foreach (BlobSignedIdentifier permission in permissions)
						{
							permission.AccessPolicy.Permissions = Azure.Storage.Sas.SasExtensions.ValidateAndSanitizeRawPermissions(permission.AccessPolicy.Permissions, Azure.Storage.Constants.Sas.ValidPermissionsInOrder);
							list.Add(permission);
						}
					}
					Azure.Core.ResponseWithHeaders<ContainerSetAccessPolicyHeaders> responseWithHeaders;
					if (async)
					{
						ContainerRestClient containerRestClient = ContainerRestClient;
						string leaseId = conditions?.LeaseId;
						PublicAccessType? access = ((accessType == PublicAccessType.None) ? ((PublicAccessType?)null) : new PublicAccessType?(accessType));
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						IEnumerable<BlobSignedIdentifier> containerAcl = list;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await containerRestClient.SetAccessPolicyAsync(null, leaseId, access, ifModifiedSince, ifUnmodifiedSince, containerAcl, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ContainerRestClient containerRestClient2 = ContainerRestClient;
						string leaseId = conditions?.LeaseId;
						PublicAccessType? access = ((accessType == PublicAccessType.None) ? ((PublicAccessType?)null) : new PublicAccessType?(accessType));
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						IEnumerable<BlobSignedIdentifier> containerAcl = list;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = containerRestClient2.SetAccessPolicy(null, leaseId, access, ifUnmodifiedSince, ifModifiedSince, containerAcl, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobContainerInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Pageable<BlobItem> GetBlobs(BlobTraits traits = BlobTraits.None, BlobStates states = BlobStates.None, string prefix = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new GetBlobsAsyncCollection(this, traits, states, prefix).ToSyncCollection(cancellationToken);
		}

		public virtual AsyncPageable<BlobItem> GetBlobsAsync(BlobTraits traits = BlobTraits.None, BlobStates states = BlobStates.None, string prefix = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new GetBlobsAsyncCollection(this, traits, states, prefix).ToAsyncCollection(cancellationToken);
		}

		internal async Task<Response<ListBlobsFlatSegmentResponse>> GetBlobsInternal(string marker, BlobTraits traits, BlobStates states, string prefix, int? pageSizeHint, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobContainerClient", "GetBlobsInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobContainerClient.GetBlobs");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<ListBlobsFlatSegmentResponse, ContainerListBlobFlatSegmentHeaders> responseWithHeaders;
					if (async)
					{
						ContainerRestClient containerRestClient = ContainerRestClient;
						IEnumerable<ListBlobsIncludeItem> include = BlobExtensions.AsIncludeItems(traits, states);
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await containerRestClient.ListBlobFlatSegmentAsync(prefix, marker, pageSizeHint, include, null, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ContainerRestClient containerRestClient2 = ContainerRestClient;
						IEnumerable<ListBlobsIncludeItem> include2 = BlobExtensions.AsIncludeItems(traits, states);
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = containerRestClient2.ListBlobFlatSegment(prefix, marker, pageSizeHint, include2, null, cancellationToken2);
					}
					ListBlobsFlatSegmentResponse value = responseWithHeaders.Value;
					if ((traits & BlobTraits.Metadata) != BlobTraits.Metadata)
					{
						responseWithHeaders.Value.Segment.BlobItems.Select((BlobItemInternal r) => new BlobItemInternal(r.Name, r.Deleted, r.Snapshot, r.VersionId, r.IsCurrentVersion, r.Properties, null, r.BlobTags, r.HasVersionsOnly, r.OrMetadata)).ToList();
					}
					return Response.FromValue(value, responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Pageable<BlobHierarchyItem> GetBlobsByHierarchy(BlobTraits traits = BlobTraits.None, BlobStates states = BlobStates.None, string delimiter = null, string prefix = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new GetBlobsByHierarchyAsyncCollection(this, delimiter, traits, states, prefix).ToSyncCollection(cancellationToken);
		}

		public virtual AsyncPageable<BlobHierarchyItem> GetBlobsByHierarchyAsync(BlobTraits traits = BlobTraits.None, BlobStates states = BlobStates.None, string delimiter = null, string prefix = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new GetBlobsByHierarchyAsyncCollection(this, delimiter, traits, states, prefix).ToAsyncCollection(cancellationToken);
		}

		internal async Task<Response<ListBlobsHierarchySegmentResponse>> GetBlobsByHierarchyInternal(string marker, string delimiter, BlobTraits traits, BlobStates states, string prefix, int? pageSizeHint, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobContainerClient", "GetBlobsByHierarchyInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobContainerClient.GetBlobsByHierarchy");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<ListBlobsHierarchySegmentResponse, ContainerListBlobHierarchySegmentHeaders> responseWithHeaders;
					if (async)
					{
						ContainerRestClient containerRestClient = ContainerRestClient;
						string text = delimiter;
						string delimiter2 = text;
						IEnumerable<ListBlobsIncludeItem> include = BlobExtensions.AsIncludeItems(traits, states);
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await containerRestClient.ListBlobHierarchySegmentAsync(prefix, delimiter2, marker, pageSizeHint, include, null, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ContainerRestClient containerRestClient2 = ContainerRestClient;
						string text = delimiter;
						string delimiter3 = text;
						IEnumerable<ListBlobsIncludeItem> include2 = BlobExtensions.AsIncludeItems(traits, states);
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = containerRestClient2.ListBlobHierarchySegment(prefix, delimiter3, marker, pageSizeHint, include2, null, cancellationToken2);
					}
					ListBlobsHierarchySegmentResponse value = responseWithHeaders.Value;
					if ((traits & BlobTraits.Metadata) != BlobTraits.Metadata)
					{
						responseWithHeaders.Value.Segment.BlobItems.Select((BlobItemInternal r) => new BlobItemInternal(r.Name, r.Deleted, r.Snapshot, r.VersionId, r.IsCurrentVersion, r.Properties, null, r.BlobTags, r.HasVersionsOnly, r.OrMetadata)).ToList();
					}
					return Response.FromValue(value, responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		[ForwardsClientCalls]
		public virtual Response<BlobContentInfo> UploadBlob(string blobName, Stream content, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetBlobClient(blobName).Upload(content, cancellationToken);
		}

		[ForwardsClientCalls]
		public virtual async Task<Response<BlobContentInfo>> UploadBlobAsync(string blobName, Stream content, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetBlobClient(blobName).UploadAsync(content, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[ForwardsClientCalls]
		public virtual Response<BlobContentInfo> UploadBlob(string blobName, BinaryData content, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetBlobClient(blobName).Upload(content, cancellationToken);
		}

		[ForwardsClientCalls]
		public virtual async Task<Response<BlobContentInfo>> UploadBlobAsync(string blobName, BinaryData content, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetBlobClient(blobName).UploadAsync(content, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[ForwardsClientCalls]
		public virtual Response DeleteBlob(string blobName, DeleteSnapshotsOption snapshotsOption = DeleteSnapshotsOption.None, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetBlobClient(blobName).Delete(snapshotsOption, conditions, cancellationToken);
		}

		[ForwardsClientCalls]
		public virtual async Task<Response> DeleteBlobAsync(string blobName, DeleteSnapshotsOption snapshotsOption = DeleteSnapshotsOption.None, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetBlobClient(blobName).DeleteAsync(snapshotsOption, conditions, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[ForwardsClientCalls]
		public virtual Response<bool> DeleteBlobIfExists(string blobName, DeleteSnapshotsOption snapshotsOption = DeleteSnapshotsOption.None, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetBlobClient(blobName).DeleteIfExists(snapshotsOption, conditions ?? null, cancellationToken);
		}

		[ForwardsClientCalls]
		public virtual async Task<Response<bool>> DeleteBlobIfExistsAsync(string blobName, DeleteSnapshotsOption snapshotsOption = DeleteSnapshotsOption.None, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetBlobClient(blobName).DeleteIfExistsAsync(snapshotsOption, conditions ?? null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal virtual Response<BlobContainerClient> Rename(string destinationContainerName, BlobRequestConditions sourceConditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return RenameInternal(destinationContainerName, sourceConditions, async: false, cancellationToken).EnsureCompleted();
		}

		internal virtual async Task<Response<BlobContainerClient>> RenameAsync(string destinationContainerName, BlobRequestConditions sourceConditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await RenameInternal(destinationContainerName, sourceConditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal async Task<Response<BlobContainerClient>> RenameInternal(string destinationContainerName, BlobRequestConditions sourceConditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobContainerClient", "RenameInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobContainerClient.Rename");
				sourceConditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.TagConditions | BlobRequestConditionProperty.IfModifiedSince | BlobRequestConditionProperty.IfUnmodifiedSince | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "Rename", "sourceConditions");
				try
				{
					scope.Start();
					BlobUriBuilder blobUriBuilder = new BlobUriBuilder(Uri, ClientConfiguration.TrimBlobNameSlashes)
					{
						BlobContainerName = destinationContainerName
					};
					BlobContainerClient destContainerClient = new BlobContainerClient(blobUriBuilder.ToUri(), ClientConfiguration, ClientSideEncryption);
					Azure.Core.ResponseWithHeaders<ContainerRenameHeaders> responseWithHeaders;
					if (async)
					{
						ContainerRestClient containerRestClient = destContainerClient.ContainerRestClient;
						string name = Name;
						string sourceLeaseId = sourceConditions?.LeaseId;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await containerRestClient.RenameAsync(name, null, sourceLeaseId, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ContainerRestClient containerRestClient2 = destContainerClient.ContainerRestClient;
						string name2 = Name;
						string sourceLeaseId = sourceConditions?.LeaseId;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = containerRestClient2.Rename(name2, null, sourceLeaseId, cancellationToken2);
					}
					return Response.FromValue(destContainerClient, responseWithHeaders);
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Pageable<TaggedBlobItem> FindBlobsByTags(string tagFilterSqlExpression, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new FilterBlobsAsyncCollection(this, tagFilterSqlExpression).ToSyncCollection(cancellationToken);
		}

		public virtual AsyncPageable<TaggedBlobItem> FindBlobsByTagsAsync(string tagFilterSqlExpression, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new FilterBlobsAsyncCollection(this, tagFilterSqlExpression).ToAsyncCollection(cancellationToken);
		}

		internal async Task<Response<FilterBlobSegment>> FindBlobsByTagsInternal(string marker, string expression, int? pageSizeHint, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobServiceClient", "FindBlobsByTagsInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobContainerClient.FindBlobsByTags");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<FilterBlobSegment, ContainerFilterBlobsHeaders> responseWithHeaders;
					if (async)
					{
						ContainerRestClient containerRestClient = ContainerRestClient;
						string text = expression;
						string marker2 = marker;
						int? maxresults = pageSizeHint;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await containerRestClient.FilterBlobsAsync(null, text, marker2, maxresults, null, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ContainerRestClient containerRestClient2 = ContainerRestClient;
						string marker2 = expression;
						string text = marker;
						int? maxresults = pageSizeHint;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = containerRestClient2.FilterBlobs(null, marker2, text, maxresults, null, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.Value, responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		[Azure.Core.CallerShouldAudit(Reason = "https://aka.ms/azsdk/callershouldaudit/storage-blobs")]
		public virtual Uri GenerateSasUri(BlobContainerSasPermissions permissions, DateTimeOffset expiresOn)
		{
			return GenerateSasUri(new BlobSasBuilder(permissions, expiresOn)
			{
				BlobContainerName = Name
			});
		}

		[Azure.Core.CallerShouldAudit(Reason = "https://aka.ms/azsdk/callershouldaudit/storage-blobs")]
		public virtual Uri GenerateSasUri(BlobSasBuilder builder)
		{
			builder = builder ?? throw Azure.Storage.Errors.ArgumentNull("builder");
			builder = BlobSasBuilder.DeepCopy(builder);
			BlobSasBuilder blobSasBuilder = builder;
			if (blobSasBuilder.BlobContainerName == null)
			{
				string text = (blobSasBuilder.BlobContainerName = Name);
			}
			if (!builder.BlobContainerName.Equals(Name, StringComparison.InvariantCulture))
			{
				throw Azure.Storage.Errors.SasNamesNotMatching("BlobContainerName", "BlobSasBuilder", "Name");
			}
			if (!string.IsNullOrEmpty(builder.BlobName))
			{
				throw Azure.Storage.Errors.SasBuilderEmptyParam("builder", "BlobName", "Name");
			}
			return new BlobUriBuilder(Uri, ClientConfiguration.TrimBlobNameSlashes)
			{
				Sas = builder.ToSasQueryParameters(ClientConfiguration.SharedKeyCredential)
			}.ToUri();
		}

		protected internal virtual BlobServiceClient GetParentBlobServiceClientCore()
		{
			if (_parentBlobServiceClient == null)
			{
				BlobUriBuilder blobUriBuilder = new BlobUriBuilder(Uri, ClientConfiguration.TrimBlobNameSlashes)
				{
					BlobContainerName = null,
					BlobName = null,
					VersionId = null,
					Snapshot = null
				};
				_parentBlobServiceClient = new BlobServiceClient(blobUriBuilder.ToUri(), ClientConfiguration, AuthenticationPolicy, ClientSideEncryption);
			}
			return _parentBlobServiceClient;
		}
	}
	internal static class BlobExtensions
	{
		internal static IDictionary<string, string> ToTagDictionary(this BlobTags blobTags)
		{
			if (blobTags?.BlobTagSet == null)
			{
				return null;
			}
			Dictionary<string, string> dictionary = new Dictionary<string, string>();
			foreach (BlobTag item in blobTags.BlobTagSet)
			{
				dictionary[item.Key] = item.Value;
			}
			return dictionary;
		}

		internal static BlobTags ToBlobTags(this IDictionary<string, string> tags)
		{
			if (tags == null)
			{
				return null;
			}
			return new BlobTags(tags.Select((KeyValuePair<string, string> tag) => new BlobTag(tag.Key, tag.Value)));
		}

		internal static string ToTagsString(this IDictionary<string, string> tags)
		{
			if (tags == null)
			{
				return null;
			}
			List<string> list = new List<string>();
			foreach (KeyValuePair<string, string> tag in tags)
			{
				list.Add(WebUtility.UrlEncode(tag.Key) + "=" + WebUtility.UrlEncode(tag.Value));
			}
			return string.Join("&", list);
		}

		internal static TaggedBlobItem ToBlobTagItem(this FilterBlobItem filterBlobItem)
		{
			if (filterBlobItem == null)
			{
				return null;
			}
			return new TaggedBlobItem
			{
				BlobName = filterBlobItem.Name,
				BlobContainerName = filterBlobItem.ContainerName,
				Tags = filterBlobItem.Tags.ToTagDictionary()
			};
		}

		internal static List<TaggedBlobItem> ToBlobTagItems(this IEnumerable<FilterBlobItem> filterBlobItems)
		{
			if (filterBlobItems == null)
			{
				return null;
			}
			List<TaggedBlobItem> list = new List<TaggedBlobItem>();
			foreach (FilterBlobItem filterBlobItem in filterBlobItems)
			{
				list.Add(filterBlobItem.ToBlobTagItem());
			}
			return list;
		}

		internal static IList<ObjectReplicationPolicy> ParseObjectReplicationIds(this IDictionary<string, string> OrIds)
		{
			try
			{
				OrIds.Single((KeyValuePair<string, string> id) => id.Key == "policy-id");
				return null;
			}
			catch (Exception)
			{
			}
			List<ObjectReplicationPolicy> list = new List<ObjectReplicationPolicy>();
			foreach (KeyValuePair<string, string> OrId in OrIds)
			{
				string[] parsedIds = OrId.Key.Split(new char[1] { '_' });
				int num = list.FindIndex((ObjectReplicationPolicy policy) => policy.PolicyId == parsedIds[0]);
				if (num > -1)
				{
					list[num].Rules.Add(new ObjectReplicationRule
					{
						RuleId = parsedIds[1],
						ReplicationStatus = (ObjectReplicationStatus)Enum.Parse(typeof(ObjectReplicationStatus), OrId.Value, ignoreCase: true)
					});
					continue;
				}
				IList<ObjectReplicationRule> list2 = new List<ObjectReplicationRule>();
				list2.Add(new ObjectReplicationRule
				{
					RuleId = parsedIds[1],
					ReplicationStatus = (ObjectReplicationStatus)Enum.Parse(typeof(ObjectReplicationStatus), OrId.Value, ignoreCase: true)
				});
				list.Add(new ObjectReplicationPolicy
				{
					PolicyId = parsedIds[0],
					Rules = list2
				});
			}
			return list;
		}

		internal static IList<ObjectReplicationPolicy> ParseObjectReplicationMetadata(this IReadOnlyDictionary<string, string> OrMetadata)
		{
			List<ObjectReplicationPolicy> list = new List<ObjectReplicationPolicy>();
			foreach (KeyValuePair<string, string> OrMetadatum in OrMetadata)
			{
				string[] parsedIds = OrMetadatum.Key.Split(new char[1] { '_' });
				if (parsedIds[0].StartsWith("or-", StringComparison.InvariantCulture))
				{
					parsedIds[0] = parsedIds[0].Substring("or-".Length);
				}
				int num = list.FindIndex((ObjectReplicationPolicy policy) => policy.PolicyId == parsedIds[0]);
				if (num > -1)
				{
					list[num].Rules.Add(new ObjectReplicationRule
					{
						RuleId = parsedIds[1],
						ReplicationStatus = (ObjectReplicationStatus)Enum.Parse(typeof(ObjectReplicationStatus), OrMetadatum.Value, ignoreCase: true)
					});
					continue;
				}
				IList<ObjectReplicationRule> list2 = new List<ObjectReplicationRule>();
				list2.Add(new ObjectReplicationRule
				{
					RuleId = parsedIds[1],
					ReplicationStatus = (ObjectReplicationStatus)Enum.Parse(typeof(ObjectReplicationStatus), OrMetadatum.Value, ignoreCase: true)
				});
				list.Add(new ObjectReplicationPolicy
				{
					PolicyId = parsedIds[0],
					Rules = list2
				});
			}
			return list;
		}

		internal static RehydratePriority? ToRehydratePriority(this string rehydratePriority)
		{
			if (rehydratePriority == null)
			{
				return null;
			}
			if (rehydratePriority == RehydratePriority.High.ToString())
			{
				return RehydratePriority.High;
			}
			if (rehydratePriority == RehydratePriority.Standard.ToString())
			{
				return RehydratePriority.Standard;
			}
			throw new ArgumentException("Unknown Rehydrate Priority value: " + rehydratePriority);
		}

		internal static AccountInfo ToAccountInfo(this Azure.Core.ResponseWithHeaders<ServiceGetAccountInfoHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			return new AccountInfo
			{
				SkuName = response.Headers.SkuName.GetValueOrDefault(),
				AccountKind = response.Headers.AccountKind.GetValueOrDefault(),
				IsHierarchicalNamespaceEnabled = (response.Headers.IsHierarchicalNamespaceEnabled == true)
			};
		}

		internal static BlobContainerInfo ToBlobContainerInfo(this Azure.Core.ResponseWithHeaders<ContainerCreateHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobContainerInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault()
			};
		}

		internal static BlobContainerAccessPolicy ToBlobContainerAccessPolicy(this Azure.Core.ResponseWithHeaders<IReadOnlyList<BlobSignedIdentifier>, ContainerGetAccessPolicyHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobContainerAccessPolicy
			{
				BlobPublicAccess = response.Headers.BlobPublicAccess.GetValueOrDefault(),
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				SignedIdentifiers = response.Value.ToList()
			};
		}

		internal static BlobContainerInfo ToBlobContainerInfo(this Azure.Core.ResponseWithHeaders<ContainerSetAccessPolicyHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobContainerInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault()
			};
		}

		internal static BlobContainerInfo ToBlobContainerInfo(this Azure.Core.ResponseWithHeaders<ContainerSetMetadataHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobContainerInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault()
			};
		}

		internal static BlobContentInfo ToBlobContentInfo(this Azure.Core.ResponseWithHeaders<AppendBlobCreateHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobContentInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				ContentHash = response.Headers.ContentMD5,
				VersionId = response.Headers.VersionId,
				EncryptionKeySha256 = response.Headers.EncryptionKeySha256,
				EncryptionScope = response.Headers.EncryptionScope
			};
		}

		internal static BlobContentInfo ToBlobContentInfo(this Azure.Core.ResponseWithHeaders<PageBlobCreateHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobContentInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				ContentHash = response.Headers.ContentMD5,
				VersionId = response.Headers.VersionId,
				EncryptionKeySha256 = response.Headers.EncryptionKeySha256,
				EncryptionScope = response.Headers.EncryptionScope
			};
		}

		internal static BlobAppendInfo ToBlobAppendInfo(this Azure.Core.ResponseWithHeaders<AppendBlobAppendBlockHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobAppendInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				ContentHash = response.Headers.ContentMD5,
				ContentCrc64 = response.Headers.XMsContentCrc64,
				BlobAppendOffset = response.Headers.BlobAppendOffset,
				BlobCommittedBlockCount = response.Headers.BlobCommittedBlockCount.GetValueOrDefault(),
				IsServerEncrypted = (response.Headers.IsServerEncrypted == true),
				EncryptionKeySha256 = response.Headers.EncryptionKeySha256,
				EncryptionScope = response.Headers.EncryptionScope
			};
		}

		internal static BlobAppendInfo ToBlobAppendInfo(this Azure.Core.ResponseWithHeaders<AppendBlobAppendBlockFromUrlHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobAppendInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				ContentHash = response.Headers.ContentMD5,
				ContentCrc64 = response.Headers.XMsContentCrc64,
				BlobAppendOffset = response.Headers.BlobAppendOffset,
				BlobCommittedBlockCount = response.Headers.BlobCommittedBlockCount.GetValueOrDefault(),
				IsServerEncrypted = (response.Headers.IsServerEncrypted == true),
				EncryptionKeySha256 = response.Headers.EncryptionKeySha256,
				EncryptionScope = response.Headers.EncryptionScope
			};
		}

		internal static BlobInfo ToBlobInfo(this Azure.Core.ResponseWithHeaders<AppendBlobSealHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault()
			};
		}

		internal static PageInfo ToPageInfo(this Azure.Core.ResponseWithHeaders<PageBlobUploadPagesHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new PageInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				ContentHash = response.Headers.ContentMD5,
				ContentCrc64 = response.Headers.XMsContentCrc64,
				BlobSequenceNumber = response.Headers.BlobSequenceNumber.GetValueOrDefault(),
				EncryptionKeySha256 = response.Headers.EncryptionKeySha256,
				EncryptionScope = response.Headers.EncryptionScope
			};
		}

		internal static PageInfo ToPageInfo(this Azure.Core.ResponseWithHeaders<PageBlobClearPagesHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new PageInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				ContentHash = response.Headers.ContentMD5,
				ContentCrc64 = response.Headers.XMsContentCrc64,
				BlobSequenceNumber = response.Headers.BlobSequenceNumber.GetValueOrDefault()
			};
		}

		internal static PageInfo ToPageInfo(this Azure.Core.ResponseWithHeaders<PageBlobUploadPagesFromURLHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new PageInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				ContentHash = response.Headers.ContentMD5,
				ContentCrc64 = response.Headers.XMsContentCrc64,
				BlobSequenceNumber = response.Headers.BlobSequenceNumber.GetValueOrDefault(),
				EncryptionKeySha256 = response.Headers.EncryptionKeySha256,
				EncryptionScope = response.Headers.EncryptionScope
			};
		}

		internal static PageRangesInfo ToPageRangesInfo(this Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new PageRangesInfo
			{
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				BlobContentLength = response.Headers.BlobContentLength.GetValueOrDefault(),
				PageRanges = response.Value.PageRange.Select((PageRange r) => r.ToHttpRange()).ToList(),
				ClearRanges = response.Value.ClearRange.Select((ClearRange r) => r.ToHttpRange()).ToList()
			};
		}

		internal static PageRangesInfo ToPageRangesInfo(this Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesDiffHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new PageRangesInfo
			{
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				BlobContentLength = response.Headers.BlobContentLength.GetValueOrDefault(),
				PageRanges = response.Value.PageRange.Select((PageRange r) => r.ToHttpRange()).ToList(),
				ClearRanges = response.Value.ClearRange.Select((ClearRange r) => r.ToHttpRange()).ToList()
			};
		}

		internal static HttpRange ToHttpRange(this PageRange pageRange)
		{
			return new HttpRange(pageRange.Start, pageRange.End - pageRange.Start + 1);
		}

		internal static HttpRange ToHttpRange(this ClearRange clearRange)
		{
			return new HttpRange(clearRange.Start, clearRange.End - clearRange.Start + 1);
		}

		internal static PageBlobInfo ToPageBlobInfo(this Azure.Core.ResponseWithHeaders<PageBlobResizeHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new PageBlobInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				BlobSequenceNumber = response.Headers.BlobSequenceNumber.GetValueOrDefault()
			};
		}

		internal static PageBlobInfo ToPageBlobInfo(this Azure.Core.ResponseWithHeaders<PageBlobUpdateSequenceNumberHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new PageBlobInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				BlobSequenceNumber = response.Headers.BlobSequenceNumber.GetValueOrDefault()
			};
		}

		internal static BlockInfo ToBlockInfo(this Azure.Core.ResponseWithHeaders<BlockBlobStageBlockHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			return new BlockInfo
			{
				ContentHash = response.Headers.ContentMD5,
				ContentCrc64 = response.Headers.XMsContentCrc64,
				EncryptionKeySha256 = response.Headers.EncryptionKeySha256,
				EncryptionScope = response.Headers.EncryptionScope
			};
		}

		internal static BlockInfo ToBlockInfo(this Azure.Core.ResponseWithHeaders<BlockBlobStageBlockFromURLHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			return new BlockInfo
			{
				ContentHash = response.Headers.ContentMD5,
				ContentCrc64 = response.Headers.XMsContentCrc64,
				EncryptionKeySha256 = response.Headers.EncryptionKeySha256,
				EncryptionScope = response.Headers.EncryptionScope
			};
		}

		internal static BlobContentInfo ToBlobContentInfo(this Azure.Core.ResponseWithHeaders<BlockBlobCommitBlockListHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobContentInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				ContentHash = response.Headers.ContentMD5,
				VersionId = response.Headers.VersionId,
				EncryptionKeySha256 = response.Headers.EncryptionKeySha256,
				EncryptionScope = response.Headers.EncryptionScope
			};
		}

		internal static BlobContentInfo ToBlobContentInfo(this Azure.Core.ResponseWithHeaders<BlockBlobPutBlobFromUrlHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobContentInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				ContentHash = response.Headers.ContentMD5,
				VersionId = response.Headers.VersionId,
				EncryptionKeySha256 = response.Headers.EncryptionKeySha256,
				EncryptionScope = response.Headers.EncryptionScope
			};
		}

		internal static BlobContentInfo ToBlobContentInfo(this Azure.Core.ResponseWithHeaders<BlockBlobUploadHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobContentInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				ContentHash = response.Headers.ContentMD5,
				VersionId = response.Headers.VersionId,
				EncryptionKeySha256 = response.Headers.EncryptionKeySha256,
				EncryptionScope = response.Headers.EncryptionScope
			};
		}

		internal static BlockList ToBlockList(this Azure.Core.ResponseWithHeaders<BlockList, BlockBlobGetBlockListHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlockList
			{
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				ContentType = response.Headers.ContentType,
				BlobContentLength = response.Headers.BlobContentLength.GetValueOrDefault(),
				CommittedBlocks = response.Value.CommittedBlocks,
				UncommittedBlocks = response.Value.UncommittedBlocks
			};
		}

		internal static BlobSnapshotInfo ToBlobSnapshotInfo(this Azure.Core.ResponseWithHeaders<BlobCreateSnapshotHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobSnapshotInfo
			{
				Snapshot = response.Headers.Snapshot,
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				VersionId = response.Headers.VersionId,
				IsServerEncrypted = (response.Headers.IsServerEncrypted == true)
			};
		}

		internal static BlobInfo ToBlobInfo(this Azure.Core.ResponseWithHeaders<BlobSetMetadataHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				VersionId = response.Headers.VersionId
			};
		}

		internal static BlobInfo ToBlobInfo(this Azure.Core.ResponseWithHeaders<BlobSetHttpHeadersHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault()
			};
		}

		internal static BlobProperties ToBlobProperties(this Azure.Core.ResponseWithHeaders<BlobGetPropertiesHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			BlobImmutabilityPolicy blobImmutabilityPolicy = new BlobImmutabilityPolicy();
			blobImmutabilityPolicy.ExpiresOn = response.Headers.ImmutabilityPolicyExpiresOn;
			blobImmutabilityPolicy.PolicyMode = response.Headers.ImmutabilityPolicyMode;
			DateTimeOffset valueOrDefault = response.Headers.LastModified.GetValueOrDefault();
			DateTimeOffset valueOrDefault2 = response.Headers.CreationTime.GetValueOrDefault();
			IDictionary<string, string> metadata = response.Headers.Metadata;
			string objectReplicationPolicyId = response.Headers.ObjectReplicationPolicyId;
			IDictionary<string, string> objectReplicationRules = response.Headers.ObjectReplicationRules;
			string value;
			return new BlobProperties(valueOrDefault, valueOrDefault2, metadata, objectReplicationPolicyId, (objectReplicationRules != null && objectReplicationRules.Count > 0) ? response.Headers.ObjectReplicationRules.ParseObjectReplicationIds() : null, response.Headers.BlobType.GetValueOrDefault(), response.Headers.CopyCompletionTime.GetValueOrDefault(), response.Headers.CopyStatusDescription, response.Headers.CopyId, response.Headers.CopyProgress, (response.Headers.CopySource == null) ? null : new Uri(response.Headers.CopySource), response.Headers.CopyStatus, response.Headers.IsIncrementalCopy == true, response.Headers.DestinationSnapshot, response.Headers.LeaseDuration.GetValueOrDefault(), response.Headers.LeaseState.GetValueOrDefault(), response.Headers.LeaseStatus.GetValueOrDefault(), response.Headers.ContentLength.GetValueOrDefault(), response.Headers.ContentType, response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag), response.Headers.ContentMD5, response.Headers.ContentEncoding, response.Headers.ContentDisposition, response.Headers.ContentLanguage, response.Headers.CacheControl, response.Headers.BlobSequenceNumber.GetValueOrDefault(), response.Headers.AcceptRanges, response.Headers.BlobCommittedBlockCount.GetValueOrDefault(), response.Headers.IsServerEncrypted == true, response.Headers.EncryptionKeySha256, response.Headers.EncryptionScope, response.Headers.AccessTier, response.Headers.AccessTierInferred == true, response.Headers.ArchiveStatus, response.Headers.AccessTierChangeTime.GetValueOrDefault(), response.Headers.VersionId, response.Headers.IsCurrentVersion == true, response.Headers.TagCount.GetValueOrDefault(), response.Headers.ExpiresOn.GetValueOrDefault(), response.Headers.IsSealed == true, response.Headers.RehydratePriority, response.Headers.LastAccessed.GetValueOrDefault(), blobImmutabilityPolicy, response.Headers.LegalHold == true);
		}

		internal static BlobCopyInfo ToBlobCopyInfo(this Azure.Core.ResponseWithHeaders<BlobCopyFromURLHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobCopyInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				VersionId = response.Headers.VersionId,
				CopyId = response.Headers.CopyId,
				CopyStatus = response.Headers.CopyStatus.ToCopyStatus(),
				EncryptionScope = response.Headers.EncryptionScope
			};
		}

		internal static BlobCopyInfo ToBlobCopyInfo(this Azure.Core.ResponseWithHeaders<BlobStartCopyFromURLHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobCopyInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				VersionId = response.Headers.VersionId,
				CopyId = response.Headers.CopyId,
				CopyStatus = response.Headers.CopyStatus.GetValueOrDefault()
			};
		}

		internal static BlobCopyInfo ToBlobCopyInfo(this Azure.Core.ResponseWithHeaders<PageBlobCopyIncrementalHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobCopyInfo
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				CopyId = response.Headers.CopyId,
				CopyStatus = response.Headers.CopyStatus.GetValueOrDefault()
			};
		}

		internal static BlobDownloadStreamingResult ToBlobDownloadStreamingResult(this Azure.Core.ResponseWithHeaders<Stream, BlobDownloadHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			response.GetRawResponse().Headers.ExtractMultiHeaderDownloadProperties(out var metadata, out var objectReplicationRules);
			BlobImmutabilityPolicy blobImmutabilityPolicy = new BlobImmutabilityPolicy();
			blobImmutabilityPolicy.ExpiresOn = response.Headers.ImmutabilityPolicyExpiresOn;
			blobImmutabilityPolicy.PolicyMode = response.Headers.ImmutabilityPolicyMode;
			string value;
			return new BlobDownloadStreamingResult
			{
				Content = response.Value,
				Details = new BlobDownloadDetails
				{
					BlobType = response.Headers.BlobType.GetValueOrDefault(),
					ContentLength = response.Headers.ContentLength.GetValueOrDefault(),
					ContentType = response.Headers.ContentType,
					ContentHash = response.Headers.ContentMD5,
					LastModified = response.Headers.LastModified.GetValueOrDefault(),
					Metadata = metadata,
					ContentRange = response.Headers.ContentRange,
					ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
					ContentEncoding = response.Headers.ContentEncoding,
					CacheControl = response.Headers.CacheControl,
					ContentDisposition = response.Headers.ContentDisposition,
					ContentLanguage = response.Headers.ContentLanguage,
					BlobSequenceNumber = response.Headers.BlobSequenceNumber.GetValueOrDefault(),
					CopyCompletedOn = response.Headers.CopyCompletionTime.GetValueOrDefault(),
					CopyStatusDescription = response.Headers.CopyStatusDescription,
					CopyId = response.Headers.CopyId,
					CopyProgress = response.Headers.CopyProgress,
					CopySource = ((response.Headers.CopySource == null) ? null : new Uri(response.Headers.CopySource)),
					CopyStatus = response.Headers.CopyStatus.GetValueOrDefault(),
					LeaseDuration = response.Headers.LeaseDuration.GetValueOrDefault(),
					LeaseStatus = (response.Headers.LeaseStatus ?? LeaseStatus.Unlocked),
					LeaseState = response.Headers.LeaseState.GetValueOrDefault(),
					AcceptRanges = response.Headers.AcceptRanges,
					BlobCommittedBlockCount = response.Headers.BlobCommittedBlockCount.GetValueOrDefault(),
					IsServerEncrypted = (response.Headers.IsServerEncrypted == true),
					EncryptionKeySha256 = response.Headers.EncryptionKeySha256,
					EncryptionScope = response.Headers.EncryptionScope,
					BlobContentHash = response.Headers.BlobContentMD5,
					TagCount = response.Headers.TagCount.GetValueOrDefault(),
					VersionId = response.Headers.VersionId,
					IsSealed = (response.Headers.IsSealed == true),
					ObjectReplicationSourceProperties = ((objectReplicationRules != null && objectReplicationRules.Count > 0) ? objectReplicationRules.ParseObjectReplicationIds() : null),
					ObjectReplicationDestinationPolicyId = response.Headers.ObjectReplicationPolicyId,
					LastAccessed = response.Headers.LastAccessed.GetValueOrDefault(),
					ImmutabilityPolicy = blobImmutabilityPolicy,
					HasLegalHold = (response.Headers.LegalHold == true),
					CreatedOn = response.Headers.CreationTime.GetValueOrDefault()
				}
			};
		}

		internal static BlobDownloadInfo ToBlobDownloadInfo(Azure.Core.ResponseWithHeaders<Stream, BlobQueryHeaders> response, Stream stream)
		{
			if (response == null)
			{
				return null;
			}
			BlobType valueOrDefault = response.Headers.BlobType.GetValueOrDefault();
			long valueOrDefault2 = response.Headers.ContentLength.GetValueOrDefault();
			string contentType = response.Headers.ContentType;
			byte[] contentMD = response.Headers.ContentMD5;
			string value;
			return new BlobDownloadInfo
			{
				BlobType = valueOrDefault,
				ContentLength = valueOrDefault2,
				Content = stream,
				ContentType = contentType,
				ContentHash = contentMD,
				Details = new BlobDownloadDetails
				{
					BlobType = valueOrDefault,
					ContentLength = valueOrDefault2,
					ContentType = contentType,
					ContentHash = contentMD,
					LastModified = response.Headers.LastModified.GetValueOrDefault(),
					Metadata = response.Headers.Metadata.ToMetadata(),
					ContentRange = response.Headers.ContentRange,
					ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
					ContentEncoding = response.Headers.ContentEncoding,
					CacheControl = response.Headers.CacheControl,
					ContentDisposition = response.Headers.ContentDisposition,
					ContentLanguage = response.Headers.ContentLanguage,
					BlobSequenceNumber = response.Headers.BlobSequenceNumber.GetValueOrDefault(),
					CopyCompletedOn = response.Headers.CopyCompletionTime.GetValueOrDefault(),
					CopyStatusDescription = response.Headers.CopyStatusDescription,
					CopyId = response.Headers.CopyId,
					CopyProgress = response.Headers.CopyProgress,
					CopySource = ((response.Headers.CopySource == null) ? null : new Uri(response.Headers.CopySource)),
					CopyStatus = response.Headers.CopyStatus.GetValueOrDefault(),
					LeaseDuration = response.Headers.LeaseDuration.GetValueOrDefault(),
					LeaseState = response.Headers.LeaseState.GetValueOrDefault(),
					AcceptRanges = response.Headers.AcceptRanges,
					BlobCommittedBlockCount = response.Headers.BlobCommittedBlockCount.GetValueOrDefault(),
					IsServerEncrypted = (response.Headers.IsServerEncrypted == true),
					EncryptionKeySha256 = response.Headers.EncryptionKeySha256,
					EncryptionScope = response.Headers.EncryptionScope,
					BlobContentHash = response.Headers.BlobContentMD5
				}
			};
		}

		private static void ExtractMultiHeaderDownloadProperties(this ResponseHeaders headers, out IDictionary<string, string> metadata, out IDictionary<string, string> objectReplicationRules)
		{
			metadata = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
			objectReplicationRules = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
			foreach (HttpHeader item in headers)
			{
				if (item.Name.StartsWith("x-ms-meta-", StringComparison.OrdinalIgnoreCase))
				{
					metadata.Add(item.Name.Substring("x-ms-meta-".Length), item.Value);
				}
				else if (item.Name.StartsWith("x-ms-or-", StringComparison.OrdinalIgnoreCase))
				{
					objectReplicationRules.Add(item.Name.Substring("x-ms-or-".Length), item.Value);
				}
			}
		}

		internal static BlobLease ToBlobLease(this Azure.Core.ResponseWithHeaders<BlobAcquireLeaseHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobLease
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				LeaseId = response.Headers.LeaseId,
				LeaseTime = response.GetRawResponse().Headers.ExtractLeaseTime()
			};
		}

		internal static BlobLease ToBlobLease(this Azure.Core.ResponseWithHeaders<ContainerAcquireLeaseHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobLease
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				LeaseId = response.Headers.LeaseId,
				LeaseTime = response.GetRawResponse().Headers.ExtractLeaseTime()
			};
		}

		internal static BlobLease ToBlobLease(this Azure.Core.ResponseWithHeaders<BlobRenewLeaseHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobLease
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				LeaseId = response.Headers.LeaseId,
				LeaseTime = response.GetRawResponse().Headers.ExtractLeaseTime()
			};
		}

		internal static BlobLease ToBlobLease(this Azure.Core.ResponseWithHeaders<ContainerRenewLeaseHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobLease
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				LeaseId = response.Headers.LeaseId,
				LeaseTime = response.GetRawResponse().Headers.ExtractLeaseTime()
			};
		}

		internal static BlobLease ToBlobLease(this Azure.Core.ResponseWithHeaders<BlobChangeLeaseHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobLease
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				LeaseId = response.Headers.LeaseId,
				LeaseTime = response.GetRawResponse().Headers.ExtractLeaseTime()
			};
		}

		internal static BlobLease ToBlobLease(this Azure.Core.ResponseWithHeaders<ContainerChangeLeaseHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobLease
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				LeaseId = response.Headers.LeaseId,
				LeaseTime = response.GetRawResponse().Headers.ExtractLeaseTime()
			};
		}

		internal static BlobLease ToBlobLease(this Azure.Core.ResponseWithHeaders<BlobBreakLeaseHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobLease
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				LeaseTime = response.GetRawResponse().Headers.ExtractLeaseTime()
			};
		}

		internal static BlobLease ToBlobLease(this Azure.Core.ResponseWithHeaders<ContainerBreakLeaseHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobLease
			{
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				LeaseTime = response.GetRawResponse().Headers.ExtractLeaseTime()
			};
		}

		internal static int? ExtractLeaseTime(this ResponseHeaders responseHeaders)
		{
			int? result = null;
			if (responseHeaders.TryGetValue("x-ms-lease-time", out string value))
			{
				result = int.Parse(value, CultureInfo.InvariantCulture);
			}
			return result;
		}

		internal static ReleasedObjectInfo ToReleasedObjectInfo(this Azure.Core.ResponseWithHeaders<BlobReleaseLeaseHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new ReleasedObjectInfo(response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag), response.Headers.LastModified.GetValueOrDefault());
		}

		internal static ReleasedObjectInfo ToReleasedObjectInfo(this Azure.Core.ResponseWithHeaders<ContainerReleaseLeaseHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new ReleasedObjectInfo(response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag), response.Headers.LastModified.GetValueOrDefault());
		}

		internal static BlobItem[] ToBlobItems(this IReadOnlyList<BlobItemInternal> blobItemInternals)
		{
			return blobItemInternals?.Select((BlobItemInternal r) => r.ToBlobItem()).ToArray();
		}

		internal static BlobItem ToBlobItem(this BlobItemInternal blobItemInternal)
		{
			if (blobItemInternal == null)
			{
				return null;
			}
			BlobItem obj = new BlobItem
			{
				Name = blobItemInternal.Name.ToBlobNameString(),
				Deleted = blobItemInternal.Deleted,
				Snapshot = blobItemInternal.Snapshot,
				VersionId = blobItemInternal.VersionId,
				IsLatestVersion = blobItemInternal.IsCurrentVersion,
				Properties = blobItemInternal.Properties.ToBlobItemProperties()
			};
			IReadOnlyDictionary<string, string> metadata = blobItemInternal.Metadata;
			IDictionary<string, string> metadata2;
			if (metadata == null || metadata.Count <= 0)
			{
				IDictionary<string, string> dictionary = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
				metadata2 = dictionary;
			}
			else
			{
				metadata2 = blobItemInternal.Metadata.ToMetadata();
			}
			obj.Metadata = metadata2;
			obj.Tags = blobItemInternal.BlobTags.ToTagDictionary();
			IReadOnlyDictionary<string, string> orMetadata = blobItemInternal.OrMetadata;
			obj.ObjectReplicationSourceProperties = ((orMetadata != null && orMetadata.Count > 0) ? blobItemInternal.OrMetadata.ParseObjectReplicationMetadata() : null);
			obj.HasVersionsOnly = blobItemInternal.HasVersionsOnly;
			return obj;
		}

		internal static string ToBlobNameString(this BlobName blobName)
		{
			if (blobName.Encoded == true)
			{
				return Uri.UnescapeDataString(blobName.Content);
			}
			return blobName.Content;
		}

		internal static BlobItemProperties ToBlobItemProperties(this BlobPropertiesInternal blobPropertiesInternal)
		{
			if (blobPropertiesInternal == null)
			{
				return null;
			}
			BlobImmutabilityPolicy blobImmutabilityPolicy = new BlobImmutabilityPolicy();
			blobImmutabilityPolicy.ExpiresOn = blobPropertiesInternal.ImmutabilityPolicyExpiresOn;
			blobImmutabilityPolicy.PolicyMode = blobPropertiesInternal.ImmutabilityPolicyMode;
			return new BlobItemProperties
			{
				LastModified = blobPropertiesInternal.LastModified,
				ContentLength = blobPropertiesInternal.ContentLength,
				ContentType = blobPropertiesInternal.ContentType,
				ContentEncoding = blobPropertiesInternal.ContentEncoding,
				ContentLanguage = blobPropertiesInternal.ContentLanguage,
				ContentHash = blobPropertiesInternal.ContentMD5,
				ContentDisposition = blobPropertiesInternal.ContentDisposition,
				CacheControl = blobPropertiesInternal.CacheControl,
				BlobSequenceNumber = blobPropertiesInternal.BlobSequenceNumber,
				BlobType = blobPropertiesInternal.BlobType,
				LeaseStatus = blobPropertiesInternal.LeaseStatus,
				LeaseState = blobPropertiesInternal.LeaseState,
				LeaseDuration = blobPropertiesInternal.LeaseDuration,
				CopyId = blobPropertiesInternal.CopyId,
				CopyStatus = blobPropertiesInternal.CopyStatus,
				CopySource = ((blobPropertiesInternal.CopySource == null) ? null : new Uri(blobPropertiesInternal.CopySource)),
				CopyProgress = blobPropertiesInternal.CopyProgress,
				CopyStatusDescription = blobPropertiesInternal.CopyStatusDescription,
				ServerEncrypted = blobPropertiesInternal.ServerEncrypted,
				DestinationSnapshot = blobPropertiesInternal.DestinationSnapshot,
				RemainingRetentionDays = blobPropertiesInternal.RemainingRetentionDays,
				AccessTier = blobPropertiesInternal.AccessTier,
				AccessTierInferred = (blobPropertiesInternal.AccessTierInferred == true),
				ArchiveStatus = blobPropertiesInternal.ArchiveStatus,
				CustomerProvidedKeySha256 = blobPropertiesInternal.CustomerProvidedKeySha256,
				EncryptionScope = blobPropertiesInternal.EncryptionScope,
				TagCount = blobPropertiesInternal.TagCount,
				ExpiresOn = blobPropertiesInternal.ExpiresOn,
				IsSealed = blobPropertiesInternal.IsSealed,
				RehydratePriority = blobPropertiesInternal.RehydratePriority,
				LastAccessedOn = blobPropertiesInternal.LastAccessedOn,
				ETag = new ETag(blobPropertiesInternal.Etag),
				CreatedOn = blobPropertiesInternal.CreationTime,
				CopyCompletedOn = blobPropertiesInternal.CopyCompletionTime,
				DeletedOn = blobPropertiesInternal.DeletedTime,
				AccessTierChangedOn = blobPropertiesInternal.AccessTierChangeTime,
				ImmutabilityPolicy = blobImmutabilityPolicy,
				HasLegalHold = (blobPropertiesInternal.LegalHold == true)
			};
		}

		internal static BlobContainerItem[] ToBlobContainerItems(this IReadOnlyList<ContainerItemInternal> containerItemInternals)
		{
			return containerItemInternals?.Select((ContainerItemInternal r) => r.ToBlobContainerItem()).ToArray();
		}

		internal static BlobContainerItem ToBlobContainerItem(this ContainerItemInternal containerItemInternal)
		{
			if (containerItemInternal == null)
			{
				return null;
			}
			return new BlobContainerItem
			{
				Name = containerItemInternal.Name,
				IsDeleted = containerItemInternal.Deleted,
				VersionId = containerItemInternal.Version,
				Properties = ToBlobContainerProperties(containerItemInternal.Properties, containerItemInternal.Metadata)
			};
		}

		internal static BlobContainerProperties ToBlobContainerProperties(ContainerPropertiesInternal containerPropertiesInternal, IReadOnlyDictionary<string, string> metadata)
		{
			if (containerPropertiesInternal == null)
			{
				return null;
			}
			return new BlobContainerProperties
			{
				LastModified = containerPropertiesInternal.LastModified,
				LeaseStatus = containerPropertiesInternal.LeaseStatus,
				LeaseState = containerPropertiesInternal.LeaseState,
				LeaseDuration = containerPropertiesInternal.LeaseDuration,
				PublicAccess = containerPropertiesInternal.PublicAccess,
				HasImmutabilityPolicy = containerPropertiesInternal.HasImmutabilityPolicy,
				HasLegalHold = containerPropertiesInternal.HasLegalHold,
				DefaultEncryptionScope = containerPropertiesInternal.DefaultEncryptionScope,
				PreventEncryptionScopeOverride = containerPropertiesInternal.PreventEncryptionScopeOverride,
				DeletedOn = containerPropertiesInternal.DeletedTime,
				RemainingRetentionDays = containerPropertiesInternal.RemainingRetentionDays,
				ETag = new ETag(containerPropertiesInternal.Etag),
				Metadata = metadata.ToMetadata(),
				HasImmutableStorageWithVersioning = (containerPropertiesInternal.IsImmutableStorageWithVersioningEnabled == true)
			};
		}

		internal static BlobContainerProperties ToBlobContainerProperties(this Azure.Core.ResponseWithHeaders<ContainerGetPropertiesHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			string value;
			return new BlobContainerProperties
			{
				LastModified = response.Headers.LastModified.GetValueOrDefault(),
				LeaseStatus = response.Headers.LeaseStatus,
				LeaseState = response.Headers.LeaseState,
				LeaseDuration = response.Headers.LeaseDuration.GetValueOrDefault(),
				PublicAccess = response.Headers.BlobPublicAccess.GetValueOrDefault(),
				HasImmutabilityPolicy = response.Headers.HasImmutabilityPolicy,
				HasLegalHold = response.Headers.HasLegalHold,
				DefaultEncryptionScope = response.Headers.DefaultEncryptionScope,
				PreventEncryptionScopeOverride = response.Headers.DenyEncryptionScopeOverride,
				ETag = (response.GetRawResponse().Headers.TryGetValue("ETag", out value) ? new ETag(value) : default(ETag)),
				Metadata = response.Headers.Metadata.ToMetadata(),
				HasImmutableStorageWithVersioning = (response.Headers.IsImmutableStorageWithVersioningEnabled == true)
			};
		}

		internal static IDictionary<string, string> ToMetadata(this IDictionary<string, string> originalMetadata)
		{
			if (originalMetadata == null)
			{
				return null;
			}
			IDictionary<string, string> dictionary = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
			foreach (KeyValuePair<string, string> originalMetadatum in originalMetadata)
			{
				dictionary.Add(originalMetadatum.Key, originalMetadatum.Value);
			}
			return dictionary;
		}

		internal static IDictionary<string, string> ToMetadata(this IReadOnlyDictionary<string, string> originalMetadata)
		{
			if (originalMetadata == null)
			{
				return null;
			}
			IDictionary<string, string> dictionary = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
			foreach (KeyValuePair<string, string> originalMetadatum in originalMetadata)
			{
				dictionary.Add(originalMetadatum.Key, originalMetadatum.Value);
			}
			return dictionary;
		}

		internal static BlobImmutabilityPolicy ToBlobImmutabilityPolicy(this Azure.Core.ResponseWithHeaders<BlobSetImmutabilityPolicyHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			return new BlobImmutabilityPolicy
			{
				ExpiresOn = response.Headers.ImmutabilityPolicyExpiry,
				PolicyMode = response.Headers.ImmutabilityPolicyMode
			};
		}

		internal static BlobLegalHoldResult ToBlobLegalHoldInfo(this Azure.Core.ResponseWithHeaders<BlobSetLegalHoldHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			return new BlobLegalHoldResult
			{
				HasLegalHold = (response.Headers.LegalHold == true)
			};
		}

		internal static string ToEncryptionAlgorithmString(this EncryptionAlgorithmType type)
		{
			if (type == EncryptionAlgorithmType.Aes256)
			{
				return EncryptionAlgorithmTypeInternal.AES256.ToSerialString();
			}
			throw new InvalidEnumArgumentException();
		}

		internal static PageRangeItem[] ToPageBlobRanges(this Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			return ToPageBlobRanges(response.Value.PageRange, response.Value.ClearRange);
		}

		internal static PageRangeItem[] ToPageBlobRanges(this Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesDiffHeaders> response)
		{
			if (response == null)
			{
				return null;
			}
			return ToPageBlobRanges(response.Value.PageRange, response.Value.ClearRange);
		}

		internal static PageRangeItem[] ToPageBlobRanges(IReadOnlyList<PageRange> pageRanges, IReadOnlyList<ClearRange> clearRanges)
		{
			List<PageRangeItem> list = new List<PageRangeItem>();
			int num = 0;
			int num2 = 0;
			while (num < pageRanges.Count || num2 < clearRanges.Count)
			{
				if (num < pageRanges.Count && num2 < clearRanges.Count)
				{
					if (pageRanges[num].Start <= clearRanges[num2].Start)
					{
						list.Add(new PageRangeItem
						{
							IsClear = false,
							Range = pageRanges[num].ToHttpRange()
						});
						num++;
					}
					else
					{
						list.Add(new PageRangeItem
						{
							IsClear = true,
							Range = clearRanges[num2].ToHttpRange()
						});
						num2++;
					}
				}
				else if (num < pageRanges.Count)
				{
					list.Add(new PageRangeItem
					{
						IsClear = false,
						Range = pageRanges[num].ToHttpRange()
					});
					num++;
				}
				else
				{
					list.Add(new PageRangeItem
					{
						IsClear = true,
						Range = clearRanges[num2].ToHttpRange()
					});
					num2++;
				}
			}
			return list.ToArray();
		}

		internal static void ValidateConditionsNotPresent(this RequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName)
		{
			if (!CompatSwitches.DisableRequestConditionsValidation && requestConditions != null)
			{
				List<string> invalidList = null;
				requestConditions.ValidateConditionsNotPresent(invalidConditions, ref invalidList);
				if (invalidList != null && invalidList.Count > 0)
				{
					string text = string.Join(", ", invalidList);
					throw new ArgumentException(operationName + " does not support the " + text + " condition(s).", parameterName);
				}
			}
		}

		internal static void ValidateConditionsNotPresent(this BlobRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName)
		{
			if (!CompatSwitches.DisableRequestConditionsValidation && requestConditions != null)
			{
				List<string> invalidList = null;
				requestConditions.ValidateConditionsNotPresent(invalidConditions, ref invalidList);
				if (invalidList != null && invalidList.Count > 0)
				{
					string text = string.Join(", ", invalidList);
					throw new ArgumentException(operationName + " does not support the " + text + " condition(s).", parameterName);
				}
			}
		}

		internal static void ValidateConditionsNotPresent(this BlobLeaseRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName)
		{
			if (!CompatSwitches.DisableRequestConditionsValidation && requestConditions != null)
			{
				List<string> invalidList = null;
				requestConditions.ValidateConditionsNotPresent(invalidConditions, ref invalidList);
				if (invalidList != null && invalidList.Count > 0)
				{
					string text = string.Join(", ", invalidList);
					throw new ArgumentException(operationName + " does not support the " + text + " condition(s).", parameterName);
				}
			}
		}

		internal static void ValidateConditionsNotPresent(this AppendBlobRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName)
		{
			if (CompatSwitches.DisableRequestConditionsValidation || requestConditions == null)
			{
				return;
			}
			List<string> invalidList = null;
			requestConditions.ValidateConditionsNotPresent(invalidConditions, ref invalidList);
			if ((invalidConditions & BlobRequestConditionProperty.IfAppendPositionEqual) == BlobRequestConditionProperty.IfAppendPositionEqual && requestConditions.IfAppendPositionEqual.HasValue)
			{
				if (invalidList == null)
				{
					invalidList = new List<string>();
				}
				invalidList.Add("IfAppendPositionEqual");
			}
			if ((invalidConditions & BlobRequestConditionProperty.IfMaxSizeLessThanOrEqual) == BlobRequestConditionProperty.IfMaxSizeLessThanOrEqual && requestConditions.IfMaxSizeLessThanOrEqual.HasValue)
			{
				if (invalidList == null)
				{
					invalidList = new List<string>();
				}
				invalidList.Add("IfMaxSizeLessThanOrEqual");
			}
			if (invalidList == null || invalidList.Count <= 0)
			{
				return;
			}
			string text = string.Join(", ", invalidList);
			throw new ArgumentException(operationName + " does not support the " + text + " condition(s).", parameterName);
		}

		internal static void ValidateConditionsNotPresent(this PageBlobRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, string operationName, string parameterName)
		{
			if (CompatSwitches.DisableRequestConditionsValidation || requestConditions == null)
			{
				return;
			}
			List<string> invalidList = null;
			requestConditions.ValidateConditionsNotPresent(invalidConditions, ref invalidList);
			if ((invalidConditions & BlobRequestConditionProperty.IfSequenceNumberLessThan) == BlobRequestConditionProperty.IfSequenceNumberLessThan && requestConditions.IfSequenceNumberLessThan.HasValue)
			{
				if (invalidList == null)
				{
					invalidList = new List<string>();
				}
				invalidList.Add("IfSequenceNumberLessThan");
			}
			if ((invalidConditions & BlobRequestConditionProperty.IfSequenceNumberLessThanOrEqual) == BlobRequestConditionProperty.IfSequenceNumberLessThanOrEqual && requestConditions.IfSequenceNumberLessThanOrEqual.HasValue)
			{
				if (invalidList == null)
				{
					invalidList = new List<string>();
				}
				invalidList.Add("IfSequenceNumberLessThanOrEqual");
			}
			if ((invalidConditions & BlobRequestConditionProperty.IfSequenceNumberEqual) == BlobRequestConditionProperty.IfSequenceNumberEqual && requestConditions.IfSequenceNumberEqual.HasValue)
			{
				if (invalidList == null)
				{
					invalidList = new List<string>();
				}
				invalidList.Add("IfSequenceNumberEqual");
			}
			if (invalidList == null || invalidList.Count <= 0)
			{
				return;
			}
			string text = string.Join(", ", invalidList);
			throw new ArgumentException(operationName + " does not support the " + text + " condition(s).", parameterName);
		}

		internal static void ValidateConditionsNotPresent(this RequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, ref List<string> invalidList)
		{
			if (requestConditions == null)
			{
				return;
			}
			if ((invalidConditions & BlobRequestConditionProperty.IfModifiedSince) == BlobRequestConditionProperty.IfModifiedSince && requestConditions.IfModifiedSince.HasValue)
			{
				if (invalidList == null)
				{
					invalidList = new List<string>();
				}
				invalidList.Add("IfModifiedSince");
			}
			if ((invalidConditions & BlobRequestConditionProperty.IfUnmodifiedSince) == BlobRequestConditionProperty.IfUnmodifiedSince && requestConditions.IfUnmodifiedSince.HasValue)
			{
				if (invalidList == null)
				{
					invalidList = new List<string>();
				}
				invalidList.Add("IfUnmodifiedSince");
			}
			if ((invalidConditions & BlobRequestConditionProperty.IfMatch) == BlobRequestConditionProperty.IfMatch && requestConditions.IfMatch.HasValue)
			{
				if (invalidList == null)
				{
					invalidList = new List<string>();
				}
				invalidList.Add("IfMatch");
			}
			if ((invalidConditions & BlobRequestConditionProperty.IfNoneMatch) == BlobRequestConditionProperty.IfNoneMatch && requestConditions.IfNoneMatch.HasValue)
			{
				if (invalidList == null)
				{
					invalidList = new List<string>();
				}
				invalidList.Add("IfNoneMatch");
			}
		}

		internal static void ValidateConditionsNotPresent(this BlobLeaseRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, ref List<string> invalidList)
		{
			if (requestConditions != null && (invalidConditions & BlobRequestConditionProperty.TagConditions) == BlobRequestConditionProperty.TagConditions && requestConditions.TagConditions != null)
			{
				if (invalidList == null)
				{
					invalidList = new List<string>();
				}
				invalidList.Add("TagConditions");
			}
		}

		internal static void ValidateConditionsNotPresent(this BlobRequestConditions requestConditions, BlobRequestConditionProperty invalidConditions, ref List<string> invalidList)
		{
			if (requestConditions == null)
			{
				return;
			}
			((RequestConditions)requestConditions).ValidateConditionsNotPresent(invalidConditions, ref invalidList);
			((BlobLeaseRequestConditions)requestConditions).ValidateConditionsNotPresent(invalidConditions, ref invalidList);
			if ((invalidConditions & BlobRequestConditionProperty.LeaseId) == BlobRequestConditionProperty.LeaseId && requestConditions.LeaseId != null)
			{
				if (invalidList == null)
				{
					invalidList = new List<string>();
				}
				invalidList.Add("LeaseId");
			}
		}

		internal static BlockListType ToBlockListType(this BlockListTypes options)
		{
			return options switch
			{
				BlockListTypes.Committed => BlockListType.Committed, 
				BlockListTypes.Uncommitted => BlockListType.Uncommitted, 
				_ => BlockListType.All, 
			};
		}

		internal static IEnumerable<ListContainersIncludeType> AsIncludeItems(BlobContainerTraits traits, BlobContainerStates states)
		{
			List<ListContainersIncludeType> list = new List<ListContainersIncludeType>();
			if ((states & BlobContainerStates.Deleted) == BlobContainerStates.Deleted)
			{
				list.Add(ListContainersIncludeType.Deleted);
			}
			if ((traits & BlobContainerTraits.Metadata) == BlobContainerTraits.Metadata)
			{
				list.Add(ListContainersIncludeType.Metadata);
			}
			if ((states & BlobContainerStates.System) == BlobContainerStates.System)
			{
				list.Add(ListContainersIncludeType.System);
			}
			if (list.Count <= 0)
			{
				return null;
			}
			return list;
		}

		internal static IEnumerable<ListBlobsIncludeItem> AsIncludeItems(BlobTraits traits, BlobStates states)
		{
			List<ListBlobsIncludeItem> list = new List<ListBlobsIncludeItem>();
			if ((traits & BlobTraits.CopyStatus) == BlobTraits.CopyStatus)
			{
				list.Add(ListBlobsIncludeItem.Copy);
			}
			if ((states & BlobStates.Deleted) == BlobStates.Deleted)
			{
				list.Add(ListBlobsIncludeItem.Deleted);
			}
			if ((traits & BlobTraits.Metadata) == BlobTraits.Metadata)
			{
				list.Add(ListBlobsIncludeItem.Metadata);
			}
			if ((states & BlobStates.Snapshots) == BlobStates.Snapshots)
			{
				list.Add(ListBlobsIncludeItem.Snapshots);
			}
			if ((traits & BlobTraits.Tags) == BlobTraits.Tags)
			{
				list.Add(ListBlobsIncludeItem.Tags);
			}
			if ((traits & BlobTraits.ImmutabilityPolicy) == BlobTraits.ImmutabilityPolicy)
			{
				list.Add(ListBlobsIncludeItem.Immutabilitypolicy);
			}
			if ((traits & BlobTraits.LegalHold) == BlobTraits.LegalHold)
			{
				list.Add(ListBlobsIncludeItem.Legalhold);
			}
			if ((states & BlobStates.Uncommitted) == BlobStates.Uncommitted)
			{
				list.Add(ListBlobsIncludeItem.Uncommittedblobs);
			}
			if ((states & BlobStates.Version) == BlobStates.Version)
			{
				list.Add(ListBlobsIncludeItem.Versions);
			}
			if ((states & BlobStates.DeletedWithVersions) == BlobStates.DeletedWithVersions)
			{
				list.Add(ListBlobsIncludeItem.DeletedWithVersions);
			}
			if (list.Count <= 0)
			{
				return null;
			}
			return list;
		}

		internal static string ToPermissionsString(this BlobAccountSasPermissions permissions)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if ((permissions & BlobAccountSasPermissions.Read) == BlobAccountSasPermissions.Read)
			{
				stringBuilder.Append('r');
			}
			if ((permissions & BlobAccountSasPermissions.Add) == BlobAccountSasPermissions.Add)
			{
				stringBuilder.Append('a');
			}
			if ((permissions & BlobAccountSasPermissions.Create) == BlobAccountSasPermissions.Create)
			{
				stringBuilder.Append('c');
			}
			if ((permissions & BlobAccountSasPermissions.Write) == BlobAccountSasPermissions.Write)
			{
				stringBuilder.Append('w');
			}
			if ((permissions & BlobAccountSasPermissions.Delete) == BlobAccountSasPermissions.Delete)
			{
				stringBuilder.Append('d');
			}
			if ((permissions & BlobAccountSasPermissions.List) == BlobAccountSasPermissions.List)
			{
				stringBuilder.Append('l');
			}
			return stringBuilder.ToString();
		}

		internal static string ToPermissionsString(this BlobContainerSasPermissions permissions)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if ((permissions & BlobContainerSasPermissions.Read) == BlobContainerSasPermissions.Read)
			{
				stringBuilder.Append('r');
			}
			if ((permissions & BlobContainerSasPermissions.Add) == BlobContainerSasPermissions.Add)
			{
				stringBuilder.Append('a');
			}
			if ((permissions & BlobContainerSasPermissions.Create) == BlobContainerSasPermissions.Create)
			{
				stringBuilder.Append('c');
			}
			if ((permissions & BlobContainerSasPermissions.Write) == BlobContainerSasPermissions.Write)
			{
				stringBuilder.Append('w');
			}
			if ((permissions & BlobContainerSasPermissions.Delete) == BlobContainerSasPermissions.Delete)
			{
				stringBuilder.Append('d');
			}
			if ((permissions & BlobContainerSasPermissions.DeleteBlobVersion) == BlobContainerSasPermissions.DeleteBlobVersion)
			{
				stringBuilder.Append('x');
			}
			if ((permissions & BlobContainerSasPermissions.List) == BlobContainerSasPermissions.List)
			{
				stringBuilder.Append('l');
			}
			if ((permissions & BlobContainerSasPermissions.Tag) == BlobContainerSasPermissions.Tag)
			{
				stringBuilder.Append('t');
			}
			if ((permissions & BlobContainerSasPermissions.Filter) == BlobContainerSasPermissions.Filter)
			{
				stringBuilder.Append('f');
			}
			if ((permissions & BlobContainerSasPermissions.SetImmutabilityPolicy) == BlobContainerSasPermissions.SetImmutabilityPolicy)
			{
				stringBuilder.Append('i');
			}
			return stringBuilder.ToString();
		}

		internal static string ToPermissionsString(this BlobSasPermissions permissions)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if ((permissions & BlobSasPermissions.Read) == BlobSasPermissions.Read)
			{
				stringBuilder.Append('r');
			}
			if ((permissions & BlobSasPermissions.Add) == BlobSasPermissions.Add)
			{
				stringBuilder.Append('a');
			}
			if ((permissions & BlobSasPermissions.Create) == BlobSasPermissions.Create)
			{
				stringBuilder.Append('c');
			}
			if ((permissions & BlobSasPermissions.Write) == BlobSasPermissions.Write)
			{
				stringBuilder.Append('w');
			}
			if ((permissions & BlobSasPermissions.Delete) == BlobSasPermissions.Delete)
			{
				stringBuilder.Append('d');
			}
			if ((permissions & BlobSasPermissions.DeleteBlobVersion) == BlobSasPermissions.DeleteBlobVersion)
			{
				stringBuilder.Append('x');
			}
			if ((permissions & BlobSasPermissions.PermanentDelete) == BlobSasPermissions.PermanentDelete)
			{
				stringBuilder.Append('y');
			}
			if ((permissions & BlobSasPermissions.List) == BlobSasPermissions.List)
			{
				stringBuilder.Append('l');
			}
			if ((permissions & BlobSasPermissions.Tag) == BlobSasPermissions.Tag)
			{
				stringBuilder.Append('t');
			}
			if ((permissions & BlobSasPermissions.Move) == BlobSasPermissions.Move)
			{
				stringBuilder.Append('m');
			}
			if ((permissions & BlobSasPermissions.Execute) == BlobSasPermissions.Execute)
			{
				stringBuilder.Append('e');
			}
			if ((permissions & BlobSasPermissions.SetImmutabilityPolicy) == BlobSasPermissions.SetImmutabilityPolicy)
			{
				stringBuilder.Append('i');
			}
			return stringBuilder.ToString();
		}

		internal static string ToPermissionsString(this BlobVersionSasPermissions permissions)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if ((permissions & BlobVersionSasPermissions.Delete) == BlobVersionSasPermissions.Delete)
			{
				stringBuilder.Append('x');
			}
			if ((permissions & BlobVersionSasPermissions.PermanentDelete) == BlobVersionSasPermissions.PermanentDelete)
			{
				stringBuilder.Append('y');
			}
			if ((permissions & BlobVersionSasPermissions.SetImmutabilityPolicy) == BlobVersionSasPermissions.SetImmutabilityPolicy)
			{
				stringBuilder.Append('i');
			}
			return stringBuilder.ToString();
		}

		internal static string ToPermissionsString(this SnapshotSasPermissions permissions)
		{
			StringBuilder stringBuilder = new StringBuilder();
			if ((permissions & SnapshotSasPermissions.Read) == SnapshotSasPermissions.Read)
			{
				stringBuilder.Append('r');
			}
			if ((permissions & SnapshotSasPermissions.Write) == SnapshotSasPermissions.Write)
			{
				stringBuilder.Append('w');
			}
			if ((permissions & SnapshotSasPermissions.Delete) == SnapshotSasPermissions.Delete)
			{
				stringBuilder.Append('d');
			}
			if ((permissions & SnapshotSasPermissions.PermanentDelete) == SnapshotSasPermissions.PermanentDelete)
			{
				stringBuilder.Append('y');
			}
			if ((permissions & SnapshotSasPermissions.SetImmutabilityPolicy) == SnapshotSasPermissions.SetImmutabilityPolicy)
			{
				stringBuilder.Append('i');
			}
			return stringBuilder.ToString();
		}
	}
	internal class BlobQuickQueryStream : Stream
	{
		internal Stream _avroStream;

		internal AvroReader _avroReader;

		internal byte[] _buffer;

		internal int _bufferOffset;

		internal int _bufferLength;

		internal IProgress<long> _progressHandler;

		internal Action<BlobQueryError> _errorHandler;

		public override bool CanRead => true;

		public override bool CanSeek => false;

		public override bool CanWrite => false;

		public override long Length
		{
			get
			{
				throw new NotSupportedException();
			}
		}

		public override long Position
		{
			get
			{
				throw new NotSupportedException();
			}
			set
			{
				throw new NotSupportedException();
			}
		}

		public BlobQuickQueryStream(Stream avroStream, IProgress<long> progressHandler = null, Action<BlobQueryError> errorHandler = null)
		{
			_avroStream = avroStream;
			_avroReader = new AvroReader(_avroStream);
			_bufferOffset = 0;
			_bufferLength = 0;
			_progressHandler = progressHandler;
			_errorHandler = errorHandler;
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			return ReadInternal(async: false, buffer, offset, count).EnsureCompleted();
		}

		public new async Task<int> ReadAsync(byte[] buffer, int offset, int count)
		{
			return await ReadInternal(async: true, buffer, offset, count).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<int> ReadInternal(bool async, byte[] buffer, int offset, int count)
		{
			ValidateReadParameters(buffer, offset, count);
			int remainingBytes = _bufferLength - _bufferOffset;
			if (count <= remainingBytes)
			{
				Array.Copy(_buffer, _bufferOffset, buffer, offset, count);
				_bufferOffset += count;
				return count;
			}
			if (remainingBytes > 0)
			{
				Array.Copy(_buffer, _bufferOffset, buffer, offset, remainingBytes);
				_bufferOffset += remainingBytes;
				return remainingBytes;
			}
			_bufferOffset = 0;
			_bufferLength = 0;
			remainingBytes = 0;
			if (!_avroReader.HasNext())
			{
				return 0;
			}
			while (remainingBytes == 0)
			{
				Dictionary<string, object> dictionary = (Dictionary<string, object>)(await _avroReader.Next(async).ConfigureAwait(continueOnCapturedContext: false));
				switch (dictionary["$schema"] as string)
				{
				case "com.microsoft.azure.storage.queryBlobContents.resultData":
				{
					dictionary.TryGetValue("data", out var value3);
					if (value3 == null)
					{
						throw new InvalidOperationException("Avro data record is missing data property");
					}
					byte[] array = (byte[])value3;
					if (_buffer != null && _buffer.Length < array.Length)
					{
						ArrayPool<byte>.Shared.Return(_buffer, clearArray: true);
					}
					if (_buffer == null || _buffer.Length < array.Length)
					{
						_buffer = ArrayPool<byte>.Shared.Rent(Math.Max(4194304, array.Length));
					}
					Array.Copy(array, 0, _buffer, 0, array.Length);
					_bufferLength = array.Length;
					remainingBytes = array.Length;
					break;
				}
				case "com.microsoft.azure.storage.queryBlobContents.progress":
					if (_progressHandler != null)
					{
						dictionary.TryGetValue("bytesScanned", out var value2);
						if (value2 == null)
						{
							throw new InvalidOperationException("Avro progress record is mssing bytesScanned property");
						}
						_progressHandler.Report((long)value2);
					}
					break;
				case "com.microsoft.azure.storage.queryBlobContents.error":
					ProcessErrorRecord(dictionary);
					break;
				case "com.microsoft.azure.storage.queryBlobContents.end":
					if (_progressHandler != null)
					{
						dictionary.TryGetValue("totalBytes", out var value);
						if (value == null)
						{
							throw new InvalidOperationException("Avro end record is missing totalBytes property");
						}
						_progressHandler.Report((long)value);
					}
					return 0;
				}
			}
			int num = Math.Min(count, remainingBytes);
			Array.Copy(_buffer, _bufferOffset, buffer, offset, num);
			_bufferOffset += num;
			return num;
		}

		internal static void ValidateReadParameters(byte[] buffer, int offset, int count)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer", "Parameter cannot be null.");
			}
			if (offset < 0)
			{
				throw new ArgumentOutOfRangeException("offset", "Parameter cannot be negative.");
			}
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException("count", "Parameter cannot be negative.");
			}
			if (offset + count > buffer.Length)
			{
				throw new ArgumentException("The sum of offset and count cannot be greater than buffer length.");
			}
		}

		internal void ProcessErrorRecord(Dictionary<string, object> record)
		{
			record.TryGetValue("fatal", out var value);
			record.TryGetValue("name", out var value2);
			record.TryGetValue("description", out var value3);
			record.TryGetValue("position", out var value4);
			if (value == null)
			{
				throw new InvalidOperationException("Avro error record is missing fatal property");
			}
			if (value2 == null)
			{
				throw new InvalidOperationException("Avro error record is missing name property");
			}
			if (value3 == null)
			{
				throw new InvalidOperationException("Avro error record is missing description property");
			}
			if (value4 == null)
			{
				throw new InvalidOperationException("Avro error record is missing position property");
			}
			if (_errorHandler != null)
			{
				BlobQueryError obj = new BlobQueryError
				{
					IsFatal = (bool)value,
					Name = (string)value2,
					Description = (string)value3,
					Position = (long)value4
				};
				_errorHandler(obj);
			}
		}

		public override void Flush()
		{
			throw new NotSupportedException();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			throw new NotSupportedException();
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing: true);
			if (_buffer != null)
			{
				ArrayPool<byte>.Shared.Return(_buffer, clearArray: true);
				_buffer = null;
			}
			_avroStream.Dispose();
			if (_buffer != null)
			{
				ArrayPool<byte>.Shared.Return(_buffer, clearArray: true);
				_buffer = null;
			}
			_avroReader.Dispose();
		}
	}
	public class BlobServiceClient
	{
		private readonly Uri _uri;

		private readonly BlobClientConfiguration _clientConfiguration;

		private readonly HttpPipelinePolicy _authenticationPolicy;

		private readonly ClientSideEncryptionOptions _clientSideEncryption;

		private string _accountName;

		private readonly ServiceRestClient _serviceRestClient;

		public virtual Uri Uri => _uri;

		internal virtual BlobClientConfiguration ClientConfiguration => _clientConfiguration;

		internal virtual HttpPipelinePolicy AuthenticationPolicy => _authenticationPolicy;

		internal virtual ClientSideEncryptionOptions ClientSideEncryption => _clientSideEncryption;

		public string AccountName
		{
			get
			{
				if (_accountName == null)
				{
					_accountName = new BlobUriBuilder(Uri).AccountName;
				}
				return _accountName;
			}
		}

		public virtual bool CanGenerateAccountSasUri => ClientConfiguration.SharedKeyCredential != null;

		internal virtual ServiceRestClient ServiceRestClient => _serviceRestClient;

		protected BlobServiceClient()
		{
		}

		public BlobServiceClient(string connectionString)
			: this(connectionString, null)
		{
		}

		public BlobServiceClient(string connectionString, BlobClientOptions options)
		{
			Azure.Storage.StorageConnectionString storageConnectionString = Azure.Storage.StorageConnectionString.Parse(connectionString);
			_uri = storageConnectionString.BlobEndpoint;
			if (options == null)
			{
				options = new BlobClientOptions();
			}
			_authenticationPolicy = StorageClientOptions.GetAuthenticationPolicy(storageConnectionString.Credentials);
			_clientConfiguration = new BlobClientConfiguration(options.Build(_authenticationPolicy), storageConnectionString.Credentials as StorageSharedKeyCredential, new Azure.Core.Pipeline.ClientDiagnostics(options), options.Version, options.CustomerProvidedKey, options.TransferValidation, options.EncryptionScope, options.TrimBlobNameSlashes);
			_clientSideEncryption = options._clientSideEncryptionOptions?.Clone();
			_serviceRestClient = BuildServiceRestClient(_uri);
			BlobErrors.VerifyHttpsCustomerProvidedKey(_uri, _clientConfiguration.CustomerProvidedKey);
			BlobErrors.VerifyCpkAndEncryptionScopeNotBothSet(_clientConfiguration.CustomerProvidedKey, _clientConfiguration.EncryptionScope);
		}

		public BlobServiceClient(Uri serviceUri, BlobClientOptions options = null)
			: this(serviceUri, (HttpPipelinePolicy)null, options ?? new BlobClientOptions())
		{
		}

		public BlobServiceClient(Uri serviceUri, StorageSharedKeyCredential credential, BlobClientOptions options = null)
			: this(serviceUri, credential.AsPolicy(), credential, options ?? new BlobClientOptions())
		{
		}

		public BlobServiceClient(Uri serviceUri, AzureSasCredential credential, BlobClientOptions options = null)
			: this(serviceUri, credential.AsPolicy<BlobUriBuilder>(serviceUri), credential, options ?? new BlobClientOptions())
		{
		}

		public BlobServiceClient(Uri serviceUri, TokenCredential credential, BlobClientOptions options = null)
			: this(serviceUri, credential.AsPolicy(string.IsNullOrEmpty(options?.Audience?.ToString()) ? BlobAudience.DefaultAudience.CreateDefaultScope() : options.Audience.Value.CreateDefaultScope(), options), credential, options ?? new BlobClientOptions())
		{
			Azure.Storage.Errors.VerifyHttpsTokenAuth(serviceUri);
		}

		internal BlobServiceClient(Uri serviceUri, HttpPipelinePolicy authentication, BlobClientOptions options)
			: this(serviceUri, new BlobClientConfiguration(options.Build(authentication), (StorageSharedKeyCredential)null, new Azure.Core.Pipeline.ClientDiagnostics(options), options?.Version ?? BlobClientOptions.ServiceVersion.V2023_11_03, options?.CustomerProvidedKey, options.TransferValidation, options?.EncryptionScope, options?.TrimBlobNameSlashes ?? false), authentication, options?._clientSideEncryptionOptions?.Clone())
		{
		}

		internal BlobServiceClient(Uri serviceUri, HttpPipelinePolicy authentication, StorageSharedKeyCredential storageSharedKeyCredential, BlobClientOptions options)
			: this(serviceUri, new BlobClientConfiguration(options.Build(authentication), storageSharedKeyCredential, new Azure.Core.Pipeline.ClientDiagnostics(options), options?.Version ?? BlobClientOptions.ServiceVersion.V2023_11_03, options?.CustomerProvidedKey, options.TransferValidation, options?.EncryptionScope, options?.TrimBlobNameSlashes ?? false), authentication, options?._clientSideEncryptionOptions?.Clone())
		{
		}

		internal BlobServiceClient(Uri serviceUri, HttpPipelinePolicy authentication, TokenCredential tokenCredential, BlobClientOptions options)
			: this(serviceUri, new BlobClientConfiguration(options.Build(authentication), tokenCredential, new Azure.Core.Pipeline.ClientDiagnostics(options), options?.Version ?? BlobClientOptions.ServiceVersion.V2023_11_03, options?.CustomerProvidedKey, options.TransferValidation, options?.EncryptionScope, options?.TrimBlobNameSlashes ?? false), authentication, options?._clientSideEncryptionOptions?.Clone())
		{
		}

		internal BlobServiceClient(Uri serviceUri, HttpPipelinePolicy authentication, AzureSasCredential sasCredential, BlobClientOptions options)
			: this(serviceUri, new BlobClientConfiguration(options.Build(authentication), sasCredential, new Azure.Core.Pipeline.ClientDiagnostics(options), options?.Version ?? BlobClientOptions.ServiceVersion.V2023_11_03, options?.CustomerProvidedKey, options.TransferValidation, options?.EncryptionScope, options?.TrimBlobNameSlashes ?? false), authentication, options?._clientSideEncryptionOptions?.Clone())
		{
		}

		internal BlobServiceClient(Uri serviceUri, BlobClientConfiguration clientConfiguration, HttpPipelinePolicy authentication, ClientSideEncryptionOptions clientSideEncryption)
		{
			Azure.Core.Argument.AssertNotNull(serviceUri, "serviceUri");
			_uri = serviceUri;
			_clientConfiguration = clientConfiguration;
			_authenticationPolicy = authentication;
			_clientSideEncryption = clientSideEncryption?.Clone();
			_serviceRestClient = BuildServiceRestClient(serviceUri);
			BlobErrors.VerifyCpkAndEncryptionScopeNotBothSet(_clientConfiguration.CustomerProvidedKey, _clientConfiguration.EncryptionScope);
			BlobErrors.VerifyHttpsCustomerProvidedKey(_uri, _clientConfiguration.CustomerProvidedKey);
		}

		protected static BlobServiceClient CreateClient(Uri serviceUri, BlobClientOptions options, HttpPipelinePolicy authentication, HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential)
		{
			return new BlobServiceClient(serviceUri, new BlobClientConfiguration(pipeline, sharedKeyCredential, tokenCredential, sasCredential, new Azure.Core.Pipeline.ClientDiagnostics(options), options.Version, null, options.TransferValidation, null, options.TrimBlobNameSlashes), authentication, null);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		protected static BlobServiceClient CreateClient(Uri serviceUri, BlobClientOptions options, HttpPipelinePolicy authentication, HttpPipeline pipeline)
		{
			return new BlobServiceClient(serviceUri, new BlobClientConfiguration(pipeline, (StorageSharedKeyCredential)null, new Azure.Core.Pipeline.ClientDiagnostics(options), options.Version, (CustomerProvidedKey?)null, options.TransferValidation, (string)null, options.TrimBlobNameSlashes), authentication, null);
		}

		private ServiceRestClient BuildServiceRestClient(Uri uri)
		{
			return new ServiceRestClient(_clientConfiguration.ClientDiagnostics, _clientConfiguration.Pipeline, uri.AbsoluteUri, _clientConfiguration.Version.ToVersionString());
		}

		public virtual BlobContainerClient GetBlobContainerClient(string blobContainerName)
		{
			return new BlobContainerClient(Uri.AppendToPath(blobContainerName), ClientConfiguration, ClientSideEncryption);
		}

		protected static HttpPipeline GetHttpPipeline(BlobServiceClient client)
		{
			return client.ClientConfiguration.Pipeline;
		}

		protected static HttpPipelinePolicy GetAuthenticationPolicy(BlobServiceClient client)
		{
			return client.AuthenticationPolicy;
		}

		protected static BlobClientOptions GetClientOptions(BlobServiceClient client)
		{
			BlobClientOptions blobClientOptions = new BlobClientOptions(client.ClientConfiguration.Version);
			blobClientOptions.Diagnostics.IsDistributedTracingEnabled = client.ClientConfiguration.ClientDiagnostics.IsActivityEnabled;
			return blobClientOptions;
		}

		public virtual Pageable<BlobContainerItem> GetBlobContainers(BlobContainerTraits traits = BlobContainerTraits.None, BlobContainerStates states = BlobContainerStates.None, string prefix = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new GetBlobContainersAsyncCollection(this, traits, states, prefix).ToSyncCollection(cancellationToken);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Pageable<BlobContainerItem> GetBlobContainers(BlobContainerTraits traits, string prefix, CancellationToken cancellationToken)
		{
			return new GetBlobContainersAsyncCollection(this, traits, BlobContainerStates.None, prefix).ToSyncCollection(cancellationToken);
		}

		public virtual AsyncPageable<BlobContainerItem> GetBlobContainersAsync(BlobContainerTraits traits = BlobContainerTraits.None, BlobContainerStates states = BlobContainerStates.None, string prefix = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new GetBlobContainersAsyncCollection(this, traits, states, prefix).ToAsyncCollection(cancellationToken);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual AsyncPageable<BlobContainerItem> GetBlobContainersAsync(BlobContainerTraits traits, string prefix, CancellationToken cancellationToken)
		{
			return new GetBlobContainersAsyncCollection(this, traits, BlobContainerStates.None, prefix).ToAsyncCollection(cancellationToken);
		}

		internal async Task<Response<ListContainersSegmentResponse>> GetBlobContainersInternal(string continuationToken, BlobContainerTraits traits, BlobContainerStates states, string prefix, int? pageSizeHint, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobServiceClient", "GetBlobContainersInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobServiceClient.GetBlobContainers");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<ListContainersSegmentResponse, ServiceListContainersSegmentHeaders> responseWithHeaders;
					if (async)
					{
						ServiceRestClient serviceRestClient = ServiceRestClient;
						IEnumerable<ListContainersIncludeType> include = BlobExtensions.AsIncludeItems(traits, states);
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await serviceRestClient.ListContainersSegmentAsync(prefix, continuationToken, pageSizeHint, include, null, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ServiceRestClient serviceRestClient2 = ServiceRestClient;
						IEnumerable<ListContainersIncludeType> include2 = BlobExtensions.AsIncludeItems(traits, states);
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = serviceRestClient2.ListContainersSegment(prefix, continuationToken, pageSizeHint, include2, null, cancellationToken2);
					}
					ListContainersSegmentResponse value = responseWithHeaders.Value;
					if ((traits & BlobContainerTraits.Metadata) != BlobContainerTraits.Metadata)
					{
						List<ContainerItemInternal> list = responseWithHeaders.Value.ContainerItems.Select((ContainerItemInternal r) => new ContainerItemInternal(r.Name, r.Deleted, r.Version, r.Properties, null)).ToList();
						value = new ListContainersSegmentResponse(responseWithHeaders.Value.ServiceEndpoint, responseWithHeaders.Value.Prefix, responseWithHeaders.Value.Marker, responseWithHeaders.Value.MaxResults, list.AsReadOnly(), responseWithHeaders.Value.NextMarker);
					}
					return Response.FromValue(value, responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<AccountInfo> GetAccountInfo(CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetAccountInfoInternal(async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<AccountInfo>> GetAccountInfoAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetAccountInfoInternal(async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<AccountInfo>> GetAccountInfoInternal(bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobServiceClient", "GetAccountInfoInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobServiceClient.GetAccountInfo");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<ServiceGetAccountInfoHeaders> responseWithHeaders = ((!async) ? ServiceRestClient.GetAccountInfo(cancellationToken) : (await ServiceRestClient.GetAccountInfoAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
					return Response.FromValue(responseWithHeaders.ToAccountInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobServiceProperties> GetProperties(CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetPropertiesInternal(async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobServiceProperties>> GetPropertiesAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetPropertiesInternal(async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobServiceProperties>> GetPropertiesInternal(bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobServiceClient", "GetPropertiesInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobServiceClient.GetProperties");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobServiceProperties, ServiceGetPropertiesHeaders> responseWithHeaders;
					if (async)
					{
						ServiceRestClient serviceRestClient = ServiceRestClient;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await serviceRestClient.GetPropertiesAsync(null, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ServiceRestClient serviceRestClient2 = ServiceRestClient;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = serviceRestClient2.GetProperties(null, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.Value, responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		[Azure.Core.CallerShouldAudit(Reason = "https://aka.ms/azsdk/callershouldaudit/storage-blobs")]
		public virtual Response SetProperties(BlobServiceProperties properties, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SetPropertiesInternal(properties, async: false, cancellationToken).EnsureCompleted();
		}

		[Azure.Core.CallerShouldAudit(Reason = "https://aka.ms/azsdk/callershouldaudit/storage-blobs")]
		public virtual async Task<Response> SetPropertiesAsync(BlobServiceProperties properties, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await SetPropertiesInternal(properties, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response> SetPropertiesInternal(BlobServiceProperties properties, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobServiceClient", "SetPropertiesInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobServiceClient.SetProperties");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<ServiceSetPropertiesHeaders> responseWithHeaders;
					if (async)
					{
						ServiceRestClient serviceRestClient = ServiceRestClient;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await serviceRestClient.SetPropertiesAsync(properties, null, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ServiceRestClient serviceRestClient2 = ServiceRestClient;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = serviceRestClient2.SetProperties(properties, null, cancellationToken2);
					}
					return responseWithHeaders.GetRawResponse();
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobServiceStatistics> GetStatistics(CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetStatisticsInternal(async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobServiceStatistics>> GetStatisticsAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetStatisticsInternal(async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobServiceStatistics>> GetStatisticsInternal(bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobServiceClient", "GetStatisticsInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobServiceClient.GetStatistics");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobServiceStatistics, ServiceGetStatisticsHeaders> responseWithHeaders;
					if (async)
					{
						ServiceRestClient serviceRestClient = ServiceRestClient;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await serviceRestClient.GetStatisticsAsync(null, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ServiceRestClient serviceRestClient2 = ServiceRestClient;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = serviceRestClient2.GetStatistics(null, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.Value, responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		[Azure.Core.CallerShouldAudit(Reason = "https://aka.ms/azsdk/callershouldaudit/storage-blobs")]
		public virtual Response<UserDelegationKey> GetUserDelegationKey(DateTimeOffset? startsOn, DateTimeOffset expiresOn, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetUserDelegationKeyInternal(startsOn, expiresOn, async: false, cancellationToken).EnsureCompleted();
		}

		[Azure.Core.CallerShouldAudit(Reason = "https://aka.ms/azsdk/callershouldaudit/storage-blobs")]
		public virtual async Task<Response<UserDelegationKey>> GetUserDelegationKeyAsync(DateTimeOffset? startsOn, DateTimeOffset expiresOn, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetUserDelegationKeyInternal(startsOn, expiresOn, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<UserDelegationKey>> GetUserDelegationKeyInternal(DateTimeOffset? startsOn, DateTimeOffset expiresOn, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobServiceClient", "GetUserDelegationKeyInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobServiceClient.GetUserDelegationKey");
				try
				{
					scope.Start();
					if (startsOn.HasValue && startsOn.Value.Offset != TimeSpan.Zero)
					{
						throw BlobErrors.InvalidDateTimeUtc("startsOn");
					}
					if (expiresOn.Offset != TimeSpan.Zero)
					{
						throw BlobErrors.InvalidDateTimeUtc("expiresOn");
					}
					KeyInfo keyInfo = new KeyInfo(expiresOn.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ssZ", CultureInfo.InvariantCulture))
					{
						Start = startsOn?.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ssZ", CultureInfo.InvariantCulture)
					};
					Azure.Core.ResponseWithHeaders<UserDelegationKey, ServiceGetUserDelegationKeyHeaders> responseWithHeaders;
					if (async)
					{
						ServiceRestClient serviceRestClient = ServiceRestClient;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await serviceRestClient.GetUserDelegationKeyAsync(keyInfo, null, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ServiceRestClient serviceRestClient2 = ServiceRestClient;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = serviceRestClient2.GetUserDelegationKey(keyInfo, null, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.Value, responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		[ForwardsClientCalls]
		public virtual Response<BlobContainerClient> CreateBlobContainer(string blobContainerName, PublicAccessType publicAccessType = PublicAccessType.None, IDictionary<string, string> metadata = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			BlobContainerClient blobContainerClient = GetBlobContainerClient(blobContainerName);
			Response<BlobContainerInfo> response = blobContainerClient.Create(publicAccessType, metadata, cancellationToken);
			return Response.FromValue(blobContainerClient, response.GetRawResponse());
		}

		[ForwardsClientCalls]
		public virtual async Task<Response<BlobContainerClient>> CreateBlobContainerAsync(string blobContainerName, PublicAccessType publicAccessType = PublicAccessType.None, IDictionary<string, string> metadata = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			BlobContainerClient container = GetBlobContainerClient(blobContainerName);
			return Response.FromValue(container, (await container.CreateAsync(publicAccessType, metadata, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).GetRawResponse());
		}

		[ForwardsClientCalls]
		public virtual Response DeleteBlobContainer(string blobContainerName, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetBlobContainerClient(blobContainerName).Delete(conditions, cancellationToken);
		}

		[ForwardsClientCalls]
		public virtual async Task<Response> DeleteBlobContainerAsync(string blobContainerName, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetBlobContainerClient(blobContainerName).DeleteAsync(conditions, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<BlobContainerClient> UndeleteBlobContainer(string deletedContainerName, string deletedContainerVersion, CancellationToken cancellationToken = default(CancellationToken))
		{
			return UndeleteBlobContainerInternal(deletedContainerName, deletedContainerVersion, deletedContainerName, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContainerClient>> UndeleteBlobContainerAsync(string deletedContainerName, string deletedContainerVersion, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await UndeleteBlobContainerInternal(deletedContainerName, deletedContainerVersion, deletedContainerName, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobContainerClient> UndeleteBlobContainer(string deletedContainerName, string deletedContainerVersion, string destinationContainerName, CancellationToken cancellationToken = default(CancellationToken))
		{
			return UndeleteBlobContainerInternal(deletedContainerName, deletedContainerVersion, destinationContainerName, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobContainerClient>> UndeleteBlobContainerAsync(string deletedContainerName, string deletedContainerVersion, string destinationContainerName, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await UndeleteBlobContainerInternal(deletedContainerName, deletedContainerVersion, destinationContainerName, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal async Task<Response<BlobContainerClient>> UndeleteBlobContainerInternal(string deletedContainerName, string deletedContainerVersion, string destinationContainerName, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobContainerClient", "UndeleteBlobContainerInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobServiceClient.UndeleteBlobContainer");
				try
				{
					scope.Start();
					BlobContainerClient containerClient = ((destinationContainerName == null) ? GetBlobContainerClient(deletedContainerName) : GetBlobContainerClient(destinationContainerName));
					Azure.Core.ResponseWithHeaders<ContainerRestoreHeaders> responseWithHeaders;
					if (async)
					{
						ContainerRestClient containerRestClient = containerClient.ContainerRestClient;
						string deletedContainerName2 = deletedContainerName;
						string deletedContainerVersion2 = deletedContainerVersion;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await containerRestClient.RestoreAsync(null, deletedContainerName2, deletedContainerVersion2, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ContainerRestClient containerRestClient2 = containerClient.ContainerRestClient;
						string deletedContainerVersion2 = deletedContainerName;
						string deletedContainerName2 = deletedContainerVersion;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = containerRestClient2.Restore(null, deletedContainerVersion2, deletedContainerName2, cancellationToken2);
					}
					return Response.FromValue(containerClient, responseWithHeaders);
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		internal virtual Response<BlobContainerClient> RenameBlobContainer(string sourceContainerName, string destinationContainerName, BlobRequestConditions sourceConditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return RenameBlobContainerInternal(sourceContainerName, destinationContainerName, sourceConditions, async: false, cancellationToken).EnsureCompleted();
		}

		internal virtual async Task<Response<BlobContainerClient>> RenameBlobContainerAsync(string sourceContainerName, string destinationContainerName, BlobRequestConditions sourceConditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await RenameBlobContainerInternal(sourceContainerName, destinationContainerName, sourceConditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal async Task<Response<BlobContainerClient>> RenameBlobContainerInternal(string sourceContainerName, string destinationContainerName, BlobRequestConditions sourceConditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobContainerClient", "RenameBlobContainerInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobServiceClient.RenameBlobContainer");
				sourceConditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.TagConditions | BlobRequestConditionProperty.IfModifiedSince | BlobRequestConditionProperty.IfUnmodifiedSince | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "RenameBlobContainer", "sourceConditions");
				try
				{
					scope.Start();
					BlobContainerClient containerClient = GetBlobContainerClient(destinationContainerName);
					Azure.Core.ResponseWithHeaders<ContainerRenameHeaders> responseWithHeaders;
					if (async)
					{
						ContainerRestClient containerRestClient = containerClient.ContainerRestClient;
						string sourceLeaseId = sourceConditions?.LeaseId;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await containerRestClient.RenameAsync(sourceContainerName, null, sourceLeaseId, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ContainerRestClient containerRestClient2 = containerClient.ContainerRestClient;
						string sourceLeaseId = sourceConditions?.LeaseId;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = containerRestClient2.Rename(sourceContainerName, null, sourceLeaseId, cancellationToken2);
					}
					return Response.FromValue(containerClient, responseWithHeaders);
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Pageable<TaggedBlobItem> FindBlobsByTags(string tagFilterSqlExpression, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new FilterBlobsAsyncCollection(this, tagFilterSqlExpression).ToSyncCollection(cancellationToken);
		}

		public virtual AsyncPageable<TaggedBlobItem> FindBlobsByTagsAsync(string tagFilterSqlExpression, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new FilterBlobsAsyncCollection(this, tagFilterSqlExpression).ToAsyncCollection(cancellationToken);
		}

		internal async Task<Response<FilterBlobSegment>> FindBlobsByTagsInternal(string marker, string expression, int? pageSizeHint, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobServiceClient", "FindBlobsByTagsInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobServiceClient.FindBlobsByTags");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<FilterBlobSegment, ServiceFilterBlobsHeaders> responseWithHeaders;
					if (async)
					{
						ServiceRestClient serviceRestClient = ServiceRestClient;
						string text = expression;
						string marker2 = marker;
						int? maxresults = pageSizeHint;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await serviceRestClient.FilterBlobsAsync(null, text, marker2, maxresults, null, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ServiceRestClient serviceRestClient2 = ServiceRestClient;
						string marker2 = expression;
						string text = marker;
						int? maxresults = pageSizeHint;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = serviceRestClient2.FilterBlobs(null, marker2, text, maxresults, null, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.Value, responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		[Azure.Core.CallerShouldAudit(Reason = "https://aka.ms/azsdk/callershouldaudit/storage-blobs")]
		public Uri GenerateAccountSasUri(AccountSasPermissions permissions, DateTimeOffset expiresOn, AccountSasResourceTypes resourceTypes)
		{
			return GenerateAccountSasUri(new AccountSasBuilder(permissions, expiresOn, AccountSasServices.Blobs, resourceTypes));
		}

		[Azure.Core.CallerShouldAudit(Reason = "https://aka.ms/azsdk/callershouldaudit/storage-blobs")]
		public Uri GenerateAccountSasUri(AccountSasBuilder builder)
		{
			builder = builder ?? throw Azure.Storage.Errors.ArgumentNull("builder");
			if (!builder.Services.HasFlag(AccountSasServices.Blobs))
			{
				throw Azure.Storage.Errors.SasServiceNotMatching("Services", "builder", "Blobs");
			}
			return new UriBuilder(Uri)
			{
				Query = builder.ToSasQueryParameters(ClientConfiguration.SharedKeyCredential).ToString()
			}.Uri;
		}
	}
	public class BlobUriBuilder
	{
		private Uri _uri;

		private readonly bool _isPathStyleUri;

		private string _scheme;

		private string _host;

		private int _port;

		private string _accountName;

		private string _containerName;

		private string _blobName;

		private string _snapshot;

		private string _versionId;

		private BlobSasQueryParameters _sas;

		private string _query;

		public bool TrimBlobNameSlashes { get; }

		public string Scheme
		{
			get
			{
				return _scheme;
			}
			set
			{
				ResetUri();
				_scheme = value;
			}
		}

		public string Host
		{
			get
			{
				return _host;
			}
			set
			{
				ResetUri();
				_host = value;
			}
		}

		public int Port
		{
			get
			{
				return _port;
			}
			set
			{
				ResetUri();
				_port = value;
			}
		}

		public string AccountName
		{
			get
			{
				return _accountName;
			}
			set
			{
				ResetUri();
				_accountName = value;
			}
		}

		public string BlobContainerName
		{
			get
			{
				return _containerName;
			}
			set
			{
				ResetUri();
				_containerName = value;
			}
		}

		public string BlobName
		{
			get
			{
				return _blobName;
			}
			set
			{
				ResetUri();
				_blobName = value;
			}
		}

		public string Snapshot
		{
			get
			{
				return _snapshot;
			}
			set
			{
				ResetUri();
				_snapshot = value;
			}
		}

		public string VersionId
		{
			get
			{
				return _versionId;
			}
			set
			{
				ResetUri();
				_versionId = value;
			}
		}

		public BlobSasQueryParameters Sas
		{
			get
			{
				return _sas;
			}
			set
			{
				ResetUri();
				_sas = value;
			}
		}

		public string Query
		{
			get
			{
				return _query;
			}
			set
			{
				ResetUri();
				_query = value;
			}
		}

		public BlobUriBuilder(Uri uri)
			: this(uri, trimBlobNameSlashes: true)
		{
		}

		public BlobUriBuilder(Uri uri, bool trimBlobNameSlashes)
		{
			uri = uri ?? throw new ArgumentNullException("uri");
			TrimBlobNameSlashes = trimBlobNameSlashes;
			Scheme = uri.Scheme;
			Host = uri.Host;
			Port = uri.Port;
			AccountName = "";
			BlobContainerName = "";
			BlobName = "";
			Snapshot = "";
			VersionId = "";
			Sas = null;
			Query = "";
			if (!string.IsNullOrEmpty(uri.AbsolutePath))
			{
				string path = uri.GetPath();
				int num = 0;
				if (uri.IsHostIPEndPointStyle())
				{
					_isPathStyleUri = true;
					int num2 = path.IndexOf("/", StringComparison.InvariantCulture);
					if (num2 == -1)
					{
						AccountName = path;
						num = path.Length;
					}
					else
					{
						AccountName = path.Substring(0, num2);
						num = num2 + 1;
					}
				}
				else
				{
					AccountName = uri.GetAccountNameFromDomain("blob") ?? string.Empty;
				}
				int num3 = path.IndexOf("/", num, StringComparison.InvariantCulture);
				if (num3 == -1)
				{
					BlobContainerName = path.Substring(num);
				}
				else
				{
					BlobContainerName = path.Substring(num, num3 - num);
					BlobName = path.Substring(num3 + 1).UnescapePath(TrimBlobNameSlashes);
				}
			}
			Azure.Storage.UriQueryParamsCollection uriQueryParamsCollection = new Azure.Storage.UriQueryParamsCollection(uri.Query);
			if (uriQueryParamsCollection.TryGetValue("snapshot", out var value))
			{
				Snapshot = value;
				uriQueryParamsCollection.Remove("snapshot");
			}
			if (uriQueryParamsCollection.TryGetValue("versionid", out var value2))
			{
				VersionId = value2;
				uriQueryParamsCollection.Remove("versionid");
			}
			if (!string.IsNullOrEmpty(Snapshot) && !string.IsNullOrEmpty(VersionId))
			{
				throw new ArgumentException("Snapshot and VersionId cannot both be set.");
			}
			if (uriQueryParamsCollection.ContainsKey("sv"))
			{
				Sas = new BlobSasQueryParameters(uriQueryParamsCollection);
			}
			Query = uriQueryParamsCollection.ToString();
		}

		public Uri ToUri()
		{
			if (_uri == null)
			{
				_uri = BuildUri().ToUri();
			}
			return _uri;
		}

		public override string ToString()
		{
			return BuildUri().ToString();
		}

		private void ResetUri()
		{
			_uri = null;
		}

		private RequestUriBuilder BuildUri()
		{
			StringBuilder stringBuilder = new StringBuilder("");
			if (_isPathStyleUri && !string.IsNullOrWhiteSpace(AccountName))
			{
				stringBuilder.Append('/').Append(AccountName);
			}
			if (!string.IsNullOrWhiteSpace(BlobContainerName))
			{
				stringBuilder.Append('/').Append(BlobContainerName);
				if (BlobName != null && BlobName.Length > 0)
				{
					stringBuilder.Append('/').Append(BlobName.EscapePath(TrimBlobNameSlashes));
				}
			}
			StringBuilder stringBuilder2 = new StringBuilder(Query);
			if (!string.IsNullOrWhiteSpace(Snapshot))
			{
				if (stringBuilder2.Length > 0)
				{
					stringBuilder2.Append('&');
				}
				stringBuilder2.Append("snapshot").Append('=').Append(Snapshot);
			}
			if (!string.IsNullOrWhiteSpace(VersionId))
			{
				if (stringBuilder2.Length > 0)
				{
					stringBuilder2.Append('&');
				}
				stringBuilder2.Append("versionid").Append('=').Append(VersionId);
			}
			string value = Sas?.ToString();
			if (!string.IsNullOrWhiteSpace(value))
			{
				if (stringBuilder2.Length > 0)
				{
					stringBuilder2.Append('&');
				}
				stringBuilder2.Append(value);
			}
			return new RequestUriBuilder
			{
				Scheme = Scheme,
				Host = Host,
				Port = Port,
				Path = stringBuilder.ToString(),
				Query = ((stringBuilder2.Length > 0) ? ("?" + stringBuilder2.ToString()) : null)
			};
		}
	}
	internal class BlockBlobWriteStream : StorageWriteStream
	{
		private readonly BlockBlobClient _blockBlobClient;

		private readonly BlobRequestConditions _conditions;

		private readonly List<string> _blockIds;

		private readonly BlobHttpHeaders _blobHttpHeaders;

		private readonly IDictionary<string, string> _metadata;

		private readonly IDictionary<string, string> _tags;

		public BlockBlobWriteStream(BlockBlobClient blockBlobClient, long bufferSize, long position, BlobRequestConditions conditions, IProgress<long> progressHandler, BlobHttpHeaders blobHttpHeaders, IDictionary<string, string> metadata, IDictionary<string, string> tags, UploadTransferValidationOptions transferValidation)
			: base(position, bufferSize, progressHandler, transferValidation)
		{
			ValidateBufferSize(bufferSize);
			_blockBlobClient = blockBlobClient;
			_conditions = conditions ?? new BlobRequestConditions();
			_blockIds = new List<string>();
			_blobHttpHeaders = blobHttpHeaders;
			_metadata = metadata;
			_tags = tags;
		}

		protected override async Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken)
		{
			if (_buffer.Length > 0)
			{
				_buffer.Position = 0L;
				string blockId = Azure.Storage.Shared.StorageExtensions.GenerateBlockId(_position);
				BlobRequestConditions conditions = null;
				if (_conditions != null)
				{
					conditions = new BlobRequestConditions
					{
						LeaseId = _conditions.LeaseId
					};
				}
				await _blockBlobClient.StageBlockInternal(blockId, _buffer, validationOptions, conditions, _progressHandler, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				_blockIds.Add(blockId);
			}
		}

		protected override async Task CommitInternal(bool async, CancellationToken cancellationToken)
		{
			Response<BlobContentInfo> response = await _blockBlobClient.CommitBlockListInternal(_blockIds, _blobHttpHeaders, _metadata, _tags, _conditions, null, null, null, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			_conditions.IfMatch = response.Value.ETag;
		}

		protected override void ValidateBufferSize(long bufferSize)
		{
			if (bufferSize < 1)
			{
				throw new ArgumentOutOfRangeException("bufferSize", "Must be greater than 1");
			}
			if (bufferSize > 4194304000u)
			{
				throw new ArgumentOutOfRangeException("bufferSize", $"Must be less than or equal to {4194304000L}");
			}
		}
	}
	internal class AppendBlobAppendBlockFromUrlHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] XMsContentCrc64
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-content-crc64", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string BlobAppendOffset
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-append-offset", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public int? BlobCommittedBlockCount
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-committed-block-count", out int? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-request-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public AppendBlobAppendBlockFromUrlHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class AppendBlobAppendBlockHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] XMsContentCrc64
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-content-crc64", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string BlobAppendOffset
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-append-offset", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public int? BlobCommittedBlockCount
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-committed-block-count", out int? value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-request-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public AppendBlobAppendBlockHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class AppendBlobCreateHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string VersionId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-request-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public AppendBlobCreateHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class AppendBlobRestClient
	{
		private readonly HttpPipeline _pipeline;

		private readonly string _url;

		private readonly string _version;

		internal Azure.Core.Pipeline.ClientDiagnostics ClientDiagnostics { get; }

		public AppendBlobRestClient(Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version)
		{
			ClientDiagnostics = clientDiagnostics ?? throw new ArgumentNullException("clientDiagnostics");
			_pipeline = pipeline ?? throw new ArgumentNullException("pipeline");
			_url = url ?? throw new ArgumentNullException("url");
			_version = version ?? throw new ArgumentNullException("version");
		}

		internal HttpMessage CreateCreateRequest(long contentLength, int? timeout, string blobContentType, string blobContentEncoding, string blobContentLanguage, byte[] blobContentMD5, string blobCacheControl, IDictionary<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, DateTimeOffset? immutabilityPolicyExpiry, BlobImmutabilityPolicyMode? immutabilityPolicyMode, bool? legalHold)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-blob-type", "AppendBlob");
			if (blobContentType != null)
			{
				request.Headers.Add("x-ms-blob-content-type", blobContentType);
			}
			if (blobContentEncoding != null)
			{
				request.Headers.Add("x-ms-blob-content-encoding", blobContentEncoding);
			}
			if (blobContentLanguage != null)
			{
				request.Headers.Add("x-ms-blob-content-language", blobContentLanguage);
			}
			if (blobContentMD5 != null)
			{
				request.Headers.Add("x-ms-blob-content-md5", blobContentMD5, "D");
			}
			if (blobCacheControl != null)
			{
				request.Headers.Add("x-ms-blob-cache-control", blobCacheControl);
			}
			if (metadata != null)
			{
				request.Headers.Add("x-ms-meta-", metadata);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (blobContentDisposition != null)
			{
				request.Headers.Add("x-ms-blob-content-disposition", blobContentDisposition);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			if (blobTagsString != null)
			{
				request.Headers.Add("x-ms-tags", blobTagsString);
			}
			if (immutabilityPolicyExpiry.HasValue)
			{
				request.Headers.Add("x-ms-immutability-policy-until-date", immutabilityPolicyExpiry.Value, "R");
			}
			if (immutabilityPolicyMode.HasValue)
			{
				request.Headers.Add("x-ms-immutability-policy-mode", immutabilityPolicyMode.Value.ToSerialString());
			}
			if (legalHold.HasValue)
			{
				request.Headers.Add("x-ms-legal-hold", legalHold.Value);
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<AppendBlobCreateHeaders>> CreateAsync(long contentLength, int? timeout = null, string blobContentType = null, string blobContentEncoding = null, string blobContentLanguage = null, byte[] blobContentMD5 = null, string blobCacheControl = null, IDictionary<string, string> metadata = null, string leaseId = null, string blobContentDisposition = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string blobTagsString = null, DateTimeOffset? immutabilityPolicyExpiry = null, BlobImmutabilityPolicyMode? immutabilityPolicyMode = null, bool? legalHold = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateCreateRequest(contentLength, timeout, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD5, blobCacheControl, metadata, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			AppendBlobCreateHeaders headers = new AppendBlobCreateHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<AppendBlobCreateHeaders> Create(long contentLength, int? timeout = null, string blobContentType = null, string blobContentEncoding = null, string blobContentLanguage = null, byte[] blobContentMD5 = null, string blobCacheControl = null, IDictionary<string, string> metadata = null, string leaseId = null, string blobContentDisposition = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string blobTagsString = null, DateTimeOffset? immutabilityPolicyExpiry = null, BlobImmutabilityPolicyMode? immutabilityPolicyMode = null, bool? legalHold = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateCreateRequest(contentLength, timeout, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD5, blobCacheControl, metadata, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold);
			_pipeline.Send(httpMessage, cancellationToken);
			AppendBlobCreateHeaders headers = new AppendBlobCreateHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateAppendBlockRequest(long contentLength, Stream body, int? timeout, byte[] transactionalContentMD5, byte[] transactionalContentCrc64, string leaseId, long? maxSize, long? appendPosition, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "appendblock", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (transactionalContentCrc64 != null)
			{
				request.Headers.Add("x-ms-content-crc64", transactionalContentCrc64, "D");
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (maxSize.HasValue)
			{
				request.Headers.Add("x-ms-blob-condition-maxsize", maxSize.Value);
			}
			if (appendPosition.HasValue)
			{
				request.Headers.Add("x-ms-blob-condition-appendpos", appendPosition.Value);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			request.Headers.Add("Content-Length", contentLength);
			if (transactionalContentMD5 != null)
			{
				request.Headers.Add("Content-MD5", transactionalContentMD5, "D");
			}
			request.Headers.Add("Content-Type", "application/octet-stream");
			request.Content = RequestContent.Create(body);
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<AppendBlobAppendBlockHeaders>> AppendBlockAsync(long contentLength, Stream body, int? timeout = null, byte[] transactionalContentMD5 = null, byte[] transactionalContentCrc64 = null, string leaseId = null, long? maxSize = null, long? appendPosition = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			using HttpMessage message = CreateAppendBlockRequest(contentLength, body, timeout, transactionalContentMD5, transactionalContentCrc64, leaseId, maxSize, appendPosition, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			AppendBlobAppendBlockHeaders headers = new AppendBlobAppendBlockHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<AppendBlobAppendBlockHeaders> AppendBlock(long contentLength, Stream body, int? timeout = null, byte[] transactionalContentMD5 = null, byte[] transactionalContentCrc64 = null, string leaseId = null, long? maxSize = null, long? appendPosition = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			using HttpMessage httpMessage = CreateAppendBlockRequest(contentLength, body, timeout, transactionalContentMD5, transactionalContentCrc64, leaseId, maxSize, appendPosition, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			AppendBlobAppendBlockHeaders headers = new AppendBlobAppendBlockHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateAppendBlockFromUrlRequest(string sourceUrl, long contentLength, string sourceRange, byte[] sourceContentMD5, byte[] sourceContentcrc64, int? timeout, byte[] transactionalContentMD5, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope, string leaseId, long? maxSize, long? appendPosition, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, DateTimeOffset? sourceIfModifiedSince, DateTimeOffset? sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "appendblock", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-copy-source", sourceUrl);
			if (sourceRange != null)
			{
				request.Headers.Add("x-ms-source-range", sourceRange);
			}
			if (sourceContentMD5 != null)
			{
				request.Headers.Add("x-ms-source-content-md5", sourceContentMD5, "D");
			}
			if (sourceContentcrc64 != null)
			{
				request.Headers.Add("x-ms-source-content-crc64", sourceContentcrc64, "D");
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (maxSize.HasValue)
			{
				request.Headers.Add("x-ms-blob-condition-maxsize", maxSize.Value);
			}
			if (appendPosition.HasValue)
			{
				request.Headers.Add("x-ms-blob-condition-appendpos", appendPosition.Value);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			if (sourceIfModifiedSince.HasValue)
			{
				request.Headers.Add("x-ms-source-if-modified-since", sourceIfModifiedSince.Value, "R");
			}
			if (sourceIfUnmodifiedSince.HasValue)
			{
				request.Headers.Add("x-ms-source-if-unmodified-since", sourceIfUnmodifiedSince.Value, "R");
			}
			if (sourceIfMatch != null)
			{
				request.Headers.Add("x-ms-source-if-match", sourceIfMatch);
			}
			if (sourceIfNoneMatch != null)
			{
				request.Headers.Add("x-ms-source-if-none-match", sourceIfNoneMatch);
			}
			request.Headers.Add("x-ms-version", _version);
			if (copySourceAuthorization != null)
			{
				request.Headers.Add("x-ms-copy-source-authorization", copySourceAuthorization);
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<AppendBlobAppendBlockFromUrlHeaders>> AppendBlockFromUrlAsync(string sourceUrl, long contentLength, string sourceRange = null, byte[] sourceContentMD5 = null, byte[] sourceContentcrc64 = null, int? timeout = null, byte[] transactionalContentMD5 = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, string leaseId = null, long? maxSize = null, long? appendPosition = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, DateTimeOffset? sourceIfModifiedSince = null, DateTimeOffset? sourceIfUnmodifiedSince = null, string sourceIfMatch = null, string sourceIfNoneMatch = null, string copySourceAuthorization = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (sourceUrl == null)
			{
				throw new ArgumentNullException("sourceUrl");
			}
			using HttpMessage message = CreateAppendBlockFromUrlRequest(sourceUrl, contentLength, sourceRange, sourceContentMD5, sourceContentcrc64, timeout, transactionalContentMD5, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, leaseId, maxSize, appendPosition, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, copySourceAuthorization);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			AppendBlobAppendBlockFromUrlHeaders headers = new AppendBlobAppendBlockFromUrlHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<AppendBlobAppendBlockFromUrlHeaders> AppendBlockFromUrl(string sourceUrl, long contentLength, string sourceRange = null, byte[] sourceContentMD5 = null, byte[] sourceContentcrc64 = null, int? timeout = null, byte[] transactionalContentMD5 = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, string leaseId = null, long? maxSize = null, long? appendPosition = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, DateTimeOffset? sourceIfModifiedSince = null, DateTimeOffset? sourceIfUnmodifiedSince = null, string sourceIfMatch = null, string sourceIfNoneMatch = null, string copySourceAuthorization = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (sourceUrl == null)
			{
				throw new ArgumentNullException("sourceUrl");
			}
			using HttpMessage httpMessage = CreateAppendBlockFromUrlRequest(sourceUrl, contentLength, sourceRange, sourceContentMD5, sourceContentcrc64, timeout, transactionalContentMD5, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, leaseId, maxSize, appendPosition, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, copySourceAuthorization);
			_pipeline.Send(httpMessage, cancellationToken);
			AppendBlobAppendBlockFromUrlHeaders headers = new AppendBlobAppendBlockFromUrlHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateSealRequest(int? timeout, string leaseId, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, long? appendPosition)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "seal", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (appendPosition.HasValue)
			{
				request.Headers.Add("x-ms-blob-condition-appendpos", appendPosition.Value);
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<AppendBlobSealHeaders>> SealAsync(int? timeout = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, long? appendPosition = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateSealRequest(timeout, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, appendPosition);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			AppendBlobSealHeaders headers = new AppendBlobSealHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<AppendBlobSealHeaders> Seal(int? timeout = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, long? appendPosition = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateSealRequest(timeout, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, appendPosition);
			_pipeline.Send(httpMessage, cancellationToken);
			AppendBlobSealHeaders headers = new AppendBlobSealHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}
	}
	internal class AppendBlobSealHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsSealed
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-sealed", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public AppendBlobSealHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobAbortCopyFromURLHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobAbortCopyFromURLHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobAcquireLeaseHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string LeaseId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobAcquireLeaseHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobBreakLeaseHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public int? LeaseTime
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-time", out int? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobBreakLeaseHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobChangeLeaseHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string LeaseId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobChangeLeaseHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobCopyFromURLHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string VersionId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopyId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopyStatus
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-status", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] XMsContentCrc64
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-content-crc64", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobCopyFromURLHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobCreateSnapshotHeaders
	{
		private readonly Response _response;

		public string Snapshot
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-snapshot", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string VersionId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-request-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobCreateSnapshotHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobDeleteHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobDeleteHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobDeleteImmutabilityPolicyHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobDeleteImmutabilityPolicyHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobDownloadHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public DateTimeOffset? CreationTime
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-creation-time", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public IDictionary<string, string> Metadata
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-meta-", out IDictionary<string, string> value))
				{
					return null;
				}
				return value;
			}
		}

		public string ObjectReplicationPolicyId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-or-policy-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public IDictionary<string, string> ObjectReplicationRules
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-or-", out IDictionary<string, string> value))
				{
					return null;
				}
				return value;
			}
		}

		public long? ContentLength
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Length", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentType
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Type", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentRange
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Range", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentEncoding
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Encoding", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CacheControl
		{
			get
			{
				if (!_response.Headers.TryGetValue("Cache-Control", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentDisposition
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Disposition", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentLanguage
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Language", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public long? BlobSequenceNumber
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-sequence-number", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobType? BlobType
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-type", out string value))
				{
					return null;
				}
				return value.ToBlobType();
			}
		}

		public DateTimeOffset? CopyCompletionTime
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-completion-time", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopyStatusDescription
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-status-description", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopyId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopyProgress
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-progress", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopySource
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-source", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public CopyStatus? CopyStatus
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-status", out string value))
				{
					return null;
				}
				return value.ToCopyStatus();
			}
		}

		public LeaseDurationType? LeaseDuration
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-duration", out string value))
				{
					return null;
				}
				return value.ToLeaseDurationType();
			}
		}

		public LeaseState? LeaseState
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-state", out string value))
				{
					return null;
				}
				return value.ToLeaseState();
			}
		}

		public LeaseStatus? LeaseStatus
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-status", out string value))
				{
					return null;
				}
				return value.ToLeaseStatus();
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string VersionId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsCurrentVersion
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-is-current-version", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string AcceptRanges
		{
			get
			{
				if (!_response.Headers.TryGetValue("Accept-Ranges", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public int? BlobCommittedBlockCount
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-committed-block-count", out int? value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] BlobContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-content-md5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public long? TagCount
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-tag-count", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsSealed
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-sealed", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public DateTimeOffset? LastAccessed
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-last-access-time", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public DateTimeOffset? ImmutabilityPolicyExpiresOn
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-immutability-policy-until-date", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobImmutabilityPolicyMode? ImmutabilityPolicyMode
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-immutability-policy-mode", out string value))
				{
					return null;
				}
				return value.ToBlobImmutabilityPolicyMode();
			}
		}

		public bool? LegalHold
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-legal-hold", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentCrc64
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-content-crc64", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public string ErrorCode
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-error-code", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobDownloadHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobGetPropertiesHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public DateTimeOffset? CreationTime
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-creation-time", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public IDictionary<string, string> Metadata
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-meta-", out IDictionary<string, string> value))
				{
					return null;
				}
				return value;
			}
		}

		public string ObjectReplicationPolicyId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-or-policy-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public IDictionary<string, string> ObjectReplicationRules
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-or-", out IDictionary<string, string> value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobType? BlobType
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-type", out string value))
				{
					return null;
				}
				return value.ToBlobType();
			}
		}

		public DateTimeOffset? CopyCompletionTime
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-completion-time", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopyStatusDescription
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-status-description", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopyId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopyProgress
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-progress", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopySource
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-source", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public CopyStatus? CopyStatus
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-status", out string value))
				{
					return null;
				}
				return value.ToCopyStatus();
			}
		}

		public bool? IsIncrementalCopy
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-incremental-copy", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string DestinationSnapshot
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-destination-snapshot", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public LeaseDurationType? LeaseDuration
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-duration", out string value))
				{
					return null;
				}
				return value.ToLeaseDurationType();
			}
		}

		public LeaseState? LeaseState
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-state", out string value))
				{
					return null;
				}
				return value.ToLeaseState();
			}
		}

		public LeaseStatus? LeaseStatus
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-status", out string value))
				{
					return null;
				}
				return value.ToLeaseStatus();
			}
		}

		public long? ContentLength
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Length", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentType
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Type", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentEncoding
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Encoding", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentDisposition
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Disposition", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentLanguage
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Language", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CacheControl
		{
			get
			{
				if (!_response.Headers.TryGetValue("Cache-Control", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public long? BlobSequenceNumber
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-sequence-number", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string AcceptRanges
		{
			get
			{
				if (!_response.Headers.TryGetValue("Accept-Ranges", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public int? BlobCommittedBlockCount
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-committed-block-count", out int? value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string AccessTier
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-access-tier", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? AccessTierInferred
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-access-tier-inferred", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string ArchiveStatus
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-archive-status", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public DateTimeOffset? AccessTierChangeTime
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-access-tier-change-time", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string VersionId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsCurrentVersion
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-is-current-version", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public long? TagCount
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-tag-count", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public DateTimeOffset? ExpiresOn
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-expiry-time", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsSealed
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-sealed", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string RehydratePriority
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-rehydrate-priority", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public DateTimeOffset? LastAccessed
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-last-access-time", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public DateTimeOffset? ImmutabilityPolicyExpiresOn
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-immutability-policy-until-date", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobImmutabilityPolicyMode? ImmutabilityPolicyMode
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-immutability-policy-mode", out string value))
				{
					return null;
				}
				return value.ToBlobImmutabilityPolicyMode();
			}
		}

		public bool? LegalHold
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-legal-hold", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobGetPropertiesHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobGetTagsHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobGetTagsHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobQueryHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public IDictionary<string, string> Metadata
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-meta-", out IDictionary<string, string> value))
				{
					return null;
				}
				return value;
			}
		}

		public long? ContentLength
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Length", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentType
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Type", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentRange
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Range", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentEncoding
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Encoding", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CacheControl
		{
			get
			{
				if (!_response.Headers.TryGetValue("Cache-Control", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentDisposition
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Disposition", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentLanguage
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Language", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public long? BlobSequenceNumber
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-sequence-number", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobType? BlobType
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-type", out string value))
				{
					return null;
				}
				return value.ToBlobType();
			}
		}

		public DateTimeOffset? CopyCompletionTime
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-completion-time", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopyStatusDescription
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-status-description", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopyId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopyProgress
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-progress", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopySource
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-source", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public CopyStatus? CopyStatus
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-status", out string value))
				{
					return null;
				}
				return value.ToCopyStatus();
			}
		}

		public LeaseDurationType? LeaseDuration
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-duration", out string value))
				{
					return null;
				}
				return value.ToLeaseDurationType();
			}
		}

		public LeaseState? LeaseState
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-state", out string value))
				{
					return null;
				}
				return value.ToLeaseState();
			}
		}

		public LeaseStatus? LeaseStatus
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-status", out string value))
				{
					return null;
				}
				return value.ToLeaseStatus();
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string AcceptRanges
		{
			get
			{
				if (!_response.Headers.TryGetValue("Accept-Ranges", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public int? BlobCommittedBlockCount
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-committed-block-count", out int? value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] BlobContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-content-md5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentCrc64
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-content-crc64", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobQueryHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobReleaseLeaseHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobReleaseLeaseHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobRenewLeaseHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string LeaseId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobRenewLeaseHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobRestClient
	{
		private readonly HttpPipeline _pipeline;

		private readonly string _url;

		private readonly string _version;

		private static ResponseClassifier _responseClassifier200;

		private static ResponseClassifier _responseClassifier201;

		internal Azure.Core.Pipeline.ClientDiagnostics ClientDiagnostics { get; }

		private static ResponseClassifier ResponseClassifier200
		{
			get
			{
				ResponseClassifier responseClassifier = _responseClassifier200;
				if (responseClassifier == null)
				{
					responseClassifier = (_responseClassifier200 = new StatusCodeClassifier(stackalloc ushort[1] { 200 }));
				}
				return responseClassifier;
			}
		}

		private static ResponseClassifier ResponseClassifier201
		{
			get
			{
				ResponseClassifier responseClassifier = _responseClassifier201;
				if (responseClassifier == null)
				{
					responseClassifier = (_responseClassifier201 = new StatusCodeClassifier(stackalloc ushort[1] { 201 }));
				}
				return responseClassifier;
			}
		}

		public BlobRestClient(Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version)
		{
			ClientDiagnostics = clientDiagnostics ?? throw new ArgumentNullException("clientDiagnostics");
			_pipeline = pipeline ?? throw new ArgumentNullException("pipeline");
			_url = url ?? throw new ArgumentNullException("url");
			_version = version ?? throw new ArgumentNullException("version");
		}

		internal HttpMessage CreateDownloadRequest(string snapshot, string versionId, int? timeout, string range, string leaseId, bool? rangeGetContentMD5, bool? rangeGetContentCRC64, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			httpMessage.BufferResponse = false;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			if (snapshot != null)
			{
				rawRequestUriBuilder.AppendQuery("snapshot", snapshot, escapeValue: true);
			}
			if (versionId != null)
			{
				rawRequestUriBuilder.AppendQuery("versionid", versionId, escapeValue: true);
			}
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (range != null)
			{
				request.Headers.Add("x-ms-range", range);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (rangeGetContentMD5.HasValue)
			{
				request.Headers.Add("x-ms-range-get-content-md5", rangeGetContentMD5.Value);
			}
			if (rangeGetContentCRC64.HasValue)
			{
				request.Headers.Add("x-ms-range-get-content-crc64", rangeGetContentCRC64.Value);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<Stream, BlobDownloadHeaders>> DownloadAsync(string snapshot = null, string versionId = null, int? timeout = null, string range = null, string leaseId = null, bool? rangeGetContentMD5 = null, bool? rangeGetContentCRC64 = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateDownloadRequest(snapshot, versionId, timeout, range, leaseId, rangeGetContentMD5, rangeGetContentCRC64, encryptionKey, encryptionKeySha256, encryptionAlgorithm, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobDownloadHeaders headers = new BlobDownloadHeaders(message.Response);
			switch (message.Response.Status)
			{
			case 200:
			case 206:
				return Azure.Core.ResponseWithHeaders.FromValue(message.ExtractResponseContent(), headers, message.Response);
			case 304:
				return Azure.Core.ResponseWithHeaders.FromValue<Stream, BlobDownloadHeaders>(null, headers, message.Response);
			default:
				throw new RequestFailedException(message.Response);
			}
		}

		public Azure.Core.ResponseWithHeaders<Stream, BlobDownloadHeaders> Download(string snapshot = null, string versionId = null, int? timeout = null, string range = null, string leaseId = null, bool? rangeGetContentMD5 = null, bool? rangeGetContentCRC64 = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateDownloadRequest(snapshot, versionId, timeout, range, leaseId, rangeGetContentMD5, rangeGetContentCRC64, encryptionKey, encryptionKeySha256, encryptionAlgorithm, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobDownloadHeaders headers = new BlobDownloadHeaders(httpMessage.Response);
			switch (httpMessage.Response.Status)
			{
			case 200:
			case 206:
				return Azure.Core.ResponseWithHeaders.FromValue(httpMessage.ExtractResponseContent(), headers, httpMessage.Response);
			case 304:
				return Azure.Core.ResponseWithHeaders.FromValue<Stream, BlobDownloadHeaders>(null, headers, httpMessage.Response);
			default:
				throw new RequestFailedException(httpMessage.Response);
			}
		}

		internal HttpMessage CreateGetPropertiesRequest(string snapshot, string versionId, int? timeout, string leaseId, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Head;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			if (snapshot != null)
			{
				rawRequestUriBuilder.AppendQuery("snapshot", snapshot, escapeValue: true);
			}
			if (versionId != null)
			{
				rawRequestUriBuilder.AppendQuery("versionid", versionId, escapeValue: true);
			}
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobGetPropertiesHeaders>> GetPropertiesAsync(string snapshot = null, string versionId = null, int? timeout = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateGetPropertiesRequest(snapshot, versionId, timeout, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobGetPropertiesHeaders headers = new BlobGetPropertiesHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobGetPropertiesHeaders> GetProperties(string snapshot = null, string versionId = null, int? timeout = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateGetPropertiesRequest(snapshot, versionId, timeout, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobGetPropertiesHeaders headers = new BlobGetPropertiesHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateGetPropertiesRequest(string snapshot, string versionId, int? timeout, string leaseId, string encryptionKey, string encryptionKeySha256, string encryptionAlgorithm, string ifTags, RequestConditions requestConditions, RequestContext context)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage(context, ResponseClassifier200);
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Head;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			if (snapshot != null)
			{
				rawRequestUriBuilder.AppendQuery("snapshot", snapshot, escapeValue: true);
			}
			if (versionId != null)
			{
				rawRequestUriBuilder.AppendQuery("versionid", versionId, escapeValue: true);
			}
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm != null)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			if (requestConditions != null)
			{
				request.Headers.Add(requestConditions, "R");
			}
			return httpMessage;
		}

		public virtual async Task<Response> GetPropertiesAsync(string snapshot = null, string versionId = null, int? timeout = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, string encryptionAlgorithm = null, string ifTags = null, RequestConditions requestConditions = null, RequestContext context = null)
		{
			using Azure.Core.Pipeline.DiagnosticScope scope = ClientDiagnostics.CreateScope("Blob.GetProperties");
			scope.Start();
			try
			{
				using HttpMessage message = CreateGetPropertiesRequest(snapshot, versionId, timeout, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, ifTags, requestConditions, context);
				return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(continueOnCapturedContext: false);
			}
			catch (Exception exception)
			{
				scope.Failed(exception);
				throw;
			}
		}

		public virtual Response GetProperties(string snapshot = null, string versionId = null, int? timeout = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, string encryptionAlgorithm = null, string ifTags = null, RequestConditions requestConditions = null, RequestContext context = null)
		{
			using Azure.Core.Pipeline.DiagnosticScope diagnosticScope = ClientDiagnostics.CreateScope("Blob.GetProperties");
			diagnosticScope.Start();
			try
			{
				using HttpMessage message = CreateGetPropertiesRequest(snapshot, versionId, timeout, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, ifTags, requestConditions, context);
				return _pipeline.ProcessMessage(message, context);
			}
			catch (Exception exception)
			{
				diagnosticScope.Failed(exception);
				throw;
			}
		}

		internal HttpMessage CreateDeleteRequest(string snapshot, string versionId, int? timeout, string leaseId, DeleteSnapshotsOption? deleteSnapshots, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, BlobDeleteType? blobDeleteType)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Delete;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			if (snapshot != null)
			{
				rawRequestUriBuilder.AppendQuery("snapshot", snapshot, escapeValue: true);
			}
			if (versionId != null)
			{
				rawRequestUriBuilder.AppendQuery("versionid", versionId, escapeValue: true);
			}
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			if (blobDeleteType.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("deletetype", blobDeleteType.Value.ToSerialString(), escapeValue: true);
			}
			request.Uri = rawRequestUriBuilder;
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (deleteSnapshots.HasValue)
			{
				request.Headers.Add("x-ms-delete-snapshots", deleteSnapshots.Value.ToSerialString());
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobDeleteHeaders>> DeleteAsync(string snapshot = null, string versionId = null, int? timeout = null, string leaseId = null, DeleteSnapshotsOption? deleteSnapshots = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, BlobDeleteType? blobDeleteType = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateDeleteRequest(snapshot, versionId, timeout, leaseId, deleteSnapshots, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobDeleteType);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobDeleteHeaders headers = new BlobDeleteHeaders(message.Response);
			if (message.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobDeleteHeaders> Delete(string snapshot = null, string versionId = null, int? timeout = null, string leaseId = null, DeleteSnapshotsOption? deleteSnapshots = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, BlobDeleteType? blobDeleteType = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateDeleteRequest(snapshot, versionId, timeout, leaseId, deleteSnapshots, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobDeleteType);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobDeleteHeaders headers = new BlobDeleteHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateUndeleteRequest(int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "undelete", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobUndeleteHeaders>> UndeleteAsync(int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateUndeleteRequest(timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobUndeleteHeaders headers = new BlobUndeleteHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobUndeleteHeaders> Undelete(int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateUndeleteRequest(timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobUndeleteHeaders headers = new BlobUndeleteHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateSetExpiryRequest(BlobExpiryOptions expiryOptions, int? timeout, string expiresOn)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "expiry", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("x-ms-expiry-option", expiryOptions.ToString());
			if (expiresOn != null)
			{
				request.Headers.Add("x-ms-expiry-time", expiresOn);
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobSetExpiryHeaders>> SetExpiryAsync(BlobExpiryOptions expiryOptions, int? timeout = null, string expiresOn = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateSetExpiryRequest(expiryOptions, timeout, expiresOn);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobSetExpiryHeaders headers = new BlobSetExpiryHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobSetExpiryHeaders> SetExpiry(BlobExpiryOptions expiryOptions, int? timeout = null, string expiresOn = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateSetExpiryRequest(expiryOptions, timeout, expiresOn);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobSetExpiryHeaders headers = new BlobSetExpiryHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateSetHttpHeadersRequest(int? timeout, string blobCacheControl, string blobContentType, byte[] blobContentMD5, string blobContentEncoding, string blobContentLanguage, string leaseId, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobContentDisposition)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "properties", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (blobCacheControl != null)
			{
				request.Headers.Add("x-ms-blob-cache-control", blobCacheControl);
			}
			if (blobContentType != null)
			{
				request.Headers.Add("x-ms-blob-content-type", blobContentType);
			}
			if (blobContentMD5 != null)
			{
				request.Headers.Add("x-ms-blob-content-md5", blobContentMD5, "D");
			}
			if (blobContentEncoding != null)
			{
				request.Headers.Add("x-ms-blob-content-encoding", blobContentEncoding);
			}
			if (blobContentLanguage != null)
			{
				request.Headers.Add("x-ms-blob-content-language", blobContentLanguage);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			if (blobContentDisposition != null)
			{
				request.Headers.Add("x-ms-blob-content-disposition", blobContentDisposition);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobSetHttpHeadersHeaders>> SetHttpHeadersAsync(int? timeout = null, string blobCacheControl = null, string blobContentType = null, byte[] blobContentMD5 = null, string blobContentEncoding = null, string blobContentLanguage = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string blobContentDisposition = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateSetHttpHeadersRequest(timeout, blobCacheControl, blobContentType, blobContentMD5, blobContentEncoding, blobContentLanguage, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobContentDisposition);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobSetHttpHeadersHeaders headers = new BlobSetHttpHeadersHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobSetHttpHeadersHeaders> SetHttpHeaders(int? timeout = null, string blobCacheControl = null, string blobContentType = null, byte[] blobContentMD5 = null, string blobContentEncoding = null, string blobContentLanguage = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string blobContentDisposition = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateSetHttpHeadersRequest(timeout, blobCacheControl, blobContentType, blobContentMD5, blobContentEncoding, blobContentLanguage, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobContentDisposition);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobSetHttpHeadersHeaders headers = new BlobSetHttpHeadersHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateSetImmutabilityPolicyRequest(int? timeout, DateTimeOffset? ifUnmodifiedSince, DateTimeOffset? immutabilityPolicyExpiry, BlobImmutabilityPolicyMode? immutabilityPolicyMode)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "immutabilityPolicies", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (immutabilityPolicyExpiry.HasValue)
			{
				request.Headers.Add("x-ms-immutability-policy-until-date", immutabilityPolicyExpiry.Value, "R");
			}
			if (immutabilityPolicyMode.HasValue)
			{
				request.Headers.Add("x-ms-immutability-policy-mode", immutabilityPolicyMode.Value.ToSerialString());
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobSetImmutabilityPolicyHeaders>> SetImmutabilityPolicyAsync(int? timeout = null, DateTimeOffset? ifUnmodifiedSince = null, DateTimeOffset? immutabilityPolicyExpiry = null, BlobImmutabilityPolicyMode? immutabilityPolicyMode = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateSetImmutabilityPolicyRequest(timeout, ifUnmodifiedSince, immutabilityPolicyExpiry, immutabilityPolicyMode);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobSetImmutabilityPolicyHeaders headers = new BlobSetImmutabilityPolicyHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobSetImmutabilityPolicyHeaders> SetImmutabilityPolicy(int? timeout = null, DateTimeOffset? ifUnmodifiedSince = null, DateTimeOffset? immutabilityPolicyExpiry = null, BlobImmutabilityPolicyMode? immutabilityPolicyMode = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateSetImmutabilityPolicyRequest(timeout, ifUnmodifiedSince, immutabilityPolicyExpiry, immutabilityPolicyMode);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobSetImmutabilityPolicyHeaders headers = new BlobSetImmutabilityPolicyHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateDeleteImmutabilityPolicyRequest(int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Delete;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "immutabilityPolicies", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobDeleteImmutabilityPolicyHeaders>> DeleteImmutabilityPolicyAsync(int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateDeleteImmutabilityPolicyRequest(timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobDeleteImmutabilityPolicyHeaders headers = new BlobDeleteImmutabilityPolicyHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobDeleteImmutabilityPolicyHeaders> DeleteImmutabilityPolicy(int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateDeleteImmutabilityPolicyRequest(timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobDeleteImmutabilityPolicyHeaders headers = new BlobDeleteImmutabilityPolicyHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateSetLegalHoldRequest(bool legalHold, int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "legalhold", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("x-ms-legal-hold", legalHold);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobSetLegalHoldHeaders>> SetLegalHoldAsync(bool legalHold, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateSetLegalHoldRequest(legalHold, timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobSetLegalHoldHeaders headers = new BlobSetLegalHoldHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobSetLegalHoldHeaders> SetLegalHold(bool legalHold, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateSetLegalHoldRequest(legalHold, timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobSetLegalHoldHeaders headers = new BlobSetLegalHoldHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateSetMetadataRequest(int? timeout, IDictionary<string, string> metadata, string leaseId, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "metadata", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (metadata != null)
			{
				request.Headers.Add("x-ms-meta-", metadata);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobSetMetadataHeaders>> SetMetadataAsync(int? timeout = null, IDictionary<string, string> metadata = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateSetMetadataRequest(timeout, metadata, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobSetMetadataHeaders headers = new BlobSetMetadataHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobSetMetadataHeaders> SetMetadata(int? timeout = null, IDictionary<string, string> metadata = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateSetMetadataRequest(timeout, metadata, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobSetMetadataHeaders headers = new BlobSetMetadataHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateAcquireLeaseRequest(int? timeout, long? duration, string proposedLeaseId, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "lease", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-lease-action", "acquire");
			if (duration.HasValue)
			{
				request.Headers.Add("x-ms-lease-duration", duration.Value);
			}
			if (proposedLeaseId != null)
			{
				request.Headers.Add("x-ms-proposed-lease-id", proposedLeaseId);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobAcquireLeaseHeaders>> AcquireLeaseAsync(int? timeout = null, long? duration = null, string proposedLeaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateAcquireLeaseRequest(timeout, duration, proposedLeaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobAcquireLeaseHeaders headers = new BlobAcquireLeaseHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobAcquireLeaseHeaders> AcquireLease(int? timeout = null, long? duration = null, string proposedLeaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateAcquireLeaseRequest(timeout, duration, proposedLeaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobAcquireLeaseHeaders headers = new BlobAcquireLeaseHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateAcquireLeaseRequest(int? timeout, long? duration, string proposedLeaseId, string ifTags, RequestConditions requestConditions, RequestContext context)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage(context, ResponseClassifier201);
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "lease", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-lease-action", "acquire");
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			if (duration.HasValue)
			{
				request.Headers.Add("x-ms-lease-duration", duration.Value);
			}
			if (proposedLeaseId != null)
			{
				request.Headers.Add("x-ms-proposed-lease-id", proposedLeaseId);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			if (requestConditions != null)
			{
				request.Headers.Add(requestConditions, "R");
			}
			return httpMessage;
		}

		public virtual async Task<Response> AcquireLeaseAsync(int? timeout = null, long? duration = null, string proposedLeaseId = null, string ifTags = null, RequestConditions requestConditions = null, RequestContext context = null)
		{
			using Azure.Core.Pipeline.DiagnosticScope scope = ClientDiagnostics.CreateScope("Blob.AcquireLease");
			scope.Start();
			try
			{
				using HttpMessage message = CreateAcquireLeaseRequest(timeout, duration, proposedLeaseId, ifTags, requestConditions, context);
				return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(continueOnCapturedContext: false);
			}
			catch (Exception exception)
			{
				scope.Failed(exception);
				throw;
			}
		}

		public virtual Response AcquireLease(int? timeout = null, long? duration = null, string proposedLeaseId = null, string ifTags = null, RequestConditions requestConditions = null, RequestContext context = null)
		{
			using Azure.Core.Pipeline.DiagnosticScope diagnosticScope = ClientDiagnostics.CreateScope("Blob.AcquireLease");
			diagnosticScope.Start();
			try
			{
				using HttpMessage message = CreateAcquireLeaseRequest(timeout, duration, proposedLeaseId, ifTags, requestConditions, context);
				return _pipeline.ProcessMessage(message, context);
			}
			catch (Exception exception)
			{
				diagnosticScope.Failed(exception);
				throw;
			}
		}

		internal HttpMessage CreateReleaseLeaseRequest(string leaseId, int? timeout, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "lease", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-lease-action", "release");
			request.Headers.Add("x-ms-lease-id", leaseId);
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobReleaseLeaseHeaders>> ReleaseLeaseAsync(string leaseId, int? timeout = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (leaseId == null)
			{
				throw new ArgumentNullException("leaseId");
			}
			using HttpMessage message = CreateReleaseLeaseRequest(leaseId, timeout, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobReleaseLeaseHeaders headers = new BlobReleaseLeaseHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobReleaseLeaseHeaders> ReleaseLease(string leaseId, int? timeout = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (leaseId == null)
			{
				throw new ArgumentNullException("leaseId");
			}
			using HttpMessage httpMessage = CreateReleaseLeaseRequest(leaseId, timeout, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobReleaseLeaseHeaders headers = new BlobReleaseLeaseHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateRenewLeaseRequest(string leaseId, int? timeout, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "lease", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-lease-action", "renew");
			request.Headers.Add("x-ms-lease-id", leaseId);
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobRenewLeaseHeaders>> RenewLeaseAsync(string leaseId, int? timeout = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (leaseId == null)
			{
				throw new ArgumentNullException("leaseId");
			}
			using HttpMessage message = CreateRenewLeaseRequest(leaseId, timeout, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobRenewLeaseHeaders headers = new BlobRenewLeaseHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobRenewLeaseHeaders> RenewLease(string leaseId, int? timeout = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (leaseId == null)
			{
				throw new ArgumentNullException("leaseId");
			}
			using HttpMessage httpMessage = CreateRenewLeaseRequest(leaseId, timeout, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobRenewLeaseHeaders headers = new BlobRenewLeaseHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateChangeLeaseRequest(string leaseId, string proposedLeaseId, int? timeout, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "lease", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-lease-action", "change");
			request.Headers.Add("x-ms-lease-id", leaseId);
			request.Headers.Add("x-ms-proposed-lease-id", proposedLeaseId);
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobChangeLeaseHeaders>> ChangeLeaseAsync(string leaseId, string proposedLeaseId, int? timeout = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (leaseId == null)
			{
				throw new ArgumentNullException("leaseId");
			}
			if (proposedLeaseId == null)
			{
				throw new ArgumentNullException("proposedLeaseId");
			}
			using HttpMessage message = CreateChangeLeaseRequest(leaseId, proposedLeaseId, timeout, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobChangeLeaseHeaders headers = new BlobChangeLeaseHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobChangeLeaseHeaders> ChangeLease(string leaseId, string proposedLeaseId, int? timeout = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (leaseId == null)
			{
				throw new ArgumentNullException("leaseId");
			}
			if (proposedLeaseId == null)
			{
				throw new ArgumentNullException("proposedLeaseId");
			}
			using HttpMessage httpMessage = CreateChangeLeaseRequest(leaseId, proposedLeaseId, timeout, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobChangeLeaseHeaders headers = new BlobChangeLeaseHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateBreakLeaseRequest(int? timeout, long? breakPeriod, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "lease", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-lease-action", "break");
			if (breakPeriod.HasValue)
			{
				request.Headers.Add("x-ms-lease-break-period", breakPeriod.Value);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobBreakLeaseHeaders>> BreakLeaseAsync(int? timeout = null, long? breakPeriod = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateBreakLeaseRequest(timeout, breakPeriod, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobBreakLeaseHeaders headers = new BlobBreakLeaseHeaders(message.Response);
			if (message.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobBreakLeaseHeaders> BreakLease(int? timeout = null, long? breakPeriod = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateBreakLeaseRequest(timeout, breakPeriod, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobBreakLeaseHeaders headers = new BlobBreakLeaseHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateCreateSnapshotRequest(int? timeout, IDictionary<string, string> metadata, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "snapshot", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (metadata != null)
			{
				request.Headers.Add("x-ms-meta-", metadata);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobCreateSnapshotHeaders>> CreateSnapshotAsync(int? timeout = null, IDictionary<string, string> metadata = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string leaseId = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateCreateSnapshotRequest(timeout, metadata, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, leaseId);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobCreateSnapshotHeaders headers = new BlobCreateSnapshotHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobCreateSnapshotHeaders> CreateSnapshot(int? timeout = null, IDictionary<string, string> metadata = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string leaseId = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateCreateSnapshotRequest(timeout, metadata, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, leaseId);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobCreateSnapshotHeaders headers = new BlobCreateSnapshotHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateStartCopyFromURLRequest(string copySource, int? timeout, IDictionary<string, string> metadata, AccessTier? tier, RehydratePriority? rehydratePriority, DateTimeOffset? sourceIfModifiedSince, DateTimeOffset? sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string sourceIfTags, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, string blobTagsString, bool? sealBlob, DateTimeOffset? immutabilityPolicyExpiry, BlobImmutabilityPolicyMode? immutabilityPolicyMode, bool? legalHold)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (metadata != null)
			{
				request.Headers.Add("x-ms-meta-", metadata);
			}
			if (tier.HasValue)
			{
				request.Headers.Add("x-ms-access-tier", tier.Value.ToString());
			}
			if (rehydratePriority.HasValue)
			{
				request.Headers.Add("x-ms-rehydrate-priority", rehydratePriority.Value.ToSerialString());
			}
			if (sourceIfModifiedSince.HasValue)
			{
				request.Headers.Add("x-ms-source-if-modified-since", sourceIfModifiedSince.Value, "R");
			}
			if (sourceIfUnmodifiedSince.HasValue)
			{
				request.Headers.Add("x-ms-source-if-unmodified-since", sourceIfUnmodifiedSince.Value, "R");
			}
			if (sourceIfMatch != null)
			{
				request.Headers.Add("x-ms-source-if-match", sourceIfMatch);
			}
			if (sourceIfNoneMatch != null)
			{
				request.Headers.Add("x-ms-source-if-none-match", sourceIfNoneMatch);
			}
			if (sourceIfTags != null)
			{
				request.Headers.Add("x-ms-source-if-tags", sourceIfTags);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-copy-source", copySource);
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			request.Headers.Add("x-ms-version", _version);
			if (blobTagsString != null)
			{
				request.Headers.Add("x-ms-tags", blobTagsString);
			}
			if (sealBlob.HasValue)
			{
				request.Headers.Add("x-ms-seal-blob", sealBlob.Value);
			}
			if (immutabilityPolicyExpiry.HasValue)
			{
				request.Headers.Add("x-ms-immutability-policy-until-date", immutabilityPolicyExpiry.Value, "R");
			}
			if (immutabilityPolicyMode.HasValue)
			{
				request.Headers.Add("x-ms-immutability-policy-mode", immutabilityPolicyMode.Value.ToSerialString());
			}
			if (legalHold.HasValue)
			{
				request.Headers.Add("x-ms-legal-hold", legalHold.Value);
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobStartCopyFromURLHeaders>> StartCopyFromURLAsync(string copySource, int? timeout = null, IDictionary<string, string> metadata = null, AccessTier? tier = null, RehydratePriority? rehydratePriority = null, DateTimeOffset? sourceIfModifiedSince = null, DateTimeOffset? sourceIfUnmodifiedSince = null, string sourceIfMatch = null, string sourceIfNoneMatch = null, string sourceIfTags = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string leaseId = null, string blobTagsString = null, bool? sealBlob = null, DateTimeOffset? immutabilityPolicyExpiry = null, BlobImmutabilityPolicyMode? immutabilityPolicyMode = null, bool? legalHold = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (copySource == null)
			{
				throw new ArgumentNullException("copySource");
			}
			using HttpMessage message = CreateStartCopyFromURLRequest(copySource, timeout, metadata, tier, rehydratePriority, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, sourceIfTags, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, leaseId, blobTagsString, sealBlob, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobStartCopyFromURLHeaders headers = new BlobStartCopyFromURLHeaders(message.Response);
			if (message.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobStartCopyFromURLHeaders> StartCopyFromURL(string copySource, int? timeout = null, IDictionary<string, string> metadata = null, AccessTier? tier = null, RehydratePriority? rehydratePriority = null, DateTimeOffset? sourceIfModifiedSince = null, DateTimeOffset? sourceIfUnmodifiedSince = null, string sourceIfMatch = null, string sourceIfNoneMatch = null, string sourceIfTags = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string leaseId = null, string blobTagsString = null, bool? sealBlob = null, DateTimeOffset? immutabilityPolicyExpiry = null, BlobImmutabilityPolicyMode? immutabilityPolicyMode = null, bool? legalHold = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (copySource == null)
			{
				throw new ArgumentNullException("copySource");
			}
			using HttpMessage httpMessage = CreateStartCopyFromURLRequest(copySource, timeout, metadata, tier, rehydratePriority, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, sourceIfTags, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, leaseId, blobTagsString, sealBlob, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobStartCopyFromURLHeaders headers = new BlobStartCopyFromURLHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateCopyFromURLRequest(string copySource, int? timeout, IDictionary<string, string> metadata, AccessTier? tier, DateTimeOffset? sourceIfModifiedSince, DateTimeOffset? sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string leaseId, byte[] sourceContentMD5, string blobTagsString, DateTimeOffset? immutabilityPolicyExpiry, BlobImmutabilityPolicyMode? immutabilityPolicyMode, bool? legalHold, string copySourceAuthorization, string encryptionScope, BlobCopySourceTagsMode? copySourceTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-requires-sync", "true");
			if (metadata != null)
			{
				request.Headers.Add("x-ms-meta-", metadata);
			}
			if (tier.HasValue)
			{
				request.Headers.Add("x-ms-access-tier", tier.Value.ToString());
			}
			if (sourceIfModifiedSince.HasValue)
			{
				request.Headers.Add("x-ms-source-if-modified-since", sourceIfModifiedSince.Value, "R");
			}
			if (sourceIfUnmodifiedSince.HasValue)
			{
				request.Headers.Add("x-ms-source-if-unmodified-since", sourceIfUnmodifiedSince.Value, "R");
			}
			if (sourceIfMatch != null)
			{
				request.Headers.Add("x-ms-source-if-match", sourceIfMatch);
			}
			if (sourceIfNoneMatch != null)
			{
				request.Headers.Add("x-ms-source-if-none-match", sourceIfNoneMatch);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-copy-source", copySource);
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			request.Headers.Add("x-ms-version", _version);
			if (sourceContentMD5 != null)
			{
				request.Headers.Add("x-ms-source-content-md5", sourceContentMD5, "D");
			}
			if (blobTagsString != null)
			{
				request.Headers.Add("x-ms-tags", blobTagsString);
			}
			if (immutabilityPolicyExpiry.HasValue)
			{
				request.Headers.Add("x-ms-immutability-policy-until-date", immutabilityPolicyExpiry.Value, "R");
			}
			if (immutabilityPolicyMode.HasValue)
			{
				request.Headers.Add("x-ms-immutability-policy-mode", immutabilityPolicyMode.Value.ToSerialString());
			}
			if (legalHold.HasValue)
			{
				request.Headers.Add("x-ms-legal-hold", legalHold.Value);
			}
			if (copySourceAuthorization != null)
			{
				request.Headers.Add("x-ms-copy-source-authorization", copySourceAuthorization);
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (copySourceTags.HasValue)
			{
				request.Headers.Add("x-ms-copy-source-tag-option", copySourceTags.Value.ToSerialString());
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobCopyFromURLHeaders>> CopyFromURLAsync(string copySource, int? timeout = null, IDictionary<string, string> metadata = null, AccessTier? tier = null, DateTimeOffset? sourceIfModifiedSince = null, DateTimeOffset? sourceIfUnmodifiedSince = null, string sourceIfMatch = null, string sourceIfNoneMatch = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string leaseId = null, byte[] sourceContentMD5 = null, string blobTagsString = null, DateTimeOffset? immutabilityPolicyExpiry = null, BlobImmutabilityPolicyMode? immutabilityPolicyMode = null, bool? legalHold = null, string copySourceAuthorization = null, string encryptionScope = null, BlobCopySourceTagsMode? copySourceTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (copySource == null)
			{
				throw new ArgumentNullException("copySource");
			}
			using HttpMessage message = CreateCopyFromURLRequest(copySource, timeout, metadata, tier, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, leaseId, sourceContentMD5, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold, copySourceAuthorization, encryptionScope, copySourceTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobCopyFromURLHeaders headers = new BlobCopyFromURLHeaders(message.Response);
			if (message.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobCopyFromURLHeaders> CopyFromURL(string copySource, int? timeout = null, IDictionary<string, string> metadata = null, AccessTier? tier = null, DateTimeOffset? sourceIfModifiedSince = null, DateTimeOffset? sourceIfUnmodifiedSince = null, string sourceIfMatch = null, string sourceIfNoneMatch = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string leaseId = null, byte[] sourceContentMD5 = null, string blobTagsString = null, DateTimeOffset? immutabilityPolicyExpiry = null, BlobImmutabilityPolicyMode? immutabilityPolicyMode = null, bool? legalHold = null, string copySourceAuthorization = null, string encryptionScope = null, BlobCopySourceTagsMode? copySourceTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (copySource == null)
			{
				throw new ArgumentNullException("copySource");
			}
			using HttpMessage httpMessage = CreateCopyFromURLRequest(copySource, timeout, metadata, tier, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, leaseId, sourceContentMD5, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold, copySourceAuthorization, encryptionScope, copySourceTags);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobCopyFromURLHeaders headers = new BlobCopyFromURLHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateAbortCopyFromURLRequest(string copyId, int? timeout, string leaseId)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "copy", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("copyid", copyId, escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-copy-action", "abort");
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobAbortCopyFromURLHeaders>> AbortCopyFromURLAsync(string copyId, int? timeout = null, string leaseId = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (copyId == null)
			{
				throw new ArgumentNullException("copyId");
			}
			using HttpMessage message = CreateAbortCopyFromURLRequest(copyId, timeout, leaseId);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobAbortCopyFromURLHeaders headers = new BlobAbortCopyFromURLHeaders(message.Response);
			if (message.Response.Status == 204)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobAbortCopyFromURLHeaders> AbortCopyFromURL(string copyId, int? timeout = null, string leaseId = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (copyId == null)
			{
				throw new ArgumentNullException("copyId");
			}
			using HttpMessage httpMessage = CreateAbortCopyFromURLRequest(copyId, timeout, leaseId);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobAbortCopyFromURLHeaders headers = new BlobAbortCopyFromURLHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 204)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateSetTierRequest(AccessTier tier, string snapshot, string versionId, int? timeout, RehydratePriority? rehydratePriority, string leaseId, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "tier", escapeValue: true);
			if (snapshot != null)
			{
				rawRequestUriBuilder.AppendQuery("snapshot", snapshot, escapeValue: true);
			}
			if (versionId != null)
			{
				rawRequestUriBuilder.AppendQuery("versionid", versionId, escapeValue: true);
			}
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-access-tier", tier.ToString());
			if (rehydratePriority.HasValue)
			{
				request.Headers.Add("x-ms-rehydrate-priority", rehydratePriority.Value.ToSerialString());
			}
			request.Headers.Add("x-ms-version", _version);
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobSetTierHeaders>> SetTierAsync(AccessTier tier, string snapshot = null, string versionId = null, int? timeout = null, RehydratePriority? rehydratePriority = null, string leaseId = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateSetTierRequest(tier, snapshot, versionId, timeout, rehydratePriority, leaseId, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobSetTierHeaders headers = new BlobSetTierHeaders(message.Response);
			int status = message.Response.Status;
			if (status == 200 || status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobSetTierHeaders> SetTier(AccessTier tier, string snapshot = null, string versionId = null, int? timeout = null, RehydratePriority? rehydratePriority = null, string leaseId = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateSetTierRequest(tier, snapshot, versionId, timeout, rehydratePriority, leaseId, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobSetTierHeaders headers = new BlobSetTierHeaders(httpMessage.Response);
			int status = httpMessage.Response.Status;
			if (status == 200 || status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateQueryRequest(string snapshot, int? timeout, string leaseId, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, QueryRequest queryRequest)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			httpMessage.BufferResponse = false;
			request.Method = RequestMethod.Post;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "query", escapeValue: true);
			if (snapshot != null)
			{
				rawRequestUriBuilder.AppendQuery("snapshot", snapshot, escapeValue: true);
			}
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			if (queryRequest != null)
			{
				request.Headers.Add("Content-Type", "application/xml");
				Azure.Core.XmlWriterContent xmlWriterContent = new Azure.Core.XmlWriterContent();
				xmlWriterContent.XmlWriter.WriteObjectValue(queryRequest, "QueryRequest");
				request.Content = xmlWriterContent;
			}
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<Stream, BlobQueryHeaders>> QueryAsync(string snapshot = null, int? timeout = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, QueryRequest queryRequest = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateQueryRequest(snapshot, timeout, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, queryRequest);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobQueryHeaders headers = new BlobQueryHeaders(message.Response);
			int status = message.Response.Status;
			if (status == 200 || status == 206)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(message.ExtractResponseContent(), headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<Stream, BlobQueryHeaders> Query(string snapshot = null, int? timeout = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, QueryRequest queryRequest = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateQueryRequest(snapshot, timeout, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, queryRequest);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobQueryHeaders headers = new BlobQueryHeaders(httpMessage.Response);
			int status = httpMessage.Response.Status;
			if (status == 200 || status == 206)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(httpMessage.ExtractResponseContent(), headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateGetTagsRequest(int? timeout, string snapshot, string versionId, string ifTags, string leaseId)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "tags", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			if (snapshot != null)
			{
				rawRequestUriBuilder.AppendQuery("snapshot", snapshot, escapeValue: true);
			}
			if (versionId != null)
			{
				rawRequestUriBuilder.AppendQuery("versionid", versionId, escapeValue: true);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobTags, BlobGetTagsHeaders>> GetTagsAsync(int? timeout = null, string snapshot = null, string versionId = null, string ifTags = null, string leaseId = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateGetTagsRequest(timeout, snapshot, versionId, ifTags, leaseId);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobGetTagsHeaders headers = new BlobGetTagsHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				BlobTags value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("Tags");
				if (xElement != null)
				{
					value = BlobTags.DeserializeBlobTags(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobTags, BlobGetTagsHeaders> GetTags(int? timeout = null, string snapshot = null, string versionId = null, string ifTags = null, string leaseId = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateGetTagsRequest(timeout, snapshot, versionId, ifTags, leaseId);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobGetTagsHeaders headers = new BlobGetTagsHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				BlobTags value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("Tags");
				if (xElement != null)
				{
					value = BlobTags.DeserializeBlobTags(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateSetTagsRequest(int? timeout, string versionId, byte[] transactionalContentMD5, byte[] transactionalContentCrc64, string ifTags, string leaseId, BlobTags tags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "tags", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			if (versionId != null)
			{
				rawRequestUriBuilder.AppendQuery("versionid", versionId, escapeValue: true);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			if (transactionalContentCrc64 != null)
			{
				request.Headers.Add("x-ms-content-crc64", transactionalContentCrc64, "D");
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			request.Headers.Add("Accept", "application/xml");
			if (tags != null)
			{
				if (transactionalContentMD5 != null)
				{
					request.Headers.Add("Content-MD5", transactionalContentMD5, "D");
				}
				request.Headers.Add("Content-Type", "application/xml");
				Azure.Core.XmlWriterContent xmlWriterContent = new Azure.Core.XmlWriterContent();
				xmlWriterContent.XmlWriter.WriteObjectValue(tags, "Tags");
				request.Content = xmlWriterContent;
			}
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobSetTagsHeaders>> SetTagsAsync(int? timeout = null, string versionId = null, byte[] transactionalContentMD5 = null, byte[] transactionalContentCrc64 = null, string ifTags = null, string leaseId = null, BlobTags tags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateSetTagsRequest(timeout, versionId, transactionalContentMD5, transactionalContentCrc64, ifTags, leaseId, tags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlobSetTagsHeaders headers = new BlobSetTagsHeaders(message.Response);
			if (message.Response.Status == 204)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobSetTagsHeaders> SetTags(int? timeout = null, string versionId = null, byte[] transactionalContentMD5 = null, byte[] transactionalContentCrc64 = null, string ifTags = null, string leaseId = null, BlobTags tags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateSetTagsRequest(timeout, versionId, transactionalContentMD5, transactionalContentCrc64, ifTags, leaseId, tags);
			_pipeline.Send(httpMessage, cancellationToken);
			BlobSetTagsHeaders headers = new BlobSetTagsHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 204)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}
	}
	internal class BlobSetExpiryHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobSetExpiryHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobSetHttpHeadersHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public long? BlobSequenceNumber
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-sequence-number", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobSetHttpHeadersHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobSetImmutabilityPolicyHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public DateTimeOffset? ImmutabilityPolicyExpiry
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-immutability-policy-until-date", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobImmutabilityPolicyMode? ImmutabilityPolicyMode
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-immutability-policy-mode", out string value))
				{
					return null;
				}
				return value.ToBlobImmutabilityPolicyMode();
			}
		}

		public BlobSetImmutabilityPolicyHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobSetLegalHoldHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? LegalHold
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-legal-hold", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobSetLegalHoldHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobSetMetadataHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string VersionId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-request-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobSetMetadataHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobSetTagsHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobSetTagsHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobSetTierHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobSetTierHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobStartCopyFromURLHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string VersionId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopyId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public CopyStatus? CopyStatus
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-status", out string value))
				{
					return null;
				}
				return value.ToCopyStatus();
			}
		}

		public BlobStartCopyFromURLHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlobUndeleteHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlobUndeleteHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlockBlobCommitBlockListHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] XMsContentCrc64
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-content-crc64", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string VersionId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-request-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlockBlobCommitBlockListHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlockBlobGetBlockListHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string ContentType
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Type", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public long? BlobContentLength
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-content-length", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlockBlobGetBlockListHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlockBlobPutBlobFromUrlHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string VersionId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-request-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlockBlobPutBlobFromUrlHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlockBlobRestClient
	{
		private readonly HttpPipeline _pipeline;

		private readonly string _url;

		private readonly string _version;

		internal Azure.Core.Pipeline.ClientDiagnostics ClientDiagnostics { get; }

		public BlockBlobRestClient(Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version)
		{
			ClientDiagnostics = clientDiagnostics ?? throw new ArgumentNullException("clientDiagnostics");
			_pipeline = pipeline ?? throw new ArgumentNullException("pipeline");
			_url = url ?? throw new ArgumentNullException("url");
			_version = version ?? throw new ArgumentNullException("version");
		}

		internal HttpMessage CreateUploadRequest(long contentLength, Stream body, int? timeout, byte[] transactionalContentMD5, string blobContentType, string blobContentEncoding, string blobContentLanguage, byte[] blobContentMD5, string blobCacheControl, IDictionary<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope, AccessTier? tier, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, DateTimeOffset? immutabilityPolicyExpiry, BlobImmutabilityPolicyMode? immutabilityPolicyMode, bool? legalHold, byte[] transactionalContentCrc64)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-blob-type", "BlockBlob");
			if (blobContentType != null)
			{
				request.Headers.Add("x-ms-blob-content-type", blobContentType);
			}
			if (blobContentEncoding != null)
			{
				request.Headers.Add("x-ms-blob-content-encoding", blobContentEncoding);
			}
			if (blobContentLanguage != null)
			{
				request.Headers.Add("x-ms-blob-content-language", blobContentLanguage);
			}
			if (blobContentMD5 != null)
			{
				request.Headers.Add("x-ms-blob-content-md5", blobContentMD5, "D");
			}
			if (blobCacheControl != null)
			{
				request.Headers.Add("x-ms-blob-cache-control", blobCacheControl);
			}
			if (metadata != null)
			{
				request.Headers.Add("x-ms-meta-", metadata);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (blobContentDisposition != null)
			{
				request.Headers.Add("x-ms-blob-content-disposition", blobContentDisposition);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (tier.HasValue)
			{
				request.Headers.Add("x-ms-access-tier", tier.Value.ToString());
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			if (blobTagsString != null)
			{
				request.Headers.Add("x-ms-tags", blobTagsString);
			}
			if (immutabilityPolicyExpiry.HasValue)
			{
				request.Headers.Add("x-ms-immutability-policy-until-date", immutabilityPolicyExpiry.Value, "R");
			}
			if (immutabilityPolicyMode.HasValue)
			{
				request.Headers.Add("x-ms-immutability-policy-mode", immutabilityPolicyMode.Value.ToSerialString());
			}
			if (legalHold.HasValue)
			{
				request.Headers.Add("x-ms-legal-hold", legalHold.Value);
			}
			if (transactionalContentCrc64 != null)
			{
				request.Headers.Add("x-ms-content-crc64", transactionalContentCrc64, "D");
			}
			request.Headers.Add("Accept", "application/xml");
			if (transactionalContentMD5 != null)
			{
				request.Headers.Add("Content-MD5", transactionalContentMD5, "D");
			}
			request.Headers.Add("Content-Length", contentLength);
			request.Headers.Add("Content-Type", "application/octet-stream");
			request.Content = RequestContent.Create(body);
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlockBlobUploadHeaders>> UploadAsync(long contentLength, Stream body, int? timeout = null, byte[] transactionalContentMD5 = null, string blobContentType = null, string blobContentEncoding = null, string blobContentLanguage = null, byte[] blobContentMD5 = null, string blobCacheControl = null, IDictionary<string, string> metadata = null, string leaseId = null, string blobContentDisposition = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, AccessTier? tier = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string blobTagsString = null, DateTimeOffset? immutabilityPolicyExpiry = null, BlobImmutabilityPolicyMode? immutabilityPolicyMode = null, bool? legalHold = null, byte[] transactionalContentCrc64 = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			using HttpMessage message = CreateUploadRequest(contentLength, body, timeout, transactionalContentMD5, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD5, blobCacheControl, metadata, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, tier, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold, transactionalContentCrc64);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlockBlobUploadHeaders headers = new BlockBlobUploadHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlockBlobUploadHeaders> Upload(long contentLength, Stream body, int? timeout = null, byte[] transactionalContentMD5 = null, string blobContentType = null, string blobContentEncoding = null, string blobContentLanguage = null, byte[] blobContentMD5 = null, string blobCacheControl = null, IDictionary<string, string> metadata = null, string leaseId = null, string blobContentDisposition = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, AccessTier? tier = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string blobTagsString = null, DateTimeOffset? immutabilityPolicyExpiry = null, BlobImmutabilityPolicyMode? immutabilityPolicyMode = null, bool? legalHold = null, byte[] transactionalContentCrc64 = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			using HttpMessage httpMessage = CreateUploadRequest(contentLength, body, timeout, transactionalContentMD5, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD5, blobCacheControl, metadata, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, tier, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold, transactionalContentCrc64);
			_pipeline.Send(httpMessage, cancellationToken);
			BlockBlobUploadHeaders headers = new BlockBlobUploadHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreatePutBlobFromUrlRequest(long contentLength, string copySource, int? timeout, byte[] transactionalContentMD5, string blobContentType, string blobContentEncoding, string blobContentLanguage, byte[] blobContentMD5, string blobCacheControl, IDictionary<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope, AccessTier? tier, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, DateTimeOffset? sourceIfModifiedSince, DateTimeOffset? sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string sourceIfTags, byte[] sourceContentMD5, string blobTagsString, bool? copySourceBlobProperties, string copySourceAuthorization, BlobCopySourceTagsMode? copySourceTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-blob-type", "BlockBlob");
			if (blobContentType != null)
			{
				request.Headers.Add("x-ms-blob-content-type", blobContentType);
			}
			if (blobContentEncoding != null)
			{
				request.Headers.Add("x-ms-blob-content-encoding", blobContentEncoding);
			}
			if (blobContentLanguage != null)
			{
				request.Headers.Add("x-ms-blob-content-language", blobContentLanguage);
			}
			if (blobContentMD5 != null)
			{
				request.Headers.Add("x-ms-blob-content-md5", blobContentMD5, "D");
			}
			if (blobCacheControl != null)
			{
				request.Headers.Add("x-ms-blob-cache-control", blobCacheControl);
			}
			if (metadata != null)
			{
				request.Headers.Add("x-ms-meta-", metadata);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (blobContentDisposition != null)
			{
				request.Headers.Add("x-ms-blob-content-disposition", blobContentDisposition);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (tier.HasValue)
			{
				request.Headers.Add("x-ms-access-tier", tier.Value.ToString());
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			if (sourceIfModifiedSince.HasValue)
			{
				request.Headers.Add("x-ms-source-if-modified-since", sourceIfModifiedSince.Value, "R");
			}
			if (sourceIfUnmodifiedSince.HasValue)
			{
				request.Headers.Add("x-ms-source-if-unmodified-since", sourceIfUnmodifiedSince.Value, "R");
			}
			if (sourceIfMatch != null)
			{
				request.Headers.Add("x-ms-source-if-match", sourceIfMatch);
			}
			if (sourceIfNoneMatch != null)
			{
				request.Headers.Add("x-ms-source-if-none-match", sourceIfNoneMatch);
			}
			if (sourceIfTags != null)
			{
				request.Headers.Add("x-ms-source-if-tags", sourceIfTags);
			}
			request.Headers.Add("x-ms-version", _version);
			if (sourceContentMD5 != null)
			{
				request.Headers.Add("x-ms-source-content-md5", sourceContentMD5, "D");
			}
			if (blobTagsString != null)
			{
				request.Headers.Add("x-ms-tags", blobTagsString);
			}
			request.Headers.Add("x-ms-copy-source", copySource);
			if (copySourceBlobProperties.HasValue)
			{
				request.Headers.Add("x-ms-copy-source-blob-properties", copySourceBlobProperties.Value);
			}
			if (copySourceAuthorization != null)
			{
				request.Headers.Add("x-ms-copy-source-authorization", copySourceAuthorization);
			}
			if (copySourceTags.HasValue)
			{
				request.Headers.Add("x-ms-copy-source-tag-option", copySourceTags.Value.ToSerialString());
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlockBlobPutBlobFromUrlHeaders>> PutBlobFromUrlAsync(long contentLength, string copySource, int? timeout = null, byte[] transactionalContentMD5 = null, string blobContentType = null, string blobContentEncoding = null, string blobContentLanguage = null, byte[] blobContentMD5 = null, string blobCacheControl = null, IDictionary<string, string> metadata = null, string leaseId = null, string blobContentDisposition = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, AccessTier? tier = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, DateTimeOffset? sourceIfModifiedSince = null, DateTimeOffset? sourceIfUnmodifiedSince = null, string sourceIfMatch = null, string sourceIfNoneMatch = null, string sourceIfTags = null, byte[] sourceContentMD5 = null, string blobTagsString = null, bool? copySourceBlobProperties = null, string copySourceAuthorization = null, BlobCopySourceTagsMode? copySourceTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (copySource == null)
			{
				throw new ArgumentNullException("copySource");
			}
			using HttpMessage message = CreatePutBlobFromUrlRequest(contentLength, copySource, timeout, transactionalContentMD5, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD5, blobCacheControl, metadata, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, tier, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, sourceIfTags, sourceContentMD5, blobTagsString, copySourceBlobProperties, copySourceAuthorization, copySourceTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlockBlobPutBlobFromUrlHeaders headers = new BlockBlobPutBlobFromUrlHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlockBlobPutBlobFromUrlHeaders> PutBlobFromUrl(long contentLength, string copySource, int? timeout = null, byte[] transactionalContentMD5 = null, string blobContentType = null, string blobContentEncoding = null, string blobContentLanguage = null, byte[] blobContentMD5 = null, string blobCacheControl = null, IDictionary<string, string> metadata = null, string leaseId = null, string blobContentDisposition = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, AccessTier? tier = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, DateTimeOffset? sourceIfModifiedSince = null, DateTimeOffset? sourceIfUnmodifiedSince = null, string sourceIfMatch = null, string sourceIfNoneMatch = null, string sourceIfTags = null, byte[] sourceContentMD5 = null, string blobTagsString = null, bool? copySourceBlobProperties = null, string copySourceAuthorization = null, BlobCopySourceTagsMode? copySourceTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (copySource == null)
			{
				throw new ArgumentNullException("copySource");
			}
			using HttpMessage httpMessage = CreatePutBlobFromUrlRequest(contentLength, copySource, timeout, transactionalContentMD5, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD5, blobCacheControl, metadata, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, tier, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, sourceIfTags, sourceContentMD5, blobTagsString, copySourceBlobProperties, copySourceAuthorization, copySourceTags);
			_pipeline.Send(httpMessage, cancellationToken);
			BlockBlobPutBlobFromUrlHeaders headers = new BlockBlobPutBlobFromUrlHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateStageBlockRequest(string blockId, long contentLength, Stream body, byte[] transactionalContentMD5, byte[] transactionalContentCrc64, int? timeout, string leaseId, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "block", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("blockid", blockId, escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (transactionalContentCrc64 != null)
			{
				request.Headers.Add("x-ms-content-crc64", transactionalContentCrc64, "D");
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			request.Headers.Add("Content-Length", contentLength);
			if (transactionalContentMD5 != null)
			{
				request.Headers.Add("Content-MD5", transactionalContentMD5, "D");
			}
			request.Headers.Add("Content-Type", "application/octet-stream");
			request.Content = RequestContent.Create(body);
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlockBlobStageBlockHeaders>> StageBlockAsync(string blockId, long contentLength, Stream body, byte[] transactionalContentMD5 = null, byte[] transactionalContentCrc64 = null, int? timeout = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (blockId == null)
			{
				throw new ArgumentNullException("blockId");
			}
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			using HttpMessage message = CreateStageBlockRequest(blockId, contentLength, body, transactionalContentMD5, transactionalContentCrc64, timeout, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlockBlobStageBlockHeaders headers = new BlockBlobStageBlockHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlockBlobStageBlockHeaders> StageBlock(string blockId, long contentLength, Stream body, byte[] transactionalContentMD5 = null, byte[] transactionalContentCrc64 = null, int? timeout = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (blockId == null)
			{
				throw new ArgumentNullException("blockId");
			}
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			using HttpMessage httpMessage = CreateStageBlockRequest(blockId, contentLength, body, transactionalContentMD5, transactionalContentCrc64, timeout, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope);
			_pipeline.Send(httpMessage, cancellationToken);
			BlockBlobStageBlockHeaders headers = new BlockBlobStageBlockHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateStageBlockFromURLRequest(string blockId, long contentLength, string sourceUrl, string sourceRange, byte[] sourceContentMD5, byte[] sourceContentcrc64, int? timeout, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope, string leaseId, DateTimeOffset? sourceIfModifiedSince, DateTimeOffset? sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "block", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("blockid", blockId, escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-copy-source", sourceUrl);
			if (sourceRange != null)
			{
				request.Headers.Add("x-ms-source-range", sourceRange);
			}
			if (sourceContentMD5 != null)
			{
				request.Headers.Add("x-ms-source-content-md5", sourceContentMD5, "D");
			}
			if (sourceContentcrc64 != null)
			{
				request.Headers.Add("x-ms-source-content-crc64", sourceContentcrc64, "D");
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (sourceIfModifiedSince.HasValue)
			{
				request.Headers.Add("x-ms-source-if-modified-since", sourceIfModifiedSince.Value, "R");
			}
			if (sourceIfUnmodifiedSince.HasValue)
			{
				request.Headers.Add("x-ms-source-if-unmodified-since", sourceIfUnmodifiedSince.Value, "R");
			}
			if (sourceIfMatch != null)
			{
				request.Headers.Add("x-ms-source-if-match", sourceIfMatch);
			}
			if (sourceIfNoneMatch != null)
			{
				request.Headers.Add("x-ms-source-if-none-match", sourceIfNoneMatch);
			}
			request.Headers.Add("x-ms-version", _version);
			if (copySourceAuthorization != null)
			{
				request.Headers.Add("x-ms-copy-source-authorization", copySourceAuthorization);
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlockBlobStageBlockFromURLHeaders>> StageBlockFromURLAsync(string blockId, long contentLength, string sourceUrl, string sourceRange = null, byte[] sourceContentMD5 = null, byte[] sourceContentcrc64 = null, int? timeout = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, string leaseId = null, DateTimeOffset? sourceIfModifiedSince = null, DateTimeOffset? sourceIfUnmodifiedSince = null, string sourceIfMatch = null, string sourceIfNoneMatch = null, string copySourceAuthorization = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (blockId == null)
			{
				throw new ArgumentNullException("blockId");
			}
			if (sourceUrl == null)
			{
				throw new ArgumentNullException("sourceUrl");
			}
			using HttpMessage message = CreateStageBlockFromURLRequest(blockId, contentLength, sourceUrl, sourceRange, sourceContentMD5, sourceContentcrc64, timeout, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, leaseId, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, copySourceAuthorization);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlockBlobStageBlockFromURLHeaders headers = new BlockBlobStageBlockFromURLHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlockBlobStageBlockFromURLHeaders> StageBlockFromURL(string blockId, long contentLength, string sourceUrl, string sourceRange = null, byte[] sourceContentMD5 = null, byte[] sourceContentcrc64 = null, int? timeout = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, string leaseId = null, DateTimeOffset? sourceIfModifiedSince = null, DateTimeOffset? sourceIfUnmodifiedSince = null, string sourceIfMatch = null, string sourceIfNoneMatch = null, string copySourceAuthorization = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (blockId == null)
			{
				throw new ArgumentNullException("blockId");
			}
			if (sourceUrl == null)
			{
				throw new ArgumentNullException("sourceUrl");
			}
			using HttpMessage httpMessage = CreateStageBlockFromURLRequest(blockId, contentLength, sourceUrl, sourceRange, sourceContentMD5, sourceContentcrc64, timeout, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, leaseId, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, copySourceAuthorization);
			_pipeline.Send(httpMessage, cancellationToken);
			BlockBlobStageBlockFromURLHeaders headers = new BlockBlobStageBlockFromURLHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateCommitBlockListRequest(BlockLookupList blocks, int? timeout, string blobCacheControl, string blobContentType, string blobContentEncoding, string blobContentLanguage, byte[] blobContentMD5, byte[] transactionalContentMD5, byte[] transactionalContentCrc64, IDictionary<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope, AccessTier? tier, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string blobTagsString, DateTimeOffset? immutabilityPolicyExpiry, BlobImmutabilityPolicyMode? immutabilityPolicyMode, bool? legalHold)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "blocklist", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (blobCacheControl != null)
			{
				request.Headers.Add("x-ms-blob-cache-control", blobCacheControl);
			}
			if (blobContentType != null)
			{
				request.Headers.Add("x-ms-blob-content-type", blobContentType);
			}
			if (blobContentEncoding != null)
			{
				request.Headers.Add("x-ms-blob-content-encoding", blobContentEncoding);
			}
			if (blobContentLanguage != null)
			{
				request.Headers.Add("x-ms-blob-content-language", blobContentLanguage);
			}
			if (blobContentMD5 != null)
			{
				request.Headers.Add("x-ms-blob-content-md5", blobContentMD5, "D");
			}
			if (transactionalContentCrc64 != null)
			{
				request.Headers.Add("x-ms-content-crc64", transactionalContentCrc64, "D");
			}
			if (metadata != null)
			{
				request.Headers.Add("x-ms-meta-", metadata);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (blobContentDisposition != null)
			{
				request.Headers.Add("x-ms-blob-content-disposition", blobContentDisposition);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (tier.HasValue)
			{
				request.Headers.Add("x-ms-access-tier", tier.Value.ToString());
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			if (blobTagsString != null)
			{
				request.Headers.Add("x-ms-tags", blobTagsString);
			}
			if (immutabilityPolicyExpiry.HasValue)
			{
				request.Headers.Add("x-ms-immutability-policy-until-date", immutabilityPolicyExpiry.Value, "R");
			}
			if (immutabilityPolicyMode.HasValue)
			{
				request.Headers.Add("x-ms-immutability-policy-mode", immutabilityPolicyMode.Value.ToSerialString());
			}
			if (legalHold.HasValue)
			{
				request.Headers.Add("x-ms-legal-hold", legalHold.Value);
			}
			request.Headers.Add("Accept", "application/xml");
			if (transactionalContentMD5 != null)
			{
				request.Headers.Add("Content-MD5", transactionalContentMD5, "D");
			}
			request.Headers.Add("Content-Type", "application/xml");
			Azure.Core.XmlWriterContent xmlWriterContent = new Azure.Core.XmlWriterContent();
			xmlWriterContent.XmlWriter.WriteObjectValue(blocks, "BlockList");
			request.Content = xmlWriterContent;
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlockBlobCommitBlockListHeaders>> CommitBlockListAsync(BlockLookupList blocks, int? timeout = null, string blobCacheControl = null, string blobContentType = null, string blobContentEncoding = null, string blobContentLanguage = null, byte[] blobContentMD5 = null, byte[] transactionalContentMD5 = null, byte[] transactionalContentCrc64 = null, IDictionary<string, string> metadata = null, string leaseId = null, string blobContentDisposition = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, AccessTier? tier = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string blobTagsString = null, DateTimeOffset? immutabilityPolicyExpiry = null, BlobImmutabilityPolicyMode? immutabilityPolicyMode = null, bool? legalHold = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (blocks == null)
			{
				throw new ArgumentNullException("blocks");
			}
			using HttpMessage message = CreateCommitBlockListRequest(blocks, timeout, blobCacheControl, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD5, transactionalContentMD5, transactionalContentCrc64, metadata, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, tier, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlockBlobCommitBlockListHeaders headers = new BlockBlobCommitBlockListHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlockBlobCommitBlockListHeaders> CommitBlockList(BlockLookupList blocks, int? timeout = null, string blobCacheControl = null, string blobContentType = null, string blobContentEncoding = null, string blobContentLanguage = null, byte[] blobContentMD5 = null, byte[] transactionalContentMD5 = null, byte[] transactionalContentCrc64 = null, IDictionary<string, string> metadata = null, string leaseId = null, string blobContentDisposition = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, AccessTier? tier = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string blobTagsString = null, DateTimeOffset? immutabilityPolicyExpiry = null, BlobImmutabilityPolicyMode? immutabilityPolicyMode = null, bool? legalHold = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (blocks == null)
			{
				throw new ArgumentNullException("blocks");
			}
			using HttpMessage httpMessage = CreateCommitBlockListRequest(blocks, timeout, blobCacheControl, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD5, transactionalContentMD5, transactionalContentCrc64, metadata, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, tier, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold);
			_pipeline.Send(httpMessage, cancellationToken);
			BlockBlobCommitBlockListHeaders headers = new BlockBlobCommitBlockListHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateGetBlockListRequest(BlockListType listType, string snapshot, int? timeout, string leaseId, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "blocklist", escapeValue: true);
			if (snapshot != null)
			{
				rawRequestUriBuilder.AppendQuery("snapshot", snapshot, escapeValue: true);
			}
			rawRequestUriBuilder.AppendQuery("blocklisttype", listType.ToSerialString(), escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlockList, BlockBlobGetBlockListHeaders>> GetBlockListAsync(BlockListType listType, string snapshot = null, int? timeout = null, string leaseId = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateGetBlockListRequest(listType, snapshot, timeout, leaseId, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			BlockBlobGetBlockListHeaders headers = new BlockBlobGetBlockListHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				BlockList value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("BlockList");
				if (xElement != null)
				{
					value = BlockList.DeserializeBlockList(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlockList, BlockBlobGetBlockListHeaders> GetBlockList(BlockListType listType, string snapshot = null, int? timeout = null, string leaseId = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateGetBlockListRequest(listType, snapshot, timeout, leaseId, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			BlockBlobGetBlockListHeaders headers = new BlockBlobGetBlockListHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				BlockList value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("BlockList");
				if (xElement != null)
				{
					value = BlockList.DeserializeBlockList(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}
	}
	internal class BlockBlobStageBlockFromURLHeaders
	{
		private readonly Response _response;

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] XMsContentCrc64
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-content-crc64", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-request-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlockBlobStageBlockFromURLHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlockBlobStageBlockHeaders
	{
		private readonly Response _response;

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] XMsContentCrc64
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-content-crc64", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-request-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlockBlobStageBlockHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class BlockBlobUploadHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string VersionId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-request-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public BlockBlobUploadHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerAcquireLeaseHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string LeaseId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerAcquireLeaseHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerBreakLeaseHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public int? LeaseTime
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-time", out int? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerBreakLeaseHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerChangeLeaseHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string LeaseId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerChangeLeaseHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerCreateHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerCreateHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerDeleteHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerDeleteHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerFilterBlobsHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerFilterBlobsHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerGetAccessPolicyHeaders
	{
		private readonly Response _response;

		public PublicAccessType? BlobPublicAccess
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-public-access", out string value))
				{
					return null;
				}
				return value.ToPublicAccessType();
			}
		}

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerGetAccessPolicyHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerGetPropertiesHeaders
	{
		private readonly Response _response;

		public IDictionary<string, string> Metadata
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-meta-", out IDictionary<string, string> value))
				{
					return null;
				}
				return value;
			}
		}

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public LeaseDurationType? LeaseDuration
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-duration", out string value))
				{
					return null;
				}
				return value.ToLeaseDurationType();
			}
		}

		public LeaseState? LeaseState
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-state", out string value))
				{
					return null;
				}
				return value.ToLeaseState();
			}
		}

		public LeaseStatus? LeaseStatus
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-status", out string value))
				{
					return null;
				}
				return value.ToLeaseStatus();
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public PublicAccessType? BlobPublicAccess
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-public-access", out string value))
				{
					return null;
				}
				return value.ToPublicAccessType();
			}
		}

		public bool? HasImmutabilityPolicy
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-has-immutability-policy", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? HasLegalHold
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-has-legal-hold", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string DefaultEncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-default-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? DenyEncryptionScopeOverride
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-deny-encryption-scope-override", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsImmutableStorageWithVersioningEnabled
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-immutable-storage-with-versioning-enabled", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerGetPropertiesHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerListBlobFlatSegmentHeaders
	{
		private readonly Response _response;

		public string ContentType
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Type", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerListBlobFlatSegmentHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerListBlobHierarchySegmentHeaders
	{
		private readonly Response _response;

		public string ContentType
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Type", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerListBlobHierarchySegmentHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerReleaseLeaseHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerReleaseLeaseHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerRenameHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerRenameHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerRenewLeaseHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string LeaseId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-lease-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerRenewLeaseHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerRestClient
	{
		private readonly HttpPipeline _pipeline;

		private readonly string _url;

		private readonly string _version;

		private static ResponseClassifier _responseClassifier201;

		internal Azure.Core.Pipeline.ClientDiagnostics ClientDiagnostics { get; }

		private static ResponseClassifier ResponseClassifier201
		{
			get
			{
				ResponseClassifier responseClassifier = _responseClassifier201;
				if (responseClassifier == null)
				{
					responseClassifier = (_responseClassifier201 = new StatusCodeClassifier(stackalloc ushort[1] { 201 }));
				}
				return responseClassifier;
			}
		}

		public ContainerRestClient(Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version)
		{
			ClientDiagnostics = clientDiagnostics ?? throw new ArgumentNullException("clientDiagnostics");
			_pipeline = pipeline ?? throw new ArgumentNullException("pipeline");
			_url = url ?? throw new ArgumentNullException("url");
			_version = version ?? throw new ArgumentNullException("version");
		}

		internal HttpMessage CreateCreateRequest(int? timeout, IDictionary<string, string> metadata, PublicAccessType? access, string defaultEncryptionScope, bool? preventEncryptionScopeOverride)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (metadata != null)
			{
				request.Headers.Add("x-ms-meta-", metadata);
			}
			if (access.HasValue)
			{
				request.Headers.Add("x-ms-blob-public-access", access.Value.ToSerialString());
			}
			request.Headers.Add("x-ms-version", _version);
			if (defaultEncryptionScope != null)
			{
				request.Headers.Add("x-ms-default-encryption-scope", defaultEncryptionScope);
			}
			if (preventEncryptionScopeOverride.HasValue)
			{
				request.Headers.Add("x-ms-deny-encryption-scope-override", preventEncryptionScopeOverride.Value);
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ContainerCreateHeaders>> CreateAsync(int? timeout = null, IDictionary<string, string> metadata = null, PublicAccessType? access = null, string defaultEncryptionScope = null, bool? preventEncryptionScopeOverride = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateCreateRequest(timeout, metadata, access, defaultEncryptionScope, preventEncryptionScopeOverride);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerCreateHeaders headers = new ContainerCreateHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ContainerCreateHeaders> Create(int? timeout = null, IDictionary<string, string> metadata = null, PublicAccessType? access = null, string defaultEncryptionScope = null, bool? preventEncryptionScopeOverride = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateCreateRequest(timeout, metadata, access, defaultEncryptionScope, preventEncryptionScopeOverride);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerCreateHeaders headers = new ContainerCreateHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateGetPropertiesRequest(int? timeout, string leaseId)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ContainerGetPropertiesHeaders>> GetPropertiesAsync(int? timeout = null, string leaseId = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateGetPropertiesRequest(timeout, leaseId);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerGetPropertiesHeaders headers = new ContainerGetPropertiesHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ContainerGetPropertiesHeaders> GetProperties(int? timeout = null, string leaseId = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateGetPropertiesRequest(timeout, leaseId);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerGetPropertiesHeaders headers = new ContainerGetPropertiesHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateDeleteRequest(int? timeout, string leaseId, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Delete;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ContainerDeleteHeaders>> DeleteAsync(int? timeout = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateDeleteRequest(timeout, leaseId, ifModifiedSince, ifUnmodifiedSince);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerDeleteHeaders headers = new ContainerDeleteHeaders(message.Response);
			if (message.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ContainerDeleteHeaders> Delete(int? timeout = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateDeleteRequest(timeout, leaseId, ifModifiedSince, ifUnmodifiedSince);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerDeleteHeaders headers = new ContainerDeleteHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateSetMetadataRequest(int? timeout, string leaseId, IDictionary<string, string> metadata, DateTimeOffset? ifModifiedSince)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("comp", "metadata", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (metadata != null)
			{
				request.Headers.Add("x-ms-meta-", metadata);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ContainerSetMetadataHeaders>> SetMetadataAsync(int? timeout = null, string leaseId = null, IDictionary<string, string> metadata = null, DateTimeOffset? ifModifiedSince = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateSetMetadataRequest(timeout, leaseId, metadata, ifModifiedSince);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerSetMetadataHeaders headers = new ContainerSetMetadataHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ContainerSetMetadataHeaders> SetMetadata(int? timeout = null, string leaseId = null, IDictionary<string, string> metadata = null, DateTimeOffset? ifModifiedSince = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateSetMetadataRequest(timeout, leaseId, metadata, ifModifiedSince);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerSetMetadataHeaders headers = new ContainerSetMetadataHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateGetAccessPolicyRequest(int? timeout, string leaseId)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("comp", "acl", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<IReadOnlyList<BlobSignedIdentifier>, ContainerGetAccessPolicyHeaders>> GetAccessPolicyAsync(int? timeout = null, string leaseId = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateGetAccessPolicyRequest(timeout, leaseId);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerGetAccessPolicyHeaders headers = new ContainerGetAccessPolicyHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				IReadOnlyList<BlobSignedIdentifier> value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("SignedIdentifiers");
				if (xElement != null)
				{
					List<BlobSignedIdentifier> list = new List<BlobSignedIdentifier>();
					foreach (XElement item in xElement.Elements("SignedIdentifier"))
					{
						list.Add(BlobSignedIdentifier.DeserializeBlobSignedIdentifier(item));
					}
					value = list;
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<IReadOnlyList<BlobSignedIdentifier>, ContainerGetAccessPolicyHeaders> GetAccessPolicy(int? timeout = null, string leaseId = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateGetAccessPolicyRequest(timeout, leaseId);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerGetAccessPolicyHeaders headers = new ContainerGetAccessPolicyHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				IReadOnlyList<BlobSignedIdentifier> value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("SignedIdentifiers");
				if (xElement != null)
				{
					List<BlobSignedIdentifier> list = new List<BlobSignedIdentifier>();
					foreach (XElement item in xElement.Elements("SignedIdentifier"))
					{
						list.Add(BlobSignedIdentifier.DeserializeBlobSignedIdentifier(item));
					}
					value = list;
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateSetAccessPolicyRequest(int? timeout, string leaseId, PublicAccessType? access, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, IEnumerable<BlobSignedIdentifier> containerAcl)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("comp", "acl", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (access.HasValue)
			{
				request.Headers.Add("x-ms-blob-public-access", access.Value.ToSerialString());
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			if (containerAcl != null)
			{
				request.Headers.Add("Content-Type", "application/xml");
				Azure.Core.XmlWriterContent xmlWriterContent = new Azure.Core.XmlWriterContent();
				xmlWriterContent.XmlWriter.WriteStartElement("SignedIdentifiers");
				foreach (BlobSignedIdentifier item in containerAcl)
				{
					xmlWriterContent.XmlWriter.WriteObjectValue(item, "SignedIdentifier");
				}
				xmlWriterContent.XmlWriter.WriteEndElement();
				request.Content = xmlWriterContent;
			}
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ContainerSetAccessPolicyHeaders>> SetAccessPolicyAsync(int? timeout = null, string leaseId = null, PublicAccessType? access = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, IEnumerable<BlobSignedIdentifier> containerAcl = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateSetAccessPolicyRequest(timeout, leaseId, access, ifModifiedSince, ifUnmodifiedSince, containerAcl);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerSetAccessPolicyHeaders headers = new ContainerSetAccessPolicyHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ContainerSetAccessPolicyHeaders> SetAccessPolicy(int? timeout = null, string leaseId = null, PublicAccessType? access = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, IEnumerable<BlobSignedIdentifier> containerAcl = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateSetAccessPolicyRequest(timeout, leaseId, access, ifModifiedSince, ifUnmodifiedSince, containerAcl);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerSetAccessPolicyHeaders headers = new ContainerSetAccessPolicyHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateRestoreRequest(int? timeout, string deletedContainerName, string deletedContainerVersion)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("comp", "undelete", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			if (deletedContainerName != null)
			{
				request.Headers.Add("x-ms-deleted-container-name", deletedContainerName);
			}
			if (deletedContainerVersion != null)
			{
				request.Headers.Add("x-ms-deleted-container-version", deletedContainerVersion);
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ContainerRestoreHeaders>> RestoreAsync(int? timeout = null, string deletedContainerName = null, string deletedContainerVersion = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateRestoreRequest(timeout, deletedContainerName, deletedContainerVersion);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerRestoreHeaders headers = new ContainerRestoreHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ContainerRestoreHeaders> Restore(int? timeout = null, string deletedContainerName = null, string deletedContainerVersion = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateRestoreRequest(timeout, deletedContainerName, deletedContainerVersion);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerRestoreHeaders headers = new ContainerRestoreHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateRenameRequest(string sourceContainerName, int? timeout, string sourceLeaseId)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("comp", "rename", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("x-ms-source-container-name", sourceContainerName);
			if (sourceLeaseId != null)
			{
				request.Headers.Add("x-ms-source-lease-id", sourceLeaseId);
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ContainerRenameHeaders>> RenameAsync(string sourceContainerName, int? timeout = null, string sourceLeaseId = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (sourceContainerName == null)
			{
				throw new ArgumentNullException("sourceContainerName");
			}
			using HttpMessage message = CreateRenameRequest(sourceContainerName, timeout, sourceLeaseId);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerRenameHeaders headers = new ContainerRenameHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ContainerRenameHeaders> Rename(string sourceContainerName, int? timeout = null, string sourceLeaseId = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (sourceContainerName == null)
			{
				throw new ArgumentNullException("sourceContainerName");
			}
			using HttpMessage httpMessage = CreateRenameRequest(sourceContainerName, timeout, sourceLeaseId);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerRenameHeaders headers = new ContainerRenameHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateSubmitBatchRequest(long contentLength, string multipartContentType, Stream body, int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Post;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("comp", "batch", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			request.Headers.Add("Content-Length", contentLength);
			request.Headers.Add("Content-Type", multipartContentType);
			request.Content = RequestContent.Create(body);
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<Stream, ContainerSubmitBatchHeaders>> SubmitBatchAsync(long contentLength, string multipartContentType, Stream body, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (multipartContentType == null)
			{
				throw new ArgumentNullException("multipartContentType");
			}
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			using HttpMessage message = CreateSubmitBatchRequest(contentLength, multipartContentType, body, timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerSubmitBatchHeaders headers = new ContainerSubmitBatchHeaders(message.Response);
			if (message.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(message.ExtractResponseContent(), headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<Stream, ContainerSubmitBatchHeaders> SubmitBatch(long contentLength, string multipartContentType, Stream body, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (multipartContentType == null)
			{
				throw new ArgumentNullException("multipartContentType");
			}
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			using HttpMessage httpMessage = CreateSubmitBatchRequest(contentLength, multipartContentType, body, timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerSubmitBatchHeaders headers = new ContainerSubmitBatchHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(httpMessage.ExtractResponseContent(), headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateFilterBlobsRequest(int? timeout, string where, string marker, int? maxresults, IEnumerable<FilterBlobsIncludeItem> include)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("comp", "blobs", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			if (where != null)
			{
				rawRequestUriBuilder.AppendQuery("where", where, escapeValue: true);
			}
			if (marker != null)
			{
				rawRequestUriBuilder.AppendQuery("marker", marker, escapeValue: true);
			}
			if (maxresults.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("maxresults", maxresults.Value);
			}
			if (include != null && Azure.Core.Optional.IsCollectionDefined(include))
			{
				rawRequestUriBuilder.AppendQueryDelimited("include", include, ",");
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<FilterBlobSegment, ContainerFilterBlobsHeaders>> FilterBlobsAsync(int? timeout = null, string where = null, string marker = null, int? maxresults = null, IEnumerable<FilterBlobsIncludeItem> include = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateFilterBlobsRequest(timeout, where, marker, maxresults, include);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerFilterBlobsHeaders headers = new ContainerFilterBlobsHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				FilterBlobSegment value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = FilterBlobSegment.DeserializeFilterBlobSegment(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<FilterBlobSegment, ContainerFilterBlobsHeaders> FilterBlobs(int? timeout = null, string where = null, string marker = null, int? maxresults = null, IEnumerable<FilterBlobsIncludeItem> include = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateFilterBlobsRequest(timeout, where, marker, maxresults, include);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerFilterBlobsHeaders headers = new ContainerFilterBlobsHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				FilterBlobSegment value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = FilterBlobSegment.DeserializeFilterBlobSegment(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateAcquireLeaseRequest(int? timeout, long? duration, string proposedLeaseId, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "lease", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-lease-action", "acquire");
			if (duration.HasValue)
			{
				request.Headers.Add("x-ms-lease-duration", duration.Value);
			}
			if (proposedLeaseId != null)
			{
				request.Headers.Add("x-ms-proposed-lease-id", proposedLeaseId);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ContainerAcquireLeaseHeaders>> AcquireLeaseAsync(int? timeout = null, long? duration = null, string proposedLeaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateAcquireLeaseRequest(timeout, duration, proposedLeaseId, ifModifiedSince, ifUnmodifiedSince);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerAcquireLeaseHeaders headers = new ContainerAcquireLeaseHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ContainerAcquireLeaseHeaders> AcquireLease(int? timeout = null, long? duration = null, string proposedLeaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateAcquireLeaseRequest(timeout, duration, proposedLeaseId, ifModifiedSince, ifUnmodifiedSince);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerAcquireLeaseHeaders headers = new ContainerAcquireLeaseHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateAcquireLeaseRequest(int? timeout, long? duration, string proposedLeaseId, RequestConditions requestConditions, RequestContext context)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage(context, ResponseClassifier201);
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "lease", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-lease-action", "acquire");
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			if (duration.HasValue)
			{
				request.Headers.Add("x-ms-lease-duration", duration.Value);
			}
			if (proposedLeaseId != null)
			{
				request.Headers.Add("x-ms-proposed-lease-id", proposedLeaseId);
			}
			if (requestConditions != null)
			{
				request.Headers.Add(requestConditions, "R");
			}
			return httpMessage;
		}

		public virtual async Task<Response> AcquireLeaseAsync(int? timeout = null, long? duration = null, string proposedLeaseId = null, RequestConditions requestConditions = null, RequestContext context = null)
		{
			Azure.Core.Argument.AssertNull(requestConditions.IfMatch, "requestConditions", "Service does not support the If-Match header for this operation.");
			Azure.Core.Argument.AssertNull(requestConditions.IfNoneMatch, "requestConditions", "Service does not support the If-None-Match header for this operation.");
			using Azure.Core.Pipeline.DiagnosticScope scope = ClientDiagnostics.CreateScope("Container.AcquireLease");
			scope.Start();
			try
			{
				using HttpMessage message = CreateAcquireLeaseRequest(timeout, duration, proposedLeaseId, requestConditions, context);
				return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(continueOnCapturedContext: false);
			}
			catch (Exception exception)
			{
				scope.Failed(exception);
				throw;
			}
		}

		public virtual Response AcquireLease(int? timeout = null, long? duration = null, string proposedLeaseId = null, RequestConditions requestConditions = null, RequestContext context = null)
		{
			Azure.Core.Argument.AssertNull(requestConditions.IfMatch, "requestConditions", "Service does not support the If-Match header for this operation.");
			Azure.Core.Argument.AssertNull(requestConditions.IfNoneMatch, "requestConditions", "Service does not support the If-None-Match header for this operation.");
			using Azure.Core.Pipeline.DiagnosticScope diagnosticScope = ClientDiagnostics.CreateScope("Container.AcquireLease");
			diagnosticScope.Start();
			try
			{
				using HttpMessage message = CreateAcquireLeaseRequest(timeout, duration, proposedLeaseId, requestConditions, context);
				return _pipeline.ProcessMessage(message, context);
			}
			catch (Exception exception)
			{
				diagnosticScope.Failed(exception);
				throw;
			}
		}

		internal HttpMessage CreateReleaseLeaseRequest(string leaseId, int? timeout, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "lease", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-lease-action", "release");
			request.Headers.Add("x-ms-lease-id", leaseId);
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ContainerReleaseLeaseHeaders>> ReleaseLeaseAsync(string leaseId, int? timeout = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (leaseId == null)
			{
				throw new ArgumentNullException("leaseId");
			}
			using HttpMessage message = CreateReleaseLeaseRequest(leaseId, timeout, ifModifiedSince, ifUnmodifiedSince);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerReleaseLeaseHeaders headers = new ContainerReleaseLeaseHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ContainerReleaseLeaseHeaders> ReleaseLease(string leaseId, int? timeout = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (leaseId == null)
			{
				throw new ArgumentNullException("leaseId");
			}
			using HttpMessage httpMessage = CreateReleaseLeaseRequest(leaseId, timeout, ifModifiedSince, ifUnmodifiedSince);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerReleaseLeaseHeaders headers = new ContainerReleaseLeaseHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateRenewLeaseRequest(string leaseId, int? timeout, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "lease", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-lease-action", "renew");
			request.Headers.Add("x-ms-lease-id", leaseId);
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ContainerRenewLeaseHeaders>> RenewLeaseAsync(string leaseId, int? timeout = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (leaseId == null)
			{
				throw new ArgumentNullException("leaseId");
			}
			using HttpMessage message = CreateRenewLeaseRequest(leaseId, timeout, ifModifiedSince, ifUnmodifiedSince);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerRenewLeaseHeaders headers = new ContainerRenewLeaseHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ContainerRenewLeaseHeaders> RenewLease(string leaseId, int? timeout = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (leaseId == null)
			{
				throw new ArgumentNullException("leaseId");
			}
			using HttpMessage httpMessage = CreateRenewLeaseRequest(leaseId, timeout, ifModifiedSince, ifUnmodifiedSince);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerRenewLeaseHeaders headers = new ContainerRenewLeaseHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateBreakLeaseRequest(int? timeout, long? breakPeriod, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "lease", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-lease-action", "break");
			if (breakPeriod.HasValue)
			{
				request.Headers.Add("x-ms-lease-break-period", breakPeriod.Value);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ContainerBreakLeaseHeaders>> BreakLeaseAsync(int? timeout = null, long? breakPeriod = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateBreakLeaseRequest(timeout, breakPeriod, ifModifiedSince, ifUnmodifiedSince);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerBreakLeaseHeaders headers = new ContainerBreakLeaseHeaders(message.Response);
			if (message.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ContainerBreakLeaseHeaders> BreakLease(int? timeout = null, long? breakPeriod = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateBreakLeaseRequest(timeout, breakPeriod, ifModifiedSince, ifUnmodifiedSince);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerBreakLeaseHeaders headers = new ContainerBreakLeaseHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateChangeLeaseRequest(string leaseId, string proposedLeaseId, int? timeout, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "lease", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-lease-action", "change");
			request.Headers.Add("x-ms-lease-id", leaseId);
			request.Headers.Add("x-ms-proposed-lease-id", proposedLeaseId);
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ContainerChangeLeaseHeaders>> ChangeLeaseAsync(string leaseId, string proposedLeaseId, int? timeout = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (leaseId == null)
			{
				throw new ArgumentNullException("leaseId");
			}
			if (proposedLeaseId == null)
			{
				throw new ArgumentNullException("proposedLeaseId");
			}
			using HttpMessage message = CreateChangeLeaseRequest(leaseId, proposedLeaseId, timeout, ifModifiedSince, ifUnmodifiedSince);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerChangeLeaseHeaders headers = new ContainerChangeLeaseHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ContainerChangeLeaseHeaders> ChangeLease(string leaseId, string proposedLeaseId, int? timeout = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (leaseId == null)
			{
				throw new ArgumentNullException("leaseId");
			}
			if (proposedLeaseId == null)
			{
				throw new ArgumentNullException("proposedLeaseId");
			}
			using HttpMessage httpMessage = CreateChangeLeaseRequest(leaseId, proposedLeaseId, timeout, ifModifiedSince, ifUnmodifiedSince);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerChangeLeaseHeaders headers = new ContainerChangeLeaseHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateListBlobFlatSegmentRequest(string prefix, string marker, int? maxresults, IEnumerable<ListBlobsIncludeItem> include, int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("comp", "list", escapeValue: true);
			if (prefix != null)
			{
				rawRequestUriBuilder.AppendQuery("prefix", prefix, escapeValue: true);
			}
			if (marker != null)
			{
				rawRequestUriBuilder.AppendQuery("marker", marker, escapeValue: true);
			}
			if (maxresults.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("maxresults", maxresults.Value);
			}
			if (include != null && Azure.Core.Optional.IsCollectionDefined(include))
			{
				rawRequestUriBuilder.AppendQueryDelimited("include", include, ",");
			}
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ListBlobsFlatSegmentResponse, ContainerListBlobFlatSegmentHeaders>> ListBlobFlatSegmentAsync(string prefix = null, string marker = null, int? maxresults = null, IEnumerable<ListBlobsIncludeItem> include = null, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateListBlobFlatSegmentRequest(prefix, marker, maxresults, include, timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerListBlobFlatSegmentHeaders headers = new ContainerListBlobFlatSegmentHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				ListBlobsFlatSegmentResponse value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = ListBlobsFlatSegmentResponse.DeserializeListBlobsFlatSegmentResponse(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ListBlobsFlatSegmentResponse, ContainerListBlobFlatSegmentHeaders> ListBlobFlatSegment(string prefix = null, string marker = null, int? maxresults = null, IEnumerable<ListBlobsIncludeItem> include = null, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateListBlobFlatSegmentRequest(prefix, marker, maxresults, include, timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerListBlobFlatSegmentHeaders headers = new ContainerListBlobFlatSegmentHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				ListBlobsFlatSegmentResponse value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = ListBlobsFlatSegmentResponse.DeserializeListBlobsFlatSegmentResponse(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateListBlobHierarchySegmentRequest(string prefix, string delimiter, string marker, int? maxresults, IEnumerable<ListBlobsIncludeItem> include, int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "container", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("comp", "list", escapeValue: true);
			if (prefix != null)
			{
				rawRequestUriBuilder.AppendQuery("prefix", prefix, escapeValue: true);
			}
			if (delimiter != null)
			{
				rawRequestUriBuilder.AppendQuery("delimiter", delimiter, escapeValue: true);
			}
			if (marker != null)
			{
				rawRequestUriBuilder.AppendQuery("marker", marker, escapeValue: true);
			}
			if (maxresults.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("maxresults", maxresults.Value);
			}
			if (include != null && Azure.Core.Optional.IsCollectionDefined(include))
			{
				rawRequestUriBuilder.AppendQueryDelimited("include", include, ",");
			}
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ListBlobsHierarchySegmentResponse, ContainerListBlobHierarchySegmentHeaders>> ListBlobHierarchySegmentAsync(string prefix = null, string delimiter = null, string marker = null, int? maxresults = null, IEnumerable<ListBlobsIncludeItem> include = null, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateListBlobHierarchySegmentRequest(prefix, delimiter, marker, maxresults, include, timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerListBlobHierarchySegmentHeaders headers = new ContainerListBlobHierarchySegmentHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				ListBlobsHierarchySegmentResponse value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = ListBlobsHierarchySegmentResponse.DeserializeListBlobsHierarchySegmentResponse(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ListBlobsHierarchySegmentResponse, ContainerListBlobHierarchySegmentHeaders> ListBlobHierarchySegment(string prefix = null, string delimiter = null, string marker = null, int? maxresults = null, IEnumerable<ListBlobsIncludeItem> include = null, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateListBlobHierarchySegmentRequest(prefix, delimiter, marker, maxresults, include, timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerListBlobHierarchySegmentHeaders headers = new ContainerListBlobHierarchySegmentHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				ListBlobsHierarchySegmentResponse value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = ListBlobsHierarchySegmentResponse.DeserializeListBlobsHierarchySegmentResponse(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateListBlobFlatSegmentNextPageRequest(string nextLink, string prefix, string marker, int? maxresults, IEnumerable<ListBlobsIncludeItem> include, int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendRawNextLink(nextLink, escape: false);
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ListBlobsFlatSegmentResponse, ContainerListBlobFlatSegmentHeaders>> ListBlobFlatSegmentNextPageAsync(string nextLink, string prefix = null, string marker = null, int? maxresults = null, IEnumerable<ListBlobsIncludeItem> include = null, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (nextLink == null)
			{
				throw new ArgumentNullException("nextLink");
			}
			using HttpMessage message = CreateListBlobFlatSegmentNextPageRequest(nextLink, prefix, marker, maxresults, include, timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerListBlobFlatSegmentHeaders headers = new ContainerListBlobFlatSegmentHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				ListBlobsFlatSegmentResponse value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = ListBlobsFlatSegmentResponse.DeserializeListBlobsFlatSegmentResponse(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ListBlobsFlatSegmentResponse, ContainerListBlobFlatSegmentHeaders> ListBlobFlatSegmentNextPage(string nextLink, string prefix = null, string marker = null, int? maxresults = null, IEnumerable<ListBlobsIncludeItem> include = null, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (nextLink == null)
			{
				throw new ArgumentNullException("nextLink");
			}
			using HttpMessage httpMessage = CreateListBlobFlatSegmentNextPageRequest(nextLink, prefix, marker, maxresults, include, timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerListBlobFlatSegmentHeaders headers = new ContainerListBlobFlatSegmentHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				ListBlobsFlatSegmentResponse value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = ListBlobsFlatSegmentResponse.DeserializeListBlobsFlatSegmentResponse(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateListBlobHierarchySegmentNextPageRequest(string nextLink, string prefix, string delimiter, string marker, int? maxresults, IEnumerable<ListBlobsIncludeItem> include, int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendRawNextLink(nextLink, escape: false);
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ListBlobsHierarchySegmentResponse, ContainerListBlobHierarchySegmentHeaders>> ListBlobHierarchySegmentNextPageAsync(string nextLink, string prefix = null, string delimiter = null, string marker = null, int? maxresults = null, IEnumerable<ListBlobsIncludeItem> include = null, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (nextLink == null)
			{
				throw new ArgumentNullException("nextLink");
			}
			using HttpMessage message = CreateListBlobHierarchySegmentNextPageRequest(nextLink, prefix, delimiter, marker, maxresults, include, timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ContainerListBlobHierarchySegmentHeaders headers = new ContainerListBlobHierarchySegmentHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				ListBlobsHierarchySegmentResponse value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = ListBlobsHierarchySegmentResponse.DeserializeListBlobsHierarchySegmentResponse(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ListBlobsHierarchySegmentResponse, ContainerListBlobHierarchySegmentHeaders> ListBlobHierarchySegmentNextPage(string nextLink, string prefix = null, string delimiter = null, string marker = null, int? maxresults = null, IEnumerable<ListBlobsIncludeItem> include = null, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (nextLink == null)
			{
				throw new ArgumentNullException("nextLink");
			}
			using HttpMessage httpMessage = CreateListBlobHierarchySegmentNextPageRequest(nextLink, prefix, delimiter, marker, maxresults, include, timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			ContainerListBlobHierarchySegmentHeaders headers = new ContainerListBlobHierarchySegmentHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				ListBlobsHierarchySegmentResponse value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = ListBlobsHierarchySegmentResponse.DeserializeListBlobsHierarchySegmentResponse(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}
	}
	internal class ContainerRestoreHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerRestoreHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerSetAccessPolicyHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerSetAccessPolicyHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerSetMetadataHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerSetMetadataHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ContainerSubmitBatchHeaders
	{
		private readonly Response _response;

		public string ContentType
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Type", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ContainerSubmitBatchHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class PageBlobClearPagesHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] XMsContentCrc64
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-content-crc64", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public long? BlobSequenceNumber
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-sequence-number", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public PageBlobClearPagesHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class PageBlobCopyIncrementalHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string CopyId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public CopyStatus? CopyStatus
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-copy-status", out string value))
				{
					return null;
				}
				return value.ToCopyStatus();
			}
		}

		public PageBlobCopyIncrementalHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class PageBlobCreateHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string VersionId
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version-id", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-request-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public PageBlobCreateHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class PageBlobGetPageRangesDiffHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public long? BlobContentLength
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-content-length", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public PageBlobGetPageRangesDiffHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class PageBlobGetPageRangesHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public long? BlobContentLength
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-content-length", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public PageBlobGetPageRangesHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class PageBlobResizeHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public long? BlobSequenceNumber
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-sequence-number", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public PageBlobResizeHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class PageBlobRestClient
	{
		private readonly HttpPipeline _pipeline;

		private readonly string _url;

		private readonly string _version;

		internal Azure.Core.Pipeline.ClientDiagnostics ClientDiagnostics { get; }

		public PageBlobRestClient(Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version)
		{
			ClientDiagnostics = clientDiagnostics ?? throw new ArgumentNullException("clientDiagnostics");
			_pipeline = pipeline ?? throw new ArgumentNullException("pipeline");
			_url = url ?? throw new ArgumentNullException("url");
			_version = version ?? throw new ArgumentNullException("version");
		}

		internal HttpMessage CreateCreateRequest(long contentLength, long blobContentLength, int? timeout, PremiumPageBlobAccessTier? tier, string blobContentType, string blobContentEncoding, string blobContentLanguage, byte[] blobContentMD5, string blobCacheControl, IDictionary<string, string> metadata, string leaseId, string blobContentDisposition, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, long? blobSequenceNumber, string blobTagsString, DateTimeOffset? immutabilityPolicyExpiry, BlobImmutabilityPolicyMode? immutabilityPolicyMode, bool? legalHold)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-blob-type", "PageBlob");
			if (tier.HasValue)
			{
				request.Headers.Add("x-ms-access-tier", tier.Value.ToString());
			}
			if (blobContentType != null)
			{
				request.Headers.Add("x-ms-blob-content-type", blobContentType);
			}
			if (blobContentEncoding != null)
			{
				request.Headers.Add("x-ms-blob-content-encoding", blobContentEncoding);
			}
			if (blobContentLanguage != null)
			{
				request.Headers.Add("x-ms-blob-content-language", blobContentLanguage);
			}
			if (blobContentMD5 != null)
			{
				request.Headers.Add("x-ms-blob-content-md5", blobContentMD5, "D");
			}
			if (blobCacheControl != null)
			{
				request.Headers.Add("x-ms-blob-cache-control", blobCacheControl);
			}
			if (metadata != null)
			{
				request.Headers.Add("x-ms-meta-", metadata);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (blobContentDisposition != null)
			{
				request.Headers.Add("x-ms-blob-content-disposition", blobContentDisposition);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-blob-content-length", blobContentLength);
			if (blobSequenceNumber.HasValue)
			{
				request.Headers.Add("x-ms-blob-sequence-number", blobSequenceNumber.Value);
			}
			request.Headers.Add("x-ms-version", _version);
			if (blobTagsString != null)
			{
				request.Headers.Add("x-ms-tags", blobTagsString);
			}
			if (immutabilityPolicyExpiry.HasValue)
			{
				request.Headers.Add("x-ms-immutability-policy-until-date", immutabilityPolicyExpiry.Value, "R");
			}
			if (immutabilityPolicyMode.HasValue)
			{
				request.Headers.Add("x-ms-immutability-policy-mode", immutabilityPolicyMode.Value.ToSerialString());
			}
			if (legalHold.HasValue)
			{
				request.Headers.Add("x-ms-legal-hold", legalHold.Value);
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<PageBlobCreateHeaders>> CreateAsync(long contentLength, long blobContentLength, int? timeout = null, PremiumPageBlobAccessTier? tier = null, string blobContentType = null, string blobContentEncoding = null, string blobContentLanguage = null, byte[] blobContentMD5 = null, string blobCacheControl = null, IDictionary<string, string> metadata = null, string leaseId = null, string blobContentDisposition = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, long? blobSequenceNumber = null, string blobTagsString = null, DateTimeOffset? immutabilityPolicyExpiry = null, BlobImmutabilityPolicyMode? immutabilityPolicyMode = null, bool? legalHold = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateCreateRequest(contentLength, blobContentLength, timeout, tier, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD5, blobCacheControl, metadata, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobSequenceNumber, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			PageBlobCreateHeaders headers = new PageBlobCreateHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<PageBlobCreateHeaders> Create(long contentLength, long blobContentLength, int? timeout = null, PremiumPageBlobAccessTier? tier = null, string blobContentType = null, string blobContentEncoding = null, string blobContentLanguage = null, byte[] blobContentMD5 = null, string blobCacheControl = null, IDictionary<string, string> metadata = null, string leaseId = null, string blobContentDisposition = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, long? blobSequenceNumber = null, string blobTagsString = null, DateTimeOffset? immutabilityPolicyExpiry = null, BlobImmutabilityPolicyMode? immutabilityPolicyMode = null, bool? legalHold = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateCreateRequest(contentLength, blobContentLength, timeout, tier, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD5, blobCacheControl, metadata, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobSequenceNumber, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold);
			_pipeline.Send(httpMessage, cancellationToken);
			PageBlobCreateHeaders headers = new PageBlobCreateHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateUploadPagesRequest(long contentLength, Stream body, byte[] transactionalContentMD5, byte[] transactionalContentCrc64, int? timeout, string range, string leaseId, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope, long? ifSequenceNumberLessThanOrEqualTo, long? ifSequenceNumberLessThan, long? ifSequenceNumberEqualTo, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "page", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-page-write", "update");
			if (transactionalContentCrc64 != null)
			{
				request.Headers.Add("x-ms-content-crc64", transactionalContentCrc64, "D");
			}
			if (range != null)
			{
				request.Headers.Add("x-ms-range", range);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (ifSequenceNumberLessThanOrEqualTo.HasValue)
			{
				request.Headers.Add("x-ms-if-sequence-number-le", ifSequenceNumberLessThanOrEqualTo.Value);
			}
			if (ifSequenceNumberLessThan.HasValue)
			{
				request.Headers.Add("x-ms-if-sequence-number-lt", ifSequenceNumberLessThan.Value);
			}
			if (ifSequenceNumberEqualTo.HasValue)
			{
				request.Headers.Add("x-ms-if-sequence-number-eq", ifSequenceNumberEqualTo.Value);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			request.Headers.Add("Content-Length", contentLength);
			if (transactionalContentMD5 != null)
			{
				request.Headers.Add("Content-MD5", transactionalContentMD5, "D");
			}
			request.Headers.Add("Content-Type", "application/octet-stream");
			request.Content = RequestContent.Create(body);
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<PageBlobUploadPagesHeaders>> UploadPagesAsync(long contentLength, Stream body, byte[] transactionalContentMD5 = null, byte[] transactionalContentCrc64 = null, int? timeout = null, string range = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, long? ifSequenceNumberLessThanOrEqualTo = null, long? ifSequenceNumberLessThan = null, long? ifSequenceNumberEqualTo = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			using HttpMessage message = CreateUploadPagesRequest(contentLength, body, transactionalContentMD5, transactionalContentCrc64, timeout, range, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifSequenceNumberLessThanOrEqualTo, ifSequenceNumberLessThan, ifSequenceNumberEqualTo, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			PageBlobUploadPagesHeaders headers = new PageBlobUploadPagesHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<PageBlobUploadPagesHeaders> UploadPages(long contentLength, Stream body, byte[] transactionalContentMD5 = null, byte[] transactionalContentCrc64 = null, int? timeout = null, string range = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, long? ifSequenceNumberLessThanOrEqualTo = null, long? ifSequenceNumberLessThan = null, long? ifSequenceNumberEqualTo = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			using HttpMessage httpMessage = CreateUploadPagesRequest(contentLength, body, transactionalContentMD5, transactionalContentCrc64, timeout, range, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifSequenceNumberLessThanOrEqualTo, ifSequenceNumberLessThan, ifSequenceNumberEqualTo, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			PageBlobUploadPagesHeaders headers = new PageBlobUploadPagesHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateClearPagesRequest(long contentLength, int? timeout, string range, string leaseId, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope, long? ifSequenceNumberLessThanOrEqualTo, long? ifSequenceNumberLessThan, long? ifSequenceNumberEqualTo, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "page", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-page-write", "clear");
			if (range != null)
			{
				request.Headers.Add("x-ms-range", range);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (ifSequenceNumberLessThanOrEqualTo.HasValue)
			{
				request.Headers.Add("x-ms-if-sequence-number-le", ifSequenceNumberLessThanOrEqualTo.Value);
			}
			if (ifSequenceNumberLessThan.HasValue)
			{
				request.Headers.Add("x-ms-if-sequence-number-lt", ifSequenceNumberLessThan.Value);
			}
			if (ifSequenceNumberEqualTo.HasValue)
			{
				request.Headers.Add("x-ms-if-sequence-number-eq", ifSequenceNumberEqualTo.Value);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<PageBlobClearPagesHeaders>> ClearPagesAsync(long contentLength, int? timeout = null, string range = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, long? ifSequenceNumberLessThanOrEqualTo = null, long? ifSequenceNumberLessThan = null, long? ifSequenceNumberEqualTo = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateClearPagesRequest(contentLength, timeout, range, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifSequenceNumberLessThanOrEqualTo, ifSequenceNumberLessThan, ifSequenceNumberEqualTo, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			PageBlobClearPagesHeaders headers = new PageBlobClearPagesHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<PageBlobClearPagesHeaders> ClearPages(long contentLength, int? timeout = null, string range = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, long? ifSequenceNumberLessThanOrEqualTo = null, long? ifSequenceNumberLessThan = null, long? ifSequenceNumberEqualTo = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateClearPagesRequest(contentLength, timeout, range, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifSequenceNumberLessThanOrEqualTo, ifSequenceNumberLessThan, ifSequenceNumberEqualTo, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			PageBlobClearPagesHeaders headers = new PageBlobClearPagesHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateUploadPagesFromURLRequest(string sourceUrl, string sourceRange, long contentLength, string range, byte[] sourceContentMD5, byte[] sourceContentcrc64, int? timeout, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope, string leaseId, long? ifSequenceNumberLessThanOrEqualTo, long? ifSequenceNumberLessThan, long? ifSequenceNumberEqualTo, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, DateTimeOffset? sourceIfModifiedSince, DateTimeOffset? sourceIfUnmodifiedSince, string sourceIfMatch, string sourceIfNoneMatch, string copySourceAuthorization)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "page", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-page-write", "update");
			request.Headers.Add("x-ms-copy-source", sourceUrl);
			request.Headers.Add("x-ms-source-range", sourceRange);
			if (sourceContentMD5 != null)
			{
				request.Headers.Add("x-ms-source-content-md5", sourceContentMD5, "D");
			}
			if (sourceContentcrc64 != null)
			{
				request.Headers.Add("x-ms-source-content-crc64", sourceContentcrc64, "D");
			}
			request.Headers.Add("x-ms-range", range);
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (ifSequenceNumberLessThanOrEqualTo.HasValue)
			{
				request.Headers.Add("x-ms-if-sequence-number-le", ifSequenceNumberLessThanOrEqualTo.Value);
			}
			if (ifSequenceNumberLessThan.HasValue)
			{
				request.Headers.Add("x-ms-if-sequence-number-lt", ifSequenceNumberLessThan.Value);
			}
			if (ifSequenceNumberEqualTo.HasValue)
			{
				request.Headers.Add("x-ms-if-sequence-number-eq", ifSequenceNumberEqualTo.Value);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			if (sourceIfModifiedSince.HasValue)
			{
				request.Headers.Add("x-ms-source-if-modified-since", sourceIfModifiedSince.Value, "R");
			}
			if (sourceIfUnmodifiedSince.HasValue)
			{
				request.Headers.Add("x-ms-source-if-unmodified-since", sourceIfUnmodifiedSince.Value, "R");
			}
			if (sourceIfMatch != null)
			{
				request.Headers.Add("x-ms-source-if-match", sourceIfMatch);
			}
			if (sourceIfNoneMatch != null)
			{
				request.Headers.Add("x-ms-source-if-none-match", sourceIfNoneMatch);
			}
			request.Headers.Add("x-ms-version", _version);
			if (copySourceAuthorization != null)
			{
				request.Headers.Add("x-ms-copy-source-authorization", copySourceAuthorization);
			}
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<PageBlobUploadPagesFromURLHeaders>> UploadPagesFromURLAsync(string sourceUrl, string sourceRange, long contentLength, string range, byte[] sourceContentMD5 = null, byte[] sourceContentcrc64 = null, int? timeout = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, string leaseId = null, long? ifSequenceNumberLessThanOrEqualTo = null, long? ifSequenceNumberLessThan = null, long? ifSequenceNumberEqualTo = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, DateTimeOffset? sourceIfModifiedSince = null, DateTimeOffset? sourceIfUnmodifiedSince = null, string sourceIfMatch = null, string sourceIfNoneMatch = null, string copySourceAuthorization = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (sourceUrl == null)
			{
				throw new ArgumentNullException("sourceUrl");
			}
			if (sourceRange == null)
			{
				throw new ArgumentNullException("sourceRange");
			}
			if (range == null)
			{
				throw new ArgumentNullException("range");
			}
			using HttpMessage message = CreateUploadPagesFromURLRequest(sourceUrl, sourceRange, contentLength, range, sourceContentMD5, sourceContentcrc64, timeout, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, leaseId, ifSequenceNumberLessThanOrEqualTo, ifSequenceNumberLessThan, ifSequenceNumberEqualTo, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, copySourceAuthorization);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			PageBlobUploadPagesFromURLHeaders headers = new PageBlobUploadPagesFromURLHeaders(message.Response);
			if (message.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<PageBlobUploadPagesFromURLHeaders> UploadPagesFromURL(string sourceUrl, string sourceRange, long contentLength, string range, byte[] sourceContentMD5 = null, byte[] sourceContentcrc64 = null, int? timeout = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, string leaseId = null, long? ifSequenceNumberLessThanOrEqualTo = null, long? ifSequenceNumberLessThan = null, long? ifSequenceNumberEqualTo = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, DateTimeOffset? sourceIfModifiedSince = null, DateTimeOffset? sourceIfUnmodifiedSince = null, string sourceIfMatch = null, string sourceIfNoneMatch = null, string copySourceAuthorization = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (sourceUrl == null)
			{
				throw new ArgumentNullException("sourceUrl");
			}
			if (sourceRange == null)
			{
				throw new ArgumentNullException("sourceRange");
			}
			if (range == null)
			{
				throw new ArgumentNullException("range");
			}
			using HttpMessage httpMessage = CreateUploadPagesFromURLRequest(sourceUrl, sourceRange, contentLength, range, sourceContentMD5, sourceContentcrc64, timeout, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, leaseId, ifSequenceNumberLessThanOrEqualTo, ifSequenceNumberLessThan, ifSequenceNumberEqualTo, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, copySourceAuthorization);
			_pipeline.Send(httpMessage, cancellationToken);
			PageBlobUploadPagesFromURLHeaders headers = new PageBlobUploadPagesFromURLHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 201)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateGetPageRangesRequest(string snapshot, int? timeout, string range, string leaseId, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, int? maxresults)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "pagelist", escapeValue: true);
			if (snapshot != null)
			{
				rawRequestUriBuilder.AppendQuery("snapshot", snapshot, escapeValue: true);
			}
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			if (marker != null)
			{
				rawRequestUriBuilder.AppendQuery("marker", marker, escapeValue: true);
			}
			if (maxresults.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("maxresults", maxresults.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (range != null)
			{
				request.Headers.Add("x-ms-range", range);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesHeaders>> GetPageRangesAsync(string snapshot = null, int? timeout = null, string range = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string marker = null, int? maxresults = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateGetPageRangesRequest(snapshot, timeout, range, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, marker, maxresults);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			PageBlobGetPageRangesHeaders headers = new PageBlobGetPageRangesHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				PageList value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("PageList");
				if (xElement != null)
				{
					value = PageList.DeserializePageList(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesHeaders> GetPageRanges(string snapshot = null, int? timeout = null, string range = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string marker = null, int? maxresults = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateGetPageRangesRequest(snapshot, timeout, range, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, marker, maxresults);
			_pipeline.Send(httpMessage, cancellationToken);
			PageBlobGetPageRangesHeaders headers = new PageBlobGetPageRangesHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				PageList value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("PageList");
				if (xElement != null)
				{
					value = PageList.DeserializePageList(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateGetPageRangesDiffRequest(string snapshot, int? timeout, string prevsnapshot, string prevSnapshotUrl, string range, string leaseId, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, int? maxresults)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "pagelist", escapeValue: true);
			if (snapshot != null)
			{
				rawRequestUriBuilder.AppendQuery("snapshot", snapshot, escapeValue: true);
			}
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			if (prevsnapshot != null)
			{
				rawRequestUriBuilder.AppendQuery("prevsnapshot", prevsnapshot, escapeValue: true);
			}
			if (marker != null)
			{
				rawRequestUriBuilder.AppendQuery("marker", marker, escapeValue: true);
			}
			if (maxresults.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("maxresults", maxresults.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (prevSnapshotUrl != null)
			{
				request.Headers.Add("x-ms-previous-snapshot-url", prevSnapshotUrl);
			}
			if (range != null)
			{
				request.Headers.Add("x-ms-range", range);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesDiffHeaders>> GetPageRangesDiffAsync(string snapshot = null, int? timeout = null, string prevsnapshot = null, string prevSnapshotUrl = null, string range = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string marker = null, int? maxresults = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateGetPageRangesDiffRequest(snapshot, timeout, prevsnapshot, prevSnapshotUrl, range, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, marker, maxresults);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			PageBlobGetPageRangesDiffHeaders headers = new PageBlobGetPageRangesDiffHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				PageList value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("PageList");
				if (xElement != null)
				{
					value = PageList.DeserializePageList(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesDiffHeaders> GetPageRangesDiff(string snapshot = null, int? timeout = null, string prevsnapshot = null, string prevSnapshotUrl = null, string range = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string marker = null, int? maxresults = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateGetPageRangesDiffRequest(snapshot, timeout, prevsnapshot, prevSnapshotUrl, range, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, marker, maxresults);
			_pipeline.Send(httpMessage, cancellationToken);
			PageBlobGetPageRangesDiffHeaders headers = new PageBlobGetPageRangesDiffHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				PageList value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("PageList");
				if (xElement != null)
				{
					value = PageList.DeserializePageList(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateResizeRequest(long blobContentLength, int? timeout, string leaseId, string encryptionKey, string encryptionKeySha256, EncryptionAlgorithmTypeInternal? encryptionAlgorithm, string encryptionScope, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "properties", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (encryptionKey != null)
			{
				request.Headers.Add("x-ms-encryption-key", encryptionKey);
			}
			if (encryptionKeySha256 != null)
			{
				request.Headers.Add("x-ms-encryption-key-sha256", encryptionKeySha256);
			}
			if (encryptionAlgorithm.HasValue)
			{
				request.Headers.Add("x-ms-encryption-algorithm", encryptionAlgorithm.Value.ToSerialString());
			}
			if (encryptionScope != null)
			{
				request.Headers.Add("x-ms-encryption-scope", encryptionScope);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-blob-content-length", blobContentLength);
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<PageBlobResizeHeaders>> ResizeAsync(long blobContentLength, int? timeout = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateResizeRequest(blobContentLength, timeout, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			PageBlobResizeHeaders headers = new PageBlobResizeHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<PageBlobResizeHeaders> Resize(long blobContentLength, int? timeout = null, string leaseId = null, string encryptionKey = null, string encryptionKeySha256 = null, EncryptionAlgorithmTypeInternal? encryptionAlgorithm = null, string encryptionScope = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateResizeRequest(blobContentLength, timeout, leaseId, encryptionKey, encryptionKeySha256, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			PageBlobResizeHeaders headers = new PageBlobResizeHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateUpdateSequenceNumberRequest(SequenceNumberAction sequenceNumberAction, int? timeout, string leaseId, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, long? blobSequenceNumber)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "properties", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-sequence-number-action", sequenceNumberAction.ToSerialString());
			if (blobSequenceNumber.HasValue)
			{
				request.Headers.Add("x-ms-blob-sequence-number", blobSequenceNumber.Value);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<PageBlobUpdateSequenceNumberHeaders>> UpdateSequenceNumberAsync(SequenceNumberAction sequenceNumberAction, int? timeout = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, long? blobSequenceNumber = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateUpdateSequenceNumberRequest(sequenceNumberAction, timeout, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobSequenceNumber);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			PageBlobUpdateSequenceNumberHeaders headers = new PageBlobUpdateSequenceNumberHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<PageBlobUpdateSequenceNumberHeaders> UpdateSequenceNumber(SequenceNumberAction sequenceNumberAction, int? timeout = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, long? blobSequenceNumber = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateUpdateSequenceNumberRequest(sequenceNumberAction, timeout, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobSequenceNumber);
			_pipeline.Send(httpMessage, cancellationToken);
			PageBlobUpdateSequenceNumberHeaders headers = new PageBlobUpdateSequenceNumberHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateCopyIncrementalRequest(string copySource, int? timeout, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "incrementalcopy", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-copy-source", copySource);
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<PageBlobCopyIncrementalHeaders>> CopyIncrementalAsync(string copySource, int? timeout = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (copySource == null)
			{
				throw new ArgumentNullException("copySource");
			}
			using HttpMessage message = CreateCopyIncrementalRequest(copySource, timeout, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			PageBlobCopyIncrementalHeaders headers = new PageBlobCopyIncrementalHeaders(message.Response);
			if (message.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<PageBlobCopyIncrementalHeaders> CopyIncremental(string copySource, int? timeout = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (copySource == null)
			{
				throw new ArgumentNullException("copySource");
			}
			using HttpMessage httpMessage = CreateCopyIncrementalRequest(copySource, timeout, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags);
			_pipeline.Send(httpMessage, cancellationToken);
			PageBlobCopyIncrementalHeaders headers = new PageBlobCopyIncrementalHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateGetPageRangesNextPageRequest(string nextLink, string snapshot, int? timeout, string range, string leaseId, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, int? maxresults)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendRawNextLink(nextLink, escape: false);
			request.Uri = rawRequestUriBuilder;
			if (range != null)
			{
				request.Headers.Add("x-ms-range", range);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesHeaders>> GetPageRangesNextPageAsync(string nextLink, string snapshot = null, int? timeout = null, string range = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string marker = null, int? maxresults = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (nextLink == null)
			{
				throw new ArgumentNullException("nextLink");
			}
			using HttpMessage message = CreateGetPageRangesNextPageRequest(nextLink, snapshot, timeout, range, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, marker, maxresults);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			PageBlobGetPageRangesHeaders headers = new PageBlobGetPageRangesHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				PageList value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("PageList");
				if (xElement != null)
				{
					value = PageList.DeserializePageList(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesHeaders> GetPageRangesNextPage(string nextLink, string snapshot = null, int? timeout = null, string range = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string marker = null, int? maxresults = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (nextLink == null)
			{
				throw new ArgumentNullException("nextLink");
			}
			using HttpMessage httpMessage = CreateGetPageRangesNextPageRequest(nextLink, snapshot, timeout, range, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, marker, maxresults);
			_pipeline.Send(httpMessage, cancellationToken);
			PageBlobGetPageRangesHeaders headers = new PageBlobGetPageRangesHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				PageList value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("PageList");
				if (xElement != null)
				{
					value = PageList.DeserializePageList(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateGetPageRangesDiffNextPageRequest(string nextLink, string snapshot, int? timeout, string prevsnapshot, string prevSnapshotUrl, string range, string leaseId, DateTimeOffset? ifModifiedSince, DateTimeOffset? ifUnmodifiedSince, string ifMatch, string ifNoneMatch, string ifTags, string marker, int? maxresults)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendRawNextLink(nextLink, escape: false);
			request.Uri = rawRequestUriBuilder;
			if (prevSnapshotUrl != null)
			{
				request.Headers.Add("x-ms-previous-snapshot-url", prevSnapshotUrl);
			}
			if (range != null)
			{
				request.Headers.Add("x-ms-range", range);
			}
			if (leaseId != null)
			{
				request.Headers.Add("x-ms-lease-id", leaseId);
			}
			if (ifModifiedSince.HasValue)
			{
				request.Headers.Add("If-Modified-Since", ifModifiedSince.Value, "R");
			}
			if (ifUnmodifiedSince.HasValue)
			{
				request.Headers.Add("If-Unmodified-Since", ifUnmodifiedSince.Value, "R");
			}
			if (ifMatch != null)
			{
				request.Headers.Add("If-Match", ifMatch);
			}
			if (ifNoneMatch != null)
			{
				request.Headers.Add("If-None-Match", ifNoneMatch);
			}
			if (ifTags != null)
			{
				request.Headers.Add("x-ms-if-tags", ifTags);
			}
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesDiffHeaders>> GetPageRangesDiffNextPageAsync(string nextLink, string snapshot = null, int? timeout = null, string prevsnapshot = null, string prevSnapshotUrl = null, string range = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string marker = null, int? maxresults = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (nextLink == null)
			{
				throw new ArgumentNullException("nextLink");
			}
			using HttpMessage message = CreateGetPageRangesDiffNextPageRequest(nextLink, snapshot, timeout, prevsnapshot, prevSnapshotUrl, range, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, marker, maxresults);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			PageBlobGetPageRangesDiffHeaders headers = new PageBlobGetPageRangesDiffHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				PageList value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("PageList");
				if (xElement != null)
				{
					value = PageList.DeserializePageList(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesDiffHeaders> GetPageRangesDiffNextPage(string nextLink, string snapshot = null, int? timeout = null, string prevsnapshot = null, string prevSnapshotUrl = null, string range = null, string leaseId = null, DateTimeOffset? ifModifiedSince = null, DateTimeOffset? ifUnmodifiedSince = null, string ifMatch = null, string ifNoneMatch = null, string ifTags = null, string marker = null, int? maxresults = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (nextLink == null)
			{
				throw new ArgumentNullException("nextLink");
			}
			using HttpMessage httpMessage = CreateGetPageRangesDiffNextPageRequest(nextLink, snapshot, timeout, prevsnapshot, prevSnapshotUrl, range, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, marker, maxresults);
			_pipeline.Send(httpMessage, cancellationToken);
			PageBlobGetPageRangesDiffHeaders headers = new PageBlobGetPageRangesDiffHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				PageList value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("PageList");
				if (xElement != null)
				{
					value = PageList.DeserializePageList(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}
	}
	internal class PageBlobUpdateSequenceNumberHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public long? BlobSequenceNumber
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-sequence-number", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public PageBlobUpdateSequenceNumberHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class PageBlobUploadPagesFromURLHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] XMsContentCrc64
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-content-crc64", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public long? BlobSequenceNumber
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-sequence-number", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-request-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public PageBlobUploadPagesFromURLHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class PageBlobUploadPagesHeaders
	{
		private readonly Response _response;

		public DateTimeOffset? LastModified
		{
			get
			{
				if (!_response.Headers.TryGetValue("Last-Modified", out DateTimeOffset? value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] ContentMD5
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-MD5", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public byte[] XMsContentCrc64
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-content-crc64", out byte[] value))
				{
					return null;
				}
				return value;
			}
		}

		public long? BlobSequenceNumber
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-blob-sequence-number", out long? value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public bool? IsServerEncrypted
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-request-server-encrypted", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionKeySha256
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-key-sha256", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string EncryptionScope
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-encryption-scope", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public PageBlobUploadPagesHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ServiceFilterBlobsHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ServiceFilterBlobsHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ServiceGetAccountInfoHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public SkuName? SkuName
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-sku-name", out string value))
				{
					return null;
				}
				return value.ToSkuName();
			}
		}

		public AccountKind? AccountKind
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-account-kind", out string value))
				{
					return null;
				}
				return value.ToAccountKind();
			}
		}

		public bool? IsHierarchicalNamespaceEnabled
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-is-hns-enabled", out bool? value))
				{
					return null;
				}
				return value;
			}
		}

		public ServiceGetAccountInfoHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ServiceGetPropertiesHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ServiceGetPropertiesHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ServiceGetStatisticsHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ServiceGetStatisticsHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ServiceGetUserDelegationKeyHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ServiceGetUserDelegationKeyHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ServiceListContainersSegmentHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ServiceListContainersSegmentHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ServiceRestClient
	{
		private readonly HttpPipeline _pipeline;

		private readonly string _url;

		private readonly string _version;

		internal Azure.Core.Pipeline.ClientDiagnostics ClientDiagnostics { get; }

		public ServiceRestClient(Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, HttpPipeline pipeline, string url, string version)
		{
			ClientDiagnostics = clientDiagnostics ?? throw new ArgumentNullException("clientDiagnostics");
			_pipeline = pipeline ?? throw new ArgumentNullException("pipeline");
			_url = url ?? throw new ArgumentNullException("url");
			_version = version ?? throw new ArgumentNullException("version");
		}

		internal HttpMessage CreateSetPropertiesRequest(BlobServiceProperties storageServiceProperties, int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Put;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendPath("/", escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "service", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("comp", "properties", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			request.Headers.Add("Content-Type", "application/xml");
			Azure.Core.XmlWriterContent xmlWriterContent = new Azure.Core.XmlWriterContent();
			xmlWriterContent.XmlWriter.WriteObjectValue(storageServiceProperties, "StorageServiceProperties");
			request.Content = xmlWriterContent;
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ServiceSetPropertiesHeaders>> SetPropertiesAsync(BlobServiceProperties storageServiceProperties, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (storageServiceProperties == null)
			{
				throw new ArgumentNullException("storageServiceProperties");
			}
			using HttpMessage message = CreateSetPropertiesRequest(storageServiceProperties, timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ServiceSetPropertiesHeaders headers = new ServiceSetPropertiesHeaders(message.Response);
			if (message.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ServiceSetPropertiesHeaders> SetProperties(BlobServiceProperties storageServiceProperties, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (storageServiceProperties == null)
			{
				throw new ArgumentNullException("storageServiceProperties");
			}
			using HttpMessage httpMessage = CreateSetPropertiesRequest(storageServiceProperties, timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			ServiceSetPropertiesHeaders headers = new ServiceSetPropertiesHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 202)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateGetPropertiesRequest(int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendPath("/", escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "service", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("comp", "properties", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobServiceProperties, ServiceGetPropertiesHeaders>> GetPropertiesAsync(int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateGetPropertiesRequest(timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ServiceGetPropertiesHeaders headers = new ServiceGetPropertiesHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				BlobServiceProperties value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("StorageServiceProperties");
				if (xElement != null)
				{
					value = BlobServiceProperties.DeserializeBlobServiceProperties(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobServiceProperties, ServiceGetPropertiesHeaders> GetProperties(int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateGetPropertiesRequest(timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			ServiceGetPropertiesHeaders headers = new ServiceGetPropertiesHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				BlobServiceProperties value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("StorageServiceProperties");
				if (xElement != null)
				{
					value = BlobServiceProperties.DeserializeBlobServiceProperties(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateGetStatisticsRequest(int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendPath("/", escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "service", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("comp", "stats", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<BlobServiceStatistics, ServiceGetStatisticsHeaders>> GetStatisticsAsync(int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateGetStatisticsRequest(timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ServiceGetStatisticsHeaders headers = new ServiceGetStatisticsHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				BlobServiceStatistics value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("StorageServiceStats");
				if (xElement != null)
				{
					value = BlobServiceStatistics.DeserializeBlobServiceStatistics(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<BlobServiceStatistics, ServiceGetStatisticsHeaders> GetStatistics(int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateGetStatisticsRequest(timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			ServiceGetStatisticsHeaders headers = new ServiceGetStatisticsHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				BlobServiceStatistics value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("StorageServiceStats");
				if (xElement != null)
				{
					value = BlobServiceStatistics.DeserializeBlobServiceStatistics(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateListContainersSegmentRequest(string prefix, string marker, int? maxresults, IEnumerable<ListContainersIncludeType> include, int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendPath("/", escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "list", escapeValue: true);
			if (prefix != null)
			{
				rawRequestUriBuilder.AppendQuery("prefix", prefix, escapeValue: true);
			}
			if (marker != null)
			{
				rawRequestUriBuilder.AppendQuery("marker", marker, escapeValue: true);
			}
			if (maxresults.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("maxresults", maxresults.Value);
			}
			if (include != null && Azure.Core.Optional.IsCollectionDefined(include))
			{
				rawRequestUriBuilder.AppendQueryDelimited("include", include, ",");
			}
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ListContainersSegmentResponse, ServiceListContainersSegmentHeaders>> ListContainersSegmentAsync(string prefix = null, string marker = null, int? maxresults = null, IEnumerable<ListContainersIncludeType> include = null, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateListContainersSegmentRequest(prefix, marker, maxresults, include, timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ServiceListContainersSegmentHeaders headers = new ServiceListContainersSegmentHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				ListContainersSegmentResponse value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = ListContainersSegmentResponse.DeserializeListContainersSegmentResponse(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ListContainersSegmentResponse, ServiceListContainersSegmentHeaders> ListContainersSegment(string prefix = null, string marker = null, int? maxresults = null, IEnumerable<ListContainersIncludeType> include = null, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateListContainersSegmentRequest(prefix, marker, maxresults, include, timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			ServiceListContainersSegmentHeaders headers = new ServiceListContainersSegmentHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				ListContainersSegmentResponse value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = ListContainersSegmentResponse.DeserializeListContainersSegmentResponse(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateGetUserDelegationKeyRequest(KeyInfo keyInfo, int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Post;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendPath("/", escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "service", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("comp", "userdelegationkey", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			request.Headers.Add("Content-Type", "application/xml");
			Azure.Core.XmlWriterContent xmlWriterContent = new Azure.Core.XmlWriterContent();
			xmlWriterContent.XmlWriter.WriteObjectValue(keyInfo, "KeyInfo");
			request.Content = xmlWriterContent;
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<UserDelegationKey, ServiceGetUserDelegationKeyHeaders>> GetUserDelegationKeyAsync(KeyInfo keyInfo, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (keyInfo == null)
			{
				throw new ArgumentNullException("keyInfo");
			}
			using HttpMessage message = CreateGetUserDelegationKeyRequest(keyInfo, timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ServiceGetUserDelegationKeyHeaders headers = new ServiceGetUserDelegationKeyHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				UserDelegationKey value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("UserDelegationKey");
				if (xElement != null)
				{
					value = UserDelegationKey.DeserializeUserDelegationKey(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<UserDelegationKey, ServiceGetUserDelegationKeyHeaders> GetUserDelegationKey(KeyInfo keyInfo, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (keyInfo == null)
			{
				throw new ArgumentNullException("keyInfo");
			}
			using HttpMessage httpMessage = CreateGetUserDelegationKeyRequest(keyInfo, timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			ServiceGetUserDelegationKeyHeaders headers = new ServiceGetUserDelegationKeyHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				UserDelegationKey value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("UserDelegationKey");
				if (xElement != null)
				{
					value = UserDelegationKey.DeserializeUserDelegationKey(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateGetAccountInfoRequest()
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendPath("/", escape: false);
			rawRequestUriBuilder.AppendQuery("restype", "account", escapeValue: true);
			rawRequestUriBuilder.AppendQuery("comp", "properties", escapeValue: true);
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ServiceGetAccountInfoHeaders>> GetAccountInfoAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateGetAccountInfoRequest();
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ServiceGetAccountInfoHeaders headers = new ServiceGetAccountInfoHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ServiceGetAccountInfoHeaders> GetAccountInfo(CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateGetAccountInfoRequest();
			_pipeline.Send(httpMessage, cancellationToken);
			ServiceGetAccountInfoHeaders headers = new ServiceGetAccountInfoHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateSubmitBatchRequest(long contentLength, string multipartContentType, Stream body, int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Post;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendPath("/", escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "batch", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			request.Headers.Add("Content-Length", contentLength);
			request.Headers.Add("Content-Type", multipartContentType);
			request.Content = RequestContent.Create(body);
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<Stream, ServiceSubmitBatchHeaders>> SubmitBatchAsync(long contentLength, string multipartContentType, Stream body, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (multipartContentType == null)
			{
				throw new ArgumentNullException("multipartContentType");
			}
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			using HttpMessage message = CreateSubmitBatchRequest(contentLength, multipartContentType, body, timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ServiceSubmitBatchHeaders headers = new ServiceSubmitBatchHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(message.ExtractResponseContent(), headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<Stream, ServiceSubmitBatchHeaders> SubmitBatch(long contentLength, string multipartContentType, Stream body, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (multipartContentType == null)
			{
				throw new ArgumentNullException("multipartContentType");
			}
			if (body == null)
			{
				throw new ArgumentNullException("body");
			}
			using HttpMessage httpMessage = CreateSubmitBatchRequest(contentLength, multipartContentType, body, timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			ServiceSubmitBatchHeaders headers = new ServiceSubmitBatchHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				return Azure.Core.ResponseWithHeaders.FromValue(httpMessage.ExtractResponseContent(), headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateFilterBlobsRequest(int? timeout, string where, string marker, int? maxresults, IEnumerable<FilterBlobsIncludeItem> include)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendPath("/", escape: false);
			rawRequestUriBuilder.AppendQuery("comp", "blobs", escapeValue: true);
			if (timeout.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("timeout", timeout.Value);
			}
			if (where != null)
			{
				rawRequestUriBuilder.AppendQuery("where", where, escapeValue: true);
			}
			if (marker != null)
			{
				rawRequestUriBuilder.AppendQuery("marker", marker, escapeValue: true);
			}
			if (maxresults.HasValue)
			{
				rawRequestUriBuilder.AppendQuery("maxresults", maxresults.Value);
			}
			if (include != null && Azure.Core.Optional.IsCollectionDefined(include))
			{
				rawRequestUriBuilder.AppendQueryDelimited("include", include, ",");
			}
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<FilterBlobSegment, ServiceFilterBlobsHeaders>> FilterBlobsAsync(int? timeout = null, string where = null, string marker = null, int? maxresults = null, IEnumerable<FilterBlobsIncludeItem> include = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage message = CreateFilterBlobsRequest(timeout, where, marker, maxresults, include);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ServiceFilterBlobsHeaders headers = new ServiceFilterBlobsHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				FilterBlobSegment value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = FilterBlobSegment.DeserializeFilterBlobSegment(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<FilterBlobSegment, ServiceFilterBlobsHeaders> FilterBlobs(int? timeout = null, string where = null, string marker = null, int? maxresults = null, IEnumerable<FilterBlobsIncludeItem> include = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			using HttpMessage httpMessage = CreateFilterBlobsRequest(timeout, where, marker, maxresults, include);
			_pipeline.Send(httpMessage, cancellationToken);
			ServiceFilterBlobsHeaders headers = new ServiceFilterBlobsHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				FilterBlobSegment value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = FilterBlobSegment.DeserializeFilterBlobSegment(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}

		internal HttpMessage CreateListContainersSegmentNextPageRequest(string nextLink, string prefix, string marker, int? maxresults, IEnumerable<ListContainersIncludeType> include, int? timeout)
		{
			HttpMessage httpMessage = _pipeline.CreateMessage();
			Request request = httpMessage.Request;
			request.Method = RequestMethod.Get;
			Azure.Core.RawRequestUriBuilder rawRequestUriBuilder = new Azure.Core.RawRequestUriBuilder();
			rawRequestUriBuilder.AppendRaw(_url, escape: false);
			rawRequestUriBuilder.AppendRawNextLink(nextLink, escape: false);
			request.Uri = rawRequestUriBuilder;
			request.Headers.Add("x-ms-version", _version);
			request.Headers.Add("Accept", "application/xml");
			return httpMessage;
		}

		public async Task<Azure.Core.ResponseWithHeaders<ListContainersSegmentResponse, ServiceListContainersSegmentHeaders>> ListContainersSegmentNextPageAsync(string nextLink, string prefix = null, string marker = null, int? maxresults = null, IEnumerable<ListContainersIncludeType> include = null, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (nextLink == null)
			{
				throw new ArgumentNullException("nextLink");
			}
			using HttpMessage message = CreateListContainersSegmentNextPageRequest(nextLink, prefix, marker, maxresults, include, timeout);
			await _pipeline.SendAsync(message, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			ServiceListContainersSegmentHeaders headers = new ServiceListContainersSegmentHeaders(message.Response);
			if (message.Response.Status == 200)
			{
				ListContainersSegmentResponse value = null;
				XElement xElement = XDocument.Load(message.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = ListContainersSegmentResponse.DeserializeListContainersSegmentResponse(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, message.Response);
			}
			throw new RequestFailedException(message.Response);
		}

		public Azure.Core.ResponseWithHeaders<ListContainersSegmentResponse, ServiceListContainersSegmentHeaders> ListContainersSegmentNextPage(string nextLink, string prefix = null, string marker = null, int? maxresults = null, IEnumerable<ListContainersIncludeType> include = null, int? timeout = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (nextLink == null)
			{
				throw new ArgumentNullException("nextLink");
			}
			using HttpMessage httpMessage = CreateListContainersSegmentNextPageRequest(nextLink, prefix, marker, maxresults, include, timeout);
			_pipeline.Send(httpMessage, cancellationToken);
			ServiceListContainersSegmentHeaders headers = new ServiceListContainersSegmentHeaders(httpMessage.Response);
			if (httpMessage.Response.Status == 200)
			{
				ListContainersSegmentResponse value = null;
				XElement xElement = XDocument.Load(httpMessage.Response.ContentStream, LoadOptions.PreserveWhitespace).Element("EnumerationResults");
				if (xElement != null)
				{
					value = ListContainersSegmentResponse.DeserializeListContainersSegmentResponse(xElement);
				}
				return Azure.Core.ResponseWithHeaders.FromValue(value, headers, httpMessage.Response);
			}
			throw new RequestFailedException(httpMessage.Response);
		}
	}
	internal class ServiceSetPropertiesHeaders
	{
		private readonly Response _response;

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ServiceSetPropertiesHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class ServiceSubmitBatchHeaders
	{
		private readonly Response _response;

		public string ContentType
		{
			get
			{
				if (!_response.Headers.TryGetValue("Content-Type", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public string Version
		{
			get
			{
				if (!_response.Headers.TryGetValue("x-ms-version", out string value))
				{
					return null;
				}
				return value;
			}
		}

		public ServiceSubmitBatchHeaders(Response response)
		{
			_response = response;
		}
	}
	internal class PageBlobWriteStream : StorageWriteStream
	{
		private readonly PageBlobClient _pageBlobClient;

		private readonly PageBlobRequestConditions _conditions;

		private long _writeIndex;

		public PageBlobWriteStream(PageBlobClient pageBlobClient, long bufferSize, long position, PageBlobRequestConditions conditions, IProgress<long> progressHandler, UploadTransferValidationOptions transferValidation)
			: base(position, bufferSize, progressHandler, transferValidation)
		{
			ValidateBufferSize(bufferSize);
			ValidatePosition(position);
			_pageBlobClient = pageBlobClient;
			_conditions = conditions ?? new PageBlobRequestConditions();
			_writeIndex = position;
		}

		protected override async Task AppendInternal(UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken)
		{
			if (_buffer.Length > 0)
			{
				_buffer.Position = 0L;
				Response<PageInfo> response = await _pageBlobClient.UploadPagesInternal(_buffer, _writeIndex, validationOptions, _conditions, _progressHandler, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				_conditions.IfMatch = response.Value.ETag;
				_writeIndex += _buffer.Length;
			}
		}

		protected override void ValidateBufferSize(long bufferSize)
		{
			if (bufferSize < 1)
			{
				throw new ArgumentOutOfRangeException("bufferSize", "Must be greater than or equal to 1");
			}
			if (bufferSize > 4194304)
			{
				throw new ArgumentOutOfRangeException("bufferSize", $"Must less than or equal to {4194304}");
			}
			if (bufferSize % 512 != 0L)
			{
				throw new ArgumentOutOfRangeException("bufferSize", $"Must be a multiple of {512}");
			}
		}

		private static void ValidatePosition(long position)
		{
			if (position % 512 != 0L)
			{
				throw new ArgumentOutOfRangeException("position", $"Must be a multiple of {512}");
			}
		}
	}
	internal class PartitionedDownloader
	{
		private const string _operationName = "BlobBaseClient.DownloadTo";

		private const string _innerOperationName = "BlobBaseClient.DownloadStreaming";

		private readonly BlobBaseClient _client;

		private readonly int _maxWorkerCount;

		private readonly long _initialRangeSize;

		private readonly long _rangeSize;

		private readonly StorageChecksumAlgorithm _validationAlgorithm;

		private readonly int _checksumSize;

		private StorageCrc64HashAlgorithm _masterCrcCalculator;

		private readonly IProgress<long> _progress;

		private readonly ArrayPool<byte> _arrayPool;

		private bool UseMasterCrc => _validationAlgorithm.ResolveAuto() == StorageChecksumAlgorithm.StorageCrc64;

		private DownloadTransferValidationOptions ValidationOptions => new DownloadTransferValidationOptions
		{
			ChecksumAlgorithm = _validationAlgorithm,
			AutoValidateChecksum = false
		};

		public PartitionedDownloader(BlobBaseClient client, StorageTransferOptions transferOptions = default(StorageTransferOptions), DownloadTransferValidationOptions transferValidation = null, IProgress<long> progress = null, ArrayPool<byte> arrayPool = null)
		{
			_client = client;
			_arrayPool = arrayPool ?? ArrayPool<byte>.Shared;
			if (transferOptions.MaximumConcurrency.HasValue && transferOptions.MaximumConcurrency > 0)
			{
				_maxWorkerCount = transferOptions.MaximumConcurrency.Value;
			}
			else
			{
				_maxWorkerCount = 5;
			}
			if (transferOptions.MaximumTransferSize.HasValue && transferOptions.MaximumTransferSize.Value > 0)
			{
				_rangeSize = Math.Min(transferOptions.MaximumTransferSize.Value, 268435456L);
			}
			else
			{
				_rangeSize = (((transferValidation?.ChecksumAlgorithm ?? StorageChecksumAlgorithm.None) != StorageChecksumAlgorithm.None) ? 4194304 : 4194304);
			}
			if (transferOptions.InitialTransferSize.HasValue && transferOptions.InitialTransferSize.Value > 0)
			{
				_initialRangeSize = transferOptions.InitialTransferSize.Value;
			}
			else
			{
				_initialRangeSize = (((transferValidation?.ChecksumAlgorithm ?? StorageChecksumAlgorithm.None) != StorageChecksumAlgorithm.None) ? 4194304 : 268435456);
			}
			Azure.Core.Argument.AssertNotNull(transferValidation, "transferValidation");
			if (!transferValidation.AutoValidateChecksum)
			{
				throw Azure.Storage.Errors.CannotDeferTransactionalHashVerification();
			}
			_validationAlgorithm = transferValidation.ChecksumAlgorithm;
			_checksumSize = ContentHasher.GetHashSizeInBytes(_validationAlgorithm);
			_progress = progress;
			if (_progress != null && !(_progress is AggregatingProgressIncrementer))
			{
				_progress = new AggregatingProgressIncrementer(_progress);
			}
		}

		public async Task<Response> DownloadToInternal(Stream destination, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			Azure.Core.Pipeline.DiagnosticScope scope = _client.ClientConfiguration.ClientDiagnostics.CreateScope("BlobBaseClient.DownloadTo");
			Memory<byte> composedCrc;
			Queue<Task<Response<BlobDownloadStreamingResult>>> runningTasks;
			using (DisposableBucket disposables = new DisposableBucket())
			{
				_ = 9;
				try
				{
					scope.Start();
					HttpRange range = new HttpRange(0L, _initialRangeSize);
					Response<BlobDownloadStreamingResult> initialResponse;
					try
					{
						initialResponse = await _client.DownloadStreamingInternal(range, conditions, ValidationOptions, _progress, "BlobBaseClient.DownloadStreaming", async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
					catch (RequestFailedException ex) when (ex.ErrorCode == BlobErrorCode.InvalidRange)
					{
						initialResponse = await _client.DownloadStreamingInternal(default(HttpRange), conditions, ValidationOptions, _progress, "BlobBaseClient.DownloadStreaming", async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
					if (initialResponse.IsUnavailable())
					{
						return initialResponse.GetRawResponse();
					}
					if (_client.UsingClientSideEncryption && initialResponse.Value.Details.Metadata.TryGetValue("encryptiondata", out var _))
					{
						destination = await new BlobClientSideDecryptor(new ClientSideDecryptor(_client.ClientSideEncryption)).DecryptWholeBlobWriteInternal(destination, initialResponse.Value.Details.Metadata, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					}
					composedCrc = default(Memory<byte>);
					if (UseMasterCrc)
					{
						_masterCrcCalculator = StorageCrc64HashAlgorithm.Create();
						destination = ChecksumCalculatingStream.GetWriteStream(destination, _masterCrcCalculator.Append);
						disposables.Add(_arrayPool.RentAsMemoryDisposable(8, out composedCrc));
						composedCrc.Span.Clear();
					}
					long initialLength = initialResponse.Value.Details.ContentLength;
					long totalLength = ParseRangeTotalLength(initialResponse.Value.Details.ContentRange);
					if (initialLength == totalLength)
					{
						await HandleOneShotDownload(initialResponse, destination, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						return initialResponse.GetRawResponse();
					}
					ETag eTag = initialResponse.Value.Details.ETag;
					BlobRequestConditions conditionsWithEtag = conditions?.WithIfMatch(eTag) ?? new BlobRequestConditions
					{
						IfMatch = eTag
					};
					runningTasks = null;
					int effectiveWorkerCount = ((!async) ? 1 : _maxWorkerCount);
					Memory<byte> partitionChecksum;
					if (effectiveWorkerCount > 1)
					{
						runningTasks = new Queue<Task<Response<BlobDownloadStreamingResult>>>();
						runningTasks.Enqueue(Task.FromResult(initialResponse));
					}
					else
					{
						using (_arrayPool.RentAsMemoryDisposable(_checksumSize, out partitionChecksum))
						{
							await CopyToInternal(initialResponse, destination, partitionChecksum, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
							if (UseMasterCrc)
							{
								Azure.Storage.StorageCrc64Composer.Compose((composedCrc.ToArray(), 0L), (partitionChecksum.ToArray(), initialResponse.Value.Details.ContentLength)).CopyTo(composedCrc);
							}
						}
						partitionChecksum = default(Memory<byte>);
					}
					foreach (HttpRange range2 in GetRanges(initialLength, totalLength))
					{
						ValueTask<Response<BlobDownloadStreamingResult>> valueTask = _client.DownloadStreamingInternal(range2, conditionsWithEtag, ValidationOptions, _progress, "BlobBaseClient.DownloadStreaming", async, cancellationToken);
						if (runningTasks != null)
						{
							runningTasks.Enqueue(valueTask.AsTask());
							if (runningTasks.Count >= effectiveWorkerCount)
							{
								await ConsumeQueuedTask().ConfigureAwait(continueOnCapturedContext: false);
							}
							continue;
						}
						Response<BlobDownloadStreamingResult> result = await valueTask.ConfigureAwait(continueOnCapturedContext: false);
						using (_arrayPool.RentAsMemoryDisposable(_checksumSize, out partitionChecksum))
						{
							await CopyToInternal(result, destination, partitionChecksum, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
							if (UseMasterCrc)
							{
								Azure.Storage.StorageCrc64Composer.Compose((composedCrc.ToArray(), 0L), (partitionChecksum.ToArray(), result.Value.Details.ContentLength)).CopyTo(composedCrc);
							}
						}
						partitionChecksum = default(Memory<byte>);
					}
					if (runningTasks != null)
					{
						while (runningTasks.Count > 0)
						{
							await ConsumeQueuedTask().ConfigureAwait(continueOnCapturedContext: false);
						}
					}
					await FinalizeDownloadInternal(destination, composedCrc, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					return initialResponse.GetRawResponse();
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
			async Task ConsumeQueuedTask()
			{
				Response<BlobDownloadStreamingResult> response = await runningTasks.Dequeue().ConfigureAwait(continueOnCapturedContext: false);
				Memory<byte> partitionChecksum2;
				using (_arrayPool.RentAsMemoryDisposable(_checksumSize, out partitionChecksum2))
				{
					await CopyToInternal(response, destination, partitionChecksum2, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					if (UseMasterCrc)
					{
						Azure.Storage.StorageCrc64Composer.Compose((composedCrc.ToArray(), 0L), (partitionChecksum2.ToArray(), response.Value.Details.ContentLength)).CopyTo(composedCrc);
					}
				}
			}
		}

		private async Task HandleOneShotDownload(Response<BlobDownloadStreamingResult> response, Stream destination, bool async, CancellationToken cancellationToken)
		{
			Memory<byte> partitionChecksum;
			using (_arrayPool.RentAsMemoryDisposable(_checksumSize, out partitionChecksum))
			{
				await CopyToInternal(response, destination, partitionChecksum, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				await FinalizeDownloadInternal(destination, partitionChecksum, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
		}

		private async Task FinalizeDownloadInternal(Stream destination, Memory<byte> composedCrc, bool async, CancellationToken cancellationToken)
		{
			await FlushFinalIfNecessaryInternal(destination, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			Memory<byte> memory;
			if (UseMasterCrc)
			{
				using (_arrayPool.RentAsMemoryDisposable(8, out memory))
				{
					_masterCrcCalculator.GetCurrentHash(memory.Span);
					ValidateFinalCrc(composedCrc.Span);
				}
			}
		}

		private static long ParseRangeTotalLength(string range)
		{
			if (range == null)
			{
				return 0L;
			}
			int num = range.IndexOf("/", StringComparison.InvariantCultureIgnoreCase);
			if (num == -1)
			{
				throw BlobErrors.ParsingFullHttpRangeFailed(range);
			}
			return long.Parse(range.Substring(num + 1), CultureInfo.InvariantCulture);
		}

		private async Task CopyToInternal(Response<BlobDownloadStreamingResult> response, Stream destination, Memory<byte> checksumBuffer, bool async, CancellationToken cancellationToken)
		{
			Azure.Core.CancellationHelper.ThrowIfCancellationRequested(cancellationToken);
			using IHasher hasher = ContentHasher.GetHasherFromAlgorithmId(_validationAlgorithm);
			using Stream rawSource = response.Value.Content;
			using Stream source = ((hasher != null) ? ChecksumCalculatingStream.GetReadStream(rawSource, hasher.AppendHash) : rawSource);
			await source.CopyToInternal(destination, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (hasher != null)
			{
				hasher.GetFinalHash(checksumBuffer.Span);
				ReadOnlyMemory<byte> item = ContentHasher.GetResponseChecksumOrDefault(response.GetRawResponse()).Checksum;
				if (!checksumBuffer.Span.SequenceEqual(item.Span))
				{
					throw Azure.Storage.Errors.HashMismatchOnStreamedDownload(response.Value.Details.ContentRange);
				}
			}
		}

		private IEnumerable<HttpRange> GetRanges(long initialLength, long totalLength)
		{
			for (long offset = initialLength; offset < totalLength; offset += _rangeSize)
			{
				yield return new HttpRange(offset, Math.Min(totalLength - offset, _rangeSize));
			}
		}

		private async Task FlushFinalIfNecessaryInternal(Stream destination, bool async, CancellationToken cancellationToken)
		{
			if (_client.UsingClientSideEncryption)
			{
				if (destination is CryptoStream cryptoStream)
				{
					cryptoStream.FlushFinalBlock();
				}
				else if (destination is AuthenticatedRegionCryptoStream authenticatedRegionCryptoStream)
				{
					await authenticatedRegionCryptoStream.FlushFinalInternal(async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
			}
		}

		private void ValidateFinalCrc(ReadOnlySpan<byte> composedCrc)
		{
			Span<byte> span;
			using (_arrayPool.RentAsSpanDisposable(8, out span))
			{
				_masterCrcCalculator.GetCurrentHash(span);
				if (!span.SequenceEqual(composedCrc))
				{
					throw Azure.Storage.Errors.ChecksumMismatch(span, composedCrc);
				}
			}
		}
	}
	internal static class QuickQueryExtensions
	{
		internal static QuerySerialization ToQuickQuerySerialization(this BlobQueryTextOptions textConfiguration, bool isInput)
		{
			if (textConfiguration == null)
			{
				return null;
			}
			QuerySerialization querySerialization;
			if (textConfiguration is BlobQueryCsvTextOptions blobQueryCsvTextOptions)
			{
				querySerialization = new QuerySerialization(new QueryFormat(QueryFormatType.Delimited));
				querySerialization.Format.DelimitedTextConfiguration = new DelimitedTextConfigurationInternal
				{
					ColumnSeparator = blobQueryCsvTextOptions.ColumnSeparator?.ToString(CultureInfo.InvariantCulture),
					FieldQuote = blobQueryCsvTextOptions.QuotationCharacter?.ToString(CultureInfo.InvariantCulture),
					RecordSeparator = blobQueryCsvTextOptions.RecordSeparator?.ToString(CultureInfo.InvariantCulture),
					EscapeChar = blobQueryCsvTextOptions.EscapeCharacter?.ToString(CultureInfo.InvariantCulture),
					HeadersPresent = blobQueryCsvTextOptions.HasHeaders
				};
			}
			else if (textConfiguration is BlobQueryJsonTextOptions blobQueryJsonTextOptions)
			{
				querySerialization = new QuerySerialization(new QueryFormat(QueryFormatType.Json));
				querySerialization.Format.JsonTextConfiguration = new JsonTextConfigurationInternal
				{
					RecordSeparator = blobQueryJsonTextOptions.RecordSeparator?.ToString(CultureInfo.InvariantCulture)
				};
			}
			else if (textConfiguration is BlobQueryArrowOptions blobQueryArrowOptions)
			{
				if (isInput)
				{
					throw new ArgumentException("BlobQueryArrowOptions can only be used for output serialization.");
				}
				querySerialization = new QuerySerialization(new QueryFormat(QueryFormatType.Arrow));
				querySerialization.Format.ArrowConfiguration = new ArrowTextConfigurationInternal(blobQueryArrowOptions.Schema?.Select(ToArrowFieldInternal).ToList());
			}
			else
			{
				if (!(textConfiguration is BlobQueryParquetTextOptions))
				{
					throw new ArgumentException("Invalid options type.  Valid options are BlobQueryCsvTextOptions, BlobQueryJsonTextOptions, BlobQueryArrowOptions, and BlobQueryParquetTextOptions");
				}
				if (!isInput)
				{
					throw new ArgumentException("BlobQueryParquetTextOptions can only be used for input serialization.");
				}
				querySerialization = new QuerySerialization(new QueryFormat(QueryFormatType.Parquet));
			}
			return querySerialization;
		}

		internal static ArrowFieldInternal ToArrowFieldInternal(this BlobQueryArrowField blobQueryArrowField)
		{
			if (blobQueryArrowField == null)
			{
				return null;
			}
			return new ArrowFieldInternal(blobQueryArrowField.Type.ToArrowFiledInternalType())
			{
				Name = blobQueryArrowField.Name,
				Precision = blobQueryArrowField.Precision,
				Scale = blobQueryArrowField.Scale
			};
		}

		internal static string ToArrowFiledInternalType(this BlobQueryArrowFieldType blobQueryArrowFieldType)
		{
			return blobQueryArrowFieldType switch
			{
				BlobQueryArrowFieldType.Bool => "bool", 
				BlobQueryArrowFieldType.Decimal => "decimal", 
				BlobQueryArrowFieldType.Double => "double", 
				BlobQueryArrowFieldType.Int64 => "int64", 
				BlobQueryArrowFieldType.String => "string", 
				BlobQueryArrowFieldType.Timestamp => "timestamp[ms]", 
				_ => throw new ArgumentException(string.Format("Unknown {0}: {1}", "BlobQueryArrowFieldType", blobQueryArrowFieldType)), 
			};
		}
	}
	internal class BlobClientConfiguration : StorageClientConfiguration
	{
		public virtual BlobClientOptions.ServiceVersion Version { get; internal set; }

		public virtual CustomerProvidedKey? CustomerProvidedKey { get; internal set; }

		public virtual TransferValidationOptions TransferValidation { get; internal set; }

		public string EncryptionScope { get; internal set; }

		public bool TrimBlobNameSlashes { get; internal set; }

		public BlobClientConfiguration(HttpPipeline pipeline, TokenCredential tokenCredential, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, BlobClientOptions.ServiceVersion version, CustomerProvidedKey? customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes)
			: base(pipeline, tokenCredential, clientDiagnostics)
		{
			Version = version;
			CustomerProvidedKey = customerProvidedKey;
			TransferValidation = transferValidation;
			EncryptionScope = encryptionScope;
			TrimBlobNameSlashes = trimBlobNameSlashes;
		}

		public BlobClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, BlobClientOptions.ServiceVersion version, CustomerProvidedKey? customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes)
			: base(pipeline, sharedKeyCredential, clientDiagnostics)
		{
			Version = version;
			CustomerProvidedKey = customerProvidedKey;
			TransferValidation = transferValidation;
			EncryptionScope = encryptionScope;
			TrimBlobNameSlashes = trimBlobNameSlashes;
		}

		public BlobClientConfiguration(HttpPipeline pipeline, AzureSasCredential sasCredential, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, BlobClientOptions.ServiceVersion version, CustomerProvidedKey? customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes)
			: base(pipeline, sasCredential, clientDiagnostics)
		{
			Version = version;
			CustomerProvidedKey = customerProvidedKey;
			TransferValidation = transferValidation;
			EncryptionScope = encryptionScope;
			TrimBlobNameSlashes = trimBlobNameSlashes;
		}

		public BlobClientConfiguration(HttpPipeline pipeline, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, BlobClientOptions.ServiceVersion version, CustomerProvidedKey? customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes)
			: base(pipeline, clientDiagnostics)
		{
			Version = version;
			CustomerProvidedKey = customerProvidedKey;
			TransferValidation = transferValidation;
			EncryptionScope = encryptionScope;
			TrimBlobNameSlashes = trimBlobNameSlashes;
		}

		internal BlobClientConfiguration(HttpPipeline pipeline, StorageSharedKeyCredential sharedKeyCredential, TokenCredential tokenCredential, AzureSasCredential sasCredential, Azure.Core.Pipeline.ClientDiagnostics clientDiagnostics, BlobClientOptions.ServiceVersion version, CustomerProvidedKey? customerProvidedKey, TransferValidationOptions transferValidation, string encryptionScope, bool trimBlobNameSlashes)
			: base(pipeline, sharedKeyCredential, sasCredential, tokenCredential, clientDiagnostics)
		{
			Version = version;
			CustomerProvidedKey = customerProvidedKey;
			TransferValidation = transferValidation;
			EncryptionScope = encryptionScope;
			TrimBlobNameSlashes = trimBlobNameSlashes;
		}

		internal static BlobClientConfiguration DeepCopy(BlobClientConfiguration originalClientConfiguration)
		{
			return new BlobClientConfiguration(originalClientConfiguration.Pipeline, originalClientConfiguration.SharedKeyCredential, originalClientConfiguration.TokenCredential, originalClientConfiguration.SasCredential, originalClientConfiguration.ClientDiagnostics, originalClientConfiguration.Version, originalClientConfiguration.CustomerProvidedKey, originalClientConfiguration.TransferValidation, originalClientConfiguration.EncryptionScope, originalClientConfiguration.TrimBlobNameSlashes);
		}
	}
	internal class BlobErrors : Azure.Storage.Errors
	{
		public static ArgumentOutOfRangeException BlobConditionsMustBeDefault(params string[] conditions)
		{
			return new ArgumentOutOfRangeException("The " + string.Join(" and ", conditions) + " conditions must have their default values because they are ignored by the blob service");
		}

		public static InvalidOperationException BlobOrContainerMissing(string leaseClient, string blobBaseClient, string blobContainerClient)
		{
			return new InvalidOperationException(leaseClient + " requires either a " + blobBaseClient + " or " + blobContainerClient);
		}

		public static ArgumentException InvalidDateTimeUtc(string dateTime)
		{
			return new ArgumentException(dateTime + " must be UTC");
		}

		internal static void VerifyHttpsCustomerProvidedKey(Uri uri, CustomerProvidedKey? customerProvidedKey)
		{
			if (customerProvidedKey.HasValue && !string.Equals(uri.Scheme, "https", StringComparison.OrdinalIgnoreCase))
			{
				throw new ArgumentException("Cannot use client-provided key without HTTPS.");
			}
		}

		internal static void VerifyCpkAndEncryptionScopeNotBothSet(CustomerProvidedKey? customerProvidedKey, string encryptionScope)
		{
			if (customerProvidedKey.HasValue && encryptionScope != null)
			{
				throw new ArgumentException("CustomerProvidedKey and EncryptionScope cannot both be set");
			}
		}

		public static ArgumentException ParsingFullHttpRangeFailed(string range)
		{
			return new ArgumentException("Could not obtain the total length from HTTP range " + range);
		}
	}
}
namespace Azure.Storage.Blobs.Models
{
	[CodeGenType("StorageBlobsModelFactory")]
	public static class BlobsModelFactory
	{
		public static UserDelegationKey UserDelegationKey(string signedObjectId = null, string signedTenantId = null, DateTimeOffset signedStartsOn = default(DateTimeOffset), DateTimeOffset signedExpiresOn = default(DateTimeOffset), string signedService = null, string signedVersion = null, string value = null)
		{
			if (signedObjectId == null)
			{
				throw new ArgumentNullException("signedObjectId");
			}
			if (signedTenantId == null)
			{
				throw new ArgumentNullException("signedTenantId");
			}
			if (signedService == null)
			{
				throw new ArgumentNullException("signedService");
			}
			if (signedVersion == null)
			{
				throw new ArgumentNullException("signedVersion");
			}
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			return new UserDelegationKey(signedObjectId, signedTenantId, signedStartsOn, signedExpiresOn, signedService, signedVersion, value);
		}

		public static BlobContentInfo BlobContentInfo(ETag eTag, DateTimeOffset lastModified, byte[] contentHash, string versionId, string encryptionKeySha256, string encryptionScope, long blobSequenceNumber)
		{
			return new BlobContentInfo
			{
				ETag = eTag,
				LastModified = lastModified,
				ContentHash = contentHash,
				VersionId = versionId,
				EncryptionKeySha256 = encryptionKeySha256,
				EncryptionScope = encryptionScope,
				BlobSequenceNumber = blobSequenceNumber
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobContentInfo BlobContentInfo(ETag eTag, DateTimeOffset lastModified, byte[] contentHash, string encryptionKeySha256, string encryptionScope, long blobSequenceNumber)
		{
			return new BlobContentInfo
			{
				ETag = eTag,
				LastModified = lastModified,
				ContentHash = contentHash,
				EncryptionKeySha256 = encryptionKeySha256,
				EncryptionScope = encryptionScope,
				BlobSequenceNumber = blobSequenceNumber
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobContentInfo BlobContentInfo(ETag eTag, DateTimeOffset lastModified, byte[] contentHash, string encryptionKeySha256, long blobSequenceNumber)
		{
			return new BlobContentInfo
			{
				ETag = eTag,
				LastModified = lastModified,
				ContentHash = contentHash,
				EncryptionKeySha256 = encryptionKeySha256,
				BlobSequenceNumber = blobSequenceNumber
			};
		}

		public static BlobAppendInfo BlobAppendInfo(ETag eTag, DateTimeOffset lastModified, byte[] contentHash, byte[] contentCrc64, string blobAppendOffset, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope)
		{
			return new BlobAppendInfo
			{
				ETag = eTag,
				LastModified = lastModified,
				ContentHash = contentHash,
				ContentCrc64 = contentCrc64,
				BlobAppendOffset = blobAppendOffset,
				BlobCommittedBlockCount = blobCommittedBlockCount,
				IsServerEncrypted = isServerEncrypted,
				EncryptionKeySha256 = encryptionKeySha256,
				EncryptionScope = encryptionScope
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobAppendInfo BlobAppendInfo(ETag eTag, DateTimeOffset lastModified, byte[] contentHash, byte[] contentCrc64, string blobAppendOffset, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256)
		{
			return new BlobAppendInfo
			{
				ETag = eTag,
				LastModified = lastModified,
				ContentHash = contentHash,
				ContentCrc64 = contentCrc64,
				BlobAppendOffset = blobAppendOffset,
				BlobCommittedBlockCount = blobCommittedBlockCount,
				IsServerEncrypted = isServerEncrypted,
				EncryptionKeySha256 = encryptionKeySha256
			};
		}

		public static BlobProperties BlobProperties(DateTimeOffset lastModified = default(DateTimeOffset), LeaseStatus leaseStatus = LeaseStatus.Locked, long contentLength = 0L, string contentType = null, ETag eTag = default(ETag), LeaseState leaseState = LeaseState.Available, string contentEncoding = null, string contentDisposition = null, string contentLanguage = null, string cacheControl = null, long blobSequenceNumber = 0L, LeaseDurationType leaseDuration = LeaseDurationType.Infinite, string acceptRanges = null, string destinationSnapshot = null, int blobCommittedBlockCount = 0, bool isIncrementalCopy = false, bool isServerEncrypted = false, CopyStatus? blobCopyStatus = null, string encryptionKeySha256 = null, Uri copySource = null, string encryptionScope = null, string copyProgress = null, string accessTier = null, string copyId = null, bool accessTierInferred = false, string copyStatusDescription = null, string archiveStatus = null, DateTimeOffset copyCompletedOn = default(DateTimeOffset), DateTimeOffset accessTierChangedOn = default(DateTimeOffset), BlobType blobType = BlobType.Block, string versionId = null, IList<ObjectReplicationPolicy> objectReplicationSourceProperties = null, bool isLatestVersion = false, string objectReplicationDestinationPolicyId = null, long tagCount = 0L, IDictionary<string, string> metadata = null, DateTimeOffset expiresOn = default(DateTimeOffset), DateTimeOffset createdOn = default(DateTimeOffset), bool isSealed = false, string rehydratePriority = null, byte[] contentHash = null, DateTimeOffset lastAccessed = default(DateTimeOffset), BlobImmutabilityPolicy immutabilityPolicy = null, bool hasLegalHold = false)
		{
			return new BlobProperties(lastModified, createdOn, metadata, objectReplicationDestinationPolicyId, objectReplicationSourceProperties, blobType, copyCompletedOn, copyStatusDescription, copyId, copyProgress, copySource, blobCopyStatus, isIncrementalCopy, destinationSnapshot, leaseDuration, leaseState, leaseStatus, contentLength, contentType, eTag, contentHash, contentEncoding, contentDisposition, contentLanguage, cacheControl, blobSequenceNumber, acceptRanges, blobCommittedBlockCount, isServerEncrypted, encryptionKeySha256, encryptionScope, accessTier, accessTierInferred, archiveStatus, accessTierChangedOn, versionId, isLatestVersion, tagCount, expiresOn, isSealed, rehydratePriority, lastAccessed, immutabilityPolicy, hasLegalHold);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, LeaseState leaseState, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, long blobSequenceNumber, LeaseDurationType leaseDuration, string acceptRanges, string destinationSnapshot, int blobCommittedBlockCount, bool isIncrementalCopy, bool isServerEncrypted, CopyStatus copyStatus, string encryptionKeySha256, Uri copySource, string encryptionScope, string copyProgress, string accessTier, string copyId, bool accessTierInferred, string copyStatusDescription, string archiveStatus, DateTimeOffset copyCompletedOn, DateTimeOffset accessTierChangedOn, BlobType blobType, string versionId, IList<ObjectReplicationPolicy> objectReplicationSourceProperties, bool isLatestVersion, string objectReplicationDestinationPolicyId, long tagCount, IDictionary<string, string> metadata, DateTimeOffset expiresOn, DateTimeOffset createdOn, bool isSealed, string rehydratePriority, byte[] contentHash, DateTimeOffset lastAccessed, BlobImmutabilityPolicy immutabilityPolicy, bool hasLegalHold)
		{
			return new BlobProperties(lastModified, createdOn, metadata, objectReplicationDestinationPolicyId, objectReplicationSourceProperties, blobType, copyCompletedOn, copyStatusDescription, copyId, copyProgress, copySource, copyStatus, isIncrementalCopy, destinationSnapshot, leaseDuration, leaseState, leaseStatus, contentLength, contentType, eTag, contentHash, contentEncoding, contentDisposition, contentLanguage, cacheControl, blobSequenceNumber, acceptRanges, blobCommittedBlockCount, isServerEncrypted, encryptionKeySha256, encryptionScope, accessTier, accessTierInferred, archiveStatus, accessTierChangedOn, versionId, isLatestVersion, tagCount, expiresOn, isSealed, rehydratePriority, lastAccessed, immutabilityPolicy, hasLegalHold);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, LeaseState leaseState, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, long blobSequenceNumber, LeaseDurationType leaseDuration, string acceptRanges, string destinationSnapshot, int blobCommittedBlockCount, bool isIncrementalCopy, bool isServerEncrypted, CopyStatus copyStatus, string encryptionKeySha256, Uri copySource, string encryptionScope, string copyProgress, string accessTier, string copyId, bool accessTierInferred, string copyStatusDescription, string archiveStatus, DateTimeOffset copyCompletedOn, DateTimeOffset accessTierChangedOn, BlobType blobType, string versionId, IList<ObjectReplicationPolicy> objectReplicationSourceProperties, bool isLatestVersion, string objectReplicationDestinationPolicyId, long tagCount, IDictionary<string, string> metadata, DateTimeOffset expiresOn, DateTimeOffset createdOn, bool isSealed, string rehydratePriority, byte[] contentHash, DateTimeOffset lastAccessed)
		{
			return new BlobProperties(lastModified, createdOn, metadata, objectReplicationDestinationPolicyId, objectReplicationSourceProperties, blobType, copyCompletedOn, copyStatusDescription, copyId, copyProgress, copySource, copyStatus, isIncrementalCopy, destinationSnapshot, leaseDuration, leaseState, leaseStatus, contentLength, contentType, eTag, contentHash, contentEncoding, contentDisposition, contentLanguage, cacheControl, blobSequenceNumber, acceptRanges, blobCommittedBlockCount, isServerEncrypted, encryptionKeySha256, encryptionScope, accessTier, accessTierInferred, archiveStatus, accessTierChangedOn, versionId, isLatestVersion, tagCount, expiresOn, isSealed, rehydratePriority, lastAccessed, new BlobImmutabilityPolicy(), hasLegalHold: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, LeaseState leaseState, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, long blobSequenceNumber, LeaseDurationType leaseDuration, string acceptRanges, string destinationSnapshot, int blobCommittedBlockCount, bool isIncrementalCopy, bool isServerEncrypted, CopyStatus copyStatus, string encryptionKeySha256, Uri copySource, string encryptionScope, string copyProgress, string accessTier, string copyId, bool accessTierInferred, string copyStatusDescription, string archiveStatus, DateTimeOffset copyCompletedOn, DateTimeOffset accessTierChangedOn, BlobType blobType, string versionId, IList<ObjectReplicationPolicy> objectReplicationSourceProperties, bool isLatestVersion, string objectReplicationDestinationPolicyId, long tagCount, IDictionary<string, string> metadata, DateTimeOffset expiresOn, DateTimeOffset createdOn, bool isSealed, string rehydratePriority, byte[] contentHash)
		{
			return new BlobProperties(lastModified, createdOn, metadata, objectReplicationDestinationPolicyId, objectReplicationSourceProperties, blobType, copyCompletedOn, copyStatusDescription, copyId, copyProgress, copySource, copyStatus, isIncrementalCopy, destinationSnapshot, leaseDuration, leaseState, leaseStatus, contentLength, contentType, eTag, contentHash, contentEncoding, contentDisposition, contentLanguage, cacheControl, blobSequenceNumber, acceptRanges, blobCommittedBlockCount, isServerEncrypted, encryptionKeySha256, encryptionScope, accessTier, accessTierInferred, archiveStatus, accessTierChangedOn, versionId, isLatestVersion, tagCount, expiresOn, isSealed, rehydratePriority, default(DateTimeOffset), new BlobImmutabilityPolicy(), hasLegalHold: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseState leaseState, LeaseStatus leaseStatus, long contentLength, LeaseDurationType leaseDuration, ETag eTag, byte[] contentHash, string contentEncoding, string contentDisposition, string contentLanguage, string destinationSnapshot, string cacheControl, bool isIncrementalCopy, long blobSequenceNumber, CopyStatus copyStatus, string acceptRanges, Uri copySource, int blobCommittedBlockCount, string copyProgress, bool isServerEncrypted, string copyId, string encryptionKeySha256, string copyStatusDescription, string encryptionScope, DateTimeOffset copyCompletedOn, string accessTier, BlobType blobType, bool accessTierInferred, IDictionary<string, string> metadata, string archiveStatus, DateTimeOffset createdOn, DateTimeOffset accessTierChangedOn, string contentType)
		{
			return new BlobProperties(lastModified, createdOn, metadata, null, null, blobType, copyCompletedOn, copyStatusDescription, copyId, copyProgress, copySource, copyStatus, isIncrementalCopy, destinationSnapshot, leaseDuration, leaseState, leaseStatus, contentLength, contentType, eTag, contentHash, contentEncoding, contentDisposition, contentLanguage, cacheControl, blobSequenceNumber, acceptRanges, blobCommittedBlockCount, isServerEncrypted, encryptionKeySha256, encryptionScope, accessTier, accessTierInferred, archiveStatus, accessTierChangedOn, null, isLatestVersion: false, 0L, default(DateTimeOffset), isSealed: false, null, default(DateTimeOffset), new BlobImmutabilityPolicy(), hasLegalHold: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobProperties BlobProperties(DateTimeOffset lastModified, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, long contentLength, string destinationSnapshot, ETag eTag, byte[] contentHash, string contentEncoding, string contentDisposition, string contentLanguage, bool isIncrementalCopy, string cacheControl, CopyStatus copyStatus, long blobSequenceNumber, Uri copySource, string acceptRanges, string copyProgress, int blobCommittedBlockCount, string copyId, bool isServerEncrypted, string copyStatusDescription, string encryptionKeySha256, DateTimeOffset copyCompletedOn, string accessTier, BlobType blobType, bool accessTierInferred, IDictionary<string, string> metadata, string archiveStatus, DateTimeOffset createdOn, DateTimeOffset accessTierChangedOn, string contentType)
		{
			return new BlobProperties(lastModified, createdOn, metadata, null, null, blobType, copyCompletedOn, copyStatusDescription, copyId, copyProgress, copySource, copyStatus, isIncrementalCopy, destinationSnapshot, leaseDuration, leaseState, leaseStatus, contentLength, contentType, eTag, contentHash, contentEncoding, contentDisposition, contentLanguage, cacheControl, blobSequenceNumber, acceptRanges, blobCommittedBlockCount, isServerEncrypted, encryptionKeySha256, null, accessTier, accessTierInferred, archiveStatus, accessTierChangedOn, null, isLatestVersion: false, 0L, default(DateTimeOffset), isSealed: false, null, default(DateTimeOffset), new BlobImmutabilityPolicy(), hasLegalHold: false);
		}

		public static BlobItemProperties BlobItemProperties(bool accessTierInferred, bool? serverEncrypted = null, string contentType = null, string contentEncoding = null, string contentLanguage = null, byte[] contentHash = null, string contentDisposition = null, string cacheControl = null, long? blobSequenceNumber = null, BlobType? blobType = null, LeaseStatus? leaseStatus = null, LeaseState? leaseState = null, LeaseDurationType? leaseDuration = null, string copyId = null, CopyStatus? copyStatus = null, Uri copySource = null, string copyProgress = null, string copyStatusDescription = null, long? contentLength = null, bool? incrementalCopy = null, string destinationSnapshot = null, int? remainingRetentionDays = null, AccessTier? accessTier = null, DateTimeOffset? lastModified = null, ArchiveStatus? archiveStatus = null, string customerProvidedKeySha256 = null, string encryptionScope = null, long? tagCount = null, DateTimeOffset? expiresOn = null, bool? isSealed = null, RehydratePriority? rehydratePriority = null, DateTimeOffset? lastAccessedOn = null, ETag? eTag = null, DateTimeOffset? createdOn = null, DateTimeOffset? copyCompletedOn = null, DateTimeOffset? deletedOn = null, DateTimeOffset? accessTierChangedOn = null)
		{
			return new BlobItemProperties
			{
				AccessTierInferred = accessTierInferred,
				ServerEncrypted = serverEncrypted,
				ContentType = contentType,
				ContentEncoding = contentEncoding,
				ContentLanguage = contentLanguage,
				ContentHash = contentHash,
				ContentDisposition = contentDisposition,
				CacheControl = cacheControl,
				BlobSequenceNumber = blobSequenceNumber,
				BlobType = blobType,
				LeaseStatus = leaseStatus,
				LeaseState = leaseState,
				LeaseDuration = leaseDuration,
				CopyId = copyId,
				CopyStatus = copyStatus,
				CopySource = copySource,
				CopyProgress = copyProgress,
				CopyStatusDescription = copyStatusDescription,
				ContentLength = contentLength,
				IncrementalCopy = incrementalCopy,
				DestinationSnapshot = destinationSnapshot,
				RemainingRetentionDays = remainingRetentionDays,
				AccessTier = accessTier,
				LastModified = lastModified,
				ArchiveStatus = archiveStatus,
				CustomerProvidedKeySha256 = customerProvidedKeySha256,
				EncryptionScope = encryptionScope,
				TagCount = tagCount,
				ExpiresOn = expiresOn,
				IsSealed = isSealed,
				RehydratePriority = rehydratePriority,
				LastAccessedOn = lastAccessedOn,
				ETag = eTag,
				CreatedOn = createdOn,
				CopyCompletedOn = copyCompletedOn,
				DeletedOn = deletedOn,
				AccessTierChangedOn = accessTierChangedOn
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobItemProperties BlobItemProperties(bool accessTierInferred, bool? serverEncrypted, string contentType, string contentEncoding, string contentLanguage, byte[] contentHash, string contentDisposition, string cacheControl, long? blobSequenceNumber, BlobType? blobType, LeaseStatus? leaseStatus, LeaseState? leaseState, LeaseDurationType? leaseDuration, string copyId, CopyStatus? copyStatus, Uri copySource, string copyProgress, string copyStatusDescription, long? contentLength, bool? incrementalCopy, string destinationSnapshot, int? remainingRetentionDays, AccessTier? accessTier, DateTimeOffset? lastModified, ArchiveStatus? archiveStatus, string customerProvidedKeySha256, string encryptionScope, long? tagCount, DateTimeOffset? expiresOn, bool? isSealed, RehydratePriority? rehydratePriority, ETag? eTag, DateTimeOffset? createdOn, DateTimeOffset? copyCompletedOn, DateTimeOffset? deletedOn, DateTimeOffset? accessTierChangedOn)
		{
			return new BlobItemProperties
			{
				AccessTierInferred = accessTierInferred,
				ServerEncrypted = serverEncrypted,
				ContentType = contentType,
				ContentEncoding = contentEncoding,
				ContentLanguage = contentLanguage,
				ContentHash = contentHash,
				ContentDisposition = contentDisposition,
				CacheControl = cacheControl,
				BlobSequenceNumber = blobSequenceNumber,
				BlobType = blobType,
				LeaseStatus = leaseStatus,
				LeaseState = leaseState,
				LeaseDuration = leaseDuration,
				CopyId = copyId,
				CopyStatus = copyStatus,
				CopySource = copySource,
				CopyProgress = copyProgress,
				CopyStatusDescription = copyStatusDescription,
				ContentLength = contentLength,
				IncrementalCopy = incrementalCopy,
				DestinationSnapshot = destinationSnapshot,
				RemainingRetentionDays = remainingRetentionDays,
				AccessTier = accessTier,
				LastModified = lastModified,
				ArchiveStatus = archiveStatus,
				CustomerProvidedKeySha256 = customerProvidedKeySha256,
				EncryptionScope = encryptionScope,
				TagCount = tagCount,
				ExpiresOn = expiresOn,
				IsSealed = isSealed,
				RehydratePriority = rehydratePriority,
				ETag = eTag,
				CreatedOn = createdOn,
				CopyCompletedOn = copyCompletedOn,
				DeletedOn = deletedOn,
				AccessTierChangedOn = accessTierChangedOn
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobItemProperties BlobItemProperties(bool accessTierInferred, string copyProgress, string contentType, string contentEncoding, string contentLanguage, byte[] contentHash, string contentDisposition, string cacheControl, long? blobSequenceNumber, BlobType? blobType, LeaseStatus? leaseStatus, LeaseState? leaseState, LeaseDurationType? leaseDuration, string copyId, CopyStatus? copyStatus, Uri copySource, long? contentLength, string copyStatusDescription, bool? serverEncrypted, bool? incrementalCopy, string destinationSnapshot, int? remainingRetentionDays, AccessTier? accessTier, DateTimeOffset? lastModified, ArchiveStatus? archiveStatus, string customerProvidedKeySha256, string encryptionScope, ETag? eTag, DateTimeOffset? createdOn, DateTimeOffset? copyCompletedOn, DateTimeOffset? deletedOn, DateTimeOffset? accessTierChangedOn)
		{
			return new BlobItemProperties
			{
				AccessTierInferred = accessTierInferred,
				CopyProgress = copyProgress,
				ContentType = contentType,
				ContentEncoding = contentEncoding,
				ContentLanguage = contentLanguage,
				ContentHash = contentHash,
				ContentDisposition = contentDisposition,
				CacheControl = cacheControl,
				BlobSequenceNumber = blobSequenceNumber,
				BlobType = blobType,
				LeaseStatus = leaseStatus,
				LeaseState = leaseState,
				LeaseDuration = leaseDuration,
				CopyId = copyId,
				CopyStatus = copyStatus,
				CopySource = copySource,
				ContentLength = contentLength,
				CopyStatusDescription = copyStatusDescription,
				ServerEncrypted = serverEncrypted,
				IncrementalCopy = incrementalCopy,
				DestinationSnapshot = destinationSnapshot,
				RemainingRetentionDays = remainingRetentionDays,
				AccessTier = accessTier,
				LastModified = lastModified,
				ArchiveStatus = archiveStatus,
				CustomerProvidedKeySha256 = customerProvidedKeySha256,
				EncryptionScope = encryptionScope,
				ETag = eTag,
				CreatedOn = createdOn,
				CopyCompletedOn = copyCompletedOn,
				DeletedOn = deletedOn,
				AccessTierChangedOn = accessTierChangedOn
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobItemProperties BlobItemProperties(bool accessTierInferred, Uri copySource, string contentType, string contentEncoding, string contentLanguage, byte[] contentHash, string contentDisposition, string cacheControl, long? blobSequenceNumber, BlobType? blobType, LeaseStatus? leaseStatus, LeaseState? leaseState, LeaseDurationType? leaseDuration, string copyId, CopyStatus? copyStatus, long? contentLength, string copyProgress, string copyStatusDescription, bool? serverEncrypted, bool? incrementalCopy, string destinationSnapshot, int? remainingRetentionDays, AccessTier? accessTier, DateTimeOffset? lastModified, ArchiveStatus? archiveStatus, string customerProvidedKeySha256, ETag? eTag, DateTimeOffset? createdOn, DateTimeOffset? copyCompletedOn, DateTimeOffset? deletedOn, DateTimeOffset? accessTierChangedOn)
		{
			return new BlobItemProperties
			{
				AccessTierInferred = accessTierInferred,
				CopyProgress = copyProgress,
				ContentType = contentType,
				ContentEncoding = contentEncoding,
				ContentLanguage = contentLanguage,
				ContentHash = contentHash,
				ContentDisposition = contentDisposition,
				CacheControl = cacheControl,
				BlobSequenceNumber = blobSequenceNumber,
				BlobType = blobType,
				LeaseStatus = leaseStatus,
				LeaseState = leaseState,
				LeaseDuration = leaseDuration,
				CopyId = copyId,
				CopyStatus = copyStatus,
				CopySource = copySource,
				ContentLength = contentLength,
				CopyStatusDescription = copyStatusDescription,
				ServerEncrypted = serverEncrypted,
				IncrementalCopy = incrementalCopy,
				DestinationSnapshot = destinationSnapshot,
				RemainingRetentionDays = remainingRetentionDays,
				AccessTier = accessTier,
				LastModified = lastModified,
				ArchiveStatus = archiveStatus,
				CustomerProvidedKeySha256 = customerProvidedKeySha256,
				ETag = eTag,
				CreatedOn = createdOn,
				CopyCompletedOn = copyCompletedOn,
				DeletedOn = deletedOn,
				AccessTierChangedOn = accessTierChangedOn
			};
		}

		public static BlockInfo BlockInfo(byte[] contentHash, byte[] contentCrc64, string encryptionKeySha256, string encryptionScope)
		{
			return new BlockInfo
			{
				ContentHash = contentHash,
				ContentCrc64 = contentCrc64,
				EncryptionKeySha256 = encryptionKeySha256,
				EncryptionScope = encryptionScope
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlockInfo BlockInfo(byte[] contentHash, byte[] contentCrc64, string encryptionKeySha256)
		{
			return new BlockInfo
			{
				ContentHash = contentHash,
				ContentCrc64 = contentCrc64,
				EncryptionKeySha256 = encryptionKeySha256
			};
		}

		public static PageInfo PageInfo(ETag eTag, DateTimeOffset lastModified, byte[] contentHash, byte[] contentCrc64, long blobSequenceNumber, string encryptionKeySha256, string encryptionScope)
		{
			return new PageInfo
			{
				ETag = eTag,
				LastModified = lastModified,
				ContentHash = contentHash,
				ContentCrc64 = contentCrc64,
				BlobSequenceNumber = blobSequenceNumber,
				EncryptionKeySha256 = encryptionKeySha256,
				EncryptionScope = encryptionScope
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static PageInfo PageInfo(ETag eTag, DateTimeOffset lastModified, byte[] contentHash, byte[] contentCrc64, long blobSequenceNumber, string encryptionKeySha256)
		{
			return new PageInfo
			{
				ETag = eTag,
				LastModified = lastModified,
				ContentHash = contentHash,
				ContentCrc64 = contentCrc64,
				BlobSequenceNumber = blobSequenceNumber,
				EncryptionKeySha256 = encryptionKeySha256
			};
		}

		public static BlobContainerProperties BlobContainerProperties(DateTimeOffset lastModified, ETag eTag, LeaseState? leaseState = null, LeaseDurationType? leaseDuration = null, PublicAccessType? publicAccess = null, bool? hasImmutabilityPolicy = null, LeaseStatus? leaseStatus = null, string defaultEncryptionScope = null, bool? preventEncryptionScopeOverride = null, DateTimeOffset? deletedOn = null, int? remainingRetentionDays = null, IDictionary<string, string> metadata = null, bool? hasLegalHold = null)
		{
			return new BlobContainerProperties
			{
				LastModified = lastModified,
				ETag = eTag,
				LeaseState = leaseState,
				LeaseDuration = leaseDuration,
				PublicAccess = publicAccess,
				HasImmutabilityPolicy = hasImmutabilityPolicy,
				LeaseStatus = leaseStatus,
				DefaultEncryptionScope = defaultEncryptionScope,
				PreventEncryptionScopeOverride = preventEncryptionScopeOverride,
				DeletedOn = deletedOn,
				RemainingRetentionDays = remainingRetentionDays,
				Metadata = metadata,
				HasLegalHold = hasLegalHold
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobContainerProperties BlobContainerProperties(DateTimeOffset lastModified, ETag eTag, LeaseStatus? leaseStatus, LeaseState? leaseState, LeaseDurationType? leaseDuration, PublicAccessType? publicAccess, bool? hasImmutabilityPolicy, bool? hasLegalHold, IDictionary<string, string> metadata)
		{
			return new BlobContainerProperties
			{
				LastModified = lastModified,
				ETag = eTag,
				LeaseState = leaseState,
				LeaseDuration = leaseDuration,
				PublicAccess = publicAccess,
				LeaseStatus = leaseStatus,
				HasLegalHold = hasLegalHold,
				Metadata = metadata,
				HasImmutabilityPolicy = hasImmutabilityPolicy
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobContainerProperties BlobContainerProperties(DateTimeOffset lastModified, ETag eTag, LeaseState? leaseState, LeaseDurationType? leaseDuration, PublicAccessType? publicAccess, bool? hasImmutabilityPolicy, LeaseStatus? leaseStatus, string defaultEncryptionScope, bool? preventEncryptionScopeOverride, IDictionary<string, string> metadata, bool? hasLegalHold)
		{
			return new BlobContainerProperties
			{
				LastModified = lastModified,
				ETag = eTag,
				LeaseState = leaseState,
				LeaseDuration = leaseDuration,
				PublicAccess = publicAccess,
				HasImmutabilityPolicy = hasImmutabilityPolicy,
				LeaseStatus = leaseStatus,
				DefaultEncryptionScope = defaultEncryptionScope,
				PreventEncryptionScopeOverride = preventEncryptionScopeOverride,
				Metadata = metadata,
				HasLegalHold = hasLegalHold
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobContainerProperties BlobContainerProperties(DateTimeOffset lastModified, ETag eTag, LeaseState? leaseState, LeaseDurationType? leaseDuration, PublicAccessType? publicAccess, LeaseStatus? leaseStatus, bool? hasLegalHold, string defaultEncryptionScope, bool? preventEncryptionScopeOverride, IDictionary<string, string> metadata, bool? hasImmutabilityPolicy)
		{
			return new BlobContainerProperties
			{
				LastModified = lastModified,
				ETag = eTag,
				LeaseState = leaseState,
				LeaseDuration = leaseDuration,
				PublicAccess = publicAccess,
				LeaseStatus = leaseStatus,
				HasLegalHold = hasLegalHold,
				DefaultEncryptionScope = defaultEncryptionScope,
				PreventEncryptionScopeOverride = preventEncryptionScopeOverride,
				Metadata = metadata,
				HasImmutabilityPolicy = hasImmutabilityPolicy
			};
		}

		public static BlobCopyInfo BlobCopyInfo(ETag eTag, DateTimeOffset lastModified, string versionId, string copyId, CopyStatus copyStatus)
		{
			return new BlobCopyInfo
			{
				ETag = eTag,
				LastModified = lastModified,
				VersionId = versionId,
				CopyId = copyId,
				CopyStatus = copyStatus
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobCopyInfo BlobCopyInfo(ETag eTag, DateTimeOffset lastModified, string copyId, CopyStatus copyStatus)
		{
			return new BlobCopyInfo
			{
				ETag = eTag,
				LastModified = lastModified,
				CopyId = copyId,
				CopyStatus = copyStatus
			};
		}

		public static BlobItem BlobItem(string name = null, bool deleted = false, BlobItemProperties properties = null, string snapshot = null, string versionId = null, bool? isLatestVersion = null, IDictionary<string, string> metadata = null, IDictionary<string, string> tags = null, List<ObjectReplicationPolicy> objectReplicationSourcePolicies = null, bool? hasVersionsOnly = null)
		{
			return new BlobItem
			{
				Name = name,
				Deleted = deleted,
				Properties = properties,
				Snapshot = snapshot,
				VersionId = versionId,
				IsLatestVersion = isLatestVersion,
				Metadata = metadata,
				Tags = tags,
				ObjectReplicationSourceProperties = objectReplicationSourcePolicies,
				HasVersionsOnly = hasVersionsOnly
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobItem BlobItem(string name, bool deleted, BlobItemProperties properties, string snapshot, string versionId, bool? isLatestVersion, IDictionary<string, string> metadata, IDictionary<string, string> tags, List<ObjectReplicationPolicy> objectReplicationSourcePolicies)
		{
			return new BlobItem
			{
				Name = name,
				Deleted = deleted,
				Properties = properties,
				Snapshot = snapshot,
				VersionId = versionId,
				IsLatestVersion = isLatestVersion,
				Metadata = metadata,
				Tags = tags,
				ObjectReplicationSourceProperties = objectReplicationSourcePolicies
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobItem BlobItem(string name, bool deleted, BlobItemProperties properties, string snapshot, IDictionary<string, string> metadata)
		{
			return new BlobItem
			{
				Name = name,
				Deleted = deleted,
				Properties = properties,
				Snapshot = snapshot,
				Metadata = metadata
			};
		}

		public static BlobSnapshotInfo BlobSnapshotInfo(string snapshot, ETag eTag, DateTimeOffset lastModified, string versionId, bool isServerEncrypted)
		{
			return new BlobSnapshotInfo
			{
				Snapshot = snapshot,
				ETag = eTag,
				LastModified = lastModified,
				VersionId = versionId,
				IsServerEncrypted = isServerEncrypted
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobSnapshotInfo BlobSnapshotInfo(string snapshot, ETag eTag, DateTimeOffset lastModified, bool isServerEncrypted)
		{
			return new BlobSnapshotInfo
			{
				Snapshot = snapshot,
				ETag = eTag,
				LastModified = lastModified,
				IsServerEncrypted = isServerEncrypted
			};
		}

		public static BlobInfo blobInfo(ETag eTag = default(ETag), DateTimeOffset lastModifed = default(DateTimeOffset), long blobSequenceNumber = 0L, string versionId = null)
		{
			return new BlobInfo
			{
				ETag = eTag,
				LastModified = lastModifed,
				BlobSequenceNumber = blobSequenceNumber,
				VersionId = versionId
			};
		}

		public static BlobContainerItem BlobContainerItem(string name, BlobContainerProperties properties, bool? isDeleted = null, string versionId = null)
		{
			return new BlobContainerItem
			{
				Name = name,
				Properties = properties,
				IsDeleted = isDeleted,
				VersionId = versionId
			};
		}

		public static BlobContainerInfo BlobContainerInfo(ETag eTag, DateTimeOffset lastModified)
		{
			return new BlobContainerInfo
			{
				ETag = eTag,
				LastModified = lastModified
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobContainerItem BlobContainerItem(string name, BlobContainerProperties properties)
		{
			return new BlobContainerItem
			{
				Name = name,
				Properties = properties
			};
		}

		public static BlobQueryError BlobQueryError(string name = null, string description = null, bool isFatal = false, long position = 0L)
		{
			return new BlobQueryError
			{
				Name = name,
				Description = description,
				IsFatal = isFatal,
				Position = position
			};
		}

		public static GetBlobTagResult GetBlobTagResult(IDictionary<string, string> tags)
		{
			return new GetBlobTagResult
			{
				Tags = tags
			};
		}

		public static TaggedBlobItem TaggedBlobItem(string blobName = null, string blobContainerName = null, IDictionary<string, string> tags = null)
		{
			return new TaggedBlobItem
			{
				BlobName = blobName,
				BlobContainerName = blobContainerName,
				Tags = tags
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static TaggedBlobItem TaggedBlobItem(string blobName = null, string blobContainerName = null)
		{
			return new TaggedBlobItem
			{
				BlobName = blobName,
				BlobContainerName = blobContainerName
			};
		}

		public static ObjectReplicationPolicy ObjectReplicationPolicy(string policyId, IList<ObjectReplicationRule> rules)
		{
			return new ObjectReplicationPolicy
			{
				PolicyId = policyId,
				Rules = rules
			};
		}

		public static ObjectReplicationRule ObjectReplicationRule(string ruleId, ObjectReplicationStatus replicationStatus)
		{
			return new ObjectReplicationRule
			{
				RuleId = ruleId,
				ReplicationStatus = replicationStatus
			};
		}

		public static BlobDownloadDetails BlobDownloadDetails(BlobType blobType, long contentLength, string contentType, byte[] contentHash, DateTimeOffset lastModified, IDictionary<string, string> metadata, string contentRange, string contentEncoding, string cacheControl, string contentDisposition, string contentLanguage, long blobSequenceNumber, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, string acceptRanges, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope, byte[] blobContentHash, long tagCount, string versionId, bool isSealed, IList<ObjectReplicationPolicy> objectReplicationSourceProperties, string objectReplicationDestinationPolicy, bool hasLegalHold, DateTimeOffset createdOn)
		{
			return new BlobDownloadDetails
			{
				BlobType = blobType,
				ContentLength = contentLength,
				ContentType = contentType,
				ContentHash = contentHash,
				LastModified = lastModified,
				Metadata = metadata,
				ContentRange = contentRange,
				ContentEncoding = contentEncoding,
				CacheControl = cacheControl,
				ContentDisposition = contentDisposition,
				ContentLanguage = contentLanguage,
				BlobSequenceNumber = blobSequenceNumber,
				CopyCompletedOn = copyCompletedOn,
				CopyStatusDescription = copyStatusDescription,
				CopyId = copyId,
				CopyProgress = copyProgress,
				CopySource = copySource,
				CopyStatus = copyStatus,
				LeaseDuration = leaseDuration,
				LeaseState = leaseState,
				LeaseStatus = leaseStatus,
				AcceptRanges = acceptRanges,
				BlobCommittedBlockCount = blobCommittedBlockCount,
				IsServerEncrypted = isServerEncrypted,
				EncryptionKeySha256 = encryptionKeySha256,
				EncryptionScope = encryptionScope,
				BlobContentHash = blobContentHash,
				TagCount = tagCount,
				VersionId = versionId,
				IsSealed = isSealed,
				ObjectReplicationSourceProperties = objectReplicationSourceProperties,
				ObjectReplicationDestinationPolicyId = objectReplicationDestinationPolicy,
				HasLegalHold = hasLegalHold,
				CreatedOn = createdOn
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobDownloadDetails BlobDownloadDetails(DateTimeOffset lastModified, IDictionary<string, string> metadata, string contentRange, string contentEncoding, string cacheControl, string contentDisposition, string contentLanguage, long blobSequenceNumber, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, string acceptRanges, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope, byte[] blobContentHash, long tagCount, string versionId, bool isSealed, IList<ObjectReplicationPolicy> objectReplicationSourceProperties, string objectReplicationDestinationPolicy)
		{
			return new BlobDownloadDetails
			{
				LastModified = lastModified,
				Metadata = metadata,
				ContentRange = contentRange,
				ContentEncoding = contentEncoding,
				CacheControl = cacheControl,
				ContentDisposition = contentDisposition,
				ContentLanguage = contentLanguage,
				BlobSequenceNumber = blobSequenceNumber,
				CopyCompletedOn = copyCompletedOn,
				CopyStatusDescription = copyStatusDescription,
				CopyId = copyId,
				CopyProgress = copyProgress,
				CopySource = copySource,
				CopyStatus = copyStatus,
				LeaseDuration = leaseDuration,
				LeaseState = leaseState,
				LeaseStatus = leaseStatus,
				AcceptRanges = acceptRanges,
				BlobCommittedBlockCount = blobCommittedBlockCount,
				IsServerEncrypted = isServerEncrypted,
				EncryptionKeySha256 = encryptionKeySha256,
				EncryptionScope = encryptionScope,
				BlobContentHash = blobContentHash,
				TagCount = tagCount,
				VersionId = versionId,
				IsSealed = isSealed,
				ObjectReplicationSourceProperties = objectReplicationSourceProperties,
				ObjectReplicationDestinationPolicyId = objectReplicationDestinationPolicy
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobDownloadDetails BlobDownloadDetails(BlobType blobType, long contentLength, string contentType, byte[] contentHash, DateTimeOffset lastModified, IDictionary<string, string> metadata, string contentRange, string contentEncoding, string cacheControl, string contentDisposition, string contentLanguage, long blobSequenceNumber, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, string acceptRanges, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope, byte[] blobContentHash, long tagCount, string versionId, bool isSealed, IList<ObjectReplicationPolicy> objectReplicationSourceProperties, string objectReplicationDestinationPolicy)
		{
			return new BlobDownloadDetails
			{
				BlobType = blobType,
				ContentLength = contentLength,
				ContentType = contentType,
				ContentHash = contentHash,
				LastModified = lastModified,
				Metadata = metadata,
				ContentRange = contentRange,
				ContentEncoding = contentEncoding,
				CacheControl = cacheControl,
				ContentDisposition = contentDisposition,
				ContentLanguage = contentLanguage,
				BlobSequenceNumber = blobSequenceNumber,
				CopyCompletedOn = copyCompletedOn,
				CopyStatusDescription = copyStatusDescription,
				CopyId = copyId,
				CopyProgress = copyProgress,
				CopySource = copySource,
				CopyStatus = copyStatus,
				LeaseDuration = leaseDuration,
				LeaseState = leaseState,
				LeaseStatus = leaseStatus,
				AcceptRanges = acceptRanges,
				BlobCommittedBlockCount = blobCommittedBlockCount,
				IsServerEncrypted = isServerEncrypted,
				EncryptionKeySha256 = encryptionKeySha256,
				EncryptionScope = encryptionScope,
				BlobContentHash = blobContentHash,
				TagCount = tagCount,
				VersionId = versionId,
				IsSealed = isSealed,
				ObjectReplicationSourceProperties = objectReplicationSourceProperties,
				ObjectReplicationDestinationPolicyId = objectReplicationDestinationPolicy
			};
		}

		public static AccountInfo AccountInfo(SkuName skuName, AccountKind accountKind, bool isHierarchicalNamespaceEnabled)
		{
			return new AccountInfo
			{
				SkuName = skuName,
				AccountKind = accountKind,
				IsHierarchicalNamespaceEnabled = isHierarchicalNamespaceEnabled
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static AccountInfo AccountInfo(SkuName skuName, AccountKind accountKind)
		{
			return new AccountInfo
			{
				SkuName = skuName,
				AccountKind = accountKind
			};
		}

		public static BlobContainerAccessPolicy BlobContainerAccessPolicy(PublicAccessType blobPublicAccess, ETag eTag, DateTimeOffset lastModified, IEnumerable<BlobSignedIdentifier> signedIdentifiers)
		{
			return new BlobContainerAccessPolicy
			{
				BlobPublicAccess = blobPublicAccess,
				ETag = eTag,
				LastModified = lastModified,
				SignedIdentifiers = signedIdentifiers
			};
		}

		public static PageBlobInfo PageBlobInfo(ETag eTag, DateTimeOffset lastModified, long blobSequenceNumber)
		{
			return new PageBlobInfo
			{
				ETag = eTag,
				LastModified = lastModified,
				BlobSequenceNumber = blobSequenceNumber
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobBlock BlobBlock(string name, int size)
		{
			return new BlobBlock(name, size);
		}

		public static BlobBlock BlobBlock(string name, long size)
		{
			return new BlobBlock(name, size);
		}

		public static BlobGeoReplication BlobGeoReplication(BlobGeoReplicationStatus status, DateTimeOffset? lastSyncedOn = null)
		{
			return new BlobGeoReplication(status, lastSyncedOn);
		}

		public static BlobInfo BlobInfo(ETag eTag, DateTimeOffset lastModified)
		{
			return new BlobInfo
			{
				ETag = eTag,
				LastModified = lastModified
			};
		}

		public static BlobLease BlobLease(ETag eTag, DateTimeOffset lastModified, string leaseId)
		{
			return new BlobLease
			{
				ETag = eTag,
				LastModified = lastModified,
				LeaseId = leaseId
			};
		}

		public static BlobServiceStatistics BlobServiceStatistics(BlobGeoReplication geoReplication = null)
		{
			return new BlobServiceStatistics(geoReplication);
		}

		public static BlockList BlockList(IEnumerable<BlobBlock> committedBlocks = null, IEnumerable<BlobBlock> uncommittedBlocks = null)
		{
			return new BlockList
			{
				CommittedBlocks = committedBlocks,
				UncommittedBlocks = uncommittedBlocks
			};
		}

		public static UserDelegationKey UserDelegationKey(string signedObjectId, string signedTenantId, string signedService, string signedVersion, string value, DateTimeOffset signedExpiresOn, DateTimeOffset signedStartsOn)
		{
			return new UserDelegationKey(signedObjectId, signedTenantId, signedStartsOn, signedExpiresOn, signedService, signedVersion, value);
		}

		public static BlobHierarchyItem BlobHierarchyItem(string prefix, BlobItem blob)
		{
			return new BlobHierarchyItem(prefix, blob);
		}

		public static BlobDownloadInfo BlobDownloadInfo(DateTimeOffset lastModified = default(DateTimeOffset), long blobSequenceNumber = 0L, BlobType blobType = BlobType.Block, byte[] contentCrc64 = null, string contentLanguage = null, string copyStatusDescription = null, string copyId = null, string copyProgress = null, Uri copySource = null, CopyStatus copyStatus = CopyStatus.Pending, string contentDisposition = null, LeaseDurationType leaseDuration = LeaseDurationType.Infinite, string cacheControl = null, LeaseState leaseState = LeaseState.Available, string contentEncoding = null, LeaseStatus leaseStatus = LeaseStatus.Locked, byte[] contentHash = null, string acceptRanges = null, ETag eTag = default(ETag), int blobCommittedBlockCount = 0, string contentRange = null, bool isServerEncrypted = false, string contentType = null, string encryptionKeySha256 = null, string encryptionScope = null, long contentLength = 0L, byte[] blobContentHash = null, string versionId = null, IDictionary<string, string> metadata = null, Stream content = null, DateTimeOffset copyCompletionTime = default(DateTimeOffset), long tagCount = 0L, DateTimeOffset lastAccessed = default(DateTimeOffset))
		{
			return new BlobDownloadInfo
			{
				BlobType = blobType,
				ContentLength = contentLength,
				Content = content,
				ContentType = contentType,
				ContentHash = contentHash,
				Details = new BlobDownloadDetails
				{
					BlobType = blobType,
					ContentLength = contentLength,
					ContentType = contentType,
					ContentHash = contentHash,
					LastModified = lastModified,
					Metadata = metadata,
					ContentRange = contentRange,
					ETag = eTag,
					ContentEncoding = contentEncoding,
					CacheControl = cacheControl,
					ContentDisposition = contentDisposition,
					ContentLanguage = contentLanguage,
					BlobSequenceNumber = blobSequenceNumber,
					CopyCompletedOn = copyCompletionTime,
					CopyStatusDescription = copyStatusDescription,
					CopyId = copyId,
					CopyProgress = copyProgress,
					CopySource = copySource,
					CopyStatus = copyStatus,
					LeaseDuration = leaseDuration,
					LeaseState = leaseState,
					LeaseStatus = leaseStatus,
					AcceptRanges = acceptRanges,
					BlobCommittedBlockCount = blobCommittedBlockCount,
					IsServerEncrypted = isServerEncrypted,
					EncryptionKeySha256 = encryptionKeySha256,
					EncryptionScope = encryptionScope,
					BlobContentHash = blobContentHash,
					TagCount = tagCount,
					VersionId = versionId,
					LastAccessed = lastAccessed
				}
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobDownloadInfo BlobDownloadInfo(DateTimeOffset lastModified, long blobSequenceNumber, BlobType blobType, byte[] contentCrc64, string contentLanguage, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, string contentDisposition, LeaseDurationType leaseDuration, string cacheControl, LeaseState leaseState, string contentEncoding, LeaseStatus leaseStatus, byte[] contentHash, string acceptRanges, ETag eTag, int blobCommittedBlockCount, string contentRange, bool isServerEncrypted, string contentType, string encryptionKeySha256, string encryptionScope, long contentLength, byte[] blobContentHash, string versionId, IDictionary<string, string> metadata, Stream content, DateTimeOffset copyCompletionTime, long tagCount)
		{
			return new BlobDownloadInfo
			{
				BlobType = blobType,
				ContentLength = contentLength,
				Content = content,
				ContentType = contentType,
				ContentHash = contentHash,
				Details = new BlobDownloadDetails
				{
					BlobType = blobType,
					ContentLength = contentLength,
					ContentType = contentType,
					ContentHash = contentHash,
					LastModified = lastModified,
					Metadata = metadata,
					ContentRange = contentRange,
					ETag = eTag,
					ContentEncoding = contentEncoding,
					CacheControl = cacheControl,
					ContentDisposition = contentDisposition,
					ContentLanguage = contentLanguage,
					BlobSequenceNumber = blobSequenceNumber,
					CopyCompletedOn = copyCompletionTime,
					CopyStatusDescription = copyStatusDescription,
					CopyId = copyId,
					CopyProgress = copyProgress,
					CopySource = copySource,
					CopyStatus = copyStatus,
					LeaseDuration = leaseDuration,
					LeaseState = leaseState,
					LeaseStatus = leaseStatus,
					AcceptRanges = acceptRanges,
					BlobCommittedBlockCount = blobCommittedBlockCount,
					IsServerEncrypted = isServerEncrypted,
					EncryptionKeySha256 = encryptionKeySha256,
					EncryptionScope = encryptionScope,
					BlobContentHash = blobContentHash,
					TagCount = tagCount,
					VersionId = versionId
				}
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobDownloadInfo BlobDownloadInfo(DateTimeOffset lastModified, long blobSequenceNumber, BlobType blobType, byte[] contentCrc64, string contentLanguage, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, string contentDisposition, LeaseDurationType leaseDuration, string cacheControl, LeaseState leaseState, string contentEncoding, LeaseStatus leaseStatus, byte[] contentHash, string acceptRanges, ETag eTag, int blobCommittedBlockCount, string contentRange, bool isServerEncrypted, string contentType, string encryptionKeySha256, string encryptionScope, long contentLength, byte[] blobContentHash, IDictionary<string, string> metadata, Stream content, DateTimeOffset copyCompletionTime)
		{
			return new BlobDownloadInfo
			{
				BlobType = blobType,
				ContentLength = contentLength,
				Content = content,
				ContentType = contentType,
				ContentHash = contentHash,
				Details = new BlobDownloadDetails
				{
					BlobType = blobType,
					ContentLength = contentLength,
					ContentType = contentType,
					ContentHash = contentHash,
					LastModified = lastModified,
					Metadata = metadata,
					ContentRange = contentRange,
					ETag = eTag,
					ContentEncoding = contentEncoding,
					CacheControl = cacheControl,
					ContentDisposition = contentDisposition,
					ContentLanguage = contentLanguage,
					BlobSequenceNumber = blobSequenceNumber,
					CopyCompletedOn = copyCompletionTime,
					CopyStatusDescription = copyStatusDescription,
					CopyId = copyId,
					CopyProgress = copyProgress,
					CopySource = copySource,
					CopyStatus = copyStatus,
					LeaseDuration = leaseDuration,
					LeaseState = leaseState,
					LeaseStatus = leaseStatus,
					AcceptRanges = acceptRanges,
					BlobCommittedBlockCount = blobCommittedBlockCount,
					IsServerEncrypted = isServerEncrypted,
					EncryptionKeySha256 = encryptionKeySha256,
					EncryptionScope = encryptionScope,
					BlobContentHash = blobContentHash
				}
			};
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobDownloadInfo BlobDownloadInfo(DateTimeOffset lastModified, long blobSequenceNumber, BlobType blobType, byte[] contentCrc64, string contentLanguage, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus copyStatus, string contentDisposition, LeaseDurationType leaseDuration, string cacheControl, LeaseState leaseState, string contentEncoding, LeaseStatus leaseStatus, byte[] contentHash, string acceptRanges, ETag eTag, int blobCommittedBlockCount, string contentRange, bool isServerEncrypted, string contentType, string encryptionKeySha256, long contentLength, byte[] blobContentHash, IDictionary<string, string> metadata, Stream content, DateTimeOffset copyCompletionTime)
		{
			return new BlobDownloadInfo
			{
				BlobType = blobType,
				ContentLength = contentLength,
				Content = content,
				ContentType = contentType,
				ContentHash = contentHash,
				Details = new BlobDownloadDetails
				{
					BlobType = blobType,
					ContentLength = contentLength,
					ContentType = contentType,
					ContentHash = contentHash,
					LastModified = lastModified,
					Metadata = metadata,
					ContentRange = contentRange,
					ETag = eTag,
					ContentEncoding = contentEncoding,
					CacheControl = cacheControl,
					ContentDisposition = contentDisposition,
					ContentLanguage = contentLanguage,
					BlobSequenceNumber = blobSequenceNumber,
					CopyCompletedOn = copyCompletionTime,
					CopyStatusDescription = copyStatusDescription,
					CopyId = copyId,
					CopyProgress = copyProgress,
					CopySource = copySource,
					CopyStatus = copyStatus,
					LeaseDuration = leaseDuration,
					LeaseState = leaseState,
					LeaseStatus = leaseStatus,
					AcceptRanges = acceptRanges,
					BlobCommittedBlockCount = blobCommittedBlockCount,
					IsServerEncrypted = isServerEncrypted,
					EncryptionKeySha256 = encryptionKeySha256,
					BlobContentHash = blobContentHash
				}
			};
		}

		public static BlobDownloadResult BlobDownloadResult(BinaryData content = null, BlobDownloadDetails details = null)
		{
			return new BlobDownloadResult
			{
				Content = content,
				Details = details
			};
		}

		public static BlobDownloadStreamingResult BlobDownloadStreamingResult(Stream content = null, BlobDownloadDetails details = null)
		{
			return new BlobDownloadStreamingResult
			{
				Content = content,
				Details = details
			};
		}

		public static PageRangesInfo PageRangesInfo(DateTimeOffset lastModified, ETag eTag, long blobContentLength, IEnumerable<HttpRange> pageRanges, IEnumerable<HttpRange> clearRanges)
		{
			return new PageRangesInfo
			{
				LastModified = lastModified,
				ETag = eTag,
				BlobContentLength = blobContentLength,
				PageRanges = pageRanges,
				ClearRanges = clearRanges
			};
		}
	}
	public readonly struct AccessTier : IEquatable<AccessTier>
	{
		private readonly string _value;

		private const string P4Value = "P4";

		private const string P6Value = "P6";

		private const string P10Value = "P10";

		private const string P15Value = "P15";

		private const string P20Value = "P20";

		private const string P30Value = "P30";

		private const string P40Value = "P40";

		private const string P50Value = "P50";

		private const string P60Value = "P60";

		private const string P70Value = "P70";

		private const string P80Value = "P80";

		private const string HotValue = "Hot";

		private const string CoolValue = "Cool";

		private const string ArchiveValue = "Archive";

		private const string PremiumValue = "Premium";

		private const string ColdValue = "Cold";

		public static AccessTier P4 { get; } = new AccessTier("P4");

		public static AccessTier P6 { get; } = new AccessTier("P6");

		public static AccessTier P10 { get; } = new AccessTier("P10");

		public static AccessTier P15 { get; } = new AccessTier("P15");

		public static AccessTier P20 { get; } = new AccessTier("P20");

		public static AccessTier P30 { get; } = new AccessTier("P30");

		public static AccessTier P40 { get; } = new AccessTier("P40");

		public static AccessTier P50 { get; } = new AccessTier("P50");

		public static AccessTier P60 { get; } = new AccessTier("P60");

		public static AccessTier P70 { get; } = new AccessTier("P70");

		public static AccessTier P80 { get; } = new AccessTier("P80");

		public static AccessTier Hot { get; } = new AccessTier("Hot");

		public static AccessTier Cool { get; } = new AccessTier("Cool");

		public static AccessTier Archive { get; } = new AccessTier("Archive");

		public static AccessTier Premium { get; } = new AccessTier("Premium");

		public static AccessTier Cold { get; } = new AccessTier("Cold");

		public AccessTier(string value)
		{
			_value = value ?? throw new ArgumentNullException("value");
		}

		public static bool operator ==(AccessTier left, AccessTier right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(AccessTier left, AccessTier right)
		{
			return !left.Equals(right);
		}

		public static implicit operator AccessTier(string value)
		{
			return new AccessTier(value);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override bool Equals(object obj)
		{
			if (obj is AccessTier other)
			{
				return Equals(other);
			}
			return false;
		}

		public bool Equals(AccessTier other)
		{
			return string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override int GetHashCode()
		{
			return _value?.GetHashCode() ?? 0;
		}

		public override string ToString()
		{
			return _value;
		}
	}
	internal static class AccountKindExtensions
	{
		public static string ToSerialString(this AccountKind value)
		{
			return value switch
			{
				AccountKind.Storage => "Storage", 
				AccountKind.BlobStorage => "BlobStorage", 
				AccountKind.StorageV2 => "StorageV2", 
				AccountKind.FileStorage => "FileStorage", 
				AccountKind.BlockBlobStorage => "BlockBlobStorage", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown AccountKind value."), 
			};
		}

		public static AccountKind ToAccountKind(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "Storage"))
			{
				return AccountKind.Storage;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "BlobStorage"))
			{
				return AccountKind.BlobStorage;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "StorageV2"))
			{
				return AccountKind.StorageV2;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "FileStorage"))
			{
				return AccountKind.FileStorage;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "BlockBlobStorage"))
			{
				return AccountKind.BlockBlobStorage;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown AccountKind value.");
		}
	}
	internal static class ArchiveStatusExtensions
	{
		public static string ToSerialString(this ArchiveStatus value)
		{
			return value switch
			{
				ArchiveStatus.RehydratePendingToHot => "rehydrate-pending-to-hot", 
				ArchiveStatus.RehydratePendingToCool => "rehydrate-pending-to-cool", 
				ArchiveStatus.RehydratePendingToCold => "rehydrate-pending-to-cold", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown ArchiveStatus value."), 
			};
		}

		public static ArchiveStatus ToArchiveStatus(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "rehydrate-pending-to-hot"))
			{
				return ArchiveStatus.RehydratePendingToHot;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "rehydrate-pending-to-cool"))
			{
				return ArchiveStatus.RehydratePendingToCool;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "rehydrate-pending-to-cold"))
			{
				return ArchiveStatus.RehydratePendingToCold;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown ArchiveStatus value.");
		}
	}
	[CodeGenModel("ArrowField")]
	internal class ArrowFieldInternal : Azure.Core.IXmlSerializable
	{
		public string Type { get; }

		public string Name { get; set; }

		public int? Precision { get; set; }

		public int? Scale { get; set; }

		public ArrowFieldInternal(string type)
		{
			Azure.Core.Argument.AssertNotNull(type, "type");
			Type = type;
		}

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "Field");
			writer.WriteStartElement("Type");
			writer.WriteValue(Type);
			writer.WriteEndElement();
			if (Azure.Core.Optional.IsDefined(Name))
			{
				writer.WriteStartElement("Name");
				writer.WriteValue(Name);
				writer.WriteEndElement();
			}
			if (Azure.Core.Optional.IsDefined(Precision))
			{
				writer.WriteStartElement("Precision");
				writer.WriteValue(Precision.Value);
				writer.WriteEndElement();
			}
			if (Azure.Core.Optional.IsDefined(Scale))
			{
				writer.WriteStartElement("Scale");
				writer.WriteValue(Scale.Value);
				writer.WriteEndElement();
			}
			writer.WriteEndElement();
		}
	}
	[CodeGenModel("ArrowConfiguration")]
	internal class ArrowTextConfigurationInternal : Azure.Core.IXmlSerializable
	{
		public IList<ArrowFieldInternal> Schema { get; }

		public ArrowTextConfigurationInternal(IEnumerable<ArrowFieldInternal> schema)
		{
			Azure.Core.Argument.AssertNotNull(schema, "schema");
			Schema = schema.ToList();
		}

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "ArrowConfiguration");
			writer.WriteStartElement("Schema");
			foreach (ArrowFieldInternal item in Schema)
			{
				writer.WriteObjectValue(item, "Field");
			}
			writer.WriteEndElement();
			writer.WriteEndElement();
		}
	}
	[CodeGenModel("AccessPolicy")]
	public class BlobAccessPolicy : Azure.Core.IXmlSerializable
	{
		[CodeGenMember("Start")]
		public DateTimeOffset? PolicyStartsOn { get; set; }

		[CodeGenMember("Expiry")]
		public DateTimeOffset? PolicyExpiresOn { get; set; }

		[CodeGenMember("Permission")]
		public string Permissions { get; set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		public DateTimeOffset StartsOn
		{
			get
			{
				if (PolicyStartsOn.HasValue)
				{
					return PolicyStartsOn.Value;
				}
				return default(DateTimeOffset);
			}
			set
			{
				PolicyStartsOn = value;
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public DateTimeOffset ExpiresOn
		{
			get
			{
				if (PolicyExpiresOn.HasValue)
				{
					return PolicyExpiresOn.Value;
				}
				return default(DateTimeOffset);
			}
			set
			{
				PolicyExpiresOn = value;
			}
		}

		public BlobAccessPolicy()
		{
		}

		internal BlobAccessPolicy(DateTimeOffset? policyStartsOn, DateTimeOffset? policyExpiresOn, string permissions)
		{
			PolicyStartsOn = policyStartsOn;
			PolicyExpiresOn = policyExpiresOn;
			Permissions = permissions;
		}

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "AccessPolicy");
			if (Azure.Core.Optional.IsDefined(PolicyStartsOn))
			{
				writer.WriteStartElement("Start");
				writer.WriteValue(PolicyStartsOn.Value, "O");
				writer.WriteEndElement();
			}
			if (Azure.Core.Optional.IsDefined(PolicyExpiresOn))
			{
				writer.WriteStartElement("Expiry");
				writer.WriteValue(PolicyExpiresOn.Value, "O");
				writer.WriteEndElement();
			}
			if (Azure.Core.Optional.IsDefined(Permissions))
			{
				writer.WriteStartElement("Permission");
				writer.WriteValue(Permissions);
				writer.WriteEndElement();
			}
			writer.WriteEndElement();
		}

		internal static BlobAccessPolicy DeserializeBlobAccessPolicy(XElement element)
		{
			DateTimeOffset? policyStartsOn = null;
			DateTimeOffset? policyExpiresOn = null;
			string permissions = null;
			XElement xElement = element.Element("Start");
			if (xElement != null)
			{
				policyStartsOn = xElement.GetDateTimeOffsetValue("O");
			}
			XElement xElement2 = element.Element("Expiry");
			if (xElement2 != null)
			{
				policyExpiresOn = xElement2.GetDateTimeOffsetValue("O");
			}
			XElement xElement3 = element.Element("Permission");
			if (xElement3 != null)
			{
				permissions = (string)xElement3;
			}
			return new BlobAccessPolicy(policyStartsOn, policyExpiresOn, permissions);
		}
	}
	[CodeGenModel("Logging")]
	public class BlobAnalyticsLogging : Azure.Core.IXmlSerializable
	{
		public string Version { get; set; }

		public bool Delete { get; set; }

		public bool Read { get; set; }

		public bool Write { get; set; }

		public BlobRetentionPolicy RetentionPolicy { get; set; }

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "Logging");
			writer.WriteStartElement("Version");
			writer.WriteValue(Version);
			writer.WriteEndElement();
			writer.WriteStartElement("Delete");
			writer.WriteValue(Delete);
			writer.WriteEndElement();
			writer.WriteStartElement("Read");
			writer.WriteValue(Read);
			writer.WriteEndElement();
			writer.WriteStartElement("Write");
			writer.WriteValue(Write);
			writer.WriteEndElement();
			writer.WriteObjectValue(RetentionPolicy, "RetentionPolicy");
			writer.WriteEndElement();
		}

		internal static BlobAnalyticsLogging DeserializeBlobAnalyticsLogging(XElement element)
		{
			string version = null;
			bool delete = false;
			bool read = false;
			bool write = false;
			BlobRetentionPolicy retentionPolicy = null;
			XElement xElement = element.Element("Version");
			if (xElement != null)
			{
				version = (string)xElement;
			}
			XElement xElement2 = element.Element("Delete");
			if (xElement2 != null)
			{
				delete = (bool)xElement2;
			}
			XElement xElement3 = element.Element("Read");
			if (xElement3 != null)
			{
				read = (bool)xElement3;
			}
			XElement xElement4 = element.Element("Write");
			if (xElement4 != null)
			{
				write = (bool)xElement4;
			}
			XElement xElement5 = element.Element("RetentionPolicy");
			if (xElement5 != null)
			{
				retentionPolicy = BlobRetentionPolicy.DeserializeBlobRetentionPolicy(xElement5);
			}
			return new BlobAnalyticsLogging(version, delete, read, write, retentionPolicy);
		}

		public BlobAnalyticsLogging()
			: this(skipInitialization: false)
		{
		}

		internal BlobAnalyticsLogging(string version, bool delete, bool read, bool write, BlobRetentionPolicy retentionPolicy)
		{
			if (version == null)
			{
				throw new ArgumentNullException("version");
			}
			if (retentionPolicy == null)
			{
				throw new ArgumentNullException("retentionPolicy");
			}
			Version = version;
			Delete = delete;
			Read = read;
			Write = write;
			RetentionPolicy = retentionPolicy;
		}

		internal BlobAnalyticsLogging(bool skipInitialization)
		{
			if (!skipInitialization)
			{
				RetentionPolicy = new BlobRetentionPolicy();
			}
		}
	}
	[CodeGenModel("Block")]
	public readonly struct BlobBlock : IEquatable<BlobBlock>
	{
		[CodeGenMember("Size")]
		public long SizeLong { get; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		public int Size => checked((int)SizeLong);

		[CodeGenMember("Name")]
		public string Name { get; }

		internal BlobBlock(string name, long sizeLong)
		{
			Azure.Core.Argument.AssertNotNull(name, "name");
			Name = name;
			SizeLong = sizeLong;
		}

		internal static BlobBlock DeserializeBlobBlock(XElement element)
		{
			string name = null;
			long sizeLong = 0L;
			XElement xElement = element.Element("Name");
			if (xElement != null)
			{
				name = (string)xElement;
			}
			XElement xElement2 = element.Element("Size");
			if (xElement2 != null)
			{
				sizeLong = (long)xElement2;
			}
			return new BlobBlock(name, sizeLong);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool Equals(BlobBlock other)
		{
			if (!StringComparer.Ordinal.Equals(Name, other.Name))
			{
				return false;
			}
			if (!Size.Equals(other.Size))
			{
				return false;
			}
			return true;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override bool Equals(object obj)
		{
			if (obj is BlobBlock)
			{
				return Equals((BlobBlock)obj);
			}
			return false;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override int GetHashCode()
		{
			Azure.Core.HashCodeBuilder hashCodeBuilder = default(Azure.Core.HashCodeBuilder);
			if (Name != null)
			{
				hashCodeBuilder.Add(Name, StringComparer.Ordinal);
			}
			hashCodeBuilder.Add(Size);
			return hashCodeBuilder.ToHashCode();
		}
	}
	internal static class BlobCopySourceTagsModeExtensions
	{
		public static string ToSerialString(this BlobCopySourceTagsMode value)
		{
			return value switch
			{
				BlobCopySourceTagsMode.Replace => "REPLACE", 
				BlobCopySourceTagsMode.Copy => "COPY", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown BlobCopySourceTagsMode value."), 
			};
		}

		public static BlobCopySourceTagsMode ToBlobCopySourceTagsMode(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "REPLACE"))
			{
				return BlobCopySourceTagsMode.Replace;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "COPY"))
			{
				return BlobCopySourceTagsMode.Copy;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown BlobCopySourceTagsMode value.");
		}
	}
	[CodeGenModel("CorsRule")]
	public class BlobCorsRule : Azure.Core.IXmlSerializable
	{
		public string AllowedOrigins { get; set; }

		public string AllowedMethods { get; set; }

		public string AllowedHeaders { get; set; }

		public string ExposedHeaders { get; set; }

		public int MaxAgeInSeconds { get; set; }

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "CorsRule");
			writer.WriteStartElement("AllowedOrigins");
			writer.WriteValue(AllowedOrigins);
			writer.WriteEndElement();
			writer.WriteStartElement("AllowedMethods");
			writer.WriteValue(AllowedMethods);
			writer.WriteEndElement();
			writer.WriteStartElement("AllowedHeaders");
			writer.WriteValue(AllowedHeaders);
			writer.WriteEndElement();
			writer.WriteStartElement("ExposedHeaders");
			writer.WriteValue(ExposedHeaders);
			writer.WriteEndElement();
			writer.WriteStartElement("MaxAgeInSeconds");
			writer.WriteValue(MaxAgeInSeconds);
			writer.WriteEndElement();
			writer.WriteEndElement();
		}

		internal static BlobCorsRule DeserializeBlobCorsRule(XElement element)
		{
			string allowedOrigins = null;
			string allowedMethods = null;
			string allowedHeaders = null;
			string exposedHeaders = null;
			int maxAgeInSeconds = 0;
			XElement xElement = element.Element("AllowedOrigins");
			if (xElement != null)
			{
				allowedOrigins = (string)xElement;
			}
			XElement xElement2 = element.Element("AllowedMethods");
			if (xElement2 != null)
			{
				allowedMethods = (string)xElement2;
			}
			XElement xElement3 = element.Element("AllowedHeaders");
			if (xElement3 != null)
			{
				allowedHeaders = (string)xElement3;
			}
			XElement xElement4 = element.Element("ExposedHeaders");
			if (xElement4 != null)
			{
				exposedHeaders = (string)xElement4;
			}
			XElement xElement5 = element.Element("MaxAgeInSeconds");
			if (xElement5 != null)
			{
				maxAgeInSeconds = (int)xElement5;
			}
			return new BlobCorsRule(allowedOrigins, allowedMethods, allowedHeaders, exposedHeaders, maxAgeInSeconds);
		}

		public BlobCorsRule()
		{
		}

		internal BlobCorsRule(string allowedOrigins, string allowedMethods, string allowedHeaders, string exposedHeaders, int maxAgeInSeconds)
		{
			Azure.Core.Argument.AssertNotNull(allowedOrigins, "allowedOrigins");
			Azure.Core.Argument.AssertNotNull(allowedMethods, "allowedMethods");
			Azure.Core.Argument.AssertNotNull(allowedHeaders, "allowedHeaders");
			Azure.Core.Argument.AssertNotNull(exposedHeaders, "exposedHeaders");
			AllowedOrigins = allowedOrigins;
			AllowedMethods = allowedMethods;
			AllowedHeaders = allowedHeaders;
			ExposedHeaders = exposedHeaders;
			MaxAgeInSeconds = maxAgeInSeconds;
		}
	}
	internal static class BlobDeleteTypeExtensions
	{
		public static string ToSerialString(this BlobDeleteType value)
		{
			return value switch
			{
				BlobDeleteType.None => "None", 
				BlobDeleteType.Permanent => "Permanent", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown BlobDeleteType value."), 
			};
		}

		public static BlobDeleteType ToBlobDeleteType(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "None"))
			{
				return BlobDeleteType.None;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "Permanent"))
			{
				return BlobDeleteType.Permanent;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown BlobDeleteType value.");
		}
	}
	[CodeGenModel("ErrorCode")]
	public readonly struct BlobErrorCode : IEquatable<BlobErrorCode>
	{
		private readonly string _value;

		private const string AccountAlreadyExistsValue = "AccountAlreadyExists";

		private const string AccountBeingCreatedValue = "AccountBeingCreated";

		private const string AccountIsDisabledValue = "AccountIsDisabled";

		private const string AuthenticationFailedValue = "AuthenticationFailed";

		private const string AuthorizationFailureValue = "AuthorizationFailure";

		private const string ConditionHeadersNotSupportedValue = "ConditionHeadersNotSupported";

		private const string ConditionNotMetValue = "ConditionNotMet";

		private const string EmptyMetadataKeyValue = "EmptyMetadataKey";

		private const string InsufficientAccountPermissionsValue = "InsufficientAccountPermissions";

		private const string InternalErrorValue = "InternalError";

		private const string InvalidAuthenticationInfoValue = "InvalidAuthenticationInfo";

		private const string InvalidHeaderValueValue = "InvalidHeaderValue";

		private const string InvalidHttpVerbValue = "InvalidHttpVerb";

		private const string InvalidInputValue = "InvalidInput";

		private const string InvalidMd5Value = "InvalidMd5";

		private const string InvalidMetadataValue = "InvalidMetadata";

		private const string InvalidQueryParameterValueValue = "InvalidQueryParameterValue";

		private const string InvalidRangeValue = "InvalidRange";

		private const string InvalidResourceNameValue = "InvalidResourceName";

		private const string InvalidUriValue = "InvalidUri";

		private const string InvalidXmlDocumentValue = "InvalidXmlDocument";

		private const string InvalidXmlNodeValueValue = "InvalidXmlNodeValue";

		private const string Md5MismatchValue = "Md5Mismatch";

		private const string MetadataTooLargeValue = "MetadataTooLarge";

		private const string MissingContentLengthHeaderValue = "MissingContentLengthHeader";

		private const string MissingRequiredQueryParameterValue = "MissingRequiredQueryParameter";

		private const string MissingRequiredHeaderValue = "MissingRequiredHeader";

		private const string MissingRequiredXmlNodeValue = "MissingRequiredXmlNode";

		private const string MultipleConditionHeadersNotSupportedValue = "MultipleConditionHeadersNotSupported";

		private const string OperationTimedOutValue = "OperationTimedOut";

		private const string OutOfRangeInputValue = "OutOfRangeInput";

		private const string OutOfRangeQueryParameterValueValue = "OutOfRangeQueryParameterValue";

		private const string RequestBodyTooLargeValue = "RequestBodyTooLarge";

		private const string ResourceTypeMismatchValue = "ResourceTypeMismatch";

		private const string RequestUrlFailedToParseValue = "RequestUrlFailedToParse";

		private const string ResourceAlreadyExistsValue = "ResourceAlreadyExists";

		private const string ResourceNotFoundValue = "ResourceNotFound";

		private const string ServerBusyValue = "ServerBusy";

		private const string UnsupportedHeaderValue = "UnsupportedHeader";

		private const string UnsupportedXmlNodeValue = "UnsupportedXmlNode";

		private const string UnsupportedQueryParameterValue = "UnsupportedQueryParameter";

		private const string UnsupportedHttpVerbValue = "UnsupportedHttpVerb";

		private const string AppendPositionConditionNotMetValue = "AppendPositionConditionNotMet";

		private const string BlobAlreadyExistsValue = "BlobAlreadyExists";

		private const string BlobImmutableDueToPolicyValue = "BlobImmutableDueToPolicy";

		private const string BlobNotFoundValue = "BlobNotFound";

		private const string BlobOverwrittenValue = "BlobOverwritten";

		private const string BlobTierInadequateForContentLengthValue = "BlobTierInadequateForContentLength";

		private const string BlobUsesCustomerSpecifiedEncryptionValue = "BlobUsesCustomerSpecifiedEncryption";

		private const string BlockCountExceedsLimitValue = "BlockCountExceedsLimit";

		private const string BlockListTooLongValue = "BlockListTooLong";

		private const string CannotChangeToLowerTierValue = "CannotChangeToLowerTier";

		private const string CannotVerifyCopySourceValue = "CannotVerifyCopySource";

		private const string ContainerAlreadyExistsValue = "ContainerAlreadyExists";

		private const string ContainerBeingDeletedValue = "ContainerBeingDeleted";

		private const string ContainerDisabledValue = "ContainerDisabled";

		private const string ContainerNotFoundValue = "ContainerNotFound";

		private const string ContentLengthLargerThanTierLimitValue = "ContentLengthLargerThanTierLimit";

		private const string CopyAcrossAccountsNotSupportedValue = "CopyAcrossAccountsNotSupported";

		private const string CopyIdMismatchValue = "CopyIdMismatch";

		private const string FeatureVersionMismatchValue = "FeatureVersionMismatch";

		private const string IncrementalCopyBlobMismatchValue = "IncrementalCopyBlobMismatch";

		private const string IncrementalCopyOfEarlierVersionSnapshotNotAllowedValue = "IncrementalCopyOfEarlierVersionSnapshotNotAllowed";

		private const string IncrementalCopySourceMustBeSnapshotValue = "IncrementalCopySourceMustBeSnapshot";

		private const string InfiniteLeaseDurationRequiredValue = "InfiniteLeaseDurationRequired";

		private const string InvalidBlobOrBlockValue = "InvalidBlobOrBlock";

		private const string InvalidBlobTierValue = "InvalidBlobTier";

		private const string InvalidBlobTypeValue = "InvalidBlobType";

		private const string InvalidBlockIdValue = "InvalidBlockId";

		private const string InvalidBlockListValue = "InvalidBlockList";

		private const string InvalidOperationValue = "InvalidOperation";

		private const string InvalidPageRangeValue = "InvalidPageRange";

		private const string InvalidSourceBlobTypeValue = "InvalidSourceBlobType";

		private const string InvalidSourceBlobUrlValue = "InvalidSourceBlobUrl";

		private const string InvalidVersionForPageBlobOperationValue = "InvalidVersionForPageBlobOperation";

		private const string LeaseAlreadyPresentValue = "LeaseAlreadyPresent";

		private const string LeaseAlreadyBrokenValue = "LeaseAlreadyBroken";

		private const string LeaseIdMismatchWithBlobOperationValue = "LeaseIdMismatchWithBlobOperation";

		private const string LeaseIdMismatchWithContainerOperationValue = "LeaseIdMismatchWithContainerOperation";

		private const string LeaseIdMismatchWithLeaseOperationValue = "LeaseIdMismatchWithLeaseOperation";

		private const string LeaseIdMissingValue = "LeaseIdMissing";

		private const string LeaseIsBreakingAndCannotBeAcquiredValue = "LeaseIsBreakingAndCannotBeAcquired";

		private const string LeaseIsBreakingAndCannotBeChangedValue = "LeaseIsBreakingAndCannotBeChanged";

		private const string LeaseIsBrokenAndCannotBeRenewedValue = "LeaseIsBrokenAndCannotBeRenewed";

		private const string LeaseLostValue = "LeaseLost";

		private const string LeaseNotPresentWithBlobOperationValue = "LeaseNotPresentWithBlobOperation";

		private const string LeaseNotPresentWithContainerOperationValue = "LeaseNotPresentWithContainerOperation";

		private const string LeaseNotPresentWithLeaseOperationValue = "LeaseNotPresentWithLeaseOperation";

		private const string MaxBlobSizeConditionNotMetValue = "MaxBlobSizeConditionNotMet";

		private const string NoAuthenticationInformationValue = "NoAuthenticationInformation";

		private const string NoPendingCopyOperationValue = "NoPendingCopyOperation";

		private const string OperationNotAllowedOnIncrementalCopyBlobValue = "OperationNotAllowedOnIncrementalCopyBlob";

		private const string PendingCopyOperationValue = "PendingCopyOperation";

		private const string PreviousSnapshotCannotBeNewerValue = "PreviousSnapshotCannotBeNewer";

		private const string PreviousSnapshotNotFoundValue = "PreviousSnapshotNotFound";

		private const string PreviousSnapshotOperationNotSupportedValue = "PreviousSnapshotOperationNotSupported";

		private const string SequenceNumberConditionNotMetValue = "SequenceNumberConditionNotMet";

		private const string SequenceNumberIncrementTooLargeValue = "SequenceNumberIncrementTooLarge";

		private const string SnapshotCountExceededValue = "SnapshotCountExceeded";

		private const string SnapshotOperationRateExceededValue = "SnapshotOperationRateExceeded";

		private const string SnapshotsPresentValue = "SnapshotsPresent";

		private const string SourceConditionNotMetValue = "SourceConditionNotMet";

		private const string SystemInUseValue = "SystemInUse";

		private const string TargetConditionNotMetValue = "TargetConditionNotMet";

		private const string UnauthorizedBlobOverwriteValue = "UnauthorizedBlobOverwrite";

		private const string BlobBeingRehydratedValue = "BlobBeingRehydrated";

		private const string BlobArchivedValue = "BlobArchived";

		private const string BlobNotArchivedValue = "BlobNotArchived";

		private const string AuthorizationSourceIPMismatchValue = "AuthorizationSourceIPMismatch";

		private const string AuthorizationProtocolMismatchValue = "AuthorizationProtocolMismatch";

		private const string AuthorizationPermissionMismatchValue = "AuthorizationPermissionMismatch";

		private const string AuthorizationServiceMismatchValue = "AuthorizationServiceMismatch";

		private const string AuthorizationResourceTypeMismatchValue = "AuthorizationResourceTypeMismatch";

		private const string SnaphotOperationRateExceededValue = "SnaphotOperationRateExceeded";

		private const string IncrementalCopyOfEralierVersionSnapshotNotAllowedValue = "IncrementalCopyOfEralierVersionSnapshotNotAllowed";

		public static BlobErrorCode AccountAlreadyExists { get; } = new BlobErrorCode("AccountAlreadyExists");

		public static BlobErrorCode AccountBeingCreated { get; } = new BlobErrorCode("AccountBeingCreated");

		public static BlobErrorCode AccountIsDisabled { get; } = new BlobErrorCode("AccountIsDisabled");

		public static BlobErrorCode AuthenticationFailed { get; } = new BlobErrorCode("AuthenticationFailed");

		public static BlobErrorCode AuthorizationFailure { get; } = new BlobErrorCode("AuthorizationFailure");

		public static BlobErrorCode ConditionHeadersNotSupported { get; } = new BlobErrorCode("ConditionHeadersNotSupported");

		public static BlobErrorCode ConditionNotMet { get; } = new BlobErrorCode("ConditionNotMet");

		public static BlobErrorCode EmptyMetadataKey { get; } = new BlobErrorCode("EmptyMetadataKey");

		public static BlobErrorCode InsufficientAccountPermissions { get; } = new BlobErrorCode("InsufficientAccountPermissions");

		public static BlobErrorCode InternalError { get; } = new BlobErrorCode("InternalError");

		public static BlobErrorCode InvalidAuthenticationInfo { get; } = new BlobErrorCode("InvalidAuthenticationInfo");

		public static BlobErrorCode InvalidHeaderValue { get; } = new BlobErrorCode("InvalidHeaderValue");

		public static BlobErrorCode InvalidHttpVerb { get; } = new BlobErrorCode("InvalidHttpVerb");

		public static BlobErrorCode InvalidInput { get; } = new BlobErrorCode("InvalidInput");

		public static BlobErrorCode InvalidMd5 { get; } = new BlobErrorCode("InvalidMd5");

		public static BlobErrorCode InvalidMetadata { get; } = new BlobErrorCode("InvalidMetadata");

		public static BlobErrorCode InvalidQueryParameterValue { get; } = new BlobErrorCode("InvalidQueryParameterValue");

		public static BlobErrorCode InvalidRange { get; } = new BlobErrorCode("InvalidRange");

		public static BlobErrorCode InvalidResourceName { get; } = new BlobErrorCode("InvalidResourceName");

		public static BlobErrorCode InvalidUri { get; } = new BlobErrorCode("InvalidUri");

		public static BlobErrorCode InvalidXmlDocument { get; } = new BlobErrorCode("InvalidXmlDocument");

		public static BlobErrorCode InvalidXmlNodeValue { get; } = new BlobErrorCode("InvalidXmlNodeValue");

		public static BlobErrorCode Md5Mismatch { get; } = new BlobErrorCode("Md5Mismatch");

		public static BlobErrorCode MetadataTooLarge { get; } = new BlobErrorCode("MetadataTooLarge");

		public static BlobErrorCode MissingContentLengthHeader { get; } = new BlobErrorCode("MissingContentLengthHeader");

		public static BlobErrorCode MissingRequiredQueryParameter { get; } = new BlobErrorCode("MissingRequiredQueryParameter");

		public static BlobErrorCode MissingRequiredHeader { get; } = new BlobErrorCode("MissingRequiredHeader");

		public static BlobErrorCode MissingRequiredXmlNode { get; } = new BlobErrorCode("MissingRequiredXmlNode");

		public static BlobErrorCode MultipleConditionHeadersNotSupported { get; } = new BlobErrorCode("MultipleConditionHeadersNotSupported");

		public static BlobErrorCode OperationTimedOut { get; } = new BlobErrorCode("OperationTimedOut");

		public static BlobErrorCode OutOfRangeInput { get; } = new BlobErrorCode("OutOfRangeInput");

		public static BlobErrorCode OutOfRangeQueryParameterValue { get; } = new BlobErrorCode("OutOfRangeQueryParameterValue");

		public static BlobErrorCode RequestBodyTooLarge { get; } = new BlobErrorCode("RequestBodyTooLarge");

		public static BlobErrorCode ResourceTypeMismatch { get; } = new BlobErrorCode("ResourceTypeMismatch");

		public static BlobErrorCode RequestUrlFailedToParse { get; } = new BlobErrorCode("RequestUrlFailedToParse");

		public static BlobErrorCode ResourceAlreadyExists { get; } = new BlobErrorCode("ResourceAlreadyExists");

		public static BlobErrorCode ResourceNotFound { get; } = new BlobErrorCode("ResourceNotFound");

		public static BlobErrorCode ServerBusy { get; } = new BlobErrorCode("ServerBusy");

		public static BlobErrorCode UnsupportedHeader { get; } = new BlobErrorCode("UnsupportedHeader");

		public static BlobErrorCode UnsupportedXmlNode { get; } = new BlobErrorCode("UnsupportedXmlNode");

		public static BlobErrorCode UnsupportedQueryParameter { get; } = new BlobErrorCode("UnsupportedQueryParameter");

		public static BlobErrorCode UnsupportedHttpVerb { get; } = new BlobErrorCode("UnsupportedHttpVerb");

		public static BlobErrorCode AppendPositionConditionNotMet { get; } = new BlobErrorCode("AppendPositionConditionNotMet");

		public static BlobErrorCode BlobAlreadyExists { get; } = new BlobErrorCode("BlobAlreadyExists");

		public static BlobErrorCode BlobImmutableDueToPolicy { get; } = new BlobErrorCode("BlobImmutableDueToPolicy");

		public static BlobErrorCode BlobNotFound { get; } = new BlobErrorCode("BlobNotFound");

		public static BlobErrorCode BlobOverwritten { get; } = new BlobErrorCode("BlobOverwritten");

		public static BlobErrorCode BlobTierInadequateForContentLength { get; } = new BlobErrorCode("BlobTierInadequateForContentLength");

		public static BlobErrorCode BlobUsesCustomerSpecifiedEncryption { get; } = new BlobErrorCode("BlobUsesCustomerSpecifiedEncryption");

		public static BlobErrorCode BlockCountExceedsLimit { get; } = new BlobErrorCode("BlockCountExceedsLimit");

		public static BlobErrorCode BlockListTooLong { get; } = new BlobErrorCode("BlockListTooLong");

		public static BlobErrorCode CannotChangeToLowerTier { get; } = new BlobErrorCode("CannotChangeToLowerTier");

		public static BlobErrorCode CannotVerifyCopySource { get; } = new BlobErrorCode("CannotVerifyCopySource");

		public static BlobErrorCode ContainerAlreadyExists { get; } = new BlobErrorCode("ContainerAlreadyExists");

		public static BlobErrorCode ContainerBeingDeleted { get; } = new BlobErrorCode("ContainerBeingDeleted");

		public static BlobErrorCode ContainerDisabled { get; } = new BlobErrorCode("ContainerDisabled");

		public static BlobErrorCode ContainerNotFound { get; } = new BlobErrorCode("ContainerNotFound");

		public static BlobErrorCode ContentLengthLargerThanTierLimit { get; } = new BlobErrorCode("ContentLengthLargerThanTierLimit");

		public static BlobErrorCode CopyAcrossAccountsNotSupported { get; } = new BlobErrorCode("CopyAcrossAccountsNotSupported");

		public static BlobErrorCode CopyIdMismatch { get; } = new BlobErrorCode("CopyIdMismatch");

		public static BlobErrorCode FeatureVersionMismatch { get; } = new BlobErrorCode("FeatureVersionMismatch");

		public static BlobErrorCode IncrementalCopyBlobMismatch { get; } = new BlobErrorCode("IncrementalCopyBlobMismatch");

		public static BlobErrorCode IncrementalCopyOfEarlierVersionSnapshotNotAllowed { get; } = new BlobErrorCode("IncrementalCopyOfEarlierVersionSnapshotNotAllowed");

		public static BlobErrorCode IncrementalCopySourceMustBeSnapshot { get; } = new BlobErrorCode("IncrementalCopySourceMustBeSnapshot");

		public static BlobErrorCode InfiniteLeaseDurationRequired { get; } = new BlobErrorCode("InfiniteLeaseDurationRequired");

		public static BlobErrorCode InvalidBlobOrBlock { get; } = new BlobErrorCode("InvalidBlobOrBlock");

		public static BlobErrorCode InvalidBlobTier { get; } = new BlobErrorCode("InvalidBlobTier");

		public static BlobErrorCode InvalidBlobType { get; } = new BlobErrorCode("InvalidBlobType");

		public static BlobErrorCode InvalidBlockId { get; } = new BlobErrorCode("InvalidBlockId");

		public static BlobErrorCode InvalidBlockList { get; } = new BlobErrorCode("InvalidBlockList");

		public static BlobErrorCode InvalidOperation { get; } = new BlobErrorCode("InvalidOperation");

		public static BlobErrorCode InvalidPageRange { get; } = new BlobErrorCode("InvalidPageRange");

		public static BlobErrorCode InvalidSourceBlobType { get; } = new BlobErrorCode("InvalidSourceBlobType");

		public static BlobErrorCode InvalidSourceBlobUrl { get; } = new BlobErrorCode("InvalidSourceBlobUrl");

		public static BlobErrorCode InvalidVersionForPageBlobOperation { get; } = new BlobErrorCode("InvalidVersionForPageBlobOperation");

		public static BlobErrorCode LeaseAlreadyPresent { get; } = new BlobErrorCode("LeaseAlreadyPresent");

		public static BlobErrorCode LeaseAlreadyBroken { get; } = new BlobErrorCode("LeaseAlreadyBroken");

		public static BlobErrorCode LeaseIdMismatchWithBlobOperation { get; } = new BlobErrorCode("LeaseIdMismatchWithBlobOperation");

		public static BlobErrorCode LeaseIdMismatchWithContainerOperation { get; } = new BlobErrorCode("LeaseIdMismatchWithContainerOperation");

		public static BlobErrorCode LeaseIdMismatchWithLeaseOperation { get; } = new BlobErrorCode("LeaseIdMismatchWithLeaseOperation");

		public static BlobErrorCode LeaseIdMissing { get; } = new BlobErrorCode("LeaseIdMissing");

		public static BlobErrorCode LeaseIsBreakingAndCannotBeAcquired { get; } = new BlobErrorCode("LeaseIsBreakingAndCannotBeAcquired");

		public static BlobErrorCode LeaseIsBreakingAndCannotBeChanged { get; } = new BlobErrorCode("LeaseIsBreakingAndCannotBeChanged");

		public static BlobErrorCode LeaseIsBrokenAndCannotBeRenewed { get; } = new BlobErrorCode("LeaseIsBrokenAndCannotBeRenewed");

		public static BlobErrorCode LeaseLost { get; } = new BlobErrorCode("LeaseLost");

		public static BlobErrorCode LeaseNotPresentWithBlobOperation { get; } = new BlobErrorCode("LeaseNotPresentWithBlobOperation");

		public static BlobErrorCode LeaseNotPresentWithContainerOperation { get; } = new BlobErrorCode("LeaseNotPresentWithContainerOperation");

		public static BlobErrorCode LeaseNotPresentWithLeaseOperation { get; } = new BlobErrorCode("LeaseNotPresentWithLeaseOperation");

		public static BlobErrorCode MaxBlobSizeConditionNotMet { get; } = new BlobErrorCode("MaxBlobSizeConditionNotMet");

		public static BlobErrorCode NoAuthenticationInformation { get; } = new BlobErrorCode("NoAuthenticationInformation");

		public static BlobErrorCode NoPendingCopyOperation { get; } = new BlobErrorCode("NoPendingCopyOperation");

		public static BlobErrorCode OperationNotAllowedOnIncrementalCopyBlob { get; } = new BlobErrorCode("OperationNotAllowedOnIncrementalCopyBlob");

		public static BlobErrorCode PendingCopyOperation { get; } = new BlobErrorCode("PendingCopyOperation");

		public static BlobErrorCode PreviousSnapshotCannotBeNewer { get; } = new BlobErrorCode("PreviousSnapshotCannotBeNewer");

		public static BlobErrorCode PreviousSnapshotNotFound { get; } = new BlobErrorCode("PreviousSnapshotNotFound");

		public static BlobErrorCode PreviousSnapshotOperationNotSupported { get; } = new BlobErrorCode("PreviousSnapshotOperationNotSupported");

		public static BlobErrorCode SequenceNumberConditionNotMet { get; } = new BlobErrorCode("SequenceNumberConditionNotMet");

		public static BlobErrorCode SequenceNumberIncrementTooLarge { get; } = new BlobErrorCode("SequenceNumberIncrementTooLarge");

		public static BlobErrorCode SnapshotCountExceeded { get; } = new BlobErrorCode("SnapshotCountExceeded");

		public static BlobErrorCode SnapshotOperationRateExceeded { get; } = new BlobErrorCode("SnapshotOperationRateExceeded");

		public static BlobErrorCode SnapshotsPresent { get; } = new BlobErrorCode("SnapshotsPresent");

		public static BlobErrorCode SourceConditionNotMet { get; } = new BlobErrorCode("SourceConditionNotMet");

		public static BlobErrorCode SystemInUse { get; } = new BlobErrorCode("SystemInUse");

		public static BlobErrorCode TargetConditionNotMet { get; } = new BlobErrorCode("TargetConditionNotMet");

		public static BlobErrorCode UnauthorizedBlobOverwrite { get; } = new BlobErrorCode("UnauthorizedBlobOverwrite");

		public static BlobErrorCode BlobBeingRehydrated { get; } = new BlobErrorCode("BlobBeingRehydrated");

		public static BlobErrorCode BlobArchived { get; } = new BlobErrorCode("BlobArchived");

		public static BlobErrorCode BlobNotArchived { get; } = new BlobErrorCode("BlobNotArchived");

		public static BlobErrorCode AuthorizationSourceIPMismatch { get; } = new BlobErrorCode("AuthorizationSourceIPMismatch");

		public static BlobErrorCode AuthorizationProtocolMismatch { get; } = new BlobErrorCode("AuthorizationProtocolMismatch");

		public static BlobErrorCode AuthorizationPermissionMismatch { get; } = new BlobErrorCode("AuthorizationPermissionMismatch");

		public static BlobErrorCode AuthorizationServiceMismatch { get; } = new BlobErrorCode("AuthorizationServiceMismatch");

		public static BlobErrorCode AuthorizationResourceTypeMismatch { get; } = new BlobErrorCode("AuthorizationResourceTypeMismatch");

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobErrorCode SnaphotOperationRateExceeded { get; } = new BlobErrorCode("SnaphotOperationRateExceeded");

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static BlobErrorCode IncrementalCopyOfEralierVersionSnapshotNotAllowed { get; } = new BlobErrorCode("IncrementalCopyOfEralierVersionSnapshotNotAllowed");

		public BlobErrorCode(string value)
		{
			_value = value ?? throw new ArgumentNullException("value");
		}

		public static bool operator ==(BlobErrorCode left, BlobErrorCode right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(BlobErrorCode left, BlobErrorCode right)
		{
			return !left.Equals(right);
		}

		public static implicit operator BlobErrorCode(string value)
		{
			return new BlobErrorCode(value);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override bool Equals(object obj)
		{
			if (obj is BlobErrorCode other)
			{
				return Equals(other);
			}
			return false;
		}

		public bool Equals(BlobErrorCode other)
		{
			return string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override int GetHashCode()
		{
			return _value?.GetHashCode() ?? 0;
		}

		public override string ToString()
		{
			return _value;
		}
	}
	internal readonly struct BlobExpiryOptions : IEquatable<BlobExpiryOptions>
	{
		private readonly string _value;

		private const string NeverExpireValue = "NeverExpire";

		private const string RelativeToCreationValue = "RelativeToCreation";

		private const string RelativeToNowValue = "RelativeToNow";

		private const string AbsoluteValue = "Absolute";

		public static BlobExpiryOptions NeverExpire { get; } = new BlobExpiryOptions("NeverExpire");

		public static BlobExpiryOptions RelativeToCreation { get; } = new BlobExpiryOptions("RelativeToCreation");

		public static BlobExpiryOptions RelativeToNow { get; } = new BlobExpiryOptions("RelativeToNow");

		public static BlobExpiryOptions Absolute { get; } = new BlobExpiryOptions("Absolute");

		public BlobExpiryOptions(string value)
		{
			_value = value ?? throw new ArgumentNullException("value");
		}

		public static bool operator ==(BlobExpiryOptions left, BlobExpiryOptions right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(BlobExpiryOptions left, BlobExpiryOptions right)
		{
			return !left.Equals(right);
		}

		public static implicit operator BlobExpiryOptions(string value)
		{
			return new BlobExpiryOptions(value);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override bool Equals(object obj)
		{
			if (obj is BlobExpiryOptions other)
			{
				return Equals(other);
			}
			return false;
		}

		public bool Equals(BlobExpiryOptions other)
		{
			return string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override int GetHashCode()
		{
			return _value?.GetHashCode() ?? 0;
		}

		public override string ToString()
		{
			return _value;
		}
	}
	internal class BlobFlatListSegment
	{
		public IReadOnlyList<BlobItemInternal> BlobItems { get; }

		internal BlobFlatListSegment(IEnumerable<BlobItemInternal> blobItems)
		{
			Azure.Core.Argument.AssertNotNull(blobItems, "blobItems");
			BlobItems = blobItems.ToList();
		}

		internal BlobFlatListSegment(IReadOnlyList<BlobItemInternal> blobItems)
		{
			BlobItems = blobItems;
		}

		internal static BlobFlatListSegment DeserializeBlobFlatListSegment(XElement element)
		{
			List<BlobItemInternal> list = new List<BlobItemInternal>();
			foreach (XElement item in element.Elements("Blob"))
			{
				list.Add(BlobItemInternal.DeserializeBlobItemInternal(item));
			}
			return new BlobFlatListSegment(list);
		}
	}
	[CodeGenModel("GeoReplication")]
	public class BlobGeoReplication
	{
		public BlobGeoReplicationStatus Status { get; }

		[CodeGenMember("LastSyncTime")]
		public DateTimeOffset? LastSyncedOn { get; internal set; }

		internal BlobGeoReplication(BlobGeoReplicationStatus status, DateTimeOffset? lastSyncedOn)
		{
			Status = status;
			LastSyncedOn = lastSyncedOn;
		}

		internal static BlobGeoReplication DeserializeBlobGeoReplication(XElement element)
		{
			BlobGeoReplicationStatus status = BlobGeoReplicationStatus.Live;
			DateTimeOffset? lastSyncedOn = null;
			XElement xElement = element.Element("Status");
			if (xElement != null)
			{
				status = xElement.Value.ToBlobGeoReplicationStatus();
			}
			XElement xElement2 = element.Element("LastSyncTime");
			if (xElement2 != null)
			{
				lastSyncedOn = xElement2.GetDateTimeOffsetValue("R");
			}
			return new BlobGeoReplication(status, lastSyncedOn);
		}
	}
	public enum BlobGeoReplicationStatus
	{
		Live,
		Bootstrap,
		Unavailable
	}
	internal static class BlobGeoReplicationStatusExtensions
	{
		public static string ToSerialString(this BlobGeoReplicationStatus value)
		{
			return value switch
			{
				BlobGeoReplicationStatus.Live => "live", 
				BlobGeoReplicationStatus.Bootstrap => "bootstrap", 
				BlobGeoReplicationStatus.Unavailable => "unavailable", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown BlobGeoReplicationStatus value."), 
			};
		}

		public static BlobGeoReplicationStatus ToBlobGeoReplicationStatus(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "live"))
			{
				return BlobGeoReplicationStatus.Live;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "bootstrap"))
			{
				return BlobGeoReplicationStatus.Bootstrap;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "unavailable"))
			{
				return BlobGeoReplicationStatus.Unavailable;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown BlobGeoReplicationStatus value.");
		}
	}
	internal class BlobHierarchyListSegment
	{
		public IReadOnlyList<BlobPrefix> BlobPrefixes { get; }

		public IReadOnlyList<BlobItemInternal> BlobItems { get; }

		internal BlobHierarchyListSegment(IEnumerable<BlobItemInternal> blobItems)
		{
			Azure.Core.Argument.AssertNotNull(blobItems, "blobItems");
			BlobPrefixes = new Azure.Core.ChangeTrackingList<BlobPrefix>();
			BlobItems = blobItems.ToList();
		}

		internal BlobHierarchyListSegment(IReadOnlyList<BlobPrefix> blobPrefixes, IReadOnlyList<BlobItemInternal> blobItems)
		{
			BlobPrefixes = blobPrefixes;
			BlobItems = blobItems;
		}

		internal static BlobHierarchyListSegment DeserializeBlobHierarchyListSegment(XElement element)
		{
			IReadOnlyList<BlobPrefix> readOnlyList = null;
			IReadOnlyList<BlobItemInternal> readOnlyList2 = null;
			List<BlobPrefix> list = new List<BlobPrefix>();
			foreach (XElement item in element.Elements("BlobPrefix"))
			{
				list.Add(BlobPrefix.DeserializeBlobPrefix(item));
			}
			readOnlyList = list;
			List<BlobItemInternal> list2 = new List<BlobItemInternal>();
			foreach (XElement item2 in element.Elements("Blob"))
			{
				list2.Add(BlobItemInternal.DeserializeBlobItemInternal(item2));
			}
			readOnlyList2 = list2;
			return new BlobHierarchyListSegment(readOnlyList, readOnlyList2);
		}
	}
	internal static class BlobImmutabilityPolicyModeExtensions
	{
		public static string ToSerialString(this BlobImmutabilityPolicyMode value)
		{
			return value switch
			{
				BlobImmutabilityPolicyMode.Mutable => "Mutable", 
				BlobImmutabilityPolicyMode.Unlocked => "Unlocked", 
				BlobImmutabilityPolicyMode.Locked => "Locked", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown BlobImmutabilityPolicyMode value."), 
			};
		}

		public static BlobImmutabilityPolicyMode ToBlobImmutabilityPolicyMode(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "Mutable"))
			{
				return BlobImmutabilityPolicyMode.Mutable;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "Unlocked"))
			{
				return BlobImmutabilityPolicyMode.Unlocked;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "Locked"))
			{
				return BlobImmutabilityPolicyMode.Locked;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown BlobImmutabilityPolicyMode value.");
		}
	}
	internal class BlobItemInternal
	{
		public BlobName Name { get; }

		public bool Deleted { get; }

		public string Snapshot { get; }

		public string VersionId { get; }

		public bool? IsCurrentVersion { get; }

		public BlobPropertiesInternal Properties { get; }

		public IReadOnlyDictionary<string, string> Metadata { get; }

		public BlobTags BlobTags { get; }

		public bool? HasVersionsOnly { get; }

		public IReadOnlyDictionary<string, string> OrMetadata { get; }

		internal BlobItemInternal(BlobName name, bool deleted, string snapshot, BlobPropertiesInternal properties)
		{
			Azure.Core.Argument.AssertNotNull(name, "name");
			Azure.Core.Argument.AssertNotNull(snapshot, "snapshot");
			Azure.Core.Argument.AssertNotNull(properties, "properties");
			Name = name;
			Deleted = deleted;
			Snapshot = snapshot;
			Properties = properties;
			Metadata = new Azure.Core.ChangeTrackingDictionary<string, string>();
			OrMetadata = new Azure.Core.ChangeTrackingDictionary<string, string>();
		}

		internal BlobItemInternal(BlobName name, bool deleted, string snapshot, string versionId, bool? isCurrentVersion, BlobPropertiesInternal properties, IReadOnlyDictionary<string, string> metadata, BlobTags blobTags, bool? hasVersionsOnly, IReadOnlyDictionary<string, string> orMetadata)
		{
			Name = name;
			Deleted = deleted;
			Snapshot = snapshot;
			VersionId = versionId;
			IsCurrentVersion = isCurrentVersion;
			Properties = properties;
			Metadata = metadata;
			BlobTags = blobTags;
			HasVersionsOnly = hasVersionsOnly;
			OrMetadata = orMetadata;
		}

		internal static BlobItemInternal DeserializeBlobItemInternal(XElement element)
		{
			BlobName name = null;
			bool deleted = false;
			string snapshot = null;
			string versionId = null;
			bool? isCurrentVersion = null;
			BlobPropertiesInternal properties = null;
			IReadOnlyDictionary<string, string> metadata = null;
			BlobTags blobTags = null;
			bool? hasVersionsOnly = null;
			IReadOnlyDictionary<string, string> orMetadata = null;
			XElement xElement = element.Element("Name");
			if (xElement != null)
			{
				name = BlobName.DeserializeBlobName(xElement);
			}
			XElement xElement2 = element.Element("Deleted");
			if (xElement2 != null)
			{
				deleted = (bool)xElement2;
			}
			XElement xElement3 = element.Element("Snapshot");
			if (xElement3 != null)
			{
				snapshot = (string)xElement3;
			}
			XElement xElement4 = element.Element("VersionId");
			if (xElement4 != null)
			{
				versionId = (string)xElement4;
			}
			XElement xElement5 = element.Element("IsCurrentVersion");
			if (xElement5 != null)
			{
				isCurrentVersion = (bool?)xElement5;
			}
			XElement xElement6 = element.Element("Properties");
			if (xElement6 != null)
			{
				properties = BlobPropertiesInternal.DeserializeBlobPropertiesInternal(xElement6);
			}
			XElement xElement7 = element.Element("Metadata");
			if (xElement7 != null)
			{
				Dictionary<string, string> dictionary = new Dictionary<string, string>();
				foreach (XElement item in xElement7.Elements())
				{
					dictionary.Add(item.Name.LocalName, (string)item);
				}
				metadata = dictionary;
			}
			XElement xElement8 = element.Element("Tags");
			if (xElement8 != null)
			{
				blobTags = BlobTags.DeserializeBlobTags(xElement8);
			}
			XElement xElement9 = element.Element("HasVersionsOnly");
			if (xElement9 != null)
			{
				hasVersionsOnly = (bool?)xElement9;
			}
			XElement xElement10 = element.Element("OrMetadata");
			if (xElement10 != null)
			{
				Dictionary<string, string> dictionary2 = new Dictionary<string, string>();
				foreach (XElement item2 in xElement10.Elements())
				{
					dictionary2.Add(item2.Name.LocalName, (string)item2);
				}
				orMetadata = dictionary2;
			}
			return new BlobItemInternal(name, deleted, snapshot, versionId, isCurrentVersion, properties, metadata, blobTags, hasVersionsOnly, orMetadata);
		}
	}
	[CodeGenModel("Metrics")]
	public class BlobMetrics : Azure.Core.IXmlSerializable
	{
		public string Version { get; set; }

		public bool Enabled { get; set; }

		public BlobRetentionPolicy RetentionPolicy { get; set; }

		[CodeGenMember("IncludeAPIs")]
		public bool? IncludeApis { get; set; }

		internal BlobMetrics(string version, bool enabled, bool? includeApis, BlobRetentionPolicy retentionPolicy)
		{
			Version = version;
			Enabled = enabled;
			IncludeApis = includeApis;
			RetentionPolicy = retentionPolicy;
		}

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "Metrics");
			if (Azure.Core.Optional.IsDefined(Version))
			{
				writer.WriteStartElement("Version");
				writer.WriteValue(Version);
				writer.WriteEndElement();
			}
			writer.WriteStartElement("Enabled");
			writer.WriteValue(Enabled);
			writer.WriteEndElement();
			if (Azure.Core.Optional.IsDefined(IncludeApis))
			{
				writer.WriteStartElement("IncludeAPIs");
				writer.WriteValue(IncludeApis.Value);
				writer.WriteEndElement();
			}
			if (Azure.Core.Optional.IsDefined(RetentionPolicy))
			{
				writer.WriteObjectValue(RetentionPolicy, "RetentionPolicy");
			}
			writer.WriteEndElement();
		}

		internal static BlobMetrics DeserializeBlobMetrics(XElement element)
		{
			string version = null;
			bool enabled = false;
			bool? includeApis = null;
			BlobRetentionPolicy retentionPolicy = null;
			XElement xElement = element.Element("Version");
			if (xElement != null)
			{
				version = (string)xElement;
			}
			XElement xElement2 = element.Element("Enabled");
			if (xElement2 != null)
			{
				enabled = (bool)xElement2;
			}
			XElement xElement3 = element.Element("IncludeAPIs");
			if (xElement3 != null)
			{
				includeApis = (bool?)xElement3;
			}
			XElement xElement4 = element.Element("RetentionPolicy");
			if (xElement4 != null)
			{
				retentionPolicy = BlobRetentionPolicy.DeserializeBlobRetentionPolicy(xElement4);
			}
			return new BlobMetrics(version, enabled, includeApis, retentionPolicy);
		}

		public BlobMetrics()
			: this(skipInitialization: false)
		{
		}

		internal BlobMetrics(bool skipInitialization)
		{
			if (!skipInitialization)
			{
				RetentionPolicy = new BlobRetentionPolicy();
			}
		}
	}
	internal class BlobName
	{
		public bool? Encoded { get; }

		public string Content { get; }

		internal BlobName()
		{
		}

		internal BlobName(bool? encoded, string content)
		{
			Encoded = encoded;
			Content = content;
		}

		internal static BlobName DeserializeBlobName(XElement element)
		{
			bool? encoded = null;
			string text = null;
			XAttribute xAttribute = element.Attribute("Encoded");
			if (xAttribute != null)
			{
				encoded = (bool?)xAttribute;
			}
			text = (string)element;
			return new BlobName(encoded, text);
		}
	}
	internal class BlobPrefix
	{
		public BlobName Name { get; }

		internal BlobPrefix(BlobName name)
		{
			Azure.Core.Argument.AssertNotNull(name, "name");
			Name = name;
		}

		internal static BlobPrefix DeserializeBlobPrefix(XElement element)
		{
			BlobName name = null;
			XElement xElement = element.Element("Name");
			if (xElement != null)
			{
				name = BlobName.DeserializeBlobName(xElement);
			}
			return new BlobPrefix(name);
		}
	}
	internal class BlobPropertiesInternal
	{
		public DateTimeOffset? CreationTime { get; }

		public DateTimeOffset LastModified { get; }

		public string Etag { get; }

		public long? ContentLength { get; }

		public string ContentType { get; }

		public string ContentEncoding { get; }

		public string ContentLanguage { get; }

		public byte[] ContentMD5 { get; }

		public string ContentDisposition { get; }

		public string CacheControl { get; }

		public long? BlobSequenceNumber { get; }

		public BlobType? BlobType { get; }

		public LeaseStatus? LeaseStatus { get; }

		public LeaseState? LeaseState { get; }

		public LeaseDurationType? LeaseDuration { get; }

		public string CopyId { get; }

		public CopyStatus? CopyStatus { get; }

		public string CopySource { get; }

		public string CopyProgress { get; }

		public DateTimeOffset? CopyCompletionTime { get; }

		public string CopyStatusDescription { get; }

		public bool? ServerEncrypted { get; }

		public bool? IncrementalCopy { get; }

		public string DestinationSnapshot { get; }

		public DateTimeOffset? DeletedTime { get; }

		public int? RemainingRetentionDays { get; }

		public AccessTier? AccessTier { get; }

		public bool? AccessTierInferred { get; }

		public ArchiveStatus? ArchiveStatus { get; }

		public string CustomerProvidedKeySha256 { get; }

		public string EncryptionScope { get; }

		public DateTimeOffset? AccessTierChangeTime { get; }

		public int? TagCount { get; }

		public DateTimeOffset? ExpiresOn { get; }

		public bool? IsSealed { get; }

		public RehydratePriority? RehydratePriority { get; }

		public DateTimeOffset? LastAccessedOn { get; }

		public DateTimeOffset? ImmutabilityPolicyExpiresOn { get; }

		public BlobImmutabilityPolicyMode? ImmutabilityPolicyMode { get; }

		public bool? LegalHold { get; }

		internal BlobPropertiesInternal(DateTimeOffset lastModified, string etag)
		{
			Azure.Core.Argument.AssertNotNull(etag, "etag");
			LastModified = lastModified;
			Etag = etag;
		}

		internal BlobPropertiesInternal(DateTimeOffset? creationTime, DateTimeOffset lastModified, string etag, long? contentLength, string contentType, string contentEncoding, string contentLanguage, byte[] contentMD5, string contentDisposition, string cacheControl, long? blobSequenceNumber, BlobType? blobType, LeaseStatus? leaseStatus, LeaseState? leaseState, LeaseDurationType? leaseDuration, string copyId, CopyStatus? copyStatus, string copySource, string copyProgress, DateTimeOffset? copyCompletionTime, string copyStatusDescription, bool? serverEncrypted, bool? incrementalCopy, string destinationSnapshot, DateTimeOffset? deletedTime, int? remainingRetentionDays, AccessTier? accessTier, bool? accessTierInferred, ArchiveStatus? archiveStatus, string customerProvidedKeySha256, string encryptionScope, DateTimeOffset? accessTierChangeTime, int? tagCount, DateTimeOffset? expiresOn, bool? isSealed, RehydratePriority? rehydratePriority, DateTimeOffset? lastAccessedOn, DateTimeOffset? immutabilityPolicyExpiresOn, BlobImmutabilityPolicyMode? immutabilityPolicyMode, bool? legalHold)
		{
			CreationTime = creationTime;
			LastModified = lastModified;
			Etag = etag;
			ContentLength = contentLength;
			ContentType = contentType;
			ContentEncoding = contentEncoding;
			ContentLanguage = contentLanguage;
			ContentMD5 = contentMD5;
			ContentDisposition = contentDisposition;
			CacheControl = cacheControl;
			BlobSequenceNumber = blobSequenceNumber;
			BlobType = blobType;
			LeaseStatus = leaseStatus;
			LeaseState = leaseState;
			LeaseDuration = leaseDuration;
			CopyId = copyId;
			CopyStatus = copyStatus;
			CopySource = copySource;
			CopyProgress = copyProgress;
			CopyCompletionTime = copyCompletionTime;
			CopyStatusDescription = copyStatusDescription;
			ServerEncrypted = serverEncrypted;
			IncrementalCopy = incrementalCopy;
			DestinationSnapshot = destinationSnapshot;
			DeletedTime = deletedTime;
			RemainingRetentionDays = remainingRetentionDays;
			AccessTier = accessTier;
			AccessTierInferred = accessTierInferred;
			ArchiveStatus = archiveStatus;
			CustomerProvidedKeySha256 = customerProvidedKeySha256;
			EncryptionScope = encryptionScope;
			AccessTierChangeTime = accessTierChangeTime;
			TagCount = tagCount;
			ExpiresOn = expiresOn;
			IsSealed = isSealed;
			RehydratePriority = rehydratePriority;
			LastAccessedOn = lastAccessedOn;
			ImmutabilityPolicyExpiresOn = immutabilityPolicyExpiresOn;
			ImmutabilityPolicyMode = immutabilityPolicyMode;
			LegalHold = legalHold;
		}

		internal static BlobPropertiesInternal DeserializeBlobPropertiesInternal(XElement element)
		{
			DateTimeOffset? creationTime = null;
			DateTimeOffset lastModified = default(DateTimeOffset);
			string etag = null;
			long? contentLength = null;
			string contentType = null;
			string contentEncoding = null;
			string contentLanguage = null;
			byte[] contentMD = null;
			string contentDisposition = null;
			string cacheControl = null;
			long? blobSequenceNumber = null;
			BlobType? blobType = null;
			LeaseStatus? leaseStatus = null;
			LeaseState? leaseState = null;
			LeaseDurationType? leaseDuration = null;
			string copyId = null;
			CopyStatus? copyStatus = null;
			string copySource = null;
			string copyProgress = null;
			DateTimeOffset? copyCompletionTime = null;
			string copyStatusDescription = null;
			bool? serverEncrypted = null;
			bool? incrementalCopy = null;
			string destinationSnapshot = null;
			DateTimeOffset? deletedTime = null;
			int? remainingRetentionDays = null;
			AccessTier? accessTier = null;
			bool? accessTierInferred = null;
			ArchiveStatus? archiveStatus = null;
			string customerProvidedKeySha = null;
			string encryptionScope = null;
			DateTimeOffset? accessTierChangeTime = null;
			int? tagCount = null;
			DateTimeOffset? expiresOn = null;
			bool? isSealed = null;
			RehydratePriority? rehydratePriority = null;
			DateTimeOffset? lastAccessedOn = null;
			DateTimeOffset? immutabilityPolicyExpiresOn = null;
			BlobImmutabilityPolicyMode? immutabilityPolicyMode = null;
			bool? legalHold = null;
			XElement xElement = element.Element("Creation-Time");
			if (xElement != null)
			{
				creationTime = xElement.GetDateTimeOffsetValue("R");
			}
			XElement xElement2 = element.Element("Last-Modified");
			if (xElement2 != null)
			{
				lastModified = xElement2.GetDateTimeOffsetValue("R");
			}
			XElement xElement3 = element.Element("Etag");
			if (xElement3 != null)
			{
				etag = (string)xElement3;
			}
			XElement xElement4 = element.Element("Content-Length");
			if (xElement4 != null)
			{
				contentLength = (long?)xElement4;
			}
			XElement xElement5 = element.Element("Content-Type");
			if (xElement5 != null)
			{
				contentType = (string)xElement5;
			}
			XElement xElement6 = element.Element("Content-Encoding");
			if (xElement6 != null)
			{
				contentEncoding = (string)xElement6;
			}
			XElement xElement7 = element.Element("Content-Language");
			if (xElement7 != null)
			{
				contentLanguage = (string)xElement7;
			}
			XElement xElement8 = element.Element("Content-MD5");
			if (xElement8 != null)
			{
				contentMD = xElement8.GetBytesFromBase64Value("D");
			}
			XElement xElement9 = element.Element("Content-Disposition");
			if (xElement9 != null)
			{
				contentDisposition = (string)xElement9;
			}
			XElement xElement10 = element.Element("Cache-Control");
			if (xElement10 != null)
			{
				cacheControl = (string)xElement10;
			}
			XElement xElement11 = element.Element("x-ms-blob-sequence-number");
			if (xElement11 != null)
			{
				blobSequenceNumber = (long?)xElement11;
			}
			XElement xElement12 = element.Element("BlobType");
			if (xElement12 != null)
			{
				blobType = xElement12.Value.ToBlobType();
			}
			XElement xElement13 = element.Element("LeaseStatus");
			if (xElement13 != null)
			{
				leaseStatus = xElement13.Value.ToLeaseStatus();
			}
			XElement xElement14 = element.Element("LeaseState");
			if (xElement14 != null)
			{
				leaseState = xElement14.Value.ToLeaseState();
			}
			XElement xElement15 = element.Element("LeaseDuration");
			if (xElement15 != null)
			{
				leaseDuration = xElement15.Value.ToLeaseDurationType();
			}
			XElement xElement16 = element.Element("CopyId");
			if (xElement16 != null)
			{
				copyId = (string)xElement16;
			}
			XElement xElement17 = element.Element("CopyStatus");
			if (xElement17 != null)
			{
				copyStatus = xElement17.Value.ToCopyStatus();
			}
			XElement xElement18 = element.Element("CopySource");
			if (xElement18 != null)
			{
				copySource = (string)xElement18;
			}
			XElement xElement19 = element.Element("CopyProgress");
			if (xElement19 != null)
			{
				copyProgress = (string)xElement19;
			}
			XElement xElement20 = element.Element("CopyCompletionTime");
			if (xElement20 != null)
			{
				copyCompletionTime = xElement20.GetDateTimeOffsetValue("R");
			}
			XElement xElement21 = element.Element("CopyStatusDescription");
			if (xElement21 != null)
			{
				copyStatusDescription = (string)xElement21;
			}
			XElement xElement22 = element.Element("ServerEncrypted");
			if (xElement22 != null)
			{
				serverEncrypted = (bool?)xElement22;
			}
			XElement xElement23 = element.Element("IncrementalCopy");
			if (xElement23 != null)
			{
				incrementalCopy = (bool?)xElement23;
			}
			XElement xElement24 = element.Element("DestinationSnapshot");
			if (xElement24 != null)
			{
				destinationSnapshot = (string)xElement24;
			}
			XElement xElement25 = element.Element("DeletedTime");
			if (xElement25 != null)
			{
				deletedTime = xElement25.GetDateTimeOffsetValue("R");
			}
			XElement xElement26 = element.Element("RemainingRetentionDays");
			if (xElement26 != null)
			{
				remainingRetentionDays = (int?)xElement26;
			}
			XElement xElement27 = element.Element("AccessTier");
			if (xElement27 != null)
			{
				accessTier = new AccessTier(xElement27.Value);
			}
			XElement xElement28 = element.Element("AccessTierInferred");
			if (xElement28 != null)
			{
				accessTierInferred = (bool?)xElement28;
			}
			XElement xElement29 = element.Element("ArchiveStatus");
			if (xElement29 != null)
			{
				archiveStatus = xElement29.Value.ToArchiveStatus();
			}
			XElement xElement30 = element.Element("CustomerProvidedKeySha256");
			if (xElement30 != null)
			{
				customerProvidedKeySha = (string)xElement30;
			}
			XElement xElement31 = element.Element("EncryptionScope");
			if (xElement31 != null)
			{
				encryptionScope = (string)xElement31;
			}
			XElement xElement32 = element.Element("AccessTierChangeTime");
			if (xElement32 != null)
			{
				accessTierChangeTime = xElement32.GetDateTimeOffsetValue("R");
			}
			XElement xElement33 = element.Element("TagCount");
			if (xElement33 != null)
			{
				tagCount = (int?)xElement33;
			}
			XElement xElement34 = element.Element("Expiry-Time");
			if (xElement34 != null)
			{
				expiresOn = xElement34.GetDateTimeOffsetValue("R");
			}
			XElement xElement35 = element.Element("Sealed");
			if (xElement35 != null)
			{
				isSealed = (bool?)xElement35;
			}
			XElement xElement36 = element.Element("RehydratePriority");
			if (xElement36 != null)
			{
				rehydratePriority = xElement36.Value.ToRehydratePriority();
			}
			XElement xElement37 = element.Element("LastAccessTime");
			if (xElement37 != null)
			{
				lastAccessedOn = xElement37.GetDateTimeOffsetValue("R");
			}
			XElement xElement38 = element.Element("ImmutabilityPolicyUntilDate");
			if (xElement38 != null)
			{
				immutabilityPolicyExpiresOn = xElement38.GetDateTimeOffsetValue("R");
			}
			XElement xElement39 = element.Element("ImmutabilityPolicyMode");
			if (xElement39 != null)
			{
				immutabilityPolicyMode = xElement39.Value.ToBlobImmutabilityPolicyMode();
			}
			XElement xElement40 = element.Element("LegalHold");
			if (xElement40 != null)
			{
				legalHold = (bool?)xElement40;
			}
			return new BlobPropertiesInternal(creationTime, lastModified, etag, contentLength, contentType, contentEncoding, contentLanguage, contentMD, contentDisposition, cacheControl, blobSequenceNumber, blobType, leaseStatus, leaseState, leaseDuration, copyId, copyStatus, copySource, copyProgress, copyCompletionTime, copyStatusDescription, serverEncrypted, incrementalCopy, destinationSnapshot, deletedTime, remainingRetentionDays, accessTier, accessTierInferred, archiveStatus, customerProvidedKeySha, encryptionScope, accessTierChangeTime, tagCount, expiresOn, isSealed, rehydratePriority, lastAccessedOn, immutabilityPolicyExpiresOn, immutabilityPolicyMode, legalHold);
		}
	}
	[CodeGenModel("RetentionPolicy")]
	public class BlobRetentionPolicy : Azure.Core.IXmlSerializable
	{
		public bool Enabled { get; set; }

		public int? Days { get; set; }

		internal bool? AllowPermanentDelete { get; set; }

		internal BlobRetentionPolicy(bool enabled, int? days, bool? allowPermanentDelete)
		{
			Enabled = enabled;
			Days = days;
			AllowPermanentDelete = allowPermanentDelete;
		}

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "RetentionPolicy");
			writer.WriteStartElement("Enabled");
			writer.WriteValue(Enabled);
			writer.WriteEndElement();
			if (Azure.Core.Optional.IsDefined(Days))
			{
				writer.WriteStartElement("Days");
				writer.WriteValue(Days.Value);
				writer.WriteEndElement();
			}
			if (Azure.Core.Optional.IsDefined(AllowPermanentDelete))
			{
				writer.WriteStartElement("AllowPermanentDelete");
				writer.WriteValue(AllowPermanentDelete.Value);
				writer.WriteEndElement();
			}
			writer.WriteEndElement();
		}

		internal static BlobRetentionPolicy DeserializeBlobRetentionPolicy(XElement element)
		{
			bool enabled = false;
			int? days = null;
			bool? allowPermanentDelete = null;
			XElement xElement = element.Element("Enabled");
			if (xElement != null)
			{
				enabled = (bool)xElement;
			}
			XElement xElement2 = element.Element("Days");
			if (xElement2 != null)
			{
				days = (int?)xElement2;
			}
			XElement xElement3 = element.Element("AllowPermanentDelete");
			if (xElement3 != null)
			{
				allowPermanentDelete = (bool?)xElement3;
			}
			return new BlobRetentionPolicy(enabled, days, allowPermanentDelete);
		}

		public BlobRetentionPolicy()
		{
		}

		internal BlobRetentionPolicy(bool enabled)
		{
			Enabled = enabled;
		}
	}
	[CodeGenModel("StorageServiceProperties")]
	public class BlobServiceProperties : Azure.Core.IXmlSerializable
	{
		public BlobAnalyticsLogging Logging { get; set; }

		public BlobMetrics HourMetrics { get; set; }

		public BlobMetrics MinuteMetrics { get; set; }

		public string DefaultServiceVersion { get; set; }

		public BlobRetentionPolicy DeleteRetentionPolicy { get; set; }

		public BlobStaticWebsite StaticWebsite { get; set; }

		public IList<BlobCorsRule> Cors { get; set; }

		internal BlobServiceProperties(BlobAnalyticsLogging logging, BlobMetrics hourMetrics, BlobMetrics minuteMetrics, IList<BlobCorsRule> cors, string defaultServiceVersion, BlobRetentionPolicy deleteRetentionPolicy, BlobStaticWebsite staticWebsite)
		{
			Logging = logging;
			HourMetrics = hourMetrics;
			MinuteMetrics = minuteMetrics;
			Cors = cors;
			DefaultServiceVersion = defaultServiceVersion;
			DeleteRetentionPolicy = deleteRetentionPolicy;
			StaticWebsite = staticWebsite;
		}

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "StorageServiceProperties");
			if (Azure.Core.Optional.IsDefined(Logging))
			{
				writer.WriteObjectValue(Logging, "Logging");
			}
			if (Azure.Core.Optional.IsDefined(HourMetrics))
			{
				writer.WriteObjectValue(HourMetrics, "HourMetrics");
			}
			if (Azure.Core.Optional.IsDefined(MinuteMetrics))
			{
				writer.WriteObjectValue(MinuteMetrics, "MinuteMetrics");
			}
			if (Azure.Core.Optional.IsDefined(DefaultServiceVersion))
			{
				writer.WriteStartElement("DefaultServiceVersion");
				writer.WriteValue(DefaultServiceVersion);
				writer.WriteEndElement();
			}
			if (Azure.Core.Optional.IsDefined(DeleteRetentionPolicy))
			{
				writer.WriteObjectValue(DeleteRetentionPolicy, "DeleteRetentionPolicy");
			}
			if (Azure.Core.Optional.IsDefined(StaticWebsite))
			{
				writer.WriteObjectValue(StaticWebsite, "StaticWebsite");
			}
			if (Azure.Core.Optional.IsCollectionDefined(Cors))
			{
				writer.WriteStartElement("Cors");
				foreach (BlobCorsRule cor in Cors)
				{
					writer.WriteObjectValue(cor, "CorsRule");
				}
				writer.WriteEndElement();
			}
			writer.WriteEndElement();
		}

		internal static BlobServiceProperties DeserializeBlobServiceProperties(XElement element)
		{
			BlobAnalyticsLogging logging = null;
			BlobMetrics hourMetrics = null;
			BlobMetrics minuteMetrics = null;
			string defaultServiceVersion = null;
			BlobRetentionPolicy deleteRetentionPolicy = null;
			BlobStaticWebsite staticWebsite = null;
			IList<BlobCorsRule> cors = null;
			XElement xElement = element.Element("Logging");
			if (xElement != null)
			{
				logging = BlobAnalyticsLogging.DeserializeBlobAnalyticsLogging(xElement);
			}
			XElement xElement2 = element.Element("HourMetrics");
			if (xElement2 != null)
			{
				hourMetrics = BlobMetrics.DeserializeBlobMetrics(xElement2);
			}
			XElement xElement3 = element.Element("MinuteMetrics");
			if (xElement3 != null)
			{
				minuteMetrics = BlobMetrics.DeserializeBlobMetrics(xElement3);
			}
			XElement xElement4 = element.Element("DefaultServiceVersion");
			if (xElement4 != null)
			{
				defaultServiceVersion = (string)xElement4;
			}
			XElement xElement5 = element.Element("DeleteRetentionPolicy");
			if (xElement5 != null)
			{
				deleteRetentionPolicy = BlobRetentionPolicy.DeserializeBlobRetentionPolicy(xElement5);
			}
			XElement xElement6 = element.Element("StaticWebsite");
			if (xElement6 != null)
			{
				staticWebsite = BlobStaticWebsite.DeserializeBlobStaticWebsite(xElement6);
			}
			XElement xElement7 = element.Element("Cors");
			if (xElement7 != null)
			{
				List<BlobCorsRule> list = new List<BlobCorsRule>();
				foreach (XElement item in xElement7.Elements("CorsRule"))
				{
					list.Add(BlobCorsRule.DeserializeBlobCorsRule(item));
				}
				cors = list;
			}
			return new BlobServiceProperties(logging, hourMetrics, minuteMetrics, cors, defaultServiceVersion, deleteRetentionPolicy, staticWebsite);
		}

		public BlobServiceProperties()
			: this(skipInitialization: false)
		{
		}

		internal BlobServiceProperties(bool skipInitialization)
		{
			if (!skipInitialization)
			{
				Logging = new BlobAnalyticsLogging();
				HourMetrics = new BlobMetrics();
				MinuteMetrics = new BlobMetrics();
				DeleteRetentionPolicy = new BlobRetentionPolicy();
				StaticWebsite = new BlobStaticWebsite();
			}
		}
	}
	[CodeGenModel("StorageServiceStats")]
	public class BlobServiceStatistics
	{
		public BlobGeoReplication GeoReplication { get; }

		internal BlobServiceStatistics()
		{
		}

		internal BlobServiceStatistics(BlobGeoReplication geoReplication)
		{
			GeoReplication = geoReplication;
		}

		internal static BlobServiceStatistics DeserializeBlobServiceStatistics(XElement element)
		{
			BlobGeoReplication geoReplication = null;
			XElement xElement = element.Element("GeoReplication");
			if (xElement != null)
			{
				geoReplication = BlobGeoReplication.DeserializeBlobGeoReplication(xElement);
			}
			return new BlobServiceStatistics(geoReplication);
		}
	}
	[CodeGenModel("SignedIdentifier")]
	public class BlobSignedIdentifier : Azure.Core.IXmlSerializable
	{
		public string Id { get; set; }

		public BlobAccessPolicy AccessPolicy { get; set; }

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "SignedIdentifier");
			writer.WriteStartElement("Id");
			writer.WriteValue(Id);
			writer.WriteEndElement();
			writer.WriteObjectValue(AccessPolicy, "AccessPolicy");
			writer.WriteEndElement();
		}

		internal static BlobSignedIdentifier DeserializeBlobSignedIdentifier(XElement element)
		{
			string id = null;
			BlobAccessPolicy accessPolicy = null;
			XElement xElement = element.Element("Id");
			if (xElement != null)
			{
				id = (string)xElement;
			}
			XElement xElement2 = element.Element("AccessPolicy");
			if (xElement2 != null)
			{
				accessPolicy = BlobAccessPolicy.DeserializeBlobAccessPolicy(xElement2);
			}
			return new BlobSignedIdentifier(id, accessPolicy);
		}

		internal BlobSignedIdentifier(string id, BlobAccessPolicy accessPolicy)
		{
			if (id == null)
			{
				throw new ArgumentNullException("id");
			}
			Id = id;
			AccessPolicy = accessPolicy;
		}

		public BlobSignedIdentifier()
			: this(skipInitialization: false)
		{
		}

		internal BlobSignedIdentifier(bool skipInitialization)
		{
			if (!skipInitialization)
			{
				AccessPolicy = new BlobAccessPolicy();
			}
		}
	}
	[CodeGenModel("StaticWebsite")]
	public class BlobStaticWebsite : Azure.Core.IXmlSerializable
	{
		public bool Enabled { get; set; }

		public string IndexDocument { get; set; }

		public string ErrorDocument404Path { get; set; }

		public string DefaultIndexDocumentPath { get; set; }

		internal BlobStaticWebsite(bool enabled, string indexDocument, string errorDocument404Path, string defaultIndexDocumentPath)
		{
			Enabled = enabled;
			IndexDocument = indexDocument;
			ErrorDocument404Path = errorDocument404Path;
			DefaultIndexDocumentPath = defaultIndexDocumentPath;
		}

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "StaticWebsite");
			writer.WriteStartElement("Enabled");
			writer.WriteValue(Enabled);
			writer.WriteEndElement();
			if (Azure.Core.Optional.IsDefined(IndexDocument))
			{
				writer.WriteStartElement("IndexDocument");
				writer.WriteValue(IndexDocument);
				writer.WriteEndElement();
			}
			if (Azure.Core.Optional.IsDefined(ErrorDocument404Path))
			{
				writer.WriteStartElement("ErrorDocument404Path");
				writer.WriteValue(ErrorDocument404Path);
				writer.WriteEndElement();
			}
			if (Azure.Core.Optional.IsDefined(DefaultIndexDocumentPath))
			{
				writer.WriteStartElement("DefaultIndexDocumentPath");
				writer.WriteValue(DefaultIndexDocumentPath);
				writer.WriteEndElement();
			}
			writer.WriteEndElement();
		}

		internal static BlobStaticWebsite DeserializeBlobStaticWebsite(XElement element)
		{
			bool enabled = false;
			string indexDocument = null;
			string errorDocument404Path = null;
			string defaultIndexDocumentPath = null;
			XElement xElement = element.Element("Enabled");
			if (xElement != null)
			{
				enabled = (bool)xElement;
			}
			XElement xElement2 = element.Element("IndexDocument");
			if (xElement2 != null)
			{
				indexDocument = (string)xElement2;
			}
			XElement xElement3 = element.Element("ErrorDocument404Path");
			if (xElement3 != null)
			{
				errorDocument404Path = (string)xElement3;
			}
			XElement xElement4 = element.Element("DefaultIndexDocumentPath");
			if (xElement4 != null)
			{
				defaultIndexDocumentPath = (string)xElement4;
			}
			return new BlobStaticWebsite(enabled, indexDocument, errorDocument404Path, defaultIndexDocumentPath);
		}

		public BlobStaticWebsite()
		{
		}

		internal BlobStaticWebsite(bool enabled)
		{
			Enabled = enabled;
		}
	}
	internal class BlobTag : Azure.Core.IXmlSerializable
	{
		public string Key { get; set; }

		public string Value { get; set; }

		public BlobTag(string key, string value)
		{
			Azure.Core.Argument.AssertNotNull(key, "key");
			Azure.Core.Argument.AssertNotNull(value, "value");
			Key = key;
			Value = value;
		}

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "Tag");
			writer.WriteStartElement("Key");
			writer.WriteValue(Key);
			writer.WriteEndElement();
			writer.WriteStartElement("Value");
			writer.WriteValue(Value);
			writer.WriteEndElement();
			writer.WriteEndElement();
		}

		internal static BlobTag DeserializeBlobTag(XElement element)
		{
			string key = null;
			string value = null;
			XElement xElement = element.Element("Key");
			if (xElement != null)
			{
				key = (string)xElement;
			}
			XElement xElement2 = element.Element("Value");
			if (xElement2 != null)
			{
				value = (string)xElement2;
			}
			return new BlobTag(key, value);
		}
	}
	internal class BlobTags : Azure.Core.IXmlSerializable
	{
		public IList<BlobTag> BlobTagSet { get; }

		public BlobTags(IEnumerable<BlobTag> blobTagSet)
		{
			Azure.Core.Argument.AssertNotNull(blobTagSet, "blobTagSet");
			BlobTagSet = blobTagSet.ToList();
		}

		internal BlobTags(IList<BlobTag> blobTagSet)
		{
			BlobTagSet = blobTagSet;
		}

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "Tags");
			writer.WriteStartElement("TagSet");
			foreach (BlobTag item in BlobTagSet)
			{
				writer.WriteObjectValue(item, "Tag");
			}
			writer.WriteEndElement();
			writer.WriteEndElement();
		}

		internal static BlobTags DeserializeBlobTags(XElement element)
		{
			IList<BlobTag> blobTagSet = null;
			XElement xElement = element.Element("TagSet");
			if (xElement != null)
			{
				List<BlobTag> list = new List<BlobTag>();
				foreach (XElement item in xElement.Elements("Tag"))
				{
					list.Add(BlobTag.DeserializeBlobTag(item));
				}
				blobTagSet = list;
			}
			return new BlobTags(blobTagSet);
		}
	}
	internal static class BlobTypeExtensions
	{
		public static string ToSerialString(this BlobType value)
		{
			return value switch
			{
				BlobType.Block => "BlockBlob", 
				BlobType.Page => "PageBlob", 
				BlobType.Append => "AppendBlob", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown BlobType value."), 
			};
		}

		public static BlobType ToBlobType(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "BlockBlob"))
			{
				return BlobType.Block;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "PageBlob"))
			{
				return BlobType.Page;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "AppendBlob"))
			{
				return BlobType.Append;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown BlobType value.");
		}
	}
	public class BlockList
	{
		public DateTimeOffset LastModified { get; internal set; }

		public ETag ETag { get; internal set; }

		public string ContentType { get; internal set; }

		public long BlobContentLength { get; internal set; }

		public IEnumerable<BlobBlock> CommittedBlocks { get; internal set; }

		public IEnumerable<BlobBlock> UncommittedBlocks { get; internal set; }

		internal BlockList()
		{
			CommittedBlocks = new Azure.Core.ChangeTrackingList<BlobBlock>();
			UncommittedBlocks = new Azure.Core.ChangeTrackingList<BlobBlock>();
		}

		internal BlockList(IEnumerable<BlobBlock> committedBlocks, IEnumerable<BlobBlock> uncommittedBlocks)
		{
			CommittedBlocks = committedBlocks;
			UncommittedBlocks = uncommittedBlocks;
		}

		internal static BlockList DeserializeBlockList(XElement element)
		{
			IEnumerable<BlobBlock> committedBlocks = null;
			IEnumerable<BlobBlock> uncommittedBlocks = null;
			XElement xElement = element.Element("CommittedBlocks");
			if (xElement != null)
			{
				List<BlobBlock> list = new List<BlobBlock>();
				foreach (XElement item in xElement.Elements("Block"))
				{
					list.Add(BlobBlock.DeserializeBlobBlock(item));
				}
				committedBlocks = list;
			}
			XElement xElement2 = element.Element("UncommittedBlocks");
			if (xElement2 != null)
			{
				List<BlobBlock> list2 = new List<BlobBlock>();
				foreach (XElement item2 in xElement2.Elements("Block"))
				{
					list2.Add(BlobBlock.DeserializeBlobBlock(item2));
				}
				uncommittedBlocks = list2;
			}
			return new BlockList(committedBlocks, uncommittedBlocks);
		}
	}
	internal static class BlockListTypeExtensions
	{
		public static string ToSerialString(this BlockListType value)
		{
			return value switch
			{
				BlockListType.Committed => "committed", 
				BlockListType.Uncommitted => "uncommitted", 
				BlockListType.All => "all", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown BlockListType value."), 
			};
		}

		public static BlockListType ToBlockListType(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "committed"))
			{
				return BlockListType.Committed;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "uncommitted"))
			{
				return BlockListType.Uncommitted;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "all"))
			{
				return BlockListType.All;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown BlockListType value.");
		}
	}
	internal class BlockLookupList : Azure.Core.IXmlSerializable
	{
		public IList<string> Committed { get; set; }

		public IList<string> Uncommitted { get; set; }

		public IList<string> Latest { get; set; }

		public BlockLookupList()
		{
			Committed = new Azure.Core.ChangeTrackingList<string>();
			Uncommitted = new Azure.Core.ChangeTrackingList<string>();
			Latest = new Azure.Core.ChangeTrackingList<string>();
		}

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "BlockList");
			if (Azure.Core.Optional.IsCollectionDefined(Committed))
			{
				foreach (string item in Committed)
				{
					writer.WriteStartElement("Committed");
					writer.WriteValue(item);
					writer.WriteEndElement();
				}
			}
			if (Azure.Core.Optional.IsCollectionDefined(Uncommitted))
			{
				foreach (string item2 in Uncommitted)
				{
					writer.WriteStartElement("Uncommitted");
					writer.WriteValue(item2);
					writer.WriteEndElement();
				}
			}
			if (Azure.Core.Optional.IsCollectionDefined(Latest))
			{
				foreach (string item3 in Latest)
				{
					writer.WriteStartElement("Latest");
					writer.WriteValue(item3);
					writer.WriteEndElement();
				}
			}
			writer.WriteEndElement();
		}
	}
	internal class ClearRange
	{
		public long Start { get; }

		public long End { get; }

		internal ClearRange(long start, long end)
		{
			Start = start;
			End = end;
		}

		internal static ClearRange DeserializeClearRange(XElement element)
		{
			long start = 0L;
			long end = 0L;
			XElement xElement = element.Element("Start");
			if (xElement != null)
			{
				start = (long)xElement;
			}
			XElement xElement2 = element.Element("End");
			if (xElement2 != null)
			{
				end = (long)xElement2;
			}
			return new ClearRange(start, end);
		}
	}
	[CodeGenModel("ContainerItem")]
	internal class ContainerItemInternal
	{
		public string Name { get; }

		public bool? Deleted { get; }

		public string Version { get; }

		public ContainerPropertiesInternal Properties { get; }

		public IReadOnlyDictionary<string, string> Metadata { get; }

		internal ContainerItemInternal(string name, ContainerPropertiesInternal properties)
		{
			Azure.Core.Argument.AssertNotNull(name, "name");
			Azure.Core.Argument.AssertNotNull(properties, "properties");
			Name = name;
			Properties = properties;
			Metadata = new Azure.Core.ChangeTrackingDictionary<string, string>();
		}

		internal ContainerItemInternal(string name, bool? deleted, string version, ContainerPropertiesInternal properties, IReadOnlyDictionary<string, string> metadata)
		{
			Name = name;
			Deleted = deleted;
			Version = version;
			Properties = properties;
			Metadata = metadata;
		}

		internal static ContainerItemInternal DeserializeContainerItemInternal(XElement element)
		{
			string name = null;
			bool? deleted = null;
			string version = null;
			ContainerPropertiesInternal properties = null;
			IReadOnlyDictionary<string, string> metadata = null;
			XElement xElement = element.Element("Name");
			if (xElement != null)
			{
				name = (string)xElement;
			}
			XElement xElement2 = element.Element("Deleted");
			if (xElement2 != null)
			{
				deleted = (bool?)xElement2;
			}
			XElement xElement3 = element.Element("Version");
			if (xElement3 != null)
			{
				version = (string)xElement3;
			}
			XElement xElement4 = element.Element("Properties");
			if (xElement4 != null)
			{
				properties = ContainerPropertiesInternal.DeserializeContainerPropertiesInternal(xElement4);
			}
			XElement xElement5 = element.Element("Metadata");
			if (xElement5 != null)
			{
				Dictionary<string, string> dictionary = new Dictionary<string, string>();
				foreach (XElement item in xElement5.Elements())
				{
					dictionary.Add(item.Name.LocalName, (string)item);
				}
				metadata = dictionary;
			}
			return new ContainerItemInternal(name, deleted, version, properties, metadata);
		}
	}
	[CodeGenModel("ContainerProperties")]
	internal class ContainerPropertiesInternal
	{
		public DateTimeOffset LastModified { get; }

		public string Etag { get; }

		public LeaseStatus? LeaseStatus { get; }

		public LeaseState? LeaseState { get; }

		public LeaseDurationType? LeaseDuration { get; }

		public PublicAccessType? PublicAccess { get; }

		public bool? HasImmutabilityPolicy { get; }

		public bool? HasLegalHold { get; }

		public string DefaultEncryptionScope { get; }

		public bool? PreventEncryptionScopeOverride { get; }

		public DateTimeOffset? DeletedTime { get; }

		public int? RemainingRetentionDays { get; }

		public bool? IsImmutableStorageWithVersioningEnabled { get; }

		internal ContainerPropertiesInternal(DateTimeOffset lastModified, string etag)
		{
			Azure.Core.Argument.AssertNotNull(etag, "etag");
			LastModified = lastModified;
			Etag = etag;
		}

		internal ContainerPropertiesInternal(DateTimeOffset lastModified, string etag, LeaseStatus? leaseStatus, LeaseState? leaseState, LeaseDurationType? leaseDuration, PublicAccessType? publicAccess, bool? hasImmutabilityPolicy, bool? hasLegalHold, string defaultEncryptionScope, bool? preventEncryptionScopeOverride, DateTimeOffset? deletedTime, int? remainingRetentionDays, bool? isImmutableStorageWithVersioningEnabled)
		{
			LastModified = lastModified;
			Etag = etag;
			LeaseStatus = leaseStatus;
			LeaseState = leaseState;
			LeaseDuration = leaseDuration;
			PublicAccess = publicAccess;
			HasImmutabilityPolicy = hasImmutabilityPolicy;
			HasLegalHold = hasLegalHold;
			DefaultEncryptionScope = defaultEncryptionScope;
			PreventEncryptionScopeOverride = preventEncryptionScopeOverride;
			DeletedTime = deletedTime;
			RemainingRetentionDays = remainingRetentionDays;
			IsImmutableStorageWithVersioningEnabled = isImmutableStorageWithVersioningEnabled;
		}

		internal static ContainerPropertiesInternal DeserializeContainerPropertiesInternal(XElement element)
		{
			DateTimeOffset lastModified = default(DateTimeOffset);
			string etag = null;
			LeaseStatus? leaseStatus = null;
			LeaseState? leaseState = null;
			LeaseDurationType? leaseDuration = null;
			PublicAccessType? publicAccess = null;
			bool? hasImmutabilityPolicy = null;
			bool? hasLegalHold = null;
			string defaultEncryptionScope = null;
			bool? preventEncryptionScopeOverride = null;
			DateTimeOffset? deletedTime = null;
			int? remainingRetentionDays = null;
			bool? isImmutableStorageWithVersioningEnabled = null;
			XElement xElement = element.Element("Last-Modified");
			if (xElement != null)
			{
				lastModified = xElement.GetDateTimeOffsetValue("R");
			}
			XElement xElement2 = element.Element("Etag");
			if (xElement2 != null)
			{
				etag = (string)xElement2;
			}
			XElement xElement3 = element.Element("LeaseStatus");
			if (xElement3 != null)
			{
				leaseStatus = xElement3.Value.ToLeaseStatus();
			}
			XElement xElement4 = element.Element("LeaseState");
			if (xElement4 != null)
			{
				leaseState = xElement4.Value.ToLeaseState();
			}
			XElement xElement5 = element.Element("LeaseDuration");
			if (xElement5 != null)
			{
				leaseDuration = xElement5.Value.ToLeaseDurationType();
			}
			XElement xElement6 = element.Element("PublicAccess");
			if (xElement6 != null)
			{
				publicAccess = xElement6.Value.ToPublicAccessType();
			}
			XElement xElement7 = element.Element("HasImmutabilityPolicy");
			if (xElement7 != null)
			{
				hasImmutabilityPolicy = (bool?)xElement7;
			}
			XElement xElement8 = element.Element("HasLegalHold");
			if (xElement8 != null)
			{
				hasLegalHold = (bool?)xElement8;
			}
			XElement xElement9 = element.Element("DefaultEncryptionScope");
			if (xElement9 != null)
			{
				defaultEncryptionScope = (string)xElement9;
			}
			XElement xElement10 = element.Element("DenyEncryptionScopeOverride");
			if (xElement10 != null)
			{
				preventEncryptionScopeOverride = (bool?)xElement10;
			}
			XElement xElement11 = element.Element("DeletedTime");
			if (xElement11 != null)
			{
				deletedTime = xElement11.GetDateTimeOffsetValue("R");
			}
			XElement xElement12 = element.Element("RemainingRetentionDays");
			if (xElement12 != null)
			{
				remainingRetentionDays = (int?)xElement12;
			}
			XElement xElement13 = element.Element("ImmutableStorageWithVersioningEnabled");
			if (xElement13 != null)
			{
				isImmutableStorageWithVersioningEnabled = (bool?)xElement13;
			}
			return new ContainerPropertiesInternal(lastModified, etag, leaseStatus, leaseState, leaseDuration, publicAccess, hasImmutabilityPolicy, hasLegalHold, defaultEncryptionScope, preventEncryptionScopeOverride, deletedTime, remainingRetentionDays, isImmutableStorageWithVersioningEnabled);
		}
	}
	internal static class CopyStatusExtensions
	{
		public static string ToSerialString(this CopyStatus value)
		{
			return value switch
			{
				CopyStatus.Pending => "pending", 
				CopyStatus.Success => "success", 
				CopyStatus.Aborted => "aborted", 
				CopyStatus.Failed => "failed", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown CopyStatus value."), 
			};
		}

		public static CopyStatus ToCopyStatus(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "pending"))
			{
				return CopyStatus.Pending;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "success"))
			{
				return CopyStatus.Success;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "aborted"))
			{
				return CopyStatus.Aborted;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "failed"))
			{
				return CopyStatus.Failed;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown CopyStatus value.");
		}
	}
	internal static class DeleteSnapshotsOptionExtensions
	{
		public static string ToSerialString(this DeleteSnapshotsOption value)
		{
			return value switch
			{
				DeleteSnapshotsOption.IncludeSnapshots => "include", 
				DeleteSnapshotsOption.OnlySnapshots => "only", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown DeleteSnapshotsOption value."), 
			};
		}

		public static DeleteSnapshotsOption ToDeleteSnapshotsOption(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "include"))
			{
				return DeleteSnapshotsOption.IncludeSnapshots;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "only"))
			{
				return DeleteSnapshotsOption.OnlySnapshots;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown DeleteSnapshotsOption value.");
		}
	}
	[CodeGenModel("DelimitedTextConfiguration")]
	internal class DelimitedTextConfigurationInternal : Azure.Core.IXmlSerializable
	{
		public string ColumnSeparator { get; set; }

		public string FieldQuote { get; set; }

		public string RecordSeparator { get; set; }

		public string EscapeChar { get; set; }

		public bool? HeadersPresent { get; set; }

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "DelimitedTextConfiguration");
			if (Azure.Core.Optional.IsDefined(ColumnSeparator))
			{
				writer.WriteStartElement("ColumnSeparator");
				writer.WriteValue(ColumnSeparator);
				writer.WriteEndElement();
			}
			if (Azure.Core.Optional.IsDefined(FieldQuote))
			{
				writer.WriteStartElement("FieldQuote");
				writer.WriteValue(FieldQuote);
				writer.WriteEndElement();
			}
			if (Azure.Core.Optional.IsDefined(RecordSeparator))
			{
				writer.WriteStartElement("RecordSeparator");
				writer.WriteValue(RecordSeparator);
				writer.WriteEndElement();
			}
			if (Azure.Core.Optional.IsDefined(EscapeChar))
			{
				writer.WriteStartElement("EscapeChar");
				writer.WriteValue(EscapeChar);
				writer.WriteEndElement();
			}
			if (Azure.Core.Optional.IsDefined(HeadersPresent))
			{
				writer.WriteStartElement("HasHeaders");
				writer.WriteValue(HeadersPresent.Value);
				writer.WriteEndElement();
			}
			writer.WriteEndElement();
		}
	}
	internal static class EncryptionAlgorithmTypeInternalExtensions
	{
		public static string ToSerialString(this EncryptionAlgorithmTypeInternal value)
		{
			return value switch
			{
				EncryptionAlgorithmTypeInternal.None => "None", 
				EncryptionAlgorithmTypeInternal.AES256 => "AES256", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown EncryptionAlgorithmTypeInternal value."), 
			};
		}

		public static EncryptionAlgorithmTypeInternal ToEncryptionAlgorithmTypeInternal(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "None"))
			{
				return EncryptionAlgorithmTypeInternal.None;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "AES256"))
			{
				return EncryptionAlgorithmTypeInternal.AES256;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown EncryptionAlgorithmTypeInternal value.");
		}
	}
	internal class FilterBlobItem
	{
		public string Name { get; }

		public string ContainerName { get; }

		public BlobTags Tags { get; }

		public string VersionId { get; }

		public bool? IsCurrentVersion { get; }

		internal FilterBlobItem(string name, string containerName)
		{
			Azure.Core.Argument.AssertNotNull(name, "name");
			Azure.Core.Argument.AssertNotNull(containerName, "containerName");
			Name = name;
			ContainerName = containerName;
		}

		internal FilterBlobItem(string name, string containerName, BlobTags tags, string versionId, bool? isCurrentVersion)
		{
			Name = name;
			ContainerName = containerName;
			Tags = tags;
			VersionId = versionId;
			IsCurrentVersion = isCurrentVersion;
		}

		internal static FilterBlobItem DeserializeFilterBlobItem(XElement element)
		{
			string name = null;
			string containerName = null;
			BlobTags tags = null;
			string versionId = null;
			bool? isCurrentVersion = null;
			XElement xElement = element.Element("Name");
			if (xElement != null)
			{
				name = (string)xElement;
			}
			XElement xElement2 = element.Element("ContainerName");
			if (xElement2 != null)
			{
				containerName = (string)xElement2;
			}
			XElement xElement3 = element.Element("Tags");
			if (xElement3 != null)
			{
				tags = BlobTags.DeserializeBlobTags(xElement3);
			}
			XElement xElement4 = element.Element("VersionId");
			if (xElement4 != null)
			{
				versionId = (string)xElement4;
			}
			XElement xElement5 = element.Element("IsCurrentVersion");
			if (xElement5 != null)
			{
				isCurrentVersion = (bool?)xElement5;
			}
			return new FilterBlobItem(name, containerName, tags, versionId, isCurrentVersion);
		}
	}
	internal class FilterBlobSegment
	{
		public string ServiceEndpoint { get; }

		public string Where { get; }

		public IReadOnlyList<FilterBlobItem> Blobs { get; }

		public string NextMarker { get; }

		internal FilterBlobSegment(string serviceEndpoint, string where, IEnumerable<FilterBlobItem> blobs)
		{
			Azure.Core.Argument.AssertNotNull(serviceEndpoint, "serviceEndpoint");
			Azure.Core.Argument.AssertNotNull(where, "where");
			Azure.Core.Argument.AssertNotNull(blobs, "blobs");
			ServiceEndpoint = serviceEndpoint;
			Where = where;
			Blobs = blobs.ToList();
		}

		internal FilterBlobSegment(string serviceEndpoint, string where, IReadOnlyList<FilterBlobItem> blobs, string nextMarker)
		{
			ServiceEndpoint = serviceEndpoint;
			Where = where;
			Blobs = blobs;
			NextMarker = nextMarker;
		}

		internal static FilterBlobSegment DeserializeFilterBlobSegment(XElement element)
		{
			string serviceEndpoint = null;
			string text = null;
			string nextMarker = null;
			IReadOnlyList<FilterBlobItem> blobs = null;
			XAttribute xAttribute = element.Attribute("ServiceEndpoint");
			if (xAttribute != null)
			{
				serviceEndpoint = (string)xAttribute;
			}
			XElement xElement = element.Element("Where");
			if (xElement != null)
			{
				text = (string)xElement;
			}
			XElement xElement2 = element.Element("NextMarker");
			if (xElement2 != null)
			{
				nextMarker = (string)xElement2;
			}
			XElement xElement3 = element.Element("Blobs");
			if (xElement3 != null)
			{
				List<FilterBlobItem> list = new List<FilterBlobItem>();
				foreach (XElement item in xElement3.Elements("Blob"))
				{
					list.Add(FilterBlobItem.DeserializeFilterBlobItem(item));
				}
				blobs = list;
			}
			return new FilterBlobSegment(serviceEndpoint, text, blobs, nextMarker);
		}
	}
	internal static class FilterBlobsIncludeItemExtensions
	{
		public static string ToSerialString(this FilterBlobsIncludeItem value)
		{
			return value switch
			{
				FilterBlobsIncludeItem.None => "none", 
				FilterBlobsIncludeItem.Versions => "versions", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown FilterBlobsIncludeItem value."), 
			};
		}

		public static FilterBlobsIncludeItem ToFilterBlobsIncludeItem(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "none"))
			{
				return FilterBlobsIncludeItem.None;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "versions"))
			{
				return FilterBlobsIncludeItem.Versions;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown FilterBlobsIncludeItem value.");
		}
	}
	[CodeGenModel("JsonTextConfiguration")]
	internal class JsonTextConfigurationInternal : Azure.Core.IXmlSerializable
	{
		public string RecordSeparator { get; set; }

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "JsonTextConfiguration");
			if (Azure.Core.Optional.IsDefined(RecordSeparator))
			{
				writer.WriteStartElement("RecordSeparator");
				writer.WriteValue(RecordSeparator);
				writer.WriteEndElement();
			}
			writer.WriteEndElement();
		}
	}
	internal class KeyInfo : Azure.Core.IXmlSerializable
	{
		public string Start { get; set; }

		public string Expiry { get; }

		public KeyInfo(string expiry)
		{
			Azure.Core.Argument.AssertNotNull(expiry, "expiry");
			Expiry = expiry;
		}

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "KeyInfo");
			if (Azure.Core.Optional.IsDefined(Start))
			{
				writer.WriteStartElement("Start");
				writer.WriteValue(Start);
				writer.WriteEndElement();
			}
			writer.WriteStartElement("Expiry");
			writer.WriteValue(Expiry);
			writer.WriteEndElement();
			writer.WriteEndElement();
		}
	}
	internal static class LeaseDurationTypeExtensions
	{
		public static string ToSerialString(this LeaseDurationType value)
		{
			return value switch
			{
				LeaseDurationType.Infinite => "infinite", 
				LeaseDurationType.Fixed => "fixed", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown LeaseDurationType value."), 
			};
		}

		public static LeaseDurationType ToLeaseDurationType(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "infinite"))
			{
				return LeaseDurationType.Infinite;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "fixed"))
			{
				return LeaseDurationType.Fixed;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown LeaseDurationType value.");
		}
	}
	internal static class LeaseStateExtensions
	{
		public static string ToSerialString(this LeaseState value)
		{
			return value switch
			{
				LeaseState.Available => "available", 
				LeaseState.Leased => "leased", 
				LeaseState.Expired => "expired", 
				LeaseState.Breaking => "breaking", 
				LeaseState.Broken => "broken", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown LeaseState value."), 
			};
		}

		public static LeaseState ToLeaseState(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "available"))
			{
				return LeaseState.Available;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "leased"))
			{
				return LeaseState.Leased;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "expired"))
			{
				return LeaseState.Expired;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "breaking"))
			{
				return LeaseState.Breaking;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "broken"))
			{
				return LeaseState.Broken;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown LeaseState value.");
		}
	}
	internal static class LeaseStatusExtensions
	{
		public static string ToSerialString(this LeaseStatus value)
		{
			return value switch
			{
				LeaseStatus.Locked => "locked", 
				LeaseStatus.Unlocked => "unlocked", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown LeaseStatus value."), 
			};
		}

		public static LeaseStatus ToLeaseStatus(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "locked"))
			{
				return LeaseStatus.Locked;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "unlocked"))
			{
				return LeaseStatus.Unlocked;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown LeaseStatus value.");
		}
	}
	internal class ListBlobsFlatSegmentResponse
	{
		public string ServiceEndpoint { get; }

		public string ContainerName { get; }

		public string Prefix { get; }

		public string Marker { get; }

		public int? MaxResults { get; }

		public BlobFlatListSegment Segment { get; }

		public string NextMarker { get; }

		internal ListBlobsFlatSegmentResponse(string serviceEndpoint, string containerName, BlobFlatListSegment segment)
		{
			Azure.Core.Argument.AssertNotNull(serviceEndpoint, "serviceEndpoint");
			Azure.Core.Argument.AssertNotNull(containerName, "containerName");
			Azure.Core.Argument.AssertNotNull(segment, "segment");
			ServiceEndpoint = serviceEndpoint;
			ContainerName = containerName;
			Segment = segment;
		}

		internal ListBlobsFlatSegmentResponse(string serviceEndpoint, string containerName, string prefix, string marker, int? maxResults, BlobFlatListSegment segment, string nextMarker)
		{
			ServiceEndpoint = serviceEndpoint;
			ContainerName = containerName;
			Prefix = prefix;
			Marker = marker;
			MaxResults = maxResults;
			Segment = segment;
			NextMarker = nextMarker;
		}

		internal static ListBlobsFlatSegmentResponse DeserializeListBlobsFlatSegmentResponse(XElement element)
		{
			string serviceEndpoint = null;
			string containerName = null;
			string prefix = null;
			string marker = null;
			int? maxResults = null;
			BlobFlatListSegment segment = null;
			string nextMarker = null;
			XAttribute xAttribute = element.Attribute("ServiceEndpoint");
			if (xAttribute != null)
			{
				serviceEndpoint = (string)xAttribute;
			}
			XAttribute xAttribute2 = element.Attribute("ContainerName");
			if (xAttribute2 != null)
			{
				containerName = (string)xAttribute2;
			}
			XElement xElement = element.Element("Prefix");
			if (xElement != null)
			{
				prefix = (string)xElement;
			}
			XElement xElement2 = element.Element("Marker");
			if (xElement2 != null)
			{
				marker = (string)xElement2;
			}
			XElement xElement3 = element.Element("MaxResults");
			if (xElement3 != null)
			{
				maxResults = (int?)xElement3;
			}
			XElement xElement4 = element.Element("Blobs");
			if (xElement4 != null)
			{
				segment = BlobFlatListSegment.DeserializeBlobFlatListSegment(xElement4);
			}
			XElement xElement5 = element.Element("NextMarker");
			if (xElement5 != null)
			{
				nextMarker = (string)xElement5;
			}
			return new ListBlobsFlatSegmentResponse(serviceEndpoint, containerName, prefix, marker, maxResults, segment, nextMarker);
		}
	}
	internal class ListBlobsHierarchySegmentResponse
	{
		public string ServiceEndpoint { get; }

		public string ContainerName { get; }

		public string Prefix { get; }

		public string Marker { get; }

		public int? MaxResults { get; }

		public string Delimiter { get; }

		public BlobHierarchyListSegment Segment { get; }

		public string NextMarker { get; }

		internal ListBlobsHierarchySegmentResponse(string serviceEndpoint, string containerName, BlobHierarchyListSegment segment)
		{
			Azure.Core.Argument.AssertNotNull(serviceEndpoint, "serviceEndpoint");
			Azure.Core.Argument.AssertNotNull(containerName, "containerName");
			Azure.Core.Argument.AssertNotNull(segment, "segment");
			ServiceEndpoint = serviceEndpoint;
			ContainerName = containerName;
			Segment = segment;
		}

		internal ListBlobsHierarchySegmentResponse(string serviceEndpoint, string containerName, string prefix, string marker, int? maxResults, string delimiter, BlobHierarchyListSegment segment, string nextMarker)
		{
			ServiceEndpoint = serviceEndpoint;
			ContainerName = containerName;
			Prefix = prefix;
			Marker = marker;
			MaxResults = maxResults;
			Delimiter = delimiter;
			Segment = segment;
			NextMarker = nextMarker;
		}

		internal static ListBlobsHierarchySegmentResponse DeserializeListBlobsHierarchySegmentResponse(XElement element)
		{
			string serviceEndpoint = null;
			string containerName = null;
			string prefix = null;
			string marker = null;
			int? maxResults = null;
			string delimiter = null;
			BlobHierarchyListSegment segment = null;
			string nextMarker = null;
			XAttribute xAttribute = element.Attribute("ServiceEndpoint");
			if (xAttribute != null)
			{
				serviceEndpoint = (string)xAttribute;
			}
			XAttribute xAttribute2 = element.Attribute("ContainerName");
			if (xAttribute2 != null)
			{
				containerName = (string)xAttribute2;
			}
			XElement xElement = element.Element("Prefix");
			if (xElement != null)
			{
				prefix = (string)xElement;
			}
			XElement xElement2 = element.Element("Marker");
			if (xElement2 != null)
			{
				marker = (string)xElement2;
			}
			XElement xElement3 = element.Element("MaxResults");
			if (xElement3 != null)
			{
				maxResults = (int?)xElement3;
			}
			XElement xElement4 = element.Element("Delimiter");
			if (xElement4 != null)
			{
				delimiter = (string)xElement4;
			}
			XElement xElement5 = element.Element("Blobs");
			if (xElement5 != null)
			{
				segment = BlobHierarchyListSegment.DeserializeBlobHierarchyListSegment(xElement5);
			}
			XElement xElement6 = element.Element("NextMarker");
			if (xElement6 != null)
			{
				nextMarker = (string)xElement6;
			}
			return new ListBlobsHierarchySegmentResponse(serviceEndpoint, containerName, prefix, marker, maxResults, delimiter, segment, nextMarker);
		}
	}
	internal static class ListBlobsIncludeItemExtensions
	{
		public static string ToSerialString(this ListBlobsIncludeItem value)
		{
			return value switch
			{
				ListBlobsIncludeItem.Copy => "copy", 
				ListBlobsIncludeItem.Deleted => "deleted", 
				ListBlobsIncludeItem.Metadata => "metadata", 
				ListBlobsIncludeItem.Snapshots => "snapshots", 
				ListBlobsIncludeItem.Uncommittedblobs => "uncommittedblobs", 
				ListBlobsIncludeItem.Versions => "versions", 
				ListBlobsIncludeItem.Tags => "tags", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown ListBlobsIncludeItem value."), 
			};
		}

		public static ListBlobsIncludeItem ToListBlobsIncludeItem(this string value)
		{
			if (string.Equals(value, "copy", StringComparison.InvariantCultureIgnoreCase))
			{
				return ListBlobsIncludeItem.Copy;
			}
			if (string.Equals(value, "deleted", StringComparison.InvariantCultureIgnoreCase))
			{
				return ListBlobsIncludeItem.Deleted;
			}
			if (string.Equals(value, "metadata", StringComparison.InvariantCultureIgnoreCase))
			{
				return ListBlobsIncludeItem.Metadata;
			}
			if (string.Equals(value, "snapshots", StringComparison.InvariantCultureIgnoreCase))
			{
				return ListBlobsIncludeItem.Snapshots;
			}
			if (string.Equals(value, "uncommittedblobs", StringComparison.InvariantCultureIgnoreCase))
			{
				return ListBlobsIncludeItem.Uncommittedblobs;
			}
			if (string.Equals(value, "versions", StringComparison.InvariantCultureIgnoreCase))
			{
				return ListBlobsIncludeItem.Versions;
			}
			if (string.Equals(value, "tags", StringComparison.InvariantCultureIgnoreCase))
			{
				return ListBlobsIncludeItem.Tags;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown ListBlobsIncludeItem value.");
		}
	}
	internal static class ListContainersIncludeTypeExtensions
	{
		public static string ToSerialString(this ListContainersIncludeType value)
		{
			return value switch
			{
				ListContainersIncludeType.Metadata => "metadata", 
				ListContainersIncludeType.Deleted => "deleted", 
				ListContainersIncludeType.System => "system", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown ListContainersIncludeType value."), 
			};
		}

		public static ListContainersIncludeType ToListContainersIncludeType(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "metadata"))
			{
				return ListContainersIncludeType.Metadata;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "deleted"))
			{
				return ListContainersIncludeType.Deleted;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "system"))
			{
				return ListContainersIncludeType.System;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown ListContainersIncludeType value.");
		}
	}
	internal class ListContainersSegmentResponse
	{
		public string ServiceEndpoint { get; }

		public string Prefix { get; }

		public string Marker { get; }

		public int? MaxResults { get; }

		public IReadOnlyList<ContainerItemInternal> ContainerItems { get; }

		public string NextMarker { get; }

		internal ListContainersSegmentResponse(string serviceEndpoint, IEnumerable<ContainerItemInternal> containerItems)
		{
			Azure.Core.Argument.AssertNotNull(serviceEndpoint, "serviceEndpoint");
			Azure.Core.Argument.AssertNotNull(containerItems, "containerItems");
			ServiceEndpoint = serviceEndpoint;
			ContainerItems = containerItems.ToList();
		}

		internal ListContainersSegmentResponse(string serviceEndpoint, string prefix, string marker, int? maxResults, IReadOnlyList<ContainerItemInternal> containerItems, string nextMarker)
		{
			ServiceEndpoint = serviceEndpoint;
			Prefix = prefix;
			Marker = marker;
			MaxResults = maxResults;
			ContainerItems = containerItems;
			NextMarker = nextMarker;
		}

		internal static ListContainersSegmentResponse DeserializeListContainersSegmentResponse(XElement element)
		{
			string serviceEndpoint = null;
			string prefix = null;
			string marker = null;
			int? maxResults = null;
			string nextMarker = null;
			IReadOnlyList<ContainerItemInternal> containerItems = null;
			XAttribute xAttribute = element.Attribute("ServiceEndpoint");
			if (xAttribute != null)
			{
				serviceEndpoint = (string)xAttribute;
			}
			XElement xElement = element.Element("Prefix");
			if (xElement != null)
			{
				prefix = (string)xElement;
			}
			XElement xElement2 = element.Element("Marker");
			if (xElement2 != null)
			{
				marker = (string)xElement2;
			}
			XElement xElement3 = element.Element("MaxResults");
			if (xElement3 != null)
			{
				maxResults = (int?)xElement3;
			}
			XElement xElement4 = element.Element("NextMarker");
			if (xElement4 != null)
			{
				nextMarker = (string)xElement4;
			}
			XElement xElement5 = element.Element("Containers");
			if (xElement5 != null)
			{
				List<ContainerItemInternal> list = new List<ContainerItemInternal>();
				foreach (XElement item in xElement5.Elements("Container"))
				{
					list.Add(ContainerItemInternal.DeserializeContainerItemInternal(item));
				}
				containerItems = list;
			}
			return new ListContainersSegmentResponse(serviceEndpoint, prefix, marker, maxResults, containerItems, nextMarker);
		}
	}
	internal class PageList
	{
		public IReadOnlyList<PageRange> PageRange { get; }

		public IReadOnlyList<ClearRange> ClearRange { get; }

		public string NextMarker { get; }

		internal PageList()
		{
			PageRange = new Azure.Core.ChangeTrackingList<PageRange>();
			ClearRange = new Azure.Core.ChangeTrackingList<ClearRange>();
		}

		internal PageList(IReadOnlyList<PageRange> pageRange, IReadOnlyList<ClearRange> clearRange, string nextMarker)
		{
			PageRange = pageRange;
			ClearRange = clearRange;
			NextMarker = nextMarker;
		}

		internal static PageList DeserializePageList(XElement element)
		{
			string nextMarker = null;
			IReadOnlyList<PageRange> readOnlyList = null;
			IReadOnlyList<ClearRange> readOnlyList2 = null;
			XElement xElement = element.Element("NextMarker");
			if (xElement != null)
			{
				nextMarker = (string)xElement;
			}
			List<PageRange> list = new List<PageRange>();
			foreach (XElement item in element.Elements("PageRange"))
			{
				list.Add(Azure.Storage.Blobs.Models.PageRange.DeserializePageRange(item));
			}
			readOnlyList = list;
			List<ClearRange> list2 = new List<ClearRange>();
			foreach (XElement item2 in element.Elements("ClearRange"))
			{
				list2.Add(Azure.Storage.Blobs.Models.ClearRange.DeserializeClearRange(item2));
			}
			readOnlyList2 = list2;
			return new PageList(readOnlyList, readOnlyList2, nextMarker);
		}
	}
	internal readonly struct PageRange : IEquatable<PageRange>
	{
		public long Start { get; }

		public long End { get; }

		internal static PageRange DeserializePageRange(XElement element)
		{
			long start = 0L;
			long end = 0L;
			XElement xElement = element.Element("Start");
			if (xElement != null)
			{
				start = (long)xElement;
			}
			XElement xElement2 = element.Element("End");
			if (xElement2 != null)
			{
				end = (long)xElement2;
			}
			return new PageRange(start, end);
		}

		internal PageRange(long start, long end)
		{
			Start = start;
			End = end;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public bool Equals(PageRange other)
		{
			if (!Start.Equals(other.Start))
			{
				return false;
			}
			if (!End.Equals(other.End))
			{
				return false;
			}
			return true;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override bool Equals(object obj)
		{
			if (obj is PageRange)
			{
				return Equals((PageRange)obj);
			}
			return false;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override int GetHashCode()
		{
			Azure.Core.HashCodeBuilder hashCodeBuilder = default(Azure.Core.HashCodeBuilder);
			hashCodeBuilder.Add(Start);
			hashCodeBuilder.Add(End);
			return hashCodeBuilder.ToHashCode();
		}
	}
	internal readonly struct PremiumPageBlobAccessTier : IEquatable<PremiumPageBlobAccessTier>
	{
		private readonly string _value;

		private const string P4Value = "P4";

		private const string P6Value = "P6";

		private const string P10Value = "P10";

		private const string P15Value = "P15";

		private const string P20Value = "P20";

		private const string P30Value = "P30";

		private const string P40Value = "P40";

		private const string P50Value = "P50";

		private const string P60Value = "P60";

		private const string P70Value = "P70";

		private const string P80Value = "P80";

		public static PremiumPageBlobAccessTier P4 { get; } = new PremiumPageBlobAccessTier("P4");

		public static PremiumPageBlobAccessTier P6 { get; } = new PremiumPageBlobAccessTier("P6");

		public static PremiumPageBlobAccessTier P10 { get; } = new PremiumPageBlobAccessTier("P10");

		public static PremiumPageBlobAccessTier P15 { get; } = new PremiumPageBlobAccessTier("P15");

		public static PremiumPageBlobAccessTier P20 { get; } = new PremiumPageBlobAccessTier("P20");

		public static PremiumPageBlobAccessTier P30 { get; } = new PremiumPageBlobAccessTier("P30");

		public static PremiumPageBlobAccessTier P40 { get; } = new PremiumPageBlobAccessTier("P40");

		public static PremiumPageBlobAccessTier P50 { get; } = new PremiumPageBlobAccessTier("P50");

		public static PremiumPageBlobAccessTier P60 { get; } = new PremiumPageBlobAccessTier("P60");

		public static PremiumPageBlobAccessTier P70 { get; } = new PremiumPageBlobAccessTier("P70");

		public static PremiumPageBlobAccessTier P80 { get; } = new PremiumPageBlobAccessTier("P80");

		public PremiumPageBlobAccessTier(string value)
		{
			_value = value ?? throw new ArgumentNullException("value");
		}

		public static bool operator ==(PremiumPageBlobAccessTier left, PremiumPageBlobAccessTier right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(PremiumPageBlobAccessTier left, PremiumPageBlobAccessTier right)
		{
			return !left.Equals(right);
		}

		public static implicit operator PremiumPageBlobAccessTier(string value)
		{
			return new PremiumPageBlobAccessTier(value);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override bool Equals(object obj)
		{
			if (obj is PremiumPageBlobAccessTier other)
			{
				return Equals(other);
			}
			return false;
		}

		public bool Equals(PremiumPageBlobAccessTier other)
		{
			return string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override int GetHashCode()
		{
			return _value?.GetHashCode() ?? 0;
		}

		public override string ToString()
		{
			return _value;
		}
	}
	internal static class PublicAccessTypeExtensions
	{
		public static string ToSerialString(this PublicAccessType value)
		{
			return value switch
			{
				PublicAccessType.BlobContainer => "container", 
				PublicAccessType.Blob => "blob", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown PublicAccessType value."), 
			};
		}

		public static PublicAccessType ToPublicAccessType(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "container"))
			{
				return PublicAccessType.BlobContainer;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "blob"))
			{
				return PublicAccessType.Blob;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown PublicAccessType value.");
		}
	}
	internal class QueryFormat : Azure.Core.IXmlSerializable
	{
		public QueryFormatType Type { get; }

		public DelimitedTextConfigurationInternal DelimitedTextConfiguration { get; set; }

		public JsonTextConfigurationInternal JsonTextConfiguration { get; set; }

		public ArrowTextConfigurationInternal ArrowConfiguration { get; set; }

		public object ParquetTextConfiguration { get; set; }

		public QueryFormat(QueryFormatType type)
		{
			Type = type;
		}

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "QueryFormat");
			writer.WriteStartElement("Type");
			writer.WriteValue(Type.ToSerialString());
			writer.WriteEndElement();
			if (Azure.Core.Optional.IsDefined(DelimitedTextConfiguration))
			{
				writer.WriteObjectValue(DelimitedTextConfiguration, "DelimitedTextConfiguration");
			}
			if (Azure.Core.Optional.IsDefined(JsonTextConfiguration))
			{
				writer.WriteObjectValue(JsonTextConfiguration, "JsonTextConfiguration");
			}
			if (Azure.Core.Optional.IsDefined(ArrowConfiguration))
			{
				writer.WriteObjectValue(ArrowConfiguration, "ArrowConfiguration");
			}
			if (Azure.Core.Optional.IsDefined(ParquetTextConfiguration))
			{
				writer.WriteObjectValue(ParquetTextConfiguration, "ParquetTextConfiguration");
			}
			writer.WriteEndElement();
		}
	}
	internal static class QueryFormatTypeExtensions
	{
		public static string ToSerialString(this QueryFormatType value)
		{
			return value switch
			{
				QueryFormatType.Delimited => "delimited", 
				QueryFormatType.Json => "json", 
				QueryFormatType.Arrow => "arrow", 
				QueryFormatType.Parquet => "parquet", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown QueryFormatType value."), 
			};
		}

		public static QueryFormatType ToQueryFormatType(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "delimited"))
			{
				return QueryFormatType.Delimited;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "json"))
			{
				return QueryFormatType.Json;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "arrow"))
			{
				return QueryFormatType.Arrow;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "parquet"))
			{
				return QueryFormatType.Parquet;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown QueryFormatType value.");
		}
	}
	internal class QueryRequest : Azure.Core.IXmlSerializable
	{
		public QuerySerialization InputSerialization { get; set; }

		public QuerySerialization OutputSerialization { get; set; }

		public string QueryType { get; set; }

		public string Expression { get; set; }

		public QueryRequest(string expression)
		{
			Azure.Core.Argument.AssertNotNull(expression, "expression");
			QueryType = "SQL";
			Expression = expression;
		}

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "QueryRequest");
			writer.WriteStartElement("QueryType");
			writer.WriteValue(QueryType);
			writer.WriteEndElement();
			writer.WriteStartElement("Expression");
			writer.WriteValue(Expression);
			writer.WriteEndElement();
			if (Azure.Core.Optional.IsDefined(InputSerialization))
			{
				writer.WriteObjectValue(InputSerialization, "InputSerialization");
			}
			if (Azure.Core.Optional.IsDefined(OutputSerialization))
			{
				writer.WriteObjectValue(OutputSerialization, "OutputSerialization");
			}
			writer.WriteEndElement();
		}

		internal QueryRequest()
		{
		}
	}
	internal class QuerySerialization : Azure.Core.IXmlSerializable
	{
		public QueryFormat Format { get; }

		public QuerySerialization(QueryFormat format)
		{
			Azure.Core.Argument.AssertNotNull(format, "format");
			Format = format;
		}

		void Azure.Core.IXmlSerializable.Write(XmlWriter writer, string nameHint)
		{
			writer.WriteStartElement(nameHint ?? "QuerySerialization");
			writer.WriteObjectValue(Format, "Format");
			writer.WriteEndElement();
		}
	}
	public enum RehydratePriority
	{
		High,
		Standard
	}
	internal static class RehydratePriorityExtensions
	{
		public static string ToSerialString(this RehydratePriority value)
		{
			return value switch
			{
				RehydratePriority.High => "High", 
				RehydratePriority.Standard => "Standard", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown RehydratePriority value."), 
			};
		}

		public static RehydratePriority ToRehydratePriority(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "High"))
			{
				return RehydratePriority.High;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "Standard"))
			{
				return RehydratePriority.Standard;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown RehydratePriority value.");
		}
	}
	internal static class SequenceNumberActionExtensions
	{
		public static string ToSerialString(this SequenceNumberAction value)
		{
			return value switch
			{
				SequenceNumberAction.Max => "max", 
				SequenceNumberAction.Update => "update", 
				SequenceNumberAction.Increment => "increment", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown SequenceNumberAction value."), 
			};
		}

		public static SequenceNumberAction ToSequenceNumberAction(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "max"))
			{
				return SequenceNumberAction.Max;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "update"))
			{
				return SequenceNumberAction.Update;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "increment"))
			{
				return SequenceNumberAction.Increment;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown SequenceNumberAction value.");
		}
	}
	internal static class SkuNameExtensions
	{
		public static string ToSerialString(this SkuName value)
		{
			return value switch
			{
				SkuName.StandardLrs => "Standard_LRS", 
				SkuName.StandardGrs => "Standard_GRS", 
				SkuName.StandardRagrs => "Standard_RAGRS", 
				SkuName.StandardZrs => "Standard_ZRS", 
				SkuName.PremiumLrs => "Premium_LRS", 
				_ => throw new ArgumentOutOfRangeException("value", value, "Unknown SkuName value."), 
			};
		}

		public static SkuName ToSkuName(this string value)
		{
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "Standard_LRS"))
			{
				return SkuName.StandardLrs;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "Standard_GRS"))
			{
				return SkuName.StandardGrs;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "Standard_RAGRS"))
			{
				return SkuName.StandardRagrs;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "Standard_ZRS"))
			{
				return SkuName.StandardZrs;
			}
			if (StringComparer.OrdinalIgnoreCase.Equals(value, "Premium_LRS"))
			{
				return SkuName.PremiumLrs;
			}
			throw new ArgumentOutOfRangeException("value", value, "Unknown SkuName value.");
		}
	}
	internal class StorageError
	{
		public string Message { get; }

		internal StorageError()
		{
		}

		internal StorageError(string message)
		{
			Message = message;
		}

		internal static StorageError DeserializeStorageError(XElement element)
		{
			string message = null;
			XElement xElement = element.Element("Message");
			if (xElement != null)
			{
				message = (string)xElement;
			}
			return new StorageError(message);
		}
	}
	public class UserDelegationKey
	{
		[CodeGenMember("SignedOid")]
		public string SignedObjectId { get; internal set; }

		[CodeGenMember("SignedTid")]
		public string SignedTenantId { get; internal set; }

		[CodeGenMember("SignedExpiry")]
		public DateTimeOffset SignedExpiresOn { get; internal set; }

		[CodeGenMember("SignedStart")]
		public DateTimeOffset SignedStartsOn { get; internal set; }

		public string SignedService { get; internal set; }

		public string SignedVersion { get; internal set; }

		public string Value { get; internal set; }

		internal UserDelegationKey(string signedObjectId, string signedTenantId, DateTimeOffset signedStartsOn, DateTimeOffset signedExpiresOn, string signedService, string signedVersion, string value)
		{
			Azure.Core.Argument.AssertNotNull(signedObjectId, "signedObjectId");
			Azure.Core.Argument.AssertNotNull(signedTenantId, "signedTenantId");
			Azure.Core.Argument.AssertNotNull(signedService, "signedService");
			Azure.Core.Argument.AssertNotNull(signedVersion, "signedVersion");
			Azure.Core.Argument.AssertNotNull(value, "value");
			SignedObjectId = signedObjectId;
			SignedTenantId = signedTenantId;
			SignedStartsOn = signedStartsOn;
			SignedExpiresOn = signedExpiresOn;
			SignedService = signedService;
			SignedVersion = signedVersion;
			Value = value;
		}

		internal static UserDelegationKey DeserializeUserDelegationKey(XElement element)
		{
			string signedObjectId = null;
			string signedTenantId = null;
			DateTimeOffset signedStartsOn = default(DateTimeOffset);
			DateTimeOffset signedExpiresOn = default(DateTimeOffset);
			string signedService = null;
			string signedVersion = null;
			string value = null;
			XElement xElement = element.Element("SignedOid");
			if (xElement != null)
			{
				signedObjectId = (string)xElement;
			}
			XElement xElement2 = element.Element("SignedTid");
			if (xElement2 != null)
			{
				signedTenantId = (string)xElement2;
			}
			XElement xElement3 = element.Element("SignedStart");
			if (xElement3 != null)
			{
				signedStartsOn = xElement3.GetDateTimeOffsetValue("O");
			}
			XElement xElement4 = element.Element("SignedExpiry");
			if (xElement4 != null)
			{
				signedExpiresOn = xElement4.GetDateTimeOffsetValue("O");
			}
			XElement xElement5 = element.Element("SignedService");
			if (xElement5 != null)
			{
				signedService = (string)xElement5;
			}
			XElement xElement6 = element.Element("SignedVersion");
			if (xElement6 != null)
			{
				signedVersion = (string)xElement6;
			}
			XElement xElement7 = element.Element("Value");
			if (xElement7 != null)
			{
				value = (string)xElement7;
			}
			return new UserDelegationKey(signedObjectId, signedTenantId, signedStartsOn, signedExpiresOn, signedService, signedVersion, value);
		}

		internal UserDelegationKey()
		{
		}
	}
	public class AccountInfo
	{
		public SkuName SkuName { get; internal set; }

		public AccountKind AccountKind { get; internal set; }

		public bool IsHierarchicalNamespaceEnabled { get; internal set; }

		internal AccountInfo()
		{
		}
	}
	public enum AccountKind
	{
		Storage,
		BlobStorage,
		StorageV2,
		FileStorage,
		BlockBlobStorage
	}
	public class AppendBlobAppendBlockFromUriOptions
	{
		public HttpRange SourceRange { get; set; }

		public byte[] SourceContentHash { get; set; }

		public AppendBlobRequestConditions DestinationConditions { get; set; }

		public AppendBlobRequestConditions SourceConditions { get; set; }

		public HttpAuthorization SourceAuthentication { get; set; }
	}
	public class AppendBlobAppendBlockOptions
	{
		public AppendBlobRequestConditions Conditions { get; set; }

		public IProgress<long> ProgressHandler { get; set; }

		public UploadTransferValidationOptions TransferValidation { get; set; }
	}
	public class AppendBlobCreateOptions
	{
		public BlobHttpHeaders HttpHeaders { get; set; }

		public IDictionary<string, string> Metadata { get; set; }

		public IDictionary<string, string> Tags { get; set; }

		public BlobImmutabilityPolicy ImmutabilityPolicy { get; set; }

		public bool? HasLegalHold { get; set; }

		public AppendBlobRequestConditions Conditions { get; set; }
	}
	public class AppendBlobOpenWriteOptions
	{
		public long? BufferSize { get; set; }

		public AppendBlobRequestConditions OpenConditions { get; set; }

		public IProgress<long> ProgressHandler { get; set; }

		public UploadTransferValidationOptions TransferValidation { get; set; }
	}
	public class AppendBlobRequestConditions : BlobRequestConditions
	{
		public long? IfAppendPositionEqual { get; set; }

		public long? IfMaxSizeLessThanOrEqual { get; set; }

		internal override void AddConditions(StringBuilder conditions)
		{
			base.AddConditions(conditions);
			if (IfAppendPositionEqual.HasValue)
			{
				conditions.Append("IfAppendPositionEqual").Append('=').Append(IfAppendPositionEqual)
					.Append(';');
			}
			if (IfMaxSizeLessThanOrEqual.HasValue)
			{
				conditions.Append("IfMaxSizeLessThanOrEqual").Append('=').Append(IfMaxSizeLessThanOrEqual)
					.Append(';');
			}
		}
	}
	public enum ArchiveStatus
	{
		RehydratePendingToHot,
		RehydratePendingToCool,
		RehydratePendingToCold
	}
	public class BlobAppendInfo
	{
		public ETag ETag { get; internal set; }

		public DateTimeOffset LastModified { get; internal set; }

		public byte[] ContentHash { get; internal set; }

		public byte[] ContentCrc64 { get; internal set; }

		public string BlobAppendOffset { get; internal set; }

		public int BlobCommittedBlockCount { get; internal set; }

		public bool IsServerEncrypted { get; internal set; }

		public string EncryptionKeySha256 { get; internal set; }

		public string EncryptionScope { get; internal set; }

		internal BlobAppendInfo()
		{
		}
	}
	public readonly struct BlobAudience : IEquatable<BlobAudience>
	{
		private readonly string _value;

		private const string _defaultAudience = "https://storage.azure.com/";

		public static BlobAudience DefaultAudience { get; } = new BlobAudience("https://storage.azure.com/");

		public BlobAudience(string value)
		{
			Azure.Core.Argument.AssertNotNullOrEmpty(value, "value");
			_value = value;
		}

		public static BlobAudience CreateBlobServiceAccountAudience(string storageAccountName)
		{
			return new BlobAudience("https://" + storageAccountName + ".blob.core.windows.net/");
		}

		public static bool operator ==(BlobAudience left, BlobAudience right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(BlobAudience left, BlobAudience right)
		{
			return !left.Equals(right);
		}

		public static implicit operator BlobAudience(string value)
		{
			return new BlobAudience(value);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override bool Equals(object obj)
		{
			if (obj is BlobAudience other)
			{
				return Equals(other);
			}
			return false;
		}

		public bool Equals(BlobAudience other)
		{
			return string.Equals(_value, other._value, StringComparison.InvariantCultureIgnoreCase);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override int GetHashCode()
		{
			return _value?.GetHashCode() ?? 0;
		}

		public override string ToString()
		{
			return _value;
		}

		internal string CreateDefaultScope()
		{
			if (_value.EndsWith("/", StringComparison.InvariantCultureIgnoreCase))
			{
				return _value + "/.default";
			}
			return _value + "//.default";
		}
	}
	internal class BlobBaseClientExistsClassifier : ResponseClassificationHandler
	{
		public static bool IsResourceNotFoundResponse(Response response)
		{
			if (response.Headers.TryGetValue("x-ms-error-code", out string value) && (value == BlobErrorCode.BlobNotFound || value == BlobErrorCode.ContainerNotFound))
			{
				return true;
			}
			return false;
		}

		public static bool IsUsesCustomerSpecifiedEncryptionResponse(Response response)
		{
			if (response.Headers.TryGetValue("x-ms-error-code", out string value) && value == BlobErrorCode.BlobUsesCustomerSpecifiedEncryption)
			{
				return true;
			}
			return false;
		}

		public override bool TryClassify(HttpMessage message, out bool isError)
		{
			if (IsResourceNotFoundResponse(message.Response) || IsUsesCustomerSpecifiedEncryptionResponse(message.Response))
			{
				isError = false;
				return true;
			}
			isError = false;
			return false;
		}
	}
	public class BlobContainerAccessPolicy
	{
		public PublicAccessType BlobPublicAccess { get; internal set; }

		public ETag ETag { get; internal set; }

		public DateTimeOffset LastModified { get; internal set; }

		public IEnumerable<BlobSignedIdentifier> SignedIdentifiers { get; internal set; }

		public BlobContainerAccessPolicy()
		{
			SignedIdentifiers = new List<BlobSignedIdentifier>();
		}
	}
	public class BlobContainerEncryptionScopeOptions
	{
		public string DefaultEncryptionScope { get; set; }

		public bool PreventEncryptionScopeOverride { get; set; }
	}
	public class BlobContainerInfo
	{
		public ETag ETag { get; internal set; }

		public DateTimeOffset LastModified { get; internal set; }

		internal BlobContainerInfo()
		{
		}
	}
	public class BlobContainerItem
	{
		public string Name { get; internal set; }

		public bool? IsDeleted { get; internal set; }

		public string VersionId { get; internal set; }

		public BlobContainerProperties Properties { get; internal set; }

		internal BlobContainerItem()
		{
		}
	}
	public class BlobContainerProperties
	{
		public DateTimeOffset LastModified { get; internal set; }

		public LeaseStatus? LeaseStatus { get; internal set; }

		public LeaseState? LeaseState { get; internal set; }

		public LeaseDurationType? LeaseDuration { get; internal set; }

		public PublicAccessType? PublicAccess { get; internal set; }

		public bool? HasImmutabilityPolicy { get; internal set; }

		public bool? HasLegalHold { get; internal set; }

		public string DefaultEncryptionScope { get; internal set; }

		public bool? PreventEncryptionScopeOverride { get; internal set; }

		public DateTimeOffset? DeletedOn { get; internal set; }

		public int? RemainingRetentionDays { get; internal set; }

		public ETag ETag { get; internal set; }

		public IDictionary<string, string> Metadata { get; internal set; }

		public bool HasImmutableStorageWithVersioning { get; internal set; }

		internal BlobContainerProperties()
			: this(skipInitialization: false)
		{
		}

		internal BlobContainerProperties(bool skipInitialization)
		{
			if (!skipInitialization)
			{
				Metadata = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
			}
		}
	}
	[Flags]
	public enum BlobContainerStates
	{
		None = 0,
		Deleted = 1,
		System = 2
	}
	[Flags]
	public enum BlobContainerTraits
	{
		None = 0,
		Metadata = 1
	}
	public class BlobContentInfo
	{
		public ETag ETag { get; internal set; }

		public DateTimeOffset LastModified { get; internal set; }

		public byte[] ContentHash { get; internal set; }

		public string VersionId { get; internal set; }

		public string EncryptionKeySha256 { get; internal set; }

		public string EncryptionScope { get; internal set; }

		public long BlobSequenceNumber { get; internal set; }

		internal BlobContentInfo()
		{
		}
	}
	public class BlobCopyFromUriOptions
	{
		public IDictionary<string, string> Metadata { get; set; }

		public IDictionary<string, string> Tags { get; set; }

		public AccessTier? AccessTier { get; set; }

		public BlobRequestConditions SourceConditions { get; set; }

		public BlobRequestConditions DestinationConditions { get; set; }

		public RehydratePriority? RehydratePriority { get; set; }

		public bool? ShouldSealDestination { get; set; }

		public BlobImmutabilityPolicy DestinationImmutabilityPolicy { get; set; }

		public bool? LegalHold { get; set; }

		public HttpAuthorization SourceAuthentication { get; set; }

		public BlobCopySourceTagsMode? CopySourceTagsMode { get; set; }
	}
	public class BlobCopyInfo
	{
		public ETag ETag { get; internal set; }

		public DateTimeOffset LastModified { get; internal set; }

		public string VersionId { get; internal set; }

		public string CopyId { get; internal set; }

		public CopyStatus CopyStatus { get; internal set; }

		public string EncryptionScope { get; internal set; }

		internal BlobCopyInfo()
		{
		}
	}
	[CodeGenModel("BlobCopySourceTags")]
	public enum BlobCopySourceTagsMode
	{
		Replace,
		Copy
	}
	public class BlobDownloadDetails
	{
		public BlobType BlobType { get; internal set; }

		public long ContentLength { get; internal set; }

		public string ContentType { get; internal set; }

		public byte[] ContentHash { get; internal set; }

		public DateTimeOffset LastModified { get; internal set; }

		public IDictionary<string, string> Metadata { get; internal set; }

		public string ContentRange { get; internal set; }

		public ETag ETag { get; internal set; }

		public string ContentEncoding { get; internal set; }

		public string CacheControl { get; internal set; }

		public string ContentDisposition { get; internal set; }

		public string ContentLanguage { get; internal set; }

		public long BlobSequenceNumber { get; internal set; }

		public DateTimeOffset CopyCompletedOn { get; internal set; }

		public string CopyStatusDescription { get; internal set; }

		public string CopyId { get; internal set; }

		public string CopyProgress { get; internal set; }

		public Uri CopySource { get; internal set; }

		public CopyStatus CopyStatus { get; internal set; }

		public LeaseDurationType LeaseDuration { get; internal set; }

		public LeaseState LeaseState { get; internal set; }

		public LeaseStatus LeaseStatus { get; internal set; }

		public string AcceptRanges { get; internal set; }

		public int BlobCommittedBlockCount { get; internal set; }

		public bool IsServerEncrypted { get; internal set; }

		public string EncryptionKeySha256 { get; internal set; }

		public string EncryptionScope { get; internal set; }

		public byte[] BlobContentHash { get; internal set; }

		public long TagCount { get; internal set; }

		public string VersionId { get; internal set; }

		public bool IsSealed { get; internal set; }

		public IList<ObjectReplicationPolicy> ObjectReplicationSourceProperties { get; internal set; }

		public string ObjectReplicationDestinationPolicyId { get; internal set; }

		public DateTimeOffset LastAccessed { get; internal set; }

		public BlobImmutabilityPolicy ImmutabilityPolicy { get; internal set; }

		public bool HasLegalHold { get; internal set; }

		public DateTimeOffset CreatedOn { get; internal set; }
	}
	public class BlobDownloadInfo : IDisposable, IDownloadedContent
	{
		[EditorBrowsable(EditorBrowsableState.Never)]
		public BlobType BlobType { get; internal set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		public long ContentLength { get; internal set; }

		public Stream Content { get; internal set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		public string ContentType { get; internal set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		public byte[] ContentHash { get; internal set; }

		public BlobDownloadDetails Details { get; internal set; }

		internal BlobDownloadInfo()
		{
		}

		public void Dispose()
		{
			Content?.Dispose();
			GC.SuppressFinalize(this);
		}
	}
	public class BlobDownloadOptions
	{
		public HttpRange Range { get; set; }

		public BlobRequestConditions Conditions { get; set; }

		public IProgress<long> ProgressHandler { get; set; }

		public DownloadTransferValidationOptions TransferValidation { get; set; }
	}
	public class BlobDownloadResult
	{
		public BlobDownloadDetails Details { get; internal set; }

		public BinaryData Content { get; internal set; }

		internal BlobDownloadResult()
		{
		}
	}
	public class BlobDownloadStreamingResult : IDisposable, IDownloadedContent
	{
		public BlobDownloadDetails Details { get; internal set; }

		public Stream Content { get; internal set; }

		internal BlobDownloadStreamingResult()
		{
		}

		public void Dispose()
		{
			Content?.Dispose();
			GC.SuppressFinalize(this);
		}
	}
	public class BlobDownloadToOptions
	{
		public BlobRequestConditions Conditions { get; set; }

		public IProgress<long> ProgressHandler { get; set; }

		public StorageTransferOptions TransferOptions { get; set; }

		public DownloadTransferValidationOptions TransferValidation { get; set; }
	}
	public class BlobHierarchyItem
	{
		public string Prefix { get; internal set; }

		public BlobItem Blob { get; internal set; }

		public bool IsPrefix => Prefix != null;

		public bool IsBlob => Blob != null;

		internal BlobHierarchyItem(string prefix, BlobItem blob)
		{
			Prefix = prefix;
			Blob = blob;
		}
	}
	public class BlobHttpHeaders
	{
		public string ContentType { get; set; }

		public byte[] ContentHash { get; set; }

		public string ContentEncoding { get; set; }

		public string ContentLanguage { get; set; }

		public string ContentDisposition { get; set; }

		public string CacheControl { get; set; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override string ToString()
		{
			return base.ToString();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override bool Equals(object obj)
		{
			return base.Equals(obj);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}
	}
	public class BlobImmutabilityPolicy
	{
		public DateTimeOffset? ExpiresOn { get; set; }

		public BlobImmutabilityPolicyMode? PolicyMode { get; set; }
	}
	public enum BlobImmutabilityPolicyMode
	{
		Mutable,
		Unlocked,
		Locked
	}
	public class BlobInfo
	{
		public ETag ETag { get; internal set; }

		public DateTimeOffset LastModified { get; internal set; }

		public long BlobSequenceNumber { get; internal set; }

		public string VersionId { get; internal set; }

		internal BlobInfo()
		{
		}
	}
	public class BlobItem
	{
		public string Name { get; internal set; }

		public bool Deleted { get; internal set; }

		public string Snapshot { get; internal set; }

		public string VersionId { get; internal set; }

		public bool? IsLatestVersion { get; internal set; }

		public BlobItemProperties Properties { get; internal set; }

		public IDictionary<string, string> Metadata { get; internal set; }

		public IDictionary<string, string> Tags { get; internal set; }

		public IList<ObjectReplicationPolicy> ObjectReplicationSourceProperties { get; internal set; }

		public bool? HasVersionsOnly { get; internal set; }

		internal BlobItem()
		{
		}
	}
	public class BlobItemProperties
	{
		public DateTimeOffset? LastModified { get; internal set; }

		public long? ContentLength { get; internal set; }

		public string ContentType { get; internal set; }

		public string ContentEncoding { get; internal set; }

		public string ContentLanguage { get; internal set; }

		public byte[] ContentHash { get; internal set; }

		public string ContentDisposition { get; internal set; }

		public string CacheControl { get; internal set; }

		public long? BlobSequenceNumber { get; internal set; }

		public BlobType? BlobType { get; internal set; }

		public LeaseStatus? LeaseStatus { get; internal set; }

		public LeaseState? LeaseState { get; internal set; }

		public LeaseDurationType? LeaseDuration { get; internal set; }

		public string CopyId { get; internal set; }

		public CopyStatus? CopyStatus { get; internal set; }

		public Uri CopySource { get; internal set; }

		public string CopyProgress { get; internal set; }

		public string CopyStatusDescription { get; internal set; }

		public bool? ServerEncrypted { get; internal set; }

		public bool? IncrementalCopy { get; internal set; }

		public string DestinationSnapshot { get; internal set; }

		public int? RemainingRetentionDays { get; internal set; }

		public AccessTier? AccessTier { get; internal set; }

		public bool AccessTierInferred { get; internal set; }

		public ArchiveStatus? ArchiveStatus { get; internal set; }

		public string CustomerProvidedKeySha256 { get; internal set; }

		public string EncryptionScope { get; internal set; }

		public long? TagCount { get; internal set; }

		public DateTimeOffset? ExpiresOn { get; internal set; }

		public bool? IsSealed { get; internal set; }

		public RehydratePriority? RehydratePriority { get; internal set; }

		public DateTimeOffset? LastAccessedOn { get; internal set; }

		public ETag? ETag { get; internal set; }

		public DateTimeOffset? CreatedOn { get; internal set; }

		public DateTimeOffset? CopyCompletedOn { get; internal set; }

		public DateTimeOffset? DeletedOn { get; internal set; }

		public DateTimeOffset? AccessTierChangedOn { get; internal set; }

		public BlobImmutabilityPolicy ImmutabilityPolicy { get; internal set; }

		public bool HasLegalHold { get; internal set; }

		internal BlobItemProperties()
		{
		}
	}
	public class BlobLease
	{
		public ETag ETag { get; internal set; }

		public DateTimeOffset LastModified { get; internal set; }

		public string LeaseId { get; internal set; }

		public int? LeaseTime { get; internal set; }

		internal BlobLease()
		{
		}
	}
	public class BlobLeaseRequestConditions : RequestConditions
	{
		public string TagConditions { get; set; }

		public BlobLeaseRequestConditions()
		{
		}

		internal BlobLeaseRequestConditions(BlobLeaseRequestConditions deepCopySource)
		{
			Azure.Core.Argument.AssertNotNull(deepCopySource, "deepCopySource");
			TagConditions = deepCopySource.TagConditions;
			base.IfMatch = deepCopySource.IfMatch;
			base.IfNoneMatch = deepCopySource.IfNoneMatch;
			base.IfModifiedSince = deepCopySource.IfModifiedSince;
			base.IfUnmodifiedSince = deepCopySource.IfUnmodifiedSince;
		}

		internal static BlobLeaseRequestConditions CloneOrDefault(BlobLeaseRequestConditions deepCopySource)
		{
			if (deepCopySource == null)
			{
				return null;
			}
			return new BlobLeaseRequestConditions(deepCopySource);
		}
	}
	public class BlobLegalHoldResult
	{
		public bool HasLegalHold { get; internal set; }
	}
	public class BlobOpenReadOptions
	{
		public long Position { get; set; }

		public int? BufferSize { get; set; }

		public BlobRequestConditions Conditions { get; set; }

		public DownloadTransferValidationOptions TransferValidation { get; set; }

		internal bool AllowModifications { get; }

		public BlobOpenReadOptions(bool allowModifications)
		{
			AllowModifications = allowModifications;
		}
	}
	public class BlobOpenWriteOptions
	{
		public long? BufferSize { get; set; }

		public BlobRequestConditions OpenConditions { get; set; }

		public IProgress<long> ProgressHandler { get; set; }

		public BlobHttpHeaders HttpHeaders { get; set; }

		public IDictionary<string, string> Metadata { get; set; }

		public IDictionary<string, string> Tags { get; set; }

		public UploadTransferValidationOptions TransferValidation { get; set; }
	}
	internal static class BlobOpenWriteOptionsExtensions
	{
		public static BlockBlobOpenWriteOptions ToBlockBlobOpenWriteOptions(this BlobOpenWriteOptions options)
		{
			return new BlockBlobOpenWriteOptions
			{
				BufferSize = options.BufferSize,
				OpenConditions = options.OpenConditions,
				ProgressHandler = options.ProgressHandler,
				HttpHeaders = options.HttpHeaders,
				Metadata = options.Metadata,
				Tags = options.Tags,
				TransferValidation = options.TransferValidation,
				OperationName = "BlobClient.OpenWrite"
			};
		}
	}
	public class BlobProperties
	{
		public DateTimeOffset LastModified { get; }

		public DateTimeOffset CreatedOn { get; }

		public IDictionary<string, string> Metadata { get; }

		public string ObjectReplicationDestinationPolicyId { get; }

		public IList<ObjectReplicationPolicy> ObjectReplicationSourceProperties { get; }

		public BlobType BlobType { get; }

		public DateTimeOffset CopyCompletedOn { get; }

		public string CopyStatusDescription { get; }

		public string CopyId { get; }

		public string CopyProgress { get; }

		public Uri CopySource { get; }

		[EditorBrowsable(EditorBrowsableState.Never)]
		public CopyStatus CopyStatus => BlobCopyStatus.GetValueOrDefault();

		public CopyStatus? BlobCopyStatus { get; }

		public bool IsIncrementalCopy { get; }

		public string DestinationSnapshot { get; }

		public LeaseDurationType LeaseDuration { get; }

		public LeaseState LeaseState { get; }

		public LeaseStatus LeaseStatus { get; }

		public long ContentLength { get; }

		public string ContentType { get; }

		public ETag ETag { get; }

		public byte[] ContentHash { get; }

		public string ContentEncoding { get; }

		public string ContentDisposition { get; }

		public string ContentLanguage { get; }

		public string CacheControl { get; }

		public long BlobSequenceNumber { get; }

		public string AcceptRanges { get; }

		public int BlobCommittedBlockCount { get; }

		public bool IsServerEncrypted { get; }

		public string EncryptionKeySha256 { get; }

		public string EncryptionScope { get; }

		public string AccessTier { get; }

		public bool AccessTierInferred { get; }

		public string ArchiveStatus { get; }

		public DateTimeOffset AccessTierChangedOn { get; }

		public string VersionId { get; }

		public bool IsLatestVersion { get; }

		public long TagCount { get; }

		public DateTimeOffset ExpiresOn { get; }

		public bool IsSealed { get; }

		public string RehydratePriority { get; }

		public DateTimeOffset LastAccessed { get; }

		public BlobImmutabilityPolicy ImmutabilityPolicy { get; internal set; }

		public bool HasLegalHold { get; internal set; }

		public BlobProperties()
		{
			Metadata = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
			ObjectReplicationSourceProperties = new List<ObjectReplicationPolicy>();
		}

		internal BlobProperties(DateTimeOffset lastModified, DateTimeOffset createdOn, IDictionary<string, string> metadata, string objectReplicationDestinationPolicyId, IList<ObjectReplicationPolicy> objectReplicationSourceProperties, BlobType blobType, DateTimeOffset copyCompletedOn, string copyStatusDescription, string copyId, string copyProgress, Uri copySource, CopyStatus? blobCopyStatus, bool isIncrementalCopy, string destinationSnapshot, LeaseDurationType leaseDuration, LeaseState leaseState, LeaseStatus leaseStatus, long contentLength, string contentType, ETag eTag, byte[] contentHash, string contentEncoding, string contentDisposition, string contentLanguage, string cacheControl, long blobSequenceNumber, string acceptRanges, int blobCommittedBlockCount, bool isServerEncrypted, string encryptionKeySha256, string encryptionScope, string accessTier, bool accessTierInferred, string archiveStatus, DateTimeOffset accessTierChangedOn, string versionId, bool isLatestVersion, long tagCount, DateTimeOffset expiresOn, bool isSealed, string rehydratePriority, DateTimeOffset lastAccessed, BlobImmutabilityPolicy immutabilityPolicy, bool hasLegalHold)
		{
			LastModified = lastModified;
			LeaseStatus = leaseStatus;
			ContentLength = contentLength;
			ContentType = contentType;
			ETag = eTag;
			LeaseState = leaseState;
			ContentEncoding = contentEncoding;
			ContentDisposition = contentDisposition;
			ContentLanguage = contentLanguage;
			CacheControl = cacheControl;
			BlobSequenceNumber = blobSequenceNumber;
			LeaseDuration = leaseDuration;
			AcceptRanges = acceptRanges;
			DestinationSnapshot = destinationSnapshot;
			BlobCommittedBlockCount = blobCommittedBlockCount;
			IsIncrementalCopy = isIncrementalCopy;
			IsServerEncrypted = isServerEncrypted;
			BlobCopyStatus = blobCopyStatus;
			EncryptionKeySha256 = encryptionKeySha256;
			CopySource = copySource;
			EncryptionScope = encryptionScope;
			CopyProgress = copyProgress;
			AccessTier = accessTier;
			CopyId = copyId;
			AccessTierInferred = accessTierInferred;
			CopyStatusDescription = copyStatusDescription;
			ArchiveStatus = archiveStatus;
			CopyCompletedOn = copyCompletedOn;
			AccessTierChangedOn = accessTierChangedOn;
			BlobType = blobType;
			VersionId = versionId;
			ObjectReplicationSourceProperties = objectReplicationSourceProperties;
			IsLatestVersion = isLatestVersion;
			ObjectReplicationDestinationPolicyId = objectReplicationDestinationPolicyId;
			TagCount = tagCount;
			Metadata = metadata;
			ExpiresOn = expiresOn;
			CreatedOn = createdOn;
			IsSealed = isSealed;
			RehydratePriority = rehydratePriority;
			ContentHash = contentHash;
			LastAccessed = lastAccessed;
			ImmutabilityPolicy = immutabilityPolicy;
			HasLegalHold = hasLegalHold;
		}
	}
	public class BlobQueryArrowField
	{
		public BlobQueryArrowFieldType Type { get; set; }

		public string Name { get; set; }

		public int Precision { get; set; }

		public int Scale { get; set; }
	}
	public enum BlobQueryArrowFieldType
	{
		Int64,
		Bool,
		Timestamp,
		String,
		Double,
		Decimal
	}
	public class BlobQueryArrowOptions : BlobQueryTextOptions
	{
		public IList<BlobQueryArrowField> Schema { get; set; } = new List<BlobQueryArrowField>();
	}
	public class BlobQueryCsvTextOptions : BlobQueryTextOptions
	{
		public string RecordSeparator { get; set; }

		public string ColumnSeparator { get; set; }

		public char? QuotationCharacter { get; set; }

		public char? EscapeCharacter { get; set; }

		public bool HasHeaders { get; set; }
	}
	public class BlobQueryError
	{
		public string Name { get; internal set; }

		public string Description { get; internal set; }

		public bool IsFatal { get; internal set; }

		public long Position { get; internal set; }

		internal BlobQueryError()
		{
		}
	}
	public class BlobQueryJsonTextOptions : BlobQueryTextOptions
	{
		public string RecordSeparator { get; set; }
	}
	public class BlobQueryOptions
	{
		private readonly object _objectLock = new object();

		internal Action<BlobQueryError> _errorHandler;

		public BlobQueryTextOptions InputTextConfiguration { get; set; }

		public BlobQueryTextOptions OutputTextConfiguration { get; set; }

		public BlobRequestConditions Conditions { get; set; }

		public IProgress<long> ProgressHandler { get; set; }

		public event Action<BlobQueryError> ErrorHandler
		{
			add
			{
				lock (_objectLock)
				{
					_errorHandler = (Action<BlobQueryError>)Delegate.Combine(_errorHandler, value);
				}
			}
			remove
			{
				lock (_objectLock)
				{
					_errorHandler = (Action<BlobQueryError>)Delegate.Remove(_errorHandler, value);
				}
			}
		}
	}
	public class BlobQueryParquetTextOptions : BlobQueryTextOptions
	{
	}
	public abstract class BlobQueryTextOptions
	{
	}
	public class BlobRequestConditions : BlobLeaseRequestConditions
	{
		public string LeaseId { get; set; }

		public BlobRequestConditions()
		{
		}

		private BlobRequestConditions(BlobRequestConditions deepCopySource)
			: base(deepCopySource)
		{
			Azure.Core.Argument.AssertNotNull(deepCopySource, "deepCopySource");
			LeaseId = deepCopySource.LeaseId;
		}

		internal static BlobRequestConditions CloneOrDefault(BlobRequestConditions deepCopySource)
		{
			if (deepCopySource == null)
			{
				return null;
			}
			return new BlobRequestConditions(deepCopySource);
		}

		public override string ToString()
		{
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.Append('[').Append(GetType().Name);
			AddConditions(stringBuilder);
			if (stringBuilder[stringBuilder.Length - 1] == ';')
			{
				stringBuilder[stringBuilder.Length - 1] = ']';
			}
			else
			{
				stringBuilder.Append(']');
			}
			return stringBuilder.ToString();
		}

		internal BlobRequestConditions WithIfMatch(ETag etag)
		{
			return new BlobRequestConditions(this)
			{
				IfMatch = etag
			};
		}

		internal virtual void AddConditions(StringBuilder conditions)
		{
			if (base.IfMatch.HasValue)
			{
				conditions.Append("IfMatch").Append('=').Append(base.IfMatch)
					.Append(';');
			}
			if (base.IfNoneMatch.HasValue)
			{
				conditions.Append("IfNoneMatch").Append('=').Append(base.IfNoneMatch)
					.Append(';');
			}
			if (base.IfModifiedSince.HasValue)
			{
				conditions.Append("IfModifiedSince").Append('=').Append(base.IfModifiedSince)
					.Append(';');
			}
			if (base.IfUnmodifiedSince.HasValue)
			{
				conditions.Append("IfUnmodifiedSince").Append('=').Append(base.IfUnmodifiedSince)
					.Append(';');
			}
			if (LeaseId != null)
			{
				conditions.Append("LeaseId").Append('=').Append(LeaseId)
					.Append(';');
			}
			if (base.TagConditions != null)
			{
				conditions.Append("TagConditions").Append('=').Append(base.TagConditions)
					.Append(';');
			}
		}
	}
	public class BlobSnapshotInfo
	{
		public string Snapshot { get; internal set; }

		public ETag ETag { get; internal set; }

		public DateTimeOffset LastModified { get; internal set; }

		public string VersionId { get; internal set; }

		public bool IsServerEncrypted { get; internal set; }

		internal BlobSnapshotInfo()
		{
		}
	}
	[Flags]
	public enum BlobStates
	{
		None = 0,
		Snapshots = 1,
		Uncommitted = 2,
		Deleted = 4,
		Version = 8,
		DeletedWithVersions = 0x10,
		All = -1
	}
	public class BlobSyncUploadFromUriOptions
	{
		public bool? CopySourceBlobProperties { get; set; }

		public BlobHttpHeaders HttpHeaders { get; set; }

		public IDictionary<string, string> Metadata { get; set; }

		public IDictionary<string, string> Tags { get; set; }

		public BlobRequestConditions DestinationConditions { get; set; }

		public BlobRequestConditions SourceConditions { get; set; }

		public AccessTier? AccessTier { get; set; }

		public byte[] ContentHash { get; set; }

		public HttpAuthorization SourceAuthentication { get; set; }

		public BlobCopySourceTagsMode? CopySourceTagsMode { get; set; }
	}
	[Flags]
	public enum BlobTraits
	{
		None = 0,
		CopyStatus = 1,
		Metadata = 2,
		Tags = 4,
		ImmutabilityPolicy = 8,
		LegalHold = 0x10,
		All = -1
	}
	public enum BlobType
	{
		[CodeGenMember("BlockBlob")]
		Block,
		[CodeGenMember("PageBlob")]
		Page,
		[CodeGenMember("AppendBlob")]
		Append
	}
	public class BlobUploadOptions
	{
		public BlobHttpHeaders HttpHeaders { get; set; }

		public IDictionary<string, string> Metadata { get; set; }

		public IDictionary<string, string> Tags { get; set; }

		public BlobRequestConditions Conditions { get; set; }

		public IProgress<long> ProgressHandler { get; set; }

		public AccessTier? AccessTier { get; set; }

		public StorageTransferOptions TransferOptions { get; set; }

		public BlobImmutabilityPolicy ImmutabilityPolicy { get; set; }

		public bool? LegalHold { get; set; }

		public UploadTransferValidationOptions TransferValidation { get; set; }
	}
	public class BlockBlobOpenWriteOptions
	{
		public long? BufferSize { get; set; }

		public BlobRequestConditions OpenConditions { get; set; }

		public IProgress<long> ProgressHandler { get; set; }

		public BlobHttpHeaders HttpHeaders { get; set; }

		public IDictionary<string, string> Metadata { get; set; }

		public IDictionary<string, string> Tags { get; set; }

		public UploadTransferValidationOptions TransferValidation { get; set; }

		internal string OperationName { get; set; }
	}
	public class BlockBlobStageBlockOptions
	{
		public BlobRequestConditions Conditions { get; set; }

		public IProgress<long> ProgressHandler { get; set; }

		public UploadTransferValidationOptions TransferValidation { get; set; }
	}
	public class BlockInfo
	{
		public byte[] ContentHash { get; internal set; }

		public byte[] ContentCrc64 { get; internal set; }

		public string EncryptionKeySha256 { get; internal set; }

		public string EncryptionScope { get; internal set; }

		internal BlockInfo()
		{
		}
	}
	[Flags]
	public enum BlockListTypes
	{
		All = 3,
		Committed = 1,
		Uncommitted = 2
	}
	public class CommitBlockListOptions
	{
		public BlobHttpHeaders HttpHeaders { get; set; }

		public IDictionary<string, string> Metadata { get; set; }

		public IDictionary<string, string> Tags { get; set; }

		public BlobRequestConditions Conditions { get; set; }

		public AccessTier? AccessTier { get; set; }

		public BlobImmutabilityPolicy ImmutabilityPolicy { get; set; }

		public bool? LegalHold { get; set; }
	}
	internal struct ContentRange
	{
		public struct RangeUnit
		{
			internal const string BytesValue = "bytes";

			private readonly string _value;

			public static RangeUnit Bytes { get; } = new RangeUnit("bytes");

			public RangeUnit(string value)
			{
				_value = value ?? throw new ArgumentNullException("value");
			}

			public static bool operator ==(RangeUnit left, RangeUnit right)
			{
				return left.Equals(right);
			}

			public static bool operator !=(RangeUnit left, RangeUnit right)
			{
				return !left.Equals(right);
			}

			public static implicit operator RangeUnit(string value)
			{
				return new RangeUnit(value);
			}

			[EditorBrowsable(EditorBrowsableState.Never)]
			public override bool Equals(object obj)
			{
				if (obj is RangeUnit other)
				{
					return Equals(other);
				}
				return false;
			}

			public bool Equals(RangeUnit other)
			{
				return string.Equals(_value, other._value, StringComparison.Ordinal);
			}

			[EditorBrowsable(EditorBrowsableState.Never)]
			public override int GetHashCode()
			{
				return _value?.GetHashCode() ?? 0;
			}

			public override string ToString()
			{
				return _value;
			}
		}

		private const string WildcardMarker = "*";

		public long? Start { get; }

		public long? End { get; }

		public long? Size { get; }

		public RangeUnit Unit { get; }

		public ContentRange(RangeUnit unit, long? start, long? end, long? size)
		{
			Start = start;
			End = end;
			Size = size;
			Unit = unit;
		}

		public static ContentRange Parse(string headerValue)
		{
			string[] array = headerValue.Split(' ', '-', '/');
			long? start = null;
			long? end = null;
			long? size = null;
			try
			{
				string obj = array[0];
				int num;
				if (array[1] == "*")
				{
					num = 2;
				}
				else
				{
					num = 3;
					start = long.Parse(array[1], CultureInfo.InvariantCulture);
					end = long.Parse(array[2], CultureInfo.InvariantCulture);
				}
				string text = array[num];
				if (text != "*")
				{
					size = long.Parse(text, CultureInfo.InvariantCulture);
				}
				return new ContentRange(obj, start, end, size);
			}
			catch (IndexOutOfRangeException)
			{
				throw Azure.Storage.Errors.ParsingHttpRangeFailed();
			}
		}
	}
	public class CopyFromUriOperation : Operation<long>
	{
		private readonly BlobBaseClient _client;

		private readonly CancellationToken _cancellationToken;

		private bool _hasCompleted;

		private long? _value;

		private Response _rawResponse;

		public override bool HasCompleted => _hasCompleted;

		public override bool HasValue => _value.HasValue;

		public override string Id { get; }

		public override long Value => Azure.Core.OperationHelpers.GetValue(ref _value);

		public override Response GetRawResponse()
		{
			return _rawResponse;
		}

		public override ValueTask<Response<long>> WaitForCompletionAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return this.DefaultWaitForCompletionAsync(cancellationToken);
		}

		public override ValueTask<Response<long>> WaitForCompletionAsync(TimeSpan pollingInterval, CancellationToken cancellationToken)
		{
			return this.DefaultWaitForCompletionAsync(pollingInterval, cancellationToken);
		}

		protected CopyFromUriOperation()
		{
		}

		public CopyFromUriOperation(string id, BlobBaseClient client)
			: this(client, id, null, CancellationToken.None)
		{
		}

		internal CopyFromUriOperation(BlobBaseClient client, string copyId, Response initialResponse, CancellationToken cancellationToken)
		{
			Id = copyId;
			_value = null;
			_rawResponse = initialResponse;
			_client = client;
			_cancellationToken = cancellationToken;
		}

		public override Response UpdateStatus(CancellationToken cancellationToken = default(CancellationToken))
		{
			return UpdateStatusAsync(async: false, cancellationToken).EnsureCompleted();
		}

		public override async ValueTask<Response> UpdateStatusAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return await UpdateStatusAsync(async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response> UpdateStatusAsync(bool async, CancellationToken cancellationToken)
		{
			if (HasCompleted)
			{
				return GetRawResponse();
			}
			if (cancellationToken == default(CancellationToken))
			{
				cancellationToken = _cancellationToken;
			}
			Response<BlobProperties> response = ((!async) ? _client.GetProperties(null, cancellationToken) : (await _client.GetPropertiesAsync(null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
			Response<BlobProperties> response2 = response;
			if (Id != response2.Value.CopyId || response2.Value.CopyStatus != CopyStatus.Pending)
			{
				_hasCompleted = true;
			}
			if (Id == response2.Value.CopyId && response2.Value.CopyStatus == CopyStatus.Success)
			{
				_value = response2.Value.ContentLength;
			}
			if (Id == response2.Value.CopyId && (response2.Value.CopyStatus == CopyStatus.Aborted || response2.Value.CopyStatus == CopyStatus.Failed))
			{
				_value = 0L;
			}
			return _rawResponse = response2.GetRawResponse();
		}
	}
	[CodeGenModel("CopyStatusType")]
	public enum CopyStatus
	{
		Pending,
		Success,
		Aborted,
		Failed
	}
	public readonly struct CustomerProvidedKey : IEquatable<CustomerProvidedKey>
	{
		public string EncryptionKey { get; }

		public string EncryptionKeyHash { get; }

		public EncryptionAlgorithmType EncryptionAlgorithm { get; }

		public CustomerProvidedKey(string key)
		{
			EncryptionKey = key;
			EncryptionAlgorithm = EncryptionAlgorithmType.Aes256;
			using SHA256 sHA = SHA256.Create();
			byte[] inArray = sHA.ComputeHash(Convert.FromBase64String(key));
			EncryptionKeyHash = Convert.ToBase64String(inArray);
		}

		public CustomerProvidedKey(byte[] key)
			: this(Convert.ToBase64String(key))
		{
		}

		public override bool Equals(object obj)
		{
			if (obj is CustomerProvidedKey other)
			{
				return Equals(other);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return EncryptionKey.GetHashCode() ^ EncryptionKeyHash.GetHashCode() ^ EncryptionAlgorithm.GetHashCode();
		}

		public static bool operator ==(CustomerProvidedKey left, CustomerProvidedKey right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(CustomerProvidedKey left, CustomerProvidedKey right)
		{
			return !(left == right);
		}

		public bool Equals(CustomerProvidedKey other)
		{
			if (EncryptionKey == other.EncryptionKey && EncryptionKeyHash == other.EncryptionKeyHash)
			{
				return EncryptionAlgorithm == other.EncryptionAlgorithm;
			}
			return false;
		}

		public override string ToString()
		{
			return string.Format("[{0}:{1}={2};{3}={4};{5}={6}]", "CustomerProvidedKey", "EncryptionKey", EncryptionKey, "EncryptionKeyHash", EncryptionKeyHash, "EncryptionAlgorithm", EncryptionAlgorithm);
		}
	}
	[CodeGenModel("DeleteSnapshotsOptionType")]
	public enum DeleteSnapshotsOption
	{
		None,
		[CodeGenMember("Include")]
		IncludeSnapshots,
		[CodeGenMember("Only")]
		OnlySnapshots
	}
	public enum EncryptionAlgorithmType
	{
		Aes256
	}
	internal class FilterBlobsAsyncCollection : StorageCollectionEnumerator<TaggedBlobItem>
	{
		private readonly BlobServiceClient _serviceClient;

		private readonly BlobContainerClient _containerClient;

		private readonly string _expression;

		public FilterBlobsAsyncCollection(BlobServiceClient serviceClient, string expression)
		{
			_serviceClient = serviceClient;
			_expression = expression;
		}

		public FilterBlobsAsyncCollection(BlobContainerClient containerClient, string expression)
		{
			_containerClient = containerClient;
			_expression = expression;
		}

		public override async ValueTask<Page<TaggedBlobItem>> GetNextPageAsync(string continuationToken, int? pageSizeHint, bool async, CancellationToken cancellationToken)
		{
			Response<FilterBlobSegment> response = ((_serviceClient == null) ? (await _containerClient.FindBlobsByTagsInternal(continuationToken, _expression, pageSizeHint, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)) : (await _serviceClient.FindBlobsByTagsInternal(continuationToken, _expression, pageSizeHint, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
			return Page<TaggedBlobItem>.FromValues(response.Value.Blobs.ToBlobTagItems(), response.Value.NextMarker, response.GetRawResponse());
		}
	}
	internal class GetBlobContainersAsyncCollection : StorageCollectionEnumerator<BlobContainerItem>
	{
		private readonly BlobServiceClient _client;

		private readonly BlobContainerTraits _traits;

		private readonly BlobContainerStates _states;

		private readonly string _prefix;

		public GetBlobContainersAsyncCollection(BlobServiceClient client, BlobContainerTraits traits, BlobContainerStates states, string prefix = null)
		{
			_client = client;
			_traits = traits;
			_states = states;
			_prefix = prefix;
		}

		public override async ValueTask<Page<BlobContainerItem>> GetNextPageAsync(string continuationToken, int? pageSizeHint, bool async, CancellationToken cancellationToken)
		{
			Response<ListContainersSegmentResponse> response = ((!async) ? _client.GetBlobContainersInternal(continuationToken, _traits, _states, _prefix, pageSizeHint, async, cancellationToken).EnsureCompleted() : (await _client.GetBlobContainersInternal(continuationToken, _traits, _states, _prefix, pageSizeHint, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
			return Page<BlobContainerItem>.FromValues(response.Value.ContainerItems.ToBlobContainerItems(), response.Value.NextMarker, response.GetRawResponse());
		}
	}
	internal class GetBlobsAsyncCollection : StorageCollectionEnumerator<BlobItem>
	{
		private readonly BlobContainerClient _client;

		private readonly BlobTraits _traits;

		private readonly BlobStates _states;

		private readonly string _prefix;

		public GetBlobsAsyncCollection(BlobContainerClient client, BlobTraits traits, BlobStates states, string prefix)
		{
			_client = client;
			_traits = traits;
			_states = states;
			_prefix = prefix;
		}

		public override async ValueTask<Page<BlobItem>> GetNextPageAsync(string continuationToken, int? pageSizeHint, bool async, CancellationToken cancellationToken)
		{
			Response<ListBlobsFlatSegmentResponse> response = ((!async) ? _client.GetBlobsInternal(continuationToken, _traits, _states, _prefix, pageSizeHint, async, cancellationToken).EnsureCompleted() : (await _client.GetBlobsInternal(continuationToken, _traits, _states, _prefix, pageSizeHint, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
			return Page<BlobItem>.FromValues(response.Value.Segment.BlobItems.ToBlobItems().ToArray(), response.Value.NextMarker, response.GetRawResponse());
		}
	}
	internal class GetBlobsByHierarchyAsyncCollection : StorageCollectionEnumerator<BlobHierarchyItem>
	{
		private readonly BlobContainerClient _client;

		private readonly BlobTraits _traits;

		private readonly BlobStates _states;

		private readonly string _delimiter;

		private readonly string _prefix;

		public GetBlobsByHierarchyAsyncCollection(BlobContainerClient client, string delimiter, BlobTraits traits, BlobStates states, string prefix)
		{
			_client = client;
			_delimiter = delimiter;
			_traits = traits;
			_states = states;
			_prefix = prefix;
		}

		public override async ValueTask<Page<BlobHierarchyItem>> GetNextPageAsync(string continuationToken, int? pageSizeHint, bool async, CancellationToken cancellationToken)
		{
			Response<ListBlobsHierarchySegmentResponse> response = ((!async) ? _client.GetBlobsByHierarchyInternal(continuationToken, _delimiter, _traits, _states, _prefix, pageSizeHint, async, cancellationToken).EnsureCompleted() : (await _client.GetBlobsByHierarchyInternal(continuationToken, _delimiter, _traits, _states, _prefix, pageSizeHint, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
			List<BlobHierarchyItem> list = new List<BlobHierarchyItem>();
			list.AddRange(response.Value.Segment.BlobPrefixes.Select((BlobPrefix p) => new BlobHierarchyItem(p.Name.ToBlobNameString(), null)));
			list.AddRange(response.Value.Segment.BlobItems.Select((BlobItemInternal b) => new BlobHierarchyItem(null, b.ToBlobItem())));
			return Page<BlobHierarchyItem>.FromValues(list.ToArray(), response.Value.NextMarker, response.GetRawResponse());
		}
	}
	public class GetBlobTagResult
	{
		public IDictionary<string, string> Tags { get; internal set; }
	}
	internal class GetPageRangesAsyncCollection : StorageCollectionEnumerator<PageRangeItem>
	{
		private readonly bool _diff;

		private readonly PageBlobClient _client;

		private readonly HttpRange? _range;

		private readonly string _snapshot;

		private readonly string _previousSnapshot;

		private readonly Uri _previousSnapshotUri;

		private readonly PageBlobRequestConditions _requestConditions;

		private readonly string _operationName;

		public GetPageRangesAsyncCollection(bool diff, PageBlobClient client, HttpRange? range, string snapshot, string previousSnapshot, Uri previousSnapshotUri, PageBlobRequestConditions requestConditions, string operationName)
		{
			_diff = diff;
			_client = client;
			_range = range;
			_snapshot = snapshot;
			_previousSnapshot = previousSnapshot;
			_previousSnapshotUri = previousSnapshotUri;
			_requestConditions = requestConditions;
			_operationName = operationName;
		}

		public override async ValueTask<Page<PageRangeItem>> GetNextPageAsync(string continuationToken, int? pageSizeHint, bool async, CancellationToken cancellationToken)
		{
			if (_diff)
			{
				Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesDiffHeaders> responseWithHeaders = ((!async) ? _client.GetAllPageRangesDiffInternal(continuationToken, pageSizeHint, _range, _snapshot, _previousSnapshot, _previousSnapshotUri, _requestConditions, async: false, _operationName, cancellationToken).EnsureCompleted() : (await _client.GetAllPageRangesDiffInternal(continuationToken, pageSizeHint, _range, _snapshot, _previousSnapshot, _previousSnapshotUri, _requestConditions, async: true, _operationName, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
				return Page<PageRangeItem>.FromValues(responseWithHeaders.ToPageBlobRanges(), responseWithHeaders.Value.NextMarker, responseWithHeaders.GetRawResponse());
			}
			Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesHeaders> responseWithHeaders2 = ((!async) ? _client.GetAllPageRangesInteral(continuationToken, pageSizeHint, _range, _snapshot, _requestConditions, async: false, cancellationToken).EnsureCompleted() : (await _client.GetAllPageRangesInteral(continuationToken, pageSizeHint, _range, _snapshot, _requestConditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
			return Page<PageRangeItem>.FromValues(responseWithHeaders2.ToPageBlobRanges(), responseWithHeaders2.Value.NextMarker, responseWithHeaders2.GetRawResponse());
		}
	}
	public class GetPageRangesDiffOptions
	{
		public HttpRange? Range { get; set; }

		public string Snapshot { get; set; }

		public string PreviousSnapshot { get; set; }

		public PageBlobRequestConditions Conditions { get; set; }
	}
	public class GetPageRangesOptions
	{
		public HttpRange? Range { get; set; }

		public string Snapshot { get; set; }

		public PageBlobRequestConditions Conditions { get; set; }
	}
	internal class ArrowConfiguration
	{
	}
	internal enum BlobDeleteType
	{
		None,
		Permanent
	}
	[Flags]
	internal enum BlobRequestConditionProperty
	{
		None = 0,
		LeaseId = 1,
		TagConditions = 2,
		IfModifiedSince = 4,
		IfUnmodifiedSince = 8,
		IfMatch = 0x10,
		IfNoneMatch = 0x20,
		IfAppendPositionEqual = 0x40,
		IfMaxSizeLessThanOrEqual = 0x80,
		IfSequenceNumberLessThan = 0x100,
		IfSequenceNumberLessThanOrEqual = 0x200,
		IfSequenceNumberEqual = 0x400
	}
	internal enum BlockListType
	{
		Committed,
		Uncommitted,
		All
	}
	[CodeGenModel("EncryptionAlgorithmType")]
	internal enum EncryptionAlgorithmTypeInternal
	{
		None,
		AES256
	}
	internal enum FilterBlobsIncludeItem
	{
		None,
		Versions
	}
	internal enum ListBlobsIncludeItem
	{
		Copy,
		Deleted,
		Metadata,
		Snapshots,
		Uncommittedblobs,
		Versions,
		Tags,
		Immutabilitypolicy,
		Legalhold,
		DeletedWithVersions
	}
	internal enum ListContainersIncludeType
	{
		Metadata,
		Deleted,
		System
	}
	internal enum QueryFormatType
	{
		Delimited,
		Json,
		Arrow,
		Parquet
	}
	public enum LeaseDurationType
	{
		Infinite,
		Fixed
	}
	[CodeGenModel("LeaseStateType")]
	public enum LeaseState
	{
		Available,
		Leased,
		Expired,
		Breaking,
		Broken
	}
	[CodeGenModel("LeaseStatusType")]
	public enum LeaseStatus
	{
		Locked,
		Unlocked
	}
	public class ObjectReplicationPolicy
	{
		public string PolicyId { get; internal set; }

		public IList<ObjectReplicationRule> Rules { get; internal set; }

		internal ObjectReplicationPolicy()
		{
		}
	}
	public class ObjectReplicationRule
	{
		public string RuleId { get; internal set; }

		public ObjectReplicationStatus ReplicationStatus { get; internal set; }

		internal ObjectReplicationRule()
		{
		}
	}
	[Flags]
	public enum ObjectReplicationStatus
	{
		Complete = 0,
		Failed = 1
	}
	public class PageBlobCreateOptions
	{
		public long? SequenceNumber { get; set; }

		public BlobHttpHeaders HttpHeaders { get; set; }

		public PageBlobRequestConditions Conditions { get; set; }

		public IDictionary<string, string> Metadata { get; set; }

		public IDictionary<string, string> Tags { get; set; }

		public BlobImmutabilityPolicy ImmutabilityPolicy { get; set; }

		public bool? LegalHold { get; set; }
	}
	public class PageBlobInfo
	{
		public ETag ETag { get; internal set; }

		public DateTimeOffset LastModified { get; internal set; }

		public long BlobSequenceNumber { get; internal set; }

		internal PageBlobInfo()
		{
		}
	}
	public class PageBlobOpenWriteOptions
	{
		public long? BufferSize { get; set; }

		public PageBlobRequestConditions OpenConditions { get; set; }

		public IProgress<long> ProgressHandler { get; set; }

		public long? Size { get; set; }

		public UploadTransferValidationOptions TransferValidation { get; set; }
	}
	public class PageBlobRequestConditions : BlobRequestConditions
	{
		public long? IfSequenceNumberLessThan { get; set; }

		public long? IfSequenceNumberLessThanOrEqual { get; set; }

		public long? IfSequenceNumberEqual { get; set; }

		internal override void AddConditions(StringBuilder conditions)
		{
			base.AddConditions(conditions);
			if (IfSequenceNumberLessThan.HasValue)
			{
				conditions.Append("IfSequenceNumberLessThan").Append('=').Append(IfSequenceNumberLessThan)
					.Append(';');
			}
			if (IfSequenceNumberLessThanOrEqual.HasValue)
			{
				conditions.Append("IfSequenceNumberLessThanOrEqual").Append('=').Append(IfSequenceNumberLessThanOrEqual)
					.Append(';');
			}
			if (IfSequenceNumberEqual.HasValue)
			{
				conditions.Append("IfSequenceNumberEqual").Append('=').Append(IfSequenceNumberEqual)
					.Append(';');
			}
		}
	}
	public class PageBlobUploadPagesFromUriOptions
	{
		public byte[] SourceContentHash { get; set; }

		public PageBlobRequestConditions DestinationConditions { get; set; }

		public PageBlobRequestConditions SourceConditions { get; set; }

		public HttpAuthorization SourceAuthentication { get; set; }
	}
	public class PageBlobUploadPagesOptions
	{
		public PageBlobRequestConditions Conditions { get; set; }

		public IProgress<long> ProgressHandler { get; set; }

		public UploadTransferValidationOptions TransferValidation { get; set; }
	}
	public class PageInfo
	{
		public ETag ETag { get; internal set; }

		public DateTimeOffset LastModified { get; internal set; }

		public byte[] ContentHash { get; internal set; }

		public byte[] ContentCrc64 { get; internal set; }

		public long BlobSequenceNumber { get; internal set; }

		public string EncryptionKeySha256 { get; internal set; }

		public string EncryptionScope { get; internal set; }

		internal PageInfo()
		{
		}
	}
	public class PageRangeItem
	{
		public HttpRange Range { get; internal set; }

		public bool IsClear { get; internal set; }
	}
	public class PageRangesInfo
	{
		public DateTimeOffset LastModified { get; internal set; }

		public ETag ETag { get; internal set; }

		public long BlobContentLength { get; internal set; }

		public IEnumerable<HttpRange> PageRanges { get; internal set; }

		public IEnumerable<HttpRange> ClearRanges { get; internal set; }

		internal PageRangesInfo()
		{
		}
	}
	public enum PathRenameMode
	{
		Legacy,
		Posix
	}
	public enum PublicAccessType
	{
		None,
		[CodeGenMember("Container")]
		BlobContainer,
		Blob
	}
	public class ReleasedObjectInfo
	{
		public ETag ETag { get; }

		public DateTimeOffset LastModified { get; }

		public ReleasedObjectInfo(ETag eTag, DateTimeOffset lastModified)
		{
			ETag = eTag;
			LastModified = lastModified;
		}

		internal ReleasedObjectInfo(BlobInfo info)
			: this(info.ETag, info.LastModified)
		{
		}

		internal ReleasedObjectInfo(BlobContainerInfo info)
			: this(info.ETag, info.LastModified)
		{
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override string ToString()
		{
			return base.ToString();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override bool Equals(object obj)
		{
			return base.Equals(obj);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public override int GetHashCode()
		{
			return base.GetHashCode();
		}
	}
	[CodeGenModel("SequenceNumberActionType")]
	public enum SequenceNumberAction
	{
		Max,
		Update,
		Increment
	}
	public enum SkuName
	{
		[CodeGenMember("StandardLRS")]
		StandardLrs,
		[CodeGenMember("StandardGRS")]
		StandardGrs,
		StandardRagrs,
		[CodeGenMember("StandardZRS")]
		StandardZrs,
		[CodeGenMember("PremiumLRS")]
		PremiumLrs
	}
	public class StageBlockFromUriOptions
	{
		public HttpRange SourceRange { get; set; }

		public byte[] SourceContentHash { get; set; }

		public RequestConditions SourceConditions { get; set; }

		public BlobRequestConditions DestinationConditions { get; set; }

		public HttpAuthorization SourceAuthentication { get; set; }
	}
	public class TaggedBlobItem
	{
		public string BlobName { get; internal set; }

		public string BlobContainerName { get; internal set; }

		public IDictionary<string, string> Tags { get; internal set; }

		internal TaggedBlobItem()
		{
		}
	}
}
namespace Azure.Storage.Blobs.Specialized
{
	public class AppendBlobClient : BlobBaseClient
	{
		private readonly AppendBlobRestClient _appendBlobRestClient;

		public virtual int AppendBlobMaxAppendBlockBytes
		{
			get
			{
				if (ClientConfiguration.Version >= BlobClientOptions.ServiceVersion.V2022_11_02)
				{
					return 104857600;
				}
				return 4194304;
			}
		}

		public virtual int AppendBlobMaxBlocks => 50000;

		internal virtual AppendBlobRestClient AppendBlobRestClient => _appendBlobRestClient;

		protected AppendBlobClient()
		{
		}

		public AppendBlobClient(string connectionString, string blobContainerName, string blobName)
			: base(connectionString, blobContainerName, blobName)
		{
			_appendBlobRestClient = BuildAppendBlobRestClient(_uri);
		}

		public AppendBlobClient(string connectionString, string blobContainerName, string blobName, BlobClientOptions options)
			: base(connectionString, blobContainerName, blobName, options)
		{
			_appendBlobRestClient = BuildAppendBlobRestClient(_uri);
			AssertNoClientSideEncryption(options);
		}

		public AppendBlobClient(Uri blobUri, BlobClientOptions options = null)
			: base(blobUri, options)
		{
			AssertNoClientSideEncryption(options);
			_appendBlobRestClient = BuildAppendBlobRestClient(blobUri);
		}

		public AppendBlobClient(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options = null)
			: base(blobUri, credential, options)
		{
			AssertNoClientSideEncryption(options);
			_appendBlobRestClient = BuildAppendBlobRestClient(blobUri);
		}

		public AppendBlobClient(Uri blobUri, AzureSasCredential credential, BlobClientOptions options = null)
			: base(blobUri, credential, options)
		{
			AssertNoClientSideEncryption(options);
			_appendBlobRestClient = BuildAppendBlobRestClient(blobUri);
		}

		public AppendBlobClient(Uri blobUri, TokenCredential credential, BlobClientOptions options = null)
			: base(blobUri, credential, options)
		{
			AssertNoClientSideEncryption(options);
			_appendBlobRestClient = BuildAppendBlobRestClient(blobUri);
		}

		internal AppendBlobClient(Uri blobUri, BlobClientConfiguration clientConfiguration)
			: base(blobUri, clientConfiguration, null)
		{
			_appendBlobRestClient = BuildAppendBlobRestClient(blobUri);
		}

		private static void AssertNoClientSideEncryption(BlobClientOptions options)
		{
			if (options?._clientSideEncryptionOptions != null)
			{
				throw Azure.Storage.Errors.ClientSideEncryption.TypeNotSupported(typeof(AppendBlobClient));
			}
		}

		private AppendBlobRestClient BuildAppendBlobRestClient(Uri blobUri)
		{
			return new AppendBlobRestClient(_clientConfiguration.ClientDiagnostics, _clientConfiguration.Pipeline, blobUri.AbsoluteUri, _clientConfiguration.Version.ToVersionString());
		}

		public new AppendBlobClient WithSnapshot(string snapshot)
		{
			return new AppendBlobClient(new BlobUriBuilder(Uri)
			{
				Snapshot = snapshot
			}.ToUri(), ClientConfiguration);
		}

		public new AppendBlobClient WithVersion(string versionId)
		{
			return new AppendBlobClient(new BlobUriBuilder(Uri)
			{
				VersionId = versionId
			}.ToUri(), ClientConfiguration);
		}

		public new AppendBlobClient WithCustomerProvidedKey(CustomerProvidedKey? customerProvidedKey)
		{
			BlobClientConfiguration blobClientConfiguration = BlobClientConfiguration.DeepCopy(ClientConfiguration);
			blobClientConfiguration.CustomerProvidedKey = customerProvidedKey;
			return new AppendBlobClient(Uri, blobClientConfiguration);
		}

		public new AppendBlobClient WithEncryptionScope(string encryptionScope)
		{
			BlobClientConfiguration blobClientConfiguration = BlobClientConfiguration.DeepCopy(ClientConfiguration);
			blobClientConfiguration.EncryptionScope = encryptionScope;
			return new AppendBlobClient(Uri, blobClientConfiguration);
		}

		public virtual Response<BlobContentInfo> Create(AppendBlobCreateOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CreateInternal(options?.HttpHeaders, options?.Metadata, options?.Tags, options?.Conditions, options?.ImmutabilityPolicy, options?.HasLegalHold, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContentInfo>> CreateAsync(AppendBlobCreateOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await CreateInternal(options?.HttpHeaders, options?.Metadata, options?.Tags, options?.Conditions, options?.ImmutabilityPolicy, options?.HasLegalHold, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobContentInfo> Create(BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, AppendBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CreateInternal(httpHeaders, metadata, null, conditions, null, null, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobContentInfo>> CreateAsync(BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, AppendBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await CreateInternal(httpHeaders, metadata, null, conditions, null, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<BlobContentInfo> CreateIfNotExists(AppendBlobCreateOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CreateIfNotExistsInternal(options?.HttpHeaders, options?.Metadata, immutabilityPolicy: options?.ImmutabilityPolicy, legalHold: options?.HasLegalHold, tags: options?.Tags, async: false, cancellationToken: cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContentInfo>> CreateIfNotExistsAsync(AppendBlobCreateOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await CreateIfNotExistsInternal(options?.HttpHeaders, options?.Metadata, options?.Tags, options?.ImmutabilityPolicy, options?.HasLegalHold, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobContentInfo> CreateIfNotExists(BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CreateIfNotExistsInternal(httpHeaders, metadata, null, null, null, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobContentInfo>> CreateIfNotExistsAsync(BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await CreateIfNotExistsInternal(httpHeaders, metadata, null, null, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobContentInfo>> CreateIfNotExistsInternal(BlobHttpHeaders httpHeaders, IDictionary<string, string> metadata, IDictionary<string, string> tags, BlobImmutabilityPolicy immutabilityPolicy, bool? legalHold, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("AppendBlobClient", "CreateIfNotExistsInternal"))
			{
				string text = "AppendBlobClient.CreateIfNotExists";
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope(text);
				AppendBlobRequestConditions conditions = new AppendBlobRequestConditions
				{
					IfNoneMatch = new ETag("*")
				};
				try
				{
					scope.Start();
					return await CreateInternal(httpHeaders, metadata, tags, conditions, immutabilityPolicy, legalHold, async, cancellationToken, text).ConfigureAwait(continueOnCapturedContext: false);
				}
				catch (RequestFailedException ex) when (ex.ErrorCode == BlobErrorCode.BlobAlreadyExists)
				{
					return null;
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		private async Task<Response<BlobContentInfo>> CreateInternal(BlobHttpHeaders httpHeaders, IDictionary<string, string> metadata, IDictionary<string, string> tags, AppendBlobRequestConditions conditions, BlobImmutabilityPolicy immutabilityPolicy, bool? legalHold, bool async, CancellationToken cancellationToken, string operationName = null)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("AppendBlobClient", "CreateInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("AppendBlobClient.Create");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfAppendPositionEqual | BlobRequestConditionProperty.IfMaxSizeLessThanOrEqual, "Create", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<AppendBlobCreateHeaders> responseWithHeaders;
					if (async)
					{
						AppendBlobRestClient appendBlobRestClient = AppendBlobRestClient;
						long contentLength = 0L;
						string blobContentType = httpHeaders?.ContentType;
						string blobContentEncoding = httpHeaders?.ContentEncoding;
						string blobContentLanguage = httpHeaders?.ContentLanguage;
						byte[] blobContentMD = httpHeaders?.ContentHash;
						string blobCacheControl = httpHeaders?.CacheControl;
						IDictionary<string, string> metadata2 = metadata;
						string leaseId = conditions?.LeaseId;
						string blobContentDisposition = httpHeaders?.ContentDisposition;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						string blobTagsString = tags?.ToTagsString();
						DateTimeOffset? immutabilityPolicyExpiry = immutabilityPolicy?.ExpiresOn;
						BlobImmutabilityPolicyMode? immutabilityPolicyMode = immutabilityPolicy?.PolicyMode;
						bool? legalHold2 = legalHold;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await appendBlobRestClient.CreateAsync(contentLength, null, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD, blobCacheControl, metadata2, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold2, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						AppendBlobRestClient appendBlobRestClient2 = AppendBlobRestClient;
						long contentLength2 = 0L;
						string blobTagsString = httpHeaders?.ContentType;
						string ifTags = httpHeaders?.ContentEncoding;
						string ifNoneMatch = httpHeaders?.ContentLanguage;
						byte[] blobContentMD = httpHeaders?.ContentHash;
						string ifMatch = httpHeaders?.CacheControl;
						IDictionary<string, string> metadata2 = metadata;
						string encryptionScope = conditions?.LeaseId;
						string encryptionKeySha = httpHeaders?.ContentDisposition;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string blobContentDisposition = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string leaseId = ClientConfiguration.EncryptionScope;
						DateTimeOffset? immutabilityPolicyExpiry = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string blobCacheControl = conditions?.IfMatch?.ToString();
						string blobContentLanguage = conditions?.IfNoneMatch?.ToString();
						string blobContentEncoding = conditions?.TagConditions;
						string blobContentType = tags?.ToTagsString();
						DateTimeOffset? ifModifiedSince = immutabilityPolicy?.ExpiresOn;
						BlobImmutabilityPolicyMode? immutabilityPolicyMode = immutabilityPolicy?.PolicyMode;
						bool? legalHold2 = legalHold;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = appendBlobRestClient2.Create(contentLength2, null, blobTagsString, ifTags, ifNoneMatch, blobContentMD, ifMatch, metadata2, encryptionScope, encryptionKeySha, encryptionKey, blobContentDisposition, encryptionAlgorithm, leaseId, immutabilityPolicyExpiry, ifUnmodifiedSince, blobCacheControl, blobContentLanguage, blobContentEncoding, blobContentType, ifModifiedSince, immutabilityPolicyMode, legalHold2, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobContentInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobAppendInfo> AppendBlock(Stream content, byte[] transactionalContentHash, AppendBlobRequestConditions conditions, IProgress<long> progressHandler, CancellationToken cancellationToken)
		{
			return AppendBlockInternal(content, transactionalContentHash.ToValidationOptions(), conditions, progressHandler, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobAppendInfo>> AppendBlockAsync(Stream content, byte[] transactionalContentHash, AppendBlobRequestConditions conditions, IProgress<long> progressHandler, CancellationToken cancellationToken)
		{
			return await AppendBlockInternal(content, transactionalContentHash.ToValidationOptions(), conditions, progressHandler, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<BlobAppendInfo> AppendBlock(Stream content, AppendBlobAppendBlockOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return AppendBlockInternal(content, options?.TransferValidation, options?.Conditions, options?.ProgressHandler, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobAppendInfo>> AppendBlockAsync(Stream content, AppendBlobAppendBlockOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await AppendBlockInternal(content, options?.TransferValidation, options?.Conditions, options?.ProgressHandler, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal async Task<Response<BlobAppendInfo>> AppendBlockInternal(Stream content, UploadTransferValidationOptions transferValidationOverride, AppendBlobRequestConditions conditions, IProgress<long> progressHandler, bool async, CancellationToken cancellationToken)
		{
			UploadTransferValidationOptions options = transferValidationOverride ?? ClientConfiguration.TransferValidation.Upload;
			using (ClientConfiguration.Pipeline.BeginLoggingScope("AppendBlobClient", "AppendBlockInternal"))
			{
				Azure.Core.Argument.AssertNotNull(content, "content");
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("AppendBlobClient.AppendBlock");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "AppendBlock", "conditions");
				try
				{
					scope.Start();
					BlobErrors.VerifyHttpsCustomerProvidedKey(Uri, ClientConfiguration.CustomerProvidedKey);
					Azure.Storage.Errors.VerifyStreamPosition(content, "content");
					ContentHasher.GetHashResult getHashResult = await ContentHasher.GetHashOrDefaultInternal(content, options, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					content = content.WithNoDispose().WithProgress(progressHandler);
					Azure.Core.ResponseWithHeaders<AppendBlobAppendBlockHeaders> responseWithHeaders;
					if (async)
					{
						AppendBlobRestClient appendBlobRestClient = AppendBlobRestClient;
						long contentLength = content.Length - content.Position;
						Stream body = content;
						byte[] transactionalContentCrc = getHashResult?.StorageCrc64AsArray;
						byte[] transactionalContentMD = getHashResult?.MD5AsArray;
						string leaseId = conditions?.LeaseId;
						long? maxSize = conditions?.IfMaxSizeLessThanOrEqual;
						long? appendPosition = conditions?.IfAppendPositionEqual;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await appendBlobRestClient.AppendBlockAsync(contentLength, body, null, transactionalContentMD, transactionalContentCrc, leaseId, maxSize, appendPosition, encryptionKey, encryptionKeySha, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						AppendBlobRestClient appendBlobRestClient2 = AppendBlobRestClient;
						long contentLength2 = content.Length - content.Position;
						Stream body2 = content;
						byte[] transactionalContentMD = getHashResult?.StorageCrc64AsArray;
						byte[] transactionalContentCrc = getHashResult?.MD5AsArray;
						string ifTags = conditions?.LeaseId;
						long? appendPosition = conditions?.IfMaxSizeLessThanOrEqual;
						long? maxSize = conditions?.IfAppendPositionEqual;
						string ifNoneMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string ifMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string encryptionKeySha = conditions?.IfMatch?.ToString();
						string encryptionKey = conditions?.IfNoneMatch?.ToString();
						string leaseId = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = appendBlobRestClient2.AppendBlock(contentLength2, body2, null, transactionalContentCrc, transactionalContentMD, ifTags, appendPosition, maxSize, ifNoneMatch, ifMatch, encryptionAlgorithm, encryptionScope, ifUnmodifiedSince, ifModifiedSince, encryptionKeySha, encryptionKey, leaseId, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobAppendInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobAppendInfo> AppendBlockFromUri(Uri sourceUri, AppendBlobAppendBlockFromUriOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return AppendBlockFromUriInternal(sourceUri, options?.SourceRange ?? default(HttpRange), options?.SourceContentHash, options?.DestinationConditions, options?.SourceConditions, options?.SourceAuthentication, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobAppendInfo>> AppendBlockFromUriAsync(Uri sourceUri, AppendBlobAppendBlockFromUriOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await AppendBlockFromUriInternal(sourceUri, options?.SourceRange ?? default(HttpRange), options?.SourceContentHash, options?.DestinationConditions, options?.SourceConditions, options?.SourceAuthentication, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobAppendInfo> AppendBlockFromUri(Uri sourceUri, HttpRange sourceRange, byte[] sourceContentHash, AppendBlobRequestConditions conditions, AppendBlobRequestConditions sourceConditions, CancellationToken cancellationToken)
		{
			return AppendBlockFromUriInternal(sourceUri, sourceRange, sourceContentHash, conditions, sourceConditions, null, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobAppendInfo>> AppendBlockFromUriAsync(Uri sourceUri, HttpRange sourceRange, byte[] sourceContentHash, AppendBlobRequestConditions conditions, AppendBlobRequestConditions sourceConditions, CancellationToken cancellationToken)
		{
			return await AppendBlockFromUriInternal(sourceUri, sourceRange, sourceContentHash, conditions, sourceConditions, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobAppendInfo>> AppendBlockFromUriInternal(Uri sourceUri, HttpRange sourceRange, byte[] sourceContentHash, AppendBlobRequestConditions conditions, AppendBlobRequestConditions sourceConditions, HttpAuthorization sourceAuthentication, bool async, CancellationToken cancellationToken = default(CancellationToken))
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("AppendBlobClient", "AppendBlockFromUriInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("AppendBlobClient.AppendBlockFromUri");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "AppendBlockFromUri", "conditions");
				sourceConditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.LeaseId | BlobRequestConditionProperty.TagConditions | BlobRequestConditionProperty.IfAppendPositionEqual | BlobRequestConditionProperty.IfMaxSizeLessThanOrEqual, "AppendBlockFromUri", "sourceConditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<AppendBlobAppendBlockFromUrlHeaders> responseWithHeaders;
					if (async)
					{
						AppendBlobRestClient appendBlobRestClient = AppendBlobRestClient;
						string absoluteUri = sourceUri.AbsoluteUri;
						long contentLength = 0L;
						string sourceRange2 = sourceRange.ToString();
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						string leaseId = conditions?.LeaseId;
						long? maxSize = conditions?.IfMaxSizeLessThanOrEqual;
						long? appendPosition = conditions?.IfAppendPositionEqual;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						DateTimeOffset? sourceIfModifiedSince = sourceConditions?.IfModifiedSince;
						DateTimeOffset? sourceIfUnmodifiedSince = sourceConditions?.IfUnmodifiedSince;
						string sourceIfMatch = sourceConditions?.IfMatch?.ToString();
						string sourceIfNoneMatch = sourceConditions?.IfNoneMatch?.ToString();
						string copySourceAuthorization = sourceAuthentication?.ToString();
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await appendBlobRestClient.AppendBlockFromUrlAsync(absoluteUri, contentLength, sourceRange2, sourceContentHash, null, null, null, encryptionKey, encryptionKeySha, encryptionAlgorithm, encryptionScope, leaseId, maxSize, appendPosition, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, copySourceAuthorization, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						AppendBlobRestClient appendBlobRestClient2 = AppendBlobRestClient;
						string absoluteUri2 = sourceUri.AbsoluteUri;
						long contentLength2 = 0L;
						string sourceRange3 = sourceRange.ToString();
						string copySourceAuthorization = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string sourceIfNoneMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string sourceIfMatch = ClientConfiguration.EncryptionScope;
						string ifTags = conditions?.LeaseId;
						long? appendPosition = conditions?.IfMaxSizeLessThanOrEqual;
						long? maxSize = conditions?.IfAppendPositionEqual;
						DateTimeOffset? sourceIfUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? sourceIfModifiedSince = conditions?.IfUnmodifiedSince;
						string ifNoneMatch = conditions?.IfMatch?.ToString();
						string ifMatch = conditions?.IfNoneMatch?.ToString();
						string leaseId = conditions?.TagConditions;
						DateTimeOffset? ifUnmodifiedSince = sourceConditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = sourceConditions?.IfUnmodifiedSince;
						string encryptionScope = sourceConditions?.IfMatch?.ToString();
						string encryptionKeySha = sourceConditions?.IfNoneMatch?.ToString();
						string encryptionKey = sourceAuthentication?.ToString();
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = appendBlobRestClient2.AppendBlockFromUrl(absoluteUri2, contentLength2, sourceRange3, sourceContentHash, null, null, null, copySourceAuthorization, sourceIfNoneMatch, encryptionAlgorithm, sourceIfMatch, ifTags, appendPosition, maxSize, sourceIfUnmodifiedSince, sourceIfModifiedSince, ifNoneMatch, ifMatch, leaseId, ifUnmodifiedSince, ifModifiedSince, encryptionScope, encryptionKeySha, encryptionKey, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobAppendInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobInfo> Seal(AppendBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SealInternal(conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobInfo>> SealAsync(AppendBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await SealInternal(conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobInfo>> SealInternal(AppendBlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("AppendBlobClient", "SealInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("AppendBlobClient.Seal");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.TagConditions | BlobRequestConditionProperty.IfMaxSizeLessThanOrEqual, "Seal", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<AppendBlobSealHeaders> responseWithHeaders;
					if (async)
					{
						AppendBlobRestClient appendBlobRestClient = AppendBlobRestClient;
						string leaseId = conditions?.LeaseId;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						long? appendPosition = conditions?.IfAppendPositionEqual;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await appendBlobRestClient.SealAsync(null, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, appendPosition, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						AppendBlobRestClient appendBlobRestClient2 = AppendBlobRestClient;
						string ifNoneMatch = conditions?.LeaseId;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string leaseId = conditions?.IfNoneMatch?.ToString();
						long? appendPosition = conditions?.IfAppendPositionEqual;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = appendBlobRestClient2.Seal(null, ifNoneMatch, ifUnmodifiedSince, ifModifiedSince, ifMatch, leaseId, appendPosition, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Stream OpenWrite(bool overwrite, AppendBlobOpenWriteOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return OpenWriteInternal(overwrite, options, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Stream> OpenWriteAsync(bool overwrite, AppendBlobOpenWriteOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await OpenWriteInternal(overwrite, options, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Stream> OpenWriteInternal(bool overwrite, AppendBlobOpenWriteOptions options, bool async, CancellationToken cancellationToken)
		{
			Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("AppendBlobClient.OpenWrite");
			try
			{
				scope.Start();
				long position;
				ETag? etag;
				if (overwrite)
				{
					Response<BlobContentInfo> response = await CreateInternal(null, null, null, options?.OpenConditions, null, null, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					position = 0L;
					etag = response.Value.ETag;
				}
				else
				{
					try
					{
						Response<BlobProperties> response2 = await GetPropertiesInternal(options?.OpenConditions, async, new RequestContext
						{
							CancellationToken = cancellationToken
						}).ConfigureAwait(continueOnCapturedContext: false);
						position = response2.Value.ContentLength;
						etag = response2.Value.ETag;
					}
					catch (RequestFailedException ex) when (ex.ErrorCode == BlobErrorCode.BlobNotFound)
					{
						Response<BlobContentInfo> response3 = await CreateInternal(null, null, null, options?.OpenConditions, null, null, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						position = 0L;
						etag = response3.Value.ETag;
					}
				}
				AppendBlobRequestConditions conditions = new AppendBlobRequestConditions
				{
					IfMatch = etag,
					LeaseId = options?.OpenConditions?.LeaseId
				};
				return new AppendBlobWriteStream(this, options?.BufferSize ?? 4194304, position, conditions, options?.ProgressHandler, options?.TransferValidation ?? ClientConfiguration.TransferValidation.Upload);
			}
			catch (Exception exception)
			{
				scope.Failed(exception);
				throw;
			}
			finally
			{
				scope.Dispose();
			}
		}
	}
	public static class SpecializedBlobExtensions
	{
		public static AppendBlobClient GetAppendBlobClient(this BlobContainerClient client, string blobName)
		{
			return client.GetAppendBlobClientCore(blobName);
		}

		public static BlobContainerClient GetParentBlobContainerClient(this BlobBaseClient client)
		{
			return client.GetParentBlobContainerClientCore();
		}

		public static BlobBaseClient GetBlobBaseClient(this BlobContainerClient client, string blobName)
		{
			return client.GetBlobBaseClientCore(blobName);
		}

		public static BlobClient WithClientSideEncryptionOptions(this BlobClient client, ClientSideEncryptionOptions clientSideEncryptionOptions)
		{
			return client.WithClientSideEncryptionOptionsCore(clientSideEncryptionOptions);
		}

		public static BlobServiceClient GetParentBlobServiceClient(this BlobContainerClient client)
		{
			return client.GetParentBlobServiceClientCore();
		}

		public static BlobLeaseClient GetBlobLeaseClient(this BlobBaseClient client, string leaseId = null)
		{
			return client.GetBlobLeaseClientCore(leaseId);
		}

		public static BlobLeaseClient GetBlobLeaseClient(this BlobContainerClient client, string leaseId = null)
		{
			return client.GetBlobLeaseClientCore(leaseId);
		}

		public static BlockBlobClient GetBlockBlobClient(this BlobContainerClient client, string blobName)
		{
			return client.GetBlockBlobClientCore(blobName);
		}

		public static PageBlobClient GetPageBlobClient(this BlobContainerClient client, string blobName)
		{
			return client.GetPageBlobClientCore(blobName);
		}

		public static void UpdateClientSideKeyEncryptionKey(this BlobClient client, ClientSideEncryptionOptions encryptionOptionsOverride = null, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			UpdateClientsideKeyEncryptionKeyInternal(client, encryptionOptionsOverride, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public static async Task UpdateClientSideKeyEncryptionKeyAsync(this BlobClient client, ClientSideEncryptionOptions encryptionOptionsOverride = null, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			await UpdateClientsideKeyEncryptionKeyInternal(client, encryptionOptionsOverride, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private static async Task UpdateClientsideKeyEncryptionKeyInternal(BlobClient client, ClientSideEncryptionOptions encryptionOptionsOverride, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			Azure.Core.Argument.AssertNotNull(client, "client");
			ClientSideEncryptionOptions operationEncryptionOptions = encryptionOptionsOverride ?? client.ClientSideEncryption ?? throw new ArgumentException("ClientSideEncryptionOptions are not configured on this client and none were provided for the operation.");
			Azure.Core.Argument.AssertNotNull(operationEncryptionOptions.KeyEncryptionKey, "KeyEncryptionKey");
			Azure.Core.Argument.AssertNotNull(operationEncryptionOptions.KeyResolver, "KeyResolver");
			Azure.Core.Argument.AssertNotNull(operationEncryptionOptions.KeyWrapAlgorithm, "KeyWrapAlgorithm");
			using (client.ClientConfiguration.Pipeline.BeginLoggingScope("BlobClient", "UpdateClientsideKeyEncryptionKeyInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = client.ClientConfiguration.ClientDiagnostics.CreateScope("BlobClient.UpdateClientSideKeyEncryptionKey");
				try
				{
					BlobProperties blobProperties = await client.GetPropertiesInternal(conditions, async, new RequestContext
					{
						CancellationToken = cancellationToken
					}).ConfigureAwait(continueOnCapturedContext: false);
					ETag etag = blobProperties.ETag;
					IDictionary<string, string> metadata = blobProperties.Metadata;
					EncryptionData encryptionData = BlobClientSideDecryptor.GetAndValidateEncryptionDataOrDefault(metadata) ?? throw new InvalidOperationException("Resource has no client-side encryption key to rotate.");
					byte[] encryptedKey = await WrapKeyInternal(await UnwrapKeyInternal(encryptionData, operationEncryptionOptions.KeyResolver, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false), operationEncryptionOptions.KeyWrapAlgorithm, operationEncryptionOptions.KeyEncryptionKey, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					encryptionData.WrappedContentKey = new KeyEnvelope
					{
						EncryptedKey = encryptedKey,
						Algorithm = operationEncryptionOptions.KeyWrapAlgorithm,
						KeyId = operationEncryptionOptions.KeyEncryptionKey.KeyId
					};
					metadata["encryptiondata"] = EncryptionDataSerializer.Serialize(encryptionData);
					BlobRequestConditions blobRequestConditions = BlobRequestConditions.CloneOrDefault(conditions) ?? new BlobRequestConditions();
					blobRequestConditions.IfMatch = etag;
					await client.SetMetadataInternal(metadata, blobRequestConditions, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		private static async Task<byte[]> UnwrapKeyInternal(EncryptionData encryptionData, IKeyEncryptionKeyResolver keyResolver, bool async, CancellationToken cancellationToken)
		{
			IKeyEncryptionKey keyEncryptionKey = ((!async) ? keyResolver.Resolve(encryptionData.WrappedContentKey.KeyId, cancellationToken) : (await keyResolver.ResolveAsync(encryptionData.WrappedContentKey.KeyId, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
			IKeyEncryptionKey keyEncryptionKey2 = keyEncryptionKey;
			if (keyEncryptionKey2 == null)
			{
				throw Azure.Storage.Errors.ClientSideEncryption.KeyNotFound(encryptionData.WrappedContentKey.KeyId);
			}
			return (!async) ? keyEncryptionKey2.UnwrapKey(encryptionData.WrappedContentKey.Algorithm, encryptionData.WrappedContentKey.EncryptedKey, cancellationToken) : (await keyEncryptionKey2.UnwrapKeyAsync(encryptionData.WrappedContentKey.Algorithm, encryptionData.WrappedContentKey.EncryptedKey, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}

		private static async Task<byte[]> WrapKeyInternal(ReadOnlyMemory<byte> contentEncryptionKey, string keyWrapAlgorithm, IKeyEncryptionKey key, bool async, CancellationToken cancellationToken)
		{
			return (!async) ? key.UnwrapKey(keyWrapAlgorithm, contentEncryptionKey, cancellationToken) : (await key.WrapKeyAsync(keyWrapAlgorithm, contentEncryptionKey, cancellationToken).ConfigureAwait(continueOnCapturedContext: false));
		}
	}
	public class BlobBaseClient
	{
		private protected readonly Uri _uri;

		internal readonly BlobClientConfiguration _clientConfiguration;

		private readonly ClientSideEncryptionOptions _clientSideEncryption;

		private string _snapshot;

		private string _blobVersionId;

		private string _accountName;

		private string _containerName;

		private string _name;

		private readonly BlobRestClient _blobRestClient;

		private BlobContainerClient _parentBlobContainerClient;

		public virtual Uri Uri => _uri;

		internal virtual BlobClientConfiguration ClientConfiguration => _clientConfiguration;

		internal virtual ClientSideEncryptionOptions ClientSideEncryption => _clientSideEncryption;

		internal virtual bool UsingClientSideEncryption => ClientSideEncryption != null;

		public virtual string AccountName
		{
			get
			{
				SetNameFieldsIfNull();
				return _accountName;
			}
		}

		public virtual string BlobContainerName
		{
			get
			{
				SetNameFieldsIfNull();
				return _containerName;
			}
		}

		public virtual string Name
		{
			get
			{
				SetNameFieldsIfNull();
				return _name;
			}
		}

		public virtual bool CanGenerateSasUri => ClientConfiguration.SharedKeyCredential != null;

		internal virtual BlobRestClient BlobRestClient => _blobRestClient;

		protected BlobBaseClient()
		{
		}

		public BlobBaseClient(string connectionString, string blobContainerName, string blobName)
			: this(connectionString, blobContainerName, blobName, null)
		{
		}

		public BlobBaseClient(string connectionString, string blobContainerName, string blobName, BlobClientOptions options)
		{
			if (options == null)
			{
				options = new BlobClientOptions();
			}
			Azure.Storage.StorageConnectionString storageConnectionString = Azure.Storage.StorageConnectionString.Parse(connectionString);
			BlobUriBuilder blobUriBuilder = new BlobUriBuilder(storageConnectionString.BlobEndpoint)
			{
				BlobContainerName = blobContainerName,
				BlobName = blobName
			};
			_uri = blobUriBuilder.ToUri();
			_clientConfiguration = new BlobClientConfiguration(options.Build(storageConnectionString.Credentials), storageConnectionString.Credentials as StorageSharedKeyCredential, new Azure.Core.Pipeline.ClientDiagnostics(options), options.Version, options.CustomerProvidedKey, options.TransferValidation, options.EncryptionScope, options.TrimBlobNameSlashes);
			_clientSideEncryption = options._clientSideEncryptionOptions?.Clone();
			_blobRestClient = BuildBlobRestClient(_uri);
			BlobErrors.VerifyHttpsCustomerProvidedKey(_uri, _clientConfiguration.CustomerProvidedKey);
			BlobErrors.VerifyCpkAndEncryptionScopeNotBothSet(_clientConfiguration.CustomerProvidedKey, _clientConfiguration.EncryptionScope);
		}

		public BlobBaseClient(Uri blobUri, BlobClientOptions options = null)
			: this(blobUri, null, options, null, null, null)
		{
		}

		public BlobBaseClient(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options = null)
			: this(blobUri, credential.AsPolicy(), options, credential, null, null)
		{
		}

		public BlobBaseClient(Uri blobUri, AzureSasCredential credential, BlobClientOptions options = null)
			: this(blobUri, credential.AsPolicy<BlobUriBuilder>(blobUri), options, null, credential, null)
		{
		}

		public BlobBaseClient(Uri blobUri, TokenCredential credential, BlobClientOptions options = null)
			: this(blobUri, credential.AsPolicy(string.IsNullOrEmpty(options?.Audience?.ToString()) ? BlobAudience.DefaultAudience.CreateDefaultScope() : options.Audience.Value.CreateDefaultScope(), options), options, null, null, credential)
		{
			Azure.Storage.Errors.VerifyHttpsTokenAuth(blobUri);
		}

		internal BlobBaseClient(Uri blobUri, HttpPipelinePolicy authentication, BlobClientOptions options, StorageSharedKeyCredential storageSharedKeyCredential, AzureSasCredential sasCredential, TokenCredential tokenCredential)
		{
			Azure.Core.Argument.AssertNotNull(blobUri, "blobUri");
			if (options == null)
			{
				options = new BlobClientOptions();
			}
			_uri = blobUri;
			if (!string.IsNullOrEmpty(blobUri.Query))
			{
				Azure.Storage.UriQueryParamsCollection uriQueryParamsCollection = new Azure.Storage.UriQueryParamsCollection(blobUri.Query);
				if (uriQueryParamsCollection.ContainsKey("snapshot"))
				{
					_snapshot = HttpUtility.ParseQueryString(blobUri.Query).Get("snapshot");
				}
				if (uriQueryParamsCollection.ContainsKey("versionid"))
				{
					_blobVersionId = HttpUtility.ParseQueryString(blobUri.Query).Get("versionid");
				}
			}
			_clientConfiguration = new BlobClientConfiguration(options.Build(authentication), storageSharedKeyCredential, tokenCredential, sasCredential, new Azure.Core.Pipeline.ClientDiagnostics(options), options.Version, options.CustomerProvidedKey, options.TransferValidation, options.EncryptionScope, options.TrimBlobNameSlashes);
			_clientSideEncryption = options._clientSideEncryptionOptions?.Clone();
			_blobRestClient = BuildBlobRestClient(blobUri);
			BlobErrors.VerifyHttpsCustomerProvidedKey(_uri, _clientConfiguration.CustomerProvidedKey);
			BlobErrors.VerifyCpkAndEncryptionScopeNotBothSet(_clientConfiguration.CustomerProvidedKey, _clientConfiguration.EncryptionScope);
		}

		internal BlobBaseClient(Uri blobUri, BlobClientConfiguration clientConfiguration, ClientSideEncryptionOptions clientSideEncryption)
		{
			_uri = blobUri;
			if (!string.IsNullOrEmpty(blobUri.Query))
			{
				Azure.Storage.UriQueryParamsCollection uriQueryParamsCollection = new Azure.Storage.UriQueryParamsCollection(blobUri.Query);
				if (uriQueryParamsCollection.ContainsKey("snapshot"))
				{
					_snapshot = HttpUtility.ParseQueryString(blobUri.Query).Get("snapshot");
				}
				if (uriQueryParamsCollection.ContainsKey("versionid"))
				{
					_blobVersionId = HttpUtility.ParseQueryString(blobUri.Query).Get("versionid");
				}
			}
			_clientConfiguration = clientConfiguration;
			_clientSideEncryption = clientSideEncryption?.Clone();
			_blobRestClient = BuildBlobRestClient(blobUri);
			BlobErrors.VerifyHttpsCustomerProvidedKey(_uri, _clientConfiguration.CustomerProvidedKey);
			BlobErrors.VerifyCpkAndEncryptionScopeNotBothSet(_clientConfiguration.CustomerProvidedKey, _clientConfiguration.EncryptionScope);
		}

		private BlobRestClient BuildBlobRestClient(Uri blobUri)
		{
			return new BlobRestClient(_clientConfiguration.ClientDiagnostics, _clientConfiguration.Pipeline, blobUri.AbsoluteUri, _clientConfiguration.Version.ToVersionString());
		}

		public virtual BlobBaseClient WithSnapshot(string snapshot)
		{
			return WithSnapshotCore(snapshot);
		}

		protected virtual BlobBaseClient WithSnapshotCore(string snapshot)
		{
			_snapshot = snapshot;
			return new BlobBaseClient(new BlobUriBuilder(Uri)
			{
				Snapshot = snapshot
			}.ToUri(), ClientConfiguration, ClientSideEncryption);
		}

		public virtual BlobBaseClient WithVersion(string versionId)
		{
			return WithVersionCore(versionId);
		}

		private protected virtual BlobBaseClient WithVersionCore(string versionId)
		{
			_blobVersionId = versionId;
			return new BlobBaseClient(new BlobUriBuilder(Uri)
			{
				VersionId = versionId
			}.ToUri(), ClientConfiguration, ClientSideEncryption);
		}

		public virtual BlobBaseClient WithCustomerProvidedKey(CustomerProvidedKey? customerProvidedKey)
		{
			return WithCustomerProvidedKeyCore(customerProvidedKey);
		}

		private protected virtual BlobBaseClient WithCustomerProvidedKeyCore(CustomerProvidedKey? customerProvidedKey)
		{
			BlobClientConfiguration blobClientConfiguration = BlobClientConfiguration.DeepCopy(ClientConfiguration);
			blobClientConfiguration.CustomerProvidedKey = customerProvidedKey;
			return new BlobBaseClient(Uri, blobClientConfiguration, ClientSideEncryption?.Clone());
		}

		public virtual BlobBaseClient WithEncryptionScope(string encryptionScope)
		{
			return WithEncryptionScopeCore(encryptionScope);
		}

		private protected virtual BlobBaseClient WithEncryptionScopeCore(string encryptionScope)
		{
			BlobClientConfiguration blobClientConfiguration = BlobClientConfiguration.DeepCopy(ClientConfiguration);
			blobClientConfiguration.EncryptionScope = encryptionScope;
			return new BlobBaseClient(Uri, blobClientConfiguration, ClientSideEncryption?.Clone());
		}

		protected internal virtual BlobLeaseClient GetBlobLeaseClientCore(string leaseId)
		{
			return new BlobLeaseClient(this, leaseId);
		}

		private void SetNameFieldsIfNull()
		{
			if (_name == null || _containerName == null || _accountName == null)
			{
				BlobUriBuilder blobUriBuilder = new BlobUriBuilder(Uri, ClientConfiguration.TrimBlobNameSlashes);
				_name = blobUriBuilder.BlobName;
				_containerName = blobUriBuilder.BlobContainerName;
				_accountName = blobUriBuilder.AccountName;
			}
		}

		protected static async Task<HttpAuthorization> GetCopyAuthorizationHeaderAsync(BlobBaseClient client, CancellationToken cancellationToken = default(CancellationToken))
		{
			if (client.ClientConfiguration.TokenCredential != null)
			{
				return await client.ClientConfiguration.TokenCredential.GetCopyAuthorizationHeaderAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			return null;
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobDownloadInfo> Download()
		{
			return Download(CancellationToken.None);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobDownloadInfo>> DownloadAsync()
		{
			return await DownloadAsync(CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobDownloadInfo> Download(CancellationToken cancellationToken = default(CancellationToken))
		{
			return Download(default(HttpRange), null, rangeGetContentHash: false, cancellationToken);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobDownloadInfo>> DownloadAsync(CancellationToken cancellationToken)
		{
			return await DownloadAsync(default(HttpRange), null, rangeGetContentHash: false, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobDownloadInfo> Download(HttpRange range = default(HttpRange), BlobRequestConditions conditions = null, bool rangeGetContentHash = false, CancellationToken cancellationToken = default(CancellationToken))
		{
			return DownloadInternal(range, conditions, rangeGetContentHash, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobDownloadInfo>> DownloadAsync(HttpRange range = default(HttpRange), BlobRequestConditions conditions = null, bool rangeGetContentHash = false, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await DownloadInternal(range, conditions, rangeGetContentHash, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobDownloadInfo>> DownloadInternal(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, bool async, CancellationToken cancellationToken)
		{
			Response<BlobDownloadStreamingResult> response = await DownloadStreamingDirect(range, conditions, rangeGetContentHash.ToValidationOptions(), null, "BlobBaseClient.Download", async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (response.IsUnavailable())
			{
				return response.GetRawResponse().AsNoBodyResponse<BlobDownloadInfo>();
			}
			BlobDownloadStreamingResult value = response.Value;
			BlobDownloadDetails details = value.Details;
			return Response.FromValue(new BlobDownloadInfo
			{
				Content = value.Content,
				Details = details,
				BlobType = details.BlobType,
				ContentHash = details.ContentHash,
				ContentLength = details.ContentLength,
				ContentType = details.ContentType
			}, response.GetRawResponse());
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobDownloadStreamingResult> DownloadStreaming(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, CancellationToken cancellationToken)
		{
			return DownloadStreaming(range, conditions, rangeGetContentHash, null, cancellationToken);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobDownloadStreamingResult>> DownloadStreamingAsync(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, CancellationToken cancellationToken)
		{
			return await DownloadStreamingAsync(range, conditions, rangeGetContentHash, null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobDownloadStreamingResult> DownloadStreaming(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, IProgress<long> progressHandler, CancellationToken cancellationToken)
		{
			return DownloadStreamingDirect(range, conditions, rangeGetContentHash.ToValidationOptions(), progressHandler, "BlobBaseClient.DownloadStreaming", async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobDownloadStreamingResult>> DownloadStreamingAsync(HttpRange range, BlobRequestConditions conditions, bool rangeGetContentHash, IProgress<long> progressHandler, CancellationToken cancellationToken)
		{
			return await DownloadStreamingDirect(range, conditions, rangeGetContentHash.ToValidationOptions(), progressHandler, "BlobBaseClient.DownloadStreaming", async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<BlobDownloadStreamingResult> DownloadStreaming(BlobDownloadOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return DownloadStreamingDirect(options?.Range ?? default(HttpRange), options?.Conditions, options?.TransferValidation, options?.ProgressHandler, "BlobBaseClient.DownloadStreaming", async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobDownloadStreamingResult>> DownloadStreamingAsync(BlobDownloadOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await DownloadStreamingDirect(options?.Range ?? default(HttpRange), options?.Conditions, options?.TransferValidation, options?.ProgressHandler, "BlobBaseClient.DownloadStreaming", async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async ValueTask<Response<BlobDownloadStreamingResult>> DownloadStreamingDirect(HttpRange range, BlobRequestConditions conditions, DownloadTransferValidationOptions transferValidationOverride, IProgress<long> progressHandler, string operationName, bool async, CancellationToken cancellationToken)
		{
			HttpRange requestedRange = range;
			if (UsingClientSideEncryption && (await GetPropertiesInternal(conditions, async, new RequestContext
			{
				CancellationToken = cancellationToken
			}).ConfigureAwait(continueOnCapturedContext: false)).Value.Metadata.TryGetValue("encryptiondata", out var value))
			{
				range = BlobClientSideDecryptor.GetEncryptedBlobRange(range, value);
			}
			Response<BlobDownloadStreamingResult> response = await DownloadStreamingInternal(range, conditions, transferValidationOverride, progressHandler, operationName, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (UsingClientSideEncryption)
			{
				BlobDownloadStreamingResult value2 = response.Value;
				value2.Content = await new BlobClientSideDecryptor(new ClientSideDecryptor(ClientSideEncryption)).DecryptInternal(response.Value.Content, response.Value.Details.Metadata, requestedRange, response.Value.Details.ContentRange, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			}
			return response;
		}

		internal virtual async ValueTask<Response<BlobDownloadStreamingResult>> DownloadStreamingInternal(HttpRange range, BlobRequestConditions conditions, DownloadTransferValidationOptions transferValidationOverride, IProgress<long> progressHandler, string operationName, bool async, CancellationToken cancellationToken)
		{
			DownloadTransferValidationOptions validationOptions = transferValidationOverride ?? ClientConfiguration.TransferValidation.Download;
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "DownloadStreamingInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope(operationName);
				try
				{
					scope.Start();
					using DisposableBucket disposableBucket = new DisposableBucket();
					if (ClientSideEncryption != null)
					{
						disposableBucket.Add(Azure.Storage.Shared.StorageExtensions.CreateClientSideEncryptionScope(ClientSideEncryption.EncryptionVersion));
					}
					Response<BlobDownloadStreamingResult> response = await StartDownloadAsync(range, conditions, validationOptions, 0L, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					if (response.IsUnavailable())
					{
						return response.GetRawResponse().AsNoBodyResponse<BlobDownloadStreamingResult>();
					}
					ETag eTag = response.Value.Details.ETag;
					BlobRequestConditions conditionsWithEtag = conditions?.WithIfMatch(eTag) ?? new BlobRequestConditions
					{
						IfMatch = eTag
					};
					Stream stream = RetriableStream.Create(response.Value.Content, (long startOffset) => StartDownloadAsync(range, conditionsWithEtag, validationOptions, startOffset, async, cancellationToken).EnsureCompleted().Value.Content, async (long startOffset) => (await StartDownloadAsync(range, conditionsWithEtag, validationOptions, startOffset, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Value.Content, ClientConfiguration.Pipeline.ResponseClassifier, 5);
					stream = stream.WithNoDispose().WithProgress(progressHandler);
					if (validationOptions != null && validationOptions.ChecksumAlgorithm != StorageChecksumAlgorithm.None && validationOptions.AutoValidateChecksum)
					{
						MemoryStream readDestStream = new MemoryStream((int)response.Value.Details.ContentLength);
						if (async)
						{
							await stream.CopyToAsync(readDestStream, 81920, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						}
						else
						{
							stream.CopyTo(readDestStream);
						}
						readDestStream.Position = 0L;
						await ContentHasher.AssertResponseHashMatchInternal(readDestStream, validationOptions.ChecksumAlgorithm, response.GetRawResponse(), async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
						stream = readDestStream;
					}
					response.Value.Content = stream;
					return response;
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		private async ValueTask<Response<BlobDownloadStreamingResult>> StartDownloadAsync(HttpRange range, BlobRequestConditions conditions, DownloadTransferValidationOptions validationOptions, long startOffset = 0L, bool async = true, CancellationToken cancellationToken = default(CancellationToken))
		{
			HttpRange? httpRange = null;
			if (range != default(HttpRange))
			{
				httpRange = new HttpRange(range.Offset + startOffset, range.Length.HasValue ? new long?(range.Length.Value - startOffset) : ((long?)null));
			}
			else if (startOffset != 0L)
			{
				httpRange = new HttpRange(startOffset);
			}
			conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "Download", "conditions");
			Azure.Core.ResponseWithHeaders<Stream, BlobDownloadHeaders> responseWithHeaders;
			if (async)
			{
				BlobRestClient blobRestClient = BlobRestClient;
				string range2 = httpRange?.ToString();
				string leaseId = conditions?.LeaseId;
				bool? rangeGetContentMD = ((validationOptions != null && validationOptions.ChecksumAlgorithm.ResolveAuto() == StorageChecksumAlgorithm.MD5) ? new bool?(true) : ((bool?)null));
				bool? rangeGetContentCRC = ((validationOptions != null && validationOptions.ChecksumAlgorithm.ResolveAuto() == StorageChecksumAlgorithm.StorageCrc64) ? new bool?(true) : ((bool?)null));
				string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
				string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
				CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
				int num;
				if (!customerProvidedKey.HasValue)
				{
					num = 1;
				}
				else
				{
					_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
					num = 0;
				}
				EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
				DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
				DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
				string ifMatch = conditions?.IfMatch?.ToString();
				string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
				string ifTags = conditions?.TagConditions;
				CancellationToken cancellationToken2 = cancellationToken;
				responseWithHeaders = await blobRestClient.DownloadAsync(null, null, null, range2, leaseId, rangeGetContentMD, rangeGetContentCRC, encryptionKey, encryptionKeySha, encryptionAlgorithm, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
			}
			else
			{
				BlobRestClient blobRestClient2 = BlobRestClient;
				string ifTags = httpRange?.ToString();
				string ifNoneMatch = conditions?.LeaseId;
				bool? rangeGetContentCRC = ((validationOptions != null && validationOptions.ChecksumAlgorithm.ResolveAuto() == StorageChecksumAlgorithm.MD5) ? new bool?(true) : ((bool?)null));
				bool? rangeGetContentMD = ((validationOptions != null && validationOptions.ChecksumAlgorithm.ResolveAuto() == StorageChecksumAlgorithm.StorageCrc64) ? new bool?(true) : ((bool?)null));
				string ifMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
				string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
				CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
				int num2;
				if (!customerProvidedKey.HasValue)
				{
					num2 = 1;
				}
				else
				{
					_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
					num2 = 0;
				}
				EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
				DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
				DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
				string encryptionKey = conditions?.IfMatch?.ToString();
				string leaseId = conditions?.IfNoneMatch?.ToString();
				string range2 = conditions?.TagConditions;
				CancellationToken cancellationToken2 = cancellationToken;
				responseWithHeaders = blobRestClient2.Download(null, null, null, ifTags, ifNoneMatch, rangeGetContentCRC, rangeGetContentMD, ifMatch, encryptionKeySha, encryptionAlgorithm, ifUnmodifiedSince, ifModifiedSince, encryptionKey, leaseId, range2, cancellationToken2);
			}
			if (!responseWithHeaders.IsUnavailable())
			{
				responseWithHeaders.Headers.ContentLength.GetValueOrDefault();
			}
			return Response.FromValue(responseWithHeaders.ToBlobDownloadStreamingResult(), responseWithHeaders.GetRawResponse());
		}

		public virtual Response<BlobDownloadResult> DownloadContent()
		{
			return DownloadContent(CancellationToken.None);
		}

		public virtual async Task<Response<BlobDownloadResult>> DownloadContentAsync()
		{
			return await DownloadContentAsync(CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<BlobDownloadResult> DownloadContent(CancellationToken cancellationToken = default(CancellationToken))
		{
			return DownloadContent((BlobRequestConditions)null, cancellationToken);
		}

		public virtual async Task<Response<BlobDownloadResult>> DownloadContentAsync(CancellationToken cancellationToken)
		{
			return await DownloadContentAsync((BlobRequestConditions)null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobDownloadResult> DownloadContent(BlobRequestConditions conditions, CancellationToken cancellationToken)
		{
			return DownloadContentInternal(conditions, null, default(HttpRange), null, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobDownloadResult>> DownloadContentAsync(BlobRequestConditions conditions, CancellationToken cancellationToken)
		{
			return await DownloadContentInternal(conditions, null, default(HttpRange), null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobDownloadResult> DownloadContent(BlobRequestConditions conditions, IProgress<long> progressHandler, HttpRange range, CancellationToken cancellationToken)
		{
			return DownloadContentInternal(conditions, progressHandler, range, null, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobDownloadResult>> DownloadContentAsync(BlobRequestConditions conditions, IProgress<long> progressHandler, HttpRange range, CancellationToken cancellationToken)
		{
			return await DownloadContentInternal(conditions, progressHandler, range, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<BlobDownloadResult> DownloadContent(BlobDownloadOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return DownloadContentInternal(options?.Conditions, options?.ProgressHandler, options?.Range ?? default(HttpRange), options?.TransferValidation, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobDownloadResult>> DownloadContentAsync(BlobDownloadOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await DownloadContentInternal(options?.Conditions, options?.ProgressHandler, options?.Range ?? default(HttpRange), options?.TransferValidation, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobDownloadResult>> DownloadContentInternal(BlobRequestConditions conditions, IProgress<long> progressHandler, HttpRange range, DownloadTransferValidationOptions transferValidationOverride, bool async, CancellationToken cancellationToken)
		{
			Response<BlobDownloadStreamingResult> response = await DownloadStreamingDirect(range, conditions, transferValidationOverride, progressHandler, "BlobBaseClient.DownloadContent", async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			if (response.IsUnavailable())
			{
				return response.GetRawResponse().AsNoBodyResponse<BlobDownloadResult>();
			}
			using BlobDownloadStreamingResult blobDownloadStreamingResult = response.Value;
			BinaryData content = ((!async) ? BinaryData.FromStream(blobDownloadStreamingResult.Content) : (await BinaryData.FromStreamAsync(blobDownloadStreamingResult.Content, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
			return Response.FromValue(new BlobDownloadResult
			{
				Content = content,
				Details = blobDownloadStreamingResult.Details
			}, response.GetRawResponse());
		}

		public virtual Response DownloadTo(Stream destination)
		{
			return DownloadTo(destination, CancellationToken.None);
		}

		public virtual Response DownloadTo(string path)
		{
			return DownloadTo(path, CancellationToken.None);
		}

		public virtual async Task<Response> DownloadToAsync(Stream destination)
		{
			return await DownloadToAsync(destination, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual async Task<Response> DownloadToAsync(string path)
		{
			return await DownloadToAsync(path, CancellationToken.None).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response DownloadTo(Stream destination, CancellationToken cancellationToken)
		{
			return DownloadTo(destination, null, default(StorageTransferOptions), cancellationToken);
		}

		public virtual Response DownloadTo(string path, CancellationToken cancellationToken)
		{
			return DownloadTo(path, null, default(StorageTransferOptions), cancellationToken);
		}

		public virtual async Task<Response> DownloadToAsync(Stream destination, CancellationToken cancellationToken)
		{
			return await DownloadToAsync(destination, null, default(StorageTransferOptions), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual async Task<Response> DownloadToAsync(string path, CancellationToken cancellationToken)
		{
			return await DownloadToAsync(path, null, default(StorageTransferOptions), cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response DownloadTo(Stream destination, BlobDownloadToOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return StagedDownloadAsync(destination, options?.Conditions, options?.ProgressHandler, options?.TransferOptions ?? default(StorageTransferOptions), options?.TransferValidation, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual Response DownloadTo(string path, BlobDownloadToOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			using Stream destination = File.Create(path);
			return StagedDownloadAsync(destination, options?.Conditions, options?.ProgressHandler, options?.TransferOptions ?? default(StorageTransferOptions), options?.TransferValidation, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response> DownloadToAsync(Stream destination, BlobDownloadToOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await StagedDownloadAsync(destination, options?.Conditions, options?.ProgressHandler, options?.TransferOptions ?? default(StorageTransferOptions), options?.TransferValidation, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual async Task<Response> DownloadToAsync(string path, BlobDownloadToOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			using Stream destination = File.Create(path);
			return await StagedDownloadAsync(destination, options?.Conditions, options?.ProgressHandler, options?.TransferOptions ?? default(StorageTransferOptions), options?.TransferValidation, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response DownloadTo(Stream destination, BlobRequestConditions conditions = null, StorageTransferOptions transferOptions = default(StorageTransferOptions), CancellationToken cancellationToken = default(CancellationToken))
		{
			return StagedDownloadAsync(destination, conditions, null, transferOptions, null, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response DownloadTo(string path, BlobRequestConditions conditions = null, StorageTransferOptions transferOptions = default(StorageTransferOptions), CancellationToken cancellationToken = default(CancellationToken))
		{
			using Stream destination = File.Create(path);
			return StagedDownloadAsync(destination, conditions, null, transferOptions, null, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response> DownloadToAsync(Stream destination, BlobRequestConditions conditions = null, StorageTransferOptions transferOptions = default(StorageTransferOptions), CancellationToken cancellationToken = default(CancellationToken))
		{
			return await StagedDownloadAsync(destination, conditions, null, transferOptions, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response> DownloadToAsync(string path, BlobRequestConditions conditions = null, StorageTransferOptions transferOptions = default(StorageTransferOptions), CancellationToken cancellationToken = default(CancellationToken))
		{
			using Stream destination = File.Create(path);
			return await StagedDownloadAsync(destination, conditions, null, transferOptions, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal async Task<Response> StagedDownloadAsync(Stream destination, BlobRequestConditions conditions = null, IProgress<long> progressHandler = null, StorageTransferOptions transferOptions = default(StorageTransferOptions), DownloadTransferValidationOptions transferValidationOverride = null, bool async = true, CancellationToken cancellationToken = default(CancellationToken))
		{
			DownloadTransferValidationOptions transferValidation = transferValidationOverride ?? ClientConfiguration.TransferValidation.Download;
			PartitionedDownloader partitionedDownloader = new PartitionedDownloader(this, transferOptions, transferValidation, progressHandler);
			if (UsingClientSideEncryption)
			{
				ClientSideDecryptor.BeginContentEncryptionKeyCaching();
			}
			return await partitionedDownloader.DownloadToInternal(destination, conditions, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Stream OpenRead(BlobOpenReadOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return OpenReadInternal(options?.Position ?? 0, options?.BufferSize, options?.Conditions, options?.AllowModifications ?? false, options?.TransferValidation, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Stream> OpenReadAsync(BlobOpenReadOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await OpenReadInternal(options?.Position ?? 0, options?.BufferSize, options?.Conditions, options?.AllowModifications ?? false, options?.TransferValidation, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Stream OpenRead(long position = 0L, int? bufferSize = null, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return OpenReadInternal(position, bufferSize, conditions, allowModifications: false, null, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Stream OpenRead(bool allowBlobModifications, long position = 0L, int? bufferSize = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return OpenRead(position, bufferSize, allowBlobModifications ? new BlobRequestConditions() : null, cancellationToken);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Stream> OpenReadAsync(long position = 0L, int? bufferSize = null, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await OpenReadInternal(position, bufferSize, conditions, allowModifications: false, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Stream> OpenReadAsync(bool allowBlobModifications, long position = 0L, int? bufferSize = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await OpenReadAsync(position, bufferSize, allowBlobModifications ? new BlobRequestConditions() : null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal async Task<Stream> OpenReadInternal(long position, int? bufferSize, BlobRequestConditions conditions, bool allowModifications, DownloadTransferValidationOptions transferValidationOverride, bool async, CancellationToken cancellationToken)
		{
			DownloadTransferValidationOptions validationOptions = transferValidationOverride ?? _clientConfiguration.TransferValidation.Download;
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "OpenReadInternal"))
			{
				string operationName = "BlobBaseClient.OpenRead";
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope(operationName);
				try
				{
					scope.Start();
					Response<BlobProperties> response = await GetPropertiesInternal(conditions, async, new RequestContext
					{
						CancellationToken = cancellationToken
					}).ConfigureAwait(continueOnCapturedContext: false);
					ETag eTag = response.Value.ETag;
					BlobRequestConditions readConditions = conditions;
					if (!allowModifications)
					{
						readConditions = readConditions?.WithIfMatch(eTag) ?? new BlobRequestConditions
						{
							IfMatch = eTag
						};
					}
					long contentLength = response.Value.ContentLength;
					ClientSideDecryptor.ContentEncryptionKeyCache contentEncryptionKeyCache = null;
					EncryptionData encryptionData = null;
					if (UsingClientSideEncryption && !allowModifications)
					{
						contentEncryptionKeyCache = new ClientSideDecryptor.ContentEncryptionKeyCache();
						encryptionData = BlobClientSideDecryptor.GetAndValidateEncryptionDataOrDefault(response?.Value?.Metadata);
					}
					LazyLoadingReadOnlyStream<BlobProperties>.PredictEncryptedRangeAdjustment rangeAdjustmentFunc = (UsingClientSideEncryption ? ((LazyLoadingReadOnlyStream<BlobProperties>.PredictEncryptedRangeAdjustment)((HttpRange r) => BlobClientSideDecryptor.GetEncryptedBlobRange(r, encryptionData))) : LazyLoadingReadOnlyStream<BlobProperties>.NoRangeAdjustment);
					return new LazyLoadingReadOnlyStream<BlobProperties>(async delegate(HttpRange range, DownloadTransferValidationOptions downloadValidationOptions, bool async2, CancellationToken cancellationToken2)
					{
						HttpRange requestedRange = range;
						if (UsingClientSideEncryption)
						{
							ClientSideDecryptor.BeginContentEncryptionKeyCaching(contentEncryptionKeyCache);
							range = rangeAdjustmentFunc(requestedRange);
						}
						Response<BlobDownloadStreamingResult> response2 = await DownloadStreamingInternal(range, readConditions, downloadValidationOptions, null, operationName, async2, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
						if (UsingClientSideEncryption)
						{
							BlobDownloadStreamingResult value = response2.Value;
							value.Content = await new BlobClientSideDecryptor(new ClientSideDecryptor(ClientSideEncryption)).DecryptInternal(response2.Value.Content, response2.Value.Details.Metadata, requestedRange, response2.Value.Details.ContentRange, async2, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
						}
						return Response.FromValue((IDownloadedContent)response2.Value, response2.GetRawResponse());
					}, async (bool async2, CancellationToken cancellationToken2) => await GetPropertiesInternal(null, async2, new RequestContext
					{
						CancellationToken = cancellationToken2
					}).ConfigureAwait(continueOnCapturedContext: false), validationOptions, allowModifications, contentLength, position, bufferSize, rangeAdjustmentFunc);
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual CopyFromUriOperation StartCopyFromUri(Uri source, BlobCopyFromUriOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			Response<BlobCopyInfo> response = StartCopyFromUriInternal(source, options?.Metadata, options?.Tags, options?.AccessTier, options?.SourceConditions, options?.DestinationConditions, options?.RehydratePriority, options?.ShouldSealDestination, options?.DestinationImmutabilityPolicy, options?.LegalHold, async: false, cancellationToken).EnsureCompleted();
			return new CopyFromUriOperation(this, response.Value.CopyId, response.GetRawResponse(), cancellationToken);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual CopyFromUriOperation StartCopyFromUri(Uri source, IDictionary<string, string> metadata = null, AccessTier? accessTier = null, BlobRequestConditions sourceConditions = null, BlobRequestConditions destinationConditions = null, RehydratePriority? rehydratePriority = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			Response<BlobCopyInfo> response = StartCopyFromUriInternal(source, metadata, null, accessTier, sourceConditions, destinationConditions, rehydratePriority, null, null, null, async: false, cancellationToken).EnsureCompleted();
			return new CopyFromUriOperation(this, response.Value.CopyId, response.GetRawResponse(), cancellationToken);
		}

		public virtual async Task<CopyFromUriOperation> StartCopyFromUriAsync(Uri source, BlobCopyFromUriOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			Response<BlobCopyInfo> response = await StartCopyFromUriInternal(source, options?.Metadata, options?.Tags, options?.AccessTier, options?.SourceConditions, options?.DestinationConditions, options?.RehydratePriority, options?.ShouldSealDestination, options?.DestinationImmutabilityPolicy, options?.LegalHold, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return new CopyFromUriOperation(this, response.Value.CopyId, response.GetRawResponse(), cancellationToken);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<CopyFromUriOperation> StartCopyFromUriAsync(Uri source, IDictionary<string, string> metadata = null, AccessTier? accessTier = null, BlobRequestConditions sourceConditions = null, BlobRequestConditions destinationConditions = null, RehydratePriority? rehydratePriority = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			Response<BlobCopyInfo> response = await StartCopyFromUriInternal(source, metadata, null, accessTier, sourceConditions, destinationConditions, rehydratePriority, null, null, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return new CopyFromUriOperation(this, response.Value.CopyId, response.GetRawResponse(), cancellationToken);
		}

		private async Task<Response<BlobCopyInfo>> StartCopyFromUriInternal(Uri source, IDictionary<string, string> metadata, IDictionary<string, string> tags, AccessTier? accessTier, BlobRequestConditions sourceConditions, BlobRequestConditions destinationConditions, RehydratePriority? rehydratePriority, bool? sealBlob, BlobImmutabilityPolicy destinationImmutabilityPolicy, bool? legalHold, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "StartCopyFromUriInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobBaseClient.StartCopyFromUri");
				destinationConditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "StartCopyFromUri", "destinationConditions");
				sourceConditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.LeaseId, "StartCopyFromUri", "sourceConditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobStartCopyFromURLHeaders> responseWithHeaders;
					if (async)
					{
						BlobRestClient blobRestClient = BlobRestClient;
						string absoluteUri = source.AbsoluteUri;
						IDictionary<string, string> metadata2 = metadata;
						AccessTier? tier = accessTier;
						RehydratePriority? rehydratePriority2 = rehydratePriority;
						DateTimeOffset? sourceIfModifiedSince = sourceConditions?.IfModifiedSince;
						DateTimeOffset? sourceIfUnmodifiedSince = sourceConditions?.IfUnmodifiedSince;
						string sourceIfMatch = sourceConditions?.IfMatch?.ToString();
						string sourceIfNoneMatch = sourceConditions?.IfNoneMatch?.ToString();
						string sourceIfTags = sourceConditions?.TagConditions;
						DateTimeOffset? ifModifiedSince = destinationConditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = destinationConditions?.IfUnmodifiedSince;
						string ifMatch = destinationConditions?.IfMatch?.ToString();
						string ifNoneMatch = destinationConditions?.IfNoneMatch?.ToString();
						string leaseId = destinationConditions?.LeaseId;
						string ifTags = destinationConditions?.TagConditions;
						string blobTagsString = tags?.ToTagsString();
						bool? sealBlob2 = sealBlob;
						DateTimeOffset? immutabilityPolicyExpiry = destinationImmutabilityPolicy?.ExpiresOn;
						BlobImmutabilityPolicyMode? immutabilityPolicyMode = destinationImmutabilityPolicy?.PolicyMode;
						bool? legalHold2 = legalHold;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blobRestClient.StartCopyFromURLAsync(absoluteUri, null, metadata2, tier, rehydratePriority2, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, sourceIfTags, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, leaseId, blobTagsString, sealBlob2, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold2, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlobRestClient blobRestClient2 = BlobRestClient;
						string absoluteUri2 = source.AbsoluteUri;
						IDictionary<string, string> metadata2 = metadata;
						AccessTier? tier = accessTier;
						RehydratePriority? rehydratePriority2 = rehydratePriority;
						DateTimeOffset? immutabilityPolicyExpiry = sourceConditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = sourceConditions?.IfUnmodifiedSince;
						string blobTagsString = sourceConditions?.IfMatch?.ToString();
						string ifTags = sourceConditions?.IfNoneMatch?.ToString();
						string leaseId = sourceConditions?.TagConditions;
						DateTimeOffset? ifModifiedSince = destinationConditions?.IfModifiedSince;
						DateTimeOffset? sourceIfUnmodifiedSince = destinationConditions?.IfUnmodifiedSince;
						string ifNoneMatch = destinationConditions?.IfMatch?.ToString();
						string ifMatch = destinationConditions?.IfNoneMatch?.ToString();
						string sourceIfTags = destinationConditions?.LeaseId;
						string sourceIfNoneMatch = destinationConditions?.TagConditions;
						string sourceIfMatch = tags?.ToTagsString();
						bool? legalHold2 = sealBlob;
						DateTimeOffset? sourceIfModifiedSince = destinationImmutabilityPolicy?.ExpiresOn;
						BlobImmutabilityPolicyMode? immutabilityPolicyMode = destinationImmutabilityPolicy?.PolicyMode;
						bool? sealBlob2 = legalHold;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blobRestClient2.StartCopyFromURL(absoluteUri2, null, metadata2, tier, rehydratePriority2, immutabilityPolicyExpiry, ifUnmodifiedSince, blobTagsString, ifTags, leaseId, ifModifiedSince, sourceIfUnmodifiedSince, ifNoneMatch, ifMatch, sourceIfNoneMatch, sourceIfTags, sourceIfMatch, legalHold2, sourceIfModifiedSince, immutabilityPolicyMode, sealBlob2, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobCopyInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response AbortCopyFromUri(string copyId, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return AbortCopyFromUriInternal(copyId, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response> AbortCopyFromUriAsync(string copyId, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await AbortCopyFromUriInternal(copyId, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response> AbortCopyFromUriInternal(string copyId, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "AbortCopyFromUriInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobBaseClient.AbortCopyFromUri");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.TagConditions | BlobRequestConditionProperty.IfModifiedSince | BlobRequestConditionProperty.IfUnmodifiedSince | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "AbortCopyFromUri", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobAbortCopyFromURLHeaders> responseWithHeaders;
					if (async)
					{
						BlobRestClient blobRestClient = BlobRestClient;
						string leaseId = conditions?.LeaseId;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blobRestClient.AbortCopyFromURLAsync(copyId, null, leaseId, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlobRestClient blobRestClient2 = BlobRestClient;
						string leaseId = conditions?.LeaseId;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blobRestClient2.AbortCopyFromURL(copyId, null, leaseId, cancellationToken2);
					}
					return responseWithHeaders.GetRawResponse();
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobCopyInfo> SyncCopyFromUri(Uri source, BlobCopyFromUriOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SyncCopyFromUriInternal(source, options?.Metadata, options?.Tags, options?.AccessTier, options?.SourceConditions, options?.DestinationConditions, options?.DestinationImmutabilityPolicy, options?.LegalHold, options?.SourceAuthentication, options?.CopySourceTagsMode, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobCopyInfo>> SyncCopyFromUriAsync(Uri source, BlobCopyFromUriOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await SyncCopyFromUriInternal(source, options?.Metadata, options?.Tags, options?.AccessTier, options?.SourceConditions, options?.DestinationConditions, options?.DestinationImmutabilityPolicy, options?.LegalHold, options?.SourceAuthentication, options?.CopySourceTagsMode, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobCopyInfo>> SyncCopyFromUriInternal(Uri source, IDictionary<string, string> metadata, IDictionary<string, string> tags, AccessTier? accessTier, BlobRequestConditions sourceConditions, BlobRequestConditions destinationConditions, BlobImmutabilityPolicy destinationImmutabilityPolicy, bool? legalHold, HttpAuthorization sourceAuthentication, BlobCopySourceTagsMode? copySourceTags, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "SyncCopyFromUriInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobBaseClient.SyncCopyFromUri");
				destinationConditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "SyncCopyFromUri", "destinationConditions");
				sourceConditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.LeaseId, "SyncCopyFromUri", "sourceConditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobCopyFromURLHeaders> responseWithHeaders;
					if (async)
					{
						BlobRestClient blobRestClient = BlobRestClient;
						string absoluteUri = source.AbsoluteUri;
						IDictionary<string, string> metadata2 = metadata;
						AccessTier? tier = accessTier;
						DateTimeOffset? sourceIfModifiedSince = sourceConditions?.IfModifiedSince;
						DateTimeOffset? sourceIfUnmodifiedSince = sourceConditions?.IfUnmodifiedSince;
						string sourceIfMatch = sourceConditions?.IfMatch.ToString();
						string sourceIfNoneMatch = sourceConditions?.IfNoneMatch.ToString();
						DateTimeOffset? ifModifiedSince = destinationConditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = destinationConditions?.IfUnmodifiedSince;
						string ifMatch = destinationConditions?.IfMatch?.ToString();
						string ifNoneMatch = destinationConditions?.IfNoneMatch?.ToString();
						string ifTags = destinationConditions?.TagConditions;
						string leaseId = destinationConditions?.LeaseId;
						string blobTagsString = tags?.ToTagsString();
						DateTimeOffset? immutabilityPolicyExpiry = destinationImmutabilityPolicy?.ExpiresOn;
						BlobImmutabilityPolicyMode? immutabilityPolicyMode = destinationImmutabilityPolicy?.PolicyMode;
						bool? legalHold2 = legalHold;
						string copySourceAuthorization = sourceAuthentication?.ToString();
						string encryptionScope = ClientConfiguration.EncryptionScope;
						BlobCopySourceTagsMode? copySourceTags2 = copySourceTags;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blobRestClient.CopyFromURLAsync(absoluteUri, null, metadata2, tier, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, leaseId, null, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold2, copySourceAuthorization, encryptionScope, copySourceTags2, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlobRestClient blobRestClient2 = BlobRestClient;
						string absoluteUri2 = source.AbsoluteUri;
						IDictionary<string, string> metadata2 = metadata;
						AccessTier? tier = accessTier;
						DateTimeOffset? immutabilityPolicyExpiry = sourceConditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = sourceConditions?.IfUnmodifiedSince;
						string encryptionScope = sourceConditions?.IfMatch.ToString();
						string copySourceAuthorization = sourceConditions?.IfNoneMatch.ToString();
						DateTimeOffset? ifModifiedSince = destinationConditions?.IfModifiedSince;
						DateTimeOffset? sourceIfUnmodifiedSince = destinationConditions?.IfUnmodifiedSince;
						string blobTagsString = destinationConditions?.IfMatch?.ToString();
						string leaseId = destinationConditions?.IfNoneMatch?.ToString();
						string ifTags = destinationConditions?.TagConditions;
						string ifNoneMatch = destinationConditions?.LeaseId;
						string ifMatch = tags?.ToTagsString();
						DateTimeOffset? sourceIfModifiedSince = destinationImmutabilityPolicy?.ExpiresOn;
						BlobImmutabilityPolicyMode? immutabilityPolicyMode = destinationImmutabilityPolicy?.PolicyMode;
						bool? legalHold2 = legalHold;
						string sourceIfNoneMatch = sourceAuthentication?.ToString();
						string sourceIfMatch = ClientConfiguration.EncryptionScope;
						BlobCopySourceTagsMode? copySourceTags2 = copySourceTags;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blobRestClient2.CopyFromURL(absoluteUri2, null, metadata2, tier, immutabilityPolicyExpiry, ifUnmodifiedSince, encryptionScope, copySourceAuthorization, ifModifiedSince, sourceIfUnmodifiedSince, blobTagsString, leaseId, ifTags, ifNoneMatch, null, ifMatch, sourceIfModifiedSince, immutabilityPolicyMode, legalHold2, sourceIfNoneMatch, sourceIfMatch, copySourceTags2, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobCopyInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response Delete(DeleteSnapshotsOption snapshotsOption = DeleteSnapshotsOption.None, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return DeleteInternal(snapshotsOption, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response> DeleteAsync(DeleteSnapshotsOption snapshotsOption = DeleteSnapshotsOption.None, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await DeleteInternal(snapshotsOption, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<bool> DeleteIfExists(DeleteSnapshotsOption snapshotsOption = DeleteSnapshotsOption.None, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return DeleteIfExistsInternal(snapshotsOption, conditions ?? null, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<bool>> DeleteIfExistsAsync(DeleteSnapshotsOption snapshotsOption = DeleteSnapshotsOption.None, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await DeleteIfExistsInternal(snapshotsOption, conditions ?? null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal async Task<Response<bool>> DeleteIfExistsInternal(DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "DeleteIfExistsInternal"))
			{
				string text = "BlobBaseClient.DeleteIfExists";
				ClientConfiguration.ClientDiagnostics.CreateScope(text);
				try
				{
					return Response.FromValue(value: true, await DeleteInternal(snapshotsOption, conditions, async, cancellationToken, text).ConfigureAwait(continueOnCapturedContext: false));
				}
				catch (RequestFailedException ex) when (ex.ErrorCode == BlobErrorCode.BlobNotFound || ex.ErrorCode == BlobErrorCode.ContainerNotFound)
				{
					return Response.FromValue(value: false, null);
				}
				catch (Exception)
				{
					throw;
				}
				finally
				{
					_ = 0;
				}
			}
		}

		private async Task<Response> DeleteInternal(DeleteSnapshotsOption snapshotsOption, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken, string operationName = null)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "DeleteInternal"))
			{
				if (operationName == null)
				{
					operationName = "BlobBaseClient.Delete";
				}
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope(operationName);
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "Delete", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobDeleteHeaders> responseWithHeaders;
					if (async)
					{
						BlobRestClient blobRestClient = BlobRestClient;
						string leaseId = conditions?.LeaseId;
						DeleteSnapshotsOption? deleteSnapshots = ((snapshotsOption == DeleteSnapshotsOption.None) ? ((DeleteSnapshotsOption?)null) : new DeleteSnapshotsOption?(snapshotsOption));
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blobRestClient.DeleteAsync(null, null, null, leaseId, deleteSnapshots, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, null, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlobRestClient blobRestClient2 = BlobRestClient;
						string ifTags = conditions?.LeaseId;
						DeleteSnapshotsOption? deleteSnapshots = ((snapshotsOption == DeleteSnapshotsOption.None) ? ((DeleteSnapshotsOption?)null) : new DeleteSnapshotsOption?(snapshotsOption));
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string ifNoneMatch = conditions?.IfMatch?.ToString();
						string ifMatch = conditions?.IfNoneMatch?.ToString();
						string leaseId = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blobRestClient2.Delete(null, null, null, ifTags, deleteSnapshots, ifUnmodifiedSince, ifModifiedSince, ifNoneMatch, ifMatch, leaseId, null, cancellationToken2);
					}
					return responseWithHeaders.GetRawResponse();
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<bool> Exists(CancellationToken cancellationToken = default(CancellationToken))
		{
			return ExistsInternal(async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<bool>> ExistsAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return await ExistsInternal(async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<bool>> ExistsInternal(bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "ExistsInternal"))
			{
				string operationName = "BlobBaseClient.Exists";
				RequestContext requestContext = new RequestContext
				{
					CancellationToken = cancellationToken
				};
				requestContext.AddClassifier(new BlobBaseClientExistsClassifier());
				try
				{
					Response rawResponse = (await GetPropertiesInternal(null, async, requestContext, operationName).ConfigureAwait(continueOnCapturedContext: false)).GetRawResponse();
					if (BlobBaseClientExistsClassifier.IsResourceNotFoundResponse(rawResponse))
					{
						return Response.FromValue(value: false, rawResponse);
					}
					BlobBaseClientExistsClassifier.IsUsesCustomerSpecifiedEncryptionResponse(rawResponse);
					return Response.FromValue(value: true, rawResponse);
				}
				catch (Exception)
				{
					throw;
				}
				finally
				{
					_ = 0;
				}
			}
		}

		public virtual Response Undelete(CancellationToken cancellationToken = default(CancellationToken))
		{
			return UndeleteInternal(async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response> UndeleteAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return await UndeleteInternal(async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response> UndeleteInternal(bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "UndeleteInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobBaseClient.Undelete");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobUndeleteHeaders> responseWithHeaders;
					if (async)
					{
						BlobRestClient blobRestClient = BlobRestClient;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blobRestClient.UndeleteAsync(null, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlobRestClient blobRestClient2 = BlobRestClient;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blobRestClient2.Undelete(null, cancellationToken2);
					}
					return responseWithHeaders.GetRawResponse();
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobProperties> GetProperties(BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetPropertiesInternal(conditions, async: false, new RequestContext
			{
				CancellationToken = cancellationToken
			}).EnsureCompleted();
		}

		public virtual async Task<Response<BlobProperties>> GetPropertiesAsync(BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetPropertiesInternal(conditions, async: true, new RequestContext
			{
				CancellationToken = cancellationToken
			}).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal async Task<Response<BlobProperties>> GetPropertiesInternal(BlobRequestConditions conditions, bool async, RequestContext context, string operationName = null)
		{
			if (context == null)
			{
				context = new RequestContext();
			}
			if (operationName == null)
			{
				operationName = "BlobBaseClient.GetProperties";
			}
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "GetPropertiesInternal"))
			{
				if (operationName == null)
				{
					operationName = "BlobBaseClient.GetProperties";
				}
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope(operationName);
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "GetProperties", "conditions");
				try
				{
					scope.Start();
					Response response;
					if (async)
					{
						BlobRestClient blobRestClient = BlobRestClient;
						string leaseId = conditions?.LeaseId;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						string encryptionAlgorithm = ClientConfiguration.CustomerProvidedKey?.EncryptionAlgorithm.ToEncryptionAlgorithmString();
						RequestConditions requestConditions = conditions;
						string ifTags = conditions?.TagConditions;
						RequestContext context2 = context;
						response = await blobRestClient.GetPropertiesAsync(null, null, null, leaseId, encryptionKey, encryptionKeySha, encryptionAlgorithm, ifTags, requestConditions, context2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlobRestClient blobRestClient2 = BlobRestClient;
						string ifTags = conditions?.LeaseId;
						string encryptionAlgorithm = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionAlgorithm.ToEncryptionAlgorithmString();
						RequestConditions requestConditions = conditions;
						string leaseId = conditions?.TagConditions;
						RequestContext context2 = context;
						response = blobRestClient2.GetProperties(null, null, null, ifTags, encryptionAlgorithm, encryptionKeySha, encryptionKey, leaseId, requestConditions, context2);
					}
					Azure.Core.ResponseWithHeaders<BlobGetPropertiesHeaders> responseWithHeaders = Azure.Core.ResponseWithHeaders.FromValue(new BlobGetPropertiesHeaders(response), response);
					return Response.FromValue(responseWithHeaders.ToBlobProperties(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobInfo> SetHttpHeaders(BlobHttpHeaders httpHeaders = null, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SetHttpHeadersInternal(httpHeaders, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobInfo>> SetHttpHeadersAsync(BlobHttpHeaders httpHeaders = null, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await SetHttpHeadersInternal(httpHeaders, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobInfo>> SetHttpHeadersInternal(BlobHttpHeaders httpHeaders, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "SetHttpHeadersInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobBaseClient.SetHttpHeaders");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "SetHttpHeaders", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobSetHttpHeadersHeaders> responseWithHeaders;
					if (async)
					{
						BlobRestClient blobRestClient = BlobRestClient;
						string blobCacheControl = httpHeaders?.CacheControl;
						string blobContentType = httpHeaders?.ContentType;
						byte[] blobContentMD = httpHeaders?.ContentHash;
						string blobContentEncoding = httpHeaders?.ContentEncoding;
						string blobContentLanguage = httpHeaders?.ContentLanguage;
						string leaseId = conditions?.LeaseId;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						string blobContentDisposition = httpHeaders?.ContentDisposition;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blobRestClient.SetHttpHeadersAsync(null, blobCacheControl, blobContentType, blobContentMD, blobContentEncoding, blobContentLanguage, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobContentDisposition, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlobRestClient blobRestClient2 = BlobRestClient;
						string blobContentDisposition = httpHeaders?.CacheControl;
						string ifTags = httpHeaders?.ContentType;
						byte[] blobContentMD = httpHeaders?.ContentHash;
						string ifNoneMatch = httpHeaders?.ContentEncoding;
						string ifMatch = httpHeaders?.ContentLanguage;
						string leaseId = conditions?.LeaseId;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string blobContentLanguage = conditions?.IfMatch?.ToString();
						string blobContentEncoding = conditions?.IfNoneMatch?.ToString();
						string blobContentType = conditions?.TagConditions;
						string blobCacheControl = httpHeaders?.ContentDisposition;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blobRestClient2.SetHttpHeaders(null, blobContentDisposition, ifTags, blobContentMD, ifNoneMatch, ifMatch, leaseId, ifUnmodifiedSince, ifModifiedSince, blobContentLanguage, blobContentEncoding, blobContentType, blobCacheControl, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobInfo> SetMetadata(IDictionary<string, string> metadata, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SetMetadataInternal(metadata, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobInfo>> SetMetadataAsync(IDictionary<string, string> metadata, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await SetMetadataInternal(metadata, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal async Task<Response<BlobInfo>> SetMetadataInternal(IDictionary<string, string> metadata, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "SetMetadataInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobBaseClient.SetMetadata");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "SetMetadata", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobSetMetadataHeaders> responseWithHeaders;
					if (async)
					{
						BlobRestClient blobRestClient = BlobRestClient;
						IDictionary<string, string> metadata2 = metadata;
						string leaseId = conditions?.LeaseId;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blobRestClient.SetMetadataAsync(null, metadata2, leaseId, encryptionKey, encryptionKeySha, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlobRestClient blobRestClient2 = BlobRestClient;
						IDictionary<string, string> metadata2 = metadata;
						string ifTags = conditions?.LeaseId;
						string ifNoneMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string ifMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string encryptionKeySha = conditions?.IfMatch?.ToString();
						string encryptionKey = conditions?.IfNoneMatch?.ToString();
						string leaseId = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blobRestClient2.SetMetadata(null, metadata2, ifTags, ifNoneMatch, ifMatch, encryptionAlgorithm, encryptionScope, ifUnmodifiedSince, ifModifiedSince, encryptionKeySha, encryptionKey, leaseId, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobSnapshotInfo> CreateSnapshot(IDictionary<string, string> metadata = null, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CreateSnapshotInternal(metadata, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobSnapshotInfo>> CreateSnapshotAsync(IDictionary<string, string> metadata = null, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await CreateSnapshotInternal(metadata, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobSnapshotInfo>> CreateSnapshotInternal(IDictionary<string, string> metadata, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "CreateSnapshotInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobBaseClient.CreateSnapshot");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "CreateSnapshot", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobCreateSnapshotHeaders> responseWithHeaders;
					if (async)
					{
						BlobRestClient blobRestClient = BlobRestClient;
						IDictionary<string, string> metadata2 = metadata;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						string leaseId = conditions?.LeaseId;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blobRestClient.CreateSnapshotAsync(null, metadata2, encryptionKey, encryptionKeySha, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, leaseId, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlobRestClient blobRestClient2 = BlobRestClient;
						IDictionary<string, string> metadata2 = metadata;
						string leaseId = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string ifTags = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string ifNoneMatch = ClientConfiguration.EncryptionScope;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string encryptionScope = conditions?.IfNoneMatch?.ToString();
						string encryptionKeySha = conditions?.TagConditions;
						string encryptionKey = conditions?.LeaseId;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blobRestClient2.CreateSnapshot(null, metadata2, leaseId, ifTags, encryptionAlgorithm, ifNoneMatch, ifUnmodifiedSince, ifModifiedSince, ifMatch, encryptionScope, encryptionKeySha, encryptionKey, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobSnapshotInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response SetAccessTier(AccessTier accessTier, BlobRequestConditions conditions = null, RehydratePriority? rehydratePriority = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SetAccessTierInternal(accessTier, conditions, rehydratePriority, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response> SetAccessTierAsync(AccessTier accessTier, BlobRequestConditions conditions = null, RehydratePriority? rehydratePriority = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await SetAccessTierInternal(accessTier, conditions, rehydratePriority, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response> SetAccessTierInternal(AccessTier accessTier, BlobRequestConditions conditions, RehydratePriority? rehydratePriority, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "SetAccessTierInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobBaseClient.SetAccessTier");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfModifiedSince | BlobRequestConditionProperty.IfUnmodifiedSince | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "SetAccessTier", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobSetTierHeaders> responseWithHeaders;
					if (async)
					{
						BlobRestClient blobRestClient = BlobRestClient;
						RehydratePriority? rehydratePriority2 = rehydratePriority;
						string leaseId = conditions?.LeaseId;
						string ifTags = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blobRestClient.SetTierAsync(accessTier, null, null, null, rehydratePriority2, leaseId, ifTags, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlobRestClient blobRestClient2 = BlobRestClient;
						RehydratePriority? rehydratePriority2 = rehydratePriority;
						string ifTags = conditions?.LeaseId;
						string leaseId = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blobRestClient2.SetTier(accessTier, null, null, null, rehydratePriority2, ifTags, leaseId, cancellationToken2);
					}
					return responseWithHeaders.GetRawResponse();
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<GetBlobTagResult> GetTags(BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetTagsInternal(async: false, conditions, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<GetBlobTagResult>> GetTagsAsync(BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetTagsInternal(async: true, conditions, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<GetBlobTagResult>> GetTagsInternal(bool async, BlobRequestConditions conditions, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "GetTagsInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobBaseClient.GetTags");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfModifiedSince | BlobRequestConditionProperty.IfUnmodifiedSince | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "GetTags", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobTags, BlobGetTagsHeaders> responseWithHeaders;
					if (async)
					{
						BlobRestClient blobRestClient = BlobRestClient;
						string ifTags = conditions?.TagConditions;
						string leaseId = conditions?.LeaseId;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blobRestClient.GetTagsAsync(null, null, null, ifTags, leaseId, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlobRestClient blobRestClient2 = BlobRestClient;
						string leaseId = conditions?.TagConditions;
						string ifTags = conditions?.LeaseId;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blobRestClient2.GetTags(null, null, null, leaseId, ifTags, cancellationToken2);
					}
					return Response.FromValue(new GetBlobTagResult
					{
						Tags = responseWithHeaders.Value.ToTagDictionary()
					}, responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response SetTags(IDictionary<string, string> tags, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SetTagsInternal(tags, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response> SetTagsAsync(IDictionary<string, string> tags, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await SetTagsInternal(tags, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response> SetTagsInternal(IDictionary<string, string> tags, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "SetTagsInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobBaseClient.SetTags");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfModifiedSince | BlobRequestConditionProperty.IfUnmodifiedSince | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "SetTags", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobSetTagsHeaders> responseWithHeaders;
					if (async)
					{
						BlobRestClient blobRestClient = BlobRestClient;
						string ifTags = conditions?.TagConditions;
						string leaseId = conditions?.LeaseId;
						BlobTags tags2 = tags.ToBlobTags();
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blobRestClient.SetTagsAsync(null, null, null, null, ifTags, leaseId, tags2, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlobRestClient blobRestClient2 = BlobRestClient;
						string leaseId = conditions?.TagConditions;
						string ifTags = conditions?.LeaseId;
						BlobTags tags2 = tags.ToBlobTags();
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blobRestClient2.SetTags(null, null, null, null, leaseId, ifTags, tags2, cancellationToken2);
					}
					return responseWithHeaders.GetRawResponse();
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobImmutabilityPolicy> SetImmutabilityPolicy(BlobImmutabilityPolicy immutabilityPolicy, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SetImmutabilityPolicyInternal(immutabilityPolicy, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobImmutabilityPolicy>> SetImmutabilityPolicyAsync(BlobImmutabilityPolicy immutabilityPolicy, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await SetImmutabilityPolicyInternal(immutabilityPolicy, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobImmutabilityPolicy>> SetImmutabilityPolicyInternal(BlobImmutabilityPolicy immutabilityPolicy, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "SetImmutabilityPolicyInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobBaseClient.SetImmutabilityPolicy");
				if (immutabilityPolicy != null && immutabilityPolicy.PolicyMode == BlobImmutabilityPolicyMode.Mutable)
				{
					throw new ArgumentException(string.Format("{0} must be {1} or {2}", "PolicyMode", BlobImmutabilityPolicyMode.Locked, BlobImmutabilityPolicyMode.Unlocked));
				}
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.LeaseId | BlobRequestConditionProperty.TagConditions | BlobRequestConditionProperty.IfModifiedSince | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "SetImmutabilityPolicy", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobSetImmutabilityPolicyHeaders> responseWithHeaders = ((!async) ? BlobRestClient.SetImmutabilityPolicy(null, conditions?.IfUnmodifiedSince, immutabilityPolicy.ExpiresOn, immutabilityPolicy.PolicyMode, cancellationToken) : (await BlobRestClient.SetImmutabilityPolicyAsync(null, conditions?.IfUnmodifiedSince, immutabilityPolicy.ExpiresOn, immutabilityPolicy.PolicyMode, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
					return Response.FromValue(responseWithHeaders.ToBlobImmutabilityPolicy(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response DeleteImmutabilityPolicy(CancellationToken cancellationToken = default(CancellationToken))
		{
			return DeleteImmutabilityPolicyInternal(async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response> DeleteImmutabilityPolicyAsync(CancellationToken cancellationToken = default(CancellationToken))
		{
			return await DeleteImmutabilityPolicyInternal(async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response> DeleteImmutabilityPolicyInternal(bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "DeleteImmutabilityPolicyInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobBaseClient.DeleteImmutabilityPolicy");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobDeleteImmutabilityPolicyHeaders> responseWithHeaders;
					if (async)
					{
						BlobRestClient blobRestClient = BlobRestClient;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blobRestClient.DeleteImmutabilityPolicyAsync(null, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlobRestClient blobRestClient2 = BlobRestClient;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blobRestClient2.DeleteImmutabilityPolicy(null, cancellationToken2);
					}
					return responseWithHeaders.GetRawResponse();
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobLegalHoldResult> SetLegalHold(bool hasLegalHold, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SetLegalHoldInternal(hasLegalHold, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobLegalHoldResult>> SetLegalHoldAsync(bool hasLegalHold, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await SetLegalHoldInternal(hasLegalHold, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobLegalHoldResult>> SetLegalHoldInternal(bool hasLegalHold, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlobBaseClient", "SetLegalHoldInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlobBaseClient.SetLegalHold");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlobSetLegalHoldHeaders> responseWithHeaders = ((!async) ? BlobRestClient.SetLegalHold(hasLegalHold, null, cancellationToken) : (await BlobRestClient.SetLegalHoldAsync(hasLegalHold, null, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)));
					return Response.FromValue(responseWithHeaders.ToBlobLegalHoldInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		[Azure.Core.CallerShouldAudit(Reason = "https://aka.ms/azsdk/callershouldaudit/storage-blobs")]
		public virtual Uri GenerateSasUri(BlobSasPermissions permissions, DateTimeOffset expiresOn)
		{
			return GenerateSasUri(new BlobSasBuilder(permissions, expiresOn)
			{
				BlobContainerName = BlobContainerName,
				BlobName = Name,
				Snapshot = _snapshot,
				BlobVersionId = _blobVersionId,
				EncryptionScope = _clientConfiguration.EncryptionScope
			});
		}

		[Azure.Core.CallerShouldAudit(Reason = "https://aka.ms/azsdk/callershouldaudit/storage-blobs")]
		public virtual Uri GenerateSasUri(BlobSasBuilder builder)
		{
			if (builder == null)
			{
				throw Azure.Storage.Errors.ArgumentNull("builder");
			}
			builder = BlobSasBuilder.DeepCopy(builder);
			BlobSasBuilder blobSasBuilder = builder;
			if (blobSasBuilder.BlobContainerName == null)
			{
				string text = (blobSasBuilder.BlobContainerName = BlobContainerName);
			}
			blobSasBuilder = builder;
			if (blobSasBuilder.BlobName == null)
			{
				string text = (blobSasBuilder.BlobName = Name);
			}
			blobSasBuilder = builder;
			if (blobSasBuilder.Snapshot == null)
			{
				string text = (blobSasBuilder.Snapshot = _snapshot);
			}
			blobSasBuilder = builder;
			if (blobSasBuilder.BlobVersionId == null)
			{
				string text = (blobSasBuilder.BlobVersionId = _blobVersionId);
			}
			blobSasBuilder = builder;
			if (blobSasBuilder.EncryptionScope == null)
			{
				string text = (blobSasBuilder.EncryptionScope = _clientConfiguration.EncryptionScope);
			}
			if (!builder.BlobContainerName.Equals(BlobContainerName, StringComparison.InvariantCulture))
			{
				throw Azure.Storage.Errors.SasNamesNotMatching("BlobContainerName", "BlobSasBuilder", "BlobContainerName");
			}
			if (!builder.BlobName.Equals(Name, StringComparison.InvariantCulture))
			{
				throw Azure.Storage.Errors.SasNamesNotMatching("BlobName", "BlobSasBuilder", "Name");
			}
			if (string.Compare(_snapshot, builder.Snapshot, StringComparison.InvariantCulture) != 0)
			{
				throw Azure.Storage.Errors.SasNamesNotMatching("Snapshot", "BlobSasBuilder");
			}
			if (string.Compare(_blobVersionId, builder.BlobVersionId, StringComparison.InvariantCulture) != 0)
			{
				throw Azure.Storage.Errors.SasNamesNotMatching("BlobVersionId", "BlobSasBuilder");
			}
			return new BlobUriBuilder(Uri, ClientConfiguration.TrimBlobNameSlashes)
			{
				Sas = builder.ToSasQueryParameters(ClientConfiguration.SharedKeyCredential)
			}.ToUri();
		}

		protected internal virtual BlobContainerClient GetParentBlobContainerClientCore()
		{
			if (_parentBlobContainerClient == null)
			{
				BlobUriBuilder blobUriBuilder = new BlobUriBuilder(Uri)
				{
					BlobName = null,
					VersionId = null,
					Snapshot = null
				};
				_parentBlobContainerClient = new BlobContainerClient(blobUriBuilder.ToUri(), ClientConfiguration, ClientSideEncryption);
			}
			return _parentBlobContainerClient;
		}
	}
	public class BlobLeaseClient
	{
		private readonly BlobBaseClient _blob;

		private readonly BlobContainerClient _container;

		private string _leaseId;

		public static readonly TimeSpan InfiniteLeaseDuration = TimeSpan.FromSeconds(-1.0);

		protected virtual BlobBaseClient BlobClient => _blob;

		protected virtual BlobContainerClient BlobContainerClient => _container;

		public Uri Uri
		{
			get
			{
				object obj = BlobClient?.Uri;
				if (obj == null)
				{
					BlobContainerClient blobContainerClient = BlobContainerClient;
					if (blobContainerClient == null)
					{
						return null;
					}
					obj = blobContainerClient.Uri;
				}
				return (Uri)obj;
			}
		}

		public virtual string LeaseId
		{
			get
			{
				return Volatile.Read(ref _leaseId);
			}
			private set
			{
				Volatile.Write(ref _leaseId, value);
			}
		}

		private HttpPipeline Pipeline => BlobClient?.ClientConfiguration.Pipeline ?? BlobContainerClient.ClientConfiguration.Pipeline;

		internal virtual BlobClientOptions.ServiceVersion Version => BlobClient?.ClientConfiguration.Version ?? BlobContainerClient.ClientConfiguration.Version;

		internal virtual Azure.Core.Pipeline.ClientDiagnostics ClientDiagnostics => BlobClient?.ClientConfiguration.ClientDiagnostics ?? BlobContainerClient.ClientConfiguration.ClientDiagnostics;

		protected BlobLeaseClient()
		{
			_blob = null;
			_container = null;
		}

		public BlobLeaseClient(BlobBaseClient client, string leaseId = null)
		{
			_blob = client ?? throw Azure.Storage.Errors.ArgumentNull("client");
			_container = null;
			LeaseId = leaseId ?? CreateUniqueLeaseId();
		}

		public BlobLeaseClient(BlobContainerClient client, string leaseId = null)
		{
			_blob = null;
			_container = client ?? throw Azure.Storage.Errors.ArgumentNull("client");
			LeaseId = leaseId ?? CreateUniqueLeaseId();
		}

		private static string CreateUniqueLeaseId()
		{
			return Guid.NewGuid().ToString();
		}

		private void EnsureClient()
		{
			if (BlobClient == null && BlobContainerClient == null)
			{
				throw BlobErrors.BlobOrContainerMissing("BlobLeaseClient", "BlobBaseClient", "BlobContainerClient");
			}
		}

		public virtual Response<BlobLease> Acquire(TimeSpan duration, RequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return ParseAcquireResponse(AcquireInternal(duration, conditions, async: false, new RequestContext
			{
				CancellationToken = cancellationToken
			}).EnsureCompleted());
		}

		public virtual async Task<Response<BlobLease>> AcquireAsync(TimeSpan duration, RequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return ParseAcquireResponse(await AcquireInternal(duration, conditions, async: true, new RequestContext
			{
				CancellationToken = cancellationToken
			}).ConfigureAwait(continueOnCapturedContext: false));
		}

		private Response<BlobLease> ParseAcquireResponse(Response response)
		{
			if (BlobClient != null)
			{
				return Response.FromValue(Azure.Core.ResponseWithHeaders.FromValue(new BlobAcquireLeaseHeaders(response), response).ToBlobLease(), response);
			}
			return Response.FromValue(Azure.Core.ResponseWithHeaders.FromValue(new ContainerAcquireLeaseHeaders(response), response).ToBlobLease(), response);
		}

		public virtual Response Acquire(TimeSpan duration, RequestConditions conditions, RequestContext context)
		{
			return AcquireInternal(duration, conditions, async: false, context).EnsureCompleted();
		}

		public virtual async Task<Response> AcquireAsync(TimeSpan duration, RequestConditions conditions, RequestContext context)
		{
			return await AcquireInternal(duration, conditions, async: true, context).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response> AcquireInternal(TimeSpan duration, RequestConditions conditions, bool async, RequestContext context)
		{
			EnsureClient();
			if (conditions == null)
			{
				conditions = new RequestConditions();
			}
			if (context == null)
			{
				context = new RequestContext();
			}
			long value = ((duration < TimeSpan.Zero) ? (-1) : Convert.ToInt64(duration.TotalSeconds));
			using (Pipeline.BeginLoggingScope("BlobLeaseClient", "AcquireInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientDiagnostics.CreateScope("BlobLeaseClient.Acquire");
				try
				{
					scope.Start();
					string text = null;
					if (conditions is BlobLeaseRequestConditions blobLeaseRequestConditions)
					{
						text = blobLeaseRequestConditions?.TagConditions;
					}
					Response response;
					if (BlobClient != null)
					{
						if (async)
						{
							BlobRestClient blobRestClient = BlobClient.BlobRestClient;
							long? duration2 = value;
							string leaseId = LeaseId;
							RequestConditions requestConditions = conditions;
							string ifTags = text;
							RequestContext context2 = context;
							response = await blobRestClient.AcquireLeaseAsync(null, duration2, leaseId, ifTags, requestConditions, context2).ConfigureAwait(continueOnCapturedContext: false);
						}
						else
						{
							BlobRestClient blobRestClient2 = BlobClient.BlobRestClient;
							long? duration2 = value;
							string ifTags = LeaseId;
							RequestConditions requestConditions = conditions;
							string leaseId = text;
							RequestContext context2 = context;
							response = blobRestClient2.AcquireLease(null, duration2, ifTags, leaseId, requestConditions, context2);
						}
					}
					else
					{
						conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "Acquire", "conditions");
						if (async)
						{
							ContainerRestClient containerRestClient = BlobContainerClient.ContainerRestClient;
							long? duration2 = value;
							string leaseId = LeaseId;
							RequestConditions requestConditions = conditions;
							RequestContext context2 = context;
							response = await containerRestClient.AcquireLeaseAsync(null, duration2, leaseId, requestConditions, context2).ConfigureAwait(continueOnCapturedContext: false);
						}
						else
						{
							ContainerRestClient containerRestClient2 = BlobContainerClient.ContainerRestClient;
							long? duration2 = value;
							string leaseId = LeaseId;
							RequestConditions requestConditions = conditions;
							RequestContext context2 = context;
							response = containerRestClient2.AcquireLease(null, duration2, leaseId, requestConditions, context2);
						}
					}
					if (response.Headers.TryGetValue("x-ms-lease-id", out string value2))
					{
						LeaseId = value2;
					}
					return response;
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobLease> Renew(RequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return RenewInternal(conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobLease>> RenewAsync(RequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await RenewInternal(conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobLease>> RenewInternal(RequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (Pipeline.BeginLoggingScope("BlobLeaseClient", "RenewInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientDiagnostics.CreateScope("BlobLeaseClient.Renew");
				try
				{
					scope.Start();
					string text = null;
					if (conditions != null && conditions.GetType() == typeof(BlobLeaseRequestConditions))
					{
						text = ((BlobLeaseRequestConditions)conditions).TagConditions;
					}
					Response<BlobLease> response;
					if (BlobClient != null)
					{
						Azure.Core.ResponseWithHeaders<BlobRenewLeaseHeaders> responseWithHeaders;
						if (async)
						{
							BlobRestClient blobRestClient = BlobClient.BlobRestClient;
							string leaseId = LeaseId;
							DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
							DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
							string ifMatch = conditions?.IfMatch?.ToString();
							string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
							string ifTags = text;
							CancellationToken cancellationToken2 = cancellationToken;
							responseWithHeaders = await blobRestClient.RenewLeaseAsync(leaseId, null, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
						}
						else
						{
							BlobRestClient blobRestClient2 = BlobClient.BlobRestClient;
							string leaseId2 = LeaseId;
							DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
							DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
							string ifTags = conditions?.IfMatch?.ToString();
							string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
							string ifMatch = text;
							CancellationToken cancellationToken2 = cancellationToken;
							responseWithHeaders = blobRestClient2.RenewLease(leaseId2, null, ifUnmodifiedSince, ifModifiedSince, ifTags, ifNoneMatch, ifMatch, cancellationToken2);
						}
						response = Response.FromValue(responseWithHeaders.ToBlobLease(), responseWithHeaders.GetRawResponse());
					}
					else
					{
						conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "Release", "conditions");
						Azure.Core.ResponseWithHeaders<ContainerRenewLeaseHeaders> responseWithHeaders2;
						if (async)
						{
							ContainerRestClient containerRestClient = BlobContainerClient.ContainerRestClient;
							string leaseId3 = LeaseId;
							DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
							DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
							CancellationToken cancellationToken2 = cancellationToken;
							responseWithHeaders2 = await containerRestClient.RenewLeaseAsync(leaseId3, null, ifModifiedSince, ifUnmodifiedSince, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
						}
						else
						{
							ContainerRestClient containerRestClient2 = BlobContainerClient.ContainerRestClient;
							string leaseId4 = LeaseId;
							DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
							DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
							CancellationToken cancellationToken2 = cancellationToken;
							responseWithHeaders2 = containerRestClient2.RenewLease(leaseId4, null, ifUnmodifiedSince, ifModifiedSince, cancellationToken2);
						}
						response = Response.FromValue(responseWithHeaders2.ToBlobLease(), responseWithHeaders2.GetRawResponse());
					}
					LeaseId = response.Value.LeaseId;
					return response;
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<ReleasedObjectInfo> Release(RequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return ReleaseInternal(conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<ReleasedObjectInfo>> ReleaseAsync(RequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await ReleaseInternal(conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<ReleasedObjectInfo>> ReleaseInternal(RequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			EnsureClient();
			using (Pipeline.BeginLoggingScope("BlobLeaseClient", "ReleaseInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientDiagnostics.CreateScope("BlobLeaseClient.Release");
				try
				{
					scope.Start();
					string text = null;
					if (conditions != null && conditions.GetType() == typeof(BlobLeaseRequestConditions))
					{
						text = ((BlobLeaseRequestConditions)conditions).TagConditions;
					}
					if (BlobClient != null)
					{
						Azure.Core.ResponseWithHeaders<BlobReleaseLeaseHeaders> responseWithHeaders;
						if (async)
						{
							BlobRestClient blobRestClient = BlobClient.BlobRestClient;
							string leaseId = LeaseId;
							DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
							DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
							string ifMatch = conditions?.IfMatch?.ToString();
							string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
							string ifTags = text;
							CancellationToken cancellationToken2 = cancellationToken;
							responseWithHeaders = await blobRestClient.ReleaseLeaseAsync(leaseId, null, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
						}
						else
						{
							BlobRestClient blobRestClient2 = BlobClient.BlobRestClient;
							string leaseId2 = LeaseId;
							DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
							DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
							string ifTags = conditions?.IfMatch?.ToString();
							string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
							string ifMatch = text;
							CancellationToken cancellationToken2 = cancellationToken;
							responseWithHeaders = blobRestClient2.ReleaseLease(leaseId2, null, ifUnmodifiedSince, ifModifiedSince, ifTags, ifNoneMatch, ifMatch, cancellationToken2);
						}
						return Response.FromValue(responseWithHeaders.ToReleasedObjectInfo(), responseWithHeaders.GetRawResponse());
					}
					conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "Release", "conditions");
					Azure.Core.ResponseWithHeaders<ContainerReleaseLeaseHeaders> responseWithHeaders2;
					if (async)
					{
						ContainerRestClient containerRestClient = BlobContainerClient.ContainerRestClient;
						string leaseId3 = LeaseId;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders2 = await containerRestClient.ReleaseLeaseAsync(leaseId3, null, ifModifiedSince, ifUnmodifiedSince, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ContainerRestClient containerRestClient2 = BlobContainerClient.ContainerRestClient;
						string leaseId4 = LeaseId;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders2 = containerRestClient2.ReleaseLease(leaseId4, null, ifUnmodifiedSince, ifModifiedSince, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders2.ToReleasedObjectInfo(), responseWithHeaders2.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobLease> Change(string proposedId, RequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return ChangeInternal(proposedId, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobLease>> ChangeAsync(string proposedId, RequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await ChangeInternal(proposedId, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobLease>> ChangeInternal(string proposedId, RequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			EnsureClient();
			using (Pipeline.BeginLoggingScope("BlobLeaseClient", "ChangeInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientDiagnostics.CreateScope("BlobLeaseClient.Change");
				try
				{
					scope.Start();
					string text = null;
					if (conditions != null && conditions.GetType() == typeof(BlobLeaseRequestConditions))
					{
						text = ((BlobLeaseRequestConditions)conditions).TagConditions;
					}
					Response<BlobLease> response;
					if (BlobClient != null)
					{
						Azure.Core.ResponseWithHeaders<BlobChangeLeaseHeaders> responseWithHeaders;
						if (async)
						{
							BlobRestClient blobRestClient = BlobClient.BlobRestClient;
							string leaseId = LeaseId;
							DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
							DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
							string ifMatch = conditions?.IfMatch?.ToString();
							string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
							string ifTags = text;
							CancellationToken cancellationToken2 = cancellationToken;
							responseWithHeaders = await blobRestClient.ChangeLeaseAsync(leaseId, proposedId, null, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
						}
						else
						{
							BlobRestClient blobRestClient2 = BlobClient.BlobRestClient;
							string leaseId2 = LeaseId;
							DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
							DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
							string ifTags = conditions?.IfMatch?.ToString();
							string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
							string ifMatch = text;
							CancellationToken cancellationToken2 = cancellationToken;
							responseWithHeaders = blobRestClient2.ChangeLease(leaseId2, proposedId, null, ifUnmodifiedSince, ifModifiedSince, ifTags, ifNoneMatch, ifMatch, cancellationToken2);
						}
						response = Response.FromValue(responseWithHeaders.ToBlobLease(), responseWithHeaders.GetRawResponse());
					}
					else
					{
						conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "Change", "conditions");
						Azure.Core.ResponseWithHeaders<ContainerChangeLeaseHeaders> responseWithHeaders2;
						if (async)
						{
							ContainerRestClient containerRestClient = BlobContainerClient.ContainerRestClient;
							string leaseId3 = LeaseId;
							DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
							DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
							CancellationToken cancellationToken2 = cancellationToken;
							responseWithHeaders2 = await containerRestClient.ChangeLeaseAsync(leaseId3, proposedId, null, ifModifiedSince, ifUnmodifiedSince, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
						}
						else
						{
							ContainerRestClient containerRestClient2 = BlobContainerClient.ContainerRestClient;
							string leaseId4 = LeaseId;
							DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
							DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
							CancellationToken cancellationToken2 = cancellationToken;
							responseWithHeaders2 = containerRestClient2.ChangeLease(leaseId4, proposedId, null, ifUnmodifiedSince, ifModifiedSince, cancellationToken2);
						}
						response = Response.FromValue(responseWithHeaders2.ToBlobLease(), responseWithHeaders2.GetRawResponse());
					}
					LeaseId = response.Value.LeaseId;
					return response;
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobLease> Break(TimeSpan? breakPeriod = null, RequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return BreakInternal(breakPeriod, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobLease>> BreakAsync(TimeSpan? breakPeriod = null, RequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await BreakInternal(breakPeriod, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobLease>> BreakInternal(TimeSpan? breakPeriod, RequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			EnsureClient();
			long? num = (breakPeriod.HasValue ? new long?(Convert.ToInt64(breakPeriod.Value.TotalSeconds)) : ((long?)null));
			using (Pipeline.BeginLoggingScope("BlobLeaseClient", "BreakInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientDiagnostics.CreateScope("BlobLeaseClient.Break");
				try
				{
					scope.Start();
					string text = null;
					if (conditions != null && conditions.GetType() == typeof(BlobLeaseRequestConditions))
					{
						text = ((BlobLeaseRequestConditions)conditions).TagConditions;
					}
					if (BlobClient != null)
					{
						Azure.Core.ResponseWithHeaders<BlobBreakLeaseHeaders> responseWithHeaders;
						if (async)
						{
							BlobRestClient blobRestClient = BlobClient.BlobRestClient;
							long? breakPeriod2 = num;
							DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
							DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
							string ifMatch = conditions?.IfMatch?.ToString();
							string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
							string ifTags = text;
							CancellationToken cancellationToken2 = cancellationToken;
							responseWithHeaders = await blobRestClient.BreakLeaseAsync(null, breakPeriod2, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
						}
						else
						{
							BlobRestClient blobRestClient2 = BlobClient.BlobRestClient;
							long? breakPeriod2 = num;
							DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
							DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
							string ifTags = conditions?.IfMatch?.ToString();
							string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
							string ifMatch = text;
							CancellationToken cancellationToken2 = cancellationToken;
							responseWithHeaders = blobRestClient2.BreakLease(null, breakPeriod2, ifUnmodifiedSince, ifModifiedSince, ifTags, ifNoneMatch, ifMatch, cancellationToken2);
						}
						return Response.FromValue(responseWithHeaders.ToBlobLease(), responseWithHeaders.GetRawResponse());
					}
					conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "Break", "conditions");
					Azure.Core.ResponseWithHeaders<ContainerBreakLeaseHeaders> responseWithHeaders2;
					if (async)
					{
						ContainerRestClient containerRestClient = BlobContainerClient.ContainerRestClient;
						long? breakPeriod2 = num;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders2 = await containerRestClient.BreakLeaseAsync(null, breakPeriod2, ifModifiedSince, ifUnmodifiedSince, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						ContainerRestClient containerRestClient2 = BlobContainerClient.ContainerRestClient;
						long? breakPeriod2 = num;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders2 = containerRestClient2.BreakLease(null, breakPeriod2, ifUnmodifiedSince, ifModifiedSince, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders2.ToBlobLease(), responseWithHeaders2.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}
	}
	public class BlockBlobClient : BlobBaseClient
	{
		private readonly BlockBlobRestClient _blockBlobRestClient;

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual int BlockBlobMaxUploadBlobBytes
		{
			get
			{
				if (ClientConfiguration.Version >= BlobClientOptions.ServiceVersion.V2019_12_12)
				{
					return int.MaxValue;
				}
				return 268435456;
			}
		}

		public virtual long BlockBlobMaxUploadBlobLongBytes
		{
			get
			{
				if (ClientConfiguration.Version >= BlobClientOptions.ServiceVersion.V2019_12_12)
				{
					return 5242880000L;
				}
				return 268435456L;
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual int BlockBlobMaxStageBlockBytes
		{
			get
			{
				if (ClientConfiguration.Version >= BlobClientOptions.ServiceVersion.V2019_12_12)
				{
					return int.MaxValue;
				}
				return 104857600;
			}
		}

		public virtual long BlockBlobMaxStageBlockLongBytes
		{
			get
			{
				if (ClientConfiguration.Version >= BlobClientOptions.ServiceVersion.V2019_12_12)
				{
					return 4194304000L;
				}
				return 104857600L;
			}
		}

		public virtual int BlockBlobMaxBlocks => 50000;

		internal virtual BlockBlobRestClient BlockBlobRestClient => _blockBlobRestClient;

		protected BlockBlobClient()
		{
		}

		public BlockBlobClient(string connectionString, string containerName, string blobName)
			: base(connectionString, containerName, blobName)
		{
			_blockBlobRestClient = BuildBlockBlobRestClient(_uri);
		}

		public BlockBlobClient(string connectionString, string blobContainerName, string blobName, BlobClientOptions options)
			: base(connectionString, blobContainerName, blobName, options)
		{
			_blockBlobRestClient = BuildBlockBlobRestClient(_uri);
			AssertNoClientSideEncryption(options);
		}

		public BlockBlobClient(Uri blobUri, BlobClientOptions options = null)
			: base(blobUri, options)
		{
			_blockBlobRestClient = BuildBlockBlobRestClient(blobUri);
			AssertNoClientSideEncryption(options);
		}

		public BlockBlobClient(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options = null)
			: base(blobUri, credential, options)
		{
			_blockBlobRestClient = BuildBlockBlobRestClient(blobUri);
			AssertNoClientSideEncryption(options);
		}

		public BlockBlobClient(Uri blobUri, AzureSasCredential credential, BlobClientOptions options = null)
			: base(blobUri, credential, options)
		{
			_blockBlobRestClient = BuildBlockBlobRestClient(blobUri);
			AssertNoClientSideEncryption(options);
		}

		public BlockBlobClient(Uri blobUri, TokenCredential credential, BlobClientOptions options = null)
			: base(blobUri, credential, options)
		{
			_blockBlobRestClient = BuildBlockBlobRestClient(blobUri);
			AssertNoClientSideEncryption(options);
		}

		internal BlockBlobClient(Uri blobUri, BlobClientConfiguration clientConfiguration)
			: base(blobUri, clientConfiguration, null)
		{
			_blockBlobRestClient = BuildBlockBlobRestClient(blobUri);
		}

		internal BlockBlobClient(Uri blobUri, BlobClientConfiguration clientConfiguration, ClientSideEncryptionOptions clientSideEncryption)
			: base(blobUri, clientConfiguration, clientSideEncryption)
		{
			_blockBlobRestClient = BuildBlockBlobRestClient(blobUri);
		}

		protected static BlockBlobClient CreateClient(Uri blobUri, BlobClientOptions options, HttpPipeline pipeline)
		{
			return new BlockBlobClient(blobUri, new BlobClientConfiguration(pipeline, (StorageSharedKeyCredential)null, new Azure.Core.Pipeline.ClientDiagnostics(options), options.Version, options.CustomerProvidedKey, options.TransferValidation, (string)null, options.TrimBlobNameSlashes));
		}

		private static void AssertNoClientSideEncryption(BlobClientOptions options)
		{
			if (options?._clientSideEncryptionOptions != null)
			{
				throw Azure.Storage.Errors.ClientSideEncryption.TypeNotSupported(typeof(BlockBlobClient));
			}
		}

		private BlockBlobRestClient BuildBlockBlobRestClient(Uri blobUri)
		{
			return new BlockBlobRestClient(_clientConfiguration.ClientDiagnostics, _clientConfiguration.Pipeline, blobUri.AbsoluteUri, _clientConfiguration.Version.ToVersionString());
		}

		public new BlockBlobClient WithSnapshot(string snapshot)
		{
			return (BlockBlobClient)WithSnapshotCore(snapshot);
		}

		public new BlockBlobClient WithVersion(string versionId)
		{
			return new BlockBlobClient(new BlobUriBuilder(Uri)
			{
				VersionId = versionId
			}.ToUri(), ClientConfiguration);
		}

		protected sealed override BlobBaseClient WithSnapshotCore(string snapshot)
		{
			return new BlockBlobClient(new BlobUriBuilder(Uri)
			{
				Snapshot = snapshot
			}.ToUri(), ClientConfiguration);
		}

		public new BlockBlobClient WithCustomerProvidedKey(CustomerProvidedKey? customerProvidedKey)
		{
			BlobClientConfiguration blobClientConfiguration = BlobClientConfiguration.DeepCopy(ClientConfiguration);
			blobClientConfiguration.CustomerProvidedKey = customerProvidedKey;
			return new BlockBlobClient(Uri, blobClientConfiguration);
		}

		public new BlockBlobClient WithEncryptionScope(string encryptionScope)
		{
			BlobClientConfiguration blobClientConfiguration = BlobClientConfiguration.DeepCopy(ClientConfiguration);
			blobClientConfiguration.EncryptionScope = encryptionScope;
			return new BlockBlobClient(Uri, blobClientConfiguration);
		}

		public virtual Response<BlobContentInfo> Upload(Stream content, BlobUploadOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetPartitionedUploader(options?.TransferOptions ?? default(StorageTransferOptions), options?.TransferValidation ?? ClientConfiguration.TransferValidation.Upload, null, "BlockBlobClient.Upload").UploadInternal(content, null, options, options.ProgressHandler, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContentInfo>> UploadAsync(Stream content, BlobUploadOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetPartitionedUploader(options?.TransferOptions ?? default(StorageTransferOptions), options?.TransferValidation ?? ClientConfiguration.TransferValidation.Upload, null, "BlockBlobClient.Upload").UploadInternal(content, null, options, options.ProgressHandler, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobContentInfo> Upload(Stream content, BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, BlobRequestConditions conditions = null, AccessTier? accessTier = null, IProgress<long> progressHandler = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return Upload(content, new BlobUploadOptions
			{
				HttpHeaders = httpHeaders,
				Metadata = metadata,
				Conditions = conditions,
				AccessTier = accessTier,
				ProgressHandler = progressHandler
			}, cancellationToken);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobContentInfo>> UploadAsync(Stream content, BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, BlobRequestConditions conditions = null, AccessTier? accessTier = null, IProgress<long> progressHandler = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await UploadAsync(content, new BlobUploadOptions
			{
				HttpHeaders = httpHeaders,
				Metadata = metadata,
				Conditions = conditions,
				AccessTier = accessTier,
				ProgressHandler = progressHandler
			}, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal virtual async Task<Response<BlobContentInfo>> UploadInternal(Stream content, BlobHttpHeaders blobHttpHeaders, IDictionary<string, string> metadata, IDictionary<string, string> tags, BlobRequestConditions conditions, AccessTier? accessTier, BlobImmutabilityPolicy immutabilityPolicy, bool? legalHold, IProgress<long> progressHandler, UploadTransferValidationOptions transferValidationOverride, string operationName, bool async, CancellationToken cancellationToken)
		{
			UploadTransferValidationOptions options = transferValidationOverride ?? ClientConfiguration.TransferValidation.Upload;
			content = content?.WithNoDispose().WithProgress(progressHandler);
			if (operationName == null)
			{
				operationName = "BlockBlobClient.Upload";
			}
			Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope(operationName);
			conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "Upload", "conditions");
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlockBlobClient", "UploadInternal"))
			{
				_ = 1;
				try
				{
					scope.Start();
					Azure.Storage.Errors.VerifyStreamPosition(content, "content");
					ContentHasher.GetHashResult getHashResult = await ContentHasher.GetHashOrDefaultInternal(content, options, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					content = content?.WithNoDispose().WithProgress(progressHandler);
					using DisposableBucket disposableBucket = new DisposableBucket();
					if (ClientSideEncryption != null)
					{
						disposableBucket.Add(Azure.Storage.Shared.StorageExtensions.CreateClientSideEncryptionScope(ClientSideEncryption.EncryptionVersion));
					}
					Azure.Core.ResponseWithHeaders<BlockBlobUploadHeaders> responseWithHeaders;
					if (async)
					{
						BlockBlobRestClient blockBlobRestClient = BlockBlobRestClient;
						long valueOrDefault = (content?.Length - content?.Position).GetValueOrDefault();
						Stream body = content;
						string blobContentType = blobHttpHeaders?.ContentType;
						string blobContentEncoding = blobHttpHeaders?.ContentEncoding;
						string blobContentLanguage = blobHttpHeaders?.ContentLanguage;
						byte[] blobContentMD = blobHttpHeaders?.ContentHash;
						string blobCacheControl = blobHttpHeaders?.CacheControl;
						IDictionary<string, string> metadata2 = metadata;
						string leaseId = conditions?.LeaseId;
						string blobContentDisposition = blobHttpHeaders?.ContentDisposition;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						AccessTier? tier = accessTier;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						string blobTagsString = tags?.ToTagsString();
						DateTimeOffset? immutabilityPolicyExpiry = immutabilityPolicy?.ExpiresOn;
						BlobImmutabilityPolicyMode? immutabilityPolicyMode = immutabilityPolicy?.PolicyMode;
						bool? legalHold2 = legalHold;
						byte[] transactionalContentMD = getHashResult?.MD5AsArray;
						byte[] transactionalContentCrc = getHashResult?.StorageCrc64AsArray;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blockBlobRestClient.UploadAsync(valueOrDefault, body, null, transactionalContentMD, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD, blobCacheControl, metadata2, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha, encryptionAlgorithm, encryptionScope, tier, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold2, transactionalContentCrc, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlockBlobRestClient blockBlobRestClient2 = BlockBlobRestClient;
						long valueOrDefault2 = (content?.Length - content?.Position).GetValueOrDefault();
						Stream body2 = content;
						string blobTagsString = blobHttpHeaders?.ContentType;
						string ifTags = blobHttpHeaders?.ContentEncoding;
						string ifNoneMatch = blobHttpHeaders?.ContentLanguage;
						byte[] transactionalContentCrc = blobHttpHeaders?.ContentHash;
						string ifMatch = blobHttpHeaders?.CacheControl;
						IDictionary<string, string> metadata2 = metadata;
						string encryptionScope = conditions?.LeaseId;
						string encryptionKeySha = blobHttpHeaders?.ContentDisposition;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string blobContentDisposition = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string leaseId = ClientConfiguration.EncryptionScope;
						AccessTier? tier = accessTier;
						DateTimeOffset? immutabilityPolicyExpiry = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string blobCacheControl = conditions?.IfMatch?.ToString();
						string blobContentLanguage = conditions?.IfNoneMatch?.ToString();
						string blobContentEncoding = conditions?.TagConditions;
						string blobContentType = tags?.ToTagsString();
						DateTimeOffset? ifModifiedSince = immutabilityPolicy?.ExpiresOn;
						BlobImmutabilityPolicyMode? immutabilityPolicyMode = immutabilityPolicy?.PolicyMode;
						bool? legalHold2 = legalHold;
						byte[] transactionalContentMD = getHashResult?.MD5AsArray;
						byte[] blobContentMD = getHashResult?.StorageCrc64AsArray;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blockBlobRestClient2.Upload(valueOrDefault2, body2, null, transactionalContentMD, blobTagsString, ifTags, ifNoneMatch, transactionalContentCrc, ifMatch, metadata2, encryptionScope, encryptionKeySha, encryptionKey, blobContentDisposition, encryptionAlgorithm, leaseId, tier, immutabilityPolicyExpiry, ifUnmodifiedSince, blobCacheControl, blobContentLanguage, blobContentEncoding, blobContentType, ifModifiedSince, immutabilityPolicyMode, legalHold2, blobContentMD, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobContentInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlockInfo> StageBlock(string base64BlockId, Stream content, byte[] transactionalContentHash, BlobRequestConditions conditions, IProgress<long> progressHandler, CancellationToken cancellationToken)
		{
			return StageBlockInternal(base64BlockId, content, transactionalContentHash.ToValidationOptions(), conditions, progressHandler, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlockInfo>> StageBlockAsync(string base64BlockId, Stream content, byte[] transactionalContentHash, BlobRequestConditions conditions, IProgress<long> progressHandler, CancellationToken cancellationToken)
		{
			return await StageBlockInternal(base64BlockId, content, transactionalContentHash.ToValidationOptions(), conditions, progressHandler, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<BlockInfo> StageBlock(string base64BlockId, Stream content, BlockBlobStageBlockOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return StageBlockInternal(base64BlockId, content, options?.TransferValidation, options?.Conditions, options?.ProgressHandler, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlockInfo>> StageBlockAsync(string base64BlockId, Stream content, BlockBlobStageBlockOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await StageBlockInternal(base64BlockId, content, options?.TransferValidation, options?.Conditions, options?.ProgressHandler, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal virtual async Task<Response<BlockInfo>> StageBlockInternal(string base64BlockId, Stream content, UploadTransferValidationOptions transferValidationOverride, BlobRequestConditions conditions, IProgress<long> progressHandler, bool async, CancellationToken cancellationToken)
		{
			UploadTransferValidationOptions options = transferValidationOverride ?? ClientConfiguration.TransferValidation.Upload;
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlockBlobClient", "StageBlockInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlockBlobClient.StageBlock");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.TagConditions | BlobRequestConditionProperty.IfModifiedSince | BlobRequestConditionProperty.IfUnmodifiedSince | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "StageBlock", "conditions");
				try
				{
					scope.Start();
					Azure.Storage.Errors.VerifyStreamPosition(content, "content");
					ContentHasher.GetHashResult getHashResult = await ContentHasher.GetHashOrDefaultInternal(content, options, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					content = content.WithNoDispose().WithProgress(progressHandler);
					Azure.Core.ResponseWithHeaders<BlockBlobStageBlockHeaders> responseWithHeaders;
					if (async)
					{
						BlockBlobRestClient blockBlobRestClient = BlockBlobRestClient;
						long valueOrDefault = (content?.Length - content?.Position).GetValueOrDefault();
						Stream body = content;
						byte[] array = getHashResult?.StorageCrc64AsArray;
						byte[] transactionalContentMD = getHashResult?.MD5AsArray;
						byte[] transactionalContentCrc = array;
						string leaseId = conditions?.LeaseId;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blockBlobRestClient.StageBlockAsync(base64BlockId, valueOrDefault, body, transactionalContentMD, transactionalContentCrc, null, leaseId, encryptionKey, encryptionKeySha, encryptionAlgorithm, encryptionScope, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlockBlobRestClient blockBlobRestClient2 = BlockBlobRestClient;
						long valueOrDefault2 = (content?.Length - content?.Position).GetValueOrDefault();
						Stream body2 = content;
						byte[] array = getHashResult?.StorageCrc64AsArray;
						byte[] transactionalContentMD2 = getHashResult?.MD5AsArray;
						byte[] transactionalContentCrc2 = array;
						string encryptionScope = conditions?.LeaseId;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string leaseId = ClientConfiguration.EncryptionScope;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blockBlobRestClient2.StageBlock(base64BlockId, valueOrDefault2, body2, transactionalContentMD2, transactionalContentCrc2, null, encryptionScope, encryptionKeySha, encryptionKey, encryptionAlgorithm, leaseId, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlockInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlockInfo> StageBlockFromUri(Uri sourceUri, string base64BlockId, StageBlockFromUriOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return StageBlockFromUriInternal(sourceUri, base64BlockId, options?.SourceRange ?? default(HttpRange), options?.SourceContentHash, options?.SourceConditions, options?.DestinationConditions, options?.SourceAuthentication, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlockInfo>> StageBlockFromUriAsync(Uri sourceUri, string base64BlockId, StageBlockFromUriOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await StageBlockFromUriInternal(sourceUri, base64BlockId, options?.SourceRange ?? default(HttpRange), options?.SourceContentHash, options?.SourceConditions, options?.DestinationConditions, options?.SourceAuthentication, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlockInfo> StageBlockFromUri(Uri sourceUri, string base64BlockId, HttpRange sourceRange, byte[] sourceContentHash, RequestConditions sourceConditions, BlobRequestConditions conditions, CancellationToken cancellationToken)
		{
			return StageBlockFromUriInternal(sourceUri, base64BlockId, sourceRange, sourceContentHash, sourceConditions, conditions, null, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlockInfo>> StageBlockFromUriAsync(Uri sourceUri, string base64BlockId, HttpRange sourceRange, byte[] sourceContentHash, RequestConditions sourceConditions, BlobRequestConditions conditions, CancellationToken cancellationToken)
		{
			return await StageBlockFromUriInternal(sourceUri, base64BlockId, sourceRange, sourceContentHash, sourceConditions, conditions, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlockInfo>> StageBlockFromUriInternal(Uri sourceUri, string base64BlockId, HttpRange sourceRange, byte[] sourceContentHash, RequestConditions sourceConditions, BlobRequestConditions conditions, HttpAuthorization sourceAuthentication, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlockBlobClient", "StageBlockFromUriInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlockBlobClient.StageBlockFromUri");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.TagConditions | BlobRequestConditionProperty.IfModifiedSince | BlobRequestConditionProperty.IfUnmodifiedSince | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "StageBlockFromUri", "conditions");
				sourceConditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "StageBlockFromUri", "sourceConditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlockBlobStageBlockFromURLHeaders> responseWithHeaders;
					if (async)
					{
						BlockBlobRestClient blockBlobRestClient = BlockBlobRestClient;
						long contentLength = 0L;
						string absoluteUri = sourceUri.AbsoluteUri;
						string sourceRange2 = sourceRange.ToString();
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						string leaseId = conditions?.LeaseId;
						DateTimeOffset? sourceIfModifiedSince = sourceConditions?.IfModifiedSince;
						DateTimeOffset? sourceIfUnmodifiedSince = sourceConditions?.IfUnmodifiedSince;
						string sourceIfMatch = sourceConditions?.IfMatch?.ToString();
						string sourceIfNoneMatch = sourceConditions?.IfNoneMatch?.ToString();
						string copySourceAuthorization = sourceAuthentication?.ToString();
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blockBlobRestClient.StageBlockFromURLAsync(base64BlockId, contentLength, absoluteUri, sourceRange2, sourceContentHash, null, null, encryptionKey, encryptionKeySha, encryptionAlgorithm, encryptionScope, leaseId, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, copySourceAuthorization, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlockBlobRestClient blockBlobRestClient2 = BlockBlobRestClient;
						long contentLength2 = 0L;
						string absoluteUri2 = sourceUri.AbsoluteUri;
						string sourceRange3 = sourceRange.ToString();
						string copySourceAuthorization = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string sourceIfNoneMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string sourceIfMatch = ClientConfiguration.EncryptionScope;
						string leaseId = conditions?.LeaseId;
						DateTimeOffset? sourceIfUnmodifiedSince = sourceConditions?.IfModifiedSince;
						DateTimeOffset? sourceIfModifiedSince = sourceConditions?.IfUnmodifiedSince;
						string encryptionScope = sourceConditions?.IfMatch?.ToString();
						string encryptionKeySha = sourceConditions?.IfNoneMatch?.ToString();
						string encryptionKey = sourceAuthentication?.ToString();
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blockBlobRestClient2.StageBlockFromURL(base64BlockId, contentLength2, absoluteUri2, sourceRange3, sourceContentHash, null, null, copySourceAuthorization, sourceIfNoneMatch, encryptionAlgorithm, sourceIfMatch, leaseId, sourceIfUnmodifiedSince, sourceIfModifiedSince, encryptionScope, encryptionKeySha, encryptionKey, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlockInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobContentInfo> CommitBlockList(IEnumerable<string> base64BlockIds, CommitBlockListOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CommitBlockListInternal(base64BlockIds, options?.HttpHeaders, options?.Metadata, options?.Tags, options?.Conditions, options?.AccessTier, options?.ImmutabilityPolicy, options?.LegalHold, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobContentInfo> CommitBlockList(IEnumerable<string> base64BlockIds, BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, BlobRequestConditions conditions = null, AccessTier? accessTier = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CommitBlockListInternal(base64BlockIds, httpHeaders, metadata, null, conditions, accessTier, null, null, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContentInfo>> CommitBlockListAsync(IEnumerable<string> base64BlockIds, CommitBlockListOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await CommitBlockListInternal(base64BlockIds, options?.HttpHeaders, options?.Metadata, options?.Tags, options?.Conditions, options?.AccessTier, options?.ImmutabilityPolicy, options?.LegalHold, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobContentInfo>> CommitBlockListAsync(IEnumerable<string> base64BlockIds, BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, BlobRequestConditions conditions = null, AccessTier? accessTier = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await CommitBlockListInternal(base64BlockIds, httpHeaders, metadata, null, conditions, accessTier, null, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal virtual async Task<Response<BlobContentInfo>> CommitBlockListInternal(IEnumerable<string> base64BlockIds, BlobHttpHeaders blobHttpHeaders, IDictionary<string, string> metadata, IDictionary<string, string> tags, BlobRequestConditions conditions, AccessTier? accessTier, BlobImmutabilityPolicy immutabilityPolicy, bool? legalHold, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlockBlobClient", "CommitBlockListInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlockBlobClient.CommitBlockList");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "CommitBlockList", "conditions");
				try
				{
					scope.Start();
					BlockLookupList blocks = new BlockLookupList
					{
						Latest = base64BlockIds.ToList()
					};
					using DisposableBucket disposableBucket = new DisposableBucket();
					if (ClientSideEncryption != null)
					{
						disposableBucket.Add(Azure.Storage.Shared.StorageExtensions.CreateClientSideEncryptionScope(ClientSideEncryption.EncryptionVersion));
					}
					Azure.Core.ResponseWithHeaders<BlockBlobCommitBlockListHeaders> responseWithHeaders;
					if (async)
					{
						BlockBlobRestClient blockBlobRestClient = BlockBlobRestClient;
						string blobCacheControl = blobHttpHeaders?.CacheControl;
						string blobContentType = blobHttpHeaders?.ContentType;
						string blobContentEncoding = blobHttpHeaders?.ContentEncoding;
						string blobContentLanguage = blobHttpHeaders?.ContentLanguage;
						byte[] blobContentMD = blobHttpHeaders?.ContentHash;
						IDictionary<string, string> metadata2 = metadata;
						string leaseId = conditions?.LeaseId;
						string blobContentDisposition = blobHttpHeaders?.ContentDisposition;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						AccessTier? tier = accessTier;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						string blobTagsString = tags?.ToTagsString();
						DateTimeOffset? immutabilityPolicyExpiry = immutabilityPolicy?.ExpiresOn;
						BlobImmutabilityPolicyMode? immutabilityPolicyMode = immutabilityPolicy?.PolicyMode;
						bool? legalHold2 = legalHold;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blockBlobRestClient.CommitBlockListAsync(blocks, null, blobCacheControl, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD, null, null, metadata2, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha, encryptionAlgorithm, encryptionScope, tier, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold2, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlockBlobRestClient blockBlobRestClient2 = BlockBlobRestClient;
						string blobTagsString = blobHttpHeaders?.CacheControl;
						string ifTags = blobHttpHeaders?.ContentType;
						string ifNoneMatch = blobHttpHeaders?.ContentEncoding;
						string ifMatch = blobHttpHeaders?.ContentLanguage;
						byte[] blobContentMD = blobHttpHeaders?.ContentHash;
						IDictionary<string, string> metadata2 = metadata;
						string encryptionScope = conditions?.LeaseId;
						string encryptionKeySha = blobHttpHeaders?.ContentDisposition;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string blobContentDisposition = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string leaseId = ClientConfiguration.EncryptionScope;
						AccessTier? tier = accessTier;
						DateTimeOffset? immutabilityPolicyExpiry = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string blobContentLanguage = conditions?.IfMatch?.ToString();
						string blobContentEncoding = conditions?.IfNoneMatch?.ToString();
						string blobContentType = conditions?.TagConditions;
						string blobCacheControl = tags?.ToTagsString();
						DateTimeOffset? ifModifiedSince = immutabilityPolicy?.ExpiresOn;
						BlobImmutabilityPolicyMode? immutabilityPolicyMode = immutabilityPolicy?.PolicyMode;
						bool? legalHold2 = legalHold;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blockBlobRestClient2.CommitBlockList(blocks, null, blobTagsString, ifTags, ifNoneMatch, ifMatch, blobContentMD, null, null, metadata2, encryptionScope, encryptionKeySha, encryptionKey, blobContentDisposition, encryptionAlgorithm, leaseId, tier, immutabilityPolicyExpiry, ifUnmodifiedSince, blobContentLanguage, blobContentEncoding, blobContentType, blobCacheControl, ifModifiedSince, immutabilityPolicyMode, legalHold2, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobContentInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlockList> GetBlockList(BlockListTypes blockListTypes = BlockListTypes.All, string snapshot = null, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetBlockListInternal(blockListTypes, snapshot, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlockList>> GetBlockListAsync(BlockListTypes blockListTypes = BlockListTypes.All, string snapshot = null, BlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetBlockListInternal(blockListTypes, snapshot, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlockList>> GetBlockListInternal(BlockListTypes blockListTypes, string snapshot, BlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlockBlobClient", "GetBlockListInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlockBlobClient.GetBlockList");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfModifiedSince | BlobRequestConditionProperty.IfUnmodifiedSince | BlobRequestConditionProperty.IfMatch | BlobRequestConditionProperty.IfNoneMatch, "GetBlockList", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlockList, BlockBlobGetBlockListHeaders> responseWithHeaders;
					if (async)
					{
						BlockBlobRestClient blockBlobRestClient = BlockBlobRestClient;
						BlockListType listType = blockListTypes.ToBlockListType();
						string leaseId = conditions?.LeaseId;
						string ifTags = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blockBlobRestClient.GetBlockListAsync(listType, snapshot, null, leaseId, ifTags, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlockBlobRestClient blockBlobRestClient2 = BlockBlobRestClient;
						BlockListType listType2 = blockListTypes.ToBlockListType();
						string ifTags = conditions?.LeaseId;
						string leaseId = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blockBlobRestClient2.GetBlockList(listType2, snapshot, null, ifTags, leaseId, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlockList(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<BlobDownloadInfo> Query(string querySqlExpression, BlobQueryOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return QueryInternal(querySqlExpression, options, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobDownloadInfo>> QueryAsync(string querySqlExpression, BlobQueryOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await QueryInternal(querySqlExpression, options, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobDownloadInfo>> QueryInternal(string querySqlExpression, BlobQueryOptions options, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlockBlobClient", "QueryInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlockBlobClient.Query");
				options?.Conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "Query", "Conditions");
				try
				{
					scope.Start();
					QueryRequest queryRequest = new QueryRequest
					{
						QueryType = "SQL",
						Expression = querySqlExpression,
						InputSerialization = options?.InputTextConfiguration.ToQuickQuerySerialization(isInput: true),
						OutputSerialization = options?.OutputTextConfiguration.ToQuickQuerySerialization(isInput: false)
					};
					Azure.Core.ResponseWithHeaders<Stream, BlobQueryHeaders> responseWithHeaders;
					if (async)
					{
						BlobRestClient blobRestClient = BlobRestClient;
						string leaseId = options?.Conditions?.LeaseId;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						DateTimeOffset? ifModifiedSince = options?.Conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = options?.Conditions?.IfUnmodifiedSince;
						string ifMatch = options?.Conditions?.IfMatch?.ToString();
						string ifNoneMatch = options?.Conditions?.IfNoneMatch?.ToString();
						string ifTags = options?.Conditions?.TagConditions;
						QueryRequest queryRequest2 = queryRequest;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blobRestClient.QueryAsync(null, null, leaseId, encryptionKey, encryptionKeySha, encryptionAlgorithm, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, queryRequest2, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlobRestClient blobRestClient2 = BlobRestClient;
						string ifTags = options?.Conditions?.LeaseId;
						string ifNoneMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string ifMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						DateTimeOffset? ifUnmodifiedSince = options?.Conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = options?.Conditions?.IfUnmodifiedSince;
						string encryptionKeySha = options?.Conditions?.IfMatch?.ToString();
						string encryptionKey = options?.Conditions?.IfNoneMatch?.ToString();
						string leaseId = options?.Conditions?.TagConditions;
						QueryRequest queryRequest2 = queryRequest;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blobRestClient2.Query(null, null, ifTags, ifNoneMatch, ifMatch, encryptionAlgorithm, ifUnmodifiedSince, ifModifiedSince, encryptionKeySha, encryptionKey, leaseId, queryRequest2, cancellationToken2);
					}
					Action<BlobQueryError> errorHandler = options?._errorHandler;
					Stream stream = new BlobQuickQueryStream(responseWithHeaders.Value, options?.ProgressHandler, errorHandler);
					return Response.FromValue(BlobExtensions.ToBlobDownloadInfo(responseWithHeaders, stream), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Stream OpenWrite(bool overwrite, BlockBlobOpenWriteOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return OpenWriteInternal(overwrite, options, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Stream> OpenWriteAsync(bool overwrite, BlockBlobOpenWriteOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await OpenWriteInternal(overwrite, options, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal async Task<Stream> OpenWriteInternal(bool overwrite, BlockBlobOpenWriteOptions options, bool async, CancellationToken cancellationToken)
		{
			string name = options?.OperationName ?? "BlockBlobClient.OpenWrite";
			Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope(name);
			try
			{
				scope.Start();
				if (!overwrite)
				{
					throw new ArgumentException("BlockBlobClient.OpenWrite only supports overwriting");
				}
				long position = 0L;
				Response<BlobContentInfo> response = await UploadInternal(new MemoryStream(Array.Empty<byte>()), options?.HttpHeaders, options?.Metadata, options?.Tags, options?.OpenConditions, null, null, null, null, null, null, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				BlobRequestConditions conditions = new BlobRequestConditions
				{
					IfMatch = response.Value.ETag,
					LeaseId = options?.OpenConditions?.LeaseId
				};
				return new BlockBlobWriteStream(this, options?.BufferSize ?? 4194304, position, conditions, options?.ProgressHandler, options?.HttpHeaders, options?.Metadata, options?.Tags, options?.TransferValidation ?? ClientConfiguration.TransferValidation.Upload);
			}
			catch (Exception exception)
			{
				scope.Failed(exception);
				throw;
			}
			finally
			{
				scope.Dispose();
			}
		}

		public virtual Response<BlobContentInfo> SyncUploadFromUri(Uri copySource, bool overwrite = false, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SyncUploadFromUriInternal(copySource, overwrite ? null : new BlobSyncUploadFromUriOptions
			{
				DestinationConditions = new BlobRequestConditions
				{
					IfNoneMatch = new ETag("*")
				}
			}, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContentInfo>> SyncUploadFromUriAsync(Uri copySource, bool overwrite = false, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await SyncUploadFromUriInternal(copySource, overwrite ? null : new BlobSyncUploadFromUriOptions
			{
				DestinationConditions = new BlobRequestConditions
				{
					IfNoneMatch = new ETag("*")
				}
			}, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<BlobContentInfo> SyncUploadFromUri(Uri copySource, BlobSyncUploadFromUriOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return SyncUploadFromUriInternal(copySource, options, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContentInfo>> SyncUploadFromUriAsync(Uri copySource, BlobSyncUploadFromUriOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await SyncUploadFromUriInternal(copySource, options, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal virtual async Task<Response<BlobContentInfo>> SyncUploadFromUriInternal(Uri copySource, BlobSyncUploadFromUriOptions options, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("BlockBlobClient", "SyncUploadFromUriInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("BlockBlobClient.SyncUploadFromUri");
				options?.DestinationConditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "SyncUploadFromUri", "DestinationConditions");
				options?.SourceConditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.LeaseId, "SyncUploadFromUri", "SourceConditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<BlockBlobPutBlobFromUrlHeaders> responseWithHeaders;
					if (async)
					{
						BlockBlobRestClient blockBlobRestClient = BlockBlobRestClient;
						long contentLength = 0L;
						string absoluteUri = copySource.AbsoluteUri;
						string blobContentType = options?.HttpHeaders?.ContentType;
						string blobContentEncoding = options?.HttpHeaders?.ContentEncoding;
						string blobContentLanguage = options?.HttpHeaders?.ContentLanguage;
						byte[] blobContentMD = options?.HttpHeaders?.ContentHash;
						string blobCacheControl = options?.HttpHeaders?.CacheControl;
						IDictionary<string, string> metadata = options?.Metadata;
						string leaseId = options?.DestinationConditions?.LeaseId;
						string blobContentDisposition = options?.HttpHeaders?.ContentDisposition;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						AccessTier? tier = options?.AccessTier;
						DateTimeOffset? ifModifiedSince = options?.DestinationConditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = options?.DestinationConditions?.IfUnmodifiedSince;
						string ifMatch = options?.DestinationConditions?.IfMatch?.ToString();
						string ifNoneMatch = options?.DestinationConditions?.IfNoneMatch?.ToString();
						string ifTags = options?.DestinationConditions?.TagConditions;
						DateTimeOffset? sourceIfModifiedSince = options?.SourceConditions?.IfModifiedSince;
						DateTimeOffset? sourceIfUnmodifiedSince = options?.SourceConditions?.IfUnmodifiedSince;
						string sourceIfMatch = options?.SourceConditions?.IfMatch?.ToString();
						string sourceIfNoneMatch = options?.SourceConditions?.IfNoneMatch?.ToString();
						string sourceIfTags = options?.SourceConditions?.TagConditions;
						byte[] sourceContentMD = options?.ContentHash;
						string blobTagsString = options?.Tags?.ToTagsString();
						bool? copySourceBlobProperties = options?.CopySourceBlobProperties;
						string copySourceAuthorization = options?.SourceAuthentication?.ToString();
						BlobCopySourceTagsMode? copySourceTags = options?.CopySourceTagsMode;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await blockBlobRestClient.PutBlobFromUrlAsync(contentLength, absoluteUri, null, null, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD, blobCacheControl, metadata, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha, encryptionAlgorithm, encryptionScope, tier, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, sourceIfTags, sourceContentMD, blobTagsString, copySourceBlobProperties, copySourceAuthorization, copySourceTags, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						BlockBlobRestClient blockBlobRestClient2 = BlockBlobRestClient;
						long contentLength2 = 0L;
						string absoluteUri2 = copySource.AbsoluteUri;
						string copySourceAuthorization = options?.HttpHeaders?.ContentType;
						string blobTagsString = options?.HttpHeaders?.ContentEncoding;
						string sourceIfTags = options?.HttpHeaders?.ContentLanguage;
						byte[] sourceContentMD = options?.HttpHeaders?.ContentHash;
						string sourceIfNoneMatch = options?.HttpHeaders?.CacheControl;
						IDictionary<string, string> metadata = options?.Metadata;
						string sourceIfMatch = options?.DestinationConditions?.LeaseId;
						string ifTags = options?.HttpHeaders?.ContentDisposition;
						string ifNoneMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string ifMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						AccessTier? tier = options?.AccessTier;
						DateTimeOffset? sourceIfUnmodifiedSince = options?.DestinationConditions?.IfModifiedSince;
						DateTimeOffset? sourceIfModifiedSince = options?.DestinationConditions?.IfUnmodifiedSince;
						string encryptionKeySha = options?.DestinationConditions?.IfMatch?.ToString();
						string encryptionKey = options?.DestinationConditions?.IfNoneMatch?.ToString();
						string blobContentDisposition = options?.DestinationConditions?.TagConditions;
						DateTimeOffset? ifUnmodifiedSince = options?.SourceConditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = options?.SourceConditions?.IfUnmodifiedSince;
						string leaseId = options?.SourceConditions?.IfMatch?.ToString();
						string blobCacheControl = options?.SourceConditions?.IfNoneMatch?.ToString();
						string blobContentLanguage = options?.SourceConditions?.TagConditions;
						byte[] blobContentMD = options?.ContentHash;
						string blobContentEncoding = options?.Tags?.ToTagsString();
						bool? copySourceBlobProperties = options?.CopySourceBlobProperties;
						string blobContentType = options?.SourceAuthentication?.ToString();
						BlobCopySourceTagsMode? copySourceTags = options?.CopySourceTagsMode;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = blockBlobRestClient2.PutBlobFromUrl(contentLength2, absoluteUri2, null, null, copySourceAuthorization, blobTagsString, sourceIfTags, sourceContentMD, sourceIfNoneMatch, metadata, sourceIfMatch, ifTags, ifNoneMatch, ifMatch, encryptionAlgorithm, encryptionScope, tier, sourceIfUnmodifiedSince, sourceIfModifiedSince, encryptionKeySha, encryptionKey, blobContentDisposition, ifUnmodifiedSince, ifModifiedSince, leaseId, blobCacheControl, blobContentLanguage, blobContentMD, blobContentEncoding, copySourceBlobProperties, blobContentType, copySourceTags, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobContentInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		internal PartitionedUploader<BlobUploadOptions, BlobContentInfo> GetPartitionedUploader(StorageTransferOptions transferOptions, UploadTransferValidationOptions validationOptions, ArrayPool<byte> arrayPool = null, string operationName = null)
		{
			return new PartitionedUploader<BlobUploadOptions, BlobContentInfo>(GetPartitionedUploaderBehaviors(this), transferOptions, validationOptions, arrayPool, operationName);
		}

		internal static PartitionedUploader<BlobUploadOptions, BlobContentInfo>.Behaviors GetPartitionedUploaderBehaviors(BlockBlobClient client)
		{
			return new PartitionedUploader<BlobUploadOptions, BlobContentInfo>.Behaviors
			{
				SingleUploadStreaming = async (Stream stream, BlobUploadOptions args, IProgress<long> progressHandler, UploadTransferValidationOptions validationOptions, string operationName, bool async, CancellationToken cancellationToken) => await client.UploadInternal(stream, args?.HttpHeaders, args?.Metadata, args?.Tags, args?.Conditions, args?.AccessTier, args?.ImmutabilityPolicy, args?.LegalHold, progressHandler, validationOptions, operationName, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false),
				SingleUploadBinaryData = async (BinaryData content, BlobUploadOptions args, IProgress<long> progressHandler, UploadTransferValidationOptions validationOptions, string operationName, bool async, CancellationToken cancellationToken) => await client.UploadInternal(content.ToStream(), args?.HttpHeaders, args?.Metadata, args?.Tags, args?.Conditions, args?.AccessTier, args?.ImmutabilityPolicy, args?.LegalHold, progressHandler, validationOptions, operationName, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false),
				UploadPartitionStreaming = async delegate(Stream stream, long offset, BlobUploadOptions args, IProgress<long> progressHandler, UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken)
				{
					BlobRequestConditions conditions = null;
					if (args?.Conditions != null)
					{
						conditions = new BlobRequestConditions
						{
							LeaseId = args.Conditions.LeaseId
						};
					}
					await client.StageBlockInternal(Azure.Storage.Shared.StorageExtensions.GenerateBlockId(offset), stream, validationOptions, conditions, progressHandler, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				},
				UploadPartitionBinaryData = async delegate(BinaryData content, long offset, BlobUploadOptions args, IProgress<long> progressHandler, UploadTransferValidationOptions validationOptions, bool async, CancellationToken cancellationToken)
				{
					BlobRequestConditions conditions = null;
					if (args?.Conditions != null)
					{
						conditions = new BlobRequestConditions
						{
							LeaseId = args.Conditions.LeaseId
						};
					}
					await client.StageBlockInternal(Azure.Storage.Shared.StorageExtensions.GenerateBlockId(offset), content.ToStream(), validationOptions, conditions, progressHandler, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
				},
				CommitPartitionedUpload = async (List<(long Offset, long Size)> partitions, BlobUploadOptions args, bool async, CancellationToken cancellationToken) => await client.CommitBlockListInternal(partitions.Select(((long Offset, long Size) partition) => Azure.Storage.Shared.StorageExtensions.GenerateBlockId(partition.Offset)), args?.HttpHeaders, args?.Metadata, args?.Tags, args?.Conditions, args?.AccessTier, args?.ImmutabilityPolicy, args?.LegalHold, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false),
				Scope = (string operationName) => client.ClientConfiguration.ClientDiagnostics.CreateScope(operationName ?? "Azure.Storage.Blobs.BlobClient.Upload")
			};
		}
	}
	public class PageBlobClient : BlobBaseClient
	{
		private readonly PageBlobRestClient _pageBlobRestClient;

		public virtual int PageBlobPageBytes => 512;

		public virtual int PageBlobMaxUploadPagesBytes => 4194304;

		internal virtual PageBlobRestClient PageBlobRestClient => _pageBlobRestClient;

		protected PageBlobClient()
		{
		}

		public PageBlobClient(string connectionString, string blobContainerName, string blobName)
			: base(connectionString, blobContainerName, blobName)
		{
			_pageBlobRestClient = BuildPageBlobRestClient(_uri);
		}

		public PageBlobClient(string connectionString, string blobContainerName, string blobName, BlobClientOptions options)
			: base(connectionString, blobContainerName, blobName, options)
		{
			_pageBlobRestClient = BuildPageBlobRestClient(_uri);
			AssertNoClientSideEncryption(options);
		}

		public PageBlobClient(Uri blobUri, BlobClientOptions options = null)
			: base(blobUri, options)
		{
			_pageBlobRestClient = BuildPageBlobRestClient(blobUri);
			AssertNoClientSideEncryption(options);
		}

		public PageBlobClient(Uri blobUri, StorageSharedKeyCredential credential, BlobClientOptions options = null)
			: base(blobUri, credential, options)
		{
			_pageBlobRestClient = BuildPageBlobRestClient(blobUri);
			AssertNoClientSideEncryption(options);
		}

		public PageBlobClient(Uri blobUri, AzureSasCredential credential, BlobClientOptions options = null)
			: base(blobUri, credential, options)
		{
			_pageBlobRestClient = BuildPageBlobRestClient(blobUri);
			AssertNoClientSideEncryption(options);
		}

		public PageBlobClient(Uri blobUri, TokenCredential credential, BlobClientOptions options = null)
			: base(blobUri, credential, options)
		{
			_pageBlobRestClient = BuildPageBlobRestClient(blobUri);
			AssertNoClientSideEncryption(options);
		}

		internal PageBlobClient(Uri blobUri, BlobClientConfiguration clientConfiguration)
			: base(blobUri, clientConfiguration, null)
		{
			_pageBlobRestClient = BuildPageBlobRestClient(blobUri);
		}

		private static void AssertNoClientSideEncryption(BlobClientOptions options)
		{
			if (options?._clientSideEncryptionOptions != null)
			{
				throw Azure.Storage.Errors.ClientSideEncryption.TypeNotSupported(typeof(PageBlobClient));
			}
		}

		private PageBlobRestClient BuildPageBlobRestClient(Uri blobUri)
		{
			return new PageBlobRestClient(_clientConfiguration.ClientDiagnostics, _clientConfiguration.Pipeline, blobUri.AbsoluteUri, _clientConfiguration.Version.ToVersionString());
		}

		public new PageBlobClient WithSnapshot(string snapshot)
		{
			return (PageBlobClient)WithSnapshotCore(snapshot);
		}

		protected sealed override BlobBaseClient WithSnapshotCore(string snapshot)
		{
			return new PageBlobClient(new BlobUriBuilder(Uri)
			{
				Snapshot = snapshot
			}.ToUri(), ClientConfiguration);
		}

		public new PageBlobClient WithVersion(string versionId)
		{
			return new PageBlobClient(new BlobUriBuilder(Uri)
			{
				VersionId = versionId
			}.ToUri(), ClientConfiguration);
		}

		public new PageBlobClient WithCustomerProvidedKey(CustomerProvidedKey? customerProvidedKey)
		{
			BlobClientConfiguration blobClientConfiguration = BlobClientConfiguration.DeepCopy(ClientConfiguration);
			blobClientConfiguration.CustomerProvidedKey = customerProvidedKey;
			return new PageBlobClient(Uri, blobClientConfiguration);
		}

		public new PageBlobClient WithEncryptionScope(string encryptionScope)
		{
			BlobClientConfiguration blobClientConfiguration = BlobClientConfiguration.DeepCopy(ClientConfiguration);
			blobClientConfiguration.EncryptionScope = encryptionScope;
			return new PageBlobClient(Uri, blobClientConfiguration);
		}

		public virtual Response<BlobContentInfo> Create(long size, PageBlobCreateOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CreateInternal(size, options?.SequenceNumber, options?.HttpHeaders, options?.Metadata, options?.Tags, options?.Conditions, options?.ImmutabilityPolicy, options?.LegalHold, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContentInfo>> CreateAsync(long size, PageBlobCreateOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await CreateInternal(size, options?.SequenceNumber, options?.HttpHeaders, options?.Metadata, options?.Tags, options?.Conditions, options?.ImmutabilityPolicy, options?.LegalHold, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobContentInfo> Create(long size, long? sequenceNumber = null, BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CreateInternal(size, sequenceNumber, httpHeaders, metadata, null, conditions, null, null, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobContentInfo>> CreateAsync(long size, long? sequenceNumber = null, BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await CreateInternal(size, sequenceNumber, httpHeaders, metadata, null, conditions, null, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<BlobContentInfo> CreateIfNotExists(long size, PageBlobCreateOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CreateIfNotExistsInternal(size, options?.SequenceNumber, options?.HttpHeaders, options?.Metadata, options?.Tags, options?.ImmutabilityPolicy, options?.LegalHold, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<BlobContentInfo>> CreateIfNotExistsAsync(long size, PageBlobCreateOptions options, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await CreateIfNotExistsInternal(size, options?.SequenceNumber, options?.HttpHeaders, options?.Metadata, options?.Tags, options?.ImmutabilityPolicy, options?.LegalHold, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<BlobContentInfo> CreateIfNotExists(long size, long? sequenceNumber = null, BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return CreateIfNotExistsInternal(size, sequenceNumber, httpHeaders, metadata, null, null, null, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<BlobContentInfo>> CreateIfNotExistsAsync(long size, long? sequenceNumber = null, BlobHttpHeaders httpHeaders = null, IDictionary<string, string> metadata = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await CreateIfNotExistsInternal(size, sequenceNumber, httpHeaders, metadata, null, null, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<BlobContentInfo>> CreateIfNotExistsInternal(long size, long? sequenceNumber, BlobHttpHeaders httpHeaders, IDictionary<string, string> metadata, IDictionary<string, string> tags, BlobImmutabilityPolicy immutabilityPolicy, bool? legalHold, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("PageBlobClient", "CreateIfNotExistsInternal"))
			{
				PageBlobRequestConditions conditions = new PageBlobRequestConditions
				{
					IfNoneMatch = new ETag("*")
				};
				try
				{
					return await CreateInternal(size, sequenceNumber, httpHeaders, metadata, tags, conditions, immutabilityPolicy, legalHold, async, cancellationToken, "PageBlobClient.CreateIfNotExists").ConfigureAwait(continueOnCapturedContext: false);
				}
				catch (RequestFailedException ex) when (ex.ErrorCode == BlobErrorCode.BlobAlreadyExists)
				{
					return null;
				}
				catch (Exception)
				{
					throw;
				}
				finally
				{
					_ = 0;
				}
			}
		}

		private async Task<Response<BlobContentInfo>> CreateInternal(long size, long? sequenceNumber, BlobHttpHeaders httpHeaders, IDictionary<string, string> metadata, IDictionary<string, string> tags, PageBlobRequestConditions conditions, BlobImmutabilityPolicy immutabilityPolicy, bool? legalHold, bool async, CancellationToken cancellationToken, string operationName = null)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("PageBlobClient", "CreateInternal"))
			{
				if (operationName == null)
				{
					operationName = "PageBlobClient.Create";
				}
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope(operationName);
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfSequenceNumberLessThan | BlobRequestConditionProperty.IfSequenceNumberLessThanOrEqual | BlobRequestConditionProperty.IfSequenceNumberEqual, "Create", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<PageBlobCreateHeaders> responseWithHeaders;
					if (async)
					{
						PageBlobRestClient pageBlobRestClient = PageBlobRestClient;
						long contentLength = 0L;
						PremiumPageBlobAccessTier? tier = null;
						string blobContentType = httpHeaders?.ContentType;
						string blobContentEncoding = httpHeaders?.ContentEncoding;
						string blobContentLanguage = httpHeaders?.ContentLanguage;
						byte[] blobContentMD = httpHeaders?.ContentHash;
						string blobCacheControl = httpHeaders?.CacheControl;
						IDictionary<string, string> metadata2 = metadata;
						string leaseId = conditions?.LeaseId;
						string blobContentDisposition = httpHeaders?.ContentDisposition;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						long? blobSequenceNumber = sequenceNumber;
						string blobTagsString = tags?.ToTagsString();
						DateTimeOffset? immutabilityPolicyExpiry = immutabilityPolicy?.ExpiresOn;
						BlobImmutabilityPolicyMode? immutabilityPolicyMode = immutabilityPolicy?.PolicyMode;
						bool? legalHold2 = legalHold;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await pageBlobRestClient.CreateAsync(contentLength, size, null, tier, blobContentType, blobContentEncoding, blobContentLanguage, blobContentMD, blobCacheControl, metadata2, leaseId, blobContentDisposition, encryptionKey, encryptionKeySha, encryptionAlgorithm, encryptionScope, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobSequenceNumber, blobTagsString, immutabilityPolicyExpiry, immutabilityPolicyMode, legalHold2, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						PageBlobRestClient pageBlobRestClient2 = PageBlobRestClient;
						long contentLength2 = 0L;
						PremiumPageBlobAccessTier? tier = null;
						string blobTagsString = httpHeaders?.ContentType;
						string ifTags = httpHeaders?.ContentEncoding;
						string ifNoneMatch = httpHeaders?.ContentLanguage;
						byte[] blobContentMD = httpHeaders?.ContentHash;
						string ifMatch = httpHeaders?.CacheControl;
						IDictionary<string, string> metadata2 = metadata;
						string encryptionScope = conditions?.LeaseId;
						string encryptionKeySha = httpHeaders?.ContentDisposition;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string blobContentDisposition = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string leaseId = ClientConfiguration.EncryptionScope;
						DateTimeOffset? immutabilityPolicyExpiry = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string blobCacheControl = conditions?.IfMatch?.ToString();
						string blobContentLanguage = conditions?.IfNoneMatch?.ToString();
						string blobContentEncoding = conditions?.TagConditions;
						long? blobSequenceNumber = sequenceNumber;
						string blobContentType = tags?.ToTagsString();
						DateTimeOffset? ifModifiedSince = immutabilityPolicy?.ExpiresOn;
						BlobImmutabilityPolicyMode? immutabilityPolicyMode = immutabilityPolicy?.PolicyMode;
						bool? legalHold2 = legalHold;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = pageBlobRestClient2.Create(contentLength2, size, null, tier, blobTagsString, ifTags, ifNoneMatch, blobContentMD, ifMatch, metadata2, encryptionScope, encryptionKeySha, encryptionKey, blobContentDisposition, encryptionAlgorithm, leaseId, immutabilityPolicyExpiry, ifUnmodifiedSince, blobCacheControl, blobContentLanguage, blobContentEncoding, blobSequenceNumber, blobContentType, ifModifiedSince, immutabilityPolicyMode, legalHold2, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobContentInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<PageInfo> UploadPages(Stream content, long offset, byte[] transactionalContentHash, PageBlobRequestConditions conditions, IProgress<long> progressHandler, CancellationToken cancellationToken)
		{
			return UploadPagesInternal(content, offset, transactionalContentHash.ToValidationOptions(), conditions, progressHandler, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<PageInfo>> UploadPagesAsync(Stream content, long offset, byte[] transactionalContentHash, PageBlobRequestConditions conditions, IProgress<long> progressHandler, CancellationToken cancellationToken)
		{
			return await UploadPagesInternal(content, offset, transactionalContentHash.ToValidationOptions(), conditions, progressHandler, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<PageInfo> UploadPages(Stream content, long offset, PageBlobUploadPagesOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return UploadPagesInternal(content, offset, options?.TransferValidation, options?.Conditions, options?.ProgressHandler, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<PageInfo>> UploadPagesAsync(Stream content, long offset, PageBlobUploadPagesOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await UploadPagesInternal(content, offset, options?.TransferValidation, options?.Conditions, options?.ProgressHandler, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		internal async Task<Response<PageInfo>> UploadPagesInternal(Stream content, long offset, UploadTransferValidationOptions transferValidationOverride, PageBlobRequestConditions conditions, IProgress<long> progressHandler, bool async, CancellationToken cancellationToken)
		{
			UploadTransferValidationOptions options = transferValidationOverride ?? ClientConfiguration.TransferValidation.Upload;
			using (ClientConfiguration.Pipeline.BeginLoggingScope("PageBlobClient", "UploadPagesInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("PageBlobClient.UploadPages");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "UploadPages", "conditions");
				try
				{
					scope.Start();
					Azure.Storage.Errors.VerifyStreamPosition(content, "content");
					ContentHasher.GetHashResult getHashResult = await ContentHasher.GetHashOrDefaultInternal(content, options, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
					content = content?.WithNoDispose().WithProgress(progressHandler);
					HttpRange httpRange = new HttpRange(offset, (content?.Length - content?.Position) ?? ((long?)null));
					Azure.Core.ResponseWithHeaders<PageBlobUploadPagesHeaders> responseWithHeaders;
					if (async)
					{
						PageBlobRestClient pageBlobRestClient = PageBlobRestClient;
						long valueOrDefault = (content?.Length - content?.Position).GetValueOrDefault();
						Stream body = content;
						byte[] array = getHashResult?.StorageCrc64AsArray;
						byte[] transactionalContentMD = getHashResult?.MD5AsArray;
						byte[] transactionalContentCrc = array;
						string range = httpRange.ToString();
						string leaseId = conditions?.LeaseId;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						long? ifSequenceNumberLessThanOrEqualTo = conditions?.IfSequenceNumberLessThanOrEqual;
						long? ifSequenceNumberLessThan = conditions?.IfSequenceNumberLessThan;
						long? ifSequenceNumberEqualTo = conditions?.IfSequenceNumberEqual;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await pageBlobRestClient.UploadPagesAsync(valueOrDefault, body, transactionalContentMD, transactionalContentCrc, null, range, leaseId, encryptionKey, encryptionKeySha, encryptionAlgorithm, encryptionScope, ifSequenceNumberLessThanOrEqualTo, ifSequenceNumberLessThan, ifSequenceNumberEqualTo, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						PageBlobRestClient pageBlobRestClient2 = PageBlobRestClient;
						long valueOrDefault2 = (content?.Length - content?.Position).GetValueOrDefault();
						Stream body2 = content;
						byte[] array = getHashResult?.StorageCrc64AsArray;
						byte[] transactionalContentMD2 = getHashResult?.MD5AsArray;
						byte[] transactionalContentCrc2 = array;
						string ifTags = httpRange.ToString();
						string ifNoneMatch = conditions?.LeaseId;
						string ifMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionScope = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionKeySha = ClientConfiguration.EncryptionScope;
						long? ifSequenceNumberLessThanOrEqualTo2 = conditions?.IfSequenceNumberLessThanOrEqual;
						long? ifSequenceNumberLessThan2 = conditions?.IfSequenceNumberLessThan;
						long? ifSequenceNumberEqualTo = conditions?.IfSequenceNumberEqual;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string encryptionKey = conditions?.IfMatch?.ToString();
						string leaseId = conditions?.IfNoneMatch?.ToString();
						string range = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = pageBlobRestClient2.UploadPages(valueOrDefault2, body2, transactionalContentMD2, transactionalContentCrc2, null, ifTags, ifNoneMatch, ifMatch, encryptionScope, encryptionAlgorithm, encryptionKeySha, ifSequenceNumberLessThanOrEqualTo2, ifSequenceNumberLessThan2, ifSequenceNumberEqualTo, ifUnmodifiedSince, ifModifiedSince, encryptionKey, leaseId, range, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToPageInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<PageInfo> ClearPages(HttpRange range, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return ClearPagesInternal(range, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<PageInfo>> ClearPagesAsync(HttpRange range, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await ClearPagesInternal(range, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<PageInfo>> ClearPagesInternal(HttpRange range, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("PageBlobClient", "ClearPagesInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("PageBlobClient.ClearPages");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "ClearPages", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<PageBlobClearPagesHeaders> responseWithHeaders;
					if (async)
					{
						PageBlobRestClient pageBlobRestClient = PageBlobRestClient;
						long contentLength = 0L;
						string range2 = range.ToString();
						string leaseId = conditions?.LeaseId;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						string encryptionScope = ClientConfiguration.EncryptionScope;
						long? ifSequenceNumberLessThanOrEqualTo = conditions?.IfSequenceNumberLessThanOrEqual;
						long? ifSequenceNumberLessThan = conditions?.IfSequenceNumberLessThan;
						long? ifSequenceNumberEqualTo = conditions?.IfSequenceNumberEqual;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await pageBlobRestClient.ClearPagesAsync(contentLength, null, range2, leaseId, encryptionKey, encryptionKeySha, null, encryptionScope, ifSequenceNumberLessThanOrEqualTo, ifSequenceNumberLessThan, ifSequenceNumberEqualTo, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						PageBlobRestClient pageBlobRestClient2 = PageBlobRestClient;
						long contentLength2 = 0L;
						string ifTags = range.ToString();
						string ifNoneMatch = conditions?.LeaseId;
						string ifMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionScope = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						string encryptionKeySha = ClientConfiguration.EncryptionScope;
						long? ifSequenceNumberEqualTo = conditions?.IfSequenceNumberLessThanOrEqual;
						long? ifSequenceNumberLessThan = conditions?.IfSequenceNumberLessThan;
						long? ifSequenceNumberLessThanOrEqualTo = conditions?.IfSequenceNumberEqual;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string encryptionKey = conditions?.IfMatch?.ToString();
						string leaseId = conditions?.IfNoneMatch?.ToString();
						string range2 = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = pageBlobRestClient2.ClearPages(contentLength2, null, ifTags, ifNoneMatch, ifMatch, encryptionScope, null, encryptionKeySha, ifSequenceNumberEqualTo, ifSequenceNumberLessThan, ifSequenceNumberLessThanOrEqualTo, ifUnmodifiedSince, ifModifiedSince, encryptionKey, leaseId, range2, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToPageInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Pageable<PageRangeItem> GetAllPageRanges(GetPageRangesOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new GetPageRangesAsyncCollection(diff: false, this, options?.Range, options?.Snapshot, null, null, options?.Conditions, "PageBlobClient.GetAllPageRanges").ToSyncCollection(cancellationToken);
		}

		public virtual AsyncPageable<PageRangeItem> GetAllPageRangesAsync(GetPageRangesOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new GetPageRangesAsyncCollection(diff: false, this, options?.Range, options?.Snapshot, null, null, options?.Conditions, "PageBlobClient.GetAllPageRanges").ToAsyncCollection(cancellationToken);
		}

		internal async Task<Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesHeaders>> GetAllPageRangesInteral(string marker, int? pageSizeHint, HttpRange? range, string snapshot, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("PageBlobClient", "GetAllPageRangesInteral"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("PageBlobClient.GetAllPageRanges");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfSequenceNumberLessThan | BlobRequestConditionProperty.IfSequenceNumberLessThanOrEqual | BlobRequestConditionProperty.IfSequenceNumberEqual, "GetPageRanges", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesHeaders> responseWithHeaders;
					if (async)
					{
						PageBlobRestClient pageBlobRestClient = PageBlobRestClient;
						string range2 = range?.ToString();
						string leaseId = conditions?.LeaseId;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						string marker2 = marker;
						int? maxresults = pageSizeHint;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await pageBlobRestClient.GetPageRangesAsync(snapshot, null, range2, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, marker2, maxresults, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						PageBlobRestClient pageBlobRestClient2 = PageBlobRestClient;
						string marker2 = range?.ToString();
						string ifTags = conditions?.LeaseId;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string ifNoneMatch = conditions?.IfMatch?.ToString();
						string ifMatch = conditions?.IfNoneMatch?.ToString();
						string leaseId = conditions?.TagConditions;
						string range2 = marker;
						int? maxresults = pageSizeHint;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = pageBlobRestClient2.GetPageRanges(snapshot, null, marker2, ifTags, ifUnmodifiedSince, ifModifiedSince, ifNoneMatch, ifMatch, leaseId, range2, maxresults, cancellationToken2);
					}
					if (responseWithHeaders.IsUnavailable())
					{
						return responseWithHeaders.GetRawResponse().AsNoBodyResponse<Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesHeaders>>();
					}
					return responseWithHeaders;
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<PageRangesInfo> GetPageRanges(HttpRange? range = null, string snapshot = null, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetPageRangesInternal(range, snapshot, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<PageRangesInfo>> GetPageRangesAsync(HttpRange? range = null, string snapshot = null, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetPageRangesInternal(range, snapshot, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<PageRangesInfo>> GetPageRangesInternal(HttpRange? range, string snapshot, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("PageBlobClient", "GetPageRangesInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("PageBlobClient.GetPageRanges");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfSequenceNumberLessThan | BlobRequestConditionProperty.IfSequenceNumberLessThanOrEqual | BlobRequestConditionProperty.IfSequenceNumberEqual, "GetPageRanges", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesHeaders> responseWithHeaders;
					if (async)
					{
						PageBlobRestClient pageBlobRestClient = PageBlobRestClient;
						string range2 = range?.ToString();
						string leaseId = conditions?.LeaseId;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await pageBlobRestClient.GetPageRangesAsync(snapshot, null, range2, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, null, null, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						PageBlobRestClient pageBlobRestClient2 = PageBlobRestClient;
						string ifTags = range?.ToString();
						string ifNoneMatch = conditions?.LeaseId;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string leaseId = conditions?.IfNoneMatch?.ToString();
						string range2 = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = pageBlobRestClient2.GetPageRanges(snapshot, null, ifTags, ifNoneMatch, ifUnmodifiedSince, ifModifiedSince, ifMatch, leaseId, range2, null, null, cancellationToken2);
					}
					return responseWithHeaders.IsUnavailable() ? responseWithHeaders.GetRawResponse().AsNoBodyResponse<PageRangesInfo>() : Response.FromValue(responseWithHeaders.ToPageRangesInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Pageable<PageRangeItem> GetAllPageRangesDiff(GetPageRangesDiffOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new GetPageRangesAsyncCollection(diff: true, this, options?.Range, options?.Snapshot, options?.PreviousSnapshot, null, options?.Conditions, "PageBlobClient.GetAllPageRangesDiff").ToSyncCollection(cancellationToken);
		}

		public virtual AsyncPageable<PageRangeItem> GetAllPageRangesDiffAsync(GetPageRangesDiffOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return new GetPageRangesAsyncCollection(diff: true, this, options?.Range, options?.Snapshot, options?.PreviousSnapshot, null, options?.Conditions, "PageBlobClient.GetAllPageRangesDiff").ToAsyncCollection(cancellationToken);
		}

		internal async Task<Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesDiffHeaders>> GetAllPageRangesDiffInternal(string marker, int? pageSizeHint, HttpRange? range, string snapshot, string previousSnapshot, Uri previousSnapshotUri, PageBlobRequestConditions conditions, bool async, string operationName, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("PageBlobClient", "GetAllPageRangesDiffInternal"))
			{
				if (operationName == null)
				{
					operationName = "PageBlobClient.GetAllPageRangesDiff";
				}
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope(operationName);
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfSequenceNumberLessThan | BlobRequestConditionProperty.IfSequenceNumberLessThanOrEqual | BlobRequestConditionProperty.IfSequenceNumberEqual, "GetPageRanges", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesDiffHeaders> responseWithHeaders;
					if (async)
					{
						PageBlobRestClient pageBlobRestClient = PageBlobRestClient;
						string prevsnapshot = previousSnapshot;
						string prevSnapshotUrl = previousSnapshotUri?.AbsoluteUri;
						string range2 = range?.ToString();
						string leaseId = conditions?.LeaseId;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						string marker2 = marker;
						int? maxresults = pageSizeHint;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await pageBlobRestClient.GetPageRangesDiffAsync(snapshot, null, prevsnapshot, prevSnapshotUrl, range2, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, marker2, maxresults, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						PageBlobRestClient pageBlobRestClient2 = PageBlobRestClient;
						string marker2 = previousSnapshot;
						string ifTags = previousSnapshotUri?.AbsoluteUri;
						string ifNoneMatch = range?.ToString();
						string ifMatch = conditions?.LeaseId;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string leaseId = conditions?.IfMatch?.ToString();
						string range2 = conditions?.IfNoneMatch?.ToString();
						string prevSnapshotUrl = conditions?.TagConditions;
						string prevsnapshot = marker;
						int? maxresults = pageSizeHint;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = pageBlobRestClient2.GetPageRangesDiff(snapshot, null, marker2, ifTags, ifNoneMatch, ifMatch, ifUnmodifiedSince, ifModifiedSince, leaseId, range2, prevSnapshotUrl, prevsnapshot, maxresults, cancellationToken2);
					}
					if (responseWithHeaders.IsUnavailable())
					{
						return responseWithHeaders.GetRawResponse().AsNoBodyResponse<Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesDiffHeaders>>();
					}
					return responseWithHeaders;
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<PageRangesInfo> GetPageRangesDiff(HttpRange? range = null, string snapshot = null, string previousSnapshot = null, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetPageRangesDiffInternal(range, snapshot, previousSnapshot, null, conditions, async: false, "PageBlobClient.GetPageRangesDiff", cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<PageRangesInfo>> GetPageRangesDiffAsync(HttpRange? range = null, string snapshot = null, string previousSnapshot = null, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetPageRangesDiffInternal(range, snapshot, previousSnapshot, null, conditions, async: true, "PageBlobClient.GetPageRangesDiff", cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<PageRangesInfo>> GetPageRangesDiffInternal(HttpRange? range, string snapshot, string previousSnapshot, Uri previousSnapshotUri, PageBlobRequestConditions conditions, bool async, string operationName, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("PageBlobClient", "GetPageRangesDiffInternal"))
			{
				if (operationName == null)
				{
					operationName = "PageBlobClient.GetPageRangesDiff";
				}
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope(operationName);
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfSequenceNumberLessThan | BlobRequestConditionProperty.IfSequenceNumberLessThanOrEqual | BlobRequestConditionProperty.IfSequenceNumberEqual, "GetPageRangesDiff", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<PageList, PageBlobGetPageRangesDiffHeaders> responseWithHeaders;
					if (async)
					{
						PageBlobRestClient pageBlobRestClient = PageBlobRestClient;
						string prevsnapshot = previousSnapshot;
						string prevSnapshotUrl = previousSnapshotUri?.AbsoluteUri;
						string range2 = range?.ToString();
						string leaseId = conditions?.LeaseId;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await pageBlobRestClient.GetPageRangesDiffAsync(snapshot, null, prevsnapshot, prevSnapshotUrl, range2, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, null, null, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						PageBlobRestClient pageBlobRestClient2 = PageBlobRestClient;
						string ifTags = previousSnapshot;
						string ifNoneMatch = previousSnapshotUri?.AbsoluteUri;
						string ifMatch = range?.ToString();
						string leaseId = conditions?.LeaseId;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string range2 = conditions?.IfMatch?.ToString();
						string prevSnapshotUrl = conditions?.IfNoneMatch?.ToString();
						string prevsnapshot = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = pageBlobRestClient2.GetPageRangesDiff(snapshot, null, ifTags, ifNoneMatch, ifMatch, leaseId, ifUnmodifiedSince, ifModifiedSince, range2, prevSnapshotUrl, prevsnapshot, null, null, cancellationToken2);
					}
					return responseWithHeaders.IsUnavailable() ? responseWithHeaders.GetRawResponse().AsNoBodyResponse<PageRangesInfo>() : Response.FromValue(responseWithHeaders.ToPageRangesInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<PageRangesInfo> GetManagedDiskPageRangesDiff(HttpRange? range = null, string snapshot = null, Uri previousSnapshotUri = null, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return GetPageRangesDiffInternal(range, snapshot, null, previousSnapshotUri, conditions, async: false, "PageBlobClient.GetManagedDiskPageRangesDiff", cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<PageRangesInfo>> GetManagedDiskPageRangesDiffAsync(HttpRange? range = null, string snapshot = null, Uri previousSnapshotUri = null, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await GetPageRangesDiffInternal(range, snapshot, null, previousSnapshotUri, conditions, async: true, "PageBlobClient.GetManagedDiskPageRangesDiff", cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		public virtual Response<PageBlobInfo> Resize(long size, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return ResizeInternal(size, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<PageBlobInfo>> ResizeAsync(long size, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await ResizeInternal(size, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<PageBlobInfo>> ResizeInternal(long size, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("PageBlobClient", "ResizeInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("PageBlobClient.Resize");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfSequenceNumberLessThan | BlobRequestConditionProperty.IfSequenceNumberLessThanOrEqual | BlobRequestConditionProperty.IfSequenceNumberEqual, "Resize", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<PageBlobResizeHeaders> responseWithHeaders;
					if (async)
					{
						PageBlobRestClient pageBlobRestClient = PageBlobRestClient;
						string leaseId = conditions?.LeaseId;
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await pageBlobRestClient.ResizeAsync(size, null, leaseId, encryptionKey, encryptionKeySha, encryptionAlgorithm, null, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						PageBlobRestClient pageBlobRestClient2 = PageBlobRestClient;
						string ifTags = conditions?.LeaseId;
						string ifNoneMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string ifMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string encryptionKeySha = conditions?.IfMatch?.ToString();
						string encryptionKey = conditions?.IfNoneMatch?.ToString();
						string leaseId = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = pageBlobRestClient2.Resize(size, null, ifTags, ifNoneMatch, ifMatch, encryptionAlgorithm, null, ifUnmodifiedSince, ifModifiedSince, encryptionKeySha, encryptionKey, leaseId, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToPageBlobInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<PageBlobInfo> UpdateSequenceNumber(SequenceNumberAction action, long? sequenceNumber = null, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return UpdateSequenceNumberInternal(action, sequenceNumber, conditions, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<PageBlobInfo>> UpdateSequenceNumberAsync(SequenceNumberAction action, long? sequenceNumber = null, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await UpdateSequenceNumberInternal(action, sequenceNumber, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<PageBlobInfo>> UpdateSequenceNumberInternal(SequenceNumberAction action, long? sequenceNumber, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("PageBlobClient", "UpdateSequenceNumberInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("PageBlobClient.UpdateSequenceNumber");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.IfSequenceNumberLessThan | BlobRequestConditionProperty.IfSequenceNumberLessThanOrEqual | BlobRequestConditionProperty.IfSequenceNumberEqual, "UpdateSequenceNumber", "conditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<PageBlobUpdateSequenceNumberHeaders> responseWithHeaders;
					if (async)
					{
						PageBlobRestClient pageBlobRestClient = PageBlobRestClient;
						string leaseId = conditions?.LeaseId;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						long? blobSequenceNumber = sequenceNumber;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await pageBlobRestClient.UpdateSequenceNumberAsync(action, null, leaseId, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, blobSequenceNumber, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						PageBlobRestClient pageBlobRestClient2 = PageBlobRestClient;
						string ifTags = conditions?.LeaseId;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string ifNoneMatch = conditions?.IfMatch?.ToString();
						string ifMatch = conditions?.IfNoneMatch?.ToString();
						string leaseId = conditions?.TagConditions;
						long? blobSequenceNumber = sequenceNumber;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = pageBlobRestClient2.UpdateSequenceNumber(action, null, ifTags, ifUnmodifiedSince, ifModifiedSince, ifNoneMatch, ifMatch, leaseId, blobSequenceNumber, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToPageBlobInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual CopyFromUriOperation StartCopyIncremental(Uri sourceUri, string snapshot, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			Response<BlobCopyInfo> response = StartCopyIncrementalInternal(sourceUri, snapshot, conditions, async: false, cancellationToken).EnsureCompleted();
			return new CopyFromUriOperation(this, response.Value.CopyId, response.GetRawResponse(), cancellationToken);
		}

		public virtual async Task<CopyFromUriOperation> StartCopyIncrementalAsync(Uri sourceUri, string snapshot, PageBlobRequestConditions conditions = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			Response<BlobCopyInfo> response = await StartCopyIncrementalInternal(sourceUri, snapshot, conditions, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
			return new CopyFromUriOperation(this, response.Value.CopyId, response.GetRawResponse(), cancellationToken);
		}

		private async Task<Response<BlobCopyInfo>> StartCopyIncrementalInternal(Uri sourceUri, string snapshot, PageBlobRequestConditions conditions, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("PageBlobClient", "StartCopyIncrementalInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("PageBlobClient.StartCopyIncremental");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.LeaseId | BlobRequestConditionProperty.IfSequenceNumberLessThan | BlobRequestConditionProperty.IfSequenceNumberLessThanOrEqual | BlobRequestConditionProperty.IfSequenceNumberEqual, "StartCopyIncremental", "conditions");
				try
				{
					scope.Start();
					PageBlobClient pageBlobClient = new PageBlobClient(sourceUri, ClientConfiguration).WithSnapshot(snapshot);
					Azure.Core.ResponseWithHeaders<PageBlobCopyIncrementalHeaders> responseWithHeaders;
					if (async)
					{
						PageBlobRestClient pageBlobRestClient = PageBlobRestClient;
						string absoluteUri = pageBlobClient.Uri.AbsoluteUri;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await pageBlobRestClient.CopyIncrementalAsync(absoluteUri, null, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						PageBlobRestClient pageBlobRestClient2 = PageBlobRestClient;
						string absoluteUri2 = pageBlobClient.Uri.AbsoluteUri;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = conditions?.IfUnmodifiedSince;
						string ifTags = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifMatch = conditions?.TagConditions;
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = pageBlobRestClient2.CopyIncremental(absoluteUri2, null, ifUnmodifiedSince, ifModifiedSince, ifTags, ifNoneMatch, ifMatch, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToBlobCopyInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Response<PageInfo> UploadPagesFromUri(Uri sourceUri, HttpRange sourceRange, HttpRange range, PageBlobUploadPagesFromUriOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return UploadPagesFromUriInternal(sourceUri, sourceRange, range, options?.SourceContentHash, options?.DestinationConditions, options?.SourceConditions, options?.SourceAuthentication, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Response<PageInfo>> UploadPagesFromUriAsync(Uri sourceUri, HttpRange sourceRange, HttpRange range, PageBlobUploadPagesFromUriOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await UploadPagesFromUriInternal(sourceUri, sourceRange, range, options?.SourceContentHash, options?.DestinationConditions, options?.SourceConditions, options?.SourceAuthentication, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual Response<PageInfo> UploadPagesFromUri(Uri sourceUri, HttpRange sourceRange, HttpRange range, byte[] sourceContentHash, PageBlobRequestConditions conditions, PageBlobRequestConditions sourceConditions, CancellationToken cancellationToken)
		{
			return UploadPagesFromUriInternal(sourceUri, sourceRange, range, sourceContentHash, conditions, sourceConditions, null, async: false, cancellationToken).EnsureCompleted();
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual async Task<Response<PageInfo>> UploadPagesFromUriAsync(Uri sourceUri, HttpRange sourceRange, HttpRange range, byte[] sourceContentHash, PageBlobRequestConditions conditions, PageBlobRequestConditions sourceConditions, CancellationToken cancellationToken)
		{
			return await UploadPagesFromUriInternal(sourceUri, sourceRange, range, sourceContentHash, conditions, sourceConditions, null, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Response<PageInfo>> UploadPagesFromUriInternal(Uri sourceUri, HttpRange sourceRange, HttpRange range, byte[] sourceContentHash, PageBlobRequestConditions conditions, PageBlobRequestConditions sourceConditions, HttpAuthorization sourceAuthentication, bool async, CancellationToken cancellationToken)
		{
			using (ClientConfiguration.Pipeline.BeginLoggingScope("PageBlobClient", "UploadPagesFromUriInternal"))
			{
				Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("PageBlobClient.UploadPagesFromUri");
				conditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.None, "UploadPagesFromUri", "conditions");
				sourceConditions.ValidateConditionsNotPresent(BlobRequestConditionProperty.LeaseId | BlobRequestConditionProperty.TagConditions | BlobRequestConditionProperty.IfSequenceNumberLessThan | BlobRequestConditionProperty.IfSequenceNumberLessThanOrEqual | BlobRequestConditionProperty.IfSequenceNumberEqual, "UploadPagesFromUri", "sourceConditions");
				try
				{
					scope.Start();
					Azure.Core.ResponseWithHeaders<PageBlobUploadPagesFromURLHeaders> responseWithHeaders;
					if (async)
					{
						PageBlobRestClient pageBlobRestClient = PageBlobRestClient;
						string absoluteUri = sourceUri.AbsoluteUri;
						string sourceRange2 = sourceRange.ToString();
						long contentLength = 0L;
						string range2 = range.ToString();
						string encryptionKey = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string encryptionKeySha = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num;
						if (!customerProvidedKey.HasValue)
						{
							num = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string encryptionScope = ClientConfiguration.EncryptionScope;
						string leaseId = conditions?.LeaseId;
						long? ifSequenceNumberLessThanOrEqualTo = conditions?.IfSequenceNumberLessThanOrEqual;
						long? ifSequenceNumberLessThan = conditions?.IfSequenceNumberLessThan;
						long? ifSequenceNumberEqualTo = conditions?.IfSequenceNumberEqual;
						DateTimeOffset? ifModifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? ifUnmodifiedSince = conditions?.IfUnmodifiedSince;
						string ifMatch = conditions?.IfMatch?.ToString();
						string ifNoneMatch = conditions?.IfNoneMatch?.ToString();
						string ifTags = conditions?.TagConditions;
						DateTimeOffset? sourceIfModifiedSince = sourceConditions?.IfModifiedSince;
						DateTimeOffset? sourceIfUnmodifiedSince = sourceConditions?.IfUnmodifiedSince;
						string sourceIfMatch = sourceConditions?.IfMatch?.ToString();
						string sourceIfNoneMatch = sourceConditions?.IfNoneMatch?.ToString();
						string copySourceAuthorization = sourceAuthentication?.ToString();
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = await pageBlobRestClient.UploadPagesFromURLAsync(absoluteUri, sourceRange2, contentLength, range2, sourceContentHash, null, null, encryptionKey, encryptionKeySha, encryptionAlgorithm, encryptionScope, leaseId, ifSequenceNumberLessThanOrEqualTo, ifSequenceNumberLessThan, ifSequenceNumberEqualTo, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, ifTags, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, copySourceAuthorization, cancellationToken2).ConfigureAwait(continueOnCapturedContext: false);
					}
					else
					{
						PageBlobRestClient pageBlobRestClient2 = PageBlobRestClient;
						string absoluteUri2 = sourceUri.AbsoluteUri;
						string sourceRange3 = sourceRange.ToString();
						long contentLength2 = 0L;
						string range3 = range.ToString();
						string copySourceAuthorization = ClientConfiguration.CustomerProvidedKey?.EncryptionKey;
						string sourceIfNoneMatch = ClientConfiguration.CustomerProvidedKey?.EncryptionKeyHash;
						CustomerProvidedKey? customerProvidedKey = ClientConfiguration.CustomerProvidedKey;
						int num2;
						if (!customerProvidedKey.HasValue)
						{
							num2 = 1;
						}
						else
						{
							_ = customerProvidedKey.GetValueOrDefault().EncryptionAlgorithm;
							num2 = 0;
						}
						EncryptionAlgorithmTypeInternal? encryptionAlgorithm = ((num2 != 0) ? ((EncryptionAlgorithmTypeInternal?)null) : new EncryptionAlgorithmTypeInternal?(EncryptionAlgorithmTypeInternal.AES256));
						string sourceIfMatch = ClientConfiguration.EncryptionScope;
						string ifTags = conditions?.LeaseId;
						long? ifSequenceNumberEqualTo = conditions?.IfSequenceNumberLessThanOrEqual;
						long? ifSequenceNumberLessThan = conditions?.IfSequenceNumberLessThan;
						long? ifSequenceNumberLessThanOrEqualTo = conditions?.IfSequenceNumberEqual;
						DateTimeOffset? sourceIfUnmodifiedSince = conditions?.IfModifiedSince;
						DateTimeOffset? sourceIfModifiedSince = conditions?.IfUnmodifiedSince;
						string ifNoneMatch = conditions?.IfMatch?.ToString();
						string ifMatch = conditions?.IfNoneMatch?.ToString();
						string leaseId = conditions?.TagConditions;
						DateTimeOffset? ifUnmodifiedSince = sourceConditions?.IfModifiedSince;
						DateTimeOffset? ifModifiedSince = sourceConditions?.IfUnmodifiedSince;
						string encryptionScope = sourceConditions?.IfMatch?.ToString();
						string encryptionKeySha = sourceConditions?.IfNoneMatch?.ToString();
						string encryptionKey = sourceAuthentication?.ToString();
						CancellationToken cancellationToken2 = cancellationToken;
						responseWithHeaders = pageBlobRestClient2.UploadPagesFromURL(absoluteUri2, sourceRange3, contentLength2, range3, sourceContentHash, null, null, copySourceAuthorization, sourceIfNoneMatch, encryptionAlgorithm, sourceIfMatch, ifTags, ifSequenceNumberEqualTo, ifSequenceNumberLessThan, ifSequenceNumberLessThanOrEqualTo, sourceIfUnmodifiedSince, sourceIfModifiedSince, ifNoneMatch, ifMatch, leaseId, ifUnmodifiedSince, ifModifiedSince, encryptionScope, encryptionKeySha, encryptionKey, cancellationToken2);
					}
					return Response.FromValue(responseWithHeaders.ToPageInfo(), responseWithHeaders.GetRawResponse());
				}
				catch (Exception exception)
				{
					scope.Failed(exception);
					throw;
				}
				finally
				{
					scope.Dispose();
				}
			}
		}

		public virtual Stream OpenWrite(bool overwrite, long position, PageBlobOpenWriteOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return OpenWriteInternal(overwrite, position, options, async: false, cancellationToken).EnsureCompleted();
		}

		public virtual async Task<Stream> OpenWriteAsync(bool overwrite, long position, PageBlobOpenWriteOptions options = null, CancellationToken cancellationToken = default(CancellationToken))
		{
			return await OpenWriteInternal(overwrite, position, options, async: true, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
		}

		private async Task<Stream> OpenWriteInternal(bool overwrite, long position, PageBlobOpenWriteOptions options, bool async, CancellationToken cancellationToken)
		{
			Azure.Core.Pipeline.DiagnosticScope scope = ClientConfiguration.ClientDiagnostics.CreateScope("PageBlobClient.OpenWrite");
			try
			{
				scope.Start();
				ETag? etag;
				if (overwrite)
				{
					if (options == null || !options.Size.HasValue)
					{
						throw new ArgumentException("options.Size must be set if overwrite is set to true");
					}
					etag = (await CreateInternal(options.Size.Value, null, null, null, null, options?.OpenConditions, null, null, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Value.ETag;
				}
				else
				{
					try
					{
						etag = (await GetPropertiesInternal(options?.OpenConditions, async, new RequestContext
						{
							CancellationToken = cancellationToken
						}).ConfigureAwait(continueOnCapturedContext: false)).Value.ETag;
					}
					catch (RequestFailedException ex) when (ex.ErrorCode == BlobErrorCode.BlobNotFound)
					{
						if (options == null || !options.Size.HasValue)
						{
							throw new ArgumentException("options.Size must be set if the Page Blob is being created for the first time");
						}
						etag = (await CreateInternal(options.Size.Value, null, null, null, null, options?.OpenConditions, null, null, async, cancellationToken).ConfigureAwait(continueOnCapturedContext: false)).Value.ETag;
					}
				}
				PageBlobRequestConditions conditions = new PageBlobRequestConditions
				{
					IfMatch = etag,
					LeaseId = options?.OpenConditions?.LeaseId
				};
				return new PageBlobWriteStream(this, options?.BufferSize ?? 4194304, position, conditions, options?.ProgressHandler, options?.TransferValidation ?? ClientConfiguration.TransferValidation.Upload);
			}
			catch (Exception exception)
			{
				scope.Failed(exception);
				throw;
			}
			finally
			{
				scope.Dispose();
			}
		}
	}
	public class SpecializedBlobClientOptions : BlobClientOptions
	{
		public ClientSideEncryptionOptions ClientSideEncryption
		{
			get
			{
				return _clientSideEncryptionOptions;
			}
			set
			{
				_clientSideEncryptionOptions = value;
			}
		}

		public SpecializedBlobClientOptions(ServiceVersion version = ServiceVersion.V2023_11_03)
			: base(version)
		{
		}
	}
}
