using System;
using System.Buffers;
using System.Buffers.Binary;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.Permissions;
using System.Text.Internal;
using System.Text.Unicode;
using System.Threading;
using Microsoft.CodeAnalysis;

[assembly: CompilationRelaxations(8)]
[assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)]
[assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)]
[assembly: AssemblyDefaultAlias("System.Text.Encodings.Web")]
[assembly: AssemblyMetadata(".NETFrameworkAssembly", "")]
[assembly: AssemblyMetadata("Serviceable", "True")]
[assembly: AssemblyMetadata("PreferInbox", "True")]
[assembly: AssemblyCompany("Microsoft Corporation")]
[assembly: AssemblyCopyright("© Microsoft Corporation. All rights reserved.")]
[assembly: AssemblyDescription("System.Text.Encodings.Web")]
[assembly: AssemblyFileVersion("4.700.21.11602")]
[assembly: AssemblyInformationalVersion("3.1.13+9299d909ff6c03c664a3f9a3ef995a9fa2eeec3e")]
[assembly: AssemblyProduct("Microsoft® .NET Core")]
[assembly: AssemblyTitle("System.Text.Encodings.Web")]
[assembly: CLSCompliant(true)]
[assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]
[assembly: AssemblyVersion("4.0.5.1")]
[module: UnverifiableCode]
namespace Microsoft.CodeAnalysis
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class EmbeddedAttribute : Attribute
	{
	}
}
namespace System.Runtime.CompilerServices
{
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class IsReadOnlyAttribute : Attribute
	{
	}
	[CompilerGenerated]
	[Microsoft.CodeAnalysis.Embedded]
	internal sealed class IsByRefLikeAttribute : Attribute
	{
	}
}
namespace System.Text
{
	internal static class UnicodeDebug
	{
		[Conditional("DEBUG")]
		internal static void AssertIsHighSurrogateCodePoint(uint codePoint)
		{
		}

		[Conditional("DEBUG")]
		internal static void AssertIsLowSurrogateCodePoint(uint codePoint)
		{
		}

		[Conditional("DEBUG")]
		internal static void AssertIsValidCodePoint(uint codePoint)
		{
		}

		[Conditional("DEBUG")]
		internal static void AssertIsValidScalar(uint scalarValue)
		{
		}

		[Conditional("DEBUG")]
		internal static void AssertIsValidSupplementaryPlaneScalar(uint scalarValue)
		{
		}

		private static string ToHexString(uint codePoint)
		{
			return FormattableString.Invariant($"U+{codePoint:X4}");
		}
	}
	internal static class UnicodeUtility
	{
		public const uint ReplacementChar = 65533u;

		public static int GetPlane(uint codePoint)
		{
			return (int)(codePoint >> 16);
		}

		public static uint GetScalarFromUtf16SurrogatePair(uint highSurrogateCodePoint, uint lowSurrogateCodePoint)
		{
			return (highSurrogateCodePoint << 10) + lowSurrogateCodePoint - 56613888;
		}

		public static int GetUtf16SequenceLength(uint value)
		{
			value -= 65536;
			value += 33554432;
			value >>= 24;
			return (int)value;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static void GetUtf16SurrogatesFromSupplementaryPlaneScalar(uint value, out char highSurrogateCodePoint, out char lowSurrogateCodePoint)
		{
			highSurrogateCodePoint = (char)(value + 56557568 >> 10);
			lowSurrogateCodePoint = (char)((value & 0x3FF) + 56320);
		}

		public static int GetUtf8SequenceLength(uint value)
		{
			int num = (int)(value - 2048) >> 31;
			value ^= 0xF800;
			value -= 63616;
			value += 67108864;
			value >>= 24;
			return (int)value + num * 2;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsAsciiCodePoint(uint value)
		{
			return value <= 127;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsBmpCodePoint(uint value)
		{
			return value <= 65535;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsHighSurrogateCodePoint(uint value)
		{
			return IsInRangeInclusive(value, 55296u, 56319u);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsInRangeInclusive(uint value, uint lowerBound, uint upperBound)
		{
			return value - lowerBound <= upperBound - lowerBound;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsLowSurrogateCodePoint(uint value)
		{
			return IsInRangeInclusive(value, 56320u, 57343u);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsSurrogateCodePoint(uint value)
		{
			return IsInRangeInclusive(value, 55296u, 57343u);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsValidCodePoint(uint codePoint)
		{
			return codePoint <= 1114111;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static bool IsValidUnicodeScalar(uint value)
		{
			return ((value - 1114112) ^ 0xD800) >= 4293855232u;
		}
	}
	internal ref struct ValueStringBuilder
	{
		private char[] _arrayToReturnToPool;

		private Span<char> _chars;

		private int _pos;

		public int Length
		{
			get
			{
				return _pos;
			}
			set
			{
				_pos = value;
			}
		}

		public int Capacity => _chars.Length;

		public ref char this[int index] => ref _chars[index];

		public Span<char> RawChars => _chars;

		public ValueStringBuilder(Span<char> initialBuffer)
		{
			_arrayToReturnToPool = null;
			_chars = initialBuffer;
			_pos = 0;
		}

		public ValueStringBuilder(int initialCapacity)
		{
			_arrayToReturnToPool = ArrayPool<char>.Shared.Rent(initialCapacity);
			_chars = _arrayToReturnToPool;
			_pos = 0;
		}

		public void EnsureCapacity(int capacity)
		{
			if (capacity > _chars.Length)
			{
				Grow(capacity - _pos);
			}
		}

		public ref char GetPinnableReference()
		{
			return ref MemoryMarshal.GetReference(_chars);
		}

		public ref char GetPinnableReference(bool terminate)
		{
			if (terminate)
			{
				EnsureCapacity(Length + 1);
				_chars[Length] = '\0';
			}
			return ref MemoryMarshal.GetReference(_chars);
		}

		public override string ToString()
		{
			string result = _chars.Slice(0, _pos).ToString();
			Dispose();
			return result;
		}

		public ReadOnlySpan<char> AsSpan(bool terminate)
		{
			if (terminate)
			{
				EnsureCapacity(Length + 1);
				_chars[Length] = '\0';
			}
			return _chars.Slice(0, _pos);
		}

		public ReadOnlySpan<char> AsSpan()
		{
			return _chars.Slice(0, _pos);
		}

		public ReadOnlySpan<char> AsSpan(int start)
		{
			return _chars.Slice(start, _pos - start);
		}

		public ReadOnlySpan<char> AsSpan(int start, int length)
		{
			return _chars.Slice(start, length);
		}

		public bool TryCopyTo(Span<char> destination, out int charsWritten)
		{
			if (_chars.Slice(0, _pos).TryCopyTo(destination))
			{
				charsWritten = _pos;
				Dispose();
				return true;
			}
			charsWritten = 0;
			Dispose();
			return false;
		}

		public void Insert(int index, char value, int count)
		{
			if (_pos > _chars.Length - count)
			{
				Grow(count);
			}
			int length = _pos - index;
			_chars.Slice(index, length).CopyTo(_chars.Slice(index + count));
			_chars.Slice(index, count).Fill(value);
			_pos += count;
		}

		public void Insert(int index, string s)
		{
			int length = s.Length;
			if (_pos > _chars.Length - length)
			{
				Grow(length);
			}
			int length2 = _pos - index;
			_chars.Slice(index, length2).CopyTo(_chars.Slice(index + length));
			MemoryExtensions.AsSpan(s).CopyTo(_chars.Slice(index));
			_pos += length;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(char c)
		{
			int pos = _pos;
			if ((uint)pos < (uint)_chars.Length)
			{
				_chars[pos] = c;
				_pos = pos + 1;
			}
			else
			{
				GrowAndAppend(c);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Append(string s)
		{
			int pos = _pos;
			if (s.Length == 1 && (uint)pos < (uint)_chars.Length)
			{
				_chars[pos] = s[0];
				_pos = pos + 1;
			}
			else
			{
				AppendSlow(s);
			}
		}

		private void AppendSlow(string s)
		{
			int pos = _pos;
			if (pos > _chars.Length - s.Length)
			{
				Grow(s.Length);
			}
			MemoryExtensions.AsSpan(s).CopyTo(_chars.Slice(pos));
			_pos += s.Length;
		}

		public void Append(char c, int count)
		{
			if (_pos > _chars.Length - count)
			{
				Grow(count);
			}
			Span<char> span = _chars.Slice(_pos, count);
			for (int i = 0; i < span.Length; i++)
			{
				span[i] = c;
			}
			_pos += count;
		}

		public unsafe void Append(char* value, int length)
		{
			int pos = _pos;
			if (pos > _chars.Length - length)
			{
				Grow(length);
			}
			Span<char> span = _chars.Slice(_pos, length);
			for (int i = 0; i < span.Length; i++)
			{
				span[i] = *(value++);
			}
			_pos += length;
		}

		public void Append(ReadOnlySpan<char> value)
		{
			int pos = _pos;
			if (pos > _chars.Length - value.Length)
			{
				Grow(value.Length);
			}
			value.CopyTo(_chars.Slice(_pos));
			_pos += value.Length;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Span<char> AppendSpan(int length)
		{
			int pos = _pos;
			if (pos > _chars.Length - length)
			{
				Grow(length);
			}
			_pos = pos + length;
			return _chars.Slice(pos, length);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private void GrowAndAppend(char c)
		{
			Grow(1);
			Append(c);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private void Grow(int additionalCapacityBeyondPos)
		{
			char[] array = ArrayPool<char>.Shared.Rent(Math.Max(_pos + additionalCapacityBeyondPos, _chars.Length * 2));
			_chars.CopyTo(array);
			char[] arrayToReturnToPool = _arrayToReturnToPool;
			_chars = (_arrayToReturnToPool = array);
			if (arrayToReturnToPool != null)
			{
				ArrayPool<char>.Shared.Return(arrayToReturnToPool);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Dispose()
		{
			char[] arrayToReturnToPool = _arrayToReturnToPool;
			this = default(System.Text.ValueStringBuilder);
			if (arrayToReturnToPool != null)
			{
				ArrayPool<char>.Shared.Return(arrayToReturnToPool);
			}
		}
	}
}
namespace System.Text.Unicode
{
	internal static class UnicodeHelpers
	{
		internal const int UNICODE_LAST_CODEPOINT = 1114111;

		private static uint[] _definedCharacterBitmapBigEndian = (BitConverter.IsLittleEndian ? null : CreateDefinedCharacterBitmapMachineEndian());

		private static ReadOnlySpan<byte> DefinedCharsBitmapSpan => new byte[8192]
		{
			0, 0, 0, 0, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 127, 0, 0, 0, 0,
			254, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 252, 240, 215, 255, 255, 251, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 254, 255, 255, 255,
			127, 254, 255, 255, 255, 255, 255, 231, 254, 255,
			255, 255, 255, 255, 255, 0, 255, 255, 255, 135,
			31, 0, 255, 255, 255, 223, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 191, 255, 255, 255, 255,
			255, 255, 255, 231, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 3, 0, 255, 255,
			255, 255, 255, 255, 255, 231, 255, 255, 255, 255,
			255, 63, 255, 127, 255, 255, 255, 79, 255, 7,
			0, 0, 0, 0, 0, 0, 255, 255, 223, 63,
			0, 0, 248, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 239, 159, 249, 255, 255, 253,
			197, 243, 159, 121, 128, 176, 207, 255, 255, 127,
			238, 135, 249, 255, 255, 253, 109, 211, 135, 57,
			2, 94, 192, 255, 127, 0, 238, 191, 251, 255,
			255, 253, 237, 243, 191, 59, 1, 0, 207, 255,
			3, 254, 238, 159, 249, 255, 255, 253, 237, 243,
			159, 57, 192, 176, 207, 255, 255, 0, 236, 199,
			61, 214, 24, 199, 255, 195, 199, 61, 129, 0,
			192, 255, 255, 7, 255, 223, 253, 255, 255, 253,
			255, 227, 223, 61, 96, 7, 207, 255, 128, 255,
			255, 223, 253, 255, 255, 253, 239, 243, 223, 61,
			96, 64, 207, 255, 6, 0, 239, 223, 253, 255,
			255, 255, 255, 255, 223, 253, 240, 255, 207, 255,
			255, 255, 236, 255, 127, 252, 255, 255, 251, 47,
			127, 132, 95, 255, 192, 255, 28, 0, 254, 255,
			255, 255, 255, 255, 255, 135, 255, 255, 255, 15,
			0, 0, 0, 0, 214, 247, 255, 255, 175, 255,
			255, 63, 95, 63, 255, 243, 0, 0, 0, 0,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 254,
			255, 255, 255, 31, 254, 255, 255, 255, 255, 254,
			255, 255, 255, 223, 255, 223, 255, 7, 0, 0,
			0, 0, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 191, 32, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 61, 127, 61, 255, 255,
			255, 255, 255, 61, 255, 255, 255, 255, 61, 127,
			61, 255, 127, 255, 255, 255, 255, 255, 255, 255,
			61, 255, 255, 255, 255, 255, 255, 255, 255, 231,
			255, 255, 255, 31, 255, 255, 255, 3, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 63, 63,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			254, 255, 255, 31, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 1, 255, 223, 31, 0,
			255, 255, 127, 0, 255, 255, 15, 0, 255, 223,
			13, 0, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 63, 255, 3, 255, 3, 255, 127,
			255, 3, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 1, 255, 255, 255, 255, 255, 7,
			255, 255, 255, 255, 255, 255, 255, 255, 63, 0,
			255, 255, 255, 127, 255, 15, 255, 15, 241, 255,
			255, 255, 255, 63, 31, 0, 255, 255, 255, 255,
			255, 15, 255, 255, 255, 3, 255, 199, 255, 255,
			255, 255, 255, 255, 255, 207, 255, 255, 255, 255,
			255, 255, 255, 127, 255, 255, 255, 159, 255, 3,
			255, 3, 255, 63, 255, 127, 0, 0, 0, 0,
			0, 0, 0, 0, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 15, 255, 255, 255, 255, 255, 31,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 15, 240, 255, 255, 255, 255,
			255, 255, 255, 248, 255, 227, 255, 255, 255, 255,
			255, 255, 255, 1, 255, 255, 255, 255, 255, 231,
			255, 0, 255, 255, 255, 255, 255, 7, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 251,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 63, 63, 255, 255, 255, 255,
			63, 63, 255, 170, 255, 255, 255, 63, 255, 255,
			255, 255, 255, 255, 223, 255, 223, 255, 207, 239,
			255, 255, 220, 127, 0, 248, 255, 255, 255, 124,
			255, 255, 255, 255, 255, 127, 223, 255, 243, 255,
			255, 127, 255, 31, 255, 255, 255, 255, 0, 0,
			255, 255, 255, 255, 1, 0, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 15, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 127, 0, 0, 0,
			255, 7, 0, 0, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			207, 255, 255, 255, 63, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 127, 255, 255, 255, 255, 255, 127,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 15, 254,
			255, 255, 255, 255, 191, 32, 255, 255, 255, 255,
			255, 255, 255, 128, 1, 128, 255, 255, 127, 0,
			127, 127, 127, 127, 127, 127, 127, 127, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 0, 0, 0, 0, 0, 0, 255, 255,
			255, 251, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 15, 0, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			63, 0, 0, 0, 255, 15, 254, 255, 255, 255,
			255, 255, 255, 255, 254, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 127, 254, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 224, 255,
			255, 255, 255, 255, 254, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 127, 255, 255, 255, 255,
			255, 7, 255, 255, 255, 255, 15, 0, 255, 255,
			255, 255, 255, 127, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 63, 0, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 0, 0,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 31, 255, 255, 255, 255,
			255, 255, 127, 0, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 15, 0, 0,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 0, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 124, 0,
			0, 0, 0, 0, 128, 255, 255, 255, 255, 255,
			255, 15, 255, 3, 255, 255, 255, 255, 255, 255,
			255, 0, 255, 255, 255, 255, 255, 255, 255, 255,
			63, 192, 255, 3, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 15, 128,
			255, 255, 255, 31, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 191, 255, 195, 255, 255, 255, 127,
			255, 255, 255, 255, 255, 255, 127, 0, 255, 63,
			255, 243, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 7, 0, 0, 248, 255, 255,
			127, 0, 126, 126, 126, 0, 127, 127, 255, 255,
			255, 255, 255, 255, 255, 0, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 63, 255, 3, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			15, 0, 255, 255, 127, 248, 255, 255, 255, 255,
			255, 15, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 63, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 3, 0, 0,
			0, 0, 127, 0, 248, 224, 255, 255, 127, 95,
			219, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 3, 0, 248, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 0, 0, 255, 255, 255, 255,
			255, 255, 255, 255, 252, 255, 255, 255, 255, 255,
			255, 0, 0, 0, 0, 0, 255, 63, 255, 255,
			255, 3, 255, 255, 255, 255, 255, 255, 247, 255,
			127, 15, 223, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 159,
			254, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
			255, 255, 255, 127, 252, 252, 252, 28, 127, 127,
			0, 62
		};

		private static uint[] CreateDefinedCharacterBitmapMachineEndian()
		{
			ReadOnlySpan<byte> source = DefinedCharsBitmapSpan;
			uint[] array = new uint[source.Length / 4];
			for (int i = 0; i < array.Length; i++)
			{
				array[i] = BinaryPrimitives.ReadUInt32LittleEndian(source);
				source = source.Slice(4);
			}
			return array;
		}

		public static OperationStatus DecodeScalarValueFromUtf8(ReadOnlySpan<byte> source, out uint result, out int bytesConsumed)
		{
			int num = 0;
			uint num2;
			if ((uint)num < (uint)source.Length)
			{
				num2 = source[num];
				if (System.Text.UnicodeUtility.IsAsciiCodePoint(num2))
				{
					goto IL_0021;
				}
				if (System.Text.UnicodeUtility.IsInRangeInclusive(num2, 194u, 244u))
				{
					num2 = num2 - 194 << 6;
					num++;
					if ((uint)num >= (uint)source.Length)
					{
						goto IL_0150;
					}
					int num3 = (sbyte)source[num];
					if (num3 < -64)
					{
						num2 += (uint)num3;
						num2 += 128;
						num2 += 128;
						if (num2 < 2048)
						{
							goto IL_0021;
						}
						if (System.Text.UnicodeUtility.IsInRangeInclusive(num2, 2080u, 3343u) && !System.Text.UnicodeUtility.IsInRangeInclusive(num2, 2912u, 2943u) && !System.Text.UnicodeUtility.IsInRangeInclusive(num2, 3072u, 3087u))
						{
							num++;
							if ((uint)num >= (uint)source.Length)
							{
								goto IL_0150;
							}
							num3 = (sbyte)source[num];
							if (num3 < -64)
							{
								num2 <<= 6;
								num2 += (uint)num3;
								num2 += 128;
								num2 -= 131072;
								if (num2 > 65535)
								{
									num++;
									if ((uint)num >= (uint)source.Length)
									{
										goto IL_0150;
									}
									num3 = (sbyte)source[num];
									if (num3 >= -64)
									{
										goto IL_0144;
									}
									num2 <<= 6;
									num2 += (uint)num3;
									num2 += 128;
									num2 -= 4194304;
								}
								goto IL_0021;
							}
						}
					}
				}
				else
				{
					num = 1;
				}
				goto IL_0144;
			}
			goto IL_0150;
			IL_0021:
			bytesConsumed = num + 1;
			result = num2;
			return OperationStatus.Done;
			IL_0150:
			bytesConsumed = num;
			result = 65533u;
			return OperationStatus.NeedMoreData;
			IL_0144:
			bytesConsumed = num;
			result = 65533u;
			return OperationStatus.InvalidData;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ReadOnlySpan<uint> GetDefinedCharacterBitmap()
		{
			if (BitConverter.IsLittleEndian)
			{
				return MemoryMarshal.Cast<byte, uint>(DefinedCharsBitmapSpan);
			}
			return _definedCharacterBitmapBigEndian;
		}

		internal static void GetUtf16SurrogatePairFromAstralScalarValue(int scalar, out char highSurrogate, out char lowSurrogate)
		{
			int num = scalar & 0xFFFF;
			int num2 = scalar >> 16;
			int num3 = num2 - 1;
			highSurrogate = (char)(0xD800 | (num3 << 6) | (num >> 10));
			lowSurrogate = (char)(0xDC00 | (num & 0x3FF));
		}

		internal static int GetUtf8RepresentationForScalarValue(uint scalar)
		{
			if (scalar <= 127)
			{
				return (byte)scalar;
			}
			if (scalar <= 2047)
			{
				byte b = (byte)(0xC0 | (scalar >> 6));
				byte b2 = (byte)(0x80 | (scalar & 0x3F));
				return (b2 << 8) | b;
			}
			if (scalar <= 65535)
			{
				byte b3 = (byte)(0xE0 | (scalar >> 12));
				byte b4 = (byte)(0x80 | ((scalar >> 6) & 0x3F));
				byte b5 = (byte)(0x80 | (scalar & 0x3F));
				return (((b5 << 8) | b4) << 8) | b3;
			}
			byte b6 = (byte)(0xF0 | (scalar >> 18));
			byte b7 = (byte)(0x80 | ((scalar >> 12) & 0x3F));
			byte b8 = (byte)(0x80 | ((scalar >> 6) & 0x3F));
			byte b9 = (byte)(0x80 | (scalar & 0x3F));
			return (((((b9 << 8) | b8) << 8) | b7) << 8) | b6;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static bool IsSupplementaryCodePoint(int scalar)
		{
			return (scalar & -65536) != 0;
		}
	}
	public sealed class UnicodeRange
	{
		public int FirstCodePoint { get; private set; }

		public int Length { get; private set; }

		public UnicodeRange(int firstCodePoint, int length)
		{
			if (firstCodePoint < 0 || firstCodePoint > 65535)
			{
				throw new ArgumentOutOfRangeException("firstCodePoint");
			}
			if (length < 0 || (long)firstCodePoint + (long)length > 65536)
			{
				throw new ArgumentOutOfRangeException("length");
			}
			FirstCodePoint = firstCodePoint;
			Length = length;
		}

		public static UnicodeRange Create(char firstCharacter, char lastCharacter)
		{
			if (lastCharacter < firstCharacter)
			{
				throw new ArgumentOutOfRangeException("lastCharacter");
			}
			return new UnicodeRange(firstCharacter, 1 + (lastCharacter - firstCharacter));
		}
	}
	public static class UnicodeRanges
	{
		private static UnicodeRange _none;

		private static UnicodeRange _all;

		private static UnicodeRange _u0000;

		private static UnicodeRange _u0080;

		private static UnicodeRange _u0100;

		private static UnicodeRange _u0180;

		private static UnicodeRange _u0250;

		private static UnicodeRange _u02B0;

		private static UnicodeRange _u0300;

		private static UnicodeRange _u0370;

		private static UnicodeRange _u0400;

		private static UnicodeRange _u0500;

		private static UnicodeRange _u0530;

		private static UnicodeRange _u0590;

		private static UnicodeRange _u0600;

		private static UnicodeRange _u0700;

		private static UnicodeRange _u0750;

		private static UnicodeRange _u0780;

		private static UnicodeRange _u07C0;

		private static UnicodeRange _u0800;

		private static UnicodeRange _u0840;

		private static UnicodeRange _u0860;

		private static UnicodeRange _u08A0;

		private static UnicodeRange _u0900;

		private static UnicodeRange _u0980;

		private static UnicodeRange _u0A00;

		private static UnicodeRange _u0A80;

		private static UnicodeRange _u0B00;

		private static UnicodeRange _u0B80;

		private static UnicodeRange _u0C00;

		private static UnicodeRange _u0C80;

		private static UnicodeRange _u0D00;

		private static UnicodeRange _u0D80;

		private static UnicodeRange _u0E00;

		private static UnicodeRange _u0E80;

		private static UnicodeRange _u0F00;

		private static UnicodeRange _u1000;

		private static UnicodeRange _u10A0;

		private static UnicodeRange _u1100;

		private static UnicodeRange _u1200;

		private static UnicodeRange _u1380;

		private static UnicodeRange _u13A0;

		private static UnicodeRange _u1400;

		private static UnicodeRange _u1680;

		private static UnicodeRange _u16A0;

		private static UnicodeRange _u1700;

		private static UnicodeRange _u1720;

		private static UnicodeRange _u1740;

		private static UnicodeRange _u1760;

		private static UnicodeRange _u1780;

		private static UnicodeRange _u1800;

		private static UnicodeRange _u18B0;

		private static UnicodeRange _u1900;

		private static UnicodeRange _u1950;

		private static UnicodeRange _u1980;

		private static UnicodeRange _u19E0;

		private static UnicodeRange _u1A00;

		private static UnicodeRange _u1A20;

		private static UnicodeRange _u1AB0;

		private static UnicodeRange _u1B00;

		private static UnicodeRange _u1B80;

		private static UnicodeRange _u1BC0;

		private static UnicodeRange _u1C00;

		private static UnicodeRange _u1C50;

		private static UnicodeRange _u1C80;

		private static UnicodeRange _u1C90;

		private static UnicodeRange _u1CC0;

		private static UnicodeRange _u1CD0;

		private static UnicodeRange _u1D00;

		private static UnicodeRange _u1D80;

		private static UnicodeRange _u1DC0;

		private static UnicodeRange _u1E00;

		private static UnicodeRange _u1F00;

		private static UnicodeRange _u2000;

		private static UnicodeRange _u2070;

		private static UnicodeRange _u20A0;

		private static UnicodeRange _u20D0;

		private static UnicodeRange _u2100;

		private static UnicodeRange _u2150;

		private static UnicodeRange _u2190;

		private static UnicodeRange _u2200;

		private static UnicodeRange _u2300;

		private static UnicodeRange _u2400;

		private static UnicodeRange _u2440;

		private static UnicodeRange _u2460;

		private static UnicodeRange _u2500;

		private static UnicodeRange _u2580;

		private static UnicodeRange _u25A0;

		private static UnicodeRange _u2600;

		private static UnicodeRange _u2700;

		private static UnicodeRange _u27C0;

		private static UnicodeRange _u27F0;

		private static UnicodeRange _u2800;

		private static UnicodeRange _u2900;

		private static UnicodeRange _u2980;

		private static UnicodeRange _u2A00;

		private static UnicodeRange _u2B00;

		private static UnicodeRange _u2C00;

		private static UnicodeRange _u2C60;

		private static UnicodeRange _u2C80;

		private static UnicodeRange _u2D00;

		private static UnicodeRange _u2D30;

		private static UnicodeRange _u2D80;

		private static UnicodeRange _u2DE0;

		private static UnicodeRange _u2E00;

		private static UnicodeRange _u2E80;

		private static UnicodeRange _u2F00;

		private static UnicodeRange _u2FF0;

		private static UnicodeRange _u3000;

		private static UnicodeRange _u3040;

		private static UnicodeRange _u30A0;

		private static UnicodeRange _u3100;

		private static UnicodeRange _u3130;

		private static UnicodeRange _u3190;

		private static UnicodeRange _u31A0;

		private static UnicodeRange _u31C0;

		private static UnicodeRange _u31F0;

		private static UnicodeRange _u3200;

		private static UnicodeRange _u3300;

		private static UnicodeRange _u3400;

		private static UnicodeRange _u4DC0;

		private static UnicodeRange _u4E00;

		private static UnicodeRange _uA000;

		private static UnicodeRange _uA490;

		private static UnicodeRange _uA4D0;

		private static UnicodeRange _uA500;

		private static UnicodeRange _uA640;

		private static UnicodeRange _uA6A0;

		private static UnicodeRange _uA700;

		private static UnicodeRange _uA720;

		private static UnicodeRange _uA800;

		private static UnicodeRange _uA830;

		private static UnicodeRange _uA840;

		private static UnicodeRange _uA880;

		private static UnicodeRange _uA8E0;

		private static UnicodeRange _uA900;

		private static UnicodeRange _uA930;

		private static UnicodeRange _uA960;

		private static UnicodeRange _uA980;

		private static UnicodeRange _uA9E0;

		private static UnicodeRange _uAA00;

		private static UnicodeRange _uAA60;

		private static UnicodeRange _uAA80;

		private static UnicodeRange _uAAE0;

		private static UnicodeRange _uAB00;

		private static UnicodeRange _uAB30;

		private static UnicodeRange _uAB70;

		private static UnicodeRange _uABC0;

		private static UnicodeRange _uAC00;

		private static UnicodeRange _uD7B0;

		private static UnicodeRange _uF900;

		private static UnicodeRange _uFB00;

		private static UnicodeRange _uFB50;

		private static UnicodeRange _uFE00;

		private static UnicodeRange _uFE10;

		private static UnicodeRange _uFE20;

		private static UnicodeRange _uFE30;

		private static UnicodeRange _uFE50;

		private static UnicodeRange _uFE70;

		private static UnicodeRange _uFF00;

		private static UnicodeRange _uFFF0;

		public static UnicodeRange None => _none ?? CreateEmptyRange(ref _none);

		public static UnicodeRange All => _all ?? CreateRange(ref _all, '\0', '\uffff');

		public static UnicodeRange BasicLatin => _u0000 ?? CreateRange(ref _u0000, '\0', '\u007f');

		public static UnicodeRange Latin1Supplement => _u0080 ?? CreateRange(ref _u0080, '\u0080', 'ÿ');

		public static UnicodeRange LatinExtendedA => _u0100 ?? CreateRange(ref _u0100, 'Ā', 'ſ');

		public static UnicodeRange LatinExtendedB => _u0180 ?? CreateRange(ref _u0180, 'ƀ', 'ɏ');

		public static UnicodeRange IpaExtensions => _u0250 ?? CreateRange(ref _u0250, 'ɐ', 'ʯ');

		public static UnicodeRange SpacingModifierLetters => _u02B0 ?? CreateRange(ref _u02B0, 'ʰ', '\u02ff');

		public static UnicodeRange CombiningDiacriticalMarks => _u0300 ?? CreateRange(ref _u0300, '\u0300', '\u036f');

		public static UnicodeRange GreekandCoptic => _u0370 ?? CreateRange(ref _u0370, 'Ͱ', 'Ͽ');

		public static UnicodeRange Cyrillic => _u0400 ?? CreateRange(ref _u0400, 'Ѐ', 'ӿ');

		public static UnicodeRange CyrillicSupplement => _u0500 ?? CreateRange(ref _u0500, 'Ԁ', 'ԯ');

		public static UnicodeRange Armenian => _u0530 ?? CreateRange(ref _u0530, '\u0530', '֏');

		public static UnicodeRange Hebrew => _u0590 ?? CreateRange(ref _u0590, '\u0590', '\u05ff');

		public static UnicodeRange Arabic => _u0600 ?? CreateRange(ref _u0600, '\u0600', 'ۿ');

		public static UnicodeRange Syriac => _u0700 ?? CreateRange(ref _u0700, '܀', 'ݏ');

		public static UnicodeRange ArabicSupplement => _u0750 ?? CreateRange(ref _u0750, 'ݐ', 'ݿ');

		public static UnicodeRange Thaana => _u0780 ?? CreateRange(ref _u0780, 'ހ', '\u07bf');

		public static UnicodeRange NKo => _u07C0 ?? CreateRange(ref _u07C0, '߀', '߿');

		public static UnicodeRange Samaritan => _u0800 ?? CreateRange(ref _u0800, 'ࠀ', '\u083f');

		public static UnicodeRange Mandaic => _u0840 ?? CreateRange(ref _u0840, 'ࡀ', '\u085f');

		public static UnicodeRange SyriacSupplement => _u0860 ?? CreateRange(ref _u0860, 'ࡠ', '\u086f');

		public static UnicodeRange ArabicExtendedA => _u08A0 ?? CreateRange(ref _u08A0, 'ࢠ', '\u08ff');

		public static UnicodeRange Devanagari => _u0900 ?? CreateRange(ref _u0900, '\u0900', 'ॿ');

		public static UnicodeRange Bengali => _u0980 ?? CreateRange(ref _u0980, 'ঀ', '\u09ff');

		public static UnicodeRange Gurmukhi => _u0A00 ?? CreateRange(ref _u0A00, '\u0a00', '\u0a7f');

		public static UnicodeRange Gujarati => _u0A80 ?? CreateRange(ref _u0A80, '\u0a80', '\u0aff');

		public static UnicodeRange Oriya => _u0B00 ?? CreateRange(ref _u0B00, '\u0b00', '\u0b7f');

		public static UnicodeRange Tamil => _u0B80 ?? CreateRange(ref _u0B80, '\u0b80', '\u0bff');

		public static UnicodeRange Telugu => _u0C00 ?? CreateRange(ref _u0C00, '\u0c00', '౿');

		public static UnicodeRange Kannada => _u0C80 ?? CreateRange(ref _u0C80, 'ಀ', '\u0cff');

		public static UnicodeRange Malayalam => _u0D00 ?? CreateRange(ref _u0D00, '\u0d00', 'ൿ');

		public static UnicodeRange Sinhala => _u0D80 ?? CreateRange(ref _u0D80, '\u0d80', '\u0dff');

		public static UnicodeRange Thai => _u0E00 ?? CreateRange(ref _u0E00, '\u0e00', '\u0e7f');

		public static UnicodeRange Lao => _u0E80 ?? CreateRange(ref _u0E80, '\u0e80', '\u0eff');

		public static UnicodeRange Tibetan => _u0F00 ?? CreateRange(ref _u0F00, 'ༀ', '\u0fff');

		public static UnicodeRange Myanmar => _u1000 ?? CreateRange(ref _u1000, 'က', '႟');

		public static UnicodeRange Georgian => _u10A0 ?? CreateRange(ref _u10A0, 'Ⴀ', 'ჿ');

		public static UnicodeRange HangulJamo => _u1100 ?? CreateRange(ref _u1100, 'ᄀ', 'ᇿ');

		public static UnicodeRange Ethiopic => _u1200 ?? CreateRange(ref _u1200, 'ሀ', '\u137f');

		public static UnicodeRange EthiopicSupplement => _u1380 ?? CreateRange(ref _u1380, 'ᎀ', '\u139f');

		public static UnicodeRange Cherokee => _u13A0 ?? CreateRange(ref _u13A0, 'Ꭰ', '\u13ff');

		public static UnicodeRange UnifiedCanadianAboriginalSyllabics => _u1400 ?? CreateRange(ref _u1400, '᐀', 'ᙿ');

		public static UnicodeRange Ogham => _u1680 ?? CreateRange(ref _u1680, '\u1680', '\u169f');

		public static UnicodeRange Runic => _u16A0 ?? CreateRange(ref _u16A0, 'ᚠ', '\u16ff');

		public static UnicodeRange Tagalog => _u1700 ?? CreateRange(ref _u1700, 'ᜀ', 'ᜟ');

		public static UnicodeRange Hanunoo => _u1720 ?? CreateRange(ref _u1720, 'ᜠ', '\u173f');

		public static UnicodeRange Buhid => _u1740 ?? CreateRange(ref _u1740, 'ᝀ', '\u175f');

		public static UnicodeRange Tagbanwa => _u1760 ?? CreateRange(ref _u1760, 'ᝠ', '\u177f');

		public static UnicodeRange Khmer => _u1780 ?? CreateRange(ref _u1780, 'ក', '\u17ff');

		public static UnicodeRange Mongolian => _u1800 ?? CreateRange(ref _u1800, '᠀', '\u18af');

		public static UnicodeRange UnifiedCanadianAboriginalSyllabicsExtended => _u18B0 ?? CreateRange(ref _u18B0, 'ᢰ', '\u18ff');

		public static UnicodeRange Limbu => _u1900 ?? CreateRange(ref _u1900, 'ᤀ', '᥏');

		public static UnicodeRange TaiLe => _u1950 ?? CreateRange(ref _u1950, 'ᥐ', '\u197f');

		public static UnicodeRange NewTaiLue => _u1980 ?? CreateRange(ref _u1980, 'ᦀ', '᧟');

		public static UnicodeRange KhmerSymbols => _u19E0 ?? CreateRange(ref _u19E0, '᧠', '᧿');

		public static UnicodeRange Buginese => _u1A00 ?? CreateRange(ref _u1A00, 'ᨀ', '᨟');

		public static UnicodeRange TaiTham => _u1A20 ?? CreateRange(ref _u1A20, 'ᨠ', '\u1aaf');

		public static UnicodeRange CombiningDiacriticalMarksExtended => _u1AB0 ?? CreateRange(ref _u1AB0, '\u1ab0', '\u1aff');

		public static UnicodeRange Balinese => _u1B00 ?? CreateRange(ref _u1B00, '\u1b00', '\u1b7f');

		public static UnicodeRange Sundanese => _u1B80 ?? CreateRange(ref _u1B80, '\u1b80', 'ᮿ');

		public static UnicodeRange Batak => _u1BC0 ?? CreateRange(ref _u1BC0, 'ᯀ', '᯿');

		public static UnicodeRange Lepcha => _u1C00 ?? CreateRange(ref _u1C00, 'ᰀ', 'ᱏ');

		public static UnicodeRange OlChiki => _u1C50 ?? CreateRange(ref _u1C50, '᱐', '᱿');

		public static UnicodeRange CyrillicExtendedC => _u1C80 ?? CreateRange(ref _u1C80, 'ᲀ', '\u1c8f');

		public static UnicodeRange GeorgianExtended => _u1C90 ?? CreateRange(ref _u1C90, 'Ა', 'Ჿ');

		public static UnicodeRange SundaneseSupplement => _u1CC0 ?? CreateRange(ref _u1CC0, '᳀', '\u1ccf');

		public static UnicodeRange VedicExtensions => _u1CD0 ?? CreateRange(ref _u1CD0, '\u1cd0', '\u1cff');

		public static UnicodeRange PhoneticExtensions => _u1D00 ?? CreateRange(ref _u1D00, 'ᴀ', 'ᵿ');

		public static UnicodeRange PhoneticExtensionsSupplement => _u1D80 ?? CreateRange(ref _u1D80, 'ᶀ', 'ᶿ');

		public static UnicodeRange CombiningDiacriticalMarksSupplement => _u1DC0 ?? CreateRange(ref _u1DC0, '\u1dc0', '\u1dff');

		public static UnicodeRange LatinExtendedAdditional => _u1E00 ?? CreateRange(ref _u1E00, 'Ḁ', 'ỿ');

		public static UnicodeRange GreekExtended => _u1F00 ?? CreateRange(ref _u1F00, 'ἀ', '\u1fff');

		public static UnicodeRange GeneralPunctuation => _u2000 ?? CreateRange(ref _u2000, '\u2000', '\u206f');

		public static UnicodeRange SuperscriptsandSubscripts => _u2070 ?? CreateRange(ref _u2070, '⁰', '\u209f');

		public static UnicodeRange CurrencySymbols => _u20A0 ?? CreateRange(ref _u20A0, '₠', '\u20cf');

		public static UnicodeRange CombiningDiacriticalMarksforSymbols => _u20D0 ?? CreateRange(ref _u20D0, '\u20d0', '\u20ff');

		public static UnicodeRange LetterlikeSymbols => _u2100 ?? CreateRange(ref _u2100, '℀', '⅏');

		public static UnicodeRange NumberForms => _u2150 ?? CreateRange(ref _u2150, '⅐', '\u218f');

		public static UnicodeRange Arrows => _u2190 ?? CreateRange(ref _u2190, '←', '⇿');

		public static UnicodeRange MathematicalOperators => _u2200 ?? CreateRange(ref _u2200, '∀', '⋿');

		public static UnicodeRange MiscellaneousTechnical => _u2300 ?? CreateRange(ref _u2300, '⌀', '⏿');

		public static UnicodeRange ControlPictures => _u2400 ?? CreateRange(ref _u2400, '␀', '\u243f');

		public static UnicodeRange OpticalCharacterRecognition => _u2440 ?? CreateRange(ref _u2440, '⑀', '\u245f');

		public static UnicodeRange EnclosedAlphanumerics => _u2460 ?? CreateRange(ref _u2460, '①', '⓿');

		public static UnicodeRange BoxDrawing => _u2500 ?? CreateRange(ref _u2500, '─', '╿');

		public static UnicodeRange BlockElements => _u2580 ?? CreateRange(ref _u2580, '▀', '▟');

		public static UnicodeRange GeometricShapes => _u25A0 ?? CreateRange(ref _u25A0, '■', '◿');

		public static UnicodeRange MiscellaneousSymbols => _u2600 ?? CreateRange(ref _u2600, '☀', '⛿');

		public static UnicodeRange Dingbats => _u2700 ?? CreateRange(ref _u2700, '✀', '➿');

		public static UnicodeRange MiscellaneousMathematicalSymbolsA => _u27C0 ?? CreateRange(ref _u27C0, '⟀', '⟯');

		public static UnicodeRange SupplementalArrowsA => _u27F0 ?? CreateRange(ref _u27F0, '⟰', '⟿');

		public static UnicodeRange BraillePatterns => _u2800 ?? CreateRange(ref _u2800, '⠀', '⣿');

		public static UnicodeRange SupplementalArrowsB => _u2900 ?? CreateRange(ref _u2900, '⤀', '⥿');

		public static UnicodeRange MiscellaneousMathematicalSymbolsB => _u2980 ?? CreateRange(ref _u2980, '⦀', '⧿');

		public static UnicodeRange SupplementalMathematicalOperators => _u2A00 ?? CreateRange(ref _u2A00, '⨀', '⫿');

		public static UnicodeRange MiscellaneousSymbolsandArrows => _u2B00 ?? CreateRange(ref _u2B00, '⬀', '⯿');

		public static UnicodeRange Glagolitic => _u2C00 ?? CreateRange(ref _u2C00, 'Ⰰ', 'ⱟ');

		public static UnicodeRange LatinExtendedC => _u2C60 ?? CreateRange(ref _u2C60, 'Ⱡ', 'Ɀ');

		public static UnicodeRange Coptic => _u2C80 ?? CreateRange(ref _u2C80, 'Ⲁ', '⳿');

		public static UnicodeRange GeorgianSupplement => _u2D00 ?? CreateRange(ref _u2D00, 'ⴀ', '\u2d2f');

		public static UnicodeRange Tifinagh => _u2D30 ?? CreateRange(ref _u2D30, 'ⴰ', '\u2d7f');

		public static UnicodeRange EthiopicExtended => _u2D80 ?? CreateRange(ref _u2D80, 'ⶀ', '\u2ddf');

		public static UnicodeRange CyrillicExtendedA => _u2DE0 ?? CreateRange(ref _u2DE0, '\u2de0', '\u2dff');

		public static UnicodeRange SupplementalPunctuation => _u2E00 ?? CreateRange(ref _u2E00, '⸀', '\u2e7f');

		public static UnicodeRange CjkRadicalsSupplement => _u2E80 ?? CreateRange(ref _u2E80, '⺀', '\u2eff');

		public static UnicodeRange KangxiRadicals => _u2F00 ?? CreateRange(ref _u2F00, '⼀', '\u2fdf');

		public static UnicodeRange IdeographicDescriptionCharacters => _u2FF0 ?? CreateRange(ref _u2FF0, '⿰', '\u2fff');

		public static UnicodeRange CjkSymbolsandPunctuation => _u3000 ?? CreateRange(ref _u3000, '\u3000', '〿');

		public static UnicodeRange Hiragana => _u3040 ?? CreateRange(ref _u3040, '\u3040', 'ゟ');

		public static UnicodeRange Katakana => _u30A0 ?? CreateRange(ref _u30A0, '゠', 'ヿ');

		public static UnicodeRange Bopomofo => _u3100 ?? CreateRange(ref _u3100, '\u3100', 'ㄯ');

		public static UnicodeRange HangulCompatibilityJamo => _u3130 ?? CreateRange(ref _u3130, '\u3130', '\u318f');

		public static UnicodeRange Kanbun => _u3190 ?? CreateRange(ref _u3190, '㆐', '㆟');

		public static UnicodeRange BopomofoExtended => _u31A0 ?? CreateRange(ref _u31A0, 'ㆠ', 'ㆿ');

		public static UnicodeRange CjkStrokes => _u31C0 ?? CreateRange(ref _u31C0, '㇀', '\u31ef');

		public static UnicodeRange KatakanaPhoneticExtensions => _u31F0 ?? CreateRange(ref _u31F0, 'ㇰ', 'ㇿ');

		public static UnicodeRange EnclosedCjkLettersandMonths => _u3200 ?? CreateRange(ref _u3200, '㈀', '㋿');

		public static UnicodeRange CjkCompatibility => _u3300 ?? CreateRange(ref _u3300, '㌀', '㏿');

		public static UnicodeRange CjkUnifiedIdeographsExtensionA => _u3400 ?? CreateRange(ref _u3400, '㐀', '䶿');

		public static UnicodeRange YijingHexagramSymbols => _u4DC0 ?? CreateRange(ref _u4DC0, '䷀', '䷿');

		public static UnicodeRange CjkUnifiedIdeographs => _u4E00 ?? CreateRange(ref _u4E00, '一', '鿿');

		public static UnicodeRange YiSyllables => _uA000 ?? CreateRange(ref _uA000, 'ꀀ', '\ua48f');

		public static UnicodeRange YiRadicals => _uA490 ?? CreateRange(ref _uA490, '꒐', '\ua4cf');

		public static UnicodeRange Lisu => _uA4D0 ?? CreateRange(ref _uA4D0, 'ꓐ', '꓿');

		public static UnicodeRange Vai => _uA500 ?? CreateRange(ref _uA500, 'ꔀ', '\ua63f');

		public static UnicodeRange CyrillicExtendedB => _uA640 ?? CreateRange(ref _uA640, 'Ꙁ', '\ua69f');

		public static UnicodeRange Bamum => _uA6A0 ?? CreateRange(ref _uA6A0, 'ꚠ', '\ua6ff');

		public static UnicodeRange ModifierToneLetters => _uA700 ?? CreateRange(ref _uA700, '\ua700', 'ꜟ');

		public static UnicodeRange LatinExtendedD => _uA720 ?? CreateRange(ref _uA720, '\ua720', 'ꟿ');

		public static UnicodeRange SylotiNagri => _uA800 ?? CreateRange(ref _uA800, 'ꠀ', '\ua82f');

		public static UnicodeRange CommonIndicNumberForms => _uA830 ?? CreateRange(ref _uA830, '꠰', '\ua83f');

		public static UnicodeRange Phagspa => _uA840 ?? CreateRange(ref _uA840, 'ꡀ', '\ua87f');

		public static UnicodeRange Saurashtra => _uA880 ?? CreateRange(ref _uA880, '\ua880', '\ua8df');

		public static UnicodeRange DevanagariExtended => _uA8E0 ?? CreateRange(ref _uA8E0, '\ua8e0', '\ua8ff');

		public static UnicodeRange KayahLi => _uA900 ?? CreateRange(ref _uA900, '꤀', '꤯');

		public static UnicodeRange Rejang => _uA930 ?? CreateRange(ref _uA930, 'ꤰ', '꥟');

		public static UnicodeRange HangulJamoExtendedA => _uA960 ?? CreateRange(ref _uA960, 'ꥠ', '\ua97f');

		public static UnicodeRange Javanese => _uA980 ?? CreateRange(ref _uA980, '\ua980', '꧟');

		public static UnicodeRange MyanmarExtendedB => _uA9E0 ?? CreateRange(ref _uA9E0, 'ꧠ', '\ua9ff');

		public static UnicodeRange Cham => _uAA00 ?? CreateRange(ref _uAA00, 'ꨀ', '꩟');

		public static UnicodeRange MyanmarExtendedA => _uAA60 ?? CreateRange(ref _uAA60, 'ꩠ', 'ꩿ');

		public static UnicodeRange TaiViet => _uAA80 ?? CreateRange(ref _uAA80, 'ꪀ', '꫟');

		public static UnicodeRange MeeteiMayekExtensions => _uAAE0 ?? CreateRange(ref _uAAE0, 'ꫠ', '\uaaff');

		public static UnicodeRange EthiopicExtendedA => _uAB00 ?? CreateRange(ref _uAB00, '\uab00', '\uab2f');

		public static UnicodeRange LatinExtendedE => _uAB30 ?? CreateRange(ref _uAB30, 'ꬰ', '\uab6f');

		public static UnicodeRange CherokeeSupplement => _uAB70 ?? CreateRange(ref _uAB70, 'ꭰ', 'ꮿ');

		public static UnicodeRange MeeteiMayek => _uABC0 ?? CreateRange(ref _uABC0, 'ꯀ', '\uabff');

		public static UnicodeRange HangulSyllables => _uAC00 ?? CreateRange(ref _uAC00, '가', '\ud7af');

		public static UnicodeRange HangulJamoExtendedB => _uD7B0 ?? CreateRange(ref _uD7B0, 'ힰ', '\ud7ff');

		public static UnicodeRange CjkCompatibilityIdeographs => _uF900 ?? CreateRange(ref _uF900, '豈', '\ufaff');

		public static UnicodeRange AlphabeticPresentationForms => _uFB00 ?? CreateRange(ref _uFB00, 'ﬀ', 'ﭏ');

		public static UnicodeRange ArabicPresentationFormsA => _uFB50 ?? CreateRange(ref _uFB50, 'ﭐ', '﷿');

		public static UnicodeRange VariationSelectors => _uFE00 ?? CreateRange(ref _uFE00, '\ufe00', '\ufe0f');

		public static UnicodeRange VerticalForms => _uFE10 ?? CreateRange(ref _uFE10, '︐', '\ufe1f');

		public static UnicodeRange CombiningHalfMarks => _uFE20 ?? CreateRange(ref _uFE20, '\ufe20', '\ufe2f');

		public static UnicodeRange CjkCompatibilityForms => _uFE30 ?? CreateRange(ref _uFE30, '︰', '\ufe4f');

		public static UnicodeRange SmallFormVariants => _uFE50 ?? CreateRange(ref _uFE50, '﹐', '\ufe6f');

		public static UnicodeRange ArabicPresentationFormsB => _uFE70 ?? CreateRange(ref _uFE70, 'ﹰ', '\ufeff');

		public static UnicodeRange HalfwidthandFullwidthForms => _uFF00 ?? CreateRange(ref _uFF00, '\uff00', '\uffef');

		public static UnicodeRange Specials => _uFFF0 ?? CreateRange(ref _uFFF0, '\ufff0', '\uffff');

		[MethodImpl(MethodImplOptions.NoInlining)]
		private static UnicodeRange CreateEmptyRange(ref UnicodeRange range)
		{
			Volatile.Write(ref range, new UnicodeRange(0, 0));
			return range;
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		private static UnicodeRange CreateRange(ref UnicodeRange range, char first, char last)
		{
			Volatile.Write(ref range, UnicodeRange.Create(first, last));
			return range;
		}
	}
}
namespace System.Text.Internal
{
	internal readonly struct AllowedCharactersBitmap
	{
		private const int ALLOWED_CHARS_BITMAP_LENGTH = 2048;

		private readonly uint[] _allowedCharacters;

		public static AllowedCharactersBitmap CreateNew()
		{
			return new AllowedCharactersBitmap(new uint[2048]);
		}

		private AllowedCharactersBitmap(uint[] allowedCharacters)
		{
			if (allowedCharacters == null)
			{
				throw new ArgumentNullException("allowedCharacters");
			}
			_allowedCharacters = allowedCharacters;
		}

		public void AllowCharacter(char character)
		{
			int num = (int)character >> 5;
			int num2 = character & 0x1F;
			_allowedCharacters[num] |= (uint)(1 << num2);
		}

		public void ForbidCharacter(char character)
		{
			int num = (int)character >> 5;
			int num2 = character & 0x1F;
			_allowedCharacters[num] &= (uint)(~(1 << num2));
		}

		public void ForbidUndefinedCharacters()
		{
			ReadOnlySpan<uint> definedCharacterBitmap = UnicodeHelpers.GetDefinedCharacterBitmap();
			for (int i = 0; i < _allowedCharacters.Length; i++)
			{
				_allowedCharacters[i] &= definedCharacterBitmap[i];
			}
		}

		public void Clear()
		{
			Array.Clear(_allowedCharacters, 0, _allowedCharacters.Length);
		}

		public AllowedCharactersBitmap Clone()
		{
			return new AllowedCharactersBitmap((uint[])_allowedCharacters.Clone());
		}

		public bool IsCharacterAllowed(char character)
		{
			int num = (int)character >> 5;
			int num2 = character & 0x1F;
			return ((_allowedCharacters[num] >> num2) & 1) != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public bool IsUnicodeScalarAllowed(int unicodeScalar)
		{
			int num = unicodeScalar >> 5;
			int num2 = unicodeScalar & 0x1F;
			return ((_allowedCharacters[num] >> num2) & 1) != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe int FindFirstCharacterToEncode(char* text, int textLength)
		{
			for (int i = 0; i < textLength; i++)
			{
				if (!IsCharacterAllowed(text[i]))
				{
					return i;
				}
			}
			return -1;
		}
	}
}
namespace System.Text.Encodings.Web
{
	internal static class HexUtil
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static char UInt32LsbToHexDigit(uint value)
		{
			if (value >= 10)
			{
				return (char)(65 + (value - 10));
			}
			return (char)(48 + value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static char Int32LsbToHexDigit(int value)
		{
			return (char)((value < 10) ? (48 + value) : (65 + (value - 10)));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ByteToHexDigits(byte value, out char firstHexChar, out char secondHexChar)
		{
			firstHexChar = UInt32LsbToHexDigit((uint)value >> 4);
			secondHexChar = UInt32LsbToHexDigit((uint)(value & 0xF));
		}
	}
	public abstract class HtmlEncoder : TextEncoder
	{
		public static HtmlEncoder Default => DefaultHtmlEncoder.Singleton;

		public static HtmlEncoder Create(TextEncoderSettings settings)
		{
			return new DefaultHtmlEncoder(settings);
		}

		public static HtmlEncoder Create(params UnicodeRange[] allowedRanges)
		{
			return new DefaultHtmlEncoder(allowedRanges);
		}
	}
	internal sealed class DefaultHtmlEncoder : HtmlEncoder
	{
		private AllowedCharactersBitmap _allowedCharacters;

		internal static readonly DefaultHtmlEncoder Singleton = new DefaultHtmlEncoder(new TextEncoderSettings(UnicodeRanges.BasicLatin));

		private static readonly char[] s_quote = "&quot;".ToCharArray();

		private static readonly char[] s_ampersand = "&amp;".ToCharArray();

		private static readonly char[] s_lessthan = "&lt;".ToCharArray();

		private static readonly char[] s_greaterthan = "&gt;".ToCharArray();

		public override int MaxOutputCharactersPerInputCharacter => 10;

		public DefaultHtmlEncoder(TextEncoderSettings settings)
		{
			if (settings == null)
			{
				throw new ArgumentNullException("settings");
			}
			_allowedCharacters = settings.GetAllowedCharacters();
			_allowedCharacters.ForbidUndefinedCharacters();
			ForbidHtmlCharacters(_allowedCharacters);
		}

		internal static void ForbidHtmlCharacters(AllowedCharactersBitmap allowedCharacters)
		{
			allowedCharacters.ForbidCharacter('<');
			allowedCharacters.ForbidCharacter('>');
			allowedCharacters.ForbidCharacter('&');
			allowedCharacters.ForbidCharacter('\'');
			allowedCharacters.ForbidCharacter('"');
			allowedCharacters.ForbidCharacter('+');
		}

		public DefaultHtmlEncoder(params UnicodeRange[] allowedRanges)
			: this(new TextEncoderSettings(allowedRanges))
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public override bool WillEncode(int unicodeScalar)
		{
			if (UnicodeHelpers.IsSupplementaryCodePoint(unicodeScalar))
			{
				return true;
			}
			return !_allowedCharacters.IsUnicodeScalarAllowed(unicodeScalar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe override int FindFirstCharacterToEncode(char* text, int textLength)
		{
			return _allowedCharacters.FindFirstCharacterToEncode(text, textLength);
		}

		public unsafe override bool TryEncodeUnicodeScalar(int unicodeScalar, char* buffer, int bufferLength, out int numberOfCharactersWritten)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (!WillEncode(unicodeScalar))
			{
				return TextEncoder.TryWriteScalarAsChar(unicodeScalar, buffer, bufferLength, out numberOfCharactersWritten);
			}
			return unicodeScalar switch
			{
				34 => TextEncoder.TryCopyCharacters(s_quote, buffer, bufferLength, out numberOfCharactersWritten), 
				38 => TextEncoder.TryCopyCharacters(s_ampersand, buffer, bufferLength, out numberOfCharactersWritten), 
				60 => TextEncoder.TryCopyCharacters(s_lessthan, buffer, bufferLength, out numberOfCharactersWritten), 
				62 => TextEncoder.TryCopyCharacters(s_greaterthan, buffer, bufferLength, out numberOfCharactersWritten), 
				_ => TryWriteEncodedScalarAsNumericEntity(unicodeScalar, buffer, bufferLength, out numberOfCharactersWritten), 
			};
		}

		private unsafe static bool TryWriteEncodedScalarAsNumericEntity(int unicodeScalar, char* buffer, int bufferLength, out int numberOfCharactersWritten)
		{
			int num = 0;
			int num2 = unicodeScalar;
			do
			{
				num++;
				num2 >>= 4;
			}
			while (num2 != 0);
			numberOfCharactersWritten = num + 4;
			if (num + 4 > bufferLength)
			{
				numberOfCharactersWritten = 0;
				return false;
			}
			*buffer = '&';
			buffer++;
			*buffer = '#';
			buffer++;
			*buffer = 'x';
			buffer += num;
			do
			{
				*buffer = HexUtil.Int32LsbToHexDigit(unicodeScalar & 0xF);
				unicodeScalar >>= 4;
				buffer--;
			}
			while (unicodeScalar != 0);
			buffer += num + 1;
			*buffer = ';';
			return true;
		}
	}
	public abstract class JavaScriptEncoder : TextEncoder
	{
		public static JavaScriptEncoder Default => DefaultJavaScriptEncoder.Singleton;

		public static JavaScriptEncoder UnsafeRelaxedJsonEscaping => UnsafeRelaxedJavaScriptEncoder.s_singleton;

		public static JavaScriptEncoder Create(TextEncoderSettings settings)
		{
			return new DefaultJavaScriptEncoder(settings);
		}

		public static JavaScriptEncoder Create(params UnicodeRange[] allowedRanges)
		{
			return new DefaultJavaScriptEncoder(allowedRanges);
		}
	}
	internal sealed class DefaultJavaScriptEncoder : JavaScriptEncoder
	{
		private AllowedCharactersBitmap _allowedCharacters;

		internal static readonly DefaultJavaScriptEncoder Singleton = new DefaultJavaScriptEncoder(new TextEncoderSettings(UnicodeRanges.BasicLatin));

		private static readonly char[] s_b = new char[2] { '\\', 'b' };

		private static readonly char[] s_t = new char[2] { '\\', 't' };

		private static readonly char[] s_n = new char[2] { '\\', 'n' };

		private static readonly char[] s_f = new char[2] { '\\', 'f' };

		private static readonly char[] s_r = new char[2] { '\\', 'r' };

		private static readonly char[] s_back = new char[2] { '\\', '\\' };

		public override int MaxOutputCharactersPerInputCharacter => 12;

		public DefaultJavaScriptEncoder(TextEncoderSettings filter)
		{
			if (filter == null)
			{
				throw new ArgumentNullException("filter");
			}
			_allowedCharacters = filter.GetAllowedCharacters();
			_allowedCharacters.ForbidUndefinedCharacters();
			DefaultHtmlEncoder.ForbidHtmlCharacters(_allowedCharacters);
			_allowedCharacters.ForbidCharacter('\\');
			_allowedCharacters.ForbidCharacter('`');
		}

		public DefaultJavaScriptEncoder(params UnicodeRange[] allowedRanges)
			: this(new TextEncoderSettings(allowedRanges))
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public override bool WillEncode(int unicodeScalar)
		{
			if (UnicodeHelpers.IsSupplementaryCodePoint(unicodeScalar))
			{
				return true;
			}
			return !_allowedCharacters.IsUnicodeScalarAllowed(unicodeScalar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe override int FindFirstCharacterToEncode(char* text, int textLength)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			return _allowedCharacters.FindFirstCharacterToEncode(text, textLength);
		}

		public unsafe override bool TryEncodeUnicodeScalar(int unicodeScalar, char* buffer, int bufferLength, out int numberOfCharactersWritten)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (!WillEncode(unicodeScalar))
			{
				return TextEncoder.TryWriteScalarAsChar(unicodeScalar, buffer, bufferLength, out numberOfCharactersWritten);
			}
			char[] source;
			switch (unicodeScalar)
			{
			case 8:
				source = s_b;
				break;
			case 9:
				source = s_t;
				break;
			case 10:
				source = s_n;
				break;
			case 12:
				source = s_f;
				break;
			case 13:
				source = s_r;
				break;
			case 92:
				source = s_back;
				break;
			default:
				return TryWriteEncodedScalarAsNumericEntity(unicodeScalar, buffer, bufferLength, out numberOfCharactersWritten);
			}
			return TextEncoder.TryCopyCharacters(source, buffer, bufferLength, out numberOfCharactersWritten);
		}

		private unsafe static bool TryWriteEncodedScalarAsNumericEntity(int unicodeScalar, char* buffer, int length, out int numberOfCharactersWritten)
		{
			if (UnicodeHelpers.IsSupplementaryCodePoint(unicodeScalar))
			{
				UnicodeHelpers.GetUtf16SurrogatePairFromAstralScalarValue(unicodeScalar, out var highSurrogate, out var lowSurrogate);
				if (TryWriteEncodedSingleCharacter(highSurrogate, buffer, length, out var numberOfCharactersWritten2) && TryWriteEncodedSingleCharacter(lowSurrogate, buffer + numberOfCharactersWritten2, length - numberOfCharactersWritten2, out numberOfCharactersWritten))
				{
					numberOfCharactersWritten += numberOfCharactersWritten2;
					return true;
				}
				numberOfCharactersWritten = 0;
				return false;
			}
			return TryWriteEncodedSingleCharacter(unicodeScalar, buffer, length, out numberOfCharactersWritten);
		}

		private unsafe static bool TryWriteEncodedSingleCharacter(int unicodeScalar, char* buffer, int length, out int numberOfCharactersWritten)
		{
			if (length < 6)
			{
				numberOfCharactersWritten = 0;
				return false;
			}
			*buffer = '\\';
			buffer++;
			*buffer = 'u';
			buffer++;
			*buffer = HexUtil.Int32LsbToHexDigit(unicodeScalar >> 12);
			buffer++;
			*buffer = HexUtil.Int32LsbToHexDigit((int)((long)(unicodeScalar >> 8) & 0xFL));
			buffer++;
			*buffer = HexUtil.Int32LsbToHexDigit((int)((long)(unicodeScalar >> 4) & 0xFL));
			buffer++;
			*buffer = HexUtil.Int32LsbToHexDigit((int)((long)unicodeScalar & 0xFL));
			buffer++;
			numberOfCharactersWritten = 6;
			return true;
		}
	}
	public abstract class TextEncoder
	{
		private const int EncodeStartingOutputBufferSize = 1024;

		private byte[][] _asciiEscape = new byte[128][];

		private static readonly byte[] s_noEscape = Array.Empty<byte>();

		[EditorBrowsable(EditorBrowsableState.Never)]
		public abstract int MaxOutputCharactersPerInputCharacter { get; }

		[CLSCompliant(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public unsafe abstract bool TryEncodeUnicodeScalar(int unicodeScalar, char* buffer, int bufferLength, out int numberOfCharactersWritten);

		[CLSCompliant(false)]
		[EditorBrowsable(EditorBrowsableState.Never)]
		public unsafe abstract int FindFirstCharacterToEncode(char* text, int textLength);

		[EditorBrowsable(EditorBrowsableState.Never)]
		public abstract bool WillEncode(int unicodeScalar);

		public virtual string Encode(string value)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			int num = FindFirstCharacterToEncode(MemoryExtensions.AsSpan(value));
			if (num < 0)
			{
				return value;
			}
			ReadOnlySpan<char> source = MemoryExtensions.AsSpan(value, num);
			Span<char> initialBuffer = stackalloc char[1024];
			System.Text.ValueStringBuilder valueStringBuilder = new System.Text.ValueStringBuilder(initialBuffer);
			valueStringBuilder.Append(MemoryExtensions.AsSpan(value, 0, num));
			int val = Math.Max(MaxOutputCharactersPerInputCharacter, 1024);
			do
			{
				Span<char> destination = valueStringBuilder.AppendSpan(Math.Max(source.Length, val));
				Encode(source, destination, out var charsConsumed, out var charsWritten);
				if (charsWritten == 0 || (uint)charsWritten > (uint)destination.Length)
				{
					ThrowArgumentException_MaxOutputCharsPerInputChar();
				}
				source = source.Slice(charsConsumed);
				valueStringBuilder.Length -= destination.Length - charsWritten;
			}
			while (!source.IsEmpty);
			return valueStringBuilder.ToString();
		}

		public void Encode(TextWriter output, string value)
		{
			Encode(output, value, 0, value.Length);
		}

		public virtual void Encode(TextWriter output, string value, int startIndex, int characterCount)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (output == null)
			{
				throw new ArgumentNullException("output");
			}
			ValidateRanges(startIndex, characterCount, value.Length);
			int num = FindFirstCharacterToEncode(MemoryExtensions.AsSpan(value, startIndex, characterCount));
			if (num < 0)
			{
				num = characterCount;
			}
			output.WritePartialString(value, startIndex, num);
			if (num != characterCount)
			{
				Encode(output, MemoryExtensions.AsSpan(value, startIndex + num, characterCount - num));
			}
		}

		public virtual void Encode(TextWriter output, char[] value, int startIndex, int characterCount)
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			if (output == null)
			{
				throw new ArgumentNullException("output");
			}
			ValidateRanges(startIndex, characterCount, value.Length);
			int num = FindFirstCharacterToEncode(MemoryExtensions.AsSpan(value, startIndex, characterCount));
			if (num < 0)
			{
				num = characterCount;
			}
			output.Write(value, startIndex, num);
			if (num != characterCount)
			{
				Encode(output, MemoryExtensions.AsSpan(value, startIndex + num, characterCount - num));
			}
		}

		public unsafe virtual OperationStatus EncodeUtf8(ReadOnlySpan<byte> utf8Source, Span<byte> utf8Destination, out int bytesConsumed, out int bytesWritten, bool isFinalBlock = true)
		{
			int length = utf8Source.Length;
			int length2 = utf8Destination.Length;
			char* ptr = stackalloc char[24];
			byte* ptr2 = stackalloc byte[72];
			int bytesConsumed2 = 0;
			int num = 0;
			OperationStatus operationStatus = OperationStatus.Done;
			while (true)
			{
				if (!utf8Source.IsEmpty)
				{
					uint result;
					do
					{
						result = utf8Source[num];
						if (System.Text.UnicodeUtility.IsAsciiCodePoint(result))
						{
							byte[] asciiEncoding = GetAsciiEncoding((byte)result);
							if (asciiEncoding == s_noEscape)
							{
								if (++num > utf8Destination.Length)
								{
									num--;
									operationStatus = OperationStatus.DestinationTooSmall;
									break;
								}
								continue;
							}
							if (asciiEncoding == null)
							{
								operationStatus = OperationStatus.Done;
								bytesConsumed2 = 1;
								break;
							}
							if (num > 0)
							{
								utf8Source.Slice(0, num).CopyTo(utf8Destination);
								utf8Source = utf8Source.Slice(num);
								utf8Destination = utf8Destination.Slice(num);
								num = 0;
							}
							if (!((ReadOnlySpan<byte>)asciiEncoding).TryCopyTo(utf8Destination))
							{
								operationStatus = OperationStatus.DestinationTooSmall;
								break;
							}
							utf8Destination = utf8Destination.Slice(asciiEncoding.Length);
							utf8Source = utf8Source.Slice(1);
						}
						else
						{
							operationStatus = UnicodeHelpers.DecodeScalarValueFromUtf8(utf8Source.Slice(num), out result, out bytesConsumed2);
							if (operationStatus != OperationStatus.Done || WillEncode((int)result))
							{
								break;
							}
							num += bytesConsumed2;
							if (num > utf8Destination.Length)
							{
								num -= bytesConsumed2;
								operationStatus = OperationStatus.DestinationTooSmall;
								break;
							}
						}
					}
					while (num < utf8Source.Length);
					if (num > 0)
					{
						utf8Source.Slice(0, num).CopyTo(utf8Destination);
						utf8Source = utf8Source.Slice(num);
						utf8Destination = utf8Destination.Slice(num);
						num = 0;
					}
					if (!utf8Source.IsEmpty)
					{
						if (operationStatus != OperationStatus.Done)
						{
							if (operationStatus == OperationStatus.NeedMoreData)
							{
								if (!isFinalBlock)
								{
									bytesConsumed = length - utf8Source.Length;
									bytesWritten = length2 - utf8Destination.Length;
									return OperationStatus.NeedMoreData;
								}
							}
							else if (operationStatus == OperationStatus.DestinationTooSmall)
							{
								break;
							}
						}
						if (TryEncodeUnicodeScalar((int)result, ptr, 24, out var numberOfCharactersWritten))
						{
							int bytes = Encoding.UTF8.GetBytes(ptr, numberOfCharactersWritten, ptr2, 72);
							ReadOnlySpan<byte> readOnlySpan = new ReadOnlySpan<byte>(ptr2, bytes);
							if (System.Text.UnicodeUtility.IsAsciiCodePoint(result))
							{
								_asciiEscape[result] = readOnlySpan.ToArray();
							}
							if (!readOnlySpan.TryCopyTo(utf8Destination))
							{
								break;
							}
							utf8Destination = utf8Destination.Slice(bytes);
							utf8Source = utf8Source.Slice(bytesConsumed2);
							continue;
						}
						bytesConsumed = length - utf8Source.Length;
						bytesWritten = length2 - utf8Destination.Length;
						return OperationStatus.InvalidData;
					}
				}
				bytesConsumed = length;
				bytesWritten = length2 - utf8Destination.Length;
				return OperationStatus.Done;
			}
			bytesConsumed = length - utf8Source.Length;
			bytesWritten = length2 - utf8Destination.Length;
			return OperationStatus.DestinationTooSmall;
		}

		internal static OperationStatus EncodeUtf8Shim(TextEncoder encoder, ReadOnlySpan<byte> utf8Source, Span<byte> utf8Destination, out int bytesConsumed, out int bytesWritten, bool isFinalBlock)
		{
			return encoder.EncodeUtf8(utf8Source, utf8Destination, out bytesConsumed, out bytesWritten, isFinalBlock);
		}

		public virtual OperationStatus Encode(ReadOnlySpan<char> source, Span<char> destination, out int charsConsumed, out int charsWritten, bool isFinalBlock = true)
		{
			if (source.IsEmpty)
			{
				charsConsumed = 0;
				charsWritten = 0;
				return OperationStatus.Done;
			}
			ReadOnlySpan<char> text = source;
			if (destination.Length < source.Length)
			{
				text = source.Slice(0, destination.Length);
			}
			int num = FindFirstCharacterToEncode(text);
			if (num < 0)
			{
				num = text.Length;
			}
			source.Slice(0, num).CopyTo(destination);
			if (num == source.Length)
			{
				charsConsumed = source.Length;
				charsWritten = source.Length;
				return OperationStatus.Done;
			}
			int charsConsumed2;
			int charsWritten2;
			OperationStatus result = EncodeCore(source.Slice(num), destination.Slice(num), out charsConsumed2, out charsWritten2, isFinalBlock);
			charsConsumed = num + charsConsumed2;
			charsWritten = num + charsWritten2;
			return result;
			unsafe OperationStatus EncodeCore(ReadOnlySpan<char> readOnlySpan, Span<char> span, out int reference2, out int reference3, bool flag)
			{
				if (span.IsEmpty)
				{
					span = Array.Empty<char>();
				}
				int num2 = 0;
				int num3 = 0;
				OperationStatus result2;
				while (true)
				{
					if ((uint)num3 >= (uint)readOnlySpan.Length)
					{
						result2 = OperationStatus.Done;
						break;
					}
					int num4 = readOnlySpan[num3];
					if (!System.Text.UnicodeUtility.IsSurrogateCodePoint((uint)num4))
					{
						if (!WillEncode(num4))
						{
							if ((uint)num2 < (uint)span.Length)
							{
								span[num2++] = (char)num4;
								num3++;
								continue;
							}
							goto IL_0143;
						}
					}
					else
					{
						uint num5 = (uint)num4;
						num4 = 65533;
						if (System.Text.UnicodeUtility.IsHighSurrogateCodePoint(num5))
						{
							int num6 = num3 + 1;
							if ((uint)num6 >= (uint)readOnlySpan.Length)
							{
								if (!flag)
								{
									result2 = OperationStatus.NeedMoreData;
									break;
								}
							}
							else
							{
								uint num7 = readOnlySpan[num6];
								if (System.Text.UnicodeUtility.IsLowSurrogateCodePoint(num7))
								{
									num4 = (int)System.Text.UnicodeUtility.GetScalarFromUtf16SurrogatePair(num5, num7);
									if (!WillEncode(num4))
									{
										if ((uint)(num2 + 1) < (uint)span.Length)
										{
											span[num2] = (char)num5;
											span[num2 + 1] = (char)num7;
											num2 += 2;
											num3 += 2;
											continue;
										}
										goto IL_0143;
									}
								}
							}
						}
					}
					int numberOfCharactersWritten;
					fixed (char* reference = &MemoryMarshal.GetReference(span))
					{
						if (!TryEncodeUnicodeScalar(num4, reference + num2, span.Length - num2, out numberOfCharactersWritten))
						{
							goto IL_0143;
						}
					}
					num3 += System.Text.UnicodeUtility.GetUtf16SequenceLength((uint)num4);
					num2 += numberOfCharactersWritten;
					continue;
					IL_0143:
					result2 = OperationStatus.DestinationTooSmall;
					break;
				}
				reference2 = num3;
				reference3 = num2;
				return result2;
			}
		}

		private void Encode(TextWriter output, ReadOnlySpan<char> value)
		{
			int val = Math.Max(MaxOutputCharactersPerInputCharacter, 1024);
			char[] array = ArrayPool<char>.Shared.Rent(Math.Max(value.Length, val));
			Span<char> destination = array;
			do
			{
				Encode(value, destination, out var charsConsumed, out var charsWritten);
				if (charsWritten == 0 || (uint)charsWritten > (uint)destination.Length)
				{
					ThrowArgumentException_MaxOutputCharsPerInputChar();
				}
				output.Write(array, 0, charsWritten);
				value = value.Slice(charsConsumed);
			}
			while (!value.IsEmpty);
			ArrayPool<char>.Shared.Return(array);
		}

		private unsafe int FindFirstCharacterToEncode(ReadOnlySpan<char> text)
		{
			fixed (char* reference = &MemoryMarshal.GetReference(text))
			{
				return FindFirstCharacterToEncode(reference, text.Length);
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public virtual int FindFirstCharacterToEncodeUtf8(ReadOnlySpan<byte> utf8Text)
		{
			int length = utf8Text.Length;
			int num = 0;
			while (num < utf8Text.Length)
			{
				byte value = utf8Text[num];
				if (System.Text.UnicodeUtility.IsAsciiCodePoint(value))
				{
					if (GetAsciiEncoding(value) != s_noEscape)
					{
						return length - utf8Text.Length + num;
					}
					num++;
					continue;
				}
				if (num > 0)
				{
					utf8Text = utf8Text.Slice(num);
				}
				if (UnicodeHelpers.DecodeScalarValueFromUtf8(utf8Text, out var result, out var bytesConsumed) != OperationStatus.Done || WillEncode((int)result))
				{
					return length - utf8Text.Length;
				}
				num = bytesConsumed;
			}
			return -1;
		}

		internal static int FindFirstCharacterToEncodeUtf8Shim(TextEncoder encoder, ReadOnlySpan<byte> utf8Text)
		{
			return encoder.FindFirstCharacterToEncodeUtf8(utf8Text);
		}

		internal unsafe static bool TryCopyCharacters(char[] source, char* destination, int destinationLength, out int numberOfCharactersWritten)
		{
			if (destinationLength < source.Length)
			{
				numberOfCharactersWritten = 0;
				return false;
			}
			for (int i = 0; i < source.Length; i++)
			{
				destination[i] = source[i];
			}
			numberOfCharactersWritten = source.Length;
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal unsafe static bool TryWriteScalarAsChar(int unicodeScalar, char* destination, int destinationLength, out int numberOfCharactersWritten)
		{
			if (destinationLength < 1)
			{
				numberOfCharactersWritten = 0;
				return false;
			}
			*destination = (char)unicodeScalar;
			numberOfCharactersWritten = 1;
			return true;
		}

		private static void ValidateRanges(int startIndex, int characterCount, int actualInputLength)
		{
			if (startIndex < 0 || startIndex > actualInputLength)
			{
				throw new ArgumentOutOfRangeException("startIndex");
			}
			if (characterCount < 0 || characterCount > actualInputLength - startIndex)
			{
				throw new ArgumentOutOfRangeException("characterCount");
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private byte[] GetAsciiEncoding(byte value)
		{
			byte[] array = _asciiEscape[value];
			if (array == null && !WillEncode(value))
			{
				array = s_noEscape;
				_asciiEscape[value] = array;
			}
			return array;
		}

		private static void ThrowArgumentException_MaxOutputCharsPerInputChar()
		{
			throw new ArgumentException("Argument encoder does not implement MaxOutputCharsPerInputChar correctly.");
		}
	}
	public class TextEncoderSettings
	{
		private AllowedCharactersBitmap _allowedCharactersBitmap;

		public TextEncoderSettings()
		{
			_allowedCharactersBitmap = AllowedCharactersBitmap.CreateNew();
		}

		public TextEncoderSettings(TextEncoderSettings other)
		{
			if (other == null)
			{
				throw new ArgumentNullException("other");
			}
			_allowedCharactersBitmap = AllowedCharactersBitmap.CreateNew();
			AllowCodePoints(other.GetAllowedCodePoints());
		}

		public TextEncoderSettings(params UnicodeRange[] allowedRanges)
		{
			if (allowedRanges == null)
			{
				throw new ArgumentNullException("allowedRanges");
			}
			_allowedCharactersBitmap = AllowedCharactersBitmap.CreateNew();
			AllowRanges(allowedRanges);
		}

		public virtual void AllowCharacter(char character)
		{
			_allowedCharactersBitmap.AllowCharacter(character);
		}

		public virtual void AllowCharacters(params char[] characters)
		{
			if (characters == null)
			{
				throw new ArgumentNullException("characters");
			}
			for (int i = 0; i < characters.Length; i++)
			{
				_allowedCharactersBitmap.AllowCharacter(characters[i]);
			}
		}

		public virtual void AllowCodePoints(IEnumerable<int> codePoints)
		{
			if (codePoints == null)
			{
				throw new ArgumentNullException("codePoints");
			}
			foreach (int codePoint in codePoints)
			{
				char c = (char)codePoint;
				if (codePoint == c)
				{
					_allowedCharactersBitmap.AllowCharacter(c);
				}
			}
		}

		public virtual void AllowRange(UnicodeRange range)
		{
			if (range == null)
			{
				throw new ArgumentNullException("range");
			}
			int firstCodePoint = range.FirstCodePoint;
			int length = range.Length;
			for (int i = 0; i < length; i++)
			{
				_allowedCharactersBitmap.AllowCharacter((char)(firstCodePoint + i));
			}
		}

		public virtual void AllowRanges(params UnicodeRange[] ranges)
		{
			if (ranges == null)
			{
				throw new ArgumentNullException("ranges");
			}
			for (int i = 0; i < ranges.Length; i++)
			{
				AllowRange(ranges[i]);
			}
		}

		public virtual void Clear()
		{
			_allowedCharactersBitmap.Clear();
		}

		public virtual void ForbidCharacter(char character)
		{
			_allowedCharactersBitmap.ForbidCharacter(character);
		}

		public virtual void ForbidCharacters(params char[] characters)
		{
			if (characters == null)
			{
				throw new ArgumentNullException("characters");
			}
			for (int i = 0; i < characters.Length; i++)
			{
				_allowedCharactersBitmap.ForbidCharacter(characters[i]);
			}
		}

		public virtual void ForbidRange(UnicodeRange range)
		{
			if (range == null)
			{
				throw new ArgumentNullException("range");
			}
			int firstCodePoint = range.FirstCodePoint;
			int length = range.Length;
			for (int i = 0; i < length; i++)
			{
				_allowedCharactersBitmap.ForbidCharacter((char)(firstCodePoint + i));
			}
		}

		public virtual void ForbidRanges(params UnicodeRange[] ranges)
		{
			if (ranges == null)
			{
				throw new ArgumentNullException("ranges");
			}
			for (int i = 0; i < ranges.Length; i++)
			{
				ForbidRange(ranges[i]);
			}
		}

		internal AllowedCharactersBitmap GetAllowedCharacters()
		{
			return _allowedCharactersBitmap.Clone();
		}

		public virtual IEnumerable<int> GetAllowedCodePoints()
		{
			for (int i = 0; i < 65536; i++)
			{
				if (_allowedCharactersBitmap.IsCharacterAllowed((char)i))
				{
					yield return i;
				}
			}
		}
	}
	internal sealed class UnsafeRelaxedJavaScriptEncoder : JavaScriptEncoder
	{
		private readonly AllowedCharactersBitmap _allowedCharacters;

		internal static readonly UnsafeRelaxedJavaScriptEncoder s_singleton = new UnsafeRelaxedJavaScriptEncoder(new TextEncoderSettings(UnicodeRanges.All));

		private static readonly char[] s_b = new char[2] { '\\', 'b' };

		private static readonly char[] s_t = new char[2] { '\\', 't' };

		private static readonly char[] s_n = new char[2] { '\\', 'n' };

		private static readonly char[] s_f = new char[2] { '\\', 'f' };

		private static readonly char[] s_r = new char[2] { '\\', 'r' };

		private static readonly char[] s_back = new char[2] { '\\', '\\' };

		private static readonly char[] s_doubleQuote = new char[2] { '\\', '"' };

		public override int MaxOutputCharactersPerInputCharacter => 12;

		private UnsafeRelaxedJavaScriptEncoder(TextEncoderSettings filter)
		{
			if (filter == null)
			{
				throw new ArgumentNullException("filter");
			}
			_allowedCharacters = filter.GetAllowedCharacters();
			_allowedCharacters.ForbidUndefinedCharacters();
			_allowedCharacters.ForbidCharacter('"');
			_allowedCharacters.ForbidCharacter('\\');
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public override bool WillEncode(int unicodeScalar)
		{
			if (UnicodeHelpers.IsSupplementaryCodePoint(unicodeScalar))
			{
				return true;
			}
			return !_allowedCharacters.IsUnicodeScalarAllowed(unicodeScalar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe override int FindFirstCharacterToEncode(char* text, int textLength)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			return _allowedCharacters.FindFirstCharacterToEncode(text, textLength);
		}

		public unsafe override bool TryEncodeUnicodeScalar(int unicodeScalar, char* buffer, int bufferLength, out int numberOfCharactersWritten)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (!WillEncode(unicodeScalar))
			{
				return TextEncoder.TryWriteScalarAsChar(unicodeScalar, buffer, bufferLength, out numberOfCharactersWritten);
			}
			char[] source;
			switch (unicodeScalar)
			{
			case 34:
				source = s_doubleQuote;
				break;
			case 8:
				source = s_b;
				break;
			case 9:
				source = s_t;
				break;
			case 10:
				source = s_n;
				break;
			case 12:
				source = s_f;
				break;
			case 13:
				source = s_r;
				break;
			case 92:
				source = s_back;
				break;
			default:
				return TryWriteEncodedScalarAsNumericEntity(unicodeScalar, buffer, bufferLength, out numberOfCharactersWritten);
			}
			return TextEncoder.TryCopyCharacters(source, buffer, bufferLength, out numberOfCharactersWritten);
		}

		private unsafe static bool TryWriteEncodedScalarAsNumericEntity(int unicodeScalar, char* buffer, int length, out int numberOfCharactersWritten)
		{
			if (UnicodeHelpers.IsSupplementaryCodePoint(unicodeScalar))
			{
				UnicodeHelpers.GetUtf16SurrogatePairFromAstralScalarValue(unicodeScalar, out var highSurrogate, out var lowSurrogate);
				if (TryWriteEncodedSingleCharacter(highSurrogate, buffer, length, out var numberOfCharactersWritten2) && TryWriteEncodedSingleCharacter(lowSurrogate, buffer + numberOfCharactersWritten2, length - numberOfCharactersWritten2, out numberOfCharactersWritten))
				{
					numberOfCharactersWritten += numberOfCharactersWritten2;
					return true;
				}
				numberOfCharactersWritten = 0;
				return false;
			}
			return TryWriteEncodedSingleCharacter(unicodeScalar, buffer, length, out numberOfCharactersWritten);
		}

		private unsafe static bool TryWriteEncodedSingleCharacter(int unicodeScalar, char* buffer, int length, out int numberOfCharactersWritten)
		{
			if (length < 6)
			{
				numberOfCharactersWritten = 0;
				return false;
			}
			*buffer = '\\';
			buffer++;
			*buffer = 'u';
			buffer++;
			*buffer = HexUtil.Int32LsbToHexDigit(unicodeScalar >> 12);
			buffer++;
			*buffer = HexUtil.Int32LsbToHexDigit((int)((long)(unicodeScalar >> 8) & 0xFL));
			buffer++;
			*buffer = HexUtil.Int32LsbToHexDigit((int)((long)(unicodeScalar >> 4) & 0xFL));
			buffer++;
			*buffer = HexUtil.Int32LsbToHexDigit((int)((long)unicodeScalar & 0xFL));
			numberOfCharactersWritten = 6;
			return true;
		}
	}
	public abstract class UrlEncoder : TextEncoder
	{
		public static UrlEncoder Default => DefaultUrlEncoder.Singleton;

		public static UrlEncoder Create(TextEncoderSettings settings)
		{
			return new DefaultUrlEncoder(settings);
		}

		public static UrlEncoder Create(params UnicodeRange[] allowedRanges)
		{
			return new DefaultUrlEncoder(allowedRanges);
		}
	}
	internal sealed class DefaultUrlEncoder : UrlEncoder
	{
		private AllowedCharactersBitmap _allowedCharacters;

		internal static readonly DefaultUrlEncoder Singleton = new DefaultUrlEncoder(new TextEncoderSettings(UnicodeRanges.BasicLatin));

		public override int MaxOutputCharactersPerInputCharacter => 12;

		public DefaultUrlEncoder(TextEncoderSettings filter)
		{
			if (filter == null)
			{
				throw new ArgumentNullException("filter");
			}
			_allowedCharacters = filter.GetAllowedCharacters();
			_allowedCharacters.ForbidUndefinedCharacters();
			DefaultHtmlEncoder.ForbidHtmlCharacters(_allowedCharacters);
			string text = " #%/:=?[\\]^`{|}";
			foreach (char character in text)
			{
				_allowedCharacters.ForbidCharacter(character);
			}
			for (int j = 0; j < 16; j++)
			{
				_allowedCharacters.ForbidCharacter((char)(0xFFF0 | j));
			}
		}

		public DefaultUrlEncoder(params UnicodeRange[] allowedRanges)
			: this(new TextEncoderSettings(allowedRanges))
		{
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public override bool WillEncode(int unicodeScalar)
		{
			if (UnicodeHelpers.IsSupplementaryCodePoint(unicodeScalar))
			{
				return true;
			}
			return !_allowedCharacters.IsUnicodeScalarAllowed(unicodeScalar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe override int FindFirstCharacterToEncode(char* text, int textLength)
		{
			if (text == null)
			{
				throw new ArgumentNullException("text");
			}
			return _allowedCharacters.FindFirstCharacterToEncode(text, textLength);
		}

		public unsafe override bool TryEncodeUnicodeScalar(int unicodeScalar, char* buffer, int bufferLength, out int numberOfCharactersWritten)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException("buffer");
			}
			if (!WillEncode(unicodeScalar))
			{
				return TextEncoder.TryWriteScalarAsChar(unicodeScalar, buffer, bufferLength, out numberOfCharactersWritten);
			}
			numberOfCharactersWritten = 0;
			uint num = (uint)UnicodeHelpers.GetUtf8RepresentationForScalarValue((uint)unicodeScalar);
			do
			{
				HexUtil.ByteToHexDigits((byte)num, out var firstHexChar, out var secondHexChar);
				if (numberOfCharactersWritten + 3 > bufferLength)
				{
					numberOfCharactersWritten = 0;
					return false;
				}
				*buffer = '%';
				buffer++;
				*buffer = firstHexChar;
				buffer++;
				*buffer = secondHexChar;
				buffer++;
				numberOfCharactersWritten += 3;
			}
			while ((num >>= 8) != 0);
			return true;
		}
	}
}
namespace System.IO
{
	internal static class TextWriterExtensions
	{
		public static void WritePartialString(this TextWriter writer, string value, int offset, int count)
		{
			if (offset == 0 && count == value.Length)
			{
				writer.Write(value);
				return;
			}
			ReadOnlySpan<char> readOnlySpan = MemoryExtensions.AsSpan(value, offset, count);
			char[] array = ArrayPool<char>.Shared.Rent(readOnlySpan.Length);
			readOnlySpan.CopyTo(array);
			writer.Write(array, 0, readOnlySpan.Length);
			ArrayPool<char>.Shared.Return(array);
		}
	}
}
